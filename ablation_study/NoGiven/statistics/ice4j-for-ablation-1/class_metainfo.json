[{"uris": "src/test/java/org/ice4j/TestExecutionListener.java.TestExecutionListener", "name": "TestExecutionListener", "file_path": "src/test/java/org/ice4j/TestExecutionListener.java", "superclasses": "", "methods": ["[void]beforeAll()", "[]TestExecutionListener()", "[void]executionStarted(TestIdentifier)"], "method_uris": ["src/test/java/org/ice4j/TestExecutionListener.java.TestExecutionListener.[void]beforeAll()", "src/test/java/org/ice4j/TestExecutionListener.java.TestExecutionListener.[]TestExecutionListener()", "src/test/java/org/ice4j/TestExecutionListener.java.TestExecutionListener.[void]executionStarted(TestIdentifier)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TestExecutionListener implements org.junit.platform.launcher.TestExecutionListener {\n    private static boolean initialized = false;\n\n    private static void beforeAll()\n    {\n        // Disable config caching.\n        MetaconfigSettings.Companion.setCacheEnabled(false);\n    }\n\n    public TestExecutionListener()\n    {}\n\n    @Override\n    public void executionStarted(TestIdentifier testIdentifier)\n    {\n        synchronized (TestExecutionListener.class)\n        {\n            if (!initialized)\n            {\n                beforeAll();\n                initialized = true;\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static boolean initialized = false;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "boolean", "name": "initialized = false", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/MsgFixture.java.MsgFixture", "name": "MsgFixture", "file_path": "src/test/java/org/ice4j/MsgFixture.java", "superclasses": "", "methods": [], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class MsgFixture\n{\n    //---------------------- Attributes ---------------------------------------\n    public static final char ADDRESS_ATTRIBUTE_PORT = 1904;\n    public static final byte[] ADDRESS_ATTRIBUTE_ADDRESS = new byte[]{(byte)130, 79, (byte)156, (byte)137};\n    public static final byte[] ADDRESS_ATTRIBUTE_ADDRESS_V6 =\n        new byte[]{0x20,       0x01,       0x06,       0x60,\n                   0x47,       0x11,       0x11,       0x01,\n                   0x02,       0x30,       0x05, (byte)0xff,\n                   (byte)0xfe, 0x1a, (byte)0x80,       0x5f};\n\n    public byte[] mappedAddress = new byte[]\n        {0x00,       0x01,       0x00,       0x08, //Type, Length\n         0x00,       0x01,       0x07,       0x70, //00 Family Port(1904)\n         (byte)0x82, 0x4f, (byte)0x9c, (byte)0x89  //IP Address 130.79.156.137\n        };//\n    public byte[] mappedAddressv6 = new byte[]\n        {0x00,       0x01,       0x00,       0x14, //Type, Length\n         0x00,       0x02,       0x07,       0x70, //00 Family Port(1904)\n         0x20,       0x01,       0x06,       0x60,\n         0x47,       0x11,       0x11,       0x01,\n         0x02,       0x30,       0x05, (byte)0xff,\n         (byte)0xfe, 0x1a, (byte)0x80,       0x5f//IPv6 Address\n    };\n\n    public byte[] unknownOptionalAttribute = new byte[]\n        {(byte)0x80, 0x38,       0x00,       0x10, //Type, Length\n         (byte)0x82, 0x4f, (byte)0x9c, (byte)0x89,  //random stuff\n               0x00, 0x01,       0x07,       0x70,  //random stuff\n               0x00, 0x01,       0x07,       0x70,  //random stuff\n         (byte)0x82, 0x4f, (byte)0x9c, (byte)0x89   //random stuff\n        };//\n\n    public char optionalAttributeType = (char)0x8038;\n    public static final char ADDRESS_ATTRIBUTE_PORT_2 = 3478;\n    public static final byte[] ADDRESS_ATTRIBUTE_ADDRESS_2 = new byte[]{69, 0, (byte)208, 27};\n    public static final byte[] ADDRESS_ATTRIBUTE_ADDRESS_2_V6 =\n        new byte[]{0x20,       0x01,       0x06,       0x60,\n                   0x47,       0x11,       0x11,       0x01,\n                   0x02,       0x30,       0x55, (byte)0xff,\n                   (byte)0xfe, 0x1a, (byte)0x82,       0x5f};\n\n    public static final char ADDRESS_ATTRIBUTE_PORT_3 = 3479;\n    public static final byte[] ADDRESS_ATTRIBUTE_ADDRESS_3 = new byte[]{69, 0, (byte)209, 22};\n    public static final byte[] ADDRESS_ATTRIBUTE_ADDRESS_3_V6 =\n        new byte[]{0x20,       0x01,       0x06,       0x60,\n                   0x47,       0x11,       0x11,       0x01,\n                   0x02,       0x30,       0x05, (byte)0xff,\n                   (byte)0xfe, 0x1a, (byte)0x87,       0x5e};\n\n    public byte[] sourceAddress = new byte[]\n        {0x00,       0x04,       0x00,       0x08, //Type Length\n         0x00,       0x01,       0x0d, (byte)0x96, //00 Family Port(3478)\n         0x45,       0x00, (byte)0xd0,       0x1b  //IP Address 69.0.208.27\n        };\n    public byte[] changedAddress = new byte[]\n         {0x00,       0x05,       0x00,       0x08, //Type Length\n          0x00,       0x01,       0x0d, (byte)0x97, //00 Family Port(3479)\n          0x45,       0x00, (byte)0xd1,       0x16  //IP Address 69.0.209.22\n         };\n\n    /**\n     * Contains three invalid attribute ids. The 3d is repeated to keep an even\n     * number of reports.\n     */\n     public static final char UNKNOWN_ATTRIBUTES_1ST_ATT = 0x20;\n     public static final char UNKNOWN_ATTRIBUTES_2ND_ATT = 0x21;\n     public static final char UNKNOWN_ATTRIBUTES_3D_ATT  = 0x22;\n     public static final char UNKNOWN_ATTRIBUTES_CNT_DEC_TST   = 3;\n     public byte[] unknownAttsDecodeTestValue = new byte[]\n     {0x00,       0x0a,       0x00,       0x08, //Type Length\n      0x00,       0x20,       0x00,       0x21,\n      0x00,       0x22,       0x00,       0x22};\n\n\n    public static final char UNKNOWN_ATTRIBUTES_CNT_ENC_TST   = 2;\n    public byte[] unknownAttsEncodeExpectedResult = new byte[]\n    {0x00,        0x0a,       0x00,       0x04, //Type Length\n     0x00,      0x20,       0x00,       0x21};\n\n    //--- change request\n    public static final boolean CHANGE_IP_FLAG_1 = false;\n    public static final boolean CHANGE_PORT_FLAG_1 = false;\n    public byte[] chngReqTestValue1 = new byte[]\n    {0x00,        0x03,       0x00,       0x04,\n     0x00,        0x00,       0x00,       0x00};\n\n    public static final boolean CHANGE_IP_FLAG_2 = true;\n    public static final boolean CHANGE_PORT_FLAG_2 = true;\n    public byte[] chngReqTestValue2 = new byte[]\n    {0x00,        0x03,       0x00,       0x04,\n     0x00,        0x00,       0x00,       0x06};\n\n    //--- error code\n    public static final byte ERROR_CLASS = 4;\n    public static final byte ERROR_NUMBER = 20;\n    public static final char ERROR_CODE = 420;\n\n    public static final String REASON_PHRASE = \"Test error reason phrase.\";//odd length!\n\n    public byte[] errCodeTestValue = new byte[]\n    {0x00,        0x09,        0x00,        0x1D,\n     0x00,        0x00,        0x04,        0x14,\n     0x54,        0x65,        0x73,        0x74,\n     0x20,        0x65,        0x72,        0x72,\n     0x6F,        0x72,        0x20,        0x72,\n     0x65,        0x61,        0x73,        0x6F,\n     0x6E,        0x20,        0x70,        0x68,\n     0x72,        0x61,        0x73,        0x65,\n     0x2E,        0x00,        0x00,        0x00\n    };\n\n\n    public static final char REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V4 = 0X01;\n    public static final char REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6 = 0X02;\n    \n    public byte[] requestedAddressFamilyV4 = new byte[]\n        {0x00,       0x17,       0x00,       0x01, //Type, Length\n         0x01}; //family\n\n    public byte[] requestedAddressFamilyV6 = new byte[]\n        {0x00,       0x17,       0x00,       0x01, //Type, Length\n         0x02}; //family\n    \n    public static final int CONNECTION_ID = 0x5555; \n    public static final int CONNECTION_ID_2 = 0x2222; \n    \n    public byte[] connectionId = new byte[]\n        {0x00,       0x2a,       0x00,       0x04, //Type, Length\n         0x00,       0x00,       0x55,       0x55}; //connectionId\n\n    \n    //--------------------------- Messages ----------------------------------------\n    public static final byte[] TRANSACTION_ID =\n            new byte[]{\n                   0x05,       0x06,       0x07,       0x08, /* transaction ID */\n                   0x09,       0x10,       0x11,       0x12,\n                   0x13,       0x14,       0x15,       0x16\n        };\n\n    public byte[]          bindingRequest = new byte[]\n    {\n       0x00,       0x01,       0x00,       0x08, //STUN Msg Type  |  Msg Length\n       0x21,       0x12, (byte)0xA4,       0x42, //Transaction ID\n       0x05,       0x06,       0x07,       0x08,\n       0x09,       0x10,       0x11,       0x12,\n       0x13,       0x14,       0x15,       0x16,\n       0x00,       0x03,       0x00,       0x04,//Type(Change Request) Len\n       0x00,       0x00,       0x00,       0x00 //Don't change neither IP nor port\n    };\n\n    public byte[]          bindingRequest2 = new byte[]\n    {\n       0x00,       0x01,       0x00,       0x08, //STUN Msg Type  |  Msg Length\n       0x21,       0x12, (byte)0xA4,       0x42, //Transaction ID\n       0x06,       0x06,       0x07,       0x08,\n       0x09,       0x10,       0x11,       0x12,\n       0x13,       0x14,       0x15,       0x16,\n       0x00,       0x03,       0x00,       0x04,//Type(Change Request) Len\n       0x00,       0x00,       0x00,       0x00 //Don't change neither IP nor port\n    };\n\n    public byte[]          bindingRequest3 = new byte[]\n    {\n       0x00,       0x01,       0x00,       0x08, //STUN Msg Type  |  Msg Length\n       0x21,       0x12,       (byte)0xA4,       0x42, //Transaction ID\n       0x07,       0x06,       0x07,       0x08,\n       0x09,       0x10,       0x11,       0x12,\n       0x13,       0x14,       0x15,       0x16,\n       0x00,       0x03,       0x00,       0x04,//Type(Change Request) Len\n       0x00,       0x00,       0x00,       0x00 //Don't change neither IP nor port\n    };\n\n    public byte[]          bindingRequest4 = new byte[]\n    {\n       0x00,       0x01,       0x00,       0x08, //STUN Msg Type  |  Msg Length\n       0x21,       0x12,       (byte)0xA4,       0x42, //Transaction ID\n       0x08,       0x06,       0x07,       0x08,\n       0x09,       0x10,       0x11,       0x12,\n       0x13,       0x14,       0x15,       0x16,\n       0x00,       0x03,       0x00,       0x04,//Type(Change Request) Len\n       0x00,       0x00,       0x00,       0x00 //Don't change neither IP nor port\n    };\n\n    public byte[]        bindingResponse = new byte[]\n       {0x01,       0x01,       0x00,       0x24, //Type Length\n        0x21,       0x12,       (byte)0xA4,       0x42, //Transaction ID\n        0x05,       0x06,       0x07,       0x08,\n        0x09,       0x10,       0x11,       0x12,\n        0x13,       0x14,       0x15,       0x16,\n        0x00,       0x01,       0x00,       0x08, //AttType(MappedAddress) AttLength\n        0x00,       0x01,       0x07,       0x70, //00 Family Port(1904)\n  (byte)0x82,       0x4f, (byte)0x9c, (byte)0x89, //IP 130.79.156.37\n        0x00,       0x04,       0x00,       0x08, //AttType(Source Address) AttLen\n        0x00,       0x01,       0x0d, (byte)0x96, //00 Family Port(3478)\n        0x45,       0x00, (byte)0xd0,       0x1b, //IP 69.0.208.27\n        0x00,       0x05,       0x00,       0x08, //AttType(ChangedAddress)\n        0x00,       0x01,       0x0d, (byte)0x97, //00 Family Port(3479)\n        0x45,       0x00, (byte)0xd1,       0x16};//IP Address 69.0.209.22\n\n    public byte[] bindingErrorResponse = new byte[]\n        {\n        0x01,        0x11,        0x00,        0x24, //Type Length\n        0x21,        0x12,        (byte)0xA4,        0x42, //Transaction ID\n        0x0a,        0x77,        0x6f,        0x64,\n        0x58,        0x04, (byte) 0xae,        0x46,\n  (byte)0x85,        0x19, (byte) 0xcc,        0x3c,\n        0x00,        0x09,        0x00,        0x38,//Error Code Attribute\n        0x00,        0x00,        0x04,        0x14,//Reason Phrase\n        0x00,        0x54,        0x00,        0x65,\n        0x00,        0x73,        0x00,        0x74,\n        0x00,        0x20,        0x00,        0x65,\n        0x00,        0x72,        0x00,        0x72,\n        0x00,        0x6F,        0x00,        0x72,\n        0x00,        0x20,        0x00,        0x72,\n        0x00,        0x65,        0x00,        0x61,\n        0x00,        0x73,        0x00,        0x6F,\n        0x00,        0x6E,        0x00,        0x20,\n        0x00,        0x70,        0x00,        0x68,\n        0x00,        0x72,        0x00,        0x61,\n        0x00,        0x73,        0x00,        0x65,\n        0x00,        0x2E,        0x00,        0x20,//unknown attributes\n        0x00,        0x0a,        0x00,        0x08,//Type Length\n        0x00,        0x20,        0x00,        0x21,\n        0x00,        0x22,        0x00,        0x22\n        };\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final char ADDRESS_ATTRIBUTE_PORT = 1904;", "docstring": "---------------------- Attributes ---------------------------------------", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ADDRESS_ATTRIBUTE_PORT = 1904", "syntax_pass": true}, {"attribute_expression": "public static final byte[] ADDRESS_ATTRIBUTE_ADDRESS = new byte[]{(byte)130, 79, (byte)156, (byte)137};", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte[]", "name": "ADDRESS_ATTRIBUTE_ADDRESS = new byte[]{(byte)130, 79, (byte)156, (byte)137}", "syntax_pass": true}, {"attribute_expression": "public static final byte[] ADDRESS_ATTRIBUTE_ADDRESS_V6 =\n        new byte[]{0x20,       0x01,       0x06,       0x60,\n                   0x47,       0x11,       0x11,       0x01,\n                   0x02,       0x30,       0x05, (byte)0xff,\n                   (byte)0xfe, 0x1a, (byte)0x80,       0x5f};", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte[]", "name": "ADDRESS_ATTRIBUTE_ADDRESS_V6 =\n        new byte[]{0x20,       0x01,       0x06,       0x60,\n                   0x47,       0x11,       0x11,       0x01,\n                   0x02,       0x30,       0x05, (byte)0xff,\n                   (byte)0xfe, 0x1a, (byte)0x80,       0x5f}", "syntax_pass": true}, {"attribute_expression": "public byte[] mappedAddress = new byte[]\n        {0x00,       0x01,       0x00,       0x08, //Type, Length\n         0x00,       0x01,       0x07,       0x70, //00 Family Port(1904)\n         (byte)0x82, 0x4f, (byte)0x9c, (byte)0x89  //IP Address 130.79.156.137\n        };", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "mappedAddress = new byte[]\n        {0x00,       0x01,       0x00,       0x08, //Type, Length\n         0x00,       0x01,       0x07,       0x70, //00 Family Port(1904)\n         (byte)0x82, 0x4f, (byte)0x9c, (byte)0x89  //IP Address 130.79.156.137\n        }", "syntax_pass": true}, {"attribute_expression": "public byte[] mappedAddressv6 = new byte[]\n        {0x00,       0x01,       0x00,       0x14, //Type, Length\n         0x00,       0x02,       0x07,       0x70, //00 Family Port(1904)\n         0x20,       0x01,       0x06,       0x60,\n         0x47,       0x11,       0x11,       0x01,\n         0x02,       0x30,       0x05, (byte)0xff,\n         (byte)0xfe, 0x1a, (byte)0x80,       0x5f//IPv6 Address\n    };", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "mappedAddressv6 = new byte[]\n        {0x00,       0x01,       0x00,       0x14, //Type, Length\n         0x00,       0x02,       0x07,       0x70, //00 Family Port(1904)\n         0x20,       0x01,       0x06,       0x60,\n         0x47,       0x11,       0x11,       0x01,\n         0x02,       0x30,       0x05, (byte)0xff,\n         (byte)0xfe, 0x1a, (byte)0x80,       0x5f//IPv6 Address\n    }", "syntax_pass": true}, {"attribute_expression": "public byte[] unknownOptionalAttribute = new byte[]\n        {(byte)0x80, 0x38,       0x00,       0x10, //Type, Length\n         (byte)0x82, 0x4f, (byte)0x9c, (byte)0x89,  //random stuff\n               0x00, 0x01,       0x07,       0x70,  //random stuff\n               0x00, 0x01,       0x07,       0x70,  //random stuff\n         (byte)0x82, 0x4f, (byte)0x9c, (byte)0x89   //random stuff\n        };", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "unknownOptionalAttribute = new byte[]\n        {(byte)0x80, 0x38,       0x00,       0x10, //Type, Length\n         (byte)0x82, 0x4f, (byte)0x9c, (byte)0x89,  //random stuff\n               0x00, 0x01,       0x07,       0x70,  //random stuff\n               0x00, 0x01,       0x07,       0x70,  //random stuff\n         (byte)0x82, 0x4f, (byte)0x9c, (byte)0x89   //random stuff\n        }", "syntax_pass": true}, {"attribute_expression": "public char optionalAttributeType = (char)0x8038;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "char", "name": "optionalAttributeType = (char)0x8038", "syntax_pass": true}, {"attribute_expression": "public static final char ADDRESS_ATTRIBUTE_PORT_2 = 3478;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ADDRESS_ATTRIBUTE_PORT_2 = 3478", "syntax_pass": true}, {"attribute_expression": "public static final byte[] ADDRESS_ATTRIBUTE_ADDRESS_2 = new byte[]{69, 0, (byte)208, 27};", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte[]", "name": "ADDRESS_ATTRIBUTE_ADDRESS_2 = new byte[]{69, 0, (byte)208, 27}", "syntax_pass": true}, {"attribute_expression": "public static final byte[] ADDRESS_ATTRIBUTE_ADDRESS_2_V6 =\n        new byte[]{0x20,       0x01,       0x06,       0x60,\n                   0x47,       0x11,       0x11,       0x01,\n                   0x02,       0x30,       0x55, (byte)0xff,\n                   (byte)0xfe, 0x1a, (byte)0x82,       0x5f};", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte[]", "name": "ADDRESS_ATTRIBUTE_ADDRESS_2_V6 =\n        new byte[]{0x20,       0x01,       0x06,       0x60,\n                   0x47,       0x11,       0x11,       0x01,\n                   0x02,       0x30,       0x55, (byte)0xff,\n                   (byte)0xfe, 0x1a, (byte)0x82,       0x5f}", "syntax_pass": true}, {"attribute_expression": "public static final char ADDRESS_ATTRIBUTE_PORT_3 = 3479;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ADDRESS_ATTRIBUTE_PORT_3 = 3479", "syntax_pass": true}, {"attribute_expression": "public static final byte[] ADDRESS_ATTRIBUTE_ADDRESS_3 = new byte[]{69, 0, (byte)209, 22};", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte[]", "name": "ADDRESS_ATTRIBUTE_ADDRESS_3 = new byte[]{69, 0, (byte)209, 22}", "syntax_pass": true}, {"attribute_expression": "public static final byte[] ADDRESS_ATTRIBUTE_ADDRESS_3_V6 =\n        new byte[]{0x20,       0x01,       0x06,       0x60,\n                   0x47,       0x11,       0x11,       0x01,\n                   0x02,       0x30,       0x05, (byte)0xff,\n                   (byte)0xfe, 0x1a, (byte)0x87,       0x5e};", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte[]", "name": "ADDRESS_ATTRIBUTE_ADDRESS_3_V6 =\n        new byte[]{0x20,       0x01,       0x06,       0x60,\n                   0x47,       0x11,       0x11,       0x01,\n                   0x02,       0x30,       0x05, (byte)0xff,\n                   (byte)0xfe, 0x1a, (byte)0x87,       0x5e}", "syntax_pass": true}, {"attribute_expression": "public byte[] sourceAddress = new byte[]\n        {0x00,       0x04,       0x00,       0x08, //Type Length\n         0x00,       0x01,       0x0d, (byte)0x96, //00 Family Port(3478)\n         0x45,       0x00, (byte)0xd0,       0x1b  //IP Address 69.0.208.27\n        };", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "sourceAddress = new byte[]\n        {0x00,       0x04,       0x00,       0x08, //Type Length\n         0x00,       0x01,       0x0d, (byte)0x96, //00 Family Port(3478)\n         0x45,       0x00, (byte)0xd0,       0x1b  //IP Address 69.0.208.27\n        }", "syntax_pass": true}, {"attribute_expression": "public byte[] changedAddress = new byte[]\n         {0x00,       0x05,       0x00,       0x08, //Type Length\n          0x00,       0x01,       0x0d, (byte)0x97, //00 Family Port(3479)\n          0x45,       0x00, (byte)0xd1,       0x16  //IP Address 69.0.209.22\n         };", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "changedAddress = new byte[]\n         {0x00,       0x05,       0x00,       0x08, //Type Length\n          0x00,       0x01,       0x0d, (byte)0x97, //00 Family Port(3479)\n          0x45,       0x00, (byte)0xd1,       0x16  //IP Address 69.0.209.22\n         }", "syntax_pass": true}, {"attribute_expression": "public static final char UNKNOWN_ATTRIBUTES_1ST_ATT = 0x20;", "docstring": "\nContains three invalid attribute ids. The 3d is repeated to keep an even\nnumber of reports.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "UNKNOWN_ATTRIBUTES_1ST_ATT = 0x20", "syntax_pass": true}, {"attribute_expression": "public static final char UNKNOWN_ATTRIBUTES_2ND_ATT = 0x21;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "UNKNOWN_ATTRIBUTES_2ND_ATT = 0x21", "syntax_pass": true}, {"attribute_expression": "public static final char UNKNOWN_ATTRIBUTES_3D_ATT  = 0x22;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "UNKNOWN_ATTRIBUTES_3D_ATT  = 0x22", "syntax_pass": true}, {"attribute_expression": "public static final char UNKNOWN_ATTRIBUTES_CNT_DEC_TST   = 3;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "UNKNOWN_ATTRIBUTES_CNT_DEC_TST   = 3", "syntax_pass": true}, {"attribute_expression": "public byte[] unknownAttsDecodeTestValue = new byte[]\n     {0x00,       0x0a,       0x00,       0x08, //Type Length\n      0x00,       0x20,       0x00,       0x21,\n      0x00,       0x22,       0x00,       0x22};", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "unknownAttsDecodeTestValue = new byte[]\n     {0x00,       0x0a,       0x00,       0x08, //Type Length\n      0x00,       0x20,       0x00,       0x21,\n      0x00,       0x22,       0x00,       0x22}", "syntax_pass": true}, {"attribute_expression": "public static final char UNKNOWN_ATTRIBUTES_CNT_ENC_TST   = 2;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "UNKNOWN_ATTRIBUTES_CNT_ENC_TST   = 2", "syntax_pass": true}, {"attribute_expression": "public byte[] unknownAttsEncodeExpectedResult = new byte[]\n    {0x00,        0x0a,       0x00,       0x04, //Type Length\n     0x00,      0x20,       0x00,       0x21};", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "unknownAttsEncodeExpectedResult = new byte[]\n    {0x00,        0x0a,       0x00,       0x04, //Type Length\n     0x00,      0x20,       0x00,       0x21}", "syntax_pass": true}, {"attribute_expression": "public static final boolean CHANGE_IP_FLAG_1 = false;", "docstring": "--- change request", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "boolean", "name": "CHANGE_IP_FLAG_1 = false", "syntax_pass": true}, {"attribute_expression": "public static final boolean CHANGE_PORT_FLAG_1 = false;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "boolean", "name": "CHANGE_PORT_FLAG_1 = false", "syntax_pass": true}, {"attribute_expression": "public byte[] chngReqTestValue1 = new byte[]\n    {0x00,        0x03,       0x00,       0x04,\n     0x00,        0x00,       0x00,       0x00};", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "chngReqTestValue1 = new byte[]\n    {0x00,        0x03,       0x00,       0x04,\n     0x00,        0x00,       0x00,       0x00}", "syntax_pass": true}, {"attribute_expression": "public static final boolean CHANGE_IP_FLAG_2 = true;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "boolean", "name": "CHANGE_IP_FLAG_2 = true", "syntax_pass": true}, {"attribute_expression": "public static final boolean CHANGE_PORT_FLAG_2 = true;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "boolean", "name": "CHANGE_PORT_FLAG_2 = true", "syntax_pass": true}, {"attribute_expression": "public byte[] chngReqTestValue2 = new byte[]\n    {0x00,        0x03,       0x00,       0x04,\n     0x00,        0x00,       0x00,       0x06};", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "chngReqTestValue2 = new byte[]\n    {0x00,        0x03,       0x00,       0x04,\n     0x00,        0x00,       0x00,       0x06}", "syntax_pass": true}, {"attribute_expression": "public static final byte ERROR_CLASS = 4;", "docstring": "--- error code", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "ERROR_CLASS = 4", "syntax_pass": true}, {"attribute_expression": "public static final byte ERROR_NUMBER = 20;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "ERROR_NUMBER = 20", "syntax_pass": true}, {"attribute_expression": "public static final char ERROR_CODE = 420;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ERROR_CODE = 420", "syntax_pass": true}, {"attribute_expression": "public static final String REASON_PHRASE = \"Test error reason phrase.\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "REASON_PHRASE = \"Test error reason phrase.\"", "syntax_pass": true}, {"attribute_expression": "public byte[] errCodeTestValue = new byte[]\n    {0x00,        0x09,        0x00,        0x1D,\n     0x00,        0x00,        0x04,        0x14,\n     0x54,        0x65,        0x73,        0x74,\n     0x20,        0x65,        0x72,        0x72,\n     0x6F,        0x72,        0x20,        0x72,\n     0x65,        0x61,        0x73,        0x6F,\n     0x6E,        0x20,        0x70,        0x68,\n     0x72,        0x61,        0x73,        0x65,\n     0x2E,        0x00,        0x00,        0x00\n    };", "docstring": "odd length!", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "errCodeTestValue = new byte[]\n    {0x00,        0x09,        0x00,        0x1D,\n     0x00,        0x00,        0x04,        0x14,\n     0x54,        0x65,        0x73,        0x74,\n     0x20,        0x65,        0x72,        0x72,\n     0x6F,        0x72,        0x20,        0x72,\n     0x65,        0x61,        0x73,        0x6F,\n     0x6E,        0x20,        0x70,        0x68,\n     0x72,        0x61,        0x73,        0x65,\n     0x2E,        0x00,        0x00,        0x00\n    }", "syntax_pass": true}, {"attribute_expression": "public static final char REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V4 = 0X01;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V4 = 0X01", "syntax_pass": true}, {"attribute_expression": "public static final char REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6 = 0X02;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "REQUESTED_ADDRESS_FAMILY_ATTRIBUTE_V6 = 0X02", "syntax_pass": true}, {"attribute_expression": "public byte[] requestedAddressFamilyV4 = new byte[]\n        {0x00,       0x17,       0x00,       0x01, //Type, Length\n         0x01};", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "requestedAddressFamilyV4 = new byte[]\n        {0x00,       0x17,       0x00,       0x01, //Type, Length\n         0x01}", "syntax_pass": true}, {"attribute_expression": "public byte[] requestedAddressFamilyV6 = new byte[]\n        {0x00,       0x17,       0x00,       0x01, //Type, Length\n         0x02};", "docstring": "family", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "requestedAddressFamilyV6 = new byte[]\n        {0x00,       0x17,       0x00,       0x01, //Type, Length\n         0x02}", "syntax_pass": true}, {"attribute_expression": "public static final int CONNECTION_ID = 0x5555;", "docstring": "family", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "CONNECTION_ID = 0x5555", "syntax_pass": true}, {"attribute_expression": "public static final int CONNECTION_ID_2 = 0x2222;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "CONNECTION_ID_2 = 0x2222", "syntax_pass": true}, {"attribute_expression": "public byte[] connectionId = new byte[]\n        {0x00,       0x2a,       0x00,       0x04, //Type, Length\n         0x00,       0x00,       0x55,       0x55};", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "connectionId = new byte[]\n        {0x00,       0x2a,       0x00,       0x04, //Type, Length\n         0x00,       0x00,       0x55,       0x55}", "syntax_pass": true}, {"attribute_expression": "public static final byte[] TRANSACTION_ID =\n            new byte[]{\n                   0x05,       0x06,       0x07,       0x08, /* transaction ID */\n                   0x09,       0x10,       0x11,       0x12,\n                   0x13,       0x14,       0x15,       0x16\n        };", "docstring": "--------------------------- Messages ----------------------------------------", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte[]", "name": "TRANSACTION_ID =\n            new byte[]{\n                   0x05,       0x06,       0x07,       0x08, /* transaction ID */\n                   0x09,       0x10,       0x11,       0x12,\n                   0x13,       0x14,       0x15,       0x16\n        }", "syntax_pass": true}, {"attribute_expression": "public byte[]          bindingRequest = new byte[]\n    {\n       0x00,       0x01,       0x00,       0x08, //STUN Msg Type  |  Msg Length\n       0x21,       0x12, (byte)0xA4,       0x42, //Transaction ID\n       0x05,       0x06,       0x07,       0x08,\n       0x09,       0x10,       0x11,       0x12,\n       0x13,       0x14,       0x15,       0x16,\n       0x00,       0x03,       0x00,       0x04,//Type(Change Request) Len\n       0x00,       0x00,       0x00,       0x00 //Don't change neither IP nor port\n    };", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "bindingRequest = new byte[]\n    {\n       0x00,       0x01,       0x00,       0x08, //STUN Msg Type  |  Msg Length\n       0x21,       0x12, (byte)0xA4,       0x42, //Transaction ID\n       0x05,       0x06,       0x07,       0x08,\n       0x09,       0x10,       0x11,       0x12,\n       0x13,       0x14,       0x15,       0x16,\n       0x00,       0x03,       0x00,       0x04,//Type(Change Request) Len\n       0x00,       0x00,       0x00,       0x00 //Don't change neither IP nor port\n    }", "syntax_pass": true}, {"attribute_expression": "public byte[]          bindingRequest2 = new byte[]\n    {\n       0x00,       0x01,       0x00,       0x08, //STUN Msg Type  |  Msg Length\n       0x21,       0x12, (byte)0xA4,       0x42, //Transaction ID\n       0x06,       0x06,       0x07,       0x08,\n       0x09,       0x10,       0x11,       0x12,\n       0x13,       0x14,       0x15,       0x16,\n       0x00,       0x03,       0x00,       0x04,//Type(Change Request) Len\n       0x00,       0x00,       0x00,       0x00 //Don't change neither IP nor port\n    };", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "bindingRequest2 = new byte[]\n    {\n       0x00,       0x01,       0x00,       0x08, //STUN Msg Type  |  Msg Length\n       0x21,       0x12, (byte)0xA4,       0x42, //Transaction ID\n       0x06,       0x06,       0x07,       0x08,\n       0x09,       0x10,       0x11,       0x12,\n       0x13,       0x14,       0x15,       0x16,\n       0x00,       0x03,       0x00,       0x04,//Type(Change Request) Len\n       0x00,       0x00,       0x00,       0x00 //Don't change neither IP nor port\n    }", "syntax_pass": true}, {"attribute_expression": "public byte[]          bindingRequest3 = new byte[]\n    {\n       0x00,       0x01,       0x00,       0x08, //STUN Msg Type  |  Msg Length\n       0x21,       0x12,       (byte)0xA4,       0x42, //Transaction ID\n       0x07,       0x06,       0x07,       0x08,\n       0x09,       0x10,       0x11,       0x12,\n       0x13,       0x14,       0x15,       0x16,\n       0x00,       0x03,       0x00,       0x04,//Type(Change Request) Len\n       0x00,       0x00,       0x00,       0x00 //Don't change neither IP nor port\n    };", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "bindingRequest3 = new byte[]\n    {\n       0x00,       0x01,       0x00,       0x08, //STUN Msg Type  |  Msg Length\n       0x21,       0x12,       (byte)0xA4,       0x42, //Transaction ID\n       0x07,       0x06,       0x07,       0x08,\n       0x09,       0x10,       0x11,       0x12,\n       0x13,       0x14,       0x15,       0x16,\n       0x00,       0x03,       0x00,       0x04,//Type(Change Request) Len\n       0x00,       0x00,       0x00,       0x00 //Don't change neither IP nor port\n    }", "syntax_pass": true}, {"attribute_expression": "public byte[]          bindingRequest4 = new byte[]\n    {\n       0x00,       0x01,       0x00,       0x08, //STUN Msg Type  |  Msg Length\n       0x21,       0x12,       (byte)0xA4,       0x42, //Transaction ID\n       0x08,       0x06,       0x07,       0x08,\n       0x09,       0x10,       0x11,       0x12,\n       0x13,       0x14,       0x15,       0x16,\n       0x00,       0x03,       0x00,       0x04,//Type(Change Request) Len\n       0x00,       0x00,       0x00,       0x00 //Don't change neither IP nor port\n    };", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "bindingRequest4 = new byte[]\n    {\n       0x00,       0x01,       0x00,       0x08, //STUN Msg Type  |  Msg Length\n       0x21,       0x12,       (byte)0xA4,       0x42, //Transaction ID\n       0x08,       0x06,       0x07,       0x08,\n       0x09,       0x10,       0x11,       0x12,\n       0x13,       0x14,       0x15,       0x16,\n       0x00,       0x03,       0x00,       0x04,//Type(Change Request) Len\n       0x00,       0x00,       0x00,       0x00 //Don't change neither IP nor port\n    }", "syntax_pass": true}, {"attribute_expression": "public byte[]        bindingResponse = new byte[]\n       {0x01,       0x01,       0x00,       0x24, //Type Length\n        0x21,       0x12,       (byte)0xA4,       0x42, //Transaction ID\n        0x05,       0x06,       0x07,       0x08,\n        0x09,       0x10,       0x11,       0x12,\n        0x13,       0x14,       0x15,       0x16,\n        0x00,       0x01,       0x00,       0x08, //AttType(MappedAddress) AttLength\n        0x00,       0x01,       0x07,       0x70, //00 Family Port(1904)\n  (byte)0x82,       0x4f, (byte)0x9c, (byte)0x89, //IP 130.79.156.37\n        0x00,       0x04,       0x00,       0x08, //AttType(Source Address) AttLen\n        0x00,       0x01,       0x0d, (byte)0x96, //00 Family Port(3478)\n        0x45,       0x00, (byte)0xd0,       0x1b, //IP 69.0.208.27\n        0x00,       0x05,       0x00,       0x08, //AttType(ChangedAddress)\n        0x00,       0x01,       0x0d, (byte)0x97, //00 Family Port(3479)\n        0x45,       0x00, (byte)0xd1,       0x16};", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "bindingResponse = new byte[]\n       {0x01,       0x01,       0x00,       0x24, //Type Length\n        0x21,       0x12,       (byte)0xA4,       0x42, //Transaction ID\n        0x05,       0x06,       0x07,       0x08,\n        0x09,       0x10,       0x11,       0x12,\n        0x13,       0x14,       0x15,       0x16,\n        0x00,       0x01,       0x00,       0x08, //AttType(MappedAddress) AttLength\n        0x00,       0x01,       0x07,       0x70, //00 Family Port(1904)\n  (byte)0x82,       0x4f, (byte)0x9c, (byte)0x89, //IP 130.79.156.37\n        0x00,       0x04,       0x00,       0x08, //AttType(Source Address) AttLen\n        0x00,       0x01,       0x0d, (byte)0x96, //00 Family Port(3478)\n        0x45,       0x00, (byte)0xd0,       0x1b, //IP 69.0.208.27\n        0x00,       0x05,       0x00,       0x08, //AttType(ChangedAddress)\n        0x00,       0x01,       0x0d, (byte)0x97, //00 Family Port(3479)\n        0x45,       0x00, (byte)0xd1,       0x16}", "syntax_pass": true}, {"attribute_expression": "public byte[] bindingErrorResponse = new byte[]\n        {\n        0x01,        0x11,        0x00,        0x24, //Type Length\n        0x21,        0x12,        (byte)0xA4,        0x42, //Transaction ID\n        0x0a,        0x77,        0x6f,        0x64,\n        0x58,        0x04, (byte) 0xae,        0x46,\n  (byte)0x85,        0x19, (byte) 0xcc,        0x3c,\n        0x00,        0x09,        0x00,        0x38,//Error Code Attribute\n        0x00,        0x00,        0x04,        0x14,//Reason Phrase\n        0x00,        0x54,        0x00,        0x65,\n        0x00,        0x73,        0x00,        0x74,\n        0x00,        0x20,        0x00,        0x65,\n        0x00,        0x72,        0x00,        0x72,\n        0x00,        0x6F,        0x00,        0x72,\n        0x00,        0x20,        0x00,        0x72,\n        0x00,        0x65,        0x00,        0x61,\n        0x00,        0x73,        0x00,        0x6F,\n        0x00,        0x6E,        0x00,        0x20,\n        0x00,        0x70,        0x00,        0x68,\n        0x00,        0x72,        0x00,        0x61,\n        0x00,        0x73,        0x00,        0x65,\n        0x00,        0x2E,        0x00,        0x20,//unknown attributes\n        0x00,        0x0a,        0x00,        0x08,//Type Length\n        0x00,        0x20,        0x00,        0x21,\n        0x00,        0x22,        0x00,        0x22\n        };", "docstring": "IP Address 69.0.209.22", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "byte[]", "name": "bindingErrorResponse = new byte[]\n        {\n        0x01,        0x11,        0x00,        0x24, //Type Length\n        0x21,        0x12,        (byte)0xA4,        0x42, //Transaction ID\n        0x0a,        0x77,        0x6f,        0x64,\n        0x58,        0x04, (byte) 0xae,        0x46,\n  (byte)0x85,        0x19, (byte) 0xcc,        0x3c,\n        0x00,        0x09,        0x00,        0x38,//Error Code Attribute\n        0x00,        0x00,        0x04,        0x14,//Reason Phrase\n        0x00,        0x54,        0x00,        0x65,\n        0x00,        0x73,        0x00,        0x74,\n        0x00,        0x20,        0x00,        0x65,\n        0x00,        0x72,        0x00,        0x72,\n        0x00,        0x6F,        0x00,        0x72,\n        0x00,        0x20,        0x00,        0x72,\n        0x00,        0x65,        0x00,        0x61,\n        0x00,        0x73,        0x00,        0x6F,\n        0x00,        0x6E,        0x00,        0x20,\n        0x00,        0x70,        0x00,        0x68,\n        0x00,        0x72,        0x00,        0x61,\n        0x00,        0x73,        0x00,        0x65,\n        0x00,        0x2E,        0x00,        0x20,//unknown attributes\n        0x00,        0x0a,        0x00,        0x08,//Type Length\n        0x00,        0x20,        0x00,        0x21,\n        0x00,        0x22,        0x00,        0x22\n        }", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer", "name": "ResponseSequenceServer", "file_path": "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java", "superclasses": "", "methods": ["[]ResponseSequenceServer(StunStack,TransportAddress)", "[void]start()", "[void]shutDown()", "[void]addMessage(Response)", "[void]processRequest(StunMessageEvent)", "[String]toString()"], "method_uris": ["src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer.[]ResponseSequenceServer(StunStack,TransportAddress)", "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer.[void]start()", "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer.[void]shutDown()", "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer.[void]addMessage(Response)", "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer.[void]processRequest(StunMessageEvent)", "src/test/java/org/ice4j/stunclient/ResponseSequenceServer.java.ResponseSequenceServer.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nThis class implements a programmable STUN server that sends predefined\nsequences of responses. It may be used to test whether a STUN client\nbehaves correctly in different use cases.\n\n@author Emil Ivov\n", "original_string": "public class ResponseSequenceServer\n    implements RequestListener\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>ResponseSequenceServer</tt> class and\n     * its instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(ResponseSequenceServer.class.getName());\n\n    /**\n     * The sequence of responses to send.\n     */\n    private Vector<Object> messageSequence = new Vector<>();\n\n    /**\n     * The <tt>StunStack</tt> used by this instance for the purposes of STUN\n     * communication.\n     */\n    private final StunStack stunStack;\n\n    private TransportAddress serverAddress = null;\n    private IceSocketWrapper localSocket = null;\n\n    /**\n     * Initializes a new <tt>ResponseSequenceServer</tt> instance with a\n     * specific <tt>StunStack</tt> to be used for the purposes of STUN\n     * communication.\n     *\n     * @param stunStack the <tt>StunStack</tt> to be used by the new instance\n     * for the purposes of STUN communication\n     * @param bindAddress\n     */\n    public ResponseSequenceServer(\n            StunStack stunStack,\n            TransportAddress bindAddress)\n    {\n        this.stunStack = stunStack;\n        this.serverAddress = bindAddress;\n    }\n\n    /**\n     * Initializes the underlying stack\n     * @throws StunException if something else fails\n     * @throws IOException if we fail to bind a local socket.\n     */\n    public void start()\n        throws IOException, StunException\n    {\n        localSocket = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(serverAddress));\n\n        stunStack.addSocket(localSocket);\n        stunStack.addRequestListener(serverAddress, this);\n\n    }\n\n    /**\n     * Resets the server (deletes the sequence and stops the stack)\n     */\n    public void shutDown()\n    {\n        stunStack.removeSocket(serverAddress);\n        messageSequence.removeAllElements();\n        localSocket.close();\n    }\n\n    /**\n     * Adds the specified response to this sequence or marks a pause (i.e. do\n     * not respond) if response is null.\n     * @param response the response to add or null to mark a pause\n     */\n    public void addMessage(Response response)\n    {\n        if (response == null)\n        {\n            //leave a mark to skip a message\n            messageSequence.add(false);\n        }\n        else\n            messageSequence.add(response);\n    }\n\n    /**\n     * Completely ignores the event that is passed and just sends the next\n     * message from the sequence - or does nothing if there's something\n     * different from a Response on the current position.\n     * @param evt the event being dispatched\n     */\n    public void processRequest(StunMessageEvent evt)\n    {\n        if(messageSequence.isEmpty())\n            return;\n        Object obj = messageSequence.remove(0);\n\n        if( !(obj instanceof Response) )\n            return;\n\n        Response res = (Response)obj;\n\n        try\n        {\n            stunStack.sendResponse(evt.getMessage().getTransactionID(),\n                res, serverAddress, evt.getRemoteAddress());\n        }\n        catch (Exception ex)\n        {\n            logger.log(Level.WARNING, \"failed to send a response\", ex);\n        }\n\n    }\n\n    /**\n     * Returns a string representation of this Server.\n     * @return the ip address and port where this server is bound\n     */\n    public String toString()\n    {\n        return serverAddress == null?\"null\":serverAddress.toString();\n    }\n\n}", "super_interfaces": ["RequestListener"], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(ResponseSequenceServer.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>ResponseSequenceServer</tt> class and\nits instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(ResponseSequenceServer.class.getName())", "syntax_pass": true}, {"attribute_expression": "private Vector<Object> messageSequence = new Vector<>();", "docstring": "\nThe sequence of responses to send.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Vector<Object>", "name": "messageSequence = new Vector<>()", "syntax_pass": true}, {"attribute_expression": "private final StunStack stunStack;", "docstring": "\nThe <tt>StunStack</tt> used by this instance for the purposes of STUN\ncommunication.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StunStack", "name": "stunStack", "syntax_pass": true}, {"attribute_expression": "private TransportAddress serverAddress = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransportAddress", "name": "serverAddress = null", "syntax_pass": true}, {"attribute_expression": "private IceSocketWrapper localSocket = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IceSocketWrapper", "name": "localSocket = null", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector", "name": "DatagramCollector", "file_path": "src/test/java/org/ice4j/stack/DatagramCollector.java", "superclasses": "", "methods": ["[]DatagramCollector()", "[void]run()", "[void]startListening(DatagramSocket)", "[void]waitForPacket()", "[void]waitForPacket(long)", "[DatagramPacket]collectPacket()"], "method_uris": ["src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector.[]DatagramCollector()", "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector.[void]run()", "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector.[void]startListening(DatagramSocket)", "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector.[void]waitForPacket()", "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector.[void]waitForPacket(long)", "src/test/java/org/ice4j/stack/DatagramCollector.java.DatagramCollector.[DatagramPacket]collectPacket()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DatagramCollector\n    implements Runnable\n{\n    DatagramPacket receivedPacket = null;\n    DatagramSocket sock           = null;\n\n    boolean packetReceived = false;\n\n    public DatagramCollector()\n    {\n    }\n\n    public void run()\n    {\n        try\n        {\n            // The 'receive' method synchronized the packet, hence the 'getData()' (also synchronized) will block\n            // on this anyway even after 'waitForPacket' and 'collectPacket' calls.\n            sock.receive(receivedPacket);\n\n            synchronized (this)\n            {\n                packetReceived = true;\n                notifyAll();\n            }\n\n        }\n        catch (IOException ex)\n        {\n            receivedPacket = null;\n        }\n\n    }\n\n    public void startListening(DatagramSocket sock)\n    {\n        this.sock = sock;\n        receivedPacket = new DatagramPacket(new byte[4096], 4096);\n\n        new Thread(this).start();\n    }\n\n    public void waitForPacket()\n    {\n        waitForPacket(50);\n    }\n\n    public void waitForPacket(long timeoutMillis)\n    {\n        synchronized(this)\n        {\n            if(packetReceived)\n                return;\n\n            try\n            {\n                wait(timeoutMillis);\n            }\n            catch (InterruptedException e)\n            {\n                e.printStackTrace();\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n\n    public DatagramPacket collectPacket()\n    {\n        //recycle\n        DatagramPacket returnValue = receivedPacket;\n        receivedPacket = null;\n        sock           = null;\n        packetReceived = false;\n\n        //return\n        return returnValue;\n    }\n}", "super_interfaces": ["Runnable"], "fields": [{"attribute_expression": "DatagramPacket receivedPacket = null;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "DatagramPacket", "name": "receivedPacket = null", "syntax_pass": true}, {"attribute_expression": "DatagramSocket sock           = null;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "DatagramSocket", "name": "sock           = null", "syntax_pass": true}, {"attribute_expression": "boolean packetReceived = false;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "packetReceived = false", "syntax_pass": true}]}, {"uris": "src/test/java/org/ice4j/pseudotcp/MultiThreadSupportTest.java.MultiThreadSupportTest", "name": "MultiThreadSupportTest", "file_path": "src/test/java/org/ice4j/pseudotcp/MultiThreadSupportTest.java", "superclasses": "", "methods": ["[void]uncaughtException(Thread,Throwable)", "[boolean]assert_wait_until(BooleanSupplier,long)"], "method_uris": ["src/test/java/org/ice4j/pseudotcp/MultiThreadSupportTest.java.MultiThreadSupportTest.[void]uncaughtException(Thread,Throwable)", "src/test/java/org/ice4j/pseudotcp/MultiThreadSupportTest.java.MultiThreadSupportTest.[boolean]assert_wait_until(BooleanSupplier,long)"], "overrides": null, "attributes": [], "class_docstring": "\nThis class enables multi thread tests where main thread waits in loop for\nspecified condition to be met, while others perform some operations. For\nexample until the connection is established or closed. It also registers\ndefault uncaught exception handler to catch exceptions from other threads.\n<p>\nCondition checks are passed as IWaitUntilDone interface.\n\n@author Pawel Domas\n", "original_string": "public class MultiThreadSupportTest implements Thread.UncaughtExceptionHandler\n{\n    private volatile Throwable testError;\n\n    private volatile Thread errorThread;\n\n    private final Object testLock = new Object();\n\n    @Override\n    public void uncaughtException(Thread t, Throwable e)\n    {\n        synchronized (testLock)\n        {\n            testError = e;\n            errorThread = t;\n            testLock.notifyAll();\n        }\n    }\n\n    private static final long ASSERT_WAIT_INTERVAL = 100;\n\n    protected boolean assert_wait_until(BooleanSupplier wait, long timeoutMs)\n    {\n        long timeoutNanos = TimeUnit.MILLISECONDS.toNanos(timeoutMs);\n        try\n        {\n            long start = System.nanoTime();\n            while (!wait.getAsBoolean() && (System.nanoTime() - start) < timeoutNanos)\n            {\n                synchronized (testLock)\n                {\n                    testLock.wait(ASSERT_WAIT_INTERVAL);\n                    if (testError != null)\n                    {\n                        testError.printStackTrace();\n                        fail(\"Error in thread: \" + errorThread.getName() + \" : \"\n                            + testError.getMessage());\n                    }\n                }\n            }\n            return wait.getAsBoolean();\n        }\n        catch (InterruptedException ex)\n        {\n            ex.printStackTrace();\n            fail(\"assert_wait - interrupted\");\n            //return is unreachable\n            return false;\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private volatile Throwable testError;", "docstring": "", "modifiers": "private volatile", "marker_annotations": [], "non_marker_annotations": ["private", "volatile"], "comments": [], "type": "Throwable", "name": "testError", "syntax_pass": true}, {"attribute_expression": "private volatile Thread errorThread;", "docstring": "", "modifiers": "private volatile", "marker_annotations": [], "non_marker_annotations": ["private", "volatile"], "comments": [], "type": "Thread", "name": "errorThread", "syntax_pass": true}, {"attribute_expression": "private final Object testLock = new Object();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "testLock = new Object()", "syntax_pass": true}, {"attribute_expression": "private static final long ASSERT_WAIT_INTERVAL = 100;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "ASSERT_WAIT_INTERVAL = 100", "syntax_pass": true}]}, {"uris": "src/test/java/test/MappingTest.java.MappingTest", "name": "MappingTest", "file_path": "src/test/java/test/MappingTest.java", "superclasses": "Ice", "methods": ["[void]main(String[])"], "method_uris": ["src/test/java/test/MappingTest.java.MappingTest.[void]main(String[])"], "overrides": null, "attributes": [], "class_docstring": "\nAn example of using the AWS Harvester.\n<p>\n@author Emil Ivov\n", "original_string": "public class MappingTest\n    extends Ice\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>TrickleIce</tt>\n     * class and its instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(TrickleIce.class.getName());\n\n    /**\n     * Runs a test application that creates an agent, attaches an AWS harvester\n     * as well as a few allocates streams, generates an SDP and dumps\n     * it on stdout\n     *\n     * @param args none currently handled\n     * @throws Throwable every now and then.\n     */\n    public static void main(String[] args) throws Throwable\n    {\n        //if configured, append a mapping harvester.\n        String localAddressStr = \"<your local IP here, e.g. 192.168.0.1>\";\n        String publicAddressStr = \"<your public IP here, e.g. 203.0.113.5>\";\n\n        TransportAddress localAddress;\n        TransportAddress publicAddress;\n\n        try\n        {\n            localAddress = new TransportAddress(localAddressStr, 9, Transport.UDP);\n            publicAddress = new TransportAddress(publicAddressStr, 9, Transport.UDP);\n\n            logger.info(\"Will append a NAT harvester for \" + localAddress + \"=>\" + publicAddress);\n\n        }\n        catch(Exception exc)\n        {\n            logger.info(\"Failed to create a NAT harvester for\"\n                        + \" local address=\" + localAddressStr\n                        + \" and public address=\" + publicAddressStr);\n            return;\n        }\n\n        MappingCandidateHarvester natHarvester = new StaticMappingCandidateHarvester(publicAddress, localAddress);\n\n        List<CandidateHarvester> harvesters = new ArrayList<>();\n        harvesters.add(natHarvester);\n\n        Agent localAgent = createAgent(2020, false, harvesters);\n        localAgent.setNominationStrategy(NominationStrategy.NOMINATE_HIGHEST_PRIO);\n\n        String localSDP = SdpUtils.createSDPDescription(localAgent);\n\n        //wait a bit so that the logger can stop dumping stuff:\n        Thread.sleep(500);\n\n        logger.info(\"=================== feed the following to the remote agent ===================\");\n        logger.info(\"\\n\" + localSDP);\n        logger.info(\"==============================================================================\\n\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(TrickleIce.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>TrickleIce</tt>\nclass and its instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(TrickleIce.class.getName())", "syntax_pass": true}]}, {"uris": "src/test/java/test/SdpUtils.java.SdpUtils", "name": "SdpUtils", "file_path": "src/test/java/test/SdpUtils.java", "superclasses": "", "methods": ["[String]createSDPDescription(Agent)", "[void]parseSDP(Agent,String)", "[RemoteCandidate]parseCandidate(Attribute,IceMediaStream)"], "method_uris": ["src/test/java/test/SdpUtils.java.SdpUtils.[String]createSDPDescription(Agent)", "src/test/java/test/SdpUtils.java.SdpUtils.[void]parseSDP(Agent,String)", "src/test/java/test/SdpUtils.java.SdpUtils.[RemoteCandidate]parseCandidate(Attribute,IceMediaStream)"], "overrides": null, "attributes": [], "class_docstring": "\nUtilities for manipulating SDP. Some of the utilities in this method <b>do\nnot</b> try to act smart and make a lot of assumptions (e.g. at least one\nmedia stream with at least one component) that may not always be true in real\nlife and lead to exceptions. Therefore, make sure you reread the code if\nreusing it in an application. It should be fine for the purposes of our ice4j\nexamples though.\n\n@author Emil Ivov\n", "original_string": "public class SdpUtils\n{\n    /**\n     * Creates a session description containing the streams from the specified\n     * <tt>agent</tt> using dummy codecs. This method is unlikely to be of use\n     * to integrating applications as they would likely just want to feed a\n     * {@link MediaDescription} and have it populated with all the necessary\n     * attributes.\n     *\n     * @param agent the {@link Agent} we'd like to generate.\n     *\n     * @return a {@link SessionDescription} representing <tt>agent</tt>'s\n     * streams.\n     *\n     * @throws Throwable on rainy days\n     */\n    public static String createSDPDescription(Agent agent) throws Throwable\n    {\n        SdpFactory factory = new NistSdpFactory();\n        SessionDescription sdess = factory.createSessionDescription();\n\n        IceSdpUtils.initSessionDescription(sdess, agent);\n\n        return sdess.toString();\n    }\n\n    /**\n     * Configures <tt>localAgent</tt> the the remote peer streams, components,\n     * and candidates specified in <tt>sdp</tt>\n     *\n     * @param localAgent the {@link Agent} that we'd like to configure.\n     *\n     * @param sdp the SDP string that the remote peer sent.\n     *\n     * @throws Exception for all sorts of reasons.\n     */\n    @SuppressWarnings(\"unchecked\") // jain-sdp legacy code.\n    public static void parseSDP(Agent localAgent, String sdp)\n        throws Exception\n    {\n        SdpFactory factory = new NistSdpFactory();\n        SessionDescription sdess = factory.createSessionDescription(sdp);\n\n        for(IceMediaStream stream : localAgent.getStreams())\n        {\n            stream.setRemotePassword(sdess.getAttribute(\"ice-pwd\"));\n            stream.setRemoteUfrag(sdess.getAttribute(\"ice-ufrag\"));\n        }\n\n        Connection globalConn = sdess.getConnection();\n        String globalConnAddr = null;\n        if(globalConn != null)\n            globalConnAddr = globalConn.getAddress();\n\n        Vector<MediaDescription> mdescs = sdess.getMediaDescriptions(true);\n\n        for (MediaDescription desc : mdescs)\n        {\n            String streamName = desc.getMedia().getMediaType();\n\n            IceMediaStream stream = localAgent.getStream(streamName);\n\n            if(stream == null)\n                continue;\n\n            Vector<Attribute> attributes = desc.getAttributes(true);\n            for (Attribute attribute : attributes)\n            {\n                if (attribute.getName().equals(CandidateAttribute.NAME))\n                    parseCandidate(attribute, stream);\n            }\n\n            //set default candidates\n            Connection streamConn = desc.getConnection();\n            String streamConnAddr = null;\n            if(streamConn != null)\n                streamConnAddr = streamConn.getAddress();\n            else\n                streamConnAddr = globalConnAddr;\n\n            int port = desc.getMedia().getMediaPort();\n\n            TransportAddress defaultRtpAddress =\n                new TransportAddress(streamConnAddr, port, Transport.UDP);\n\n            int rtcpPort = port + 1;\n            String rtcpAttributeValue = desc.getAttribute(\"rtcp\");\n\n            if (rtcpAttributeValue != null)\n                rtcpPort = Integer.parseInt(rtcpAttributeValue);\n\n            TransportAddress defaultRtcpAddress =\n                new TransportAddress(streamConnAddr, rtcpPort, Transport.UDP);\n\n            Component rtpComponent = stream.getComponent(Component.RTP);\n            Component rtcpComponent = stream.getComponent(Component.RTCP);\n\n            Candidate<?> defaultRtpCandidate\n                = rtpComponent.findRemoteCandidate(defaultRtpAddress);\n            rtpComponent.setDefaultRemoteCandidate(defaultRtpCandidate);\n\n            if(rtcpComponent != null)\n            {\n                Candidate<?> defaultRtcpCandidate\n                    = rtcpComponent.findRemoteCandidate(defaultRtcpAddress);\n                rtcpComponent.setDefaultRemoteCandidate(defaultRtcpCandidate);\n            }\n        }\n    }\n\n    /**\n     * Parses the <tt>attribute</tt>.\n     *\n     * @param attribute the attribute that we need to parse.\n     * @param stream the {@link IceMediaStream} that the candidate is supposed\n     * to belong to.\n     *\n     * @return a newly created {@link RemoteCandidate} matching the\n     * content of the specified <tt>attribute</tt> or <tt>null</tt> if the\n     * candidate belonged to a component we don't have.\n     */\n    private static RemoteCandidate parseCandidate(Attribute      attribute,\n                                                  IceMediaStream stream)\n    {\n        String value = null;\n\n        try{\n            value = attribute.getValue();\n        }catch (Throwable t){}//can't happen\n\n        StringTokenizer tokenizer = new StringTokenizer(value);\n\n        //XXX add exception handling.\n        String foundation = tokenizer.nextToken();\n        int componentID = Integer.parseInt( tokenizer.nextToken() );\n        Transport transport = Transport.parse(tokenizer.nextToken());\n        long priority = Long.parseLong(tokenizer.nextToken());\n        String address = tokenizer.nextToken();\n        int port = Integer.parseInt(tokenizer.nextToken());\n\n        TransportAddress transAddr\n            = new TransportAddress(address, port, transport);\n\n        tokenizer.nextToken(); //skip the \"typ\" String\n        CandidateType type = CandidateType.parse(tokenizer.nextToken());\n\n        Component component = stream.getComponent(componentID);\n\n        if(component == null)\n            return null;\n\n        // check if there's a related address property\n\n        RemoteCandidate relatedCandidate = null;\n        if (tokenizer.countTokens() >= 4)\n        {\n            tokenizer.nextToken(); // skip the raddr element\n            String relatedAddr = tokenizer.nextToken();\n            tokenizer.nextToken(); // skip the rport element\n            int relatedPort = Integer.parseInt(tokenizer.nextToken());\n\n            TransportAddress raddr = new TransportAddress(\n                            relatedAddr, relatedPort, Transport.UDP);\n\n            relatedCandidate = component.findRemoteCandidate(raddr);\n        }\n\n        RemoteCandidate cand = new RemoteCandidate(transAddr, component, type,\n                        foundation, priority, relatedCandidate);\n\n        component.addRemoteCandidate(cand);\n\n        return cand;\n    }\n\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/test/Ice.java.Ice", "name": "Ice", "file_path": "src/test/java/test/Ice.java", "superclasses": "", "methods": ["[void]main(String[])", "[void]transferRemoteCandidates(Agent,Agent)", "[void]transferRemoteCandidates(IceMediaStream,IceMediaStream)", "[void]transferRemoteCandidates(Component,Component)", "[Agent]createAgent(int)", "[Agent]createAgent(int,boolean)", "[Agent]createAgent(int,boolean,List<CandidateHarvester>)", "[IceMediaStream]createStream(int,String,Agent)"], "method_uris": ["src/test/java/test/Ice.java.Ice.[void]main(String[])", "src/test/java/test/Ice.java.Ice.[void]transferRemoteCandidates(Agent,Agent)", "src/test/java/test/Ice.java.Ice.[void]transferRemoteCandidates(IceMediaStream,IceMediaStream)", "src/test/java/test/Ice.java.Ice.[void]transferRemoteCandidates(Component,Component)", "src/test/java/test/Ice.java.Ice.[Agent]createAgent(int)", "src/test/java/test/Ice.java.Ice.[Agent]createAgent(int,boolean)", "src/test/java/test/Ice.java.Ice.[Agent]createAgent(int,boolean,List<CandidateHarvester>)", "src/test/java/test/Ice.java.Ice.[IceMediaStream]createStream(int,String,Agent)"], "overrides": null, "attributes": [{"original_string": "    public static final class IceProcessingListener\n        implements PropertyChangeListener\n    {\n        /**\n         * System.exit()s as soon as ICE processing enters a final state.\n         *\n         * @param evt the {@link PropertyChangeEvent} containing the old and new\n         * states of ICE processing.\n         */\n        public void propertyChange(PropertyChangeEvent evt)\n        {\n            long processingEndTime = System.currentTimeMillis();\n\n            Object iceProcessingState = evt.getNewValue();\n\n            logger.info(\n                    \"Agent entered the \" + iceProcessingState + \" state.\");\n            if(iceProcessingState == IceProcessingState.COMPLETED)\n            {\n                logger.info(\n                        \"Total ICE processing time: \"\n                            + (processingEndTime - startTime) + \"ms\");\n                Agent agent = (Agent)evt.getSource();\n                List<IceMediaStream> streams = agent.getStreams();\n\n                for(IceMediaStream stream : streams)\n                {\n                    String streamName = stream.getName();\n                    logger.info(\n                            \"Pairs selected for stream: \" + streamName);\n                    List<Component> components = stream.getComponents();\n\n                    for(Component cmp : components)\n                    {\n                        String cmpName = cmp.getName();\n                        logger.info(cmpName + \": \"\n                                        + cmp.getSelectedPair());\n                    }\n                }\n\n                logger.info(\"Printing the completed check lists:\");\n                for(IceMediaStream stream : streams)\n                {\n                    String streamName = stream.getName();\n                    logger.info(\"Check list for  stream: \" + streamName);\n                    //uncomment for a more verbose output\n                    logger.info(stream.getCheckList().toString());\n                }\n\n                logger.info(\"Total ICE processing time to completion: \"\n                    + (System.currentTimeMillis() - startTime));\n            }\n            else if(iceProcessingState == IceProcessingState.TERMINATED\n                    || iceProcessingState == IceProcessingState.FAILED)\n            {\n                /*\n                 * Though the process will be instructed to die, demonstrate\n                 * that Agent instances are to be explicitly prepared for\n                 * garbage collection.\n                 */\n                ((Agent) evt.getSource()).free();\n\n                logger.info(\"Total ICE processing time: \"\n                    + (System.currentTimeMillis() - startTime));\n                System.exit(0);\n            }\n        }\n    }", "definition": "    public static final class IceProcessingListener\n        implements PropertyChangeListener", "class_docstring": "\nThe listener that would end example execution once we enter the\ncompleted state.\n", "name": "IceProcessingListener", "super_interfaces": ["PropertyChangeListener"], "superclasses": "", "attributes": {"modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public void propertyChange(PropertyChangeEvent evt)\n        {\n            long processingEndTime = System.currentTimeMillis();\n\n            Object iceProcessingState = evt.getNewValue();\n\n            logger.info(\n                    \"Agent entered the \" + iceProcessingState + \" state.\");\n            if(iceProcessingState == IceProcessingState.COMPLETED)\n            {\n                logger.info(\n                        \"Total ICE processing time: \"\n                            + (processingEndTime - startTime) + \"ms\");\n                Agent agent = (Agent)evt.getSource();\n                List<IceMediaStream> streams = agent.getStreams();\n\n                for(IceMediaStream stream : streams)\n                {\n                    String streamName = stream.getName();\n                    logger.info(\n                            \"Pairs selected for stream: \" + streamName);\n                    List<Component> components = stream.getComponents();\n\n                    for(Component cmp : components)\n                    {\n                        String cmpName = cmp.getName();\n                        logger.info(cmpName + \": \"\n                                        + cmp.getSelectedPair());\n                    }\n                }\n\n                logger.info(\"Printing the completed check lists:\");\n                for(IceMediaStream stream : streams)\n                {\n                    String streamName = stream.getName();\n                    logger.info(\"Check list for  stream: \" + streamName);\n                    //uncomment for a more verbose output\n                    logger.info(stream.getCheckList().toString());\n                }\n\n                logger.info(\"Total ICE processing time to completion: \"\n                    + (System.currentTimeMillis() - startTime));\n            }\n            else if(iceProcessingState == IceProcessingState.TERMINATED\n                    || iceProcessingState == IceProcessingState.FAILED)\n            {\n                /*\n                 * Though the process will be instructed to die, demonstrate\n                 * that Agent instances are to be explicitly prepared for\n                 * garbage collection.\n                 */\n                ((Agent) evt.getSource()).free();\n\n                logger.info(\"Total ICE processing time: \"\n                    + (System.currentTimeMillis() - startTime));\n                System.exit(0);\n            }\n        }", "docstring": "\nSystem.exit()s as soon as ICE processing enters a final state.\n\n@param evt the {@link PropertyChangeEvent} containing the old and new\nstates of ICE processing.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "propertyChange", "params": [{"name": "evt", "type": "PropertyChangeEvent"}], "body": "        {\n            long processingEndTime = System.currentTimeMillis();\n\n            Object iceProcessingState = evt.getNewValue();\n\n            logger.info(\n                    \"Agent entered the \" + iceProcessingState + \" state.\");\n            if(iceProcessingState == IceProcessingState.COMPLETED)\n            {\n                logger.info(\n                        \"Total ICE processing time: \"\n                            + (processingEndTime - startTime) + \"ms\");\n                Agent agent = (Agent)evt.getSource();\n                List<IceMediaStream> streams = agent.getStreams();\n\n                for(IceMediaStream stream : streams)\n                {\n                    String streamName = stream.getName();\n                    logger.info(\n                            \"Pairs selected for stream: \" + streamName);\n                    List<Component> components = stream.getComponents();\n\n                    for(Component cmp : components)\n                    {\n                        String cmpName = cmp.getName();\n                        logger.info(cmpName + \": \"\n                                        + cmp.getSelectedPair());\n                    }\n                }\n\n                logger.info(\"Printing the completed check lists:\");\n                for(IceMediaStream stream : streams)\n                {\n                    String streamName = stream.getName();\n                    logger.info(\"Check list for  stream: \" + streamName);\n                    //uncomment for a more verbose output\n                    logger.info(stream.getCheckList().toString());\n                }\n\n                logger.info(\"Total ICE processing time to completion: \"\n                    + (System.currentTimeMillis() - startTime));\n            }\n            else if(iceProcessingState == IceProcessingState.TERMINATED\n                    || iceProcessingState == IceProcessingState.FAILED)\n            {\n                /*\n                 * Though the process will be instructed to die, demonstrate\n                 * that Agent instances are to be explicitly prepared for\n                 * garbage collection.\n                 */\n                ((Agent) evt.getSource()).free();\n\n                logger.info(\"Total ICE processing time: \"\n                    + (System.currentTimeMillis() - startTime));\n                System.exit(0);\n            }\n        }", "signature": "public void propertyChange(PropertyChangeEvent evt)"}]}], "class_docstring": "\nSimple ice4j testing scenario. The sample application would create and start\nboth agents and make one of them run checks against the other.\n\n@author Emil Ivov\n@author Lyubomir Marinov\n", "original_string": "public class Ice\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>Ice</tt>\n     * class and its instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(Ice.class.getName());\n\n    /**\n     * The indicator which determines whether the <tt>Ice</tt> application (i.e.\n     * the run-sample Ant target) is to start connectivity establishment of the\n     * remote peer (in addition to the connectivity establishment of the local\n     * agent which is always started, of course).\n     */\n    private static final boolean START_CONNECTIVITY_ESTABLISHMENT_OF_REMOTE_PEER\n        = false;\n\n    /**\n     * Start time for debugging purposes.\n     */\n    static long startTime;\n\n    /**\n     * Runs the test\n     * @param args command line arguments\n     *\n     * @throws Throwable if bad stuff happens.\n     */\n    public static void main(String[] args) throws Throwable\n    {\n        startTime = System.currentTimeMillis();\n\n        Agent localAgent = createAgent(9090, false);\n        localAgent.setNominationStrategy(\n                        NominationStrategy.NOMINATE_HIGHEST_PRIO);\n        Agent remotePeer = createAgent(6060, false);\n\n        localAgent.addStateChangeListener(new IceProcessingListener());\n\n        //let them fight ... fights forge character.\n        localAgent.setControlling(true);\n        remotePeer.setControlling(false);\n\n        long endTime = System.currentTimeMillis();\n\n        transferRemoteCandidates(localAgent, remotePeer);\n        for(IceMediaStream stream : localAgent.getStreams())\n        {\n            stream.setRemoteUfrag(remotePeer.getLocalUfrag());\n            stream.setRemotePassword(remotePeer.getLocalPassword());\n        }\n\n        if (START_CONNECTIVITY_ESTABLISHMENT_OF_REMOTE_PEER)\n            transferRemoteCandidates(remotePeer, localAgent);\n\n        for(IceMediaStream stream : remotePeer.getStreams())\n        {\n            stream.setRemoteUfrag(localAgent.getLocalUfrag());\n            stream.setRemotePassword(localAgent.getLocalPassword());\n        }\n\n        logger.info(\"Total candidate gathering time: \"\n                        + (endTime - startTime) + \"ms\");\n        logger.info(\"LocalAgent:\\n\" + localAgent);\n\n        localAgent.startConnectivityEstablishment();\n\n        if (START_CONNECTIVITY_ESTABLISHMENT_OF_REMOTE_PEER)\n            remotePeer.startConnectivityEstablishment();\n\n        logger.info(\"Local audio clist:\\n\"\n                        + localAgent.getStream(\"audio\").getCheckList());\n\n        IceMediaStream videoStream = localAgent.getStream(\"video\");\n\n        if(videoStream != null)\n            logger.info(\"Local video clist:\\n\"\n                            + videoStream.getCheckList());\n\n        //Give processing enough time to finish. We'll System.exit() anyway\n        //as soon as localAgent enters a final state.\n        Thread.sleep(60000);\n    }\n\n    /**\n     * The listener that would end example execution once we enter the\n     * completed state.\n     */\n    public static final class IceProcessingListener\n        implements PropertyChangeListener\n    {\n        /**\n         * System.exit()s as soon as ICE processing enters a final state.\n         *\n         * @param evt the {@link PropertyChangeEvent} containing the old and new\n         * states of ICE processing.\n         */\n        public void propertyChange(PropertyChangeEvent evt)\n        {\n            long processingEndTime = System.currentTimeMillis();\n\n            Object iceProcessingState = evt.getNewValue();\n\n            logger.info(\n                    \"Agent entered the \" + iceProcessingState + \" state.\");\n            if(iceProcessingState == IceProcessingState.COMPLETED)\n            {\n                logger.info(\n                        \"Total ICE processing time: \"\n                            + (processingEndTime - startTime) + \"ms\");\n                Agent agent = (Agent)evt.getSource();\n                List<IceMediaStream> streams = agent.getStreams();\n\n                for(IceMediaStream stream : streams)\n                {\n                    String streamName = stream.getName();\n                    logger.info(\n                            \"Pairs selected for stream: \" + streamName);\n                    List<Component> components = stream.getComponents();\n\n                    for(Component cmp : components)\n                    {\n                        String cmpName = cmp.getName();\n                        logger.info(cmpName + \": \"\n                                        + cmp.getSelectedPair());\n                    }\n                }\n\n                logger.info(\"Printing the completed check lists:\");\n                for(IceMediaStream stream : streams)\n                {\n                    String streamName = stream.getName();\n                    logger.info(\"Check list for  stream: \" + streamName);\n                    //uncomment for a more verbose output\n                    logger.info(stream.getCheckList().toString());\n                }\n\n                logger.info(\"Total ICE processing time to completion: \"\n                    + (System.currentTimeMillis() - startTime));\n            }\n            else if(iceProcessingState == IceProcessingState.TERMINATED\n                    || iceProcessingState == IceProcessingState.FAILED)\n            {\n                /*\n                 * Though the process will be instructed to die, demonstrate\n                 * that Agent instances are to be explicitly prepared for\n                 * garbage collection.\n                 */\n                ((Agent) evt.getSource()).free();\n\n                logger.info(\"Total ICE processing time: \"\n                    + (System.currentTimeMillis() - startTime));\n                System.exit(0);\n            }\n        }\n    }\n\n    /**\n     * Installs remote candidates in <tt>localAgent</tt>..\n     *\n     * @param localAgent a reference to the agent that we will pretend to be the\n     * local\n     * @param remotePeer a reference to what we'll pretend to be a remote agent.\n     */\n    static void transferRemoteCandidates(Agent localAgent,\n                                                 Agent remotePeer)\n    {\n        List<IceMediaStream> streams = localAgent.getStreams();\n\n        for(IceMediaStream localStream : streams)\n        {\n            String streamName = localStream.getName();\n\n            //get a reference to the local stream\n            IceMediaStream remoteStream = remotePeer.getStream(streamName);\n\n            if(remoteStream != null)\n                transferRemoteCandidates(localStream, remoteStream);\n            else\n                localAgent.removeStream(localStream);\n        }\n    }\n\n    /**\n     * Installs remote candidates in <tt>localStream</tt>..\n     *\n     * @param localStream the stream where we will be adding remote candidates\n     * to.\n     * @param remoteStream the stream that we should extract remote candidates\n     * from.\n     */\n    private static void transferRemoteCandidates(IceMediaStream localStream,\n                                                 IceMediaStream remoteStream)\n    {\n        List<Component> localComponents = localStream.getComponents();\n\n        for(Component localComponent : localComponents)\n        {\n            int id = localComponent.getComponentID();\n\n            Component remoteComponent = remoteStream.getComponent(id);\n\n            if(remoteComponent != null)\n                transferRemoteCandidates(localComponent, remoteComponent);\n            else\n                localStream.removeComponent(localComponent);\n        }\n    }\n\n    /**\n     * Adds to <tt>localComponent</tt> a list of remote candidates that are\n     * actually the local candidates from <tt>remoteComponent</tt>.\n     *\n     * @param localComponent the <tt>Component</tt> where that we should be\n     * adding <tt>remoteCandidate</tt>s to.\n     * @param remoteComponent the source of remote candidates.\n     */\n    private static void transferRemoteCandidates(Component localComponent,\n                                                 Component remoteComponent)\n    {\n        List<LocalCandidate> remoteCandidates\n            = remoteComponent.getLocalCandidates();\n\n        localComponent.setDefaultRemoteCandidate(\n                remoteComponent.getDefaultCandidate());\n\n        for(Candidate<?> rCand : remoteCandidates)\n        {\n            localComponent.addRemoteCandidate(\n                    new RemoteCandidate(\n                            rCand.getTransportAddress(),\n                            localComponent,\n                            rCand.getType(),\n                            rCand.getFoundation(),\n                            rCand.getPriority(),\n                            null));\n        }\n    }\n\n    /**\n     * Creates a vanilla ICE <tt>Agent</tt> and adds to it an audio and a video\n     * stream with RTP and RTCP components.\n     *\n     * @param rtpPort the port that we should try to bind the RTP component on\n     * (the RTCP one would automatically go to rtpPort + 1)\n     * @return an ICE <tt>Agent</tt> with an audio stream with RTP and RTCP\n     * components.\n     *\n     * @throws Throwable if anything goes wrong.\n     */\n    protected static Agent createAgent(int rtpPort)\n        throws Throwable\n    {\n        return createAgent(rtpPort, false);\n    }\n\n    /**\n     * Creates an ICE <tt>Agent</tt> (vanilla or trickle, depending on the\n     * value of <tt>isTrickling</tt>) and adds to it an audio and a video stream\n     * with RTP and RTCP components.\n     *\n     * @param rtpPort the port that we should try to bind the RTP component on\n     * (the RTCP one would automatically go to rtpPort + 1)\n     * @return an ICE <tt>Agent</tt> with an audio stream with RTP and RTCP\n     * components.\n     * @param isTrickling indicates whether the newly created agent should be\n     * performing trickle ICE.\n     *\n     * @throws Throwable if anything goes wrong.\n     */\n    protected static Agent createAgent(int rtpPort, boolean isTrickling)\n        throws Throwable\n    {\n        return createAgent(rtpPort, isTrickling, null);\n    }\n\n    /**\n     * Creates an ICE <tt>Agent</tt> (vanilla or trickle, depending on the\n     * value of <tt>isTrickling</tt>) and adds to it an audio and a video stream\n     * with RTP and RTCP components.\n     *\n     * @param rtpPort the port that we should try to bind the RTP component on\n     * (the RTCP one would automatically go to rtpPort + 1)\n     * @return an ICE <tt>Agent</tt> with an audio stream with RTP and RTCP\n     * components.\n     * @param isTrickling indicates whether the newly created agent should be\n     * performing trickle ICE.\n     * @param harvesters the list of {@link CandidateHarvester}s that the new\n     * agent should use or <tt>null</tt> if it should include the default ones.\n     *\n     * @throws Throwable if anything goes wrong.\n     */\n    protected static Agent createAgent(int      rtpPort,\n                                       boolean  isTrickling,\n                                       List<CandidateHarvester>  harvesters)\n        throws Throwable\n    {\n        long startTime = System.currentTimeMillis();\n        Agent agent = new Agent();\n        agent.setTrickling(isTrickling);\n\n        if(harvesters == null)\n        {\n            // STUN\n            StunCandidateHarvester stunHarv = new StunCandidateHarvester(\n                new TransportAddress(\"meet-jit-si-turnrelay.jitsi.net\", 3478, Transport.UDP));\n\n            agent.addCandidateHarvester(stunHarv);\n\n            //UPnP: adding an UPnP harvester because they are generally slow\n            //which makes it more convenient to test things like trickle.\n            agent.addCandidateHarvester( new UPNPHarvester() );\n        }\n        else\n        {\n            for(CandidateHarvester harvester: harvesters)\n            {\n                agent.addCandidateHarvester(harvester);\n            }\n        }\n\n        //STREAMS\n        createStream(rtpPort, \"audio\", agent);\n        createStream(rtpPort + 2, \"video\", agent);\n\n\n        long endTime = System.currentTimeMillis();\n        long total = endTime - startTime;\n\n        logger.info(\"Total harvesting time: \" + total + \"ms.\");\n\n        return agent;\n    }\n\n    /**\n     * Creates an <tt>IceMediaStream</tt> and adds to it an RTP and and RTCP\n     * component.\n     *\n     * @param rtpPort the port that we should try to bind the RTP component on\n     * (the RTCP one would automatically go to rtpPort + 1)\n     * @param streamName the name of the stream to create\n     * @param agent the <tt>Agent</tt> that should create the stream.\n     *\n     * @return the newly created <tt>IceMediaStream</tt>.\n     * @throws Throwable if anything goes wrong.\n     */\n    private static IceMediaStream createStream(int    rtpPort,\n                                               String streamName,\n                                               Agent  agent)\n        throws Throwable\n    {\n        IceMediaStream stream = agent.createMediaStream(streamName);\n\n        long startTime = System.currentTimeMillis();\n\n        //TODO: component creation should probably be part of the library. it\n        //should also be started after we've defined all components to be\n        //created so that we could run the harvesting for everyone of them\n        //simultaneously with the others.\n\n        //rtp\n        agent.createComponent(stream, rtpPort, rtpPort, rtpPort + 100);\n\n        long endTime = System.currentTimeMillis();\n        logger.info(\"RTP Component created in \" + (endTime - startTime) + \" ms\");\n        startTime = endTime;\n        //rtcpComp\n        agent.createComponent(stream, rtpPort + 1, rtpPort + 1, rtpPort + 101);\n\n        endTime = System.currentTimeMillis();\n        logger.info(\"RTCP Component created in \"\n            + (endTime - startTime) + \" ms\");\n\n        return stream;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(Ice.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>Ice</tt>\nclass and its instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(Ice.class.getName())", "syntax_pass": true}, {"attribute_expression": "private static final boolean START_CONNECTIVITY_ESTABLISHMENT_OF_REMOTE_PEER\n        = false;", "docstring": "\nThe indicator which determines whether the <tt>Ice</tt> application (i.e.\nthe run-sample Ant target) is to start connectivity establishment of the\nremote peer (in addition to the connectivity establishment of the local\nagent which is always started, of course).\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "boolean", "name": "START_CONNECTIVITY_ESTABLISHMENT_OF_REMOTE_PEER\n        = false", "syntax_pass": true}, {"attribute_expression": "static long startTime;", "docstring": "\nStart time for debugging purposes.\n", "modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "type": "long", "name": "startTime", "syntax_pass": true}]}, {"uris": "src/test/java/test/AwsTest.java.AwsTest", "name": "AwsTest", "file_path": "src/test/java/test/AwsTest.java", "superclasses": "Ice", "methods": ["[void]main(String[])"], "method_uris": ["src/test/java/test/AwsTest.java.AwsTest.[void]main(String[])"], "overrides": null, "attributes": [], "class_docstring": "\nAn example of using the AWS Harvester.\n<p>\n@author Emil Ivov\n", "original_string": "public class AwsTest\n    extends Ice\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>TrickleIce</tt>\n     * class and its instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(TrickleIce.class.getName());\n\n    /**\n     * Runs a test application that creates an agent, attaches an AWS harvester\n     * as well as a few allocates streams, generates an SDP and dumps\n     * it on stdout\n     *\n     * @param args none currently handled\n     * @throws Throwable every now and then.\n     */\n    public static void main(String[] args) throws Throwable\n    {\n        if(!AwsCandidateHarvester.smellsLikeAnEC2())\n        {\n            logger.info(\"This does not appear to be an EC2 machine\");\n            return;\n        }\n        else\n        {\n            logger.info(\"Oh nice! Looks like we are on an EC2 machine\");\n\n        }\n        AwsCandidateHarvester mch = new AwsCandidateHarvester();\n\n        List<CandidateHarvester> harvesters = new ArrayList<>();\n        harvesters.add(mch);\n\n        Agent localAgent = createAgent(2020, false, harvesters);\n        localAgent.setNominationStrategy(\n                        NominationStrategy.NOMINATE_HIGHEST_PRIO);\n\n        String localSDP = SdpUtils.createSDPDescription(localAgent);\n\n        //wait a bit so that the logger can stop dumping stuff:\n        Thread.sleep(500);\n\n        logger.info(\"=================== feed the following\"\n                    +\" to the remote agent ===================\");\n\n\n        logger.info(\"\\n\" + localSDP);\n\n        logger.info(\"======================================\"\n            + \"========================================\\n\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(TrickleIce.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>TrickleIce</tt>\nclass and its instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(TrickleIce.class.getName())", "syntax_pass": true}]}, {"uris": "src/test/java/test/IceLite.java.IceLite", "name": "IceLite", "file_path": "src/test/java/test/IceLite.java", "superclasses": "IceDistributed", "methods": ["[void]main(String[])"], "method_uris": ["src/test/java/test/IceLite.java.IceLite.[void]main(String[])"], "overrides": null, "attributes": [], "class_docstring": "\nAn ICE sample that kind of works like ICE lite. The sample would create an\nagent, make it print its SDP, then wait for a similar SDP to be fed through\nstandard input. Once this happens, it would also answer incoming connectivity\nchecks without making checks of its own.\n<p>\nThis sample is easily used in conjunction with our {@link IceDistributed}\nsample app.\n\n@author Emil Ivov\n", "original_string": "public class IceLite\n    extends IceDistributed\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>IceLite</tt>\n     * class and its instances for logging output.\n     */\n    private static final Logger logger = Logger.getLogger(IceLite.class\n                    .getName());\n    /**\n     * Runs a test application that allocates streams, generates an SDP, dumps\n     * it on stdout, waits for a remote peer SDP on stdin, then feeds that\n     * to our local agent and starts ICE processing.\n     *\n     * @param args none currently handled\n     * @throws Throwable every now and then.\n     */\n    public static void main(String[] args) throws Throwable\n    {\n        logger.severe(\"Start\");\n        startTime = System.currentTimeMillis();\n\n        Agent localAgent = createAgent(3030);\n        localAgent.setControlling(false);\n        localAgent.setNominationStrategy(\n                        NominationStrategy.NOMINATE_HIGHEST_PRIO);\n\n        localAgent.addStateChangeListener(new IceProcessingListener());\n\n        String localSDP = SdpUtils.createSDPDescription(localAgent);\n\n        System.out.println(\"=================== feed the following\"\n                        +\" to the remote agent ===================\");\n\n        System.out.println(localSDP);\n\n        System.out.println(\"======================================\"\n                        +\"========================================\\n\");\n\n        //Give processing enough time to finish. We'll System.exit() anyway\n        //as soon as localAgent enters a final state.\n        Thread.sleep(60000);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger = Logger.getLogger(IceLite.class\n                    .getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>IceLite</tt>\nclass and its instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger = Logger.getLogger(IceLite.class\n                    .getName())", "syntax_pass": true}]}, {"uris": "src/test/java/test/TrickleIce.java.TrickleIce", "name": "TrickleIce", "file_path": "src/test/java/test/TrickleIce.java", "superclasses": "Ice", "methods": ["[void]main(String[])"], "method_uris": ["src/test/java/test/TrickleIce.java.TrickleIce.[void]main(String[])"], "overrides": null, "attributes": [{"original_string": "    static class CandidatePrinter implements TrickleCallback\n    {\n        /**\n         * Number of candidates that we have seen.\n         */\n        static int candidateCounter = 0;\n\n        /**\n         * The ICE agent that's running the show.\n         */\n        Agent agent;\n\n        /**\n         * Converts every trickled candidate to SDP and prints it on stdout.\n         *\n         * @param iceCandidates the newly discovered list of candidates or,\n         * similarly to WebRTC, <tt>null</tt> in case all candidate harvesting\n         * is now completed.\n         */\n        public void onIceCandidates(Collection<LocalCandidate> iceCandidates)\n        {\n            if( iceCandidates != null)\n                candidateCounter++ ;\n\n            Collection<Attribute> update\n                = IceSdpUtils.createTrickleUpdate(iceCandidates);\n\n            for(Attribute attribute : update)\n            {\n                logger.info(attribute.toString().trim());\n            }\n\n            if(iceCandidates == null)\n            {\n                try{Thread.sleep(1000);}catch(Exception e){}\n\n                logger.info(\"ICE stats: time=\"\n                    + agent.getTotalHarvestingTime() + \"ms\");\n\n                //print statistics\n                for (CandidateHarvester harvester : agent.getHarvesters())\n                {\n                    logger.info(\n                        harvester.getHarvestStatistics().toString().trim());\n                }\n\n\n\n            }\n        }\n    }", "definition": "    static class CandidatePrinter implements TrickleCallback", "class_docstring": "", "name": "CandidatePrinter", "super_interfaces": ["TrickleCallback"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "static int candidateCounter = 0;", "docstring": "\nNumber of candidates that we have seen.\n", "modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "type": "int", "name": "candidateCounter = 0", "syntax_pass": true}, {"attribute_expression": "Agent agent;", "docstring": "\nThe ICE agent that's running the show.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Agent", "name": "agent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public void onIceCandidates(Collection<LocalCandidate> iceCandidates)\n        {\n            if( iceCandidates != null)\n                candidateCounter++ ;\n\n            Collection<Attribute> update\n                = IceSdpUtils.createTrickleUpdate(iceCandidates);\n\n            for(Attribute attribute : update)\n            {\n                logger.info(attribute.toString().trim());\n            }\n\n            if(iceCandidates == null)\n            {\n                try{Thread.sleep(1000);}catch(Exception e){}\n\n                logger.info(\"ICE stats: time=\"\n                    + agent.getTotalHarvestingTime() + \"ms\");\n\n                //print statistics\n                for (CandidateHarvester harvester : agent.getHarvesters())\n                {\n                    logger.info(\n                        harvester.getHarvestStatistics().toString().trim());\n                }\n\n\n\n            }\n        }", "docstring": "\nConverts every trickled candidate to SDP and prints it on stdout.\n\n@param iceCandidates the newly discovered list of candidates or,\nsimilarly to WebRTC, <tt>null</tt> in case all candidate harvesting\nis now completed.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "onIceCandidates", "params": [{"name": "iceCandidates", "type": "Collection<LocalCandidate>"}], "body": "        {\n            if( iceCandidates != null)\n                candidateCounter++ ;\n\n            Collection<Attribute> update\n                = IceSdpUtils.createTrickleUpdate(iceCandidates);\n\n            for(Attribute attribute : update)\n            {\n                logger.info(attribute.toString().trim());\n            }\n\n            if(iceCandidates == null)\n            {\n                try{Thread.sleep(1000);}catch(Exception e){}\n\n                logger.info(\"ICE stats: time=\"\n                    + agent.getTotalHarvestingTime() + \"ms\");\n\n                //print statistics\n                for (CandidateHarvester harvester : agent.getHarvesters())\n                {\n                    logger.info(\n                        harvester.getHarvestStatistics().toString().trim());\n                }\n\n\n\n            }\n        }", "signature": "public void onIceCandidates(Collection<LocalCandidate> iceCandidates)"}]}], "class_docstring": "\nAn example of using trickle ICE.\n<p>\n@author Emil Ivov\n", "original_string": "public class TrickleIce\n    extends Ice\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>TrickleIce</tt>\n     * class and its instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(TrickleIce.class.getName());\n\n    /**\n     * Runs a test application that allocates streams, generates an SDP, dumps\n     * it on stdout, waits for a remote peer SDP on stdin, then feeds that\n     * to our local agent and starts ICE processing.\n     *\n     * @param args none currently handled\n     * @throws Throwable every now and then.\n     */\n    public static void main(String[] args) throws Throwable\n    {\n        Agent localAgent = createAgent(2020, true);\n        localAgent.setNominationStrategy(\n                        NominationStrategy.NOMINATE_HIGHEST_PRIO);\n\n        localAgent.addStateChangeListener(new IceProcessingListener());\n\n        //let them fight ... fights forge character.\n        localAgent.setControlling(false);\n        String localSDP = SdpUtils.createSDPDescription(localAgent);\n\n        //wait a bit so that the logger can stop dumping stuff:\n        Thread.sleep(500);\n\n        logger.info(\"=================== feed the following\"\n                    +\" to the remote agent ===================\");\n\n\n        logger.info(\"\\n\" + localSDP);\n\n        logger.info(\"======================================\"\n            + \"========================================\\n\");\n\n        CandidatePrinter printer = new CandidatePrinter();\n        printer.agent = localAgent;\n\n\n        localAgent.startCandidateTrickle(printer);\n\n\n        List<Component> allComponents = new LinkedList<>();\n        int allCandidates = 0;\n        for (IceMediaStream stream : localAgent.getStreams())\n        {\n            for(Component component : stream.getComponents())\n            {\n                allComponents.add(component);\n                allCandidates += component.getLocalCandidateCount();\n            }\n        }\n        logger.info(\"all candidates = \" + allCandidates);\n\n        /*String sdp = IceDistributed.readSDP();\n\n        startTime = System.currentTimeMillis();\n        SdpUtils.parseSDP(localAgent, sdp);\n\n        localAgent.startConnectivityEstablishment();\n        */\n\n        //Give processing enough time to finish. We'll System.exit() anyway\n        //as soon as localAgent enters a final state.\n        Thread.sleep(60000);\n    }\n\n    static class CandidatePrinter implements TrickleCallback\n    {\n        /**\n         * Number of candidates that we have seen.\n         */\n        static int candidateCounter = 0;\n\n        /**\n         * The ICE agent that's running the show.\n         */\n        Agent agent;\n\n        /**\n         * Converts every trickled candidate to SDP and prints it on stdout.\n         *\n         * @param iceCandidates the newly discovered list of candidates or,\n         * similarly to WebRTC, <tt>null</tt> in case all candidate harvesting\n         * is now completed.\n         */\n        public void onIceCandidates(Collection<LocalCandidate> iceCandidates)\n        {\n            if( iceCandidates != null)\n                candidateCounter++ ;\n\n            Collection<Attribute> update\n                = IceSdpUtils.createTrickleUpdate(iceCandidates);\n\n            for(Attribute attribute : update)\n            {\n                logger.info(attribute.toString().trim());\n            }\n\n            if(iceCandidates == null)\n            {\n                try{Thread.sleep(1000);}catch(Exception e){}\n\n                logger.info(\"ICE stats: time=\"\n                    + agent.getTotalHarvestingTime() + \"ms\");\n\n                //print statistics\n                for (CandidateHarvester harvester : agent.getHarvesters())\n                {\n                    logger.info(\n                        harvester.getHarvestStatistics().toString().trim());\n                }\n\n\n\n            }\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(TrickleIce.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>TrickleIce</tt>\nclass and its instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(TrickleIce.class.getName())", "syntax_pass": true}]}, {"uris": "src/test/java/test/IcePseudoTcp.java.IcePseudoTcp", "name": "IcePseudoTcp", "file_path": "src/test/java/test/IcePseudoTcp.java", "superclasses": "", "methods": ["[Agent]createAgent(int)", "[IceMediaStream]createStream(int,String,Agent)", "[void]main(String[])"], "method_uris": ["src/test/java/test/IcePseudoTcp.java.IcePseudoTcp.[Agent]createAgent(int)", "src/test/java/test/IcePseudoTcp.java.IcePseudoTcp.[IceMediaStream]createStream(int,String,Agent)", "src/test/java/test/IcePseudoTcp.java.IcePseudoTcp.[void]main(String[])"], "overrides": null, "attributes": [{"original_string": "    private static final class LocalIceProcessingListener\n        implements PropertyChangeListener\n    {\n        /**\n         * System.exit()s as soon as ICE processing enters a final state.\n         *\n         * @param evt the {@link PropertyChangeEvent} containing the old and new\n         * states of ICE processing.\n         */\n        public void propertyChange(PropertyChangeEvent evt)\n        {\n            long processingEndTime = System.currentTimeMillis();\n\n            Object iceProcessingState = evt.getNewValue();\n\n            logger.info(\"Local agent entered the \" + iceProcessingState + \" state.\");\n            if (iceProcessingState == IceProcessingState.COMPLETED)\n            {\n                logger.info(\"Local - Total ICE processing time: \" + (processingEndTime - startTime) + \"ms\");\n                Agent agent = (Agent) evt.getSource();\n                logger.info(\"Local: Create pseudo tcp stream\");\n                IceMediaStream dataStream = agent.getStream(\"data\");\n                Component udpComponent = dataStream.getComponents().get(0);\n                CandidatePair selectedPair = udpComponent.getSelectedPair();\n                if (selectedPair != null)\n                {\n                    LocalCandidate localCandidate\n                        = selectedPair.getLocalCandidate();\n                    Candidate<?> remoteCandidate\n                        = selectedPair.getRemoteCandidate();\n                    logger.info(\"Local: \" + localCandidate);\n                    logger.info(\"Remote: \" + remoteCandidate);\n                    try\n                    {\n                        localJob = new LocalPseudoTcpJob(selectedPair.getDatagramSocket());\n                    }\n                    catch (UnknownHostException ex)\n                    {\n                        logger.severe(\"Error while trying to create local pseudotcp thread \" + ex);\n                    }\n                }\n                else\n                {\n                    logger.info(\"Failed to select any candidate pair\");\n                }\n            }\n            else\n            {\n                if (iceProcessingState == IceProcessingState.TERMINATED\n                    || iceProcessingState == IceProcessingState.FAILED)\n                {\n                    /*\n                     * Though the process will be instructed to die, demonstrate\n                     * that Agent instances are to be explicitly prepared for\n                     * garbage collection.\n                     */\n                    if ((localJob != null)\n                            && (iceProcessingState == IceProcessingState.TERMINATED))\n                    {\n                    \tlocalJob.start();                        \n                    }\n                    synchronized (localAgentMonitor)\n                    {\n                        localAgentMonitor.notifyAll();\n                    }\n                }\n            }\n        }\n    }", "definition": "    private static final class LocalIceProcessingListener\n        implements PropertyChangeListener", "class_docstring": "", "name": "LocalIceProcessingListener", "super_interfaces": ["PropertyChangeListener"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public void propertyChange(PropertyChangeEvent evt)\n        {\n            long processingEndTime = System.currentTimeMillis();\n\n            Object iceProcessingState = evt.getNewValue();\n\n            logger.info(\"Local agent entered the \" + iceProcessingState + \" state.\");\n            if (iceProcessingState == IceProcessingState.COMPLETED)\n            {\n                logger.info(\"Local - Total ICE processing time: \" + (processingEndTime - startTime) + \"ms\");\n                Agent agent = (Agent) evt.getSource();\n                logger.info(\"Local: Create pseudo tcp stream\");\n                IceMediaStream dataStream = agent.getStream(\"data\");\n                Component udpComponent = dataStream.getComponents().get(0);\n                CandidatePair selectedPair = udpComponent.getSelectedPair();\n                if (selectedPair != null)\n                {\n                    LocalCandidate localCandidate\n                        = selectedPair.getLocalCandidate();\n                    Candidate<?> remoteCandidate\n                        = selectedPair.getRemoteCandidate();\n                    logger.info(\"Local: \" + localCandidate);\n                    logger.info(\"Remote: \" + remoteCandidate);\n                    try\n                    {\n                        localJob = new LocalPseudoTcpJob(selectedPair.getDatagramSocket());\n                    }\n                    catch (UnknownHostException ex)\n                    {\n                        logger.severe(\"Error while trying to create local pseudotcp thread \" + ex);\n                    }\n                }\n                else\n                {\n                    logger.info(\"Failed to select any candidate pair\");\n                }\n            }\n            else\n            {\n                if (iceProcessingState == IceProcessingState.TERMINATED\n                    || iceProcessingState == IceProcessingState.FAILED)\n                {\n                    /*\n                     * Though the process will be instructed to die, demonstrate\n                     * that Agent instances are to be explicitly prepared for\n                     * garbage collection.\n                     */\n                    if ((localJob != null)\n                            && (iceProcessingState == IceProcessingState.TERMINATED))\n                    {\n                    \tlocalJob.start();                        \n                    }\n                    synchronized (localAgentMonitor)\n                    {\n                        localAgentMonitor.notifyAll();\n                    }\n                }\n            }\n        }", "docstring": "\nSystem.exit()s as soon as ICE processing enters a final state.\n\n@param evt the {@link PropertyChangeEvent} containing the old and new\nstates of ICE processing.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "propertyChange", "params": [{"name": "evt", "type": "PropertyChangeEvent"}], "body": "        {\n            long processingEndTime = System.currentTimeMillis();\n\n            Object iceProcessingState = evt.getNewValue();\n\n            logger.info(\"Local agent entered the \" + iceProcessingState + \" state.\");\n            if (iceProcessingState == IceProcessingState.COMPLETED)\n            {\n                logger.info(\"Local - Total ICE processing time: \" + (processingEndTime - startTime) + \"ms\");\n                Agent agent = (Agent) evt.getSource();\n                logger.info(\"Local: Create pseudo tcp stream\");\n                IceMediaStream dataStream = agent.getStream(\"data\");\n                Component udpComponent = dataStream.getComponents().get(0);\n                CandidatePair selectedPair = udpComponent.getSelectedPair();\n                if (selectedPair != null)\n                {\n                    LocalCandidate localCandidate\n                        = selectedPair.getLocalCandidate();\n                    Candidate<?> remoteCandidate\n                        = selectedPair.getRemoteCandidate();\n                    logger.info(\"Local: \" + localCandidate);\n                    logger.info(\"Remote: \" + remoteCandidate);\n                    try\n                    {\n                        localJob = new LocalPseudoTcpJob(selectedPair.getDatagramSocket());\n                    }\n                    catch (UnknownHostException ex)\n                    {\n                        logger.severe(\"Error while trying to create local pseudotcp thread \" + ex);\n                    }\n                }\n                else\n                {\n                    logger.info(\"Failed to select any candidate pair\");\n                }\n            }\n            else\n            {\n                if (iceProcessingState == IceProcessingState.TERMINATED\n                    || iceProcessingState == IceProcessingState.FAILED)\n                {\n                    /*\n                     * Though the process will be instructed to die, demonstrate\n                     * that Agent instances are to be explicitly prepared for\n                     * garbage collection.\n                     */\n                    if ((localJob != null)\n                            && (iceProcessingState == IceProcessingState.TERMINATED))\n                    {\n                    \tlocalJob.start();                        \n                    }\n                    synchronized (localAgentMonitor)\n                    {\n                        localAgentMonitor.notifyAll();\n                    }\n                }\n            }\n        }", "signature": "public void propertyChange(PropertyChangeEvent evt)"}]}, {"original_string": "    private static final class RemoteIceProcessingListener\n        implements PropertyChangeListener\n    {\n        /**\n         * System.exit()s as soon as ICE processing enters a final state.\n         *\n         * @param evt the {@link PropertyChangeEvent} containing the old and new\n         * states of ICE processing.\n         */\n        public void propertyChange(PropertyChangeEvent evt)\n        {\n            long processingEndTime = System.currentTimeMillis();\n\n            Object iceProcessingState = evt.getNewValue();\n\n            logger.info(\"Remote agent entered the \" + iceProcessingState + \" state.\");\n            if (iceProcessingState == IceProcessingState.COMPLETED)\n            {\n                logger.info(\"Remote: Total ICE processing time: \" + (processingEndTime - startTime) + \" ms \");\n                Agent agent = (Agent) evt.getSource();\n\n                logger.info(\"Remote: Create pseudo tcp stream\");\n                IceMediaStream dataStream = agent.getStream(\"data\");\n                Component udpComponent = dataStream.getComponents().get(0);\n                CandidatePair usedPair = udpComponent.getSelectedPair();\n                if (usedPair != null)\n                {\n                    LocalCandidate localCandidate\n                        = usedPair.getLocalCandidate();\n                    Candidate<?> remoteCandidate\n                        = usedPair.getRemoteCandidate();\n                    logger.info(\"Remote: Local address \" + localCandidate);\n                    logger.info(\"Remote: Peer address \" + remoteCandidate);\n                    try\n                    {\n                        remoteJob = new RemotePseudoTcpJob(\n                            usedPair.getDatagramSocket(),\n                            remoteCandidate.getTransportAddress());\n                    }\n                    catch (UnknownHostException ex)\n                    {\n                        logger.severe(\"Error while trying to create remote pseudotcp thread \" + ex);\n                    }\n                }\n                else\n                {\n                    logger.severe(\"Remote: Failed to select any candidate pair\");\n                }\n            }\n            else\n            {\n                if (iceProcessingState == IceProcessingState.TERMINATED\n                    || iceProcessingState == IceProcessingState.FAILED)\n                {\n                    /*\n                     * Though the process will be instructed to die, demonstrate\n                     * that Agent instances are to be explicitly prepared for\n                     * garbage collection.\n                     */\n                    if ((remoteJob != null)\n                            && (iceProcessingState\n                                    == IceProcessingState.TERMINATED))\n                    {\n                    \tremoteJob.start();                        \n                    }\n                    synchronized (remoteAgentMonitor)\n                    {\n                        remoteAgentMonitor.notifyAll();\n                    }\n                }\n            }\n        }\n    }", "definition": "    private static final class RemoteIceProcessingListener\n        implements PropertyChangeListener", "class_docstring": "", "name": "RemoteIceProcessingListener", "super_interfaces": ["PropertyChangeListener"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public void propertyChange(PropertyChangeEvent evt)\n        {\n            long processingEndTime = System.currentTimeMillis();\n\n            Object iceProcessingState = evt.getNewValue();\n\n            logger.info(\"Remote agent entered the \" + iceProcessingState + \" state.\");\n            if (iceProcessingState == IceProcessingState.COMPLETED)\n            {\n                logger.info(\"Remote: Total ICE processing time: \" + (processingEndTime - startTime) + \" ms \");\n                Agent agent = (Agent) evt.getSource();\n\n                logger.info(\"Remote: Create pseudo tcp stream\");\n                IceMediaStream dataStream = agent.getStream(\"data\");\n                Component udpComponent = dataStream.getComponents().get(0);\n                CandidatePair usedPair = udpComponent.getSelectedPair();\n                if (usedPair != null)\n                {\n                    LocalCandidate localCandidate\n                        = usedPair.getLocalCandidate();\n                    Candidate<?> remoteCandidate\n                        = usedPair.getRemoteCandidate();\n                    logger.info(\"Remote: Local address \" + localCandidate);\n                    logger.info(\"Remote: Peer address \" + remoteCandidate);\n                    try\n                    {\n                        remoteJob = new RemotePseudoTcpJob(\n                            usedPair.getDatagramSocket(),\n                            remoteCandidate.getTransportAddress());\n                    }\n                    catch (UnknownHostException ex)\n                    {\n                        logger.severe(\"Error while trying to create remote pseudotcp thread \" + ex);\n                    }\n                }\n                else\n                {\n                    logger.severe(\"Remote: Failed to select any candidate pair\");\n                }\n            }\n            else\n            {\n                if (iceProcessingState == IceProcessingState.TERMINATED\n                    || iceProcessingState == IceProcessingState.FAILED)\n                {\n                    /*\n                     * Though the process will be instructed to die, demonstrate\n                     * that Agent instances are to be explicitly prepared for\n                     * garbage collection.\n                     */\n                    if ((remoteJob != null)\n                            && (iceProcessingState\n                                    == IceProcessingState.TERMINATED))\n                    {\n                    \tremoteJob.start();                        \n                    }\n                    synchronized (remoteAgentMonitor)\n                    {\n                        remoteAgentMonitor.notifyAll();\n                    }\n                }\n            }\n        }", "docstring": "\nSystem.exit()s as soon as ICE processing enters a final state.\n\n@param evt the {@link PropertyChangeEvent} containing the old and new\nstates of ICE processing.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "propertyChange", "params": [{"name": "evt", "type": "PropertyChangeEvent"}], "body": "        {\n            long processingEndTime = System.currentTimeMillis();\n\n            Object iceProcessingState = evt.getNewValue();\n\n            logger.info(\"Remote agent entered the \" + iceProcessingState + \" state.\");\n            if (iceProcessingState == IceProcessingState.COMPLETED)\n            {\n                logger.info(\"Remote: Total ICE processing time: \" + (processingEndTime - startTime) + \" ms \");\n                Agent agent = (Agent) evt.getSource();\n\n                logger.info(\"Remote: Create pseudo tcp stream\");\n                IceMediaStream dataStream = agent.getStream(\"data\");\n                Component udpComponent = dataStream.getComponents().get(0);\n                CandidatePair usedPair = udpComponent.getSelectedPair();\n                if (usedPair != null)\n                {\n                    LocalCandidate localCandidate\n                        = usedPair.getLocalCandidate();\n                    Candidate<?> remoteCandidate\n                        = usedPair.getRemoteCandidate();\n                    logger.info(\"Remote: Local address \" + localCandidate);\n                    logger.info(\"Remote: Peer address \" + remoteCandidate);\n                    try\n                    {\n                        remoteJob = new RemotePseudoTcpJob(\n                            usedPair.getDatagramSocket(),\n                            remoteCandidate.getTransportAddress());\n                    }\n                    catch (UnknownHostException ex)\n                    {\n                        logger.severe(\"Error while trying to create remote pseudotcp thread \" + ex);\n                    }\n                }\n                else\n                {\n                    logger.severe(\"Remote: Failed to select any candidate pair\");\n                }\n            }\n            else\n            {\n                if (iceProcessingState == IceProcessingState.TERMINATED\n                    || iceProcessingState == IceProcessingState.FAILED)\n                {\n                    /*\n                     * Though the process will be instructed to die, demonstrate\n                     * that Agent instances are to be explicitly prepared for\n                     * garbage collection.\n                     */\n                    if ((remoteJob != null)\n                            && (iceProcessingState\n                                    == IceProcessingState.TERMINATED))\n                    {\n                    \tremoteJob.start();                        \n                    }\n                    synchronized (remoteAgentMonitor)\n                    {\n                        remoteAgentMonitor.notifyAll();\n                    }\n                }\n            }\n        }", "signature": "public void propertyChange(PropertyChangeEvent evt)"}]}, {"original_string": "    private static class LocalPseudoTcpJob extends Thread implements Runnable\n    {\n        private DatagramSocket dgramSocket;\n\n        public LocalPseudoTcpJob(DatagramSocket socket)\n            throws UnknownHostException\n        {\n            this.dgramSocket = socket;\n        }\n\n        @Override\n        public void run()\n        {\n            logger.finest(\"Local pseudotcp worker started\");\n            try\n            {\n                logger.info(\"Local pseudotcp is using: \" + dgramSocket.getLocalSocketAddress()+dgramSocket);\n                \n                PseudoTcpSocket socket = new PseudoTcpSocketFactory().createSocket(dgramSocket);\n                socket.setConversationID(1073741824);\n                socket.setMTU(1500);\n                socket.setDebugName(\"L\");\n                socket.accept(5000);                \n                byte[] buffer = new byte[TEST_BYTES_COUNT];\n                int read = 0;\n                while (read != TEST_BYTES_COUNT)\n                {\n                    read += socket.getInputStream().read(buffer);\n                    logger.finest(\"Local job read: \" + read);\n                }\n                //TODO: close when all received data is acked\n                //socket.close();\n            }\n            catch (IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n            logger.finest(\"Local pseudotcp worker finished\");\n        }\n    }", "definition": "    private static class LocalPseudoTcpJob extends Thread implements Runnable", "class_docstring": "", "name": "LocalPseudoTcpJob", "super_interfaces": ["Runnable"], "superclasses": "Thread", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private DatagramSocket dgramSocket;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DatagramSocket", "name": "dgramSocket", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public LocalPseudoTcpJob(DatagramSocket socket)\n            throws UnknownHostException\n        {\n            this.dgramSocket = socket;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "LocalPseudoTcpJob", "params": [{"name": "socket", "type": "DatagramSocket"}], "body": "        {\n            this.dgramSocket = socket;\n        }", "signature": "public LocalPseudoTcpJob(DatagramSocket socket)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void run()\n        {\n            logger.finest(\"Local pseudotcp worker started\");\n            try\n            {\n                logger.info(\"Local pseudotcp is using: \" + dgramSocket.getLocalSocketAddress()+dgramSocket);\n                \n                PseudoTcpSocket socket = new PseudoTcpSocketFactory().createSocket(dgramSocket);\n                socket.setConversationID(1073741824);\n                socket.setMTU(1500);\n                socket.setDebugName(\"L\");\n                socket.accept(5000);                \n                byte[] buffer = new byte[TEST_BYTES_COUNT];\n                int read = 0;\n                while (read != TEST_BYTES_COUNT)\n                {\n                    read += socket.getInputStream().read(buffer);\n                    logger.finest(\"Local job read: \" + read);\n                }\n                //TODO: close when all received data is acked\n                //socket.close();\n            }\n            catch (IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n            logger.finest(\"Local pseudotcp worker finished\");\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "run", "params": [], "body": "        {\n            logger.finest(\"Local pseudotcp worker started\");\n            try\n            {\n                logger.info(\"Local pseudotcp is using: \" + dgramSocket.getLocalSocketAddress()+dgramSocket);\n                \n                PseudoTcpSocket socket = new PseudoTcpSocketFactory().createSocket(dgramSocket);\n                socket.setConversationID(1073741824);\n                socket.setMTU(1500);\n                socket.setDebugName(\"L\");\n                socket.accept(5000);                \n                byte[] buffer = new byte[TEST_BYTES_COUNT];\n                int read = 0;\n                while (read != TEST_BYTES_COUNT)\n                {\n                    read += socket.getInputStream().read(buffer);\n                    logger.finest(\"Local job read: \" + read);\n                }\n                //TODO: close when all received data is acked\n                //socket.close();\n            }\n            catch (IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n            logger.finest(\"Local pseudotcp worker finished\");\n        }", "signature": "@Override\n        public void run()"}]}, {"original_string": "    private static class RemotePseudoTcpJob extends Thread implements Runnable\n    {\n        private DatagramSocket dgramSocket;\n        private InetSocketAddress peerAddr;\n\n        public RemotePseudoTcpJob(DatagramSocket socket,\n                                  InetSocketAddress peerAddr)\n            throws UnknownHostException\n        {\n        \tthis.dgramSocket = socket;\n            this.peerAddr = peerAddr;\n        }\n\n        @Override\n        public void run()\n        {\n            logger.finest(\"Remote pseudotcp worker started\");\n            try\n            {\n                logger.info(\"Remote pseudotcp is using: \" + dgramSocket.getLocalSocketAddress()\n                           + \" and will communicate with: \" + peerAddr);\n                PseudoTcpSocket socket = new PseudoTcpSocketFactory().\n                    createSocket(dgramSocket);\n                socket.setConversationID(1073741824);\n                socket.setMTU(1500);\n                socket.setDebugName(\"R\");\n                long start, end;\n                start = System.currentTimeMillis();\n                socket.connect(peerAddr, 5000);\n                byte[] buffer = new byte[TEST_BYTES_COUNT];\n                socket.getOutputStream().write(buffer);\n                socket.getOutputStream().flush();\n                //Socket will be closed by the iceAgent\n                //socket.close();\n                end = System.currentTimeMillis();\n                logger.info(\"Transferred \" + TEST_BYTES_COUNT + \" bytes in \" + ((end - start) / 1000) + \" sec\");\n            }\n            catch (IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n            logger.finest(\"Remote pseudotcp worker finished\");\n        }\n    }", "definition": "    private static class RemotePseudoTcpJob extends Thread implements Runnable", "class_docstring": "", "name": "RemotePseudoTcpJob", "super_interfaces": ["Runnable"], "superclasses": "Thread", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private DatagramSocket dgramSocket;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DatagramSocket", "name": "dgramSocket", "syntax_pass": true}, {"attribute_expression": "private InetSocketAddress peerAddr;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "InetSocketAddress", "name": "peerAddr", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public RemotePseudoTcpJob(DatagramSocket socket,\n                                  InetSocketAddress peerAddr)\n            throws UnknownHostException\n        {\n        \tthis.dgramSocket = socket;\n            this.peerAddr = peerAddr;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "RemotePseudoTcpJob", "params": [{"name": "socket", "type": "DatagramSocket"}, {"name": "peerAddr", "type": "InetSocketAddress"}], "body": "        {\n        \tthis.dgramSocket = socket;\n            this.peerAddr = peerAddr;\n        }", "signature": "public RemotePseudoTcpJob(DatagramSocket socket,\n                                  InetSocketAddress peerAddr)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void run()\n        {\n            logger.finest(\"Remote pseudotcp worker started\");\n            try\n            {\n                logger.info(\"Remote pseudotcp is using: \" + dgramSocket.getLocalSocketAddress()\n                           + \" and will communicate with: \" + peerAddr);\n                PseudoTcpSocket socket = new PseudoTcpSocketFactory().\n                    createSocket(dgramSocket);\n                socket.setConversationID(1073741824);\n                socket.setMTU(1500);\n                socket.setDebugName(\"R\");\n                long start, end;\n                start = System.currentTimeMillis();\n                socket.connect(peerAddr, 5000);\n                byte[] buffer = new byte[TEST_BYTES_COUNT];\n                socket.getOutputStream().write(buffer);\n                socket.getOutputStream().flush();\n                //Socket will be closed by the iceAgent\n                //socket.close();\n                end = System.currentTimeMillis();\n                logger.info(\"Transferred \" + TEST_BYTES_COUNT + \" bytes in \" + ((end - start) / 1000) + \" sec\");\n            }\n            catch (IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n            logger.finest(\"Remote pseudotcp worker finished\");\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "run", "params": [], "body": "        {\n            logger.finest(\"Remote pseudotcp worker started\");\n            try\n            {\n                logger.info(\"Remote pseudotcp is using: \" + dgramSocket.getLocalSocketAddress()\n                           + \" and will communicate with: \" + peerAddr);\n                PseudoTcpSocket socket = new PseudoTcpSocketFactory().\n                    createSocket(dgramSocket);\n                socket.setConversationID(1073741824);\n                socket.setMTU(1500);\n                socket.setDebugName(\"R\");\n                long start, end;\n                start = System.currentTimeMillis();\n                socket.connect(peerAddr, 5000);\n                byte[] buffer = new byte[TEST_BYTES_COUNT];\n                socket.getOutputStream().write(buffer);\n                socket.getOutputStream().flush();\n                //Socket will be closed by the iceAgent\n                //socket.close();\n                end = System.currentTimeMillis();\n                logger.info(\"Transferred \" + TEST_BYTES_COUNT + \" bytes in \" + ((end - start) / 1000) + \" sec\");\n            }\n            catch (IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n            logger.finest(\"Remote pseudotcp worker finished\");\n        }", "signature": "@Override\n        public void run()"}]}], "class_docstring": "\nSample program which first uses ICE to discover UDP connectivity. After that\nselected cadidates are used by \"remote\" and \"local\" pseudoTCP peers to\ntransfer some test data.\n\n@author Pawel Domas\n", "original_string": "public class IcePseudoTcp\n{\n    /**\n     * The logger.\n     */\n    private static final Logger logger = Logger.getLogger(IcePseudoTcp.class.getName());\n    private static long startTime;\n    /**\n     * Local job thread variable\n     */\n    private static LocalPseudoTcpJob localJob = null;\n    /**\n     * Remote job thread variable\n     */\n    private static RemotePseudoTcpJob remoteJob = null;\n    /**\n     * Test data size\n     */\n    private static final int TEST_BYTES_COUNT = 15000000;\n    /**\n     * Flag inidcates if STUN should be used\n     */\n    private static final boolean USE_STUN = true;\n    /**\n     * Flag inidcates if TURN should be used\n     */\n    private static final boolean USE_TURN = true;\n    /**\n     * Monitor object used to wait for remote agent to finish it's job\n     */\n    private static final Object remoteAgentMonitor = new Object();\n    /**\n     * Monitor object used to wait for local agent to finish it's job\n     */\n    private static final Object localAgentMonitor = new Object();\n    /**\n     * Timeout for ICE discovery\n     */\n    private static long agentJobTimeout = 15000;\n\n    protected static Agent createAgent(int pTcpPort)\n        throws Throwable\n    {\n        Agent agent = new Agent();\n        // STUN\n        if (USE_STUN)\n        {\n            StunCandidateHarvester stunHarv = new StunCandidateHarvester(\n                new TransportAddress(\"sip-communicator.net\",\n                                     3478, Transport.UDP));\n            StunCandidateHarvester stun6Harv = new StunCandidateHarvester(\n                new TransportAddress(\"ipv6.sip-communicator.net\",\n                                     3478, Transport.UDP));\n\n            agent.addCandidateHarvester(stunHarv);\n            agent.addCandidateHarvester(stun6Harv);\n        }\n        // TURN \n        if (USE_TURN)\n        {\n            String[] hostnames = new String[]\n            {\n                \"130.79.90.150\",\n                \"2001:660:4701:1001:230:5ff:fe1a:805f\"\n            };\n            int port = 3478;\n            LongTermCredential longTermCredential = new LongTermCredential(\n                \"guest\", \"anonymouspower!!\");\n\n            for (String hostname : hostnames)\n            {\n                agent.addCandidateHarvester(new TurnCandidateHarvester(\n                    new TransportAddress(hostname, port, Transport.UDP), longTermCredential));\n            }\n        }\n        //STREAM\n        createStream(pTcpPort, \"data\", agent);\n\n        return agent;\n    }\n\n    private static IceMediaStream createStream(int pTcpPort,\n                                               String streamName,\n                                               Agent agent)\n        throws Throwable\n    {\n        IceMediaStream stream = agent.createMediaStream(streamName);\n\n        long startTime = System.currentTimeMillis();\n\n        //udp component\n        agent.createComponent(stream, pTcpPort, pTcpPort, pTcpPort + 100);\n\n        long endTime = System.currentTimeMillis();\n        logger.info(\"UDP Component created in \" + (endTime - startTime) + \" ms\");\n\n        return stream;\n    }\n\n    private static final class LocalIceProcessingListener\n        implements PropertyChangeListener\n    {\n        /**\n         * System.exit()s as soon as ICE processing enters a final state.\n         *\n         * @param evt the {@link PropertyChangeEvent} containing the old and new\n         * states of ICE processing.\n         */\n        public void propertyChange(PropertyChangeEvent evt)\n        {\n            long processingEndTime = System.currentTimeMillis();\n\n            Object iceProcessingState = evt.getNewValue();\n\n            logger.info(\"Local agent entered the \" + iceProcessingState + \" state.\");\n            if (iceProcessingState == IceProcessingState.COMPLETED)\n            {\n                logger.info(\"Local - Total ICE processing time: \" + (processingEndTime - startTime) + \"ms\");\n                Agent agent = (Agent) evt.getSource();\n                logger.info(\"Local: Create pseudo tcp stream\");\n                IceMediaStream dataStream = agent.getStream(\"data\");\n                Component udpComponent = dataStream.getComponents().get(0);\n                CandidatePair selectedPair = udpComponent.getSelectedPair();\n                if (selectedPair != null)\n                {\n                    LocalCandidate localCandidate\n                        = selectedPair.getLocalCandidate();\n                    Candidate<?> remoteCandidate\n                        = selectedPair.getRemoteCandidate();\n                    logger.info(\"Local: \" + localCandidate);\n                    logger.info(\"Remote: \" + remoteCandidate);\n                    try\n                    {\n                        localJob = new LocalPseudoTcpJob(selectedPair.getDatagramSocket());\n                    }\n                    catch (UnknownHostException ex)\n                    {\n                        logger.severe(\"Error while trying to create local pseudotcp thread \" + ex);\n                    }\n                }\n                else\n                {\n                    logger.info(\"Failed to select any candidate pair\");\n                }\n            }\n            else\n            {\n                if (iceProcessingState == IceProcessingState.TERMINATED\n                    || iceProcessingState == IceProcessingState.FAILED)\n                {\n                    /*\n                     * Though the process will be instructed to die, demonstrate\n                     * that Agent instances are to be explicitly prepared for\n                     * garbage collection.\n                     */\n                    if ((localJob != null)\n                            && (iceProcessingState == IceProcessingState.TERMINATED))\n                    {\n                    \tlocalJob.start();                        \n                    }\n                    synchronized (localAgentMonitor)\n                    {\n                        localAgentMonitor.notifyAll();\n                    }\n                }\n            }\n        }\n    }\n\n    private static final class RemoteIceProcessingListener\n        implements PropertyChangeListener\n    {\n        /**\n         * System.exit()s as soon as ICE processing enters a final state.\n         *\n         * @param evt the {@link PropertyChangeEvent} containing the old and new\n         * states of ICE processing.\n         */\n        public void propertyChange(PropertyChangeEvent evt)\n        {\n            long processingEndTime = System.currentTimeMillis();\n\n            Object iceProcessingState = evt.getNewValue();\n\n            logger.info(\"Remote agent entered the \" + iceProcessingState + \" state.\");\n            if (iceProcessingState == IceProcessingState.COMPLETED)\n            {\n                logger.info(\"Remote: Total ICE processing time: \" + (processingEndTime - startTime) + \" ms \");\n                Agent agent = (Agent) evt.getSource();\n\n                logger.info(\"Remote: Create pseudo tcp stream\");\n                IceMediaStream dataStream = agent.getStream(\"data\");\n                Component udpComponent = dataStream.getComponents().get(0);\n                CandidatePair usedPair = udpComponent.getSelectedPair();\n                if (usedPair != null)\n                {\n                    LocalCandidate localCandidate\n                        = usedPair.getLocalCandidate();\n                    Candidate<?> remoteCandidate\n                        = usedPair.getRemoteCandidate();\n                    logger.info(\"Remote: Local address \" + localCandidate);\n                    logger.info(\"Remote: Peer address \" + remoteCandidate);\n                    try\n                    {\n                        remoteJob = new RemotePseudoTcpJob(\n                            usedPair.getDatagramSocket(),\n                            remoteCandidate.getTransportAddress());\n                    }\n                    catch (UnknownHostException ex)\n                    {\n                        logger.severe(\"Error while trying to create remote pseudotcp thread \" + ex);\n                    }\n                }\n                else\n                {\n                    logger.severe(\"Remote: Failed to select any candidate pair\");\n                }\n            }\n            else\n            {\n                if (iceProcessingState == IceProcessingState.TERMINATED\n                    || iceProcessingState == IceProcessingState.FAILED)\n                {\n                    /*\n                     * Though the process will be instructed to die, demonstrate\n                     * that Agent instances are to be explicitly prepared for\n                     * garbage collection.\n                     */\n                    if ((remoteJob != null)\n                            && (iceProcessingState\n                                    == IceProcessingState.TERMINATED))\n                    {\n                    \tremoteJob.start();                        \n                    }\n                    synchronized (remoteAgentMonitor)\n                    {\n                        remoteAgentMonitor.notifyAll();\n                    }\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) throws Throwable\n    {\n        startTime = System.currentTimeMillis();\n        \n        int localPort = 7999;\n        int remotePort = 6000;\n\n        Agent localAgent = createAgent(localPort);\n        localAgent.setNominationStrategy(NominationStrategy.NOMINATE_HIGHEST_PRIO);\n        Agent remotePeer = createAgent(remotePort);\n\n        localAgent.addStateChangeListener(new IcePseudoTcp.LocalIceProcessingListener());\n        remotePeer.addStateChangeListener(new IcePseudoTcp.RemoteIceProcessingListener());\n\n        //let them fight ... fights forge character.\n        localAgent.setControlling(true);\n        remotePeer.setControlling(false);\n\n        long endTime = System.currentTimeMillis();\n\n        Ice.transferRemoteCandidates(localAgent, remotePeer);\n        for (IceMediaStream stream : localAgent.getStreams())\n        {\n            stream.setRemoteUfrag(remotePeer.getLocalUfrag());\n            stream.setRemotePassword(remotePeer.getLocalPassword());\n        }\n\n        Ice.transferRemoteCandidates(remotePeer, localAgent);\n\n        for (IceMediaStream stream : remotePeer.getStreams())\n        {\n            stream.setRemoteUfrag(localAgent.getLocalUfrag());\n            stream.setRemotePassword(localAgent.getLocalPassword());\n        }\n\n        logger.log(Level.INFO, \"Total candidate gathering time: {0} ms\", (endTime - startTime));\n        logger.log(Level.INFO, \"LocalAgent: {0}\", localAgent);\n\n        localAgent.startConnectivityEstablishment();\n\n        //if (START_CONNECTIVITY_ESTABLISHMENT_OF_REMOTE_PEER)\n        remotePeer.startConnectivityEstablishment();\n\n\n        IceMediaStream dataStream = localAgent.getStream(\"data\");\n\n        if (dataStream != null)\n        {\n            logger.info(\"Local data clist:\" + dataStream.getCheckList());\n        }\n        //wait for one of the agents to complete it's job \n        synchronized (remoteAgentMonitor)\n        {\n            remoteAgentMonitor.wait(agentJobTimeout);\n        }\n        if (remoteJob != null)\n        {\n            logger.finest(\"Remote thread join started\");\n            remoteJob.join();\n            logger.finest(\"Remote thread joined\");\n        }\n        remotePeer.free();\n        if (localJob != null)\n        {\n            logger.finest(\"Local thread join started\");\n            localJob.join();\n            logger.finest(\"Local thread joined\");\n        }\n        localAgent.free();\n        System.exit(0);\n    }\n\n    private static class LocalPseudoTcpJob extends Thread implements Runnable\n    {\n        private DatagramSocket dgramSocket;\n\n        public LocalPseudoTcpJob(DatagramSocket socket)\n            throws UnknownHostException\n        {\n            this.dgramSocket = socket;\n        }\n\n        @Override\n        public void run()\n        {\n            logger.finest(\"Local pseudotcp worker started\");\n            try\n            {\n                logger.info(\"Local pseudotcp is using: \" + dgramSocket.getLocalSocketAddress()+dgramSocket);\n                \n                PseudoTcpSocket socket = new PseudoTcpSocketFactory().createSocket(dgramSocket);\n                socket.setConversationID(1073741824);\n                socket.setMTU(1500);\n                socket.setDebugName(\"L\");\n                socket.accept(5000);                \n                byte[] buffer = new byte[TEST_BYTES_COUNT];\n                int read = 0;\n                while (read != TEST_BYTES_COUNT)\n                {\n                    read += socket.getInputStream().read(buffer);\n                    logger.finest(\"Local job read: \" + read);\n                }\n                //TODO: close when all received data is acked\n                //socket.close();\n            }\n            catch (IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n            logger.finest(\"Local pseudotcp worker finished\");\n        }\n    }\n\n    private static class RemotePseudoTcpJob extends Thread implements Runnable\n    {\n        private DatagramSocket dgramSocket;\n        private InetSocketAddress peerAddr;\n\n        public RemotePseudoTcpJob(DatagramSocket socket,\n                                  InetSocketAddress peerAddr)\n            throws UnknownHostException\n        {\n        \tthis.dgramSocket = socket;\n            this.peerAddr = peerAddr;\n        }\n\n        @Override\n        public void run()\n        {\n            logger.finest(\"Remote pseudotcp worker started\");\n            try\n            {\n                logger.info(\"Remote pseudotcp is using: \" + dgramSocket.getLocalSocketAddress()\n                           + \" and will communicate with: \" + peerAddr);\n                PseudoTcpSocket socket = new PseudoTcpSocketFactory().\n                    createSocket(dgramSocket);\n                socket.setConversationID(1073741824);\n                socket.setMTU(1500);\n                socket.setDebugName(\"R\");\n                long start, end;\n                start = System.currentTimeMillis();\n                socket.connect(peerAddr, 5000);\n                byte[] buffer = new byte[TEST_BYTES_COUNT];\n                socket.getOutputStream().write(buffer);\n                socket.getOutputStream().flush();\n                //Socket will be closed by the iceAgent\n                //socket.close();\n                end = System.currentTimeMillis();\n                logger.info(\"Transferred \" + TEST_BYTES_COUNT + \" bytes in \" + ((end - start) / 1000) + \" sec\");\n            }\n            catch (IOException e)\n            {\n                throw new RuntimeException(e);\n            }\n            logger.finest(\"Remote pseudotcp worker finished\");\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger = Logger.getLogger(IcePseudoTcp.class.getName());", "docstring": "\nThe logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger = Logger.getLogger(IcePseudoTcp.class.getName())", "syntax_pass": true}, {"attribute_expression": "private static long startTime;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "long", "name": "startTime", "syntax_pass": true}, {"attribute_expression": "private static LocalPseudoTcpJob localJob = null;", "docstring": "\nLocal job thread variable\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "LocalPseudoTcpJob", "name": "localJob = null", "syntax_pass": true}, {"attribute_expression": "private static RemotePseudoTcpJob remoteJob = null;", "docstring": "\nRemote job thread variable\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "RemotePseudoTcpJob", "name": "remoteJob = null", "syntax_pass": true}, {"attribute_expression": "private static final int TEST_BYTES_COUNT = 15000000;", "docstring": "\nTest data size\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "TEST_BYTES_COUNT = 15000000", "syntax_pass": true}, {"attribute_expression": "private static final boolean USE_STUN = true;", "docstring": "\nFlag inidcates if STUN should be used\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "boolean", "name": "USE_STUN = true", "syntax_pass": true}, {"attribute_expression": "private static final boolean USE_TURN = true;", "docstring": "\nFlag inidcates if TURN should be used\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "boolean", "name": "USE_TURN = true", "syntax_pass": true}, {"attribute_expression": "private static final Object remoteAgentMonitor = new Object();", "docstring": "\nMonitor object used to wait for remote agent to finish it's job\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "remoteAgentMonitor = new Object()", "syntax_pass": true}, {"attribute_expression": "private static final Object localAgentMonitor = new Object();", "docstring": "\nMonitor object used to wait for local agent to finish it's job\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Object", "name": "localAgentMonitor = new Object()", "syntax_pass": true}, {"attribute_expression": "private static long agentJobTimeout = 15000;", "docstring": "\nTimeout for ICE discovery\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "long", "name": "agentJobTimeout = 15000", "syntax_pass": true}]}, {"uris": "src/test/java/test/IceDistributed.java.IceDistributed", "name": "IceDistributed", "file_path": "src/test/java/test/IceDistributed.java", "superclasses": "Ice", "methods": ["[void]main(String[])", "[String]readSDP()"], "method_uris": ["src/test/java/test/IceDistributed.java.IceDistributed.[void]main(String[])", "src/test/java/test/IceDistributed.java.IceDistributed.[String]readSDP()"], "overrides": null, "attributes": [], "class_docstring": "\nA slightly more complicated ICE use sample. The sample would create an\nagent, make it print its SDP, then wait for a similar SDP to be fed through\nstandard input. Once this happens, we make our agent start checks against the\npeer described in the SDP we fed through stdin.\n<p>\nThis sample is easily used in conjunction with another instance of the same\nsample application or against our {@link IceLite} sample app.\n\n@author Emil Ivov\n", "original_string": "public class IceDistributed\n    extends Ice\n{\n    /**\n     * Runs a test application that allocates streams, generates an SDP, dumps\n     * it on stdout, waits for a remote peer SDP on stdin, then feeds that\n     * to our local agent and starts ICE processing.\n     *\n     * @param args none currently handled\n     * @throws Throwable every now and then.\n     */\n    public static void main(String[] args) throws Throwable\n    {\n        Agent localAgent = createAgent(2020);\n        localAgent.setNominationStrategy(\n                        NominationStrategy.NOMINATE_HIGHEST_PRIO);\n\n        localAgent.addStateChangeListener(new IceProcessingListener());\n\n        //let them fight ... fights forge character.\n        localAgent.setControlling(false);\n        String localSDP = SdpUtils.createSDPDescription(localAgent);\n\n        //wait a bit so that the logger can stop dumping stuff:\n        Thread.sleep(500);\n\n        System.out.println(\"=================== feed the following\"\n                        +\" to the remote agent ===================\");\n\n\n        System.out.println(localSDP);\n\n        System.out.println(\"======================================\"\n                        +\"========================================\\n\");\n\n        String sdp = readSDP();\n\n        startTime = System.currentTimeMillis();\n        SdpUtils.parseSDP(localAgent, sdp);\n\n        localAgent.startConnectivityEstablishment();\n\n        //Give processing enough time to finish. We'll System.exit() anyway\n        //as soon as localAgent enters a final state.\n        Thread.sleep(60000);\n    }\n\n    /**\n     * Reads an SDP description from the standard input. We expect descriptions\n     * provided to this method to be originating from instances of this\n     * application running on remote computers.\n     *\n     * @return whatever we got on stdin (hopefully an SDP description.\n     *\n     * @throws Throwable if something goes wrong with console reading.\n     */\n    static String readSDP() throws Throwable\n    {\n        System.out.println(\"Paste remote SDP here. Enter an empty \"\n                        +\"line to proceed:\");\n        System.out.println(\"(we don't mind the [java] prefix in SDP intput)\");\n        BufferedReader reader\n            = new BufferedReader(new InputStreamReader(System.in));\n\n        StringBuffer buff = new StringBuffer();\n        String line;\n\n        while ( (line = reader.readLine()) != null)\n        {\n            line = line.replace(\"[java]\", \"\");\n            line = line.trim();\n            if(line.length() == 0)\n                break;\n\n            buff.append(line);\n            buff.append(\"\\r\\n\");\n        }\n\n        return buff.toString();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/test/signalling/Signalling.java.Signalling", "name": "Signalling", "file_path": "src/test/java/test/signalling/Signalling.java", "superclasses": "", "methods": ["[]Signalling(Socket,SignallingCallback)", "[Signalling]createServerSignalling(InetSocketAddress,SignallingCallback)"], "method_uris": ["src/test/java/test/signalling/Signalling.java.Signalling.[]Signalling(Socket,SignallingCallback)", "src/test/java/test/signalling/Signalling.java.Signalling.[Signalling]createServerSignalling(InetSocketAddress,SignallingCallback)"], "overrides": null, "attributes": [], "class_docstring": "\nA simple signalling utility that we use for ICE tests.\n\n@author Emil Ivov\n", "original_string": "public class Signalling\n{\n    /**\n     * The socket where we send and receive signalling\n     */\n//    private final Socket signallingSocket;\n\n//    private final SignallingCallback signallingCallback;\n\n    /**\n     * Creates a signalling instance over the specified socket.\n     *\n     * @param socket the socket that this instance should use for signalling\n     */\n    public Signalling(Socket socket, SignallingCallback signallingCallback)\n    {\n//        this.signallingSocket = socket;\n//        this.signallingCallback = signallingCallback;\n    }\n\n    /**\n     * Creates a server signalling object. The method will block until a\n     * connection is actually received on\n     *\n     * @param socketAddress our bind address\n     * @param signallingCallback the callback that we will deliver signalling\n     * to.\n     *\n     * @return the newly created Signalling object\n     *\n     * @throws Throwable if anything goes wrong (which could happen with the\n     * socket stuff).\n     */\n    public static Signalling createServerSignalling(\n            InetSocketAddress socketAddress,\n            SignallingCallback signallingCallback)\n        throws Throwable\n    {\n//        ServerSocket serverSocket = new ServerSocket(socketAddress);\n//        Signalling signalling = new Signalling(socketAddress, signallingCallback);\n        return null;\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/ice4j/StunException.java.StunException", "name": "StunException", "file_path": "src/main/java/org/ice4j/StunException.java", "superclasses": "Exception", "methods": ["[]StunException()", "[]StunException(int)", "[]StunException(String)", "[]StunException(int,String)", "[]StunException(int,String,Throwable)", "[]StunException(String,Throwable)", "[]StunException(Throwable)", "[void]setID(int)", "[int]getID()"], "method_uris": ["src/main/java/org/ice4j/StunException.java.StunException.[]StunException()", "src/main/java/org/ice4j/StunException.java.StunException.[]StunException(int)", "src/main/java/org/ice4j/StunException.java.StunException.[]StunException(String)", "src/main/java/org/ice4j/StunException.java.StunException.[]StunException(int,String)", "src/main/java/org/ice4j/StunException.java.StunException.[]StunException(int,String,Throwable)", "src/main/java/org/ice4j/StunException.java.StunException.[]StunException(String,Throwable)", "src/main/java/org/ice4j/StunException.java.StunException.[]StunException(Throwable)", "src/main/java/org/ice4j/StunException.java.StunException.[void]setID(int)", "src/main/java/org/ice4j/StunException.java.StunException.[int]getID()"], "overrides": null, "attributes": [], "class_docstring": "\nA <tt>StunException</tt> is thrown when a general STUN exception is\nencountered.\n\n@author Emil Ivov\n", "original_string": "public class StunException extends Exception\n{\n    /**\n     * Serial version UID for this <tt>Serializable</tt> class.\n     */\n    private static final long serialVersionUID = 35367793L;\n\n    /**\n     * Means that the the reason that caused the exception was unclear.\n     */\n    public static final int UNKNOWN_ERROR = 0;\n\n    /**\n     * Indicates that the attempted operation is not possible in the current\n     * state of the object.\n     */\n    public static final int ILLEGAL_STATE = 1;\n\n    /**\n     * Indicates that one or more of the passed arguments had invalid values.\n     */\n    public static final int ILLEGAL_ARGUMENT = 2;\n\n    /**\n     * Indicates that an unexpected error has occurred..\n     */\n    public static final int INTERNAL_ERROR = 3;\n\n    /**\n     * Thrown when trying to send responses through a non-existent transaction\n     * That may happen when a corresponding request has already been responded\n     * to or when no such request has been received.\n     */\n    public static final int TRANSACTION_DOES_NOT_EXIST = 3;\n\n\n    /**\n     * Indicates that an unexpected error has occurred..\n     */\n    public static final int NETWORK_ERROR = 4;\n\n    /**\n     * Thrown when trying to send responses through a transaction that have\n     * already sent a response.\n     */\n    public static final int TRANSACTION_ALREADY_ANSWERED = 5;\n\n    /**\n     * Identifies the exception.\n     */\n    private int id = 0;\n\n    /**\n     * Creates a StunException.\n     */\n    public StunException()\n    {\n\n    }\n\n    /**\n     * Creates a StunException setting id as its identifier.\n     * @param id an error ID\n     */\n    public StunException(int id)\n    {\n        setID(id);\n    }\n\n    /**\n     * Creates a StunException, setting an error message.\n     * @param message an error message.\n     */\n    public StunException(String message)\n    {\n        super(message);\n    }\n\n    /**\n     * Creates a StunException, setting an error message and an error id.\n     * @param message an error message.\n     * @param id an error id.\n     */\n    public StunException(int id, String message)\n    {\n        super(message);\n        setID(id);\n    }\n\n    /**\n     * Creates a StunException, setting an error message an error id and a\n     * cause.\n     *\n     * @param id an error id.\n     * @param message an error message.\n     * @param cause the error that caused this exception.\n     */\n    public StunException(int id, String message, Throwable cause)\n    {\n        super(message, cause);\n        setID(id);\n    }\n\n    /**\n     * Creates a StunException, setting an error message and a cause object.\n     * @param message an error message.\n     * @param cause the error object that caused this exception.\n     */\n    public StunException(String message, Throwable cause)\n    {\n        super(message, cause);\n    }\n\n    /**\n     * Creates an exception, setting the Throwable object, that caused it.\n     * @param cause the error that caused this exception.\n     */\n    public StunException(Throwable cause)\n    {\n        super(cause);\n    }\n\n    /**\n     * Sets the identifier of the error that caused the exception.\n     * @param id the identifier of the error that caused the exception.\n     */\n    public void setID(int id)\n    {\n        this.id = id;\n    }\n\n    /**\n     * Returns this exception's identifier.\n     * @return this exception's identifier;\n     */\n    public int getID()\n    {\n        return id;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 35367793L;", "docstring": "\nSerial version UID for this <tt>Serializable</tt> class.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 35367793L", "syntax_pass": true}, {"attribute_expression": "public static final int UNKNOWN_ERROR = 0;", "docstring": "\nMeans that the the reason that caused the exception was unclear.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "UNKNOWN_ERROR = 0", "syntax_pass": true}, {"attribute_expression": "public static final int ILLEGAL_STATE = 1;", "docstring": "\nIndicates that the attempted operation is not possible in the current\nstate of the object.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "ILLEGAL_STATE = 1", "syntax_pass": true}, {"attribute_expression": "public static final int ILLEGAL_ARGUMENT = 2;", "docstring": "\nIndicates that one or more of the passed arguments had invalid values.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "ILLEGAL_ARGUMENT = 2", "syntax_pass": true}, {"attribute_expression": "public static final int INTERNAL_ERROR = 3;", "docstring": "\nIndicates that an unexpected error has occurred..\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "INTERNAL_ERROR = 3", "syntax_pass": true}, {"attribute_expression": "public static final int TRANSACTION_DOES_NOT_EXIST = 3;", "docstring": "\nThrown when trying to send responses through a non-existent transaction\nThat may happen when a corresponding request has already been responded\nto or when no such request has been received.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "TRANSACTION_DOES_NOT_EXIST = 3", "syntax_pass": true}, {"attribute_expression": "public static final int NETWORK_ERROR = 4;", "docstring": "\nIndicates that an unexpected error has occurred..\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "NETWORK_ERROR = 4", "syntax_pass": true}, {"attribute_expression": "public static final int TRANSACTION_ALREADY_ANSWERED = 5;", "docstring": "\nThrown when trying to send responses through a transaction that have\nalready sent a response.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "TRANSACTION_ALREADY_ANSWERED = 5", "syntax_pass": true}, {"attribute_expression": "private int id = 0;", "docstring": "\nIdentifies the exception.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "id = 0", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent", "name": "StunMessageEvent", "file_path": "src/main/java/org/ice4j/StunMessageEvent.java", "superclasses": "BaseStunMessageEvent", "methods": ["[]StunMessageEvent(StunStack,RawMessage,Message)", "[TransportAddress]getLocalAddress()", "[TransportAddress]getRemoteAddress()", "[String]toString()", "[RawMessage]getRawMessage()"], "method_uris": ["src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent.[]StunMessageEvent(StunStack,RawMessage,Message)", "src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent.[TransportAddress]getLocalAddress()", "src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent.[TransportAddress]getRemoteAddress()", "src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent.[String]toString()", "src/main/java/org/ice4j/StunMessageEvent.java.StunMessageEvent.[RawMessage]getRawMessage()"], "overrides": null, "attributes": [], "class_docstring": "\nThe class is used to dispatch incoming stun messages. Apart from the message\nitself one could also obtain the address from where the message is coming\n(used by a server implementation to determine the mapped address)\nas well as the Descriptor of the NetAccessPoint that received it (In case the\nstack is used on more than one ports/addresses).\n\n@author Emil Ivov\n", "original_string": "public class StunMessageEvent\n    extends BaseStunMessageEvent\n{\n    /**\n     * Serial version UID for this Serializable class.\n     */\n    private static final long serialVersionUID = 41267843L;\n\n    /**\n     * The message as we got it off the wire.\n     */\n    private final RawMessage rawMessage;\n\n    /**\n     * Constructs a StunMessageEvent according to the specified message.\n     *\n     * @param stunStack the <tt>StunStack</tt> to be associated with the new\n     * instance\n     * @param rawMessage the crude message we got off the wire.\n     * @param parsedMessage the message itself\n     */\n    public StunMessageEvent(\n            StunStack stunStack,\n            RawMessage rawMessage,\n            Message parsedMessage)\n    {\n        super(stunStack, rawMessage.getLocalAddress(), parsedMessage);\n\n        this.rawMessage = rawMessage;\n    }\n\n    /**\n     * Returns a <tt>TransportAddress</tt> referencing the access point where\n     * the message was received.\n     *\n     * @return a descriptor of the access point where the message arrived.\n     */\n    public TransportAddress getLocalAddress()\n    {\n        return getSourceAddress();\n    }\n\n    /**\n     * Returns the address that sent the message.\n     *\n     * @return the address that sent the message.\n     */\n    public TransportAddress getRemoteAddress()\n    {\n        return rawMessage.getRemoteAddress();\n    }\n\n    /**\n     * Returns a <tt>String</tt> representation of this event, containing the\n     * corresponding message, remote and local addresses.\n     *\n     * @return a <tt>String</tt> representation of this event, containing the\n     * corresponding message, remote and local addresses.\n     */\n    @Override\n    public String toString()\n    {\n        StringBuffer buff = new StringBuffer(\"StunMessageEvent:\\n\\tMessage=\");\n\n        buff.append(getMessage());\n        buff.append(\" remoteAddr=\").append(getRemoteAddress());\n        buff.append(\" localAddr=\").append(getLocalAddress());\n\n        return buff.toString();\n    }\n\n    /**\n     * Returns the raw message that caused this event.\n     *\n     * @return the {@link RawMessage} that caused this event.\n     */\n    public RawMessage getRawMessage()\n    {\n        return rawMessage;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 41267843L;", "docstring": "\nSerial version UID for this Serializable class.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 41267843L", "syntax_pass": true}, {"attribute_expression": "private final RawMessage rawMessage;", "docstring": "\nThe message as we got it off the wire.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RawMessage", "name": "rawMessage", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/StunTimeoutEvent.java.StunTimeoutEvent", "name": "StunTimeoutEvent", "file_path": "src/main/java/org/ice4j/StunTimeoutEvent.java", "superclasses": "BaseStunMessageEvent", "methods": ["[]StunTimeoutEvent(StunStack,Message,TransportAddress,TransactionID)", "[TransportAddress]getLocalAddress()", "[String]toString()"], "method_uris": ["src/main/java/org/ice4j/StunTimeoutEvent.java.StunTimeoutEvent.[]StunTimeoutEvent(StunStack,Message,TransportAddress,TransactionID)", "src/main/java/org/ice4j/StunTimeoutEvent.java.StunTimeoutEvent.[TransportAddress]getLocalAddress()", "src/main/java/org/ice4j/StunTimeoutEvent.java.StunTimeoutEvent.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nThe class is used to dispatch events that occur when a STUN transaction\nexpires.\n\n@author Emil Ivov\n", "original_string": "public class StunTimeoutEvent\n    extends BaseStunMessageEvent\n{\n    /**\n     * Serial version UID for this Serializable class.\n     */\n    private static final long serialVersionUID = 41267841L;\n\n    /**\n     * Constructs a <tt>StunTimeoutEvent</tt> according to the specified\n     * message.\n     *\n     * @param stunStack the <tt>StunStack</tt> to be associated with the new\n     * instance\n     * @param message the message itself\n     * @param localAddress the local address that the message was sent from.\n     * @param transactionID the ID of the  associated with this event.\n     */\n    public StunTimeoutEvent(\n            StunStack stunStack,\n            Message message,\n            TransportAddress localAddress,\n            TransactionID transactionID)\n    {\n        super(stunStack, localAddress, message);\n\n        setTransactionID(transactionID);\n    }\n\n    /**\n     * Returns the <tt>TransportAddress</tt> that the message was supposed to\n     * leave from.\n     *\n     * @return the <tt>TransportAddress</tt> that the message was supposed to\n     * leave from.\n     */\n    public TransportAddress getLocalAddress()\n    {\n        return getSourceAddress();\n    }\n\n    /**\n     * Returns a <tt>String</tt> representation of this event, containing the\n     * corresponding message, and local address.\n     *\n     * @return a <tt>String</tt> representation of this event, containing the\n     * corresponding message, and local address.\n     */\n    @Override\n    public String toString()\n    {\n        StringBuffer buff = new StringBuffer(\"StunTimeoutEvent:\\n\\tMessage=\");\n\n        buff.append(getMessage());\n        buff.append(\" localAddr=\").append(getLocalAddress());\n\n        return buff.toString();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 41267841L;", "docstring": "\nSerial version UID for this Serializable class.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 41267841L", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/StackProperties.java.StackProperties", "name": "StackProperties", "file_path": "src/main/java/org/ice4j/StackProperties.java", "superclasses": "", "methods": ["[String]getString(String)", "[String[]]getStringArray(String,String)", "[int]getInt(String,int)", "[boolean]getBoolean(String,boolean)"], "method_uris": ["src/main/java/org/ice4j/StackProperties.java.StackProperties.[String]getString(String)", "src/main/java/org/ice4j/StackProperties.java.StackProperties.[String[]]getStringArray(String,String)", "src/main/java/org/ice4j/StackProperties.java.StackProperties.[int]getInt(String,int)", "src/main/java/org/ice4j/StackProperties.java.StackProperties.[boolean]getBoolean(String,boolean)"], "overrides": null, "attributes": [], "class_docstring": "\nThe class contains a number of property names and their default values that\nwe use to configure the behavior of the ice4j stack.\n\n@author Emil Ivov\n", "original_string": "public class StackProperties\n{\n    /**\n     * Our class logger.\n     */\n    private static final Logger logger\n        = Logger.getLogger(StackProperties.class.getName());\n\n    /**\n     * The name of the property containing the number of binds that we should\n     * should execute in case a port is already bound to (each retry would be on\n     * a new random port).\n     */\n    public static final String BIND_RETRIES = \"org.ice4j.BIND_RETRIES\";\n\n    /**\n     * The default number of binds that we would try\n     * implementation should execute in case a port is already bound to (each\n     * retry would be on a different port).\n     */\n    public static final int BIND_RETRIES_DEFAULT_VALUE = 50;\n\n    /**\n     * The name of the property that tells if we should bind to the\n     * wildcard address instead of the (usually more specific) harvest candidate\n     * addresses.\n     *\n     * The wildcard is a special local IP address. It usually means \"any\".\n     */\n    public static final String BIND_WILDCARD = \"org.ice4j.BIND_WILDCARD\";\n\n    /**\n     * The number of milliseconds a client transaction should wait before\n     * retransmitting, after it has sent a request for the first time.\n     */\n    public static final String FIRST_CTRAN_RETRANS_AFTER\n                                        = \"org.ice4j.FIRST_CTRAN_RETRANS_AFTER\";\n\n    /**\n     * The maximum number of milliseconds that an exponential client\n     * retransmission timer can reach.\n     */\n    public static final String MAX_CTRAN_RETRANS_TIMER\n                                    = \"org.ice4j.MAX_CTRAN_RETRANS_TIMER\";\n\n    /**\n     * Indicates whether a client transaction should be kept after a response\n     * is received rather than destroying it which is the default.\n     */\n    public static final String KEEP_CRANS_AFTER_A_RESPONSE\n                                = \"org.ice4j.KEEP_CRANS_AFTER_A_RESPONSE\";\n\n    /**\n     * The maximum number of retransmissions a client transaction should send.\n     */\n    public static final String MAX_CTRAN_RETRANSMISSIONS\n                                = \"org.ice4j.MAX_RETRANSMISSIONS\";\n\n    /**\n     * The name of the property that tells the stack whether or not it should\n     * let the application see retransmissions of incoming requests.\n     */\n    public static final String PROPAGATE_RECEIVED_RETRANSMISSIONS\n                        = \"org.ice4j.PROPAGATE_RECEIVED_RETRANSMISSIONS\";\n\n    /**\n     * A property that allows us to specify whether we would expect link local\n     * IPv6 addresses to be able to reach globally routable ones.\n     */\n    public static final String ALLOW_LINK_TO_GLOBAL_REACHABILITY\n                                = \"org.ice4j.ALLOW_LINK_TO_GLOBAL_REACHABILITY\";\n\n    /**\n     * The name of the property that allows us to tell the stack to always\n     * sign STUN messages with a FINGERPRINT attribute.\n     */\n    public static final String ALWAYS_SIGN\n                                = \"org.ice4j.ALWAYS_SIGN\";\n\n    /**\n     * Tells the stack whether to reject all incoming requests that do not\n     * carry a MESSAGE-INTEGRITY header.\n     */\n    public static final String REQUIRE_MESSAGE_INTEGRITY\n                                    = \"org.ice4j.REQUIRE_MESSAGE_INTEGRITY\";\n\n    /**\n     * The name of the property that can be used to disable STUN keep alives.\n     * Set to <tt>true</tt> to disable.\n     */\n    public static final String NO_KEEP_ALIVES = \"org.ice4j.NO_KEEP_ALIVES\";\n\n    /**\n     * Returns the String value of the specified property (minus all\n     * encompassing whitespaces)and null in case no property value was mapped\n     * against the specified propertyName, or in case the returned property\n     * string had zero length or contained whitespaces only.\n     *\n     * @param propertyName the name of the property that is being queried.\n     *\n     * @return the result of calling the property's toString method and null in\n     * case there was no value mapped against the specified\n     * <tt>propertyName</tt>, or the returned string had zero length or\n     * contained whitespaces only.\n     */\n    public static String getString(String propertyName)\n    {\n        Object obj = System.getProperty(propertyName);\n        String str;\n\n        if (obj == null)\n        {\n            str = null;\n        }\n        else\n        {\n            str = obj.toString().trim();\n            if (str.length() == 0)\n                str = null;\n        }\n        return str;\n    }\n\n    /**\n     * Returns the String array of the specified property, or null in case\n     * the returned property string array had zero length.\n     *\n     * @param propertyName the name of the property that is being queried.\n     * @param  regex the delimiting regular expression\n     *\n     * @return  the array of strings computed by splitting the specified\n     * property value around matches of the given regular expression\n     */\n    public static String[] getStringArray(String propertyName, String regex)\n    {\n        String str = getString(propertyName);\n        if (str == null)\n            return null;\n\n        String[] parts = str.split(regex);\n\n        // Remove mal-formatted entries.\n        List<String> res = new ArrayList<>();\n        for (String s : parts)\n            if (s != null && s.trim().length() != 0)\n                res.add(s);\n\n        if (res.size() == 0)\n            return null;\n\n        return res.toArray(new String[res.size()]);\n    }\n\n    /**\n     * Returns the value of a specific property as a signed decimal integer. If\n     * a property with the specified property name exists, its string\n     * representation is parsed into a signed decimal integer according to the\n     * rules of {@link Integer#parseInt(String)}. If parsing the value as a\n     * signed decimal integer fails or there is no value associated with the\n     * specified property name, <tt>defaultValue</tt> is returned.\n     *\n     * @param propertyName the name of the property to get the value of as a\n     * signed decimal integer\n     * @param defaultValue the value to be returned if parsing the value of the\n     * specified property name as a signed decimal integer fails or there is no\n     * value associated with the specified property name in the System\n     * properties.\n     * @return the value of the property with the specified name in the System\n     * properties as a signed decimal integer;\n     * <tt>defaultValue</tt> if parsing the value of the specified property name\n     * fails or no value is associated among the System properties.\n     */\n    public static int getInt(String propertyName, int defaultValue)\n    {\n        String stringValue = getString(propertyName);\n        int intValue = defaultValue;\n\n        if ((stringValue != null) && (stringValue.length() > 0))\n        {\n            try\n            {\n                intValue = Integer.parseInt(stringValue);\n            }\n            catch (NumberFormatException ex)\n            {\n                logger.log(\n                        Level.FINE,\n                        propertyName + \" does not appear to be an integer. \"\n                            + \"Defaulting to \" + defaultValue + \".\",\n                        ex);\n            }\n        }\n        return intValue;\n    }\n\n    /**\n     * Gets the value of a specific property as a <tt>boolean</tt>. If the\n     * specified property name is associated with a value, the string\n     * representation of the value is parsed into a <tt>boolean</tt> according\n     * to the rules of {@link Boolean#parseBoolean(String)} . Otherwise,\n     * <tt>defaultValue</tt> is returned.\n     *\n     * @param propertyName the name of the property to get the value of as a\n     * <tt>boolean</tt>\n     * @param defaultValue the value to be returned if the specified property\n     * name is not associated with a value\n     * @return the value of the property with the specified name as a\n     * <tt>boolean</tt>; <tt>defaultValue</tt> if the property with the\n     * specified name is not associated with a value\n     */\n    public static boolean getBoolean(String propertyName, boolean defaultValue)\n    {\n        String str = getString(propertyName);\n\n        return (str == null) ? defaultValue : Boolean.parseBoolean(str);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(StackProperties.class.getName());", "docstring": "\nOur class logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(StackProperties.class.getName())", "syntax_pass": true}, {"attribute_expression": "public static final String BIND_RETRIES = \"org.ice4j.BIND_RETRIES\";", "docstring": "\nThe name of the property containing the number of binds that we should\nshould execute in case a port is already bound to (each retry would be on\na new random port).\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "BIND_RETRIES = \"org.ice4j.BIND_RETRIES\"", "syntax_pass": true}, {"attribute_expression": "public static final int BIND_RETRIES_DEFAULT_VALUE = 50;", "docstring": "\nThe default number of binds that we would try\nimplementation should execute in case a port is already bound to (each\nretry would be on a different port).\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "BIND_RETRIES_DEFAULT_VALUE = 50", "syntax_pass": true}, {"attribute_expression": "public static final String BIND_WILDCARD = \"org.ice4j.BIND_WILDCARD\";", "docstring": "\nThe name of the property that tells if we should bind to the\nwildcard address instead of the (usually more specific) harvest candidate\naddresses.\n\nThe wildcard is a special local IP address. It usually means \"any\".\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "BIND_WILDCARD = \"org.ice4j.BIND_WILDCARD\"", "syntax_pass": true}, {"attribute_expression": "public static final String FIRST_CTRAN_RETRANS_AFTER\n                                        = \"org.ice4j.FIRST_CTRAN_RETRANS_AFTER\";", "docstring": "\nThe number of milliseconds a client transaction should wait before\nretransmitting, after it has sent a request for the first time.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "FIRST_CTRAN_RETRANS_AFTER\n                                        = \"org.ice4j.FIRST_CTRAN_RETRANS_AFTER\"", "syntax_pass": true}, {"attribute_expression": "public static final String MAX_CTRAN_RETRANS_TIMER\n                                    = \"org.ice4j.MAX_CTRAN_RETRANS_TIMER\";", "docstring": "\nThe maximum number of milliseconds that an exponential client\nretransmission timer can reach.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "MAX_CTRAN_RETRANS_TIMER\n                                    = \"org.ice4j.MAX_CTRAN_RETRANS_TIMER\"", "syntax_pass": true}, {"attribute_expression": "public static final String KEEP_CRANS_AFTER_A_RESPONSE\n                                = \"org.ice4j.KEEP_CRANS_AFTER_A_RESPONSE\";", "docstring": "\nIndicates whether a client transaction should be kept after a response\nis received rather than destroying it which is the default.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "KEEP_CRANS_AFTER_A_RESPONSE\n                                = \"org.ice4j.KEEP_CRANS_AFTER_A_RESPONSE\"", "syntax_pass": true}, {"attribute_expression": "public static final String MAX_CTRAN_RETRANSMISSIONS\n                                = \"org.ice4j.MAX_RETRANSMISSIONS\";", "docstring": "\nThe maximum number of retransmissions a client transaction should send.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "MAX_CTRAN_RETRANSMISSIONS\n                                = \"org.ice4j.MAX_RETRANSMISSIONS\"", "syntax_pass": true}, {"attribute_expression": "public static final String PROPAGATE_RECEIVED_RETRANSMISSIONS\n                        = \"org.ice4j.PROPAGATE_RECEIVED_RETRANSMISSIONS\";", "docstring": "\nThe name of the property that tells the stack whether or not it should\nlet the application see retransmissions of incoming requests.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "PROPAGATE_RECEIVED_RETRANSMISSIONS\n                        = \"org.ice4j.PROPAGATE_RECEIVED_RETRANSMISSIONS\"", "syntax_pass": true}, {"attribute_expression": "public static final String ALLOW_LINK_TO_GLOBAL_REACHABILITY\n                                = \"org.ice4j.ALLOW_LINK_TO_GLOBAL_REACHABILITY\";", "docstring": "\nA property that allows us to specify whether we would expect link local\nIPv6 addresses to be able to reach globally routable ones.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "ALLOW_LINK_TO_GLOBAL_REACHABILITY\n                                = \"org.ice4j.ALLOW_LINK_TO_GLOBAL_REACHABILITY\"", "syntax_pass": true}, {"attribute_expression": "public static final String ALWAYS_SIGN\n                                = \"org.ice4j.ALWAYS_SIGN\";", "docstring": "\nThe name of the property that allows us to tell the stack to always\nsign STUN messages with a FINGERPRINT attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "ALWAYS_SIGN\n                                = \"org.ice4j.ALWAYS_SIGN\"", "syntax_pass": true}, {"attribute_expression": "public static final String REQUIRE_MESSAGE_INTEGRITY\n                                    = \"org.ice4j.REQUIRE_MESSAGE_INTEGRITY\";", "docstring": "\nTells the stack whether to reject all incoming requests that do not\ncarry a MESSAGE-INTEGRITY header.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "REQUIRE_MESSAGE_INTEGRITY\n                                    = \"org.ice4j.REQUIRE_MESSAGE_INTEGRITY\"", "syntax_pass": true}, {"attribute_expression": "public static final String NO_KEEP_ALIVES = \"org.ice4j.NO_KEEP_ALIVES\";", "docstring": "\nThe name of the property that can be used to disable STUN keep alives.\nSet to <tt>true</tt> to disable.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NO_KEEP_ALIVES = \"org.ice4j.NO_KEEP_ALIVES\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/StunFailureEvent.java.StunFailureEvent", "name": "StunFailureEvent", "file_path": "src/main/java/org/ice4j/StunFailureEvent.java", "superclasses": "BaseStunMessageEvent", "methods": ["[]StunFailureEvent(StunStack,Message,TransportAddress,Throwable)", "[TransportAddress]getLocalAddress()", "[Throwable]getCause()", "[String]toString()"], "method_uris": ["src/main/java/org/ice4j/StunFailureEvent.java.StunFailureEvent.[]StunFailureEvent(StunStack,Message,TransportAddress,Throwable)", "src/main/java/org/ice4j/StunFailureEvent.java.StunFailureEvent.[TransportAddress]getLocalAddress()", "src/main/java/org/ice4j/StunFailureEvent.java.StunFailureEvent.[Throwable]getCause()", "src/main/java/org/ice4j/StunFailureEvent.java.StunFailureEvent.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nThe class is used to dispatch events that occur when a STUN transaction\nfails asynchronously for reasons like a port unreachable exception for\nexample.\n\n@author Emil Ivov\n", "original_string": "public class StunFailureEvent\n    extends BaseStunMessageEvent\n{\n    /**\n     * Serial version UID for this Serializable class.\n     */\n    private static final long serialVersionUID = 41232541L;\n\n    /**\n     * The <tt>Exception</tt> that caused this failure.\n     */\n    private final Throwable cause;\n\n    /**\n     * Constructs a <tt>StunFailureEvent</tt> according to the specified\n     * message.\n     * \n     * @param stunStack the <tt>StunStack</tt> to be associated with the new\n     * instance\n     * @param message the message itself\n     * @param localAddress the local address that the message was sent from.\n     * @param cause the <tt>Exception</tt> that caused this failure or\n     * <tt>null</tt> if there's no <tt>Exception</tt> associated with this\n     * failure\n     */\n    public StunFailureEvent(\n            StunStack stunStack,\n            Message message,\n            TransportAddress localAddress,\n            Throwable cause)\n    {\n        super(stunStack, localAddress, message);\n\n        this.cause = cause;\n    }\n\n    /**\n     * Returns the <tt>TransportAddress</tt> that the message was supposed to\n     * leave from.\n     *\n     * @return the <tt>TransportAddress</tt> that the message was supposed to\n     * leave from.\n     */\n    public TransportAddress getLocalAddress()\n    {\n        return getSourceAddress();\n    }\n\n    /**\n     * Returns the <tt>Exception</tt> that cause this failure or <tt>null</tt>\n     * if the failure is not related to an <tt>Exception</tt>.\n     *\n     * @return the <tt>Exception</tt> that cause this failure or <tt>null</tt>\n     * if the failure is not related to an <tt>Exception</tt>.\n     */\n    public Throwable getCause()\n    {\n        return cause;\n    }\n\n    /**\n     * Returns a <tt>String</tt> representation of this event, containing the\n     * corresponding message, and local address.\n     *\n     * @return a <tt>String</tt> representation of this event, containing the\n     * corresponding message, and local address.\n     */\n    @Override\n    public String toString()\n    {\n        StringBuffer buff = new StringBuffer(\"StunFailureEvent:\\n\\tMessage=\");\n\n        buff.append(getMessage());\n        buff.append(\" localAddr=\").append(getLocalAddress());\n\n        return buff.toString();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 41232541L;", "docstring": "\nSerial version UID for this Serializable class.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 41232541L", "syntax_pass": true}, {"attribute_expression": "private final Throwable cause;", "docstring": "\nThe <tt>Exception</tt> that caused this failure.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Throwable", "name": "cause", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/StunResponseEvent.java.StunResponseEvent", "name": "StunResponseEvent", "file_path": "src/main/java/org/ice4j/StunResponseEvent.java", "superclasses": "StunMessageEvent", "methods": ["[]StunResponseEvent(StunStack,RawMessage,Response,Request,TransactionID)", "[Request]getRequest()", "[Response]getResponse()"], "method_uris": ["src/main/java/org/ice4j/StunResponseEvent.java.StunResponseEvent.[]StunResponseEvent(StunStack,RawMessage,Response,Request,TransactionID)", "src/main/java/org/ice4j/StunResponseEvent.java.StunResponseEvent.[Request]getRequest()", "src/main/java/org/ice4j/StunResponseEvent.java.StunResponseEvent.[Response]getResponse()"], "overrides": null, "attributes": [], "class_docstring": "\nThe class is used to dispatch incoming STUN {@link Response}s. Apart from\nthe {@link Response} itself this event also carries a reference to the\n{@link Request} that started the corresponding transaction as well as other\nuseful things.\n\n@author Emil Ivov\n", "original_string": "public class StunResponseEvent\n    extends StunMessageEvent\n{\n    /**\n     * Serial version UID for this Serializable class.\n     */\n    private static final long serialVersionUID = -1L;\n\n    /**\n     * The original {@link Request} that started the client transaction that\n     * the {@link Response} carried in this event belongs to.\n     */\n    private final Request request;\n\n    /**\n     * Creates a new instance of this event.\n     *\n     * @param stunStack the <tt>StunStack</tt> to be associated with the new\n     * instance\n     * @param rawMessage the crude message we got off the wire.\n     * @param response the STUN {@link Response} that we've just received.\n     * @param request  the message itself\n     * @param transactionID a reference to the exact {@link TransactionID}\n     * instance that represents the corresponding client transaction.\n     */\n    public StunResponseEvent(\n            StunStack stunStack,\n            RawMessage rawMessage,\n            Response response,\n            Request request,\n            TransactionID transactionID)\n    {\n        super(stunStack, rawMessage, response);\n        this.request = request;\n        super.setTransactionID(transactionID);\n    }\n\n    /**\n     * Returns the {@link Request} that started the transaction that this\n     * {@link Response} has just arrived in.\n     *\n     * @return the {@link Request} that started the transaction that this\n     * {@link Response} has just arrived in.\n     */\n    public Request getRequest()\n    {\n        return request;\n    }\n\n    /**\n     * Returns the {@link Response} that has just arrived and that caused this\n     * event.\n     *\n     * @return  the {@link Response} that has just arrived and that caused this\n     * event.\n     */\n    public Response getResponse()\n    {\n        return (Response)getMessage();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -1L;", "docstring": "\nSerial version UID for this Serializable class.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -1L", "syntax_pass": true}, {"attribute_expression": "private final Request request;", "docstring": "\nThe original {@link Request} that started the client transaction that\nthe {@link Response} carried in this event belongs to.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Request", "name": "request", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent", "name": "ChannelDataMessageEvent", "file_path": "src/main/java/org/ice4j/ChannelDataMessageEvent.java", "superclasses": "EventObject", "methods": ["[]ChannelDataMessageEvent(StunStack,TransportAddress,TransportAddress,ChannelData)", "[ChannelData]getChannelDataMessage()", "[TransportAddress]getRemoteAddress()", "[TransportAddress]getLocalAddress()", "[StunStack]getStunStack()"], "method_uris": ["src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent.[]ChannelDataMessageEvent(StunStack,TransportAddress,TransportAddress,ChannelData)", "src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent.[ChannelData]getChannelDataMessage()", "src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent.[TransportAddress]getRemoteAddress()", "src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent.[TransportAddress]getLocalAddress()", "src/main/java/org/ice4j/ChannelDataMessageEvent.java.ChannelDataMessageEvent.[StunStack]getStunStack()"], "overrides": null, "attributes": [], "class_docstring": "\nThe class is used to dispatch incoming ChannelData messages. Apart from the\nmessage itself one could also obtain the address from where the message is\ncoming (used by a server implementation to determine the mapped address) as\nwell as the Descriptor of the NetAccessPoint that received it (In case the\nstack is used on more than one ports/addresses).\n\n@author Aakash Garg\n", "original_string": "public class ChannelDataMessageEvent\n    extends EventObject\n{\n    /**\n     * A dummy version UID to suppress warnings.\n     */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * The <tt>StunStack</tt> associated with this instance.\n     */\n    private final StunStack stunStack;\n\n    /**\n     * Remote address causing this event.\n     */\n    private final TransportAddress remoteAddress;\n\n    /**\n     * Local address receiving this event.\n     */\n    private final TransportAddress localAddress;\n    \n    /**\n     * The ChannelData <tt>Message</tt> associated with this event.\n     */\n    private final ChannelData channelDataMessage;\n\n    /**\n     * Initializes a new <tt>ChannelDataMessageEvent</tt> associated with a\n     * specific ChannelData <tt>Message</tt>.\n     * \n     * @param stunStack the <tt>StunStack</tt> to be associated with the new\n     *            instance.\n     * @param remoteAddress the <tt>TransportAddress</tt> which is to be\n     *            reported as the source of the new event.\n     * @param localAddress the <tt>TransportAddress</tt> which is to be reported\n     *            as the receiving location of the new event.\n     * @param channelDataMessage the ChannelData <tt>Message</tt> associated\n     *            with the new event.\n     */\n    public ChannelDataMessageEvent(StunStack stunStack,\n        TransportAddress remoteAddress,\n        TransportAddress localAddress,\n        ChannelData channelDataMessage)\n    {\n        super(remoteAddress);\n        \n        this.remoteAddress = remoteAddress;\n        this.localAddress = localAddress;\n        this.stunStack = stunStack;\n        this.channelDataMessage = channelDataMessage;\n    }\n\n    /**\n     * Gets the ChannelData <tt>Message</tt> associated with this event.\n     * \n     * @return the ChannelData <tt>Message</tt> associated with this event\n     */\n    public ChannelData getChannelDataMessage()\n    {\n        return channelDataMessage;\n    }\n\n    /**\n     * Gets the <tt>TransportAddress</tt> which is the remote address of this\n     * event.\n     * \n     * @return the <tt>TransportAddress</tt> which is the address who caused\n     *         this event\n     */\n    public TransportAddress getRemoteAddress()\n    {\n        return this.remoteAddress;\n    }\n\n    /**\n     * Gets the <tt>TransportAddress</tt> which is local address on which this\n     * event was received.\n     * \n     * @return the <tt>TransportAddress</tt> which is local address on which\n     *         this event was received.\n     */\n    public TransportAddress getLocalAddress()\n    {\n        return this.localAddress;\n    }\n\n    /**\n     * Gets the <tt>StunStack</tt> associated with this instance.\n     * \n     * @return the <tt>StunStack</tt> associated with this instance\n     */\n    public StunStack getStunStack()\n    {\n        return stunStack;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "\nA dummy version UID to suppress warnings.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "private final StunStack stunStack;", "docstring": "\nThe <tt>StunStack</tt> associated with this instance.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StunStack", "name": "stunStack", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress remoteAddress;", "docstring": "\nRemote address causing this event.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "remoteAddress", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress localAddress;", "docstring": "\nLocal address receiving this event.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "localAddress", "syntax_pass": true}, {"attribute_expression": "private final ChannelData channelDataMessage;", "docstring": "\nThe ChannelData <tt>Message</tt> associated with this event.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ChannelData", "name": "channelDataMessage", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent", "name": "PeerUdpMessageEvent", "file_path": "src/main/java/org/ice4j/PeerUdpMessageEvent.java", "superclasses": "EventObject", "methods": ["[]PeerUdpMessageEvent(StunStack,RawMessage)", "[byte[]]getBytes()", "[int]getMessageLength()", "[TransportAddress]getRemoteAddress()", "[TransportAddress]getLocalAddress()", "[StunStack]getStunStack()"], "method_uris": ["src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent.[]PeerUdpMessageEvent(StunStack,RawMessage)", "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent.[byte[]]getBytes()", "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent.[int]getMessageLength()", "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent.[TransportAddress]getRemoteAddress()", "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent.[TransportAddress]getLocalAddress()", "src/main/java/org/ice4j/PeerUdpMessageEvent.java.PeerUdpMessageEvent.[StunStack]getStunStack()"], "overrides": null, "attributes": [], "class_docstring": "\nThe class is used to dispatch incoming UDP peer messages. Apart from the\nmessage itself one could also obtain the address from where the message is\ncoming (used by a server implementation to determine the mapped address) as\nwell as the Descriptor of the NetAccessPoint that received it (In case the\nstack is used on more than one ports/addresses).\n\n@author Aakash Garg\n", "original_string": "public class PeerUdpMessageEvent\n    extends EventObject\n{\n    /**\n     * A dummy version UID to suppress warnings.\n     */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * The <tt>StunStack</tt> associated with this instance.\n     */\n    private final StunStack stunStack;\n\n    /**\n     * The Peer UDP <tt>Message</tt> associated with this event. Stored as a\n     * RawMessage.\n     */\n    private final RawMessage udpMessage;\n\n    /**\n     * Initializes a new <tt>PeerUdpMessageEvent</tt> associated with a\n     * specific PeerUdp <tt>Message</tt>.\n     * \n     * @param stunStack the <tt>StunStack</tt> to be associated with the new\n     *            instance.\n     * @param udpMessage the Peer UDP <tt>Message</tt> associated\n     *            with the new event.\n     */\n    public PeerUdpMessageEvent(StunStack stunStack, RawMessage udpMessage)\n    {\n        super(udpMessage.getRemoteAddress());\n        \n        this.stunStack = stunStack;\n        this.udpMessage = udpMessage;\n    }\n\n    /**\n     * Returns the message itself.\n     * \n     * @return a binary array containing the message data.\n     */\n    public byte[] getBytes()\n    {\n        return this.udpMessage.getBytes();\n    }\n\n    /**\n     * Returns the message length.\n     * \n     * @return a the length of the message.\n     */\n    public int getMessageLength()\n    {\n        return this.udpMessage.getMessageLength();\n    }\n\n    /**\n     * Returns the address and port of the host that sent the message\n     * \n     * @return the [address]:[port] pair that sent the message.\n     */\n    public TransportAddress getRemoteAddress()\n    {\n        return this.udpMessage.getRemoteAddress();\n    }\n\n    /**\n     * Returns the address that this message was received on.\n     * \n     * @return the address that this message was received on.\n     */\n    public TransportAddress getLocalAddress()\n    {\n        return this.udpMessage.getLocalAddress();\n    }\n    \n    /**\n     * Gets the <tt>StunStack</tt> associated with this instance.\n     * \n     * @return the <tt>StunStack</tt> associated with this instance\n     */\n    public StunStack getStunStack()\n    {\n        return stunStack;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "\nA dummy version UID to suppress warnings.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "private final StunStack stunStack;", "docstring": "\nThe <tt>StunStack</tt> associated with this instance.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StunStack", "name": "stunStack", "syntax_pass": true}, {"attribute_expression": "private final RawMessage udpMessage;", "docstring": "\nThe Peer UDP <tt>Message</tt> associated with this event. Stored as a\nRawMessage.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RawMessage", "name": "udpMessage", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent", "name": "BaseStunMessageEvent", "file_path": "src/main/java/org/ice4j/BaseStunMessageEvent.java", "superclasses": "EventObject", "methods": ["[]BaseStunMessageEvent(StunStack,TransportAddress,Message)", "[Message]getMessage()", "[TransportAddress]getSourceAddress()", "[StunStack]getStunStack()", "[TransactionID]getTransactionID()", "[void]setTransactionID(TransactionID)"], "method_uris": ["src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent.[]BaseStunMessageEvent(StunStack,TransportAddress,Message)", "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent.[Message]getMessage()", "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent.[TransportAddress]getSourceAddress()", "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent.[StunStack]getStunStack()", "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent.[TransactionID]getTransactionID()", "src/main/java/org/ice4j/BaseStunMessageEvent.java.BaseStunMessageEvent.[void]setTransactionID(TransactionID)"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents an <tt>EventObject</tt> which notifies of an event associated with\na specific STUN <tt>Message</tt>.\n\n@author Lyubomir Marinov\n", "original_string": "public class BaseStunMessageEvent\n    extends EventObject\n{\n    /**\n     * A dummy version UID to suppress warnings.\n     */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * The STUN <tt>Message</tt> associated with this event.\n     */\n    private final Message message;\n\n    /**\n     * The <tt>StunStack</tt> associated with this instance.\n     */\n    private final StunStack stunStack;\n\n    /**\n     * The ID of the transaction related to {@link #message}.\n     */\n    private TransactionID transactionID = null;\n\n    /**\n     * Initializes a new <tt>BaseStunMessageEvent</tt> associated with a\n     * specific STUN <tt>Message</tt>.\n     *\n     * @param stunStack the <tt>StunStack</tt> to be associated with the new\n     * instance\n     * @param sourceAddress the <tt>TransportAddress</tt> which is to be\n     * reported as the source of the new event\n     * @param message the STUN <tt>Message</tt> associated with the new event\n     */\n    public BaseStunMessageEvent(\n            StunStack stunStack,\n            TransportAddress sourceAddress,\n            Message message)\n    {\n        super(sourceAddress);\n\n        this.stunStack = stunStack;\n        this.message = message;\n    }\n\n    /**\n     * Gets the STUN <tt>Message</tt> associated with this event.\n     *\n     * @return the STUN <tt>Message</tt> associated with this event\n     */\n    public Message getMessage()\n    {\n        return message;\n    }\n\n    /**\n     * Gets the <tt>TransportAddress</tt> which is the source of this event.\n     *\n     * @return the <tt>TransportAddress</tt> which is the source of this event\n     */\n    protected TransportAddress getSourceAddress()\n    {\n        return (TransportAddress) getSource();\n    }\n\n    /**\n     * Gets the <tt>StunStack</tt> associated with this instance.\n     *\n     * @return the <tt>StunStack</tt> associated with this instance\n     */\n    public StunStack getStunStack()\n    {\n        return stunStack;\n    }\n\n    /**\n     * Gets the ID of the transaction related to the STUN <tt>Message</tt>\n     * associated with this event.\n     *\n     * @return the ID of the transaction related to the STUN <tt>Message</tt>\n     * associated with this event\n     */\n    public TransactionID getTransactionID()\n    {\n        if (transactionID == null)\n        {\n            transactionID\n                = TransactionID.createTransactionID(\n                        getStunStack(),\n                        getMessage().getTransactionID());\n        }\n        return transactionID;\n    }\n\n    /**\n     * Allows descendants of this class to set the transaction ID so that we\n     * don't need to look it up later. This is not mandatory.\n     *\n     * @param tranID the ID of the transaction associated with this event.\n     */\n    protected void setTransactionID(TransactionID tranID)\n    {\n        this.transactionID = tranID;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "\nA dummy version UID to suppress warnings.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "private final Message message;", "docstring": "\nThe STUN <tt>Message</tt> associated with this event.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Message", "name": "message", "syntax_pass": true}, {"attribute_expression": "private final StunStack stunStack;", "docstring": "\nThe <tt>StunStack</tt> associated with this instance.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StunStack", "name": "stunStack", "syntax_pass": true}, {"attribute_expression": "private TransactionID transactionID = null;", "docstring": "\nThe ID of the transaction related to {@link #message}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransactionID", "name": "transactionID = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/TransportAddress.java.TransportAddress", "name": "TransportAddress", "file_path": "src/main/java/org/ice4j/TransportAddress.java", "superclasses": "InetSocketAddress", "methods": ["[]TransportAddress(String,int,Transport)", "[]TransportAddress(byte[],int,Transport)", "[]TransportAddress(InetSocketAddress,Transport)", "[]TransportAddress(InetAddress,int,Transport)", "[byte[]]getAddressBytes()", "[String]toString()", "[String]toRedactedString()", "[String]toString(boolean)", "[String]getHostAddress()", "[String]getRedactedAddress()", "[Transport]getTransport()", "[boolean]equals(TransportAddress)", "[boolean]equalsTransportAddress(Object)", "[boolean]isIPv6()", "[boolean]canReach(TransportAddress)", "[String]redact(InetAddress)", "[String]redact(SocketAddress)", "[String]toRedactedString(InetAddress)"], "method_uris": ["src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[]TransportAddress(String,int,Transport)", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[]TransportAddress(byte[],int,Transport)", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[]TransportAddress(InetSocketAddress,Transport)", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[]TransportAddress(InetAddress,int,Transport)", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[byte[]]getAddressBytes()", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]toString()", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]toRedactedString()", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]toString(boolean)", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]getHostAddress()", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]getRedactedAddress()", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[Transport]getTransport()", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[boolean]equals(TransportAddress)", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[boolean]equalsTransportAddress(Object)", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[boolean]isIPv6()", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[boolean]canReach(TransportAddress)", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]redact(InetAddress)", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]redact(SocketAddress)", "src/main/java/org/ice4j/TransportAddress.java.TransportAddress.[String]toRedactedString(InetAddress)"], "overrides": null, "attributes": [], "class_docstring": "\nThe Address class is used to define destinations to outgoing Stun Packets.\n\n@author Emil Ivov\n@author Lubomir Marinov\n", "original_string": "public class TransportAddress\n    extends InetSocketAddress\n{\n    /**\n     * our serial version UID;\n     */\n    private static final long serialVersionUID = 5076001401234631237L;\n\n    /**\n     * The variable that we are using to store the transport that this address\n     * is pertaining to.\n     */\n    private final Transport transport;\n\n    /**\n     * Creates an address instance address from an IP address and a port number.\n     * <p>\n     * A valid port value is between 0 and 65535.\n     * A port number of <tt>zero</tt> will let the system pick up an\n     * ephemeral port in a <tt>bind</tt> operation.\n     * <P>\n     * A <tt>null</tt> address will assign the <i>wildcard</i> address.\n     * <p>\n     * @param   hostname    The IP address\n     * @param   port        The port number\n     * @param   transport   The transport that this address would be bound to.\n     * @throws IllegalArgumentException if the port parameter is outside the\n     * specified range of valid port values.\n     */\n    public TransportAddress(String hostname, int port, Transport transport)\n    {\n        super(hostname, port);\n\n        this.transport = transport;\n    }\n\n    /**\n     * Creates an address instance address from a byte array containing an IP\n     * address and a port number.\n     * <p>\n     * A valid port value is between 0 and 65535.\n     * A port number of <tt>zero</tt> will let the system pick up an\n     * ephemeral port in a <tt>bind</tt> operation.\n     * <P>\n     * A <tt>null</tt> address will assign the <i>wildcard</i> address.\n     * <p>\n     * @param    ipAddress The IP address\n     * @param    port      The port number\n     * @param    transport The <tt>Transport</tt> to use with this address.\n     *\n     * @throws UnknownHostException UnknownHostException  if IP address is of\n     * illegal length\n     */\n    public TransportAddress(byte[] ipAddress, int port, Transport transport)\n        throws UnknownHostException\n    {\n        this(InetAddress.getByAddress(ipAddress), port, transport);\n    }\n\n    /**\n     * Creates an address instance from an <tt>InetSocketAddress</tt>.\n     *\n     * @param    address   the address and port.\n     * @param    transport the transport to use with this address.\n     *\n     * @throws IllegalArgumentException if the port parameter is outside the\n     * range of valid port values, or if the host name parameter is\n     * <tt>null</tt>.\n     */\n    public TransportAddress(InetSocketAddress address, Transport transport)\n    {\n        this(address.getAddress(), address.getPort(), transport);\n    }\n\n    /**\n     * Creates an address instance from a host name and a port number.\n     * <p>\n     * An attempt will be made to resolve the host name into an InetAddress.\n     * If that attempt fails, the address will be flagged as <I>unresolved</I>.\n     * <p>\n     * A valid port value is between 0 and 65535. A port number of zero will\n     * let the system pick up an ephemeral port in a <tt>bind</tt> operation.\n     * <p>\n     * @param    address   the address itself\n     * @param    port      the port number\n     * @param    transport the transport to use with this address.\n     *\n     * @throws IllegalArgumentException if the port parameter is outside the\n     * range of valid port values, or if the host name parameter is\n     * <tt>null</tt>.\n     */\n    public TransportAddress(InetAddress address, int port, Transport transport)\n    {\n        super(address, port);\n\n        this.transport = transport;\n    }\n\n    /**\n     * Returns the raw IP address of this Address object. The result is in\n     * network byte order: the highest order byte of the address is in\n     * getAddress()[0].\n     *\n     * @return the raw IP address of this object.\n     */\n    public byte[] getAddressBytes()\n    {\n        return getAddress().getAddress();\n    }\n\n    /**\n     * Constructs a string representation of this InetSocketAddress. This String\n     * is constructed by calling toString() on the InetAddress and concatenating\n     * the port number (with a colon). If the address is unresolved then the\n     * part before the colon will only contain the host name.\n     *\n     * @return a string representation of this object.\n     */\n    public String toString()\n    {\n        return toString(false);\n    }\n\n    public String toRedactedString()\n    {\n        return toString(true);\n    }\n\n    private String toString(boolean redact)\n    {\n        String hostAddress;\n        if (redact)\n        {\n            hostAddress = getRedactedAddress();\n            if (hostAddress == null)\n            {\n                String hostName = getHostName();\n                if (hostName != null)\n                {\n                    /* The transport address is an unresolved hostname.  Redact the hostname. */\n                    hostAddress = \"xxxx.xxx\";\n                }\n            }\n        }\n        else\n        {\n            hostAddress = getHostAddress();\n            if (hostAddress == null)\n            {\n                hostAddress = getHostName();\n            }\n        }\n        if (hostAddress == null)\n        {\n            // The address has neither a hostName nor a hostAddress.  Shouldn't happen, but don't NPE if it does. */\n            hostAddress = \"null\";\n        }\n\n        StringBuilder bldr = new StringBuilder(hostAddress);\n\n        if (isIPv6())\n           bldr.insert(0, \"[\").append(\"]\");\n\n        bldr.append(\":\").append(getPort());\n        bldr.append(\"/\").append(getTransport());\n\n        return bldr.toString();\n    }\n\n    /**\n     * Returns the host address.\n     *\n     * @return a String part of the address\n     */\n    public String getHostAddress()\n    {\n        InetAddress addr = getAddress();\n        String addressStr\n            = addr != null ? addr.getHostAddress() : null;\n\n        if (addr instanceof Inet6Address)\n            addressStr = NetworkUtils.stripScopeID(addressStr);\n\n        return addressStr;\n    }\n\n    /* Return the host address, redacted if address redaction is enabled. */\n    public String getRedactedAddress()\n    {\n        if (AgentConfig.config.getRedactRemoteAddresses())\n        {\n            InetAddress addr = getAddress();\n            if (addr != null)\n            {\n                return toRedactedString(addr);\n            }\n            else\n            {\n                return null;\n            }\n        }\n        else\n        {\n            return getHostAddress();\n        }\n    }\n\n    /**\n     * The transport that this transport address is suggesting.\n     *\n     * @return one of the transport strings (UDP/TCP/...) defined as contants\n     * in this class.\n     */\n    public Transport getTransport()\n    {\n        return transport;\n    }\n\n    /**\n     * Determines whether this <tt>TransportAddress</tt> is value equal to a\n     * specific <tt>TransportAddress</tt>.\n     *\n     * @param transportAddress the <tt>TransportAddress</tt> to test for value\n     * equality with this <tt>TransportAddress</tt>\n     * @return <tt>true</tt> if this <tt>TransportAddress</tt> is value equal to\n     * the specified <tt>transportAddress</tt>; otherwise, <tt>false</tt>\n     * @see #equalsTransportAddress(Object)\n     */\n    public boolean equals(TransportAddress transportAddress)\n    {\n        return equalsTransportAddress(transportAddress);\n    }\n\n    /**\n     * Compares this object against the specified object. The result is\n     * <tt>true</tt> if and only if the argument is not <tt>null</tt> and it\n     * represents the same address.\n     * <p>\n     * Two instances of <tt>TransportAddress</tt> represent the same\n     * address if both the InetAddresses (or hostnames if it is unresolved),\n     * port numbers, and <tt>Transport</tt>s are equal.\n     *\n     * If both addresses are unresolved, then the hostname, the port and\n     * the <tt>Transport</tt> are compared.\n     *\n     * @param   obj   the object to compare against.\n     * @return  <tt>true</tt> if the objects are the same and\n     * <tt>false</tt> otherwise.\n     * @see java.net.InetAddress#equals(java.lang.Object)\n     */\n    public boolean equalsTransportAddress(Object obj)\n    {\n        return super.equals(obj)\n            &&(  ((TransportAddress)obj).getTransport() == getTransport() );\n    }\n\n    /**\n     * Returns <tt>true</tt> if this is an IPv6 address and <tt>false</tt>\n     * otherwise.\n     *\n     * @return <tt>true</tt> if this is an IPv6 address and <tt>false</tt>\n     * otherwise.\n     */\n    public boolean isIPv6()\n    {\n        return getAddress() instanceof Inet6Address;\n    }\n\n    /**\n     * Determines whether this <tt>TransportAddress</tt> is theoretically\n     * capable of communicating with <tt>dst</tt>. An address is certain not\n     * to be able to communicate with another if they do not have the same\n     * <tt>Transport</tt> or family.\n     *\n     * @param dst the <tt>TransportAddress</tt> that we'd like to check for\n     * reachability from this one.\n     *\n     * @return <tt>true</tt> if this {@link TransportAddress} shares the same\n     * <tt>Transport</tt> and family as <tt>dst</tt> or <tt>false</tt>\n     * otherwise.\n     *\n     */\n    public boolean canReach(TransportAddress dst)\n    {\n        if ( getTransport() != dst.getTransport() )\n            return false;\n\n        if (isIPv6() != dst.isIPv6())\n            return false;\n\n        if (isIPv6())\n        {\n            Inet6Address srcAddr = (Inet6Address)getAddress();\n            Inet6Address dstAddr = (Inet6Address)dst.getAddress();\n\n            if (srcAddr.isLinkLocalAddress() != dstAddr.isLinkLocalAddress())\n            {\n                //this one may actually work if for example we are contacting\n                //the public address of someone in our local network. however\n                //in most cases we would also be able to reach the same address\n                //via a global address of our own and the probability of the\n                //opposite is considerably lower than the probability of us\n                //trying to reach a distant global address through one of our\n                //own. Therefore we would return false here by default.\n                return\n                    Boolean.getBoolean(\n                            StackProperties.ALLOW_LINK_TO_GLOBAL_REACHABILITY);\n            }\n        }\n\n        //may add more unreachability conditions here in the future;\n\n        return true;\n    }\n\n    public static String redact(InetAddress addr)\n    {\n        if (AgentConfig.config.getRedactRemoteAddresses())\n        {\n            return toRedactedString(addr);\n        }\n        else\n        {\n            return addr.getHostAddress();\n        }\n    }\n\n    public static String redact(SocketAddress addr)\n    {\n        if (addr instanceof InetSocketAddress && AgentConfig.config.getRedactRemoteAddresses())\n        {\n            InetSocketAddress iaddr = (InetSocketAddress)addr;\n            return toRedactedString(iaddr.getAddress()) + \":\" + iaddr.getPort();\n        }\n        else if (addr == null)\n        {\n            return null;\n        }\n        else\n        {\n            return addr.toString();\n        }\n    }\n\n    /**\n     * Return a redacted form of an InetAddress, in a form preserving its IP address family\n     * and (for IPv6) its highest-level bytes.\n     */\n    public static String toRedactedString(InetAddress addr)\n    {\n        if (addr == null)\n        {\n            return null;\n        }\n        if (addr.isAnyLocalAddress() || addr.isLoopbackAddress())\n        {\n            return addr.getHostAddress();\n        }\n        if (addr instanceof Inet6Address)\n        {\n            StringBuilder sb = new StringBuilder();\n            byte[] addrBytes = addr.getAddress();\n            if ((addrBytes[0] & 0xe0) == 0x20)\n            {\n                /* Globally-routable IPv6 address; the second nybble can indicate the\n                 * RIR that allocated the address, so don't print it.\n                 */\n                sb.append(\"2xxx\");\n            }\n            else if (addrBytes[0] != 0 || addrBytes[1] != 0)\n            {\n                /* Other IPv6 address; most common will be fc00:: unique-local and fe80:: link-local address where the\n                 * first 16 bits don't leak anything but the type; all others indicate something unexpected.\n                 */\n                sb.append(Integer.toHexString(((addrBytes[0]<<8) & 0xff00)\n                        | (addrBytes[1] & 0xff)));\n            }\n            sb.append(\"::xxx\");\n            return sb.toString();\n        }\n        else if (addr instanceof Inet4Address)\n        {\n            return \"xx.xx.xx.xx\";\n        }\n        else\n        {\n            return addr.getHostAddress();\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 5076001401234631237L;", "docstring": "\nour serial version UID;\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 5076001401234631237L", "syntax_pass": true}, {"attribute_expression": "private final Transport transport;", "docstring": "\nThe variable that we are using to store the transport that this address\nis pertaining to.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transport", "name": "transport", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory", "name": "MessageFactory", "file_path": "src/main/java/org/ice4j/message/MessageFactory.java", "superclasses": "", "methods": ["[Request]createBindingRequest()", "[Request]createBindingRequest(long)", "[Request]createBindingRequest(long,boolean,long)", "[Response]create3489BindingResponse(TransportAddress,TransportAddress,TransportAddress)", "[Response]createBindingResponse(Request,TransportAddress)", "[Response]createBindingErrorResponse(char,String,char[])", "[Response]createBindingErrorResponseUnknownAttributes(char[])", "[Response]createBindingErrorResponseUnknownAttributes(String,char[])", "[Response]createBindingErrorResponse(char,String)", "[Response]createBindingErrorResponse(char)", "[Indication]createBindingIndication()", "[Request]createAllocateRequest()", "[Request]createAllocateRequest(byte,boolean)", "[Response]createAllocationResponse(Request,TransportAddress,TransportAddress,int)", "[Response]createAllocationResponse(Request,TransportAddress,TransportAddress,byte[],int)", "[Response]createAllocationErrorResponse(char)", "[Response]createAllocationErrorResponse(char,String)", "[Request]createGoogleAllocateRequest(String)", "[void]addLongTermCredentialAttributes(Request,byte,byte,byte)", "[Request]createRefreshRequest()", "[Request]createRefreshRequest(int)", "[Response]createRefreshResponse(int)", "[Response]createRefreshErrorResponse(char)", "[Response]createRefreshErrorResponse(char,String)", "[Request]createChannelBindRequest(char,TransportAddress,byte[])", "[Response]createChannelBindResponse()", "[Response]createChannelBindErrorResponse(char)", "[Response]createChannelBindErrorResponse(char,String)", "[Request]createCreatePermissionRequest(TransportAddress,byte[])", "[Response]createCreatePermissionResponse()", "[Response]createCreatePermissionErrorResponse(char)", "[Response]createPermissionErrorResponse(char,String)", "[Indication]createSendIndication(TransportAddress,byte[],byte[])", "[Indication]createDataIndication(TransportAddress,byte[],byte[])", "[Request]createSendRequest(String,TransportAddress,byte[])", "[Request]createSharedSecretRequest()", "[Response]createSharedSecretResponse()", "[Response]createSharedSecretErrorResponse()", "[Request]createConnectRequest(TransportAddress,Request)", "[Request]createConnectRequest(TransportAddress,byte[])", "[Response]createConnectResponse(int)", "[Response]createConnectErrorResponse(char)", "[Response]createConnectErrorResponse(char,String)", "[Request]createConnectionBindRequest(int)", "[Response]createConnectionBindResponse()", "[Response]createConnectionBindErrorResponse(char)", "[Response]createConnectionBindErrorResponse(char,String)", "[Indication]createConnectionAttemptIndication(int,TransportAddress)", "[Indication]createConnectionAttemptIndication(int,TransportAddress,byte[])"], "method_uris": ["src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createBindingRequest()", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createBindingRequest(long)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createBindingRequest(long,boolean,long)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]create3489BindingResponse(TransportAddress,TransportAddress,TransportAddress)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createBindingResponse(Request,TransportAddress)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createBindingErrorResponse(char,String,char[])", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createBindingErrorResponseUnknownAttributes(char[])", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createBindingErrorResponseUnknownAttributes(String,char[])", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createBindingErrorResponse(char,String)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createBindingErrorResponse(char)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Indication]createBindingIndication()", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createAllocateRequest()", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createAllocateRequest(byte,boolean)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createAllocationResponse(Request,TransportAddress,TransportAddress,int)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createAllocationResponse(Request,TransportAddress,TransportAddress,byte[],int)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createAllocationErrorResponse(char)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createAllocationErrorResponse(char,String)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createGoogleAllocateRequest(String)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[void]addLongTermCredentialAttributes(Request,byte,byte,byte)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createRefreshRequest()", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createRefreshRequest(int)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createRefreshResponse(int)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createRefreshErrorResponse(char)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createRefreshErrorResponse(char,String)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createChannelBindRequest(char,TransportAddress,byte[])", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createChannelBindResponse()", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createChannelBindErrorResponse(char)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createChannelBindErrorResponse(char,String)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createCreatePermissionRequest(TransportAddress,byte[])", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createCreatePermissionResponse()", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createCreatePermissionErrorResponse(char)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createPermissionErrorResponse(char,String)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Indication]createSendIndication(TransportAddress,byte[],byte[])", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Indication]createDataIndication(TransportAddress,byte[],byte[])", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createSendRequest(String,TransportAddress,byte[])", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createSharedSecretRequest()", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createSharedSecretResponse()", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createSharedSecretErrorResponse()", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createConnectRequest(TransportAddress,Request)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createConnectRequest(TransportAddress,byte[])", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createConnectResponse(int)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createConnectErrorResponse(char)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createConnectErrorResponse(char,String)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Request]createConnectionBindRequest(int)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createConnectionBindResponse()", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createConnectionBindErrorResponse(char)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Response]createConnectionBindErrorResponse(char,String)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Indication]createConnectionAttemptIndication(int,TransportAddress)", "src/main/java/org/ice4j/message/MessageFactory.java.MessageFactory.[Indication]createConnectionAttemptIndication(int,TransportAddress,byte[])"], "overrides": null, "attributes": [], "class_docstring": "\nThis class provides factory methods to allow an application to create STUN\nand TURN messages from a particular implementation.\n\n@author Emil Ivov\n@author Sebastien Vincent\n@author Lubomir Marinov\n@author Aakash Garg\n", "original_string": "public class MessageFactory\n{\n\n    /**\n     * The <tt>Logger</tt> used by the <tt>MessageFactory</tt> class and its\n     * instances.\n     */\n    private static final Logger logger\n        = Logger.getLogger(MessageFactory.class.getName());\n\n    /**\n     * Creates a default binding request. The request DOES NOT contains a\n     * ChangeRequest attribute with zero change ip and change port flags.\n     *\n     * @return a default binding request.\n     */\n    public static Request createBindingRequest()\n    {\n        Request bindingRequest = new Request();\n        try\n        {\n            bindingRequest.setMessageType(Message.BINDING_REQUEST);\n        }\n        catch (IllegalArgumentException ex)\n        {\n            // there should be no exc here since we're the creators.\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n\n        /* do not add this by default */\n        /*\n         * //add a change request attribute ChangeRequestAttribute attribute =\n         * AttributeFactory.createChangeRequestAttribute();\n         *\n         * try { bindingRequest.putAttribute(attribute); } catch (StunException\n         * ex) { //shouldn't happen throw new\n         * RuntimeException(\"Failed to add a change request \"\n         * +\"attribute to a binding request!\"); }\n         */\n        return bindingRequest;\n    }\n\n    /**\n     * Creates a default binding request. The request contains a ChangeReqeust\n     * attribute with zero change ip and change port flags. It also contains the\n     * PRIORITY attribute used for ICE processing\n     *\n     * @param priority the value for the priority attribute\n     * @return a BindingRequest header with ICE PRIORITY attribute\n     * @throws StunException if we have a problem creating the request\n     */\n    public static Request createBindingRequest(long priority)\n                    throws StunException\n    {\n        Request bindingRequest = createBindingRequest();\n\n        PriorityAttribute attribute = AttributeFactory\n                        .createPriorityAttribute(priority);\n        bindingRequest.putAttribute(attribute);\n\n        return bindingRequest;\n    }\n\n    /**\n     * Creates a default binding request. The request contains a ChangeReqeust\n     * attribute with zero change ip and change port flags. It contains the\n     * PRIORITY, ICE-CONTROLLED or ICE-CONTROLLING attributes used for ICE\n     * processing\n     *\n     * @param priority the value of the ICE priority attributes\n     * @param controlling the value of the controlling attribute\n     * @param tieBreaker the value of the ICE tie breaker attribute\n     * @return a BindingRequest header with some ICE attributes (PRIORITY,\n     * ICE-CONTROLLING / ICE-CONTROLLED)\n     * @throws StunException if we have a problem creating the request\n     */\n    public static Request createBindingRequest(long priority,\n                    boolean controlling, long tieBreaker)\n                    throws StunException\n    {\n        Request bindingRequest = createBindingRequest();\n\n        PriorityAttribute attribute = AttributeFactory\n                        .createPriorityAttribute(priority);\n        bindingRequest.putAttribute(attribute);\n\n        if (controlling)\n        {\n            IceControllingAttribute iceControllingAttribute = AttributeFactory\n                            .createIceControllingAttribute(tieBreaker);\n            bindingRequest.putAttribute(iceControllingAttribute);\n        }\n        else\n        {\n            IceControlledAttribute iceControlledAttribute = AttributeFactory\n                            .createIceControlledAttribute(tieBreaker);\n            bindingRequest.putAttribute(iceControlledAttribute);\n        }\n\n        return bindingRequest;\n    }\n\n    /**\n     * Creates a BindingResponse in a 3489 compliant manner, assigning the\n     * specified values to mandatory headers.\n     *\n     * @param mappedAddress the address to assign the mappedAddressAttribute\n     * @param sourceAddress the address to assign the sourceAddressAttribute\n     * @param changedAddress the address to assign the changedAddressAttribute\n     * @return a BindingResponse assigning the specified values to mandatory\n     * headers.\n     * @throws IllegalArgumentException if there was something wrong with the\n     * way we are trying to create the response.\n     */\n    public static Response create3489BindingResponse(\n                    TransportAddress mappedAddress,\n                    TransportAddress sourceAddress,\n                    TransportAddress changedAddress)\n                    throws IllegalArgumentException\n    {\n        Response bindingResponse = new Response();\n        bindingResponse.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n\n        // mapped address\n        MappedAddressAttribute mappedAddressAttribute = AttributeFactory\n                        .createMappedAddressAttribute(mappedAddress);\n\n        // the changed address and source address attribute were removed in\n        // RFC 5389 so we should be prepared to go without them.\n\n        // source address\n        SourceAddressAttribute sourceAddressAttribute = null;\n\n        if (sourceAddress != null)\n            sourceAddressAttribute = AttributeFactory\n                            .createSourceAddressAttribute(sourceAddress);\n\n        // changed address\n        ChangedAddressAttribute changedAddressAttribute = null;\n\n        if (changedAddress != null)\n            changedAddressAttribute = AttributeFactory\n                            .createChangedAddressAttribute(changedAddress);\n\n        bindingResponse.putAttribute(mappedAddressAttribute);\n\n        // the changed address and source address attribute were removed in\n        // RFC 5389 so we should be prepared to go without them.\n\n        if (sourceAddressAttribute != null)\n            bindingResponse.putAttribute(sourceAddressAttribute);\n\n        if (changedAddressAttribute != null)\n            bindingResponse.putAttribute(changedAddressAttribute);\n\n        return bindingResponse;\n    }\n\n    /**\n     * Creates a BindingResponse in a 5389 compliant manner containing a single\n     * <tt>XOR-MAPPED-ADDRESS</tt> attribute\n     *\n     * @param request the request that created the transaction that this\n     * response will belong to.\n     * @param mappedAddress the address to assign the mappedAddressAttribute\n     * @return a BindingResponse assigning the specified values to mandatory\n     * headers.\n     * @throws IllegalArgumentException if there was something wrong with the\n     * way we are trying to create the response.\n     */\n    public static Response createBindingResponse(Request request,\n                    TransportAddress mappedAddress)\n                    throws IllegalArgumentException\n    {\n        Response bindingResponse = new Response();\n        bindingResponse.setMessageType(Message.BINDING_SUCCESS_RESPONSE);\n\n        // xor mapped address\n        XorMappedAddressAttribute xorMappedAddressAttribute = AttributeFactory\n                        .createXorMappedAddressAttribute(mappedAddress,\n                                        request.getTransactionID());\n\n        bindingResponse.putAttribute(xorMappedAddressAttribute);\n\n        return bindingResponse;\n    }\n\n    /**\n     * Creates a binding error response according to the specified error code\n     * and unknown attributes.\n     *\n     * @param errorCode the error code to encapsulate in this message\n     * @param reasonPhrase a human readable description of the error\n     * @param unknownAttributes a char[] array containing the ids of one or more\n     * attributes that had not been recognized.\n     * @throws IllegalArgumentException INVALID_ARGUMENTS if one or more of the\n     * given parameters had an invalid value.\n     *\n     * @return a binding error response message containing an error code and a\n     * UNKNOWN-ATTRIBUTES header\n     */\n    public static Response createBindingErrorResponse(char errorCode,\n                    String reasonPhrase, char[] unknownAttributes)\n        throws IllegalArgumentException\n    {\n        Response bindingErrorResponse = new Response();\n        bindingErrorResponse.setMessageType(Message.BINDING_ERROR_RESPONSE);\n\n        // init attributes\n        UnknownAttributesAttribute unknownAttributesAttribute = null;\n        ErrorCodeAttribute errorCodeAttribute = AttributeFactory\n                        .createErrorCodeAttribute(errorCode,\n                                        reasonPhrase);\n\n        bindingErrorResponse.putAttribute(errorCodeAttribute);\n\n        if (unknownAttributes != null)\n        {\n            unknownAttributesAttribute = AttributeFactory\n                            .createUnknownAttributesAttribute();\n            for (int i = 0; i < unknownAttributes.length; i++)\n            {\n                unknownAttributesAttribute\n                                .addAttributeID(unknownAttributes[i]);\n            }\n            bindingErrorResponse\n                            .putAttribute(unknownAttributesAttribute);\n        }\n\n        return bindingErrorResponse;\n    }\n\n    /**\n     * Creates a binding error response with UNKNOWN_ATTRIBUTES error code and\n     * the specified unknown attributes.\n     *\n     * @param unknownAttributes a char[] array containing the ids of one or more\n     * attributes that had not been recognized.\n     * @throws StunException INVALID_ARGUMENTS if one or more of the given\n     * parameters had an invalid value.\n     * @return a binding error response message containing an error code and a\n     * UNKNOWN-ATTRIBUTES header\n     */\n    public static Response createBindingErrorResponseUnknownAttributes(\n                    char[] unknownAttributes) throws StunException\n    {\n        return createBindingErrorResponse(\n                        ErrorCodeAttribute.UNKNOWN_ATTRIBUTE, null,\n                        unknownAttributes);\n    }\n\n    /**\n     * Creates a binding error response with UNKNOWN_ATTRIBUTES error code and\n     * the specified unknown attributes and reason phrase.\n     *\n     * @param reasonPhrase a short description of the error.\n     * @param unknownAttributes a char[] array containing the ids of one or more\n     * attributes that had not been recognized.\n     * @throws StunException INVALID_ARGUMENTS if one or more of the given\n     * parameters had an invalid value.\n     * @return a binding error response message containing an error code and a\n     * UNKNOWN-ATTRIBUTES header\n     */\n    public static Response createBindingErrorResponseUnknownAttributes(\n                    String reasonPhrase, char[] unknownAttributes)\n                    throws StunException\n    {\n        return createBindingErrorResponse(\n                        ErrorCodeAttribute.UNKNOWN_ATTRIBUTE,\n                        reasonPhrase, unknownAttributes);\n    }\n\n    /**\n     * Creates a binding error response with an ERROR-CODE attribute.\n     *\n     * @param errorCode the error code to encapsulate in this message\n     * @param reasonPhrase a human readable description of the error.\n     *\n     * @return a binding error response message containing an error code and a\n     * UNKNOWN-ATTRIBUTES header\n     */\n    public static Response createBindingErrorResponse(char errorCode,\n                    String reasonPhrase)\n    {\n        return createBindingErrorResponse(errorCode, reasonPhrase, null);\n    }\n\n    /**\n     * Creates a binding error response according to the specified error code.\n     *\n     * @param errorCode the error code to encapsulate in this message attributes\n     * that had not been recognized.\n     *\n     * @return a binding error response message containing an error code and a\n     * UNKNOWN-ATTRIBUTES header\n     */\n    public static Response createBindingErrorResponse(char errorCode)\n    {\n        return createBindingErrorResponse(errorCode, null, null);\n    }\n\n    /**\n     * Creates a default binding indication.\n     *\n     * @return a default binding indication.\n     */\n    public static Indication createBindingIndication()\n    {\n        Indication bindingIndication = new Indication();\n\n        bindingIndication.setMessageType(Message.BINDING_INDICATION);\n        return bindingIndication;\n    }\n\n    /**\n     * Create an allocate request without attribute.\n     *\n     * @return an allocate request\n     */\n    public static Request createAllocateRequest()\n    {\n        Request allocateRequest = new Request();\n\n        try\n        {\n            allocateRequest.setMessageType(Message.ALLOCATE_REQUEST);\n        }\n        catch (IllegalArgumentException ex)\n        {\n            // there should be no exc here since we're the creators.\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n        return allocateRequest;\n    }\n\n    /**\n     * Create an allocate request to allocate an even port. Attention this does\n     * not have attributes for long-term authentication.\n     *\n     * @param protocol requested protocol number\n     * @param rFlag R flag for the EVEN-PORT\n     * @return an allocation request\n     */\n    public static Request createAllocateRequest(byte protocol,\n                    boolean rFlag)\n    {\n        Request allocateRequest = new Request();\n\n        try\n        {\n            allocateRequest.setMessageType(Message.ALLOCATE_REQUEST);\n\n            /* XXX add enum somewhere for transport number */\n            if (protocol != 6 && protocol != 17)\n                throw new StunException(\"Protocol not valid!\");\n\n            // REQUESTED-TRANSPORT\n            allocateRequest.putAttribute(\n                    AttributeFactory.createRequestedTransportAttribute(\n                            protocol));\n\n            // EVEN-PORT\n            if (rFlag)\n            {\n                allocateRequest.putAttribute(\n                        AttributeFactory.createEvenPortAttribute(rFlag));\n            }\n        }\n        catch (StunException ex)\n        {\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n        return allocateRequest;\n    }\n\n    /**\n     * Creates a AllocationResponse in a 5389 compliant manner containing at\n     * most 4 attributes\n     *<br><tt>XOR-RELAYED-ADDRESS</tt> attribute\n     *<br><tt>LIFETIME</tt> attribute\n     *<br><tt>XOR-MAPPED-ADDRESS</tt> attribute\n     *\n     * @param request the request that created the transaction that this\n     * response will belong to.\n     * @param mappedAddress the address to assign the mappedAddressAttribute\n     * @param relayedAddress the address to assign the relayedAddressAttribute\n     * @param lifetime the address to assign the lifetimeAttribute\n     * @return a AllocationResponse assigning the specified values to mandatory\n     * headers.\n     * @throws IllegalArgumentException if there was something wrong with the\n     * way we are trying to create the response.\n     */\n    public static Response createAllocationResponse(\n            Request request,\n            TransportAddress mappedAddress,\n            TransportAddress relayedAddress,\n            int lifetime )\n        throws IllegalArgumentException\n    {\n        return createAllocationResponse(\n            request, mappedAddress, relayedAddress, null , lifetime);\n    }\n    \n    /**\n     * Creates a AllocationResponse in a 5389 compliant manner containing at most 4 attributes\n     *<br><tt>XOR-RELAYED-ADDRESS</tt> attribute\n     *<br><tt>LIFETIME</tt> attribute\n     *<br><tt>RESERVATION-TOKEN</tt> attribute\n     *<br><tt>XOR-MAPPED-ADDRESS</tt> attribute\n     *\n     * @param request the request that created the transaction that this\n     * response will belong to.\n     * @param mappedAddress the address to assign the mappedAddressAttribute\n     * @param relayedAddress the address to assign the relayedAddressAttribute\n     * @param token the address to assign the reservationTokenAttribute\n     * @param lifetime the address to assign the lifetimeAttribute\n     * @return a AllocationResponse assigning the specified values to mandatory\n     * headers.\n     * @throws IllegalArgumentException if there was something wrong with the\n     * way we are trying to create the response.\n     */\n    public static Response createAllocationResponse(\n            Request request,\n            TransportAddress mappedAddress,\n            TransportAddress relayedAddress,\n            byte[] token,\n            int lifetime)\n        throws IllegalArgumentException\n    {\n        Response allocationSuccessResponse = new Response();\n\n        allocationSuccessResponse.setMessageType(Message.ALLOCATE_RESPONSE);\n\n        // xor mapped address\n        XorMappedAddressAttribute xorMappedAddressAttribute\n            = AttributeFactory\n                .createXorMappedAddressAttribute(\n                        mappedAddress, request.getTransactionID());\n\n        allocationSuccessResponse.putAttribute(xorMappedAddressAttribute);\n\n        //xor relayed address\n        XorRelayedAddressAttribute xorRelayedAddressAttribute\n            = AttributeFactory\n                .createXorRelayedAddressAttribute(relayedAddress,\n                        request.getTransactionID());\n\n        allocationSuccessResponse.putAttribute(xorRelayedAddressAttribute);\n\n        //lifetime\n        LifetimeAttribute lifetimeAttribute\n            = AttributeFactory.createLifetimeAttribute(lifetime);\n\n        allocationSuccessResponse.putAttribute(lifetimeAttribute);\n        \n        if (token != null)\n        {\n            //reservation token\n            ReservationTokenAttribute reservationTokenAttribute\n                = AttributeFactory\n                    .createReservationTokenAttribute(token);\n\n            allocationSuccessResponse.putAttribute(reservationTokenAttribute);\n        }\n        \n        return allocationSuccessResponse;\n    }\n    \n    /**\n     * Creates a allocation error response according to the specified error\n     * code.\n     *\n     * @param errorCode the error code to encapsulate in this message attributes\n     * that had not been recognised.\n     *\n     * @return a allocation error response message containing an error code.\n     */\n    public static Response createAllocationErrorResponse(char errorCode)\n    {\n        return createAllocationErrorResponse(errorCode, null);\n    }\n       \n    /**\n     * Creates a allocation error response according to the specified error\n     * code.\n     *\n     * @param errorCode the error code to encapsulate in this message\n     * @param reasonPhrase a human readable description of the error\n     * attributes that had not been recognised.\n     * @throws IllegalArgumentException INVALID_ARGUMENTS if one or more of the\n     * given parameters had an invalid value.\n     *\n     * @return a allocation error response message containing an error code.\n     */\n    public static Response createAllocationErrorResponse(char errorCode,\n                        String reasonPhrase)\n    {\n        Response allocationErrorResponse = new Response();\n\n        allocationErrorResponse.setMessageType(Message.ALLOCATE_ERROR_RESPONSE);\n\n        //error code attribute\n        ErrorCodeAttribute errorCodeAttribute\n            = AttributeFactory\n                .createErrorCodeAttribute(errorCode,\n                                          reasonPhrase);\n\n        allocationErrorResponse.putAttribute(errorCodeAttribute);\n\n        return allocationErrorResponse;\n    }\n    \n    /**\n     * Create an allocate request for a Google TURN relay (old TURN protocol\n     * modified).\n     *\n     * @param username short-term username\n     * @return an allocation request\n     */\n    public static Request createGoogleAllocateRequest(String username)\n    {\n        Request allocateRequest = new Request();\n        Attribute usernameAttr = AttributeFactory.createUsernameAttribute(\n                username);\n        Attribute magicCookieAttr =\n            AttributeFactory.createMagicCookieAttribute();\n\n        allocateRequest.setMessageType(Message.ALLOCATE_REQUEST);\n        // first attribute is MAGIC-COOKIE\n        allocateRequest.putAttribute(magicCookieAttr);\n        allocateRequest.putAttribute(usernameAttr);\n\n        return allocateRequest;\n    }\n\n    /**\n     * Adds the <tt>Attribute</tt>s to a specific <tt>Request</tt> which support\n     * the STUN long-term credential mechanism.\n     * <p>\n     * <b>Warning</b>: The MESSAGE-INTEGRITY <tt>Attribute</tt> will also be\n     * added so <tt>Attribute</tt>s added afterwards will not be taken into\n     * account for the calculation of the MESSAGE-INTEGRITY value. For example,\n     * the FINGERPRINT <tt>Attribute</tt> may still safely be added afterwards,\n     * because it is known to appear after the MESSAGE-INTEGRITY.\n     * </p>\n     *\n     * @param request the <tt>Request</tt> in which the <tt>Attribute</tt>s of\n     * the STUN long-term credential mechanism are to be added\n     * @param username the value for the USERNAME <tt>Attribute</tt> to be added\n     * to <tt>request</tt>\n     * @param realm the value for the REALM <tt>Attribute</tt> to be added to\n     * <tt>request</tt>\n     * @param nonce the value for the NONCE <tt>Attribute</tt> to be added to\n     * <tt>request</tt>\n     *\n     * @throws StunException if anything goes wrong while adding the\n     * <tt>Attribute</tt>s to <tt>request</tt> which support the STUN long-term\n     * credential mechanism\n     */\n    public static void addLongTermCredentialAttributes(\n            Request request,\n            byte username[], byte realm[], byte nonce[])\n        throws StunException\n    {\n        UsernameAttribute usernameAttribute\n            = AttributeFactory.createUsernameAttribute(username);\n        RealmAttribute realmAttribute\n            = AttributeFactory.createRealmAttribute(realm);\n        NonceAttribute nonceAttribute\n            = AttributeFactory.createNonceAttribute(nonce);\n\n        request.putAttribute(usernameAttribute);\n        request.putAttribute(realmAttribute);\n        request.putAttribute(nonceAttribute);\n\n        // MESSAGE-INTEGRITY\n        MessageIntegrityAttribute messageIntegrityAttribute;\n\n        try\n        {\n            /*\n             * The value of USERNAME is a variable-length value. It MUST contain\n             * a UTF-8 [RFC3629] encoded sequence of less than 513 bytes, and\n             * MUST have been processed using SASLprep [RFC4013].\n             */\n            messageIntegrityAttribute\n                = AttributeFactory.createMessageIntegrityAttribute(\n                        new String(username, \"UTF-8\"));\n        }\n        catch (UnsupportedEncodingException ueex)\n        {\n            throw new StunException(\"username\", ueex);\n        }\n        request.putAttribute(messageIntegrityAttribute);\n    }\n\n    /**\n     * Creates a new TURN Refresh <tt>Request</tt> without any optional\n     * attributes such as LIFETIME.\n     *\n     * @return a new TURN Refresh <tt>Request</tt> without any optional\n     * attributes such as LIFETIME\n     */\n    public static Request createRefreshRequest()\n    {\n        Request refreshRequest = new Request();\n\n        try\n        {\n            refreshRequest.setMessageType(Message.REFRESH_REQUEST);\n        }\n        catch (IllegalArgumentException iaex)\n        {\n            /*\n             * We don't actually expect the exception to happen so we're\n             * ignoring it.\n             */\n            logger.log(Level.FINE, \"Failed to set message type.\", iaex);\n        }\n        return refreshRequest;\n    }\n\n    /**\n     * Create a refresh request.\n     *\n     * @param lifetime lifetime value\n     * @return refresh request\n     */\n    public static Request createRefreshRequest(int lifetime)\n    {\n        Request refreshRequest = new Request();\n\n        try\n        {\n            refreshRequest.setMessageType(Message.REFRESH_REQUEST);\n\n            /* add a LIFETIME attribute */\n            LifetimeAttribute lifetimeReq = AttributeFactory\n                            .createLifetimeAttribute(lifetime);\n            refreshRequest.putAttribute(lifetimeReq);\n        }\n        catch (IllegalArgumentException ex)\n        {\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n\n        return refreshRequest;\n    }\n    \n    /**\n     * Creates a refresh success response with given lifetime.\n     * \n     * @param lifetime the lifetime value to be used.\n     * @return refresh error response including the error code attribute.\n     */\n    public static Response createRefreshResponse(int lifetime)\n    {\n        Response refreshSuccessResponse = new Response();\n\n        try\n        {\n            refreshSuccessResponse.setMessageType(Message.REFRESH_RESPONSE);\n\n            //lifetime attribute\n            LifetimeAttribute lifetimeAttribute\n                = AttributeFactory\n                        .createLifetimeAttribute(lifetime);\n\n            refreshSuccessResponse.putAttribute(lifetimeAttribute);\n        }\n        catch(IllegalArgumentException ex)\n        {\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n        return refreshSuccessResponse;\n    }\n    \n    /**\n     * Creates a refresh error response\n     * \n     * @param errorCode the error code to encapsulate in this message.\n     * @return refresh error response including the error code attribute.\n     */\n    public static Response createRefreshErrorResponse(char errorCode)\n    {\n        return createRefreshErrorResponse(errorCode, null);\n    }\n    \n    /**\n     * Creates a refresh error response.\n     * @param errorCode the error code to encapsulate in this message.\n     * @param reasonPhrase a human readable description of the error.\n     * @return refresh error response including the error code attribute.\n     */\n    public static Response createRefreshErrorResponse(\n            char errorCode, String reasonPhrase)\n    {\n        Response refreshErrorResponse = new Response();\n\n        try\n        {\n            refreshErrorResponse.setMessageType(\n                Message.REFRESH_ERROR_RESPONSE);\n\n            ErrorCodeAttribute errorCodeAttribute\n                = AttributeFactory\n                        .createErrorCodeAttribute(\n                            errorCode, reasonPhrase);\n\n            refreshErrorResponse.putAttribute(errorCodeAttribute);\n        }\n        catch(IllegalArgumentException ex)\n        {\n             logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n        return refreshErrorResponse;\n    }\n\n    /**\n     * Create a ChannelBind request.\n     *\n     * @param channelNumber the channel number\n     * @param peerAddress the peer address\n     * @param tranID the ID of the transaction that we should be using\n     *\n     * @return channel bind request\n     */\n    public static Request createChannelBindRequest(char channelNumber,\n                    TransportAddress peerAddress, byte[] tranID)\n    {\n        Request channelBindRequest = new Request();\n\n        try\n        {\n            channelBindRequest\n                            .setMessageType(Message.CHANNELBIND_REQUEST);\n\n            // add a CHANNEL-NUMBER attribute\n            ChannelNumberAttribute channelNumberAttribute = AttributeFactory\n                            .createChannelNumberAttribute(channelNumber);\n            channelBindRequest.putAttribute(channelNumberAttribute);\n\n            // add a XOR-PEER-ADDRESS\n            XorPeerAddressAttribute peerAddressAttribute\n                = AttributeFactory\n                        .createXorPeerAddressAttribute(peerAddress, tranID);\n            channelBindRequest.putAttribute(peerAddressAttribute);\n        }\n        catch (IllegalArgumentException ex)\n        {\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n\n        return channelBindRequest;\n    }\n    \n    /**\n     * Creates a Channel Bind Success Response.\n     * @return Channel Bind Success Response.\n     */\n    public static Response createChannelBindResponse()\n    {\n        Response channelBindSuccessResponse = new Response();\n\n        channelBindSuccessResponse.setMessageType(\n            Message.CHANNELBIND_RESPONSE);\n\n        return channelBindSuccessResponse;\n    }\n    \n    /**\n     * Creates a Channel Bind Error Response with given error code.\n     * \n     * @param errorCode the error code to encapsulate in this message.\n     * @return Channel Bind Error Response including the error code attribute.\n     */\n    public static Response createChannelBindErrorResponse(char errorCode)\n    {\n        return createChannelBindErrorResponse(errorCode, null);\n    }\n    \n    /**\n     * Creates a Channel Bind Error Response with given error code\n     * and reasonPhrase.\n     * @param errorCode the error code to encapsulate in this message.\n     * @param reasonPhrase a human readable description of the error.\n     * @return Channel Bind Error Response including the error code attribute.\n     */\n    public static Response createChannelBindErrorResponse(\n            char errorCode, String reasonPhrase)\n    {\n        Response channelBindErrorResponse = new Response();\n\n        channelBindErrorResponse\n            .setMessageType(Message.CHANNELBIND_ERROR_RESPONSE);\n\n        ErrorCodeAttribute errorCodeAttribute\n            = AttributeFactory\n                .createErrorCodeAttribute(errorCode, reasonPhrase);\n\n        channelBindErrorResponse.putAttribute(errorCodeAttribute);\n\n        return channelBindErrorResponse;\n    }\n    \n    /**\n     * Creates a new TURN CreatePermission <tt>Request</tt> with a specific\n     * value for its XOR-PEER-ADDRESS attribute.\n     *\n     * @param peerAddress the value to assigned to the XOR-PEER-ADDRESS\n     * attribute\n     * @param transactionID the ID of the transaction which is to be used for\n     * the assignment of <tt>peerAddress</tt> to the XOR-PEER-ADDRESS attribute\n     * @return a new TURN CreatePermission <tt>Request</tt> with the specified\n     * value for its XOR-PEER-ADDRESS attribute\n     */\n    public static Request createCreatePermissionRequest(\n            TransportAddress peerAddress,\n            byte[] transactionID)\n    {\n        Request createPermissionRequest = new Request();\n\n        try\n        {\n            createPermissionRequest.setMessageType(\n                    Message.CREATEPERMISSION_REQUEST);\n        }\n        catch (IllegalArgumentException iaex)\n        {\n            // Expected to not happen because we are the creators.\n            logger.log(Level.FINE, \"Failed to set message type.\", iaex);\n        }\n        createPermissionRequest.putAttribute(\n                AttributeFactory.createXorPeerAddressAttribute(\n                        peerAddress,\n                        transactionID));\n        return createPermissionRequest;\n    }\n\n    /**\n     * Creates a create permission success response.\n     * \n     * @return CreatePermission Response \n     */\n    public static Response createCreatePermissionResponse()\n    {\n        Response permissionSuccessResponse = new Response();\n\n        permissionSuccessResponse.setMessageType(\n            Message.CREATEPERMISSION_RESPONSE);\n\n        return permissionSuccessResponse;\n    }\n    \n    /**\n     * Creates a create permission error response.\n     * \n     * @param errorCode the error code to encapsulate in this message.\n     * @return CreatePermission Error Response with error code attribute.\n     */\n    public static Response createCreatePermissionErrorResponse(char errorCode)\n    {\n        return createPermissionErrorResponse(\n            errorCode, null);\n    }\n    \n    /**\n     * Creates a create permission error response.\n     * \n     * @param errorCode the error code to encapsulate in this message.\n     * @param reasonPhrase a human readable description of the error.\n     * @return CreatePermission Error Response with error code attribute.\n     */\n    public static Response createPermissionErrorResponse(\n            char errorCode, String reasonPhrase)\n    {\n        Response createPermissionErrorResponse = new Response();\n\n        createPermissionErrorResponse.setMessageType(\n            Message.CREATEPERMISSION_ERROR_RESPONSE);\n\n        ErrorCodeAttribute errorCodeAttribute\n            = AttributeFactory\n                .createErrorCodeAttribute(\n                        errorCode, reasonPhrase);\n\n        createPermissionErrorResponse.putAttribute(errorCodeAttribute);\n\n        return createPermissionErrorResponse;\n    }\n    \n    /**\n     * Create a Send Indication.\n     *\n     * @param peerAddress peer address\n     * @param data data (could be 0 byte)\n     * @param tranID the ID of the transaction that we should be using\n     *\n     * @return send indication message\n     */\n    public static Indication createSendIndication(\n                    TransportAddress peerAddress, byte[] data, byte[] tranID)\n    {\n        Indication sendIndication = new Indication();\n\n        try\n        {\n            sendIndication.setMessageType(Message.SEND_INDICATION);\n\n            /* add XOR-PEER-ADDRESS attribute */\n            XorPeerAddressAttribute peerAddressAttribute = AttributeFactory\n                            .createXorPeerAddressAttribute(peerAddress, tranID);\n            sendIndication.putAttribute(peerAddressAttribute);\n\n            /* add DATA if data */\n            if (data != null && data.length > 0)\n            {\n                DataAttribute dataAttribute = AttributeFactory\n                                .createDataAttribute(data);\n                sendIndication.putAttribute(dataAttribute);\n            }\n        }\n        catch (IllegalArgumentException ex)\n        {\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n\n        return sendIndication;\n    }\n\n    /**\n     * Create a Data Indication.\n     *\n     * @param peerAddress peer address\n     * @param data data (could be 0 byte)\n     * @param tranID the ID of the transaction that we should be using\n     *\n     * @return data indication message\n     */\n    public static Indication createDataIndication(\n            TransportAddress peerAddress, byte[] data, byte[] tranID)\n    {\n        Indication dataIndication = new Indication();\n\n        try\n        {\n            dataIndication.setMessageType(Message.DATA_INDICATION);\n\n            /* add XOR-PEER-ADDRESS attribute */\n            XorPeerAddressAttribute peerAddressAttribute\n                = AttributeFactory\n                        .createXorPeerAddressAttribute(peerAddress, tranID);\n            dataIndication.putAttribute(peerAddressAttribute);\n\n            /* add DATA if data */\n            if (data != null && data.length > 0)\n            {\n                DataAttribute dataAttribute\n                    = AttributeFactory\n                            .createDataAttribute(data);\n                dataIndication.putAttribute(dataAttribute);\n            }\n        }\n        catch (IllegalArgumentException ex)\n        {\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n\n        return dataIndication;\n    }\n    \n    /**\n     * Create a old Send Request.\n     * @param username the username\n     * @param peerAddress peer address\n     * @param data data (could be 0 byte)\n     * @return send indication message\n     */\n    public static Request createSendRequest(\n                    String username, TransportAddress peerAddress, byte[] data)\n    {\n        Request sendRequest = new Request();\n\n        try\n        {\n            sendRequest.setMessageType(Message.SEND_REQUEST);\n\n            /* add MAGIC-COOKIE attribute */\n            sendRequest.putAttribute(\n                    AttributeFactory.createMagicCookieAttribute());\n\n            /* add USERNAME attribute */\n            sendRequest.putAttribute(\n                    AttributeFactory.createUsernameAttribute(username));\n\n            /* add DESTINATION-ADDRESS attribute */\n            DestinationAddressAttribute peerAddressAttribute = AttributeFactory\n                            .createDestinationAddressAttribute(peerAddress);\n            sendRequest.putAttribute(peerAddressAttribute);\n\n            /* add DATA if data */\n            if (data != null && data.length > 0)\n            {\n                DataAttribute dataAttribute = AttributeFactory\n                                .createDataAttributeWithoutPadding(data);\n                sendRequest.putAttribute(dataAttribute);\n            }\n        }\n        catch (IllegalArgumentException ex)\n        {\n            logger.log(Level.FINE, \"Failed to set message type.\", ex);\n        }\n\n        return sendRequest;\n    }\n\n    // ======================== NOT CURRENTLY SUPPORTED\n    /**\n     * Create a shared secret request.\n     * WARNING: This is not currently supported.\n     *\n     * @return request\n     */\n    public static Request createSharedSecretRequest()\n    {\n        throw new UnsupportedOperationException(\n                        \"Shared Secret Support is not currently implemented\");\n    }\n\n    /**\n     * Create a shared secret response.\n     * WARNING: This is not currently supported.\n     *\n     * @return response\n     */\n    public static Response createSharedSecretResponse()\n    {\n        throw new UnsupportedOperationException(\n                        \"Shared Secret Support is not currently implemented\");\n    }\n\n    /**\n     * Create a shared secret error response.\n     * WARNING: This is not currently supported.\n     *\n     * @return error response\n     */\n    public static Response createSharedSecretErrorResponse()\n    {\n        throw new UnsupportedOperationException(\n                        \"Shared Secret Support is not currently implemented\");\n    }\n    \n    /**\n     * Creates a ConnectRequest in a 6062 compliant manner containing only\n     *<br><tt>XOR-PEER-ADDRESS</tt> attribute\n     *\n     * @param request the request that created the transaction that this\n     * response will belong to.\n     * @param peerAddress the address to assign the xorPeerAddressAttribute\n     * @return a ConnectRequest assigning the specified values to mandatory\n     * headers.\n     * @throws IllegalArgumentException if there was something wrong with the\n     * way we are trying to create the response.\n     */\n    public static Request createConnectRequest(\n            TransportAddress peerAddress, Request request)\n        throws IllegalArgumentException\n    {\n        Request connectRequest = new Request();\n\n        connectRequest.setMessageType(Message.CONNECT_REQUEST);\n\n        //xor peer address\n        XorPeerAddressAttribute xorPeerAddressAttribute\n            = AttributeFactory\n                .createXorPeerAddressAttribute(\n                    peerAddress, request.getTransactionID());\n\n        connectRequest.putAttribute(xorPeerAddressAttribute);\n\n        return connectRequest;\n    }\n    \n    /**\n     * Creates a ConnectRequest in a 6062 compliant manner containing only\n     * <tt>XOR-PEER-ADDRESS</tt> attribute. This method is used by turnserver.\n     *\n     * @param peerAddress the address to assign the xorPeerAddressAttribute\n     * @param transactionId the transaction id that this response will belong\n     * to.\n     * @return a ConnectRequest assigning the specified values to mandatory\n     * headers.\n     * @throws IllegalArgumentException if there was something wrong with the\n     * way we are trying to create the response.\n     */\n    public static Request createConnectRequest(TransportAddress peerAddress,\n        byte[] transactionId)\n        throws IllegalArgumentException\n    {\n        Request connectRequest = new Request();\n\n        connectRequest.setMessageType(Message.CONNECT_REQUEST);\n\n        // xor peer address\n        XorPeerAddressAttribute xorPeerAddressAttribute = AttributeFactory\n            .createXorPeerAddressAttribute(peerAddress, transactionId);\n\n        connectRequest.putAttribute(xorPeerAddressAttribute);\n\n        return connectRequest;\n    }   \n\n    /**\n     * Creates a Connect Response in a 6062 compliant manner containing a single\n     * <tt>CONNECTION-ID-ATTRIBUTE</tt> attribute\n     * @param connectionIdValue the address to assign the connectionIdAttribute\n     * @return a ConnectResponse assigning the specified values to mandatory\n     * headers.\n     * @throws IllegalArgumentException if there was something wrong with the\n     * way we are trying to create the response.\n     */\n        \n    public static Response createConnectResponse(\n            int connectionIdValue)\n        throws IllegalArgumentException\n    {\n        Response connectSuccessResponse = new Response();\n\n        connectSuccessResponse.setMessageType(Message.CONNECT_RESPONSE);\n\n        //connection id\n        ConnectionIdAttribute connectionIdAttribute\n            = AttributeFactory\n                .createConnectionIdAttribute(connectionIdValue);\n\n        connectSuccessResponse.putAttribute(connectionIdAttribute);\n\n        return connectSuccessResponse;\n    }\n    \n    /**\n     * Creates a Connect error response according to the specified error code.\n     *\n     * @param errorCode the error code to encapsulate in this message\n     * @throws IllegalArgumentException INVALID_ARGUMENTS if one or more of the\n     * given parameters had an invalid value.\n     * @return a Connect error response message containing an error code.\n     */\n    \n    public static Response createConnectErrorResponse(char errorCode)\n        throws IllegalArgumentException\n    {\n        return createConnectErrorResponse(errorCode, null);\n    }\n    \n    /**\n     * Creates a Connect error response according to the specified error code.\n     *\n     * @param errorCode the error code to encapsulate in this message\n     * @param reasonPhrase a human readable description of the error\n     * @throws IllegalArgumentException INVALID_ARGUMENTS if one or more of the\n     * given parameters had an invalid value.\n     * @return a Connect error response message containing an error code.\n     */\n    public static Response createConnectErrorResponse(\n            char  errorCode, String reasonPhrase )\n        throws IllegalArgumentException\n    {\n        Response connectionErrorResponse = new Response();\n\n        connectionErrorResponse.setMessageType(Message.CONNECT_ERROR_RESPONSE);\n\n        //error code attribute\n        ErrorCodeAttribute errorCodeAttribute\n            = AttributeFactory\n                .createErrorCodeAttribute(errorCode, reasonPhrase);\n\n        connectionErrorResponse.putAttribute(errorCodeAttribute);\n\n        return connectionErrorResponse;\n    }\n\n    \n    /**\n     * Creates a ConnectionBindRequest in a 6062 compliant manner containing\n     * only <tt>CONECTION-ID-ATTRIBUTE</tt> attribute.\n     *\n     * @param connectionIdValue the value to assign the connectionIdAtribute\n     * @return a ConnectionBind Request assigning the specified values\n     *         to mandatory headers.\n     * @throws IllegalArgumentException if there was something wrong with the\n     *         way we are trying to create the Request.\n     */\n    public static Request createConnectionBindRequest(int connectionIdValue)\n        throws IllegalArgumentException\n    {\n        Request connectionBindRequest = new Request();\n\n        connectionBindRequest.setMessageType(Message.CONNECTION_BIND_REQUEST);\n\n        //connection id\n        ConnectionIdAttribute connectionIdAttribute\n            = AttributeFactory\n                .createConnectionIdAttribute(connectionIdValue);\n\n        connectionBindRequest.putAttribute(connectionIdAttribute);\n\n        return connectionBindRequest;\n    }\n    \n    /**\n     * Creates a ConnectionBind Response in a 6062 compliant manner.\n     *\n     * @return a ConnectionBind Response assigning the specified values to\n     *         mandatory headers.\n     * @throws IllegalArgumentException if there was something wrong with the\n     * way we are trying to create the response.\n     */ \n    public static Response createConnectionBindResponse()\n        throws IllegalArgumentException\n    {\n        Response connectSuccessResponse = new Response();\n\n        connectSuccessResponse.setMessageType(\n            Message.CONNECTION_BIND_SUCCESS_RESPONSE);\n\n        return connectSuccessResponse;\n    }\n    \n    /**\n     * Creates a ConnectionBind error response according to the specified error\n     * code.\n     *\n     * @param errorCode the error code to encapsulate in this message\n     * @throws IllegalArgumentException INVALID_ARGUMENTS if one or more of the\n     * given parameters had an invalid value.\n     * @return a ConnectionBind error response message containing an error code.\n     */\n    \n    public static Response createConnectionBindErrorResponse(char errorCode)\n        throws IllegalArgumentException\n    {\n        return createConnectionBindErrorResponse(errorCode, null);\n    }\n    \n    /**\n     * Creates a ConnectionBind error response according to the specified error\n     * code.\n     *\n     * @param errorCode the error code to encapsulate in this message\n     * @param reasonPhrase a human readable description of the error\n     * @throws IllegalArgumentException INVALID_ARGUMENTS if one or more of the\n     * given parameters had an invalid value.\n     * @return a ConnectionBind error response message containing an error code.\n     */\n    public static Response createConnectionBindErrorResponse(\n            char  errorCode, String reasonPhrase)\n        throws IllegalArgumentException\n    {\n        Response connectionBindErrorResponse = new Response();\n\n        connectionBindErrorResponse.setMessageType(\n            Message.CONNECTION_BIND_ERROR_RESPONSE);\n\n        //error code attribute\n        ErrorCodeAttribute errorCodeAttribute\n            = AttributeFactory\n                .createErrorCodeAttribute(errorCode, reasonPhrase);\n\n        connectionBindErrorResponse.putAttribute(errorCodeAttribute);\n\n        return connectionBindErrorResponse;\n    }\n\n    /**\n     * Creates a ConnectionAttempt Indication in a 6062 compliant manner\n     * containing only <tt>CONECTION-ID-ATTRIBUTE</tt> attribute and\n     * <tt>XOR-PPER-ADDRESS</tt> attribute.\n     *\n     * @param connectionIdValue the value to assign the connectionidAtribute\n     * @param peerAddress the value to assign the xorPeerAddress\n     * @return a ConnectionAttempt Indication assigning the specified values to\n     *         mandatory headers.\n     * @throws IllegalArgumentException if there was something wrong with the\n     * way we are trying to create the Request.\n     */\n    public static Indication createConnectionAttemptIndication(\n            int connectionIdValue, TransportAddress peerAddress)\n        throws IllegalArgumentException\n    {\n        Indication connectionAttemptIndication = new Indication();\n\n        connectionAttemptIndication.setMessageType(\n            Message.CONNECTION_ATTEMPT_INDICATION);\n\n        //connection id attribute\n        ConnectionIdAttribute connectionIdAttribute\n            = AttributeFactory\n                .createConnectionIdAttribute(connectionIdValue);\n\n        connectionAttemptIndication.putAttribute(connectionIdAttribute);\n\n        //xor peer address attribute\n        XorPeerAddressAttribute xorPeerAddressAttribute\n            = AttributeFactory\n                .createXorPeerAddressAttribute(peerAddress,\n                    connectionAttemptIndication.getTransactionID());\n\n        connectionAttemptIndication.putAttribute(xorPeerAddressAttribute);\n\n        return connectionAttemptIndication;\n   }\n    \n    /**\n     * Creates a ConnectionAttempt Indication in a 6062 compliant manner\n     * containing only <tt>CONECTION-ID-ATTRIBUTE</tt> attribute and\n     * <tt>XOR-PPER-ADDRESS</tt> attribute.\n     *\n     * @param connectionIdValue the value to assign the connectionidAtribute\n     * @param peerAddress the value to assign the xorPeerAddress\n     * @param transactionId the transaction id that the response belongs to.\n     * @return a ConnectionAttempt Indication assigning the specified values to\n     * mandatory headers.\n     * @throws IllegalArgumentException if there was something wrong with the\n     * way we are trying to create the Request.\n     * @throws StunException when the transaction id is not valid.\n     */\n    public static Indication createConnectionAttemptIndication(\n        int connectionIdValue, TransportAddress peerAddress,\n        byte[] transactionId)\n        throws IllegalArgumentException, StunException\n    {\n        Indication connectionAttemptIndication = new Indication();\n\n        // set the attempt transaction id\n        connectionAttemptIndication.setTransactionID(transactionId);\n\n        connectionAttemptIndication.setMessageType(\n            Message.CONNECTION_ATTEMPT_INDICATION);\n\n        // connection id attribute\n        ConnectionIdAttribute connectionIdAttribute = AttributeFactory\n            .createConnectionIdAttribute(connectionIdValue);\n\n        connectionAttemptIndication.putAttribute(connectionIdAttribute);\n\n        // xor peer address attribute\n        XorPeerAddressAttribute xorPeerAddressAttribute = AttributeFactory\n            .createXorPeerAddressAttribute(peerAddress,\n            connectionAttemptIndication.getTransactionID());\n\n        connectionAttemptIndication.putAttribute(xorPeerAddressAttribute);\n\n        return connectionAttemptIndication;\n    }   \n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(MessageFactory.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>MessageFactory</tt> class and its\ninstances.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(MessageFactory.class.getName())", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/message/Indication.java.Indication", "name": "Indication", "file_path": "src/main/java/org/ice4j/message/Indication.java", "superclasses": "Message", "methods": ["[]Indication()", "[void]setMessageType(char)"], "method_uris": ["src/main/java/org/ice4j/message/Indication.java.Indication.[]Indication()", "src/main/java/org/ice4j/message/Indication.java.Indication.[void]setMessageType(char)"], "overrides": null, "attributes": [], "class_docstring": "\nAn indication descendant of the message class.\n\nFor example, indication messages is used by TURN protocol\nto send and receive encapsulated data.\n\n@author Sebastien Vincent\n", "original_string": "public class Indication\n    extends Message\n{\n    /**\n     * Constructor.\n     */\n    Indication()\n    {\n    }\n\n    /**\n     * Checks whether indicationType is a valid indication type and if yes sets\n     * it as the type of this instance.\n     *\n     * @param indicationType the type to set\n     * @throws IllegalArgumentException if indicationType is not a valid\n     * indication type\n     */\n    @Override\n    public void setMessageType(char indicationType)\n        throws IllegalArgumentException\n    {\n        /* old TURN DATA indication type is an indication despite\n         * 0x0115 & 0x0110 indicates STUN error response type\n         */\n        if (!isIndicationType(indicationType) &&\n                indicationType != OLD_DATA_INDICATION)\n            throw new IllegalArgumentException(\n                    (int)(indicationType)\n                    + \" - is not a valid indication type.\");\n\n        super.setMessageType(indicationType);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/ice4j/message/ChannelData.java.ChannelData", "name": "ChannelData", "file_path": "src/main/java/org/ice4j/message/ChannelData.java", "superclasses": "", "methods": ["[]ChannelData()", "[void]setChannelNumber(char)", "[char]getChannelNumber()", "[void]setData(byte)", "[byte[]]getData()", "[char]getDataLength()", "[int]padTo4(int)", "[boolean]validateChannelNumber(char)", "[byte[]]encode()", "[byte[]]encode(boolean)", "[ChannelData]decode(byte,char,char)", "[ChannelData]decode(byte,char)", "[boolean]isChannelDataMessage(byte[])"], "method_uris": ["src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[]ChannelData()", "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[void]setChannelNumber(char)", "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[char]getChannelNumber()", "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[void]setData(byte)", "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[byte[]]getData()", "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[char]getDataLength()", "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[int]padTo4(int)", "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[boolean]validateChannelNumber(char)", "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[byte[]]encode()", "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[byte[]]encode(boolean)", "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[ChannelData]decode(byte,char,char)", "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[ChannelData]decode(byte,char)", "src/main/java/org/ice4j/message/ChannelData.java.ChannelData.[boolean]isChannelDataMessage(byte[])"], "overrides": null, "attributes": [], "class_docstring": "\nThe ChannelData message are used in TURN protocol\nafter a client has bound a channel to a peer.\n\n   0                   1                   2                   3\n  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |         Channel Number        |            Length             |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                                                               |\n /                       Application Data                        /\n /                                                               /\n |                                                               |\n |                               +-------------------------------+\n |                               |\n +-------------------------------+\n\n@author Sebastien Vincent\n@author Aakash Garg\n", "original_string": "public class ChannelData\n{\n    /**\n     * The channel number.\n     */\n    private char channelNumber = 0;\n\n    /**\n     * The data.\n     */\n    private byte data[] = null;\n\n    /**\n     * Size of the header.\n     */\n    public static char HEADER_LENGTH = 4;\n\n    /**\n     * Constructor.\n     */\n    public ChannelData()\n    {\n    }\n\n    /**\n     * Set the channel number\n     * @param channelNumber the channel number\n     */\n    public void setChannelNumber(char channelNumber)\n    {\n        this.channelNumber = channelNumber;\n    }\n\n    /**\n     * Get the channel number.\n     * @return channel number\n     */\n    public char getChannelNumber()\n    {\n        return this.channelNumber;\n    }\n\n    /**\n     * Set the data.\n     * @param data the data\n     */\n    public void setData(byte data[])\n    {\n        this.data = data;\n    }\n\n    /**\n     * Get the data.\n     * @return data\n     */\n    public byte[] getData()\n    {\n        return this.data;\n    }\n\n    /**\n     * Get the data length (without padding).\n     *\n     * @return data length\n     */\n    public char getDataLength()\n    {\n        if (data == null)\n            return 0;\n\n        return (char)data.length;\n    }\n\n    /**\n     * @return num padded to 4\n     */\n    private static int padTo4(int num)\n    {\n        return (num + 3) & ~3;\n    }\n\n    /**\n     * Determines whether a specific channel number is in the valid channel\n     * number range defined by the TURN RFC.\n     *\n     * @param channelNumber the channel number to be checked for being in the\n     * valid channel number range defined by the TURN RFC\n     * @return <tt>true</tt> if the specified <tt>channelNumber</tt> is in the\n     * valid channel number range defined by the TURN RFC\n     */\n    private static boolean validateChannelNumber(char channelNumber)\n    {\n        return (channelNumber > 0x3FFF);\n    }\n\n    /**\n     * Returns a non padded binary representation of this message.\n     * @return a non padded binary representation of this message.\n     * @throws StunException if the channel number is invalid\n     * @deprecated\n     */\n    public byte[] encode() throws StunException\n    {\n        return encode(false);\n    }\n\n    /**\n     * Returns a binary representation of this message.\n     * @param pad determine if we pad this message\n     * @return a binary representation of this message.\n     * @throws StunException if the channel number is invalid\n     */\n    public byte[] encode(boolean pad) throws StunException\n    {\n        int dataLength = getDataLength();\n        if (pad)\n            dataLength = padTo4(dataLength);\n        byte binMsg[] = new byte[HEADER_LENGTH + dataLength];\n        int offset = 0;\n\n        if (!validateChannelNumber(channelNumber))\n        {\n            throw new StunException(StunException.ILLEGAL_ARGUMENT, \"Channel number invalid\");\n        }\n\n        /* channel number */\n        binMsg[offset++] = (byte)(channelNumber >> 8);\n        binMsg[offset++] = (byte)(channelNumber & 0xff);\n\n        /* length */\n        binMsg[offset++] = (byte)((data != null) ? data.length >> 8 : 0);\n        binMsg[offset++] = (byte)((data != null) ? data.length & 0xff : 0);\n\n        if (data != null)\n        {\n            System.arraycopy(data, 0, binMsg, offset, data.length);\n        }\n\n        return binMsg;\n    }\n\n    /**\n     * Constructs a message from its binary representation.\n     * @param binMessage the binary array that contains the encoded message\n     * @param offset the index where the message starts.\n     * @param arrayLen the length of the message\n     * @return a Message object constructed from the binMessage array\n     * @throws StunException ILLEGAL_ARGUMENT if one or more of the arguments\n     * have invalid values.\n     * @deprecated\n     */\n    public static ChannelData decode(byte binMessage[], char offset, char arrayLen) throws StunException\n    {\n        return decode(binMessage, offset);\n    }\n\n    /**\n     * Constructs a message from its binary representation.\n     * @param binMessage the binary array that contains the encoded message\n     * @param offset the index where the message starts.\n     * @return a Message object constructed from the binMessage array\n     * @throws StunException ILLEGAL_ARGUMENT if one or more of the arguments\n     * have invalid values.\n     */\n    public static ChannelData decode(byte binMessage[], char offset) throws StunException\n    {\n        char msgLen = 0;\n        char channelNumber = 0;\n        ChannelData channelData = null;\n        byte data[] = null;\n\n        if ((binMessage.length - offset) < HEADER_LENGTH)\n        {\n            throw new StunException(StunException.ILLEGAL_ARGUMENT, \"Size too short\");\n        }\n\n        channelNumber = (char)((binMessage[offset++]<<8) | (binMessage[offset++]&0xFF));\n\n        if (!validateChannelNumber(channelNumber))\n        {\n            throw new StunException(StunException.ILLEGAL_ARGUMENT, \"Channel number invalid\");\n        }\n\n        msgLen = (char)((binMessage[offset++]<<8) | (binMessage[offset++]&0xFF));\n        if (msgLen > (binMessage.length - offset))\n        {\n            throw new StunException(StunException.ILLEGAL_ARGUMENT, \"Size mismatch\");\n        }\n\n        data = new byte[msgLen];\n        System.arraycopy(binMessage, offset, data, 0, msgLen);\n\n        channelData = new ChannelData();\n        channelData.setData(data);\n        channelData.setChannelNumber(channelNumber);\n\n        return channelData;\n    }\n    \n    /**\n     * Checks if the given binary message is a ChannelData Message. Every\n     * ChannelData message has first two bits as 01.\n     * \n     * @param binMessage binary message to check.\n     * @return true is given binary message is a ChannelData Message.\n     */\n    public static boolean isChannelDataMessage(byte[] binMessage)\n    {\n        return (binMessage[0] >> 6 == 0x1);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private char channelNumber = 0;", "docstring": "\nThe channel number.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "char", "name": "channelNumber = 0", "syntax_pass": true}, {"attribute_expression": "private byte data[] = null;", "docstring": "\nThe data.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte", "name": "data[] = null", "syntax_pass": true}, {"attribute_expression": "public static char HEADER_LENGTH = 4;", "docstring": "\nSize of the header.\n", "modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "type": "char", "name": "HEADER_LENGTH = 4", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/message/Response.java.Response", "name": "Response", "file_path": "src/main/java/org/ice4j/message/Response.java", "superclasses": "Message", "methods": ["[]Response()", "[boolean]isErrorResponse()", "[boolean]isSuccessResponse()", "[void]setMessageType(char)"], "method_uris": ["src/main/java/org/ice4j/message/Response.java.Response.[]Response()", "src/main/java/org/ice4j/message/Response.java.Response.[boolean]isErrorResponse()", "src/main/java/org/ice4j/message/Response.java.Response.[boolean]isSuccessResponse()", "src/main/java/org/ice4j/message/Response.java.Response.[void]setMessageType(char)"], "overrides": null, "attributes": [], "class_docstring": "\nA response descendant of the message class. The primary purpose of the\nResponse class is to allow better functional definition of the classes in the\nstack package.\n\n@author Emil Ivov\n@author Lubomir Marinov\n", "original_string": "public class Response\n    extends Message\n{\n\n    /**\n     * Constructor.\n     */\n    Response()\n    {\n    }\n\n    /**\n     * Determines whether this instance represents a STUN error response.\n     *\n     * @return <tt>true</tt> if this instance represents a STUN error response;\n     * otherwise, <tt>false</tt>\n     */\n    public boolean isErrorResponse()\n    {\n        return isErrorResponseType(getMessageType());\n    }\n\n    /**\n     * Determines whether this instance represents a STUN success response.\n     *\n     * @return <tt>true</tt> if this instance represents a STUN success\n     * response; otherwise, <tt>false</tt>\n     */\n    public boolean isSuccessResponse()\n    {\n        return isSuccessResponseType(getMessageType());\n    }\n\n    /**\n     * Checks whether responseType is a valid response type and if yes sets it\n     * as the type of the current instance.\n     * @param responseType the type to set\n     * @throws IllegalArgumentException if responseType is not a valid\n     * response type\n     */\n    public void setMessageType(char responseType)\n        throws IllegalArgumentException\n    {\n        if (!isResponseType(responseType))\n            throw new IllegalArgumentException(\n                                    Integer.toString(responseType)\n                                        + \" is not a valid response type.\");\n\n\n        super.setMessageType(responseType);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/ice4j/message/Request.java.Request", "name": "Request", "file_path": "src/main/java/org/ice4j/message/Request.java", "superclasses": "Message", "methods": ["[]Request()", "[void]setMessageType(char)"], "method_uris": ["src/main/java/org/ice4j/message/Request.java.Request.[]Request()", "src/main/java/org/ice4j/message/Request.java.Request.[void]setMessageType(char)"], "overrides": null, "attributes": [], "class_docstring": "\nA request descendant of the message class. The primary purpose of the\nRequest class is to allow better functional definition of the classes in the\nstack package.\n\n@author Emil Ivov\n", "original_string": "public class Request extends Message\n{\n\n    /**\n     * Constructor.\n     */\n    Request()\n    {\n    }\n\n    /**\n     * Checks whether requestType is a valid request type and if yes sets it\n     * as the type of the current instance.\n     * @param requestType the type to set\n     * @throws IllegalArgumentException if requestType is not a valid\n     * request type\n     */\n    public void setMessageType(char requestType)\n        throws IllegalArgumentException\n    {\n        if (!isRequestType(requestType))\n            throw new IllegalArgumentException(\n                                    (int)(requestType)\n                                    + \" - is not a valid request type.\");\n\n\n        super.setMessageType(requestType);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender", "name": "BlockingRequestSender", "file_path": "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java", "superclasses": "AbstractResponseCollector", "methods": ["[]BlockingRequestSender(StunStack,TransportAddress)", "[TransportAddress]getLocalAddress()", "[void]processFailure(BaseStunMessageEvent)", "[void]processResponse(StunResponseEvent)", "[StunMessageEvent]sendRequestAndWaitForResponse(Request,TransportAddress)", "[StunMessageEvent]sendRequestAndWaitForResponse(Request,TransportAddress,TransactionID)"], "method_uris": ["src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender.[]BlockingRequestSender(StunStack,TransportAddress)", "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender.[TransportAddress]getLocalAddress()", "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender.[void]processFailure(BaseStunMessageEvent)", "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender.[void]processResponse(StunResponseEvent)", "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender.[StunMessageEvent]sendRequestAndWaitForResponse(Request,TransportAddress)", "src/main/java/org/ice4j/stunclient/BlockingRequestSender.java.BlockingRequestSender.[StunMessageEvent]sendRequestAndWaitForResponse(Request,TransportAddress,TransactionID)"], "overrides": null, "attributes": [], "class_docstring": "\nA utility used to flatten the multi-thread architecture of the Stack\nand execute the discovery process in a synchronized manner. Roughly what\nhappens here is:\n<code>\nApplicationThread:\n    sendMessage()\n       wait();\n\nStackThread:\n    processMessage/Timeout()\n    {\n         saveMessage();\n         notify();\n    }\n</code>\n\n@author Emil Ivov\n@author Lubomir Marinov\n@author Aakash Garg\n", "original_string": "public class BlockingRequestSender\n    extends AbstractResponseCollector\n{\n    /**\n     * Our class logger\n     */\n    private static final Logger logger\n        = Logger.getLogger(BlockingRequestSender.class.getName());\n\n    /**\n     * The stack that we are using to send requests through.\n     */\n    private final StunStack stunStack;\n\n    /**\n     * The transport address that we are bound on.\n     */\n    private final TransportAddress localAddress;\n\n    /**\n     * The <tt>StunMessageEvent</tt> that contains the response matching our\n     * request.\n     */\n    private StunMessageEvent responseEvent = null;\n\n    /**\n     * Determines whether this request sender has completed its course.\n     */\n    private boolean ended = false;\n\n    /**\n     * A lock object that we are using to synchronize sending.\n     */\n    private final Object sendLock = new Object();\n\n    /**\n     * Creates a new request sender.\n     * @param stunStack the stack that the sender should send requests\n     * through.\n     * @param localAddress the <tt>TransportAddress</tt> that requests should be\n     * leaving from.\n     */\n    public BlockingRequestSender(StunStack stunStack,\n                          TransportAddress localAddress)\n    {\n        this.stunStack = stunStack;\n        this.localAddress = localAddress;\n    }\n\n    /**\n     * Returns the local Address on which this Blocking Request Sender is bound\n     * to.\n     *\n     * @return the localAddress of this RequestSender.\n     */\n    public TransportAddress getLocalAddress()\n    {\n        return localAddress;\n    }\n\n    /**\n     * Notifies this <tt>ResponseCollector</tt> that a transaction described by\n     * the specified <tt>BaseStunMessageEvent</tt> has failed. The possible\n     * reasons for the failure include timeouts, unreachable destination, etc.\n     * Notifies the discoverer so that it may resume.\n     *\n     * @param event the <tt>BaseStunMessageEvent</tt> which describes the failed\n     * transaction and the runtime type of which specifies the failure reason\n     * @see AbstractResponseCollector#processFailure(BaseStunMessageEvent)\n     */\n    @Override\n    protected synchronized void processFailure(BaseStunMessageEvent event)\n    {\n        synchronized(sendLock)\n        {\n            ended = true;\n            notifyAll();\n        }\n    }\n\n    /**\n     * Saves the message event and notifies the discoverer thread so that\n     * it may resume.\n     * @param evt the newly arrived message event.\n     */\n    @Override\n    public synchronized void processResponse(StunResponseEvent evt)\n    {\n        synchronized(sendLock)\n        {\n            this.responseEvent = evt;\n            ended = true;\n            notifyAll();\n        }\n    }\n\n    /**\n     * Sends the specified request and blocks until a response has been\n     * received or the request transaction has timed out.\n     * @param request the request to send\n     * @param serverAddress the request destination address\n     * @return the event encapsulating the response or null if no response\n     * has been received.\n     *\n     * @throws IOException  if an error occurs while sending message bytes\n     * through the network socket.\n     * @throws IllegalArgumentException if the apDescriptor references an\n     * access point that had not been installed,\n     * @throws StunException if message encoding fails,\n     */\n    public synchronized StunMessageEvent sendRequestAndWaitForResponse(\n                                                Request request,\n                                                TransportAddress serverAddress)\n            throws StunException,\n                   IOException\n    {\n        synchronized(sendLock)\n        {\n            stunStack.sendRequest(request, serverAddress, localAddress,\n                                     BlockingRequestSender.this);\n        }\n\n        ended = false;\n        while (!ended)\n        {\n            try\n            {\n                wait();\n            }\n            catch (InterruptedException ex)\n            {\n                logger.log(Level.WARNING, \"Interrupted\", ex);\n            }\n        }\n        StunMessageEvent res = responseEvent;\n        responseEvent = null; //prepare for next message\n\n        return res;\n    }\n    \n\n    /**\n     * Sends the specified request and blocks until a response has been\n     * received or the request transaction has timed out with given \n     * transactionID.\n     * @param request the request to send\n     * @param serverAddress the request destination address\n     * @param tranID the TransactionID to set for this reuest.\n     * @return the event encapsulating the response or null if no response\n     * has been received.\n     *\n     * @throws IOException  if an error occurs while sending message bytes\n     * through the network socket.\n     * @throws IllegalArgumentException if the apDescriptor references an\n     * access point that had not been installed,\n     * @throws StunException if message encoding fails,\n     */\n    public synchronized StunMessageEvent sendRequestAndWaitForResponse(\n                                                Request request,\n                                                TransportAddress serverAddress,\n                                                TransactionID tranID)\n            throws StunException,\n                   IOException\n    {\n        synchronized(sendLock)\n        {\n            stunStack.sendRequest(request, serverAddress, localAddress,\n                                     BlockingRequestSender.this, tranID);\n        }\n\n        ended = false;\n        while (!ended)\n        {\n            try\n            {\n                wait();\n            }\n            catch (InterruptedException ex)\n            {\n                logger.log(Level.WARNING, \"Interrupted\", ex);\n            }\n        }\n        StunMessageEvent res = responseEvent;\n        responseEvent = null; //prepare for next message\n\n        return res;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(BlockingRequestSender.class.getName());", "docstring": "\nOur class logger\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(BlockingRequestSender.class.getName())", "syntax_pass": true}, {"attribute_expression": "private final StunStack stunStack;", "docstring": "\nThe stack that we are using to send requests through.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StunStack", "name": "stunStack", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress localAddress;", "docstring": "\nThe transport address that we are bound on.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "localAddress", "syntax_pass": true}, {"attribute_expression": "private StunMessageEvent responseEvent = null;", "docstring": "\nThe <tt>StunMessageEvent</tt> that contains the response matching our\nrequest.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StunMessageEvent", "name": "responseEvent = null", "syntax_pass": true}, {"attribute_expression": "private boolean ended = false;", "docstring": "\nDetermines whether this request sender has completed its course.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "ended = false", "syntax_pass": true}, {"attribute_expression": "private final Object sendLock = new Object();", "docstring": "\nA lock object that we are using to synchronize sending.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "sendLock = new Object()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess", "name": "NetworkConfigurationDiscoveryProcess", "file_path": "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java", "superclasses": "", "methods": ["[]NetworkConfigurationDiscoveryProcess(StunStack,TransportAddress,TransportAddress)", "[void]shutDown()", "[void]start()", "[StunDiscoveryReport]determineAddress()", "[StunMessageEvent]doTestI(TransportAddress)", "[StunMessageEvent]doTestII(TransportAddress)", "[StunMessageEvent]doTestIII(TransportAddress)", "[void]checkStarted()"], "method_uris": ["src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[]NetworkConfigurationDiscoveryProcess(StunStack,TransportAddress,TransportAddress)", "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[void]shutDown()", "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[void]start()", "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[StunDiscoveryReport]determineAddress()", "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[StunMessageEvent]doTestI(TransportAddress)", "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[StunMessageEvent]doTestII(TransportAddress)", "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[StunMessageEvent]doTestIII(TransportAddress)", "src/main/java/org/ice4j/stunclient/NetworkConfigurationDiscoveryProcess.java.NetworkConfigurationDiscoveryProcess.[void]checkStarted()"], "overrides": null, "attributes": [], "class_docstring": "\n<p>\nThis class implements the STUN Discovery Process as described by section 10.1\nof rfc 3489.\n</p><p>\nThe flow makes use of three tests.  In test I, the client sends a\nSTUN Binding Request to a server, without any flags set in the\nCHANGE-REQUEST attribute, and without the RESPONSE-ADDRESS attribute.\nThis causes the server to send the response back to the address and\nport that the request came from.  In test II, the client sends a\nBinding Request with both the \"change IP\" and \"change port\" flags\nfrom the CHANGE-REQUEST attribute set.  In test III, the client sends\na Binding Request with only the \"change port\" flag set.\n</p><p>\nThe client begins by initiating test I.  If this test yields no\nresponse, the client knows right away that it is not capable of UDP\nconnectivity.  If the test produces a response, the client examines\nthe MAPPED-ADDRESS attribute.  If this address and port are the same\nas the local IP address and port of the socket used to send the\nrequest, the client knows that it is not natted.  It executes test\nII.\n</p><p>\nIf a response is received, the client knows that it has open access\nto the Internet (or, at least, its behind a firewall that behaves\nlike a full-cone NAT, but without the translation).  If no response\nis received, the client knows its behind a symmetric UDP firewall.\n</p><p>\nIn the event that the IP address and port of the socket did not match\nthe MAPPED-ADDRESS attribute in the response to test I, the client\nknows that it is behind a NAT.  It performs test II.  If a response\nis received, the client knows that it is behind a full-cone NAT.  If\nno response is received, it performs test I again, but this time,\ndoes so to the address and port from the CHANGED-ADDRESS attribute\nfrom the response to test I.  If the IP address and port returned in\nthe MAPPED-ADDRESS attribute are not the same as the ones from the\nfirst test I, the client knows its behind a symmetric NAT.  If the\naddress and port are the same, the client is either behind a\nrestricted or port restricted NAT.  To make a determination about\nwhich one it is behind, the client initiates test III.  If a response\nis received, its behind a restricted NAT, and if no response is\nreceived, its behind a port restricted NAT.\n</p><p>\nThis procedure yields substantial information about the operating\ncondition of the client application.  In the event of multiple NATs\nbetween the client and the Internet, the type that is discovered will\nbe the type of the most restrictive NAT between the client and the\nInternet.  The types of NAT, in order of restrictiveness, from most\nto least, are symmetric, port restricted cone, restricted cone, and\nfull cone.\n</p><p>\nTypically, a client will re-do this discovery process periodically to\ndetect changes, or look for inconsistent results.  It is important to\nnote that when the discovery process is redone, it should not\ngenerally be done from the same local address and port used in the\nprevious discovery process.  If the same local address and port are\nreused, bindings from the previous test may still be in existence,\nand these will invalidate the results of the test.  Using a different\nlocal address and port for subsequent tests resolves this problem.\nAn alternative is to wait sufficiently long to be confident that the\nold bindings have expired (half an hour should more than suffice).\n</p>\n\n@author Emil Ivov\n", "original_string": "public class NetworkConfigurationDiscoveryProcess\n{\n    /**\n     * Our class logger.\n     */\n    private static final Logger logger =\n        Logger.getLogger(NetworkConfigurationDiscoveryProcess.class.getName());\n    /**\n     * Indicates whether the underlying stack has been initialized and started\n     * and that the discoverer is operational.\n     */\n    private boolean started = false;\n\n    /**\n     * The point where we'll be listening.\n     */\n    private TransportAddress localAddress  = null;\n\n    /**\n     * The address of the stun server\n     */\n    private TransportAddress serverAddress = null;\n\n    /**\n     * A utility used to flatten the multi thread architecture of the Stack\n     * and execute the discovery process in a synchronized manner\n     */\n    private BlockingRequestSender requestSender = null;\n\n    /**\n     * The <tt>DatagramSocket</tt> that we are going to be running the\n     * discovery process through.\n     */\n    private IceSocketWrapper sock = null;\n\n    /**\n     * The <tt>StunStack</tt> used by this instance for the purposes of STUN\n     * communication.\n     */\n    private final StunStack stunStack;\n\n    /**\n     * Initializes a <tt>StunAddressDiscoverer</tt> with a specific\n     * <tt>StunStack</tt>. In order to use it one must first start it.\n     *\n     * @param stunStack the <tt>StunStack</tt> to be used by the new instance\n     * @param localAddress  the address where the stack should bind.\n     * @param serverAddress the address of the server to interrogate.\n     */\n    public NetworkConfigurationDiscoveryProcess(\n            StunStack stunStack,\n            TransportAddress localAddress, TransportAddress serverAddress)\n    {\n        if (stunStack == null)\n            throw new NullPointerException(\"stunStack\");\n\n        this.stunStack = stunStack;\n        this.localAddress  = localAddress;\n        this.serverAddress = serverAddress;\n    }\n\n    /**\n     * Shuts down the underlying stack and prepares the object for garbage\n     * collection.\n     */\n    public void shutDown()\n    {\n        stunStack.removeSocket(localAddress);\n        sock.close();\n        sock = null;\n\n        localAddress  = null;\n        requestSender = null;\n\n        this.started = false;\n    }\n\n    /**\n     * Puts the discoverer into an operational state.\n     * @throws IOException if we fail to bind.\n     * @throws StunException if the stun4j stack fails start for some reason.\n     */\n    public void start()\n        throws IOException, StunException\n    {\n        sock = new IceUdpSocketWrapper(\n            new SafeCloseDatagramSocket(localAddress));\n\n        stunStack.addSocket(sock);\n\n        requestSender = new BlockingRequestSender(stunStack, localAddress);\n\n        started = true;\n    }\n\n    /**\n     * Implements the discovery process itself (see class description).\n     * @return a StunDiscoveryReport containing details about the network\n     * configuration of the host where the class is executed.\n     *\n     * @throws StunException ILLEGAL_STATE if the discoverer has not been started\n     * @throws IOException if a failure occurs while executing the discovery\n     * algorithm.\n     */\n    public StunDiscoveryReport determineAddress()\n        throws StunException, IOException\n    {\n        checkStarted();\n        StunDiscoveryReport report = new StunDiscoveryReport();\n        StunMessageEvent evt = doTestI(serverAddress);\n\n        if (evt == null)\n        {\n            //UDP Blocked\n            report.setNatType(StunDiscoveryReport.UDP_BLOCKING_FIREWALL);\n            return report;\n        }\n        else\n        {\n            TransportAddress mappedAddress\n                =((MappedAddressAttribute)evt.getMessage()\n                  .getAttribute(Attribute.MAPPED_ADDRESS)).getAddress();\n\n            if (mappedAddress == null)\n            {\n              /* maybe we contact a STUNbis server and which do not\n               * understand our request.\n               */\n              logger.info(\"Failed to do the network discovery\");\n              return null;\n            }\n\n            logger.fine(\"mapped address is=\"+mappedAddress\n                        +\", name=\" + mappedAddress.getHostAddress());\n\n            TransportAddress backupServerAddress\n                =((ChangedAddressAttribute) evt.getMessage()\n                  .getAttribute(Attribute.CHANGED_ADDRESS)).getAddress();\n\n            logger.fine(\"backup server address is=\"+backupServerAddress\n                        + \", name=\" + backupServerAddress.getHostAddress());\n\n            report.setPublicAddress(mappedAddress);\n            if (mappedAddress.equals(localAddress))\n            {\n                evt = doTestII(serverAddress);\n                if (evt == null)\n                {\n                    //Sym UDP Firewall\n                    report.setNatType(StunDiscoveryReport\n                                        .SYMMETRIC_UDP_FIREWALL);\n                    return report;\n                }\n                else\n                {\n                    //open internet\n                    report.setNatType(StunDiscoveryReport.OPEN_INTERNET);\n                    return report;\n\n                }\n            }\n            else\n            {\n                evt = doTestII(serverAddress);\n                if (evt == null)\n                {\n                    evt = doTestI(backupServerAddress);\n                    if (evt == null)\n                    {\n                        logger.info(\"Failed to receive a response from \"\n                                    +\"backup stun server!\");\n                        return report;\n                    }\n                    TransportAddress mappedAddress2 =\n                        ((MappedAddressAttribute)evt.getMessage().\n                            getAttribute(Attribute.MAPPED_ADDRESS))\n                                .getAddress();\n                    if (mappedAddress.equals(mappedAddress2))\n                    {\n                        evt = doTestIII(serverAddress);\n                        if (evt == null)\n                        {\n                            //port restricted cone\n                            report.setNatType(StunDiscoveryReport\n                                              .PORT_RESTRICTED_CONE_NAT);\n                            return report;\n                        }\n                        else\n                        {\n                            //restricted cone\n                            report.setNatType(StunDiscoveryReport\n                                              .RESTRICTED_CONE_NAT);\n                            return report;\n\n                        }\n                    }\n                    else\n                    {\n                        //Symmetric NAT\n                        report.setNatType(StunDiscoveryReport.SYMMETRIC_NAT);\n                        return report;\n                    }\n                }\n                else\n                {\n                    //full cone\n                    report.setNatType(StunDiscoveryReport.FULL_CONE_NAT);\n                    return report;\n                }\n            }\n        }\n\n    }\n\n    /**\n     * Sends a binding request to the specified server address. Both change IP\n     * and change port flags are set to false.\n     * @param serverAddress the address where to send the bindingRequest.\n     * @return The returned message encapsulating event or null if no message\n     * was received.\n     *\n     * @throws StunException if an exception occurs while sending the messge\n     * @throws IOException if an error occurs while sending bytes through\n     * the socket.\n     */\n    private StunMessageEvent doTestI(TransportAddress serverAddress)\n        throws IOException, StunException\n    {\n        Request request = MessageFactory.createBindingRequest();\n\n/*\n        ChangeRequestAttribute changeRequest\n            = (ChangeRequestAttribute)request\n                .getAttribute(Attribute.CHANGE_REQUEST);\n        changeRequest.setChangeIpFlag(false);\n        changeRequest.setChangePortFlag(false);\n*/\n        /* add a change request attribute */\n        ChangeRequestAttribute changeRequest\n            = AttributeFactory.createChangeRequestAttribute();\n        changeRequest.setChangeIpFlag(false);\n        changeRequest.setChangePortFlag(false);\n        request.putAttribute(changeRequest);\n\n        StunMessageEvent evt = null;\n        try\n        {\n            evt = requestSender.sendRequestAndWaitForResponse(\n                    request, serverAddress);\n        }\n        catch (StunException ex)\n        {\n            //this shouldn't happen since we are the ones that created the\n            //request\n            logger.log(Level.SEVERE,\n                       \"Internal Error. Failed to encode a message\",\n                       ex);\n            return null;\n        }\n\n        if (evt != null)\n            logger.fine(\"TEST I res=\"+evt.getRemoteAddress().toString()\n                               +\" - \"+ evt.getRemoteAddress().getHostAddress());\n        else\n            logger.fine(\"NO RESPONSE received to TEST I.\");\n        return evt;\n    }\n\n    /**\n     * Sends a binding request to the specified server address with both change\n     * IP and change port flags are set to true.\n     * @param serverAddress the address where to send the bindingRequest.\n     * @return The returned message encapsulating event or null if no message\n     * was received.\n     *\n     * @throws StunException if an exception occurs while sending the messge\n     * @throws IOException if an exception occurs while executing the algorithm.\n     */\n    private StunMessageEvent doTestII(TransportAddress serverAddress)\n        throws StunException, IOException\n    {\n        Request request = MessageFactory.createBindingRequest();\n\n        /* ChangeRequestAttribute changeRequest\n         *  = (ChangeRequestAttribute)request\n         *   .getAttribute(Attribute.CHANGE_REQUEST); */\n        /* add a change request attribute */\n        ChangeRequestAttribute changeRequest = AttributeFactory.createChangeRequestAttribute();\n        changeRequest.setChangeIpFlag(true);\n        changeRequest.setChangePortFlag(true);\n        request.putAttribute(changeRequest);\n\n        StunMessageEvent evt\n            = requestSender.sendRequestAndWaitForResponse(request,\n                                                          serverAddress);\n        if (evt != null)\n            logger.fine(\"Test II res=\"+evt.getRemoteAddress().toString()\n                            +\" - \"+ evt.getRemoteAddress().getHostAddress());\n        else\n            logger.fine(\"NO RESPONSE received to Test II.\");\n\n        return evt;\n    }\n\n    /**\n     * Sends a binding request to the specified server address with only change\n     * port flag set to true and change IP flag - to false.\n     * @param serverAddress the address where to send the bindingRequest.\n     * @return The returned message encapsulating event or null if no message\n     * was received.\n     * @throws StunException if an exception occurs while sending the messge\n     * @throws IOException if an exception occurs while sending bytes through\n     * the socket.\n     */\n    private StunMessageEvent doTestIII(TransportAddress serverAddress)\n        throws StunException, IOException\n    {\n        Request request = MessageFactory.createBindingRequest();\n\n        /* ChangeRequestAttribute changeRequest\n                = (ChangeRequestAttribute)request.getAttribute(Attribute.CHANGE_REQUEST); */\n        /* add a change request attribute */\n        ChangeRequestAttribute changeRequest = AttributeFactory.createChangeRequestAttribute();\n        changeRequest.setChangeIpFlag(false);\n        changeRequest.setChangePortFlag(true);\n        request.putAttribute(changeRequest);\n\n        StunMessageEvent evt = requestSender.sendRequestAndWaitForResponse(\n            request, serverAddress);\n        if (evt != null)\n            logger.fine(\"Test III res=\"+evt.getRemoteAddress().toString()\n                            +\" - \"+ evt.getRemoteAddress().getHostAddress());\n        else\n            logger.fine(\"NO RESPONSE received to Test III.\");\n\n        return evt;\n    }\n\n    /**\n     * Makes shure the discoverer is operational and throws an\n     * StunException.ILLEGAL_STATE if that is not the case.\n     * @throws StunException ILLEGAL_STATE if the discoverer is not operational.\n     */\n    private void checkStarted()\n        throws StunException\n    {\n        if (!started)\n            throw new StunException(StunException.ILLEGAL_STATE,\n                                    \"The Discoverer must be started before \"\n                                    +\"launching the discovery process!\");\n    }\n\n    //---------- main\n    /**\n     * Runs the discoverer and shows a message dialog with the returned report.\n     * @param args args[0] - stun server address, args[1] - port. in the case of\n     * no args - defaults are provided.\n     * @throws java.lang.Exception if an exception occurrs during the discovery\n     * process.\n     */\n/*\n    public static void main(String[] args)\n        throws Exception\n    {\n        StunAddress localAddr = null;\n        StunAddress serverAddr = null;\n        if(args.length == 4)\n        {\n            localAddr = new StunAddress(args[2],\n                                        Integer.valueOf(args[3]).intValue());\n            serverAddr = new StunAddress(args[0],\n                                         Integer.valueOf(args[1]).intValue());\n        }\n        else\n        {\n            localAddr = new StunAddress(InetAddress.getLocalHost(), 5678);\n            serverAddr = new StunAddress(\"stun01bak.sipphone.com.\", 3479);\n        }\n        NetworkConfigurationDiscoveryProcess addressDiscovery\n            = new NetworkConfigurationDiscoveryProcess(localAddr, serverAddr);\n\n        addressDiscovery.start();\n        StunDiscoveryReport report = addressDiscovery.determineAddress();\n        System.out.println(report);\n    }\n*/\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger =\n        Logger.getLogger(NetworkConfigurationDiscoveryProcess.class.getName());", "docstring": "\nOur class logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger =\n        Logger.getLogger(NetworkConfigurationDiscoveryProcess.class.getName())", "syntax_pass": true}, {"attribute_expression": "private boolean started = false;", "docstring": "\nIndicates whether the underlying stack has been initialized and started\nand that the discoverer is operational.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "started = false", "syntax_pass": true}, {"attribute_expression": "private TransportAddress localAddress  = null;", "docstring": "\nThe point where we'll be listening.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransportAddress", "name": "localAddress  = null", "syntax_pass": true}, {"attribute_expression": "private TransportAddress serverAddress = null;", "docstring": "\nThe address of the stun server\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransportAddress", "name": "serverAddress = null", "syntax_pass": true}, {"attribute_expression": "private BlockingRequestSender requestSender = null;", "docstring": "\nA utility used to flatten the multi thread architecture of the Stack\nand execute the discovery process in a synchronized manner\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BlockingRequestSender", "name": "requestSender = null", "syntax_pass": true}, {"attribute_expression": "private IceSocketWrapper sock = null;", "docstring": "\nThe <tt>DatagramSocket</tt> that we are going to be running the\ndiscovery process through.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IceSocketWrapper", "name": "sock = null", "syntax_pass": true}, {"attribute_expression": "private final StunStack stunStack;", "docstring": "\nThe <tt>StunStack</tt> used by this instance for the purposes of STUN\ncommunication.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StunStack", "name": "stunStack", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport", "name": "StunDiscoveryReport", "file_path": "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java", "superclasses": "", "methods": ["[]StunDiscoveryReport()", "[String]getNatType()", "[void]setNatType(String)", "[TransportAddress]getPublicAddress()", "[void]setPublicAddress(TransportAddress)", "[boolean]equals(Object)", "[String]toString()"], "method_uris": ["src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport.[]StunDiscoveryReport()", "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport.[String]getNatType()", "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport.[void]setNatType(String)", "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport.[TransportAddress]getPublicAddress()", "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport.[void]setPublicAddress(TransportAddress)", "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport.[boolean]equals(Object)", "src/main/java/org/ice4j/stunclient/StunDiscoveryReport.java.StunDiscoveryReport.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nThe class is used to deliver results from a STUN Discovery Process. It\ncontains information about the NAT Server (or firewall )this client is behind,\nand a mapped address value (if discovered)\n\n@author Emil Ivov\n", "original_string": "public class StunDiscoveryReport\n{\n    /**\n     * Indicates that NAT detection has failed or not yet initiated.\n     */\n    public static final String UNKNOWN = \"Unknown Network Configuration\";\n\n    /**\n     * Means, there's no NAT or firewall.\n     */\n    public static final String OPEN_INTERNET = \"Open Internet Configuration\";\n\n    /**\n     * Indicates that UDP communication is not possible.\n     */\n    public static final String UDP_BLOCKING_FIREWALL = \"UDP Blocking Firewall\";\n\n    /**\n     * Means we are behind a symmetric udp firewall.\n     */\n    public static final String SYMMETRIC_UDP_FIREWALL= \"Symmetric UDP Firewall\";\n\n    /**\n     * NAT type is full cone.\n     */\n    public static final String FULL_CONE_NAT = \"Full Cone NAT\";\n\n    /**\n     * We are behind a symmetric nat.\n     */\n    public static final String SYMMETRIC_NAT = \"Symmetric NAT\";\n\n    /**\n     * NAT type is Restricted Cone.\n     */\n    public static final String RESTRICTED_CONE_NAT = \"Restricted Cone NAT\";\n\n    /**\n     * NAT type is port restricted cone.\n     */\n    public static final String PORT_RESTRICTED_CONE_NAT\n                                        = \"Port Restricted Cone NAT\";\n\n    private String natType = UNKNOWN;\n\n\n    private TransportAddress publicAddress = null;\n\n    /**\n     * Creates a discovery report with natType = UNKNOWN and a null public\n     * address.\n     */\n    StunDiscoveryReport()\n    {\n    }\n\n    /**\n     * Returns the type of the NAT described in the report.\n     * @return the type of the NAT that this report is about.\n     */\n    public String getNatType()\n    {\n        return natType;\n    }\n\n    /**\n     * Sets the type of the NAT indicated by the report.\n     * @param natType the type of the NAT.\n     */\n    void setNatType(String natType)\n    {\n        this.natType = natType;\n    }\n\n    /**\n     * Returns the public addressed discovered by a discovery process.\n     * @return an Inetner address for public use.\n     */\n    public TransportAddress getPublicAddress()\n    {\n        return publicAddress;\n    }\n\n    /**\n     * Sets a public address.\n     * @param stunAddress An address that's accesible from everywhere.\n     */\n    void setPublicAddress(TransportAddress stunAddress)\n    {\n        this.publicAddress = stunAddress;\n    }\n\n\n    /**\n     * Compares this object with obj. Two reports are considered equal if and\n     * only if both have the same nat type and their public addresses are\n     * equal or are both null.\n     * @param obj the object to compare against.\n     * @return true if the two objects are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof StunDiscoveryReport))\n           return false;\n\n        if (obj == this)\n            return true;\n\n        StunDiscoveryReport target = (StunDiscoveryReport)obj;\n\n        return (   target.getNatType() == getNatType()\n                && ( getPublicAddress() == null && target.getPublicAddress() == null\n                    || target.getPublicAddress().equals(getPublicAddress())));\n    }\n\n    /**\n     * Returns a readable representation of the report.\n     * @return a readable representation of the report.\n     */\n    public String toString()\n    {\n        return   \"The detected network configuration is: \" + getNatType() + \"\\n\"\n               + \"Your mapped public address is: \" + getPublicAddress();\n    }\n\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String UNKNOWN = \"Unknown Network Configuration\";", "docstring": "\nIndicates that NAT detection has failed or not yet initiated.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "UNKNOWN = \"Unknown Network Configuration\"", "syntax_pass": true}, {"attribute_expression": "public static final String OPEN_INTERNET = \"Open Internet Configuration\";", "docstring": "\nMeans, there's no NAT or firewall.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "OPEN_INTERNET = \"Open Internet Configuration\"", "syntax_pass": true}, {"attribute_expression": "public static final String UDP_BLOCKING_FIREWALL = \"UDP Blocking Firewall\";", "docstring": "\nIndicates that UDP communication is not possible.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "UDP_BLOCKING_FIREWALL = \"UDP Blocking Firewall\"", "syntax_pass": true}, {"attribute_expression": "public static final String SYMMETRIC_UDP_FIREWALL= \"Symmetric UDP Firewall\";", "docstring": "\nMeans we are behind a symmetric udp firewall.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "SYMMETRIC_UDP_FIREWALL= \"Symmetric UDP Firewall\"", "syntax_pass": true}, {"attribute_expression": "public static final String FULL_CONE_NAT = \"Full Cone NAT\";", "docstring": "\nNAT type is full cone.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "FULL_CONE_NAT = \"Full Cone NAT\"", "syntax_pass": true}, {"attribute_expression": "public static final String SYMMETRIC_NAT = \"Symmetric NAT\";", "docstring": "\nWe are behind a symmetric nat.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "SYMMETRIC_NAT = \"Symmetric NAT\"", "syntax_pass": true}, {"attribute_expression": "public static final String RESTRICTED_CONE_NAT = \"Restricted Cone NAT\";", "docstring": "\nNAT type is Restricted Cone.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "RESTRICTED_CONE_NAT = \"Restricted Cone NAT\"", "syntax_pass": true}, {"attribute_expression": "public static final String PORT_RESTRICTED_CONE_NAT\n                                        = \"Port Restricted Cone NAT\";", "docstring": "\nNAT type is port restricted cone.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "PORT_RESTRICTED_CONE_NAT\n                                        = \"Port Restricted Cone NAT\"", "syntax_pass": true}, {"attribute_expression": "private String natType = UNKNOWN;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "natType = UNKNOWN", "syntax_pass": true}, {"attribute_expression": "private TransportAddress publicAddress = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransportAddress", "name": "publicAddress = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector", "name": "SimpleAddressDetector", "file_path": "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java", "superclasses": "", "methods": ["[]SimpleAddressDetector(TransportAddress)", "[TransportAddress]getServerAddress()", "[void]shutDown()", "[void]start()", "[TransportAddress]getMappingFor(IceSocketWrapper)"], "method_uris": ["src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector.[]SimpleAddressDetector(TransportAddress)", "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector.[TransportAddress]getServerAddress()", "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector.[void]shutDown()", "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector.[void]start()", "src/main/java/org/ice4j/stunclient/SimpleAddressDetector.java.SimpleAddressDetector.[TransportAddress]getMappingFor(IceSocketWrapper)"], "overrides": null, "attributes": [], "class_docstring": "\nThe class provides basic means of discovering a public IP address. All it\ndoes is send a binding request through a specified port and return the\nmapped address it got back or <tt>null</tt> if there was no response.\n\n@author Emil Ivov\n", "original_string": "public class SimpleAddressDetector\n{\n    /**\n     * Our class logger.\n     */\n    private static final Logger logger\n        = Logger.getLogger(SimpleAddressDetector.class.getName());\n\n    /**\n     * The stack to use for STUN communication.\n     */\n    private StunStack stunStack = null;\n\n    /**\n     * The address of the stun server\n     */\n    private TransportAddress serverAddress = null;\n\n    /**\n     * A utility used to flatten the multi-threaded architecture of the Stack\n     * and execute the discovery process in a synchronized manner\n     */\n    private BlockingRequestSender requestSender = null;\n\n    /**\n     * Creates a StunAddressDiscoverer. In order to use it one must start the\n     * discoverer.\n     * @param serverAddress the address of the server to interrogate.\n     */\n    public SimpleAddressDetector(TransportAddress serverAddress)\n    {\n        this.serverAddress = serverAddress;\n    }\n\n    /**\n     * Returns the server address that this detector is using to run stun\n     * queries.\n     *\n     * @return StunAddress the address of the stun server that we are running\n     * stun queries against.\n     */\n    public TransportAddress getServerAddress()\n    {\n        return serverAddress;\n    }\n\n    /**\n     * Shuts down the underlying stack and prepares the object for garbage\n     * collection.\n     */\n    public void shutDown()\n    {\n        stunStack = null;\n        requestSender = null;\n    }\n\n    /**\n     * Puts the discoverer into an operational state.\n     */\n    public void start()\n    {\n        stunStack = new StunStack();\n    }\n\n    /**\n     * Creates a listening point for the specified socket and attempts to\n     * discover how its local address is NAT mapped.\n     * @param socket the socket whose address needs to be resolved.\n     * @return a StunAddress object containing the mapped address or null if\n     * discovery failed.\n     *\n     * @throws IOException if something fails along the way.\n     * @throws BindException if we cannot bind the socket.\n     */\n    public TransportAddress getMappingFor(IceSocketWrapper socket)\n       throws IOException, BindException\n    {\n         TransportAddress localAddress = new TransportAddress(\n              (InetSocketAddress)socket.getLocalSocketAddress(), Transport.UDP);\n\n         stunStack.addSocket(socket);\n\n         requestSender = new BlockingRequestSender(stunStack, localAddress);\n         StunMessageEvent evt = null;\n         try\n         {\n             evt = requestSender.sendRequestAndWaitForResponse(\n                 MessageFactory.createBindingRequest(), serverAddress);\n         }\n         catch(StunException exc)\n         {\n             //this shouldn't be happening since we are the one that constructed\n             //the request, so let's catch it here and not oblige users to\n             //handle exception they are not responsible for.\n             logger.log(Level.SEVERE, \"Internal Error. We apparently \"\n                        +\"constructed a faulty request.\", exc);\n             return null;\n         }\n         finally\n         {\n             stunStack.removeSocket(localAddress);\n         }\n\n        if (evt != null)\n        {\n            Response res = (Response)evt.getMessage();\n\n             /* in classic STUN, the response contains a MAPPED-ADDRESS */\n             MappedAddressAttribute maAtt = (MappedAddressAttribute)\n                                 res.getAttribute(Attribute.MAPPED_ADDRESS);\n             if (maAtt != null)\n             {\n                  return maAtt.getAddress();\n             }\n\n             /* in STUN bis, the response contains a XOR-MAPPED-ADDRESS */\n             XorMappedAddressAttribute xorAtt = (XorMappedAddressAttribute)res\n                 .getAttribute(Attribute.XOR_MAPPED_ADDRESS);\n             if (xorAtt != null)\n             {\n               byte xoring[] = new byte[16];\n\n               System.arraycopy(Message.MAGIC_COOKIE, 0, xoring, 0, 4);\n               System.arraycopy(res.getTransactionID(), 0, xoring, 4, 12);\n\n              return xorAtt.applyXor(xoring);\n            }\n       }\n\n       return null;\n   }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(SimpleAddressDetector.class.getName());", "docstring": "\nOur class logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(SimpleAddressDetector.class.getName())", "syntax_pass": true}, {"attribute_expression": "private StunStack stunStack = null;", "docstring": "\nThe stack to use for STUN communication.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StunStack", "name": "stunStack = null", "syntax_pass": true}, {"attribute_expression": "private TransportAddress serverAddress = null;", "docstring": "\nThe address of the stun server\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransportAddress", "name": "serverAddress = null", "syntax_pass": true}, {"attribute_expression": "private BlockingRequestSender requestSender = null;", "docstring": "\nA utility used to flatten the multi-threaded architecture of the Stack\nand execute the discovery process in a synchronized manner\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BlockingRequestSender", "name": "requestSender = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher", "name": "EventDispatcher", "file_path": "src/main/java/org/ice4j/stack/EventDispatcher.java", "superclasses": "", "methods": ["[]EventDispatcher()", "[void]addIndicationListener(TransportAddress,MessageEventHandler)", "[void]addOldIndicationListener(TransportAddress,MessageEventHandler)", "[void]addMessageListener(MessageTypeEventHandler<?>)", "[void]addMessageListener(TransportAddress,MessageTypeEventHandler<?>)", "[void]addRequestListener(RequestListener)", "[void]addRequestListener(TransportAddress,RequestListener)", "[void]removeMessageListener(MessageTypeEventHandler<?>)", "[void]removeMessageListener(TransportAddress,MessageTypeEventHandler<?>)", "[void]removeRequestListener(RequestListener)", "[void]removeRequestListener(TransportAddress,RequestListener)", "[void]fireMessageEvent(StunMessageEvent)", "[boolean]hasRequestListeners(TransportAddress)", "[void]removeAllListeners()"], "method_uris": ["src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[]EventDispatcher()", "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]addIndicationListener(TransportAddress,MessageEventHandler)", "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]addOldIndicationListener(TransportAddress,MessageEventHandler)", "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]addMessageListener(MessageTypeEventHandler<?>)", "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]addMessageListener(TransportAddress,MessageTypeEventHandler<?>)", "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]addRequestListener(RequestListener)", "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]addRequestListener(TransportAddress,RequestListener)", "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]removeMessageListener(MessageTypeEventHandler<?>)", "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]removeMessageListener(TransportAddress,MessageTypeEventHandler<?>)", "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]removeRequestListener(RequestListener)", "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]removeRequestListener(TransportAddress,RequestListener)", "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]fireMessageEvent(StunMessageEvent)", "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[boolean]hasRequestListeners(TransportAddress)", "src/main/java/org/ice4j/stack/EventDispatcher.java.EventDispatcher.[void]removeAllListeners()"], "overrides": null, "attributes": [{"original_string": "    private static class IndicationEventHandler\n        extends MessageTypeEventHandler<MessageEventHandler>\n    {\n\n        /**\n         * Initializes a new <tt>IndicationEventHandler</tt> which is to\n         * implement <tt>MessageEventHandler</tt> for a specific\n         * <tt>MessageEventHandler</tt> which handles STUN indications.\n         *\n         * @param indicationListener the <tt>RequestListener</tt> for which the\n         * new instance is to implement <tt>MessageEventHandler</tt>\n         */\n        public IndicationEventHandler(MessageEventHandler indicationListener)\n        {\n            super(Message.STUN_INDICATION, indicationListener);\n        }\n\n        /**\n         * Notifies this <tt>MessageEventHandler</tt> that a STUN message has\n         * been received, parsed and is ready for delivery.\n         *\n         * @param e a <tt>StunMessageEvent</tt> which encapsulates the STUN\n         * message to be handled\n         * @see MessageEventHandler#handleMessageEvent(StunMessageEvent)\n         */\n        public void handleMessageEvent(StunMessageEvent e)\n        {\n            delegate.handleMessageEvent(e);\n        }\n    }", "definition": "    private static class IndicationEventHandler\n        extends MessageTypeEventHandler<MessageEventHandler>", "class_docstring": "\nImplements <tt>MessageEventHandler</tt> for a\n<tt>MessageEventHandler</tt> which handles STUN indications.\n\n@author Lubomir Marinov\n", "name": "IndicationEventHandler", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public IndicationEventHandler(MessageEventHandler indicationListener)\n        {\n            super(Message.STUN_INDICATION, indicationListener);\n        }", "docstring": "\nInitializes a new <tt>IndicationEventHandler</tt> which is to\nimplement <tt>MessageEventHandler</tt> for a specific\n<tt>MessageEventHandler</tt> which handles STUN indications.\n\n@param indicationListener the <tt>RequestListener</tt> for which the\nnew instance is to implement <tt>MessageEventHandler</tt>\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "IndicationEventHandler", "params": [{"name": "indicationListener", "type": "MessageEventHandler"}], "body": "        {\n            super(Message.STUN_INDICATION, indicationListener);\n        }", "signature": "public IndicationEventHandler(MessageEventHandler indicationListener)"}, {"syntax_pass": true, "original_string": "        public void handleMessageEvent(StunMessageEvent e)\n        {\n            delegate.handleMessageEvent(e);\n        }", "docstring": "\nNotifies this <tt>MessageEventHandler</tt> that a STUN message has\nbeen received, parsed and is ready for delivery.\n\n@param e a <tt>StunMessageEvent</tt> which encapsulates the STUN\nmessage to be handled\n@see MessageEventHandler#handleMessageEvent(StunMessageEvent)\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "handleMessageEvent", "params": [{"name": "e", "type": "StunMessageEvent"}], "body": "        {\n            delegate.handleMessageEvent(e);\n        }", "signature": "public void handleMessageEvent(StunMessageEvent e)"}]}, {"original_string": "    private static class OldIndicationEventHandler\n        extends MessageTypeEventHandler<MessageEventHandler>\n    {\n\n        /**\n         * Initializes a new <tt>IndicationEventHandler</tt> which is to\n         * implement <tt>MessageEventHandler</tt> for a specific\n         * <tt>MessageEventHandler</tt> which handles old DATA indications\n         * (0x0115).\n         *\n         * @param indicationListener the <tt>RequestListener</tt> for which the\n         * new instance is to implement <tt>MessageEventHandler</tt>\n         */\n        public OldIndicationEventHandler(MessageEventHandler indicationListener)\n        {\n            super((char)0x0110, indicationListener);\n        }\n\n        /**\n         * Notifies this <tt>MessageEventHandler</tt> that a STUN message has\n         * been received, parsed and is ready for delivery.\n         *\n         * @param e a <tt>StunMessageEvent</tt> which encapsulates the STUN\n         * message to be handled\n         * @see MessageEventHandler#handleMessageEvent(StunMessageEvent)\n         */\n        public void handleMessageEvent(StunMessageEvent e)\n        {\n            delegate.handleMessageEvent(e);\n        }\n    }", "definition": "    private static class OldIndicationEventHandler\n        extends MessageTypeEventHandler<MessageEventHandler>", "class_docstring": "\nImplements <tt>MessageEventHandler</tt> for a\n<tt>MessageEventHandler</tt> which handles old DATA indications (0x0115).\n\n@author Lubomir Marinov\n@author Sebastien Vincent\n", "name": "OldIndicationEventHandler", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public OldIndicationEventHandler(MessageEventHandler indicationListener)\n        {\n            super((char)0x0110, indicationListener);\n        }", "docstring": "\nInitializes a new <tt>IndicationEventHandler</tt> which is to\nimplement <tt>MessageEventHandler</tt> for a specific\n<tt>MessageEventHandler</tt> which handles old DATA indications\n(0x0115).\n\n@param indicationListener the <tt>RequestListener</tt> for which the\nnew instance is to implement <tt>MessageEventHandler</tt>\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "OldIndicationEventHandler", "params": [{"name": "indicationListener", "type": "MessageEventHandler"}], "body": "        {\n            super((char)0x0110, indicationListener);\n        }", "signature": "public OldIndicationEventHandler(MessageEventHandler indicationListener)"}, {"syntax_pass": true, "original_string": "        public void handleMessageEvent(StunMessageEvent e)\n        {\n            delegate.handleMessageEvent(e);\n        }", "docstring": "\nNotifies this <tt>MessageEventHandler</tt> that a STUN message has\nbeen received, parsed and is ready for delivery.\n\n@param e a <tt>StunMessageEvent</tt> which encapsulates the STUN\nmessage to be handled\n@see MessageEventHandler#handleMessageEvent(StunMessageEvent)\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "handleMessageEvent", "params": [{"name": "e", "type": "StunMessageEvent"}], "body": "        {\n            delegate.handleMessageEvent(e);\n        }", "signature": "public void handleMessageEvent(StunMessageEvent e)"}]}, {"original_string": "    private static abstract class MessageTypeEventHandler<T>\n        implements MessageEventHandler\n    {\n\n        /**\n         * The <tt>Object</tt> for which this instance implements\n         * <tt>MessageEventHandler</tt>.\n         */\n        public final T delegate;\n\n        /**\n         * The type of the STUN messages that this <tt>MessageEventHandler</tt>\n         * is interested in.\n         */\n        public final char messageType;\n\n        /**\n         * Initializes a new <tt>MessageTypeEventHandler</tt> which is to\n         * forward STUN messages with a specific type to a specific handler.\n         *\n         * @param messageType the type of the STUN messages that the new\n         * instance is to forward to the specified handler <tt>delegate</tt>\n         * @param delegate the handler to which the new instance is to forward\n         * STUN messages with the specified <tt>messageType</tt>\n         */\n        public MessageTypeEventHandler(char messageType, T delegate)\n        {\n            if (delegate == null)\n                throw new NullPointerException(\"delegate\");\n\n            this.messageType = messageType;\n            this.delegate = delegate;\n        }\n\n        /**\n         * Determines whether a specific <tt>Object</tt> is value equal to this\n         * <tt>Object</tt>.\n         *\n         * @param obj the <tt>Object</tt> to be compared to this <tt>Object</tt>\n         * for value equality\n         * @return <tt>true</tt> if this <tt>Object</tt> is value equal to the\n         * specified <tt>obj</tt>\n         */\n        @Override\n        public boolean equals(Object obj)\n        {\n            if (this == obj)\n                return true;\n            if (!getClass().isInstance(obj))\n                return false;\n\n            MessageTypeEventHandler<?> mteh = (MessageTypeEventHandler<?>) obj;\n\n            return\n                (messageType == mteh.messageType)\n                    && delegate.equals(mteh.delegate);\n        }\n\n        /**\n         * Returns a hash code value for this <tt>Object</tt> for the benefit of\n         * hashtables.\n         *\n         * @return a hash code value for this <tt>Object</tt> for the benefit of\n         * hashtables\n         */\n        @Override\n        public int hashCode()\n        {\n            return (messageType | delegate.hashCode());\n        }\n    }", "definition": "    private static abstract class MessageTypeEventHandler<T>\n        implements MessageEventHandler", "class_docstring": "\nRepresents the base for providers of <tt>MessageEventHandler</tt>\nimplementations to specific <tt>Object</tt>s.\n\n@author Lubomir Marinov\n@param <T> the type of the delegate to which the notifications are to be\nforwarded\n", "name": "MessageTypeEventHandler", "super_interfaces": ["MessageEventHandler"], "superclasses": "", "attributes": {"modifiers": "private static abstract", "marker_annotations": [], "non_marker_annotations": ["private", "static", "abstract"], "comments": [], "fields": [{"attribute_expression": "public final T delegate;", "docstring": "\nThe <tt>Object</tt> for which this instance implements\n<tt>MessageEventHandler</tt>.\n", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "T", "name": "delegate", "syntax_pass": true}, {"attribute_expression": "public final char messageType;", "docstring": "\nThe type of the STUN messages that this <tt>MessageEventHandler</tt>\nis interested in.\n", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "char", "name": "messageType", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public MessageTypeEventHandler(char messageType, T delegate)\n        {\n            if (delegate == null)\n                throw new NullPointerException(\"delegate\");\n\n            this.messageType = messageType;\n            this.delegate = delegate;\n        }", "docstring": "\nInitializes a new <tt>MessageTypeEventHandler</tt> which is to\nforward STUN messages with a specific type to a specific handler.\n\n@param messageType the type of the STUN messages that the new\ninstance is to forward to the specified handler <tt>delegate</tt>\n@param delegate the handler to which the new instance is to forward\nSTUN messages with the specified <tt>messageType</tt>\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "MessageTypeEventHandler", "params": [{"name": "messageType", "type": "char"}, {"name": "delegate", "type": "T"}], "body": "        {\n            if (delegate == null)\n                throw new NullPointerException(\"delegate\");\n\n            this.messageType = messageType;\n            this.delegate = delegate;\n        }", "signature": "public MessageTypeEventHandler(char messageType, T delegate)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(Object obj)\n        {\n            if (this == obj)\n                return true;\n            if (!getClass().isInstance(obj))\n                return false;\n\n            MessageTypeEventHandler<?> mteh = (MessageTypeEventHandler<?>) obj;\n\n            return\n                (messageType == mteh.messageType)\n                    && delegate.equals(mteh.delegate);\n        }", "docstring": "\nDetermines whether a specific <tt>Object</tt> is value equal to this\n<tt>Object</tt>.\n\n@param obj the <tt>Object</tt> to be compared to this <tt>Object</tt>\nfor value equality\n@return <tt>true</tt> if this <tt>Object</tt> is value equal to the\nspecified <tt>obj</tt>\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "        {\n            if (this == obj)\n                return true;\n            if (!getClass().isInstance(obj))\n                return false;\n\n            MessageTypeEventHandler<?> mteh = (MessageTypeEventHandler<?>) obj;\n\n            return\n                (messageType == mteh.messageType)\n                    && delegate.equals(mteh.delegate);\n        }", "signature": "@Override\n        public boolean equals(Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode()\n        {\n            return (messageType | delegate.hashCode());\n        }", "docstring": "\nReturns a hash code value for this <tt>Object</tt> for the benefit of\nhashtables.\n\n@return a hash code value for this <tt>Object</tt> for the benefit of\nhashtables\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "        {\n            return (messageType | delegate.hashCode());\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    private static class RequestListenerMessageEventHandler\n        extends MessageTypeEventHandler<RequestListener>\n    {\n\n        /**\n         * Initializes a new <tt>RequestListenerMessageEventHandler</tt> which\n         * is to implement <tt>MessageEventHandler</tt> for a specific\n         * <tt>RequestListener</tt>.\n         *\n         * @param requestListener the <tt>RequestListener</tt> for which the new\n         * instance is to implement <tt>MessageEventHandler</tt>\n         */\n        public RequestListenerMessageEventHandler(\n                RequestListener requestListener)\n        {\n            super(Message.STUN_REQUEST, requestListener);\n        }\n\n        /**\n         * Notifies this <tt>MessageEventHandler</tt> that a STUN message has\n         * been received, parsed and is ready for delivery.\n         *\n         * @param e a <tt>StunMessageEvent</tt> which encapsulates the STUN\n         * message to be handled\n         * @see MessageEventHandler#handleMessageEvent(StunMessageEvent)\n         */\n        public void handleMessageEvent(StunMessageEvent e)\n        {\n            delegate.processRequest(e);\n        }\n    }", "definition": "    private static class RequestListenerMessageEventHandler\n        extends MessageTypeEventHandler<RequestListener>", "class_docstring": "\nImplements <tt>MessageEventHandler</tt> for <tt>RequestListener</tt>.\n\n@author Lubomir Marinov\n", "name": "RequestListenerMessageEventHandler", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public RequestListenerMessageEventHandler(\n                RequestListener requestListener)\n        {\n            super(Message.STUN_REQUEST, requestListener);\n        }", "docstring": "\nInitializes a new <tt>RequestListenerMessageEventHandler</tt> which\nis to implement <tt>MessageEventHandler</tt> for a specific\n<tt>RequestListener</tt>.\n\n@param requestListener the <tt>RequestListener</tt> for which the new\ninstance is to implement <tt>MessageEventHandler</tt>\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "RequestListenerMessageEventHandler", "params": [{"name": "requestListener", "type": "RequestListener"}], "body": "        {\n            super(Message.STUN_REQUEST, requestListener);\n        }", "signature": "public RequestListenerMessageEventHandler(\n                RequestListener requestListener)"}, {"syntax_pass": true, "original_string": "        public void handleMessageEvent(StunMessageEvent e)\n        {\n            delegate.processRequest(e);\n        }", "docstring": "\nNotifies this <tt>MessageEventHandler</tt> that a STUN message has\nbeen received, parsed and is ready for delivery.\n\n@param e a <tt>StunMessageEvent</tt> which encapsulates the STUN\nmessage to be handled\n@see MessageEventHandler#handleMessageEvent(StunMessageEvent)\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "handleMessageEvent", "params": [{"name": "e", "type": "StunMessageEvent"}], "body": "        {\n            delegate.processRequest(e);\n        }", "signature": "public void handleMessageEvent(StunMessageEvent e)"}]}], "class_docstring": "\nThis is a utility class used for dispatching incoming request events. We use\nthis class mainly (and probably solely) for its ability to handle listener\nproxies (i.e. listeners interested in requests received on a particular\nNetAccessPoint only).\n\n@author Emil Ivov\n@author Lubomir Marinov\n", "original_string": "public class EventDispatcher\n{\n\n    /**\n     * The STUN request and indication listeners registered with this\n     * <tt>EventDispatcher</tt>.\n     */\n    private final List<MessageTypeEventHandler<?>> messageListeners\n        = new Vector<>();\n\n    /**\n     * The <tt>Map</tt> of <tt>EventDispatcher</tt>s which keep the\n     * registrations of STUN request and indication listeners registered for\n     * STUN requests and indications from specific local\n     * <tt>TransportAddress</tt>es.\n     */\n    private final Map<TransportAddress, EventDispatcher> children\n        = new Hashtable<>();\n\n    /**\n     * Initializes a new <tt>EventDispatcher</tt> instance.\n     */\n    public EventDispatcher()\n    {\n    }\n\n    /**\n     * Registers a specific <tt>MessageEventHandler</tt> for notifications about\n     * STUN indications received at a specific local <tt>TransportAddress</tt>.\n     *\n     * @param localAddr the local <tt>TransportAddress</tt> STUN indications\n     * received at which are to be reported to the specified\n     * <tt>indicationListener</tt>\n     * @param indicationListener the <tt>MessageEventHandler</tt> which is to be\n     * registered for notifications about STUN indications received at the\n     * specified local <tt>TransportAddress</tt>\n     */\n    public void addIndicationListener(\n            TransportAddress localAddr,\n            MessageEventHandler indicationListener)\n    {\n        addMessageListener(\n                localAddr,\n                new IndicationEventHandler(indicationListener));\n    }\n\n    /**\n     * Registers a specific <tt>MessageEventHandler</tt> for notifications about\n     * old indications received at a specific local <tt>TransportAddress</tt>.\n     *\n     * @param localAddr the local <tt>TransportAddress</tt> STUN indications\n     * received at which are to be reported to the specified\n     * <tt>indicationListener</tt>\n     * @param indicationListener the <tt>MessageEventHandler</tt> which is to be\n     * registered for notifications about old indications received at the\n     * specified local <tt>TransportAddress</tt>\n     */\n    public void addOldIndicationListener(\n            TransportAddress localAddr,\n            MessageEventHandler indicationListener)\n    {\n        addMessageListener(\n                localAddr,\n                new OldIndicationEventHandler(indicationListener));\n    }\n\n    /**\n     * Registers a specific <tt>MessageTypeEventHandler</tt> for notifications\n     * about received STUN messages.\n     *\n     * @param messageListener the <tt>MessageTypeEventHandler</tt> which is to\n     * be registered for notifications about received STUN messages\n     */\n    private synchronized void addMessageListener(\n            MessageTypeEventHandler<?> messageListener)\n    {\n        synchronized(messageListeners)\n        {\n            if (!messageListeners.contains(messageListener))\n                messageListeners.add(messageListener);\n        }\n    }\n\n    /**\n     * Registers a specific <tt>MessageTypeEventHandler</tt> for notifications\n     * about STUN messages received at a specific local\n     * <tt>TransportAddress</tt>.\n     *\n     * @param localAddr the local <tt>TransportAddress</tt> STUN messages\n     * received at which are to be reported to the specified\n     * <tt>messageListener</tt>\n     * @param messageListener the <tt>MessageTypeEventHandler</tt> which is to\n     * be registered for notifications about STUN messages received at the\n     * specified local <tt>TransportAddress</tt>\n     */\n    private synchronized void addMessageListener(\n            TransportAddress localAddr,\n            MessageTypeEventHandler<?> messageListener)\n    {\n        synchronized(children)\n        {\n            EventDispatcher child = children.get(localAddr);\n\n            if (child == null)\n            {\n                child = new EventDispatcher();\n                children.put(localAddr, child);\n            }\n            child.addMessageListener(messageListener);\n        }\n    }\n\n    /**\n     * Add a RequestListener to the listener list. The listener is registered\n     * for requests coming from no matter which NetAccessPoint.\n     *\n     * @param listener  The RequestListener to be added\n     */\n    public void addRequestListener(RequestListener listener)\n    {\n        addMessageListener(new RequestListenerMessageEventHandler(listener));\n    }\n\n    /**\n     * Add a RequestListener for a specific NetAccessPoint. The listener\n     * will be invoked only when a call on fireRequestReceived is issued for\n     * that specific NetAccessPoint.\n     *\n     * @param localAddr  The NETAP descriptor that we're interested in.\n     * @param listener  The ConfigurationChangeListener to be added\n     */\n    public void addRequestListener( TransportAddress localAddr,\n                                    RequestListener  listener)\n    {\n        addMessageListener(\n                localAddr,\n                new RequestListenerMessageEventHandler(listener));\n    }\n\n    /**\n     * Unregisters a specific <tt>MessageTypeEventHandler</tt> from\n     * notifications about received STUN messages.\n     *\n     * @param messageListener the <tt>MessageTypeEventHandler</tt> to be\n     * unregistered for notifications about received STUN messages\n     */\n    private synchronized void removeMessageListener(\n            MessageTypeEventHandler<?> messageListener)\n    {\n        synchronized(messageListeners)\n        {\n            messageListeners.remove(messageListener);\n        }\n    }\n\n    /**\n     * Unregisters a specific <tt>MessageTypeEventHandler</tt> from\n     * notifications about STUN messages received at a specific local\n     * <tt>TransportAddress</tt>.\n     *\n     * @param localAddr the local <tt>TransportAddress</tt> STUN messages\n     * received at which to no longer be reported to the specified\n     * <tt>messageListener</tt>\n     * @param messageListener the <tt>MessageTypeEventHandler</tt> to be\n     * unregistered for notifications about STUN messages received at the\n     * specified local <tt>TransportAddress</tt>\n     */\n    private synchronized void removeMessageListener(\n            TransportAddress localAddr,\n            MessageTypeEventHandler<?> messageListener)\n    {\n        synchronized(children)\n        {\n            EventDispatcher child = children.get( localAddr );\n\n            if (child == null)\n                return;\n            child.removeMessageListener(messageListener);\n        }\n    }\n\n    /**\n     * Remove a RquestListener from the listener list.\n     * This removes a RequestListener that was registered\n     * for all NetAccessPoints and would not remove listeners registered for\n     * specific NetAccessPointDescriptors.\n     *\n     * @param listener The RequestListener to be removed\n     */\n    public void removeRequestListener(RequestListener listener)\n    {\n        removeMessageListener(new RequestListenerMessageEventHandler(listener));\n    }\n\n    /**\n     * Remove a RequestListener for a specific NetAccessPointDescriptor. This\n     * would only remove the listener for the specified NetAccessPointDescriptor\n     * and would not remove it if it was also registered as a wildcard listener.\n     *\n     * @param localAddr  The NetAPDescriptor that was listened on.\n     * @param listener  The RequestListener to be removed\n     */\n    public void removeRequestListener(TransportAddress localAddr,\n                                      RequestListener  listener)\n    {\n        removeMessageListener(\n                localAddr,\n                new RequestListenerMessageEventHandler(listener));\n    }\n\n\n    /**\n     * Dispatch a StunMessageEvent to any registered listeners.\n     *\n     * @param evt  The request event to be delivered.\n     */\n    public void fireMessageEvent(StunMessageEvent evt)\n    {\n        TransportAddress localAddr = evt.getLocalAddress();\n        MessageTypeEventHandler<?>[] messageListenersCopy;\n\n        synchronized(messageListeners)\n        {\n            messageListenersCopy\n                = messageListeners.toArray(\n                        new MessageTypeEventHandler<?>[\n                                messageListeners.size()]);\n        }\n\n        char messageType = (char) (evt.getMessage().getMessageType() & 0x0110);\n\n        for (MessageTypeEventHandler<?> messageListener : messageListenersCopy)\n        {\n            if (messageType == messageListener.messageType)\n                messageListener.handleMessageEvent(evt);\n        }\n\n        synchronized(children)\n        {\n            EventDispatcher child = children.get(localAddr);\n\n            if (child != null)\n                child.fireMessageEvent(evt);\n        }\n    }\n\n    /**\n     * Check if there are any listeners for a specific address.\n     * (Generic listeners count as well)\n     *\n     * @param localAddr the NetAccessPointDescriptor.\n     * @return true if there are one or more listeners for the specified\n     * NetAccessPointDescriptor\n     */\n    public boolean hasRequestListeners(TransportAddress localAddr)\n    {\n        synchronized(messageListeners)\n        {\n            if (!messageListeners.isEmpty())\n            {\n                // there is a generic listener\n                return true;\n            }\n        }\n\n        synchronized(children)\n        {\n            if (!children.isEmpty())\n            {\n                EventDispatcher child = children.get(localAddr);\n\n                if (child != null)\n                    return !child.messageListeners.isEmpty();\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Removes (absolutely all listeners for this event dispatcher).\n     */\n    public void removeAllListeners()\n    {\n        messageListeners.clear();\n        children.clear();\n    }\n\n    /**\n     * Implements <tt>MessageEventHandler</tt> for a\n     * <tt>MessageEventHandler</tt> which handles STUN indications.\n     *\n     * @author Lubomir Marinov\n     */\n    private static class IndicationEventHandler\n        extends MessageTypeEventHandler<MessageEventHandler>\n    {\n\n        /**\n         * Initializes a new <tt>IndicationEventHandler</tt> which is to\n         * implement <tt>MessageEventHandler</tt> for a specific\n         * <tt>MessageEventHandler</tt> which handles STUN indications.\n         *\n         * @param indicationListener the <tt>RequestListener</tt> for which the\n         * new instance is to implement <tt>MessageEventHandler</tt>\n         */\n        public IndicationEventHandler(MessageEventHandler indicationListener)\n        {\n            super(Message.STUN_INDICATION, indicationListener);\n        }\n\n        /**\n         * Notifies this <tt>MessageEventHandler</tt> that a STUN message has\n         * been received, parsed and is ready for delivery.\n         *\n         * @param e a <tt>StunMessageEvent</tt> which encapsulates the STUN\n         * message to be handled\n         * @see MessageEventHandler#handleMessageEvent(StunMessageEvent)\n         */\n        public void handleMessageEvent(StunMessageEvent e)\n        {\n            delegate.handleMessageEvent(e);\n        }\n    }\n\n    /**\n     * Implements <tt>MessageEventHandler</tt> for a\n     * <tt>MessageEventHandler</tt> which handles old DATA indications (0x0115).\n     *\n     * @author Lubomir Marinov\n     * @author Sebastien Vincent\n     */\n    private static class OldIndicationEventHandler\n        extends MessageTypeEventHandler<MessageEventHandler>\n    {\n\n        /**\n         * Initializes a new <tt>IndicationEventHandler</tt> which is to\n         * implement <tt>MessageEventHandler</tt> for a specific\n         * <tt>MessageEventHandler</tt> which handles old DATA indications\n         * (0x0115).\n         *\n         * @param indicationListener the <tt>RequestListener</tt> for which the\n         * new instance is to implement <tt>MessageEventHandler</tt>\n         */\n        public OldIndicationEventHandler(MessageEventHandler indicationListener)\n        {\n            super((char)0x0110, indicationListener);\n        }\n\n        /**\n         * Notifies this <tt>MessageEventHandler</tt> that a STUN message has\n         * been received, parsed and is ready for delivery.\n         *\n         * @param e a <tt>StunMessageEvent</tt> which encapsulates the STUN\n         * message to be handled\n         * @see MessageEventHandler#handleMessageEvent(StunMessageEvent)\n         */\n        public void handleMessageEvent(StunMessageEvent e)\n        {\n            delegate.handleMessageEvent(e);\n        }\n    }\n\n    /**\n     * Represents the base for providers of <tt>MessageEventHandler</tt>\n     * implementations to specific <tt>Object</tt>s.\n     *\n     * @author Lubomir Marinov\n     * @param <T> the type of the delegate to which the notifications are to be\n     * forwarded\n     */\n    private static abstract class MessageTypeEventHandler<T>\n        implements MessageEventHandler\n    {\n\n        /**\n         * The <tt>Object</tt> for which this instance implements\n         * <tt>MessageEventHandler</tt>.\n         */\n        public final T delegate;\n\n        /**\n         * The type of the STUN messages that this <tt>MessageEventHandler</tt>\n         * is interested in.\n         */\n        public final char messageType;\n\n        /**\n         * Initializes a new <tt>MessageTypeEventHandler</tt> which is to\n         * forward STUN messages with a specific type to a specific handler.\n         *\n         * @param messageType the type of the STUN messages that the new\n         * instance is to forward to the specified handler <tt>delegate</tt>\n         * @param delegate the handler to which the new instance is to forward\n         * STUN messages with the specified <tt>messageType</tt>\n         */\n        public MessageTypeEventHandler(char messageType, T delegate)\n        {\n            if (delegate == null)\n                throw new NullPointerException(\"delegate\");\n\n            this.messageType = messageType;\n            this.delegate = delegate;\n        }\n\n        /**\n         * Determines whether a specific <tt>Object</tt> is value equal to this\n         * <tt>Object</tt>.\n         *\n         * @param obj the <tt>Object</tt> to be compared to this <tt>Object</tt>\n         * for value equality\n         * @return <tt>true</tt> if this <tt>Object</tt> is value equal to the\n         * specified <tt>obj</tt>\n         */\n        @Override\n        public boolean equals(Object obj)\n        {\n            if (this == obj)\n                return true;\n            if (!getClass().isInstance(obj))\n                return false;\n\n            MessageTypeEventHandler<?> mteh = (MessageTypeEventHandler<?>) obj;\n\n            return\n                (messageType == mteh.messageType)\n                    && delegate.equals(mteh.delegate);\n        }\n\n        /**\n         * Returns a hash code value for this <tt>Object</tt> for the benefit of\n         * hashtables.\n         *\n         * @return a hash code value for this <tt>Object</tt> for the benefit of\n         * hashtables\n         */\n        @Override\n        public int hashCode()\n        {\n            return (messageType | delegate.hashCode());\n        }\n    }\n\n    /**\n     * Implements <tt>MessageEventHandler</tt> for <tt>RequestListener</tt>.\n     *\n     * @author Lubomir Marinov\n     */\n    private static class RequestListenerMessageEventHandler\n        extends MessageTypeEventHandler<RequestListener>\n    {\n\n        /**\n         * Initializes a new <tt>RequestListenerMessageEventHandler</tt> which\n         * is to implement <tt>MessageEventHandler</tt> for a specific\n         * <tt>RequestListener</tt>.\n         *\n         * @param requestListener the <tt>RequestListener</tt> for which the new\n         * instance is to implement <tt>MessageEventHandler</tt>\n         */\n        public RequestListenerMessageEventHandler(\n                RequestListener requestListener)\n        {\n            super(Message.STUN_REQUEST, requestListener);\n        }\n\n        /**\n         * Notifies this <tt>MessageEventHandler</tt> that a STUN message has\n         * been received, parsed and is ready for delivery.\n         *\n         * @param e a <tt>StunMessageEvent</tt> which encapsulates the STUN\n         * message to be handled\n         * @see MessageEventHandler#handleMessageEvent(StunMessageEvent)\n         */\n        public void handleMessageEvent(StunMessageEvent e)\n        {\n            delegate.processRequest(e);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final List<MessageTypeEventHandler<?>> messageListeners\n        = new Vector<>();", "docstring": "\nThe STUN request and indication listeners registered with this\n<tt>EventDispatcher</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<MessageTypeEventHandler<?>>", "name": "messageListeners\n        = new Vector<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<TransportAddress, EventDispatcher> children\n        = new Hashtable<>();", "docstring": "\nThe <tt>Map</tt> of <tt>EventDispatcher</tt>s which keep the\nregistrations of STUN request and indication listeners registered for\nSTUN requests and indications from specific local\n<tt>TransportAddress</tt>es.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<TransportAddress, EventDispatcher>", "name": "children\n        = new Hashtable<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager", "name": "NetAccessManager", "file_path": "src/main/java/org/ice4j/stack/NetAccessManager.java", "superclasses": "", "methods": ["[]NetAccessManager(StunStack)", "[]NetAccessManager(StunStack,PeerUdpMessageEventHandler,ChannelDataEventHandler)", "[MessageEventHandler]getMessageEventHandler()", "[PeerUdpMessageEventHandler]getUdpMessageEventHandler()", "[ChannelDataEventHandler]getChannelDataMessageEventHandler()", "[StunStack]getStunStack()", "[void]handleError(String,Throwable)", "[void]handleFatalError(Runnable,String,Throwable)", "[void]addSocket(IceSocketWrapper)", "[void]addSocket(IceSocketWrapper,TransportAddress)", "[void]removeSocket(TransportAddress,TransportAddress)", "[void]stop()", "[Connector]getConnector(TransportAddress,TransportAddress)", "[void]onIncomingRawMessage(RawMessage)", "[void]sendMessage(Message,TransportAddress,TransportAddress)", "[void]sendMessage(ChannelData,TransportAddress,TransportAddress)", "[void]sendMessage(byte[],TransportAddress,TransportAddress)"], "method_uris": ["src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[]NetAccessManager(StunStack)", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[]NetAccessManager(StunStack,PeerUdpMessageEventHandler,ChannelDataEventHandler)", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[MessageEventHandler]getMessageEventHandler()", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[PeerUdpMessageEventHandler]getUdpMessageEventHandler()", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[ChannelDataEventHandler]getChannelDataMessageEventHandler()", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[StunStack]getStunStack()", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]handleError(String,Throwable)", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]handleFatalError(Runnable,String,Throwable)", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]addSocket(IceSocketWrapper)", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]addSocket(IceSocketWrapper,TransportAddress)", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]removeSocket(TransportAddress,TransportAddress)", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]stop()", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[Connector]getConnector(TransportAddress,TransportAddress)", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]onIncomingRawMessage(RawMessage)", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]sendMessage(Message,TransportAddress,TransportAddress)", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]sendMessage(ChannelData,TransportAddress,TransportAddress)", "src/main/java/org/ice4j/stack/NetAccessManager.java.NetAccessManager.[void]sendMessage(byte[],TransportAddress,TransportAddress)"], "overrides": null, "attributes": [{"original_string": "    public class SocketNotFoundException extends IllegalArgumentException\n    {\n        private SocketNotFoundException(String message)\n        {\n            super(message);\n        }\n    }", "definition": "    public class SocketNotFoundException extends IllegalArgumentException", "class_docstring": "", "name": "SocketNotFoundException", "super_interfaces": [], "superclasses": "IllegalArgumentException", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private SocketNotFoundException(String message)\n        {\n            super(message);\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "SocketNotFoundException", "params": [{"name": "message", "type": "String"}], "body": "        {\n            super(message);\n        }", "signature": "private SocketNotFoundException(String message)"}]}], "class_docstring": "\nManages <tt>Connector</tt>s and <tt>MessageProcessingTask</tt> execution and\npooling. This class serves as a layer that masks network primitives and\nprovides equivalent STUN abstractions. Instances that operate with\nthe NetAccessManager are only supposed to understand STUN talk and\nshouldn't be aware of datagrams sockets, and etc.\n\n@author Emil Ivov\n@author Aakash Garg\n@author Boris Grozev\n@author Yura Yaroshevich\n", "original_string": "public class NetAccessManager\n    implements ErrorHandler\n{\n    /**\n     * Our class logger\n     */\n    private static final Logger logger\n        = Logger.getLogger(NetAccessManager.class.getName());\n\n    /**\n     * Thread pool to execute {@link MessageProcessingTask}s across all\n     * {@link NetAccessManager}s.\n     */\n    private static ExecutorService messageProcessingExecutor\n        = ExecutorFactory.createCachedThreadPool(\"ice4j.NetAccessManager-\");\n\n    /**\n     * Maximum number of {@link MessageProcessingTask} to keep in object pool.\n     * Each {@link NetAccessManager} has it's own pool, small pool size is\n     * enough to save allocations.\n     */\n    private static final int TASK_POOL_SIZE = 8;\n\n    /**\n     * Pool of <tt>MessageProcessingTask</tt> objects to avoid extra-allocations\n     * of processor object per <tt>RawMessage</tt> needed to process.\n     */\n    private final ArrayBlockingQueue<MessageProcessingTask> taskPool\n        = new ArrayBlockingQueue<>(TASK_POOL_SIZE);\n\n    /**\n     * The set of {@link MessageProcessingTask}'s which are not yet finished\n     * it's, processing, tracking of active tasks is necessary to properly\n     * cancel pending tasks in case {@link #stop()} is called.\n     */\n    private final ConcurrentHashMap.KeySetView<MessageProcessingTask, Boolean>\n        activeTasks = ConcurrentHashMap.newKeySet();\n\n    /**\n     * All <tt>Connectors</tt> currently in use with UDP. The table maps a local\n     * <tt>TransportAddress</tt> and and a remote <tt>TransportAddress</tt> to\n     * a <tt>Connector</tt>. We allow a <tt>Connector</tt> to be added without\n     * a specified remote address, under the <tt>null</tt> key.\n     *\n     * Due to the final hashCode() method of InetSocketAddress, TransportAddress\n     * cannot override and it causes problem to store both UDP and TCP address\n     * (i.e. 192.168.0.3:5000/tcp has the same hashcode as 192.168.0.3:5000/udp\n     * because InetSocketAddress does not take into account transport).\n     */\n    private final Map<TransportAddress, Map<TransportAddress, Connector>>\n        udpConnectors\n            = new HashMap<>();\n\n    /**\n     * All <tt>Connectors</tt> currently in use with TCP. The table maps a local\n     * <tt>TransportAddress</tt> and and a remote <tt>TransportAddress</tt> to\n     * a <tt>Connector</tt>. We allow a <tt>Connector</tt> to be added without\n     * a specified remote address, under the <tt>null</tt> key.\n     *\n     * Due to the final hashCode() method of InetSocketAddress, TransportAddress\n     * cannot override and it causes problem to store both UDP and TCP address\n     * (i.e. 192.168.0.3:5000/tcp has the same hashcode as 192.168.0.3:5000/udp\n     * because InetSocketAddress does not take into account transport).\n     */\n    private final Map<TransportAddress, Map<TransportAddress, Connector>>\n        tcpConnectors\n            = new HashMap<>();\n\n    /**\n     * The instance that should be notified when an incoming message has been\n     * processed and ready for delivery\n     */\n    private final MessageEventHandler messageEventHandler;\n\n    /**\n     * The instance that should be notified when an incoming UDP message has\n     * been processed and ready for delivery\n     */\n    private final PeerUdpMessageEventHandler peerUdpMessageEventHandler;\n\n    /**\n     * The instance that should be notified when an incoming ChannelData message\n     * has been processed and ready for delivery\n     */\n    private final ChannelDataEventHandler channelDataEventHandler;\n\n    /**\n     * The <tt>StunStack</tt> which has created this instance, is its owner and\n     * is the handler that incoming message requests should be passed to.\n     */\n    private final StunStack stunStack;\n\n    /**\n     * Indicates if this <tt>NetAccessManager</tt> is stopped\n     */\n    private final AtomicBoolean isStopped = new AtomicBoolean(false);\n\n    /**\n     * Callback to be called when scheduled <tt>MessageProcessingTask</tt>\n     * completes processing it's <tt>RawMessage</tt>.\n     */\n    private final Consumer<MessageProcessingTask> onRawMessageProcessed\n        = messageProcessingTask -> {\n\n        activeTasks.remove(messageProcessingTask);\n\n        final boolean isAdded = taskPool.offer(messageProcessingTask);\n        if (!isAdded && logger.isLoggable(Level.FINEST))\n        {\n            logger.finest(\"Dropping MessageProcessingTask for \"\n                + this + \" because pool is full, max pool size is \" + TASK_POOL_SIZE);\n        }\n    };\n\n    /**\n     * Constructs a NetAccessManager.\n     *\n     * @param stunStack the <tt>StunStack</tt> which is creating the new\n     * instance, is going to be its owner and is the handler that incoming\n     * message requests should be passed to\n     */\n    NetAccessManager(StunStack stunStack)\n    {\n        this(stunStack, null, null);\n    }\n\n    /**\n     * Constructs a NetAccessManager with given peerUdpMessageEventHandler and\n     * channelDataEventHandler.\n     * \n     * @param stunStack the <tt>StunStack</tt> which is creating the new\n     *            instance, is going to be its owner and is the handler that\n     *            incoming message requests should be passed to\n     * @param peerUdpMessageEventHandler the <tt>PeerUdpMessageEventHandler</tt>\n     *            that will handle incoming UDP messages which are not STUN\n     *            messages and ChannelData messages.\n     * @param channelDataEventHandler the <tt>ChannelDataEventHandler</tt> that\n     *            will handle incoming UDP messages which are ChannelData\n     *            messages.\n     */\n    NetAccessManager(StunStack stunStack,\n        PeerUdpMessageEventHandler peerUdpMessageEventHandler,\n        ChannelDataEventHandler channelDataEventHandler)\n    {\n        this.stunStack = stunStack;\n        this.messageEventHandler = stunStack;\n        this.peerUdpMessageEventHandler = peerUdpMessageEventHandler;\n        this.channelDataEventHandler = channelDataEventHandler;\n    }\n\n    /**\n     * Gets the <tt>MessageEventHandler</tt> of this <tt>NetAccessManager</tt>\n     * which is to be notified when incoming messages have been processed and\n     * are ready for delivery.\n     *\n     * @return the <tt>MessageEventHandler</tt> of this\n     * <tt>NetAccessManager</tt> which is to be notified when incoming messages\n     * have been processed and are ready for delivery\n     */\n    MessageEventHandler getMessageEventHandler()\n    {\n        return messageEventHandler;\n    }\n\n    /**\n     * Gets the <tt>PeerUdpMessageEventHandler</tt> of this\n     * <tt>NetAccessManager</tt> which is to be notified when incoming UDP\n     * messages have been processed and are ready for delivery.\n     * \n     * @return the <tt>PeerUdpMessageEventHandler</tt> of this\n     *         <tt>NetAccessManager</tt> which is to be notified when incoming\n     *         UDP messages have been processed and are ready for delivery\n     */\n    public PeerUdpMessageEventHandler getUdpMessageEventHandler()\n    {\n        return peerUdpMessageEventHandler;\n    }\n\n    /**\n     * Gets the <tt>ChannelDataEventHandler</tt> of this\n     * <tt>NetAccessManager</tt> which is to be notified when incoming\n     * ChannelData messages have been processed and are ready for delivery.\n     * \n     * @return the <tt>ChannelDataEventHandler</tt> of this\n     *         <tt>NetAccessManager</tt> which is to be notified when incoming\n     *         ChannelData messages have been processed and are ready for\n     *         delivery\n     */\n    public ChannelDataEventHandler getChannelDataMessageEventHandler()\n    {\n        return channelDataEventHandler;\n    }\n\n\n    /**\n     * Gets the <tt>StunStack</tt> which has created this instance and is its\n     * owner.\n     *\n     * @return the <tt>StunStack</tt> which has created this instance and is its\n     * owner\n     */\n    StunStack getStunStack()\n    {\n        return stunStack;\n    }\n\n    /**\n     * A civilized way of not caring!\n     * @param message a description of the error\n     * @param error   the error that has occurred\n     */\n    @Override\n    public void handleError(String message, Throwable error)\n    {\n        if (isStopped.get())\n        {\n            logger.log(Level.WARNING,\n                \"Got error when stopped, ignoring: \" + message, error);\n            return;\n        }\n        /**\n         * apart from logging, i am not sure what else we could do here.\n         */\n        logger.log( Level.FINE,\n                        \"The following error occurred with \"\n                        +\"an incoming message:\",\n                        error);\n    }\n\n    /**\n     * Clears the faulty thread and reports the problem.\n     *\n     * @param callingThread the thread where the error occurred.\n     * @param message       A description of the error\n     * @param error         The error itself\n     */\n    @Override\n    public void handleFatalError(Runnable callingThread,\n                                 String message,\n                                 Throwable error)\n    {\n        if (isStopped.get())\n        {\n            logger.log(Level.WARNING,\n                \"Got fatal error when stopped, ignoring: \" + message, error);\n            return;\n        }\n\n        if (callingThread instanceof Connector)\n        {\n            Connector connector = (Connector)callingThread;\n\n            //make sure nothing's left and notify user\n            removeSocket(connector.getListenAddress(),\n                         connector.getRemoteAddress());\n            if (error != null)\n            {\n                logger.log(Level.WARNING, \"Removing connector:\" + connector,\n                           error);\n            }\n            else if (logger.isLoggable(Level.FINE))\n            {\n                logger.fine(\"Removing connector \" + connector);\n            }\n        }\n        else\n        {\n            logger.log(Level.SEVERE, message, error);\n        }\n    }\n\n    /**\n     * Creates and starts a new access point based on the specified socket.\n     * If the specified access point has already been installed the method\n     * has no effect.\n     *\n     * @param  socket   the socket that the access point should use.\n     */\n    protected void addSocket(IceSocketWrapper socket)\n    {\n        //no null check - let it through as a NullPointerException\n        Socket tcpSocket  = socket.getTCPSocket();\n\n        TransportAddress remoteAddress = null;\n        if (tcpSocket != null)\n        {\n            // In case of TCP we can extract the remote address from the actual\n            // Socket.\n            remoteAddress\n                = new TransportAddress(tcpSocket.getInetAddress(),\n                                       tcpSocket.getPort(),\n                                       Transport.TCP);\n        }\n\n        addSocket(socket, remoteAddress);\n    }\n\n    /**\n     * Creates and starts a new access point based on the specified socket.\n     * If the specified access point has already been installed the method\n     * has no effect.\n     *\n     * @param  socket   the socket that the access point should use.\n     * @param remoteAddress the remote address of the socket of the\n     * {@link Connector} to be created if it is a TCP socket, or null if it\n     * is UDP.\n     */\n    protected void addSocket(IceSocketWrapper socket,\n                             TransportAddress remoteAddress)\n    {\n        Transport transport\n            = socket.getUDPSocket() != null ? Transport.UDP : Transport.TCP;\n        TransportAddress localAddress\n            = new TransportAddress(\n                    socket.getLocalAddress(),\n                    socket.getLocalPort(),\n                    transport);\n\n        final Map<TransportAddress, Map<TransportAddress, Connector>>\n            connectorsMap\n                = (transport == Transport.UDP)\n                ? udpConnectors\n                : tcpConnectors;\n\n        synchronized (connectorsMap)\n        {\n            Map<TransportAddress, Connector> connectorsForLocalAddress\n                = connectorsMap.get(localAddress);\n\n            if (connectorsForLocalAddress == null)\n            {\n                connectorsForLocalAddress = new HashMap<>();\n                connectorsMap.put(localAddress, connectorsForLocalAddress);\n            }\n\n            if (!connectorsForLocalAddress.containsKey(remoteAddress))\n            {\n                Connector connector\n                    = new Connector(\n                        socket,\n                        remoteAddress,\n                        this::onIncomingRawMessage,\n                        this);\n\n                connectorsForLocalAddress.put(remoteAddress, connector);\n                connector.start();\n            }\n            else\n            {\n                logger.info(\"Not creating a new Connector, because we already \"\n                            + \"have one for the given address pair: \"\n                            + localAddress + \" -> \" + remoteAddress);\n            }\n        }\n    }\n\n    /**\n     * Stops and deletes the specified access point.\n     *\n     * @param localAddress the local address of the connector to remove.\n     * @param remoteAddress the remote address of the connector to remote. Use\n     * <tt>null</tt> to match the <tt>Connector</tt> with no specified remote\n     * address.\n     */\n    protected void removeSocket(TransportAddress localAddress,\n                                TransportAddress remoteAddress)\n    {\n        Connector connector = null;\n\n        final Map<TransportAddress, Map<TransportAddress, Connector>>\n                connectorsMap\n                = (localAddress.getTransport() == Transport.UDP)\n                ? udpConnectors\n                : tcpConnectors;\n\n        synchronized (connectorsMap)\n        {\n            Map<TransportAddress, Connector> connectorsForLocalAddress\n                    = connectorsMap.get(localAddress);\n\n            if (connectorsForLocalAddress != null)\n            {\n                connector = connectorsForLocalAddress.get(remoteAddress);\n\n                if (connector != null)\n                {\n                    connectorsForLocalAddress.remove(remoteAddress);\n                    if (connectorsForLocalAddress.isEmpty())\n                        connectorsMap.remove(localAddress);\n                }\n            }\n        }\n\n        if (connector != null)\n            connector.stop();\n    }\n\n    /**\n     * Stops <tt>NetAccessManager</tt> and all of its active\n     * <tt>MessageProcessingTask</tt>.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void stop()\n    {\n        // Mark NetAccessManager as stopped, it will immediately result in\n        // ignoring of all concurrent requests to handle messages\n        isStopped.set(true);\n\n        // no item can be added to {@link #activeTasks} when\n        // NetAccessManager is stopped, so it is safe to iterate without\n        // removing item in-place.\n        for (MessageProcessingTask messageProcessingTask : activeTasks)\n        {\n            messageProcessingTask.cancel();\n        }\n        activeTasks.clear();\n\n        for (Object o : new Object[]{udpConnectors, tcpConnectors})\n        {\n            Map<TransportAddress, Map<TransportAddress, Connector>>\n                connectorsMap\n                    = (Map<TransportAddress, Map<TransportAddress, Connector>>)o;\n\n            synchronized (connectorsMap)\n            {\n                for (Map<TransportAddress, Connector> connectorsForLocalAddress\n                        : connectorsMap.values())\n                {\n                    for (Connector connector : connectorsForLocalAddress.values())\n                    {\n                        connector.stop();\n                    }\n                }\n            }\n\n        }\n    }\n\n    /**\n     * Returns the <tt>Connector</tt> responsible for a particular source\n     * address and a particular destination address.\n     *\n     * @param localAddress the source address.\n     * @param remoteAddress the destination address.\n     * Returns the <tt>Connector</tt> responsible for a particular source\n     * address and a particular destination address, or <tt>null</tt> if there's\n     * none.\n     */\n    private Connector getConnector(TransportAddress localAddress,\n                                   TransportAddress remoteAddress)\n    {\n        boolean udp = localAddress.getTransport() == Transport.UDP;\n        final Map<TransportAddress, Map<TransportAddress, Connector>>\n                connectorsMap\n                = udp\n                ? udpConnectors\n                : tcpConnectors;\n        Connector connector = null;\n\n        synchronized (connectorsMap)\n        {\n            Map<TransportAddress, Connector> connectorsForLocalAddress\n                    = connectorsMap.get(localAddress);\n\n            if (connectorsForLocalAddress != null)\n            {\n                connector = connectorsForLocalAddress.get(remoteAddress);\n\n                // Fallback to the socket with no specific remote address\n                if (udp && connector == null)\n                    connector = connectorsForLocalAddress.get(null);\n            }\n        }\n\n        return connector;\n    }\n\n    /**\n     * Enqueues incoming {@link RawMessage} for asynchronous\n     * processing by {@link #messageProcessingExecutor}\n     * @param message <tt>RawMessage</tt> to process\n     */\n    private void onIncomingRawMessage(final RawMessage message)\n    {\n        if (isStopped.get())\n        {\n            logger.fine(\"Got RawMessage when stopped, ignore it.\");\n            return;\n        }\n\n        MessageProcessingTask messageProcessingTask\n            = taskPool.poll();\n        if (messageProcessingTask == null)\n        {\n            messageProcessingTask\n                = new MessageProcessingTask(this);\n            if (logger.isLoggable(Level.FINEST))\n            {\n                logger.finest(\"Allocated new MessageProcessingTask for \"\n                    + this + \" due to absence of available pooled instances\");\n            }\n        }\n        else\n        {\n            messageProcessingTask.resetState();\n        }\n\n        messageProcessingTask.setMessage(message, onRawMessageProcessed);\n\n        activeTasks.add(messageProcessingTask);\n\n        // Use overload which does not return Future object to avoid\n        // unnecessary allocation\n        messageProcessingExecutor.execute(messageProcessingTask);\n    }\n\n    //--------------- SENDING MESSAGES -----------------------------------------\n    /**\n     * Sends the specified stun message through the specified access point.\n     *\n     * @param stunMessage the message to send\n     * @param srcAddr the access point to use to send the message\n     * @param remoteAddr the destination of the message.\n     *\n     * @throws IllegalArgumentException if the apDescriptor references an\n     * access point that had not been installed,\n     * @throws IOException  if an error occurs while sending message bytes\n     * through the network socket.\n     */\n    void sendMessage(\n            Message stunMessage,\n            TransportAddress srcAddr,\n            TransportAddress remoteAddr)\n        throws IllegalArgumentException,\n               IOException\n    {\n        sendMessage(stunMessage.encode(stunStack), srcAddr, remoteAddr);\n    }\n    \n    /**\n     * Sends the specified stun message through the specified access point.\n     *\n     * @param channelData the message to send\n     * @param srcAddr the access point to use to send the message\n     * @param remoteAddr the destination of the message.\n     *\n     * @throws IllegalArgumentException if the apDescriptor references an\n     * access point that had not been installed,\n     * @throws IOException  if an error occurs while sending message bytes\n     * through the network socket.\n     * @throws StunException \n     */\n    void sendMessage(\n            ChannelData channelData,\n            TransportAddress srcAddr,\n            TransportAddress remoteAddr)\n        throws IllegalArgumentException,\n               IOException, StunException\n    {\n        boolean pad = srcAddr.getTransport() == Transport.TCP\n            || srcAddr.getTransport() == Transport.TLS;\n        sendMessage(channelData.encode(pad), srcAddr, remoteAddr);\n    }\n\n    /**\n     * Sends the specified bytes through the specified access point.\n     *\n     * @param bytes the bytes to send.\n     * @param srcAddr the access point to use to send the bytes.\n     * @param remoteAddr the destination of the message.\n     *\n     * @throws IllegalArgumentException if the apDescriptor references an\n     * access point that had not been installed,\n     * @throws IOException  if an error occurs while sending message bytes\n     * through the network socket.\n     */\n    void sendMessage(\n            byte[] bytes,\n            TransportAddress srcAddr,\n            TransportAddress remoteAddr)\n        throws IllegalArgumentException,\n               IOException\n    {\n        Connector ap = getConnector(srcAddr, remoteAddr);\n        if (ap == null)\n        {\n            throw new SocketNotFoundException(\"No socket found for \" + srcAddr + \"->\" + remoteAddr);\n        }\n\n        ap.sendMessage(bytes, remoteAddr);\n    }\n\n    public class SocketNotFoundException extends IllegalArgumentException\n    {\n        private SocketNotFoundException(String message)\n        {\n            super(message);\n        }\n    }\n}", "super_interfaces": ["ErrorHandler"], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(NetAccessManager.class.getName());", "docstring": "\nOur class logger\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(NetAccessManager.class.getName())", "syntax_pass": true}, {"attribute_expression": "private static ExecutorService messageProcessingExecutor\n        = ExecutorFactory.createCachedThreadPool(\"ice4j.NetAccessManager-\");", "docstring": "\nThread pool to execute {@link MessageProcessingTask}s across all\n{@link NetAccessManager}s.\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "ExecutorService", "name": "messageProcessingExecutor\n        = ExecutorFactory.createCachedThreadPool(\"ice4j.NetAccessManager-\")", "syntax_pass": true}, {"attribute_expression": "private static final int TASK_POOL_SIZE = 8;", "docstring": "\nMaximum number of {@link MessageProcessingTask} to keep in object pool.\nEach {@link NetAccessManager} has it's own pool, small pool size is\nenough to save allocations.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "TASK_POOL_SIZE = 8", "syntax_pass": true}, {"attribute_expression": "private final ArrayBlockingQueue<MessageProcessingTask> taskPool\n        = new ArrayBlockingQueue<>(TASK_POOL_SIZE);", "docstring": "\nPool of <tt>MessageProcessingTask</tt> objects to avoid extra-allocations\nof processor object per <tt>RawMessage</tt> needed to process.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ArrayBlockingQueue<MessageProcessingTask>", "name": "taskPool\n        = new ArrayBlockingQueue<>(TASK_POOL_SIZE)", "syntax_pass": true}, {"attribute_expression": "private final ConcurrentHashMap.KeySetView<MessageProcessingTask, Boolean>\n        activeTasks = ConcurrentHashMap.newKeySet();", "docstring": "\nThe set of {@link MessageProcessingTask}'s which are not yet finished\nit's, processing, tracking of active tasks is necessary to properly\ncancel pending tasks in case {@link #stop()} is called.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ConcurrentHashMap.KeySetView<MessageProcessingTask, Boolean>", "name": "activeTasks = ConcurrentHashMap.newKeySet()", "syntax_pass": true}, {"attribute_expression": "private final Map<TransportAddress, Map<TransportAddress, Connector>>\n        udpConnectors\n            = new HashMap<>();", "docstring": "\nAll <tt>Connectors</tt> currently in use with UDP. The table maps a local\n<tt>TransportAddress</tt> and and a remote <tt>TransportAddress</tt> to\na <tt>Connector</tt>. We allow a <tt>Connector</tt> to be added without\na specified remote address, under the <tt>null</tt> key.\n\nDue to the final hashCode() method of InetSocketAddress, TransportAddress\ncannot override and it causes problem to store both UDP and TCP address\n(i.e. 192.168.0.3:5000/tcp has the same hashcode as 192.168.0.3:5000/udp\nbecause InetSocketAddress does not take into account transport).\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<TransportAddress, Map<TransportAddress, Connector>>", "name": "udpConnectors\n            = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<TransportAddress, Map<TransportAddress, Connector>>\n        tcpConnectors\n            = new HashMap<>();", "docstring": "\nAll <tt>Connectors</tt> currently in use with TCP. The table maps a local\n<tt>TransportAddress</tt> and and a remote <tt>TransportAddress</tt> to\na <tt>Connector</tt>. We allow a <tt>Connector</tt> to be added without\na specified remote address, under the <tt>null</tt> key.\n\nDue to the final hashCode() method of InetSocketAddress, TransportAddress\ncannot override and it causes problem to store both UDP and TCP address\n(i.e. 192.168.0.3:5000/tcp has the same hashcode as 192.168.0.3:5000/udp\nbecause InetSocketAddress does not take into account transport).\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<TransportAddress, Map<TransportAddress, Connector>>", "name": "tcpConnectors\n            = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final MessageEventHandler messageEventHandler;", "docstring": "\nThe instance that should be notified when an incoming message has been\nprocessed and ready for delivery\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "MessageEventHandler", "name": "messageEventHandler", "syntax_pass": true}, {"attribute_expression": "private final PeerUdpMessageEventHandler peerUdpMessageEventHandler;", "docstring": "\nThe instance that should be notified when an incoming UDP message has\nbeen processed and ready for delivery\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PeerUdpMessageEventHandler", "name": "peerUdpMessageEventHandler", "syntax_pass": true}, {"attribute_expression": "private final ChannelDataEventHandler channelDataEventHandler;", "docstring": "\nThe instance that should be notified when an incoming ChannelData message\nhas been processed and ready for delivery\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ChannelDataEventHandler", "name": "channelDataEventHandler", "syntax_pass": true}, {"attribute_expression": "private final StunStack stunStack;", "docstring": "\nThe <tt>StunStack</tt> which has created this instance, is its owner and\nis the handler that incoming message requests should be passed to.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StunStack", "name": "stunStack", "syntax_pass": true}, {"attribute_expression": "private final AtomicBoolean isStopped = new AtomicBoolean(false);", "docstring": "\nIndicates if this <tt>NetAccessManager</tt> is stopped\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AtomicBoolean", "name": "isStopped = new AtomicBoolean(false)", "syntax_pass": true}, {"attribute_expression": "private final Consumer<MessageProcessingTask> onRawMessageProcessed\n        = messageProcessingTask -> {\n\n        activeTasks.remove(messageProcessingTask);\n\n        final boolean isAdded = taskPool.offer(messageProcessingTask);\n        if (!isAdded && logger.isLoggable(Level.FINEST))\n        {\n            logger.finest(\"Dropping MessageProcessingTask for \"\n                + this + \" because pool is full, max pool size is \" + TASK_POOL_SIZE);\n        }\n    };", "docstring": "\nCallback to be called when scheduled <tt>MessageProcessingTask</tt>\ncompletes processing it's <tt>RawMessage</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Consumer<MessageProcessingTask>", "name": "onRawMessageProcessed\n        = messageProcessingTask -> {\n\n        activeTasks.remove(messageProcessingTask);\n\n        final boolean isAdded = taskPool.offer(messageProcessingTask);\n        if (!isAdded && logger.isLoggable(Level.FINEST))\n        {\n            logger.finest(\"Dropping MessageProcessingTask for \"\n                + this + \" because pool is full, max pool size is \" + TASK_POOL_SIZE);\n        }\n    }", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction", "name": "StunClientTransaction", "file_path": "src/main/java/org/ice4j/stack/StunClientTransaction.java", "superclasses": "", "methods": ["[]StunClientTransaction(StunStack,Request,TransportAddress,TransportAddress,ResponseCollector)", "[]StunClientTransaction(StunStack,Request,TransportAddress,TransportAddress,ResponseCollector,TransactionID)", "[void]sendRequest()", "[void]sendRequest0()", "[Request]getRequest()", "[void]cancel()", "[void]handleResponse(StunMessageEvent)", "[TransactionID]getTransactionID()", "[void]initTransactionConfiguration()", "[TransportAddress]getLocalAddress()", "[TransportAddress]getRemoteAddress()"], "method_uris": ["src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[]StunClientTransaction(StunStack,Request,TransportAddress,TransportAddress,ResponseCollector)", "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[]StunClientTransaction(StunStack,Request,TransportAddress,TransportAddress,ResponseCollector,TransactionID)", "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[void]sendRequest()", "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[void]sendRequest0()", "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[Request]getRequest()", "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[void]cancel()", "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[void]handleResponse(StunMessageEvent)", "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[TransactionID]getTransactionID()", "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[void]initTransactionConfiguration()", "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[TransportAddress]getLocalAddress()", "src/main/java/org/ice4j/stack/StunClientTransaction.java.StunClientTransaction.[TransportAddress]getRemoteAddress()"], "overrides": null, "attributes": [{"original_string": "    private final class Retransmitter extends PeriodicRunnable\n    {\n        /**\n         * Current number of retransmission attempts\n         */\n        private int retransmissionCounter = 0;\n\n        /**\n         * Delay before attempting next retransmission\n         */\n        private int nextRetransmissionDelay = originalWaitInterval;\n\n        protected Retransmitter()\n        {\n            super(retransmissionTimer, retransmissionExecutor);\n        }\n\n        @Override\n        protected Duration getDelayUntilNextRun()\n        {\n            return Duration.ofMillis(nextRetransmissionDelay);\n        }\n\n        @Override\n        protected void run()\n        {\n            retransmissionCounter++;\n\n            int curWaitInterval = nextRetransmissionDelay;\n            nextRetransmissionDelay\n                = Math.min(maxWaitInterval, 2 * nextRetransmissionDelay);\n\n            if (retransmissionCounter <= maxRetransmissions)\n            {\n                try\n                {\n                    logger.fine(\n                        \"retrying STUN tid \" + transactionID + \" from \"\n                            + localAddress + \" to \" + requestDestination\n                            + \" waited \" + curWaitInterval + \" ms retrans \"\n                            + retransmissionCounter + \" of \"\n                            + maxRetransmissions);\n                    sendRequest0();\n                }\n                catch (Exception ex)\n                {\n                    //I wonder whether we should notify anyone that a retransmission\n                    // has failed\n                    logger.log(\n                        Level.INFO,\n                        \"A client tran retransmission failed\",\n                        ex);\n                }\n            }\n            else\n            {\n                stackCallback.removeClientTransaction(\n                    StunClientTransaction.this);\n\n                responseCollector.processTimeout(\n                    new StunTimeoutEvent(\n                        stackCallback,\n                        getRequest(), getLocalAddress(), getTransactionID()));\n\n                nextRetransmissionDelay = -1;\n            }\n        }\n    }", "definition": "    private final class Retransmitter extends PeriodicRunnable", "class_docstring": "\nImplements the retransmissions algorithm. Retransmits the request\nstarting with an interval of 100ms, doubling every retransmit until the\ninterval reaches 1.6s.  Retransmissions continue with intervals of 1.6s\nuntil a response is received, or a total of 7 requests have been sent.\nIf no response is received by 1.6 seconds after the last request has been\nsent, we consider the transaction to have failed.\n", "name": "Retransmitter", "super_interfaces": [], "superclasses": "PeriodicRunnable", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private int retransmissionCounter = 0;", "docstring": "\nCurrent number of retransmission attempts\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "retransmissionCounter = 0", "syntax_pass": true}, {"attribute_expression": "private int nextRetransmissionDelay = originalWaitInterval;", "docstring": "\nDelay before attempting next retransmission\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "nextRetransmissionDelay = originalWaitInterval", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected Retransmitter()\n        {\n            super(retransmissionTimer, retransmissionExecutor);\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "Retransmitter", "params": [], "body": "        {\n            super(retransmissionTimer, retransmissionExecutor);\n        }", "signature": "protected Retransmitter()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected Duration getDelayUntilNextRun()\n        {\n            return Duration.ofMillis(nextRetransmissionDelay);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Duration", "classes": []}, "name": "getDelayUntilNextRun", "params": [], "body": "        {\n            return Duration.ofMillis(nextRetransmissionDelay);\n        }", "signature": "@Override\n        protected Duration getDelayUntilNextRun()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected void run()\n        {\n            retransmissionCounter++;\n\n            int curWaitInterval = nextRetransmissionDelay;\n            nextRetransmissionDelay\n                = Math.min(maxWaitInterval, 2 * nextRetransmissionDelay);\n\n            if (retransmissionCounter <= maxRetransmissions)\n            {\n                try\n                {\n                    logger.fine(\n                        \"retrying STUN tid \" + transactionID + \" from \"\n                            + localAddress + \" to \" + requestDestination\n                            + \" waited \" + curWaitInterval + \" ms retrans \"\n                            + retransmissionCounter + \" of \"\n                            + maxRetransmissions);\n                    sendRequest0();\n                }\n                catch (Exception ex)\n                {\n                    //I wonder whether we should notify anyone that a retransmission\n                    // has failed\n                    logger.log(\n                        Level.INFO,\n                        \"A client tran retransmission failed\",\n                        ex);\n                }\n            }\n            else\n            {\n                stackCallback.removeClientTransaction(\n                    StunClientTransaction.this);\n\n                responseCollector.processTimeout(\n                    new StunTimeoutEvent(\n                        stackCallback,\n                        getRequest(), getLocalAddress(), getTransactionID()));\n\n                nextRetransmissionDelay = -1;\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "run", "params": [], "body": "        {\n            retransmissionCounter++;\n\n            int curWaitInterval = nextRetransmissionDelay;\n            nextRetransmissionDelay\n                = Math.min(maxWaitInterval, 2 * nextRetransmissionDelay);\n\n            if (retransmissionCounter <= maxRetransmissions)\n            {\n                try\n                {\n                    logger.fine(\n                        \"retrying STUN tid \" + transactionID + \" from \"\n                            + localAddress + \" to \" + requestDestination\n                            + \" waited \" + curWaitInterval + \" ms retrans \"\n                            + retransmissionCounter + \" of \"\n                            + maxRetransmissions);\n                    sendRequest0();\n                }\n                catch (Exception ex)\n                {\n                    //I wonder whether we should notify anyone that a retransmission\n                    // has failed\n                    logger.log(\n                        Level.INFO,\n                        \"A client tran retransmission failed\",\n                        ex);\n                }\n            }\n            else\n            {\n                stackCallback.removeClientTransaction(\n                    StunClientTransaction.this);\n\n                responseCollector.processTimeout(\n                    new StunTimeoutEvent(\n                        stackCallback,\n                        getRequest(), getLocalAddress(), getTransactionID()));\n\n                nextRetransmissionDelay = -1;\n            }\n        }", "signature": "@Override\n        protected void run()"}]}], "class_docstring": "\nThe {@code StunClientTransaction} class retransmits requests as specified by\nRFC 3489.\n\nOnce formulated and sent, the client sends the Binding Request.  Reliability\nis accomplished through request retransmissions.  The\n{@code StunClientTransaction} retransmits the request starting with an\ninterval of 100ms, doubling every retransmit until the interval reaches 1.6s.\nRetransmissions continue with intervals of 1.6s until a response is received,\nor a total of 9 requests have been sent. If no response is received by 1.6\nseconds after the last request has been sent, the client SHOULD consider the\ntransaction to have failed. In other words, requests would be sent at times\n0ms, 100ms, 300ms, 700ms, 1500ms, 3100ms, 4700ms, 6300ms, and 7900ms. At\n9500ms, the client considers the transaction to have failed if no response\nhas been received.\n\n@author Emil Ivov.\n@author Pascal Mogeri (contributed configuration of client transactions).\n@author Lyubomir Marinov\n", "original_string": "public class StunClientTransaction\n{\n    /**\n     * Our class logger.\n     */\n    private static final java.util.logging.Logger logger\n        = java.util.logging.Logger.getLogger(StunClientTransaction.class.getName());\n\n    /**\n     * The number of times to retransmit a request if no explicit value has been\n     * specified by org.ice4j.MAX_RETRANSMISSIONS.\n     */\n    public static final int DEFAULT_MAX_RETRANSMISSIONS = 6;\n\n    /**\n     * The maximum number of milliseconds a client should wait between\n     * consecutive retransmissions, after it has sent a request for the first\n     * time.\n     */\n    public static final int DEFAULT_MAX_WAIT_INTERVAL = 1600;\n\n    /**\n     * The number of milliseconds a client should wait before retransmitting,\n     * after it has sent a request for the first time.\n     */\n    public static final int DEFAULT_ORIGINAL_WAIT_INTERVAL = 100;\n\n    /**\n     * The pool of <tt>Thread</tt>s which schedules retransmission of\n     * <tt>StunClientTransaction</tt>s.\n     */\n    private static final ScheduledExecutorService retransmissionTimer\n        = ExecutorFactory.createSingleThreadScheduledExecutor(\n            \"ice4j.StunClientTransaction-timer-\", 60, TimeUnit.SECONDS);\n\n    /**\n     * The pool of <tt>Thread</tt>s which retransmits\n     * <tt>StunClientTransaction</tt>s.\n     */\n    private static final ExecutorService retransmissionExecutor\n        = ExecutorFactory.createCachedThreadPool(\n            \"ice4j.StunClientTransaction-executor-\");\n\n\n    /**\n     * Maximum number of retransmissions. Once this number is reached and if no\n     * response is received after {@link #maxWaitInterval} milliseconds the\n     * request is considered unanswered.\n     */\n    public int maxRetransmissions = DEFAULT_MAX_RETRANSMISSIONS;\n\n    /**\n     * The number of milliseconds to wait before the first retransmission of the\n     * request.\n     */\n    public int originalWaitInterval = DEFAULT_ORIGINAL_WAIT_INTERVAL;\n\n    /**\n     * The maximum wait interval. Once this interval is reached we should stop\n     * doubling its value.\n     */\n    public int maxWaitInterval = DEFAULT_MAX_WAIT_INTERVAL;\n\n    /**\n     * The <tt>StunStack</tt> that created us.\n     */\n    private final StunStack stackCallback;\n\n    /**\n     * The request that we are retransmitting.\n     */\n    private final Request request;\n\n    /**\n     * The destination of the request.\n     */\n    private final TransportAddress requestDestination;\n\n    /**\n     * The id of the transaction.\n     */\n    private final TransactionID transactionID;\n\n    /**\n     * The <tt>TransportAddress</tt> through which the original request was sent\n     * and that we are supposed to be retransmitting through.\n     */\n    private final TransportAddress localAddress;\n\n    /**\n     * The instance to notify when a response has been received in the current\n     * transaction or when it has timed out.\n     */\n    private final ResponseCollector responseCollector;\n\n    /**\n     * Determines whether the transaction is active or not.\n     */\n    private final AtomicBoolean cancelled = new AtomicBoolean(false);\n\n    /**\n     * A transaction request retransmitter\n     */\n    private final Retransmitter retransmitter;\n\n    /**\n     * Creates a client transaction.\n     *\n     * @param stackCallback the stack that created us.\n     * @param request the request that we are living for.\n     * @param requestDestination the destination of the request.\n     * @param localAddress the local <tt>TransportAddress</tt> this transaction\n     * will be communication through.\n     * @param responseCollector the instance that should receive this request's\n     * response retransmit.\n     */\n    public StunClientTransaction(StunStack         stackCallback,\n                                 Request           request,\n                                 TransportAddress  requestDestination,\n                                 TransportAddress  localAddress,\n                                 ResponseCollector responseCollector)\n    {\n        this(stackCallback,\n             request,\n             requestDestination,\n             localAddress,\n             responseCollector,\n             TransactionID.createNewTransactionID());\n    }\n\n    /**\n     * Creates a client transaction.\n     *\n     * @param stackCallback the stack that created us.\n     * @param request the request that we are living for.\n     * @param requestDestination the destination of the request.\n     * @param localAddress the local <tt>TransportAddress</tt> this transaction\n     * will be communication through.\n     * @param responseCollector the instance that should receive this request's\n     * response retransmit.\n     * @param transactionID the ID that we'd like the new transaction to have\n     * in case the application created it in order to use it for application\n     * data correlation.\n     */\n    public StunClientTransaction(StunStack         stackCallback,\n                                 Request           request,\n                                 TransportAddress  requestDestination,\n                                 TransportAddress  localAddress,\n                                 ResponseCollector responseCollector,\n                                 TransactionID     transactionID)\n    {\n        this.stackCallback      = stackCallback;\n        this.request            = request;\n        this.localAddress       = localAddress;\n        this.responseCollector  = responseCollector;\n        this.requestDestination = requestDestination;\n\n        initTransactionConfiguration();\n\n        retransmitter = new Retransmitter(); // create it here to support 'originalWaitInterval' configuration\n\n        this.transactionID = transactionID;\n\n        try\n        {\n            request.setTransactionID(transactionID.getBytes());\n        }\n        catch (StunException ex)\n        {\n            // Shouldn't happen so lets just throw a RuntimeException in case\n            // something is really messed up.\n            throw new IllegalArgumentException(\n                    \"The TransactionID class generated an invalid transaction\"\n                        + \" ID\");\n        }\n    }\n\n    /**\n     * Sends the request and schedules the first retransmission for after\n     * {@link #originalWaitInterval} and thus starts the retransmission\n     * algorithm.\n     *\n     * @throws IOException  if an error occurs while sending message bytes\n     * through the network socket.\n     * @throws IllegalArgumentException if the apDescriptor references an\n     * access point that had not been installed\n     *\n     */\n    void sendRequest()\n        throws IllegalArgumentException, IOException\n    {\n        logger.fine(\n                \"sending STUN \" + \" tid \" + transactionID + \" from \"\n                    + localAddress + \" to \" + requestDestination);\n        sendRequest0();\n\n        this.retransmitter.schedule();\n    }\n\n    /**\n     * Simply calls the sendMessage method of the accessmanager.\n     *\n     * @throws IOException  if an error occurs while sending message bytes\n     * through the network socket.\n     * @throws IllegalArgumentException if the apDescriptor references an\n     * access point that had not been installed,\n     */\n    private void sendRequest0()\n        throws IllegalArgumentException, IOException\n    {\n        if (cancelled.get())\n        {\n            logger.finer(\"Trying to resend a cancelled transaction.\");\n        }\n        else\n        {\n            stackCallback.getNetAccessManager().sendMessage(\n                    this.request,\n                    localAddress,\n                    requestDestination);\n        }\n    }\n\n    /**\n     * Returns the request that was the reason for creating this transaction.\n     *\n     * @return the request that was the reason for creating this transaction.\n     */\n    Request getRequest()\n    {\n        return this.request;\n    }\n\n    /**\n     * Cancels the transaction. Once this method is called the transaction is\n     * considered terminated and will stop retransmissions.\n     */\n    void cancel()\n    {\n        // The cancelled field is initialized to false and then the one and\n        // only write access to it is here to set it to true. The rest of the\n        // code just checks whether it has become true.\n        cancelled.set(true);\n\n        this.retransmitter.cancel();\n    }\n\n    /**\n     * Dispatches the response then cancels itself and notifies the StunStack\n     * for its termination.\n     *\n     * @param evt the event that contains the newly received message\n     */\n    public void handleResponse(StunMessageEvent evt)\n    {\n        TransactionID transactionID = getTransactionID();\n\n        logger.fine(\"handleResponse tid \" + transactionID);\n        if (!Boolean.getBoolean(StackProperties.KEEP_CRANS_AFTER_A_RESPONSE))\n        {\n            cancel();\n        }\n\n        responseCollector.processResponse(\n            new StunResponseEvent(\n                stackCallback,\n                evt.getRawMessage(),\n                (Response) evt.getMessage(),\n                request,\n                transactionID));\n    }\n\n    /**\n     * Returns the ID of the current transaction.\n     *\n     * @return the ID of the transaction.\n     */\n    TransactionID getTransactionID()\n    {\n        return this.transactionID;\n    }\n\n    /**\n     * Init transaction duration/retransmission parameters. (Mostly contributed\n     * by Pascal Maugeri.)\n     */\n    private void initTransactionConfiguration()\n    {\n        //Max Retransmissions\n        String maxRetransmissionsStr\n            = System.getProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS);\n\n        if (maxRetransmissionsStr != null\n                && maxRetransmissionsStr.trim().length() > 0)\n        {\n            try\n            {\n                maxRetransmissions = Integer.parseInt(maxRetransmissionsStr);\n            }\n            catch (NumberFormatException e)\n            {\n                logger.log(Level.FINE,\n                           \"Failed to parse MAX_RETRANSMISSIONS\",\n                           e);\n                maxRetransmissions = DEFAULT_MAX_RETRANSMISSIONS;\n            }\n        }\n\n        //Original Wait Interval\n        String originalWaitIntervalStr\n            = System.getProperty(StackProperties.FIRST_CTRAN_RETRANS_AFTER);\n\n        if (originalWaitIntervalStr != null\n                && originalWaitIntervalStr.trim().length() > 0)\n        {\n            try\n            {\n                originalWaitInterval\n                    = Integer.parseInt(originalWaitIntervalStr);\n            }\n            catch (NumberFormatException e)\n            {\n                logger.log(Level.FINE,\n                           \"Failed to parse ORIGINAL_WAIT_INTERVAL\",\n                           e);\n                originalWaitInterval = DEFAULT_ORIGINAL_WAIT_INTERVAL;\n            }\n        }\n\n        //Max Wait Interval\n        String maxWaitIntervalStr\n                = System.getProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER);\n\n        if (maxWaitIntervalStr != null\n                && maxWaitIntervalStr.trim().length() > 0)\n        {\n            try\n            {\n                maxWaitInterval = Integer.parseInt(maxWaitIntervalStr);\n            }\n            catch (NumberFormatException e)\n            {\n                logger.log(Level.FINE, \"Failed to parse MAX_WAIT_INTERVAL\", e);\n                maxWaitInterval = DEFAULT_MAX_WAIT_INTERVAL;\n            }\n        }\n    }\n\n    /**\n     * Returns the local <tt>TransportAddress</tt> that this transaction is\n     * sending requests from.\n     *\n     * @return  the local <tt>TransportAddress</tt> that this transaction is\n     * sending requests from.\n     */\n    public TransportAddress getLocalAddress()\n    {\n        return localAddress;\n    }\n\n    /**\n     * Returns the remote <tt>TransportAddress</tt> that this transaction is\n     * sending requests to.\n     *\n     * @return the remote <tt>TransportAddress</tt> that this transaction is\n     * sending requests to.\n     */\n    public TransportAddress getRemoteAddress()\n    {\n        return requestDestination;\n    }\n\n    /**\n     * Implements the retransmissions algorithm. Retransmits the request\n     * starting with an interval of 100ms, doubling every retransmit until the\n     * interval reaches 1.6s.  Retransmissions continue with intervals of 1.6s\n     * until a response is received, or a total of 7 requests have been sent.\n     * If no response is received by 1.6 seconds after the last request has been\n     * sent, we consider the transaction to have failed.\n     */\n    private final class Retransmitter extends PeriodicRunnable\n    {\n        /**\n         * Current number of retransmission attempts\n         */\n        private int retransmissionCounter = 0;\n\n        /**\n         * Delay before attempting next retransmission\n         */\n        private int nextRetransmissionDelay = originalWaitInterval;\n\n        protected Retransmitter()\n        {\n            super(retransmissionTimer, retransmissionExecutor);\n        }\n\n        @Override\n        protected Duration getDelayUntilNextRun()\n        {\n            return Duration.ofMillis(nextRetransmissionDelay);\n        }\n\n        @Override\n        protected void run()\n        {\n            retransmissionCounter++;\n\n            int curWaitInterval = nextRetransmissionDelay;\n            nextRetransmissionDelay\n                = Math.min(maxWaitInterval, 2 * nextRetransmissionDelay);\n\n            if (retransmissionCounter <= maxRetransmissions)\n            {\n                try\n                {\n                    logger.fine(\n                        \"retrying STUN tid \" + transactionID + \" from \"\n                            + localAddress + \" to \" + requestDestination\n                            + \" waited \" + curWaitInterval + \" ms retrans \"\n                            + retransmissionCounter + \" of \"\n                            + maxRetransmissions);\n                    sendRequest0();\n                }\n                catch (Exception ex)\n                {\n                    //I wonder whether we should notify anyone that a retransmission\n                    // has failed\n                    logger.log(\n                        Level.INFO,\n                        \"A client tran retransmission failed\",\n                        ex);\n                }\n            }\n            else\n            {\n                stackCallback.removeClientTransaction(\n                    StunClientTransaction.this);\n\n                responseCollector.processTimeout(\n                    new StunTimeoutEvent(\n                        stackCallback,\n                        getRequest(), getLocalAddress(), getTransactionID()));\n\n                nextRetransmissionDelay = -1;\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final java.util.logging.Logger logger\n        = java.util.logging.Logger.getLogger(StunClientTransaction.class.getName());", "docstring": "\nOur class logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "java.util.logging.Logger", "name": "logger\n        = java.util.logging.Logger.getLogger(StunClientTransaction.class.getName())", "syntax_pass": true}, {"attribute_expression": "public static final int DEFAULT_MAX_RETRANSMISSIONS = 6;", "docstring": "\nThe number of times to retransmit a request if no explicit value has been\nspecified by org.ice4j.MAX_RETRANSMISSIONS.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_MAX_RETRANSMISSIONS = 6", "syntax_pass": true}, {"attribute_expression": "public static final int DEFAULT_MAX_WAIT_INTERVAL = 1600;", "docstring": "\nThe maximum number of milliseconds a client should wait between\nconsecutive retransmissions, after it has sent a request for the first\ntime.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_MAX_WAIT_INTERVAL = 1600", "syntax_pass": true}, {"attribute_expression": "public static final int DEFAULT_ORIGINAL_WAIT_INTERVAL = 100;", "docstring": "\nThe number of milliseconds a client should wait before retransmitting,\nafter it has sent a request for the first time.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_ORIGINAL_WAIT_INTERVAL = 100", "syntax_pass": true}, {"attribute_expression": "private static final ScheduledExecutorService retransmissionTimer\n        = ExecutorFactory.createSingleThreadScheduledExecutor(\n            \"ice4j.StunClientTransaction-timer-\", 60, TimeUnit.SECONDS);", "docstring": "\nThe pool of <tt>Thread</tt>s which schedules retransmission of\n<tt>StunClientTransaction</tt>s.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ScheduledExecutorService", "name": "retransmissionTimer\n        = ExecutorFactory.createSingleThreadScheduledExecutor(\n            \"ice4j.StunClientTransaction-timer-\", 60, TimeUnit.SECONDS)", "syntax_pass": true}, {"attribute_expression": "private static final ExecutorService retransmissionExecutor\n        = ExecutorFactory.createCachedThreadPool(\n            \"ice4j.StunClientTransaction-executor-\");", "docstring": "\nThe pool of <tt>Thread</tt>s which retransmits\n<tt>StunClientTransaction</tt>s.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ExecutorService", "name": "retransmissionExecutor\n        = ExecutorFactory.createCachedThreadPool(\n            \"ice4j.StunClientTransaction-executor-\")", "syntax_pass": true}, {"attribute_expression": "public int maxRetransmissions = DEFAULT_MAX_RETRANSMISSIONS;", "docstring": "\nMaximum number of retransmissions. Once this number is reached and if no\nresponse is received after {@link #maxWaitInterval} milliseconds the\nrequest is considered unanswered.\n", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "maxRetransmissions = DEFAULT_MAX_RETRANSMISSIONS", "syntax_pass": true}, {"attribute_expression": "public int originalWaitInterval = DEFAULT_ORIGINAL_WAIT_INTERVAL;", "docstring": "\nThe number of milliseconds to wait before the first retransmission of the\nrequest.\n", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "originalWaitInterval = DEFAULT_ORIGINAL_WAIT_INTERVAL", "syntax_pass": true}, {"attribute_expression": "public int maxWaitInterval = DEFAULT_MAX_WAIT_INTERVAL;", "docstring": "\nThe maximum wait interval. Once this interval is reached we should stop\ndoubling its value.\n", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "int", "name": "maxWaitInterval = DEFAULT_MAX_WAIT_INTERVAL", "syntax_pass": true}, {"attribute_expression": "private final StunStack stackCallback;", "docstring": "\nThe <tt>StunStack</tt> that created us.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StunStack", "name": "stackCallback", "syntax_pass": true}, {"attribute_expression": "private final Request request;", "docstring": "\nThe request that we are retransmitting.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Request", "name": "request", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress requestDestination;", "docstring": "\nThe destination of the request.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "requestDestination", "syntax_pass": true}, {"attribute_expression": "private final TransactionID transactionID;", "docstring": "\nThe id of the transaction.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransactionID", "name": "transactionID", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress localAddress;", "docstring": "\nThe <tt>TransportAddress</tt> through which the original request was sent\nand that we are supposed to be retransmitting through.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "localAddress", "syntax_pass": true}, {"attribute_expression": "private final ResponseCollector responseCollector;", "docstring": "\nThe instance to notify when a response has been received in the current\ntransaction or when it has timed out.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ResponseCollector", "name": "responseCollector", "syntax_pass": true}, {"attribute_expression": "private final AtomicBoolean cancelled = new AtomicBoolean(false);", "docstring": "\nDetermines whether the transaction is active or not.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AtomicBoolean", "name": "cancelled = new AtomicBoolean(false)", "syntax_pass": true}, {"attribute_expression": "private final Retransmitter retransmitter;", "docstring": "\nA transaction request retransmitter\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Retransmitter", "name": "retransmitter", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage", "name": "RawMessage", "file_path": "src/main/java/org/ice4j/stack/RawMessage.java", "superclasses": "", "methods": ["[]RawMessage(byte[],int,TransportAddress,TransportAddress)", "[byte[]]getBytes()", "[int]getMessageLength()", "[TransportAddress]getRemoteAddress()", "[TransportAddress]getLocalAddress()", "[RawMessage]build(byte[],int,TransportAddress,TransportAddress)"], "method_uris": ["src/main/java/org/ice4j/stack/RawMessage.java.RawMessage.[]RawMessage(byte[],int,TransportAddress,TransportAddress)", "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage.[byte[]]getBytes()", "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage.[int]getMessageLength()", "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage.[TransportAddress]getRemoteAddress()", "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage.[TransportAddress]getLocalAddress()", "src/main/java/org/ice4j/stack/RawMessage.java.RawMessage.[RawMessage]build(byte[],int,TransportAddress,TransportAddress)"], "overrides": null, "attributes": [], "class_docstring": "\nThe class represents a binary STUN message as well as the address and port\nof the host that sent it and the address and port where it was received\n(locally).\n\n@author Emil Ivov\n", "original_string": "public class RawMessage\n{\n    /**\n     * The message itself.\n     */\n    private final byte[] messageBytes;\n\n    /**\n     * The length of the message.\n     */\n    private final int messageLength;\n\n    /**\n     * The address and port where the message was sent from.\n     */\n    private final TransportAddress remoteAddress;\n\n    /**\n     * The address that this message was received on.\n     */\n    private final TransportAddress localAddress;\n\n    /**\n     * Constructs a raw message with the specified field values. All parameters\n     * are cloned before being assigned to class members.\n     *\n     * @param messageBytes the message itself.\n     * @param messageLength the number of bytes currently stored in the\n     * <tt>messageBytes</tt> array.\n     * @param remoteAddress the address where the message came from.\n     * @param localAddress the <tt>TransportAddress</tt> that the message was\n     * received on.\n     *\n     * @throws NullPointerException if one or more of the parameters were null.\n     */\n    RawMessage(byte[]           messageBytes,\n               int              messageLength,\n               TransportAddress remoteAddress,\n               TransportAddress localAddress)\n    {\n        /*\n         * Let NullPointerException go out.\n         * \n         * The length of the array messgeBytes may be enormous while\n         * messageLength may be tiny so it does not make sense to clone\n         * messageBytes.\n         */\n        this.messageBytes  = new byte[messageLength];\n        System.arraycopy(messageBytes, 0, this.messageBytes, 0, messageLength);\n        this.messageLength = messageLength;\n        this.localAddress  = localAddress;\n        this.remoteAddress = remoteAddress;\n    }\n\n    /**\n     * Returns the message itself.\n     *\n     * @return a binary array containing the message data.\n     */\n    public byte[] getBytes()\n    {\n        return messageBytes;\n    }\n\n    /**\n     * Returns the message length.\n     *\n     * @return a the length of the message.\n     */\n    public int getMessageLength()\n    {\n        return messageLength;\n    }\n\n    /**\n     * Returns the address and port of the host that sent the message\n     *\n     * @return the [address]:[port] pair that sent the message.\n     */\n    public TransportAddress getRemoteAddress()\n    {\n        return this.remoteAddress;\n    }\n\n    /**\n     * Returns the address that this message was received on.\n     *\n     * @return the address that this message was received on.\n     */\n    public TransportAddress getLocalAddress()\n    {\n        return localAddress;\n    }\n\n    /**\n     * Use builder pattern to allow creation of immutable RawMessage instances,\n     * from outside the current package.\n     *\n     * @param messageBytes the message itself.\n     * @param messageLength the number of bytes currently stored in the\n     * <tt>messageBytes</tt> array.\n     * @param remoteAddress the address where the message came from.\n     * @param localAddress the <tt>TransportAddress</tt> that the message was\n     * received on.\n     * @return RawMessage instance\n     */\n    public static RawMessage build(byte[] messageBytes, int messageLength,\n        TransportAddress remoteAddress, TransportAddress localAddress)\n    {\n        return new RawMessage(messageBytes, messageLength, remoteAddress,\n            localAddress);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final byte[] messageBytes;", "docstring": "\nThe message itself.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "byte[]", "name": "messageBytes", "syntax_pass": true}, {"attribute_expression": "private final int messageLength;", "docstring": "\nThe length of the message.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "messageLength", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress remoteAddress;", "docstring": "\nThe address and port where the message was sent from.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "remoteAddress", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress localAddress;", "docstring": "\nThe address that this message was received on.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "localAddress", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask", "name": "MessageProcessingTask", "file_path": "src/main/java/org/ice4j/stack/MessageProcessingTask.java", "superclasses": "", "methods": ["[]MessageProcessingTask(NetAccessManager)", "[void]setMessage(RawMessage,Consumer<MessageProcessingTask>)", "[void]resetState()", "[void]cancel()", "[void]run()"], "method_uris": ["src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask.[]MessageProcessingTask(NetAccessManager)", "src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask.[void]setMessage(RawMessage,Consumer<MessageProcessingTask>)", "src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask.[void]resetState()", "src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask.[void]cancel()", "src/main/java/org/ice4j/stack/MessageProcessingTask.java.MessageProcessingTask.[void]run()"], "overrides": null, "attributes": [], "class_docstring": "\nThe class is used to parse and dispatch incoming messages by being\nexecuted by concurrent {@link java.util.concurrent.ExecutorService}.\nTo reduce memory allocation this class is designed to be suitable for\nusage with pooling, the instance of this type is mutable such that\n<tt>RawMessage</tt> can be updated and instance can be reused and\nscheduled with new <tt>RawMessage</tt>\n\n@author Emil Ivov\n@author Yura Yaroshevich\n", "original_string": "class MessageProcessingTask\n    implements Runnable\n{\n    /**\n     * Our class logger.\n     */\n    private static final Logger logger\n        = Logger.getLogger(MessageProcessingTask.class.getName());\n\n    /**\n     * Indicates that <tt>MessageProcessingTask</tt> is cancelled and should not\n     * process <tt>RawMessage</tt> anymore.\n     */\n    private final AtomicBoolean cancelled = new AtomicBoolean(false);\n\n    /**\n     * The <tt>NetAccessManager</tt> which has created this instance and which\n     * is its owner.\n     */\n    private final NetAccessManager netAccessManager;\n\n    /**\n     * The listener that will be collecting error notifications.\n     */\n    private final ErrorHandler errorHandler;\n\n    /**\n     * The listener that will be retrieving <tt>MessageEvent</tt>s\n     */\n    private final MessageEventHandler messageEventHandler;\n\n    /**\n     * Raw message which is being processed\n     */\n    private RawMessage rawMessage;\n\n    /**\n     * Callback which is invoked when this <tt>MessageProcessingTask</tt>\n     * processed it's {@link #rawMessage}\n     */\n    private Consumer<MessageProcessingTask> rawMessageProcessedHandler;\n\n    /**\n     * Creates a Message processor.\n     *\n     * @param netAccessManager the <tt>NetAccessManager</tt> which is creating\n     * the new instance, is going to be its owner, specifies the\n     * <tt>MessageEventHandler</tt> and represents the <tt>ErrorHandler</tt> to\n     * handle exceptions in the new instance\n     * @throws IllegalArgumentException if any of the mentioned properties of\n     * <tt>netAccessManager</tt> are <tt>null</tt>\n     */\n    MessageProcessingTask(NetAccessManager netAccessManager)\n        throws IllegalArgumentException\n    {\n        if (netAccessManager == null)\n        {\n            throw new NullPointerException(\"netAccessManager\");\n        }\n\n        MessageEventHandler messageEventHandler\n            = netAccessManager.getMessageEventHandler();\n\n        if (messageEventHandler == null)\n        {\n            throw new IllegalArgumentException(\n                \"The message event handler may not be null\");\n        }\n\n        this.netAccessManager = netAccessManager;\n        this.messageEventHandler = messageEventHandler;\n        this.errorHandler = netAccessManager;\n    }\n\n    /**\n     * Assigns the <tt>RawMessage</tt> that will be processed\n     * by this <tt>MessageProcessingTask</tt> on executor's thread.\n     * @param message RawMessage to be processed\n     * @param onProcessed callback which will be invoked when processing\n     * of {@link #rawMessage} is completed\n     */\n    void setMessage(\n        RawMessage message,\n        Consumer<MessageProcessingTask> onProcessed)\n    {\n        if (message == null)\n        {\n            throw new IllegalArgumentException(\"The message may not be null\");\n        }\n        rawMessage = message;\n        rawMessageProcessedHandler = onProcessed;\n    }\n\n    /**\n     * Performs proper reset of internal state of pooled instance.\n     */\n    void resetState()\n    {\n        cancelled.set(false);\n        rawMessage = null;\n        rawMessageProcessedHandler = null;\n    }\n\n    /**\n     * Attempts to cancel processing of {@link #rawMessage}\n     */\n    public void cancel()\n    {\n        cancelled.set(true);\n    }\n\n    /**\n     * Does the message parsing.\n     */\n    @Override\n    public void run()\n    {\n        final Consumer<MessageProcessingTask> onProcessed\n            = rawMessageProcessedHandler;\n        final RawMessage message = rawMessage;\n        //add an extra try/catch block that handles uncatched errors\n        try\n        {\n            if (message == null)\n            {\n                return;\n            }\n            rawMessage = null;\n            rawMessageProcessedHandler = null;\n\n            if (cancelled.get())\n            {\n                return;\n            }\n\n            StunStack stunStack = netAccessManager.getStunStack();\n\n            Message stunMessage;\n            try\n            {\n                stunMessage\n                    = Message.decode(message.getBytes(),\n                                     0,\n                                     message.getMessageLength());\n            }\n            catch (StunException ex)\n            {\n                errorHandler.handleError(\n                    \"Failed to decode a stun message!\",\n                    ex);\n                    return;\n            }\n\n            logger.finest(\"Dispatching a StunMessageEvent.\");\n\n            StunMessageEvent stunMessageEvent\n                = new StunMessageEvent(stunStack, message, stunMessage);\n\n            messageEventHandler.handleMessageEvent(stunMessageEvent);\n        }\n        catch (Throwable err)\n        {\n            errorHandler.handleFatalError(\n                Thread.currentThread(),\n                \"Unexpected Error!\", err);\n        }\n        finally\n        {\n            // On processed callback must be invoked in all cases, even when\n            // cancellation or early exist happen, otherwise\n            // NetAccessManager internal tracking of pooled and active\n            // message processors will misbehave.\n            if (onProcessed != null)\n            {\n                onProcessed.accept(this);\n            }\n        }\n    }\n}", "super_interfaces": ["Runnable"], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(MessageProcessingTask.class.getName());", "docstring": "\nOur class logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(MessageProcessingTask.class.getName())", "syntax_pass": true}, {"attribute_expression": "private final AtomicBoolean cancelled = new AtomicBoolean(false);", "docstring": "\nIndicates that <tt>MessageProcessingTask</tt> is cancelled and should not\nprocess <tt>RawMessage</tt> anymore.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AtomicBoolean", "name": "cancelled = new AtomicBoolean(false)", "syntax_pass": true}, {"attribute_expression": "private final NetAccessManager netAccessManager;", "docstring": "\nThe <tt>NetAccessManager</tt> which has created this instance and which\nis its owner.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NetAccessManager", "name": "netAccessManager", "syntax_pass": true}, {"attribute_expression": "private final ErrorHandler errorHandler;", "docstring": "\nThe listener that will be collecting error notifications.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ErrorHandler", "name": "errorHandler", "syntax_pass": true}, {"attribute_expression": "private final MessageEventHandler messageEventHandler;", "docstring": "\nThe listener that will be retrieving <tt>MessageEvent</tt>s\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "MessageEventHandler", "name": "messageEventHandler", "syntax_pass": true}, {"attribute_expression": "private RawMessage rawMessage;", "docstring": "\nRaw message which is being processed\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RawMessage", "name": "rawMessage", "syntax_pass": true}, {"attribute_expression": "private Consumer<MessageProcessingTask> rawMessageProcessedHandler;", "docstring": "\nCallback which is invoked when this <tt>MessageProcessingTask</tt>\nprocessed it's {@link #rawMessage}\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Consumer<MessageProcessingTask>", "name": "rawMessageProcessedHandler", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/stack/StunStack.java.StunStack", "name": "StunStack", "file_path": "src/main/java/org/ice4j/stack/StunStack.java", "superclasses": "", "methods": ["[void]addSocket(IceSocketWrapper)", "[void]addSocket(IceSocketWrapper,TransportAddress)", "[void]removeSocket(TransportAddress)", "[void]removeSocket(TransportAddress,TransportAddress)", "[StunClientTransaction]getClientTransaction(byte[])", "[StunServerTransaction]getServerTransaction(byte[])", "[StunServerTransaction]getServerTransaction(TransactionID)", "[void]cancelTransaction(TransactionID)", "[void]cancelTransactionsForAddress(TransportAddress,TransportAddress)", "[]StunStack(PeerUdpMessageEventHandler,ChannelDataEventHandler)", "[]StunStack()", "[NetAccessManager]getNetAccessManager()", "[void]sendChannelData(ChannelData,TransportAddress,TransportAddress)", "[void]sendUdpMessage(RawMessage,TransportAddress,TransportAddress)", "[void]sendIndication(Indication,TransportAddress,TransportAddress)", "[TransactionID]sendRequest(Request,TransportAddress,TransportAddress,ResponseCollector)", "[TransactionID]sendRequest(Request,TransportAddress,TransportAddress,ResponseCollector,TransactionID)", "[TransactionID]sendRequest(Request,TransportAddress,TransportAddress,ResponseCollector,TransactionID,int,int,int)", "[TransactionID]sendRequest(Request,TransportAddress,DatagramSocket,ResponseCollector)", "[void]sendResponse(byte[],Response,TransportAddress,TransportAddress)", "[void]addIndicationListener(TransportAddress,MessageEventHandler)", "[void]addOldIndicationListener(TransportAddress,MessageEventHandler)", "[void]addRequestListener(RequestListener)", "[void]removeIndicationListener(TransportAddress,MessageEventHandler)", "[void]removeRequestListener(RequestListener)", "[void]addRequestListener(TransportAddress,RequestListener)", "[void]removeClientTransaction(StunClientTransaction)", "[void]removeServerTransaction(StunServerTransaction)", "[void]handleMessageEvent(StunMessageEvent)", "[CredentialsManager]getCredentialsManager()", "[void]shutDown()", "[void]validateRequestAttributes(StunMessageEvent)", "[boolean]validateMessageIntegrity(MessageIntegrityAttribute,String,boolean,RawMessage)", "[String]toHexString(byte[])", "[boolean]validateUsername(String)", "[PacketLogger]getPacketLogger()", "[void]setPacketLogger(PacketLogger)", "[boolean]isPacketLoggerEnabled()", "[Response]createCorrespondingErrorResponse(char,char,String)", "[void]logPacketToPcap(DatagramPacket,boolean,InetAddress,int)"], "method_uris": ["src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]addSocket(IceSocketWrapper)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]addSocket(IceSocketWrapper,TransportAddress)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]removeSocket(TransportAddress)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]removeSocket(TransportAddress,TransportAddress)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[StunClientTransaction]getClientTransaction(byte[])", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[StunServerTransaction]getServerTransaction(byte[])", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[StunServerTransaction]getServerTransaction(TransactionID)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]cancelTransaction(TransactionID)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]cancelTransactionsForAddress(TransportAddress,TransportAddress)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[]StunStack(PeerUdpMessageEventHandler,ChannelDataEventHandler)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[]StunStack()", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[NetAccessManager]getNetAccessManager()", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]sendChannelData(ChannelData,TransportAddress,TransportAddress)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]sendUdpMessage(RawMessage,TransportAddress,TransportAddress)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]sendIndication(Indication,TransportAddress,TransportAddress)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[TransactionID]sendRequest(Request,TransportAddress,TransportAddress,ResponseCollector)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[TransactionID]sendRequest(Request,TransportAddress,TransportAddress,ResponseCollector,TransactionID)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[TransactionID]sendRequest(Request,TransportAddress,TransportAddress,ResponseCollector,TransactionID,int,int,int)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[TransactionID]sendRequest(Request,TransportAddress,DatagramSocket,ResponseCollector)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]sendResponse(byte[],Response,TransportAddress,TransportAddress)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]addIndicationListener(TransportAddress,MessageEventHandler)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]addOldIndicationListener(TransportAddress,MessageEventHandler)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]addRequestListener(RequestListener)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]removeIndicationListener(TransportAddress,MessageEventHandler)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]removeRequestListener(RequestListener)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]addRequestListener(TransportAddress,RequestListener)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]removeClientTransaction(StunClientTransaction)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]removeServerTransaction(StunServerTransaction)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]handleMessageEvent(StunMessageEvent)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[CredentialsManager]getCredentialsManager()", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]shutDown()", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]validateRequestAttributes(StunMessageEvent)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[boolean]validateMessageIntegrity(MessageIntegrityAttribute,String,boolean,RawMessage)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[String]toHexString(byte[])", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[boolean]validateUsername(String)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[PacketLogger]getPacketLogger()", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]setPacketLogger(PacketLogger)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[boolean]isPacketLoggerEnabled()", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[Response]createCorrespondingErrorResponse(char,char,String)", "src/main/java/org/ice4j/stack/StunStack.java.StunStack.[void]logPacketToPcap(DatagramPacket,boolean,InetAddress,int)"], "overrides": null, "attributes": [{"original_string": "    private final class ExpiredServerTransactionsCollector\n    {\n        /**\n         * Runnable which walks {@link #serverTransactions}, check if\n         * transaction is expired and if so - remove it\n         * from {@link #serverTransactions}.\n         * Self-cancels when {@link #serverTransactions} is empty\n         */\n        private final Runnable collector = new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    synchronized (serverTransactions)\n                    {\n                        final int transactionsBeforeCollection\n                            = serverTransactions.size();\n\n                        long now = System.currentTimeMillis();\n\n                        for (Iterator<StunServerTransaction> i\n                                    = serverTransactions.values().iterator();\n                                i.hasNext();)\n                        {\n                            StunServerTransaction serverTransaction = i.next();\n\n                            if (serverTransaction == null)\n                            {\n                                i.remove();\n                            }\n                            else if (serverTransaction.isExpired(now))\n                            {\n                                i.remove();\n                                serverTransaction.expire();\n                            }\n                        }\n\n                        logger.fine(\"Non-expired server transactions \"\n                            + \"count \" + serverTransactions.size()\n                            + \", transactions before collection \"\n                            + transactionsBeforeCollection);\n\n                        if (serverTransactions.isEmpty())\n                        {\n                            cancel();\n                            logger.finest(\"Cancel expired collector \"\n                                + \"due to no more server transactions\");\n                        }\n                    }\n                }\n                catch (Throwable t)\n                {\n                    logger.log(Level.FINE,\n                        \"Failed to expire server transactions\", t);\n                }\n            }\n        };\n\n        /**\n         * Scheduled execution of {@link #collector} runnable.\n         * Access synchronized via {@link #serverTransactions}.\n         */\n        private ScheduledFuture<?> scheduledCollectorFuture;\n\n        /**\n         * Schedules repeated collector execution in background\n         * task executor. If collector is already scheduled - do nothing\n         */\n        void schedule()\n        {\n            synchronized (serverTransactions)\n            {\n                if (scheduledCollectorFuture == null ||\n                    scheduledCollectorFuture.isDone())\n                {\n                    scheduledCollectorFuture\n                        = tasksScheduler.scheduleWithFixedDelay(\n                            collector,\n                            StunServerTransaction.LIFETIME,\n                            StunServerTransaction.LIFETIME,\n                            TimeUnit.MILLISECONDS);\n                }\n            }\n        }\n\n        /**\n         * Cancels execution of scheduled expired transactions collector if\n         * it is running\n         */\n        void cancel()\n        {\n            synchronized (serverTransactions)\n            {\n                if (scheduledCollectorFuture != null)\n                {\n                    scheduledCollectorFuture.cancel(false);\n                    scheduledCollectorFuture = null;\n                }\n            }\n        }\n    }", "definition": "    private final class ExpiredServerTransactionsCollector", "class_docstring": "\nClass which performs periodic collection of expired transactions.\nIt's execution is controlled outside by {@link #schedule()}\nand {@link #cancel()} methods. Whenever expired transactions collector\nis scheduled it does self reschedule with fixed delay\nof StunServerTransaction.LIFETIME_MILLIS,\nuntil {@link #serverTransactions} is empty, in that case it self-cancel\nfurther execution and need to be scheduled again when new item added\nto {@link #serverTransactions} container.\n", "name": "ExpiredServerTransactionsCollector", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private final Runnable collector = new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    synchronized (serverTransactions)\n                    {\n                        final int transactionsBeforeCollection\n                            = serverTransactions.size();\n\n                        long now = System.currentTimeMillis();\n\n                        for (Iterator<StunServerTransaction> i\n                                    = serverTransactions.values().iterator();\n                                i.hasNext();)\n                        {\n                            StunServerTransaction serverTransaction = i.next();\n\n                            if (serverTransaction == null)\n                            {\n                                i.remove();\n                            }\n                            else if (serverTransaction.isExpired(now))\n                            {\n                                i.remove();\n                                serverTransaction.expire();\n                            }\n                        }\n\n                        logger.fine(\"Non-expired server transactions \"\n                            + \"count \" + serverTransactions.size()\n                            + \", transactions before collection \"\n                            + transactionsBeforeCollection);\n\n                        if (serverTransactions.isEmpty())\n                        {\n                            cancel();\n                            logger.finest(\"Cancel expired collector \"\n                                + \"due to no more server transactions\");\n                        }\n                    }\n                }\n                catch (Throwable t)\n                {\n                    logger.log(Level.FINE,\n                        \"Failed to expire server transactions\", t);\n                }\n            }\n        };", "docstring": "\nRunnable which walks {@link #serverTransactions}, check if\ntransaction is expired and if so - remove it\nfrom {@link #serverTransactions}.\nSelf-cancels when {@link #serverTransactions} is empty\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Runnable", "name": "collector = new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    synchronized (serverTransactions)\n                    {\n                        final int transactionsBeforeCollection\n                            = serverTransactions.size();\n\n                        long now = System.currentTimeMillis();\n\n                        for (Iterator<StunServerTransaction> i\n                                    = serverTransactions.values().iterator();\n                                i.hasNext();)\n                        {\n                            StunServerTransaction serverTransaction = i.next();\n\n                            if (serverTransaction == null)\n                            {\n                                i.remove();\n                            }\n                            else if (serverTransaction.isExpired(now))\n                            {\n                                i.remove();\n                                serverTransaction.expire();\n                            }\n                        }\n\n                        logger.fine(\"Non-expired server transactions \"\n                            + \"count \" + serverTransactions.size()\n                            + \", transactions before collection \"\n                            + transactionsBeforeCollection);\n\n                        if (serverTransactions.isEmpty())\n                        {\n                            cancel();\n                            logger.finest(\"Cancel expired collector \"\n                                + \"due to no more server transactions\");\n                        }\n                    }\n                }\n                catch (Throwable t)\n                {\n                    logger.log(Level.FINE,\n                        \"Failed to expire server transactions\", t);\n                }\n            }\n        }", "syntax_pass": true}, {"attribute_expression": "private ScheduledFuture<?> scheduledCollectorFuture;", "docstring": "\nScheduled execution of {@link #collector} runnable.\nAccess synchronized via {@link #serverTransactions}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ScheduledFuture<?>", "name": "scheduledCollectorFuture", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        void schedule()\n        {\n            synchronized (serverTransactions)\n            {\n                if (scheduledCollectorFuture == null ||\n                    scheduledCollectorFuture.isDone())\n                {\n                    scheduledCollectorFuture\n                        = tasksScheduler.scheduleWithFixedDelay(\n                            collector,\n                            StunServerTransaction.LIFETIME,\n                            StunServerTransaction.LIFETIME,\n                            TimeUnit.MILLISECONDS);\n                }\n            }\n        }", "docstring": "\nSchedules repeated collector execution in background\ntask executor. If collector is already scheduled - do nothing\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "schedule", "params": [], "body": "        {\n            synchronized (serverTransactions)\n            {\n                if (scheduledCollectorFuture == null ||\n                    scheduledCollectorFuture.isDone())\n                {\n                    scheduledCollectorFuture\n                        = tasksScheduler.scheduleWithFixedDelay(\n                            collector,\n                            StunServerTransaction.LIFETIME,\n                            StunServerTransaction.LIFETIME,\n                            TimeUnit.MILLISECONDS);\n                }\n            }\n        }", "signature": "void schedule()"}, {"syntax_pass": true, "original_string": "        void cancel()\n        {\n            synchronized (serverTransactions)\n            {\n                if (scheduledCollectorFuture != null)\n                {\n                    scheduledCollectorFuture.cancel(false);\n                    scheduledCollectorFuture = null;\n                }\n            }\n        }", "docstring": "\nCancels execution of scheduled expired transactions collector if\nit is running\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "cancel", "params": [], "body": "        {\n            synchronized (serverTransactions)\n            {\n                if (scheduledCollectorFuture != null)\n                {\n                    scheduledCollectorFuture.cancel(false);\n                    scheduledCollectorFuture = null;\n                }\n            }\n        }", "signature": "void cancel()"}]}], "class_docstring": "\nThe entry point to the Stun4J stack. The class is used to start, stop and\nconfigure the stack.\n\n@author Emil Ivov\n@author Lyubomir Marinov\n@author Aakash Garg.\n", "original_string": "public class StunStack\n    implements MessageEventHandler\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>StunStack</tt> class and its\n     * instances for logging output.\n     */\n    private static final java.util.logging.Logger logger\n        = java.util.logging.Logger.getLogger(StunStack.class.getName());\n\n    /**\n     * The indicator which determines whether\n     * <code>Mac.getInstance(MessageIntegrityAttribute.HMAC_SHA1_ALGORITHM)</code>\n     * has been called.\n     *\n     * @see #StunStack()\n     */\n    private static Mac mac;\n\n    /**\n     *  The ScheduledExecutorService to execute StunStack scheduled tasks,\n     *  in particular - expired server transactions collector.\n     */\n    private static final ScheduledExecutorService tasksScheduler\n        = ExecutorFactory.createSingleThreadScheduledExecutor(\n            \"ice4j.StunStack-\", 60, TimeUnit.SECONDS);\n\n    /**\n     * Our network gateway.\n     */\n    private final NetAccessManager netAccessManager;\n\n    /**\n     * The {@link CredentialsManager} that we are using for retrieving\n     * passwords.\n     */\n    private final CredentialsManager credentialsManager\n        = new CredentialsManager();\n\n    /**\n     * Stores active client transactions mapped against TransactionID-s.\n     */\n    private final Hashtable<TransactionID, StunClientTransaction>\n        clientTransactions\n            = new Hashtable<>();\n\n    /**\n     * The <tt>ExpiredServerTransactionsCollector</tt> which expires\n     * the <tt>StunServerTransaction</tt>s of this <tt>StunStack</tt> and\n     * removes them from {@link #serverTransactions}.\n     */\n    private ExpiredServerTransactionsCollector expiredTransactionsCollector\n        = new ExpiredServerTransactionsCollector();\n\n    /**\n     * Currently open server transactions. The vector contains transaction ids\n     * for transactions corresponding to all non-answered received requests.\n     */\n    private final Hashtable<TransactionID, StunServerTransaction>\n        serverTransactions\n            = new Hashtable<>();\n\n    /**\n     * A dispatcher for incoming requests event;\n     */\n    private final EventDispatcher eventDispatcher = new EventDispatcher();\n\n    /**\n     * The packet logger instance.\n     */\n    private static PacketLogger packetLogger;\n\n    /**\n     * Creates and starts a Network Access Point (Connector) based on the\n     * specified socket.\n     *\n     * @param sock The socket that the new access point should represent.\n     */\n    public void addSocket(IceSocketWrapper sock)\n    {\n        netAccessManager.addSocket(sock);\n    }\n\n    /**\n     * Creates and starts a Network Access Point (Connector) based on the\n     * specified socket and the specified remote address.\n     *\n     * @param sock The socket that the new access point should represent.\n     * @param remoteAddress the remote address of the socket of the\n     * {@link Connector} to be created if it is a TCP socket, or null if it\n     * is UDP.\n     */\n    public void addSocket(IceSocketWrapper sock, TransportAddress remoteAddress)\n    {\n        netAccessManager.addSocket(sock, remoteAddress);\n    }\n\n    /**\n     * Stops and deletes the connector listening on the specified local address.\n     * Note this removes connectors with UDP sockets only, use\n     * {@link #removeSocket(org.ice4j.TransportAddress, org.ice4j.TransportAddress)}\n     * with the appropriate remote address for TCP.\n     *\n     * @param localAddr the local address of the socket to remove.\n     */\n    public void removeSocket(TransportAddress localAddr)\n    {\n        removeSocket(localAddr, null);\n    }\n\n    /**\n     * Stops and deletes the connector listening on the specified local address\n     * and remote address.\n     *\n     * @param localAddr the local address of the socket to remove.\n     * @param remoteAddr the remote address of the socket to remove. Use\n     * <tt>null</tt> for UDP.\n     */\n    public void removeSocket(TransportAddress localAddr,\n                             TransportAddress remoteAddr)\n    {\n        //first cancel all transactions using this address.\n        cancelTransactionsForAddress(localAddr, remoteAddr);\n\n        netAccessManager.removeSocket(localAddr, remoteAddr);\n    }\n\n    /**\n     * Returns the transaction with the specified <tt>transactionID</tt> or\n     * <tt>null</tt> if no such transaction exists.\n     *\n     * @param transactionID the ID of the transaction we are looking for.\n     *\n     * @return the {@link StunClientTransaction} we are looking for.\n     */\n    protected StunClientTransaction getClientTransaction(byte[] transactionID)\n    {\n        synchronized (clientTransactions)\n        {\n            Collection<StunClientTransaction> cTrans\n                = clientTransactions.values();\n\n            for (StunClientTransaction tran : cTrans)\n            {\n                if (tran.getTransactionID().equals(transactionID))\n                    return tran;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the transaction with the specified <tt>transactionID</tt> or\n     * <tt>null</tt> if no such transaction exists.\n     *\n     * @param transactionID the ID of the transaction we are looking for.\n     *\n     * @return the {@link StunClientTransaction} we are looking for.\n     */\n    protected StunServerTransaction getServerTransaction(byte[] transactionID)\n    {\n        synchronized (serverTransactions)\n        {\n            long now = System.currentTimeMillis();\n\n            for (Iterator<StunServerTransaction> i\n                        = serverTransactions.values().iterator();\n                    i.hasNext();)\n            {\n                StunServerTransaction serverTransaction = i.next();\n\n                if (serverTransaction.isExpired(now))\n                    i.remove();\n                else if (serverTransaction.getTransactionID().equals(\n                        transactionID))\n                    return serverTransaction;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the transaction with the specified <tt>transactionID</tt> or\n     * <tt>null</tt> if no such transaction exists.\n     *\n     * @param transactionID the ID of the transaction we are looking for.\n     *\n     * @return the {@link StunClientTransaction} we are looking for.\n     */\n    protected StunServerTransaction getServerTransaction(\n            TransactionID transactionID)\n    {\n        StunServerTransaction serverTransaction;\n\n        synchronized (serverTransactions)\n        {\n            serverTransaction = serverTransactions.get(transactionID);\n        }\n        /*\n         * If a StunServerTransaction is expired, do not return it. It will be\n         * removed from serverTransactions soon.\n         */\n        if ((serverTransaction != null) && serverTransaction.isExpired())\n            serverTransaction = null;\n        return serverTransaction;\n    }\n\n    /**\n     * Cancels the {@link StunClientTransaction} with the specified\n     * <tt>transactionID</tt>. Cancellation means that the stack will not\n     * retransmit the request, will not treat the lack of response to be a\n     * failure, but will wait the duration of the transaction timeout for a\n     * response.\n     *\n     * @param transactionID the {@link TransactionID} of the\n     * {@link StunClientTransaction} to cancel\n     */\n    public void cancelTransaction(TransactionID transactionID)\n    {\n        StunClientTransaction clientTransaction\n            = clientTransactions.get(transactionID);\n\n        if (clientTransaction != null)\n            clientTransaction.cancel();\n    }\n\n    /**\n     * Stops all transactions for the specified <tt>localAddr</tt> so that they\n     * won't send messages through any longer and so that we could remove the\n     * associated socket.\n     *\n     * @param localAddr the <tt>TransportAddress</tt> that we'd like to remove\n     * transactions for.\n     * @param remoteAddr the remote <tt>TransportAddress</tt> that we'd like to\n     * remove transactions for. If <tt>null</tt>, then it will not be taken\n     * into account (that is, all transactions with for <tt>localAddr</tt> will\n     * be cancelled).\n     */\n    private void cancelTransactionsForAddress(TransportAddress localAddr,\n                                              TransportAddress remoteAddr)\n    {\n        List<StunClientTransaction> clientTransactionsToCancel = null;\n\n        synchronized (clientTransactions)\n        {\n            Iterator<StunClientTransaction> clientTransactionsIter\n                = clientTransactions.values().iterator();\n\n            while (clientTransactionsIter.hasNext())\n            {\n                StunClientTransaction tran = clientTransactionsIter.next();\n\n                if (tran.getLocalAddress().equals(localAddr)\n                        && (remoteAddr == null\n                                || remoteAddr.equals(tran.getRemoteAddress())))\n                {\n                    clientTransactionsIter.remove();\n\n                    /*\n                     * Invoke StunClientTransaction.cancel() outside the\n                     * clientTransactions-synchronized block in order to avoid a\n                     * deadlock. Reported by Carl Hasselskog.\n                     */\n                    if (clientTransactionsToCancel == null)\n                    {\n                        clientTransactionsToCancel = new LinkedList<>();\n                    }\n                    clientTransactionsToCancel.add(tran);\n                }\n            }\n        }\n        /*\n         * Invoke StunClientTransaction.cancel() outside the\n         * clientTransactions-synchronized block in order to avoid a deadlock.\n         * Reported by Carl Hasselskog.\n         */\n        if (clientTransactionsToCancel != null)\n        {\n            for (StunClientTransaction tran : clientTransactionsToCancel)\n                tran.cancel();\n        }\n\n        List<StunServerTransaction> serverTransactionsToExpire = null;\n\n        synchronized (serverTransactions)\n        {\n            Iterator<StunServerTransaction> serverTransactionsIter\n                = serverTransactions.values().iterator();\n\n            while (serverTransactionsIter.hasNext())\n            {\n                StunServerTransaction tran = serverTransactionsIter.next();\n                TransportAddress listenAddr = tran.getLocalListeningAddress();\n                TransportAddress sendingAddr = tran.getSendingAddress();\n\n                if (listenAddr.equals(localAddr)\n                        || (sendingAddr != null\n                                && sendingAddr.equals(localAddr)))\n                {\n                    if (remoteAddr == null\n                          || remoteAddr.equals(tran.getRequestSourceAddress()))\n                    {\n                        serverTransactionsIter.remove();\n\n                        if (serverTransactionsToExpire == null)\n                        {\n                            serverTransactionsToExpire = new LinkedList<>();\n                        }\n                        serverTransactionsToExpire.add(tran);\n                    }\n                }\n            }\n        }\n        if (serverTransactionsToExpire != null)\n        {\n            for (StunServerTransaction tran : serverTransactionsToExpire)\n                tran.expire();\n        }\n    }\n\n    /**\n     * Initializes a new <tt>StunStack</tt> instance with given\n     * peerUdpMessageEventHandler and channelDataEventHandler.\n     * \n     * @param peerUdpMessageEventHandler the <tt>PeerUdpMessageEventHandler</tt>\n     *            that will handle incoming UDP messages which are not STUN\n     *            messages and ChannelData messages.\n     * @param channelDataEventHandler the <tt>ChannelDataEventHandler</tt> that\n     *            will handle incoming UDP messages which are ChannelData\n     *            messages.\n     */\n    public StunStack(PeerUdpMessageEventHandler peerUdpMessageEventHandler,\n            ChannelDataEventHandler channelDataEventHandler)\n    {\n        /*\n         * The Mac instantiation used in MessageIntegrityAttribute could take\n         * several hundred milliseconds so we don't want it instantiated only\n         * after we get a response because the delay may cause the transaction\n         * to fail.\n         */\n        synchronized (StunStack.class)\n        {\n            if (mac == null)\n            {\n                try\n                {\n                    mac\n                        = Mac.getInstance(\n                                MessageIntegrityAttribute.HMAC_SHA1_ALGORITHM);\n                }\n                catch (NoSuchAlgorithmException nsaex)\n                {\n                    nsaex.printStackTrace();\n                }\n            }\n        }\n        netAccessManager =\n            new NetAccessManager(this, peerUdpMessageEventHandler,\n                channelDataEventHandler);\n    }\n    /**\n     * Initializes a new <tt>StunStack</tt> instance.\n     */\n    public StunStack()\n    {\n        this(null, null);\n    }\n    \n    /**\n     * Returns the currently active instance of NetAccessManager.\n     * @return the currently active instance of NetAccessManager.\n     */\n    NetAccessManager getNetAccessManager()\n    {\n        return netAccessManager;\n    }\n\n    /**\n     * Sends a specific STUN <tt>Indication</tt> to a specific destination\n     * <tt>TransportAddress</tt> through a socket registered with this\n     * <tt>StunStack</tt> using a specific <tt>TransportAddress</tt>.\n     *\n     * @param channelData the STUN <tt>Indication</tt> to be sent to the\n     * specified destination <tt>TransportAddress</tt> through the socket with\n     * the specified <tt>TransportAddress</tt>\n     * @param sendTo the <tt>TransportAddress</tt> of the destination to which\n     * the specified <tt>indication</tt> is to be sent\n     * @param sendThrough the <tt>TransportAddress</tt> of the socket registered\n     * with this <tt>StunStack</tt> through which the specified\n     * <tt>indication</tt> is to be sent\n     * @throws StunException if anything goes wrong while sending the specified\n     * <tt>indication</tt> to the destination <tt>sendTo</tt> through the socket\n     * identified by <tt>sendThrough</tt>\n     */\n    public void sendChannelData(\n            ChannelData channelData,\n            TransportAddress sendTo,\n            TransportAddress sendThrough)\n        throws StunException\n    {\n        try\n        {\n            getNetAccessManager().sendMessage(channelData, sendThrough, sendTo);\n        }\n        catch (StunException stex)\n        {\n            throw stex;\n        }\n        catch (IllegalArgumentException iaex)\n        {\n            throw new StunException(\n                    StunException.ILLEGAL_ARGUMENT,\n                    \"Failed to send STUN indication: \" + channelData,\n                    iaex);\n        }\n        catch (IOException ioex)\n        {\n            throw new StunException(\n                    StunException.NETWORK_ERROR,\n                    \"Failed to send STUN indication: \" + channelData,\n                    ioex);\n        }\n    }\n    \n\n    /**\n     * Sends a specific STUN <tt>Indication</tt> to a specific destination\n     * <tt>TransportAddress</tt> through a socket registered with this\n     * <tt>StunStack</tt> using a specific <tt>TransportAddress</tt>.\n     *\n     * @param udpMessage the <tt>RawMessage</tt> to be sent to the\n     * specified destination <tt>TransportAddress</tt> through the socket with\n     * the specified <tt>TransportAddress</tt>\n     * @param sendTo the <tt>TransportAddress</tt> of the destination to which\n     * the specified <tt>indication</tt> is to be sent\n     * @param sendThrough the <tt>TransportAddress</tt> of the socket registered\n     * with this <tt>StunStack</tt> through which the specified\n     * <tt>indication</tt> is to be sent\n     * @throws StunException if anything goes wrong while sending the specified\n     * <tt>indication</tt> to the destination <tt>sendTo</tt> through the socket\n     * identified by <tt>sendThrough</tt>\n     */\n    public void sendUdpMessage(\n            RawMessage udpMessage,\n            TransportAddress sendTo,\n            TransportAddress sendThrough)\n        throws StunException\n    {\n        \n        try\n        {\n            getNetAccessManager().sendMessage(\n                udpMessage.getBytes(), sendThrough, sendTo);\n        }\n        catch (IllegalArgumentException iaex)\n        {\n            throw new StunException(\n                    StunException.ILLEGAL_ARGUMENT,\n                    \"Failed to send STUN indication: \" + udpMessage,\n                    iaex);\n        }\n        catch (IOException ioex)\n        {\n            throw new StunException(\n                    StunException.NETWORK_ERROR,\n                    \"Failed to send STUN indication: \" + udpMessage,\n                    ioex);\n        }\n    }\n\n    /**\n     * Sends a specific STUN <tt>Indication</tt> to a specific destination\n     * <tt>TransportAddress</tt> through a socket registered with this\n     * <tt>StunStack</tt> using a specific <tt>TransportAddress</tt>.\n     *\n     * @param indication the STUN <tt>Indication</tt> to be sent to the\n     * specified destination <tt>TransportAddress</tt> through the socket with\n     * the specified <tt>TransportAddress</tt>\n     * @param sendTo the <tt>TransportAddress</tt> of the destination to which\n     * the specified <tt>indication</tt> is to be sent\n     * @param sendThrough the <tt>TransportAddress</tt> of the socket registered\n     * with this <tt>StunStack</tt> through which the specified\n     * <tt>indication</tt> is to be sent\n     * @throws StunException if anything goes wrong while sending the specified\n     * <tt>indication</tt> to the destination <tt>sendTo</tt> through the socket\n     * identified by <tt>sendThrough</tt>\n     */\n    public void sendIndication(\n            Indication indication,\n            TransportAddress sendTo,\n            TransportAddress sendThrough)\n        throws StunException\n    {\n        if (indication.getTransactionID() == null)\n        {\n            indication.setTransactionID(\n                    TransactionID.createNewTransactionID().getBytes());\n        }\n\n        try\n        {\n            getNetAccessManager().sendMessage(indication, sendThrough, sendTo);\n        }\n        catch (IllegalArgumentException iaex)\n        {\n            throw new StunException(\n                    StunException.ILLEGAL_ARGUMENT,\n                    \"Failed to send STUN indication: \" + indication,\n                    iaex);\n        }\n        catch (IOException ioex)\n        {\n            throw new StunException(\n                    StunException.NETWORK_ERROR,\n                    \"Failed to send STUN indication: \" + indication,\n                    ioex);\n        }\n    }\n\n    /**\n     * Sends the specified request through the specified access point, and\n     * registers the specified ResponseCollector for later notification.\n     * @param  request     the request to send\n     * @param  sendTo      the destination address of the request.\n     * @param  sendThrough the local address to use when sending the request\n     * @param  collector   the instance to notify when a response arrives or the\n     *                     the transaction timeouts\n     *\n     * @return the <tt>TransactionID</tt> of the <tt>StunClientTransaction</tt>\n     * that we used in order to send the request.\n     *\n     * @throws IOException  if an error occurs while sending message bytes\n     * through the network socket.\n     * @throws IllegalArgumentException if the apDescriptor references an\n     * access point that had not been installed,\n     */\n    public TransactionID sendRequest(  Request           request,\n                                       TransportAddress  sendTo,\n                                       TransportAddress  sendThrough,\n                                       ResponseCollector collector)\n        throws IOException, IllegalArgumentException\n    {\n        return sendRequest(request, sendTo, sendThrough, collector,\n                        TransactionID.createNewTransactionID());\n    }\n\n    /**\n     * Sends the specified request through the specified access point, and\n     * registers the specified ResponseCollector for later notification.\n     * @param  request     the request to send\n     * @param  sendTo      the destination address of the request.\n     * @param  sendThrough the local address to use when sending the request\n     * @param  collector   the instance to notify when a response arrives or the\n     * the transaction timeouts\n     * @param transactionID the ID that we'd like the new transaction to use\n     * in case the application created it in order to use it for application\n     * data correlation.\n     *\n     * @return the <tt>TransactionID</tt> of the <tt>StunClientTransaction</tt>\n     * that we used in order to send the request.\n     *\n     * @throws IllegalArgumentException if the apDescriptor references an\n     * access point that had not been installed,\n     * @throws IOException  if an error occurs while sending message bytes\n     * through the network socket.\n     */\n    public TransactionID sendRequest(Request           request,\n                                     TransportAddress  sendTo,\n                                     TransportAddress  sendThrough,\n                                     ResponseCollector collector,\n                                     TransactionID     transactionID)\n        throws IllegalArgumentException,\n               IOException\n    {\n        return\n            sendRequest(\n                    request, sendTo, sendThrough, collector, transactionID,\n                    -1, -1, -1);\n    }\n\n    /**\n     * Sends the specified request through the specified access point, and\n     * registers the specified ResponseCollector for later notification.\n     * @param  request     the request to send\n     * @param  sendTo      the destination address of the request.\n     * @param  sendThrough the local address to use when sending the request\n     * @param  collector   the instance to notify when a response arrives or the\n     * the transaction timeouts\n     * @param transactionID the ID that we'd like the new transaction to use\n     * in case the application created it in order to use it for application\n     * data correlation.\n     * @param originalWaitInterval The number of milliseconds to wait before\n     * the first retransmission of the request.\n     * @param maxWaitInterval The maximum wait interval. Once this interval is\n     * reached we should stop doubling its value.\n     * @param maxRetransmissions Maximum number of retransmissions. Once this\n     * number is reached and if no response is received after maxWaitInterval\n     * milliseconds the request is considered unanswered.\n     * @return the <tt>TransactionID</tt> of the <tt>StunClientTransaction</tt>\n     * that we used in order to send the request.\n     *\n     * @throws IllegalArgumentException if the apDescriptor references an\n     * access point that had not been installed,\n     * @throws IOException  if an error occurs while sending message bytes\n     * through the network socket.\n     */\n    public TransactionID sendRequest(Request           request,\n                                     TransportAddress  sendTo,\n                                     TransportAddress  sendThrough,\n                                     ResponseCollector collector,\n                                     TransactionID     transactionID,\n                                     int               originalWaitInterval,\n                                     int               maxWaitInterval,\n                                     int               maxRetransmissions)\n        throws IllegalArgumentException,\n               IOException\n    {\n        StunClientTransaction clientTransaction\n            = new StunClientTransaction(\n                    this,\n                    request,\n                    sendTo,\n                    sendThrough,\n                    collector,\n                    transactionID);\n\n        if (originalWaitInterval > 0)\n            clientTransaction.originalWaitInterval = originalWaitInterval;\n        if (maxWaitInterval > 0)\n            clientTransaction.maxWaitInterval = maxWaitInterval;\n        if (maxRetransmissions >= 0)\n            clientTransaction.maxRetransmissions = maxRetransmissions;\n\n        clientTransactions.put(\n                clientTransaction.getTransactionID(),\n                clientTransaction);\n\n        clientTransaction.sendRequest();\n\n        return clientTransaction.getTransactionID();\n    }\n\n    /**\n     * Sends the specified request through the specified access point, and\n     * registers the specified ResponseCollector for later notification.\n     * @param  request     the request to send\n     * @param  sendTo      the destination address of the request.\n     * @param  sendThrough the socket that we should send the request through.\n     * @param  collector   the instance to notify when a response arrives or the\n     *                     the transaction timeouts\n     *\n     * @return the <tt>TransactionID</tt> of the <tt>StunClientTransaction</tt>\n     * that we used in order to send the request.\n     *\n     * @throws IOException  if an error occurs while sending message bytes\n     * through the network socket.\n     * @throws IllegalArgumentException if the apDescriptor references an\n     * access point that had not been installed,\n     */\n    public TransactionID sendRequest( Request           request,\n                                      TransportAddress  sendTo,\n                                      DatagramSocket    sendThrough,\n                                      ResponseCollector collector )\n        throws IOException, IllegalArgumentException\n    {\n        TransportAddress sendThroughAddr = new TransportAddress(\n            sendThrough.getLocalAddress(), sendThrough.getLocalPort(),\n                Transport.UDP);\n\n        return sendRequest(request, sendTo, sendThroughAddr, collector);\n    }\n\n    /**\n     * Sends the specified response message through the specified access point.\n     *\n     * @param transactionID the id of the transaction to use when sending the\n     * response. Actually we are getting kind of redundant here as we already\n     * have the id in the response object, but I am bringing out as an extra\n     * parameter as the user might otherwise forget to explicitly set it.\n     * @param response      the message to send.\n     * @param sendThrough   the local address to use when sending the message.\n     * @param sendTo        the destination of the message.\n     *\n     * @throws IOException  if an error occurs while sending message bytes\n     * through the network socket.\n     * @throws IllegalArgumentException if the apDescriptor references an\n     * access point that had not been installed,\n     * @throws StunException if message encoding fails\n     */\n    public void sendResponse(byte[]           transactionID,\n                             Response         response,\n                             TransportAddress sendThrough,\n                             TransportAddress sendTo)\n        throws StunException,\n               IOException,\n               IllegalArgumentException\n    {\n        TransactionID tid\n            = TransactionID.createTransactionID(this, transactionID);\n        StunServerTransaction sTran = getServerTransaction(tid);\n\n        if (sTran == null)\n        {\n            throw new StunException(StunException.TRANSACTION_DOES_NOT_EXIST,\n                                \"The transaction specified in the response \"\n                                + \"(tid=\"+ tid.toString() +\") \"\n                                + \"object does not exist.\");\n        }\n        else if ( sTran.isRetransmitting())\n        {\n            throw new StunException(StunException.TRANSACTION_ALREADY_ANSWERED,\n                                    \"The transaction specified in the response \"\n                                    + \"(tid=\"+ tid.toString() +\") \"\n                                    + \"has already seen a previous response. \"\n                                    + \"Response was:\\n\"\n                                    + sTran.getResponse());\n        }\n        else\n        {\n            sTran.sendResponse(response, sendThrough, sendTo);\n        }\n    }\n\n    /**\n     * Adds a new <tt>MessageEventHandler</tt> which is to be notified about\n     * STUN indications received at a specific local <tt>TransportAddress</tt>.\n     *\n     * @param localAddr the <tt>TransportAddress</tt> of the local socket for\n     * which received STUN indications are to be reported to the specified\n     * <tt>MessageEventHandler</tt>\n     * @param indicationListener the <tt>MessageEventHandler</tt> which is to be\n     * registered for notifications about STUN indications received at the\n     * specified local <tt>TransportAddress</tt>\n     */\n    public void addIndicationListener(\n            TransportAddress localAddr,\n            MessageEventHandler indicationListener)\n    {\n        eventDispatcher.addIndicationListener(localAddr, indicationListener);\n    }\n\n    /**\n     * Adds a new <tt>MessageEventHandler</tt> which is to be notified about\n     * old indications received at a specific local <tt>TransportAddress</tt>.\n     *\n     * @param localAddr the <tt>TransportAddress</tt> of the local socket for\n     * which received STUN indications are to be reported to the specified\n     * <tt>MessageEventHandler</tt>\n     * @param indicationListener the <tt>MessageEventHandler</tt> which is to be\n     * registered for notifications about old indications received at the\n     * specified local <tt>TransportAddress</tt>\n     */\n    public void addOldIndicationListener(\n            TransportAddress localAddr,\n            MessageEventHandler indicationListener)\n    {\n        eventDispatcher.addOldIndicationListener(localAddr, indicationListener);\n    }\n\n    /**\n     * Sets the listener that should be notified when a new Request is received.\n     * @param requestListener the listener interested in incoming requests.\n     */\n    public void addRequestListener(RequestListener requestListener)\n    {\n        this.eventDispatcher.addRequestListener( requestListener );\n    }\n\n    /**\n     * Removes an existing <tt>MessageEventHandler</tt> to no longer be notified\n     * about STUN indications received at a specific local\n     * <tt>TransportAddress</tt>.\n     *\n     * @param localAddr the <tt>TransportAddress</tt> of the local socket for\n     * which received STUN indications are to no longer be reported to the\n     * specified <tt>MessageEventHandler</tt>\n     * @param indicationListener the <tt>MessageEventHandler</tt> which is to be\n     * unregistered for notifications about STUN indications received at the\n     * specified local <tt>TransportAddress</tt>\n     */\n    public void removeIndicationListener(\n            TransportAddress localAddr,\n            MessageEventHandler indicationListener)\n    {\n    }\n\n    /**\n     * Removes the specified listener from the local listener list. (If any\n     * instances of this listener have been registered for a particular\n     * access point, they will not be removed).\n     * @param listener the RequestListener listener to unregister\n     */\n    public void removeRequestListener(RequestListener listener)\n    {\n        this.eventDispatcher.removeRequestListener(listener);\n    }\n\n    /**\n     * Add a RequestListener for requests coming from a specific NetAccessPoint.\n     * The listener will be invoked only when a request event is received on\n     * that specific property.\n     *\n     * @param localAddress The local <tt>TransportAddress</tt> that we would\n     * like to listen on.\n     * @param listener The ConfigurationChangeListener to be added\n     */\n    public void addRequestListener( TransportAddress localAddress,\n                                    RequestListener  listener)\n    {\n            eventDispatcher.addRequestListener(localAddress, listener);\n    }\n\n    /**\n     * Removes a client transaction from this providers client transactions\n     * list. The method is used by <tt>StunClientTransaction</tt>s themselves\n     * when a timeout occurs.\n     *\n     * @param tran the transaction to remove.\n     */\n    void removeClientTransaction(StunClientTransaction tran)\n    {\n        synchronized (clientTransactions)\n        {\n            clientTransactions.remove(tran.getTransactionID());\n        }\n    }\n\n    /**\n     * Removes a server transaction from this provider's server transactions\n     * list.\n     * Method is used by StunServerTransaction-s themselves when they expire.\n     * @param tran the transaction to remove.\n     */\n    void removeServerTransaction(StunServerTransaction tran)\n    {\n        synchronized (serverTransactions)\n        {\n            serverTransactions.remove(tran.getTransactionID());\n        }\n    }\n\n    /**\n     * Called to notify this provider for an incoming message.\n     *\n     * @param ev the event object that contains the new message.\n     */\n    @Override\n    public void handleMessageEvent(StunMessageEvent ev)\n    {\n        Message msg = ev.getMessage();\n\n        if (logger.isLoggable(Level.FINEST))\n        {\n            logger.finest(\n                    \"Received a message on \" + ev.getLocalAddress()\n                        + \" of type:\" + (int) msg.getMessageType());\n        }\n\n        //request\n        if (msg instanceof Request)\n        {\n            logger.finest(\"parsing request\");\n\n            TransactionID serverTid = ev.getTransactionID();\n            StunServerTransaction sTran  = getServerTransaction(serverTid);\n\n            if ( sTran != null)\n            {\n                //requests from this transaction have already been seen\n                //retransmit the response if there was any\n                logger.finest(\"found an existing transaction\");\n\n                try\n                {\n                    sTran.retransmitResponse();\n                    logger.finest(\"Response retransmitted\");\n                }\n                catch (Exception ex)\n                {\n                    //we couldn't really do anything here .. apart from logging\n                    logger.log(Level.WARNING,\n                               \"Failed to retransmit a stun response\",\n                               ex);\n                }\n\n                if (!Boolean.getBoolean(\n                        StackProperties.PROPAGATE_RECEIVED_RETRANSMISSIONS))\n                {\n                    return;\n                }\n            }\n            else\n            {\n                logger.finest(\"existing transaction not found\");\n                sTran\n                    = new StunServerTransaction(\n                            this,\n                            serverTid,\n                            ev.getLocalAddress(),\n                            ev.getRemoteAddress());\n\n                // if there is an OOM error here, stop here right now\n                try\n                {\n                    sTran.start();\n                }\n                catch(OutOfMemoryError t)\n                {\n                    logger.info(\"STUN transaction thread start failed:\" + t);\n                    return;\n                }\n                synchronized (serverTransactions)\n                {\n                    serverTransactions.put(serverTid, sTran);\n                    expiredTransactionsCollector.schedule();\n                }\n            }\n\n            //validate attributes that need validation.\n            try\n            {\n                validateRequestAttributes(ev);\n            }\n            catch(Exception exc)\n            {\n                //validation failed. log get lost.\n                logger.log(Level.FINE, \"Failed to validate msg, removing transaction: \" + ev, exc);\n                removeServerTransaction(sTran);\n                return;\n            }\n\n            try\n            {\n                eventDispatcher.fireMessageEvent(ev);\n            }\n            catch (Throwable t)\n            {\n                Response error;\n\n                logger.log(Level.INFO, \"Received an invalid request.\", t);\n                Throwable cause = t.getCause();\n\n                if (((t instanceof StunException)\n                            && ((StunException) t).getID()\n                                    == StunException\n                                        .TRANSACTION_ALREADY_ANSWERED)\n                        || ((cause instanceof StunException)\n                                && ((StunException) cause).getID()\n                                        == StunException\n                                            .TRANSACTION_ALREADY_ANSWERED))\n                {\n                    // do not try to send an error response since we will\n                    // get another TRANSACTION_ALREADY_ANSWERED\n                    return;\n                }\n\n                if (t instanceof IllegalArgumentException)\n                {\n                    error\n                        = createCorrespondingErrorResponse(\n                                msg.getMessageType(),\n                                ErrorCodeAttribute.BAD_REQUEST,\n                                t.getMessage());\n                }\n                else\n                {\n                    error\n                        = createCorrespondingErrorResponse(\n                                msg.getMessageType(),\n                                ErrorCodeAttribute.SERVER_ERROR,\n                                \"Oops! Something went wrong on our side :(\");\n                }\n\n                try\n                {\n                    sendResponse(\n                            serverTid.getBytes(),\n                            error,\n                            ev.getLocalAddress(),\n                            ev.getRemoteAddress());\n                }\n                catch(Exception exc)\n                {\n                    logger.log(Level.FINE,\n                               \"Couldn't send a server error response\",\n                               exc);\n                }\n            }\n        }\n        //response\n        else if (msg instanceof Response)\n        {\n            TransactionID tid = ev.getTransactionID();\n            StunClientTransaction tran = clientTransactions.remove(tid);\n\n            if (tran != null)\n            {\n                tran.handleResponse(ev);\n            }\n            else\n            {\n                //do nothing - just drop the phantom response.\n                logger.fine(\n                        \"Dropped response - no matching client tran found for\"\n                            + \" tid \" + tid + \"\\n\" + \"all tids in stock were \"\n                            + clientTransactions.keySet());\n            }\n        }\n        // indication\n        else if (msg instanceof Indication)\n        {\n            eventDispatcher.fireMessageEvent(ev);\n        }\n    }\n\n    /**\n     * Returns the {@link CredentialsManager} that this stack is using for\n     * verification of {@link MessageIntegrityAttribute}s.\n     *\n     * @return the {@link CredentialsManager} that this stack is using for\n     * verification of {@link MessageIntegrityAttribute}s.\n     */\n    public CredentialsManager getCredentialsManager()\n    {\n        return credentialsManager;\n    }\n\n    /**\n     * Cancels all running transactions and prepares for garbage collection\n     */\n    public void shutDown()\n    {\n        eventDispatcher.removeAllListeners();\n\n        // clientTransactions\n        Collection<StunClientTransaction> clientTransactionsToCancel;\n\n        synchronized (clientTransactions)\n        {\n            clientTransactionsToCancel\n                = new ArrayList<>(clientTransactions.values());\n            clientTransactions.clear();\n        }\n        /*\n         * Invoke StunClientTransaction.cancel() outside the\n         * clientTransactions-synchronized block in order to avoid a deadlock.\n         * Reported by Carl Hasselskog.\n         */\n        for (StunClientTransaction tran : clientTransactionsToCancel)\n            tran.cancel();\n\n        // serverTransactions\n        Collection<StunServerTransaction> serverTransactionsToExpire;\n\n        expiredTransactionsCollector.cancel();\n\n        synchronized (serverTransactions)\n        {\n            serverTransactionsToExpire\n                = new ArrayList<>(serverTransactions.values());\n            serverTransactions.clear();\n        }\n        for (StunServerTransaction tran : serverTransactionsToExpire)\n            tran.expire();\n\n        netAccessManager.stop();\n    }\n\n    /**\n     * Executes actions related specific attributes like asserting proper\n     * checksums or verifying the validity of user names.\n     *\n     * @param evt the {@link StunMessageEvent} that contains the {@link\n     * Request} that we need to validate.\n     *\n     * @throws IllegalArgumentException if there's something in the\n     * <tt>attribute</tt> that caused us to discard the whole message (e.g. an\n     * invalid checksum\n     * or username)\n     * @throws StunException if we fail while sending an error response.\n     * @throws IOException if we fail while sending an error response.\n     */\n    private void validateRequestAttributes(StunMessageEvent evt)\n        throws IllegalArgumentException, StunException, IOException\n    {\n        Message request = evt.getMessage();\n\n        //assert valid username\n        UsernameAttribute unameAttr = (UsernameAttribute)request\n            .getAttribute(Attribute.USERNAME);\n        String username = null;\n\n        if (unameAttr != null)\n        {\n            username = LongTermCredential.toString(unameAttr.getUsername());\n            if (!validateUsername(username))\n            {\n                Response error = createCorrespondingErrorResponse(\n                                request.getMessageType(),\n                                ErrorCodeAttribute.UNAUTHORIZED,\n                                \"unknown user \" + username);\n\n                sendResponse(request.getTransactionID(), error,\n                                evt.getLocalAddress(),\n                                evt.getRemoteAddress());\n\n                throw new IllegalArgumentException(\n                    \"Non-recognized username: \" + username);\n            }\n        }\n\n        //assert Message Integrity\n        MessageIntegrityAttribute msgIntAttr\n            = (MessageIntegrityAttribute)\n                request.getAttribute(Attribute.MESSAGE_INTEGRITY);\n\n        if (msgIntAttr != null)\n        {\n            //we should complain if we have msg integrity and no username.\n            if (unameAttr == null)\n            {\n                Response error = createCorrespondingErrorResponse(\n                                request.getMessageType(),\n                                ErrorCodeAttribute.BAD_REQUEST,\n                                \"missing username\");\n\n                sendResponse(request.getTransactionID(), error,\n                                evt.getLocalAddress(),\n                                evt.getRemoteAddress());\n\n                throw new IllegalArgumentException(\n                    \"Missing USERNAME in the presence of MESSAGE-INTEGRITY: \");\n            }\n\n            if (!validateMessageIntegrity(\n                    msgIntAttr,\n                    username,\n                    true,\n                    evt.getRawMessage()))\n            {\n                Response error = createCorrespondingErrorResponse(\n                                request.getMessageType(),\n                                ErrorCodeAttribute.UNAUTHORIZED,\n                                \"Wrong MESSAGE-INTEGRITY value\");\n\n                sendResponse(request.getTransactionID(), error,\n                                evt.getLocalAddress(),\n                                evt.getRemoteAddress());\n\n                throw new IllegalArgumentException(\n                    \"Wrong MESSAGE-INTEGRITY value.\");\n            }\n        }\n        else if (Boolean.getBoolean(StackProperties.REQUIRE_MESSAGE_INTEGRITY))\n        {\n            // no message integrity\n            Response error = createCorrespondingErrorResponse(\n                            request.getMessageType(),\n                            ErrorCodeAttribute.UNAUTHORIZED,\n                            \"Missing MESSAGE-INTEGRITY.\");\n\n            sendResponse(request.getTransactionID(), error,\n                            evt.getLocalAddress(),\n                            evt.getRemoteAddress());\n            throw new IllegalArgumentException(\n                \"Missing MESSAGE-INTEGRITY.\");\n        }\n\n        //look for unknown attributes.\n        List<Attribute> allAttributes = request.getAttributes();\n        StringBuffer sBuff = new StringBuffer();\n        for (Attribute attr : allAttributes)\n        {\n            if (attr instanceof OptionalAttribute\n                && attr.getAttributeType()\n                    < Attribute.UNKNOWN_OPTIONAL_ATTRIBUTE)\n                sBuff.append(attr.getAttributeType());\n        }\n\n        if (sBuff.length() > 0)\n        {\n            Response error = createCorrespondingErrorResponse(\n                    request.getMessageType(),\n                    ErrorCodeAttribute.UNKNOWN_ATTRIBUTE,\n                    \"unknown attribute \", sBuff.toString().toCharArray());\n\n            sendResponse(request.getTransactionID(), error,\n                            evt.getLocalAddress(),\n                            evt.getRemoteAddress());\n\n            throw new IllegalArgumentException(\n                \"Unknown attribute(s).\");\n        }\n    }\n\n    /**\n     * Recalculates the HMAC-SHA1 signature of the <tt>message</tt> array so\n     * that we could compare it with the value brought by the\n     * {@link MessageIntegrityAttribute}.\n     *\n     * @param msgInt the attribute that we need to validate.\n     * @param username the user name that the message integrity checksum is\n     * supposed to have been built for.\n     * @param shortTermCredentialMechanism <tt>true</tt> if <tt>msgInt</tt> is\n     * to be validated as part of the STUN short-term credential mechanism or\n     * <tt>false</tt> for the STUN long-term credential mechanism\n     * @param message the message whose SHA1 checksum we'd need to recalculate.\n     *\n     * @return <tt>true</tt> if <tt>msgInt</tt> contains a valid SHA1 value and\n     * <tt>false</tt> otherwise.\n     */\n    public boolean validateMessageIntegrity(\n            MessageIntegrityAttribute msgInt,\n            String                    username,\n            boolean                   shortTermCredentialMechanism,\n            RawMessage                message)\n    {\n        int colon = -1;\n\n        if ((username == null)\n                || (username.length() < 1)\n                || (shortTermCredentialMechanism\n                        && ((colon = username.indexOf(\":\")) < 1)))\n        {\n            if (logger.isLoggable(Level.FINE))\n            {\n                logger.log(Level.FINE, \"Received a message with an improperly \"\n                        +\"formatted username\");\n            }\n            return false;\n        }\n\n        if (shortTermCredentialMechanism)\n            username = username.substring(0, colon); // lfrag\n\n        byte[] key = getCredentialsManager().getLocalKey(username);\n\n        if (key == null)\n            return false;\n\n        /*\n         * Now check whether the SHA1 matches. Using\n         * MessageIntegrityAttribute.calculateHmacSha1 on the bytes of the\n         * RawMessage will be incorrect if there are other Attributes after the\n         * MessageIntegrityAttribute because the value of the\n         * MessageIntegrityAttribute is calculated on a STUN \"Message Length\"\n         * upto and including the MESSAGE-INTEGRITY and excluding any Attributes\n         * after it.\n         */\n        byte[] binMsg = new byte[msgInt.getLocationInMessage()];\n\n        System.arraycopy(message.getBytes(), 0, binMsg, 0, binMsg.length);\n\n        char messageLength\n            = (char)\n                (binMsg.length\n                    + Attribute.HEADER_LENGTH\n                    + msgInt.getDataLength()\n                    - Message.HEADER_LENGTH);\n\n        binMsg[2] = (byte) (messageLength >> 8);\n        binMsg[3] = (byte) (messageLength & 0xFF);\n\n        byte[] expectedMsgIntHmacSha1Content;\n\n        try\n        {\n            expectedMsgIntHmacSha1Content\n                = MessageIntegrityAttribute.calculateHmacSha1(\n                        binMsg, 0, binMsg.length,\n                        key);\n        }\n        catch (IllegalArgumentException iaex)\n        {\n            expectedMsgIntHmacSha1Content = null;\n        }\n\n        byte[] msgIntHmacSha1Content = msgInt.getHmacSha1Content();\n\n        if (!Arrays.equals(\n                expectedMsgIntHmacSha1Content,\n                msgIntHmacSha1Content))\n        {\n            if (logger.isLoggable(Level.FINE))\n            {\n                logger.log(\n                        Level.FINE,\n                        \"Received a message with a wrong \"\n                            +\"MESSAGE-INTEGRITY HMAC-SHA1 signature: \"\n                            + \"expected: \"\n                            + toHexString(expectedMsgIntHmacSha1Content)\n                            + \", received: \"\n                            + toHexString(msgIntHmacSha1Content));\n            }\n            return false;\n        }\n\n        if (logger.isLoggable(Level.FINEST))\n            logger.finest(\"Successfully verified msg integrity\");\n        return true;\n    }\n\n    /**\n     * Returns a <tt>String</tt> representation of a specific <tt>byte</tt>\n     * array as an unsigned integer in base 16.\n     *\n     * @param bytes the <tt>byte</tt> to get the <tt>String</tt> representation\n     * of as an unsigned integer in base 16\n     * @return a <tt>String</tt> representation of the specified <tt>byte</tt>\n     * array as an unsigned integer in base 16\n     */\n    private static String toHexString(byte[] bytes)\n    {\n        if (bytes == null)\n            return null;\n        else\n        {\n            StringBuilder hexStringBuilder\n                = new StringBuilder(2 * bytes.length);\n            char[] hexes\n                = new char[]\n                            {\n                                '0', '1', '2', '3', '4', '5', '6', '7', '8',\n                                '9', 'A', 'B', 'C', 'D', 'E', 'F'\n                            };\n\n            for (int i = 0; i < bytes.length; i++)\n            {\n                byte b = bytes[i];\n\n                hexStringBuilder.append(hexes[(b & 0xF0) >> 4]);\n                hexStringBuilder.append(hexes[b & 0x0F]);\n            }\n            return hexStringBuilder.toString();\n        }\n    }\n\n    /**\n     * Asserts the validity of a specific username (e.g. which we've received in\n     * a USERNAME attribute).\n     *\n     * @param username the username to be validated\n     * @return <tt>true</tt> if <tt>username</tt> contains a valid username;\n     * <tt>false</tt>, otherwise\n     */\n    private boolean validateUsername(String username)\n    {\n        int colon = username.indexOf(\":\");\n\n        if ((username.length() < 1) || (colon < 1))\n        {\n            if (logger.isLoggable(Level.FINE))\n            {\n                logger.log(Level.FINE, \"Received a message with an improperly \"\n                        +\"formatted username\");\n            }\n            return false;\n        }\n\n        String lfrag = username.substring(0, colon);\n\n        return getCredentialsManager().checkLocalUserName(lfrag);\n    }\n\n    /**\n     * Returns the currently set packet logger.\n     * @return the currently available packet logger.\n     */\n    public static PacketLogger getPacketLogger()\n    {\n        return packetLogger;\n    }\n\n    /**\n     * Setting a packet logger for the stack.\n     * @param packetLogger the packet logger to use.\n     */\n    public static void setPacketLogger(PacketLogger packetLogger)\n    {\n        StunStack.packetLogger = packetLogger;\n    }\n\n    /**\n     * Checks whether packet logger is set and enabled.\n     * @return <tt>true</tt> if we have a packet logger instance and\n     *  it is enabled.\n     */\n    public static boolean isPacketLoggerEnabled()\n    {\n        return packetLogger != null && packetLogger.isEnabled();\n    }\n\n    /**\n     * Returns the Error Response object with specified errorCode and\n     * reasonPhrase corresponding to input type.\n     * \n     * @param requestType the message type of Request.\n     * @param errorCode the errorCode for Error Response object.\n     * @param reasonPhrase the reasonPhrase for the Error Response object.\n     * @param unknownAttributes char[] array containing the ids of one or more\n     *            attributes that had not been recognized.\n     * @return corresponding Error Response object.\n     */\n    public Response createCorrespondingErrorResponse(char requestType,\n        char errorCode, String reasonPhrase, char... unknownAttributes)\n    {\n        if (requestType == Message.BINDING_REQUEST)\n        {\n            if (unknownAttributes != null)\n            {\n                return MessageFactory.createBindingErrorResponse(\n                    errorCode, reasonPhrase, unknownAttributes);\n            }\n            else\n            {\n                return MessageFactory.createBindingErrorResponse(\n                    errorCode, reasonPhrase);\n            }\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    /**\n     * Logs a specific <tt>DatagramPacket</tt> using the packet logger of the\n     * <tt>StunStack</tt>.\n     *\n     * @param p The <tt>DatagramPacket</tt> to log.\n     * @param isSent <tt>true</tt> if the packet is sent, or <tt>false</tt>\n     * if the packet is received.\n     * @param interfaceAddress The <tt>InetAddress</tt> to use as source (if\n     * the packet was sent) or destination (if the packet was received).\n     * @param interfacePort The port to use as source (if the packet was sent)\n     * or destination (if the packet was received).\n     */\n    public static void logPacketToPcap(\n            DatagramPacket p,\n            boolean isSent,\n            InetAddress interfaceAddress,\n            int interfacePort)\n    {\n        if (interfaceAddress != null && isPacketLoggerEnabled())\n        {\n            InetAddress[] addr = {interfaceAddress, p.getAddress()};\n            int[] port = {interfacePort, p.getPort()};\n            int fromIndex = isSent ? 0 : 1;\n            int toIndex = isSent ? 1 : 0;\n\n            getPacketLogger().logPacket(\n                    addr[fromIndex].getAddress(),\n                    port[fromIndex],\n                    addr[toIndex].getAddress(),\n                    port[toIndex],\n                    p.getData(),\n                    isSent);\n        }\n    }\n\n    /**\n     * Class which performs periodic collection of expired transactions.\n     * It's execution is controlled outside by {@link #schedule()}\n     * and {@link #cancel()} methods. Whenever expired transactions collector\n     * is scheduled it does self reschedule with fixed delay\n     * of StunServerTransaction.LIFETIME_MILLIS,\n     * until {@link #serverTransactions} is empty, in that case it self-cancel\n     * further execution and need to be scheduled again when new item added\n     * to {@link #serverTransactions} container.\n     */\n    private final class ExpiredServerTransactionsCollector\n    {\n        /**\n         * Runnable which walks {@link #serverTransactions}, check if\n         * transaction is expired and if so - remove it\n         * from {@link #serverTransactions}.\n         * Self-cancels when {@link #serverTransactions} is empty\n         */\n        private final Runnable collector = new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    synchronized (serverTransactions)\n                    {\n                        final int transactionsBeforeCollection\n                            = serverTransactions.size();\n\n                        long now = System.currentTimeMillis();\n\n                        for (Iterator<StunServerTransaction> i\n                                    = serverTransactions.values().iterator();\n                                i.hasNext();)\n                        {\n                            StunServerTransaction serverTransaction = i.next();\n\n                            if (serverTransaction == null)\n                            {\n                                i.remove();\n                            }\n                            else if (serverTransaction.isExpired(now))\n                            {\n                                i.remove();\n                                serverTransaction.expire();\n                            }\n                        }\n\n                        logger.fine(\"Non-expired server transactions \"\n                            + \"count \" + serverTransactions.size()\n                            + \", transactions before collection \"\n                            + transactionsBeforeCollection);\n\n                        if (serverTransactions.isEmpty())\n                        {\n                            cancel();\n                            logger.finest(\"Cancel expired collector \"\n                                + \"due to no more server transactions\");\n                        }\n                    }\n                }\n                catch (Throwable t)\n                {\n                    logger.log(Level.FINE,\n                        \"Failed to expire server transactions\", t);\n                }\n            }\n        };\n\n        /**\n         * Scheduled execution of {@link #collector} runnable.\n         * Access synchronized via {@link #serverTransactions}.\n         */\n        private ScheduledFuture<?> scheduledCollectorFuture;\n\n        /**\n         * Schedules repeated collector execution in background\n         * task executor. If collector is already scheduled - do nothing\n         */\n        void schedule()\n        {\n            synchronized (serverTransactions)\n            {\n                if (scheduledCollectorFuture == null ||\n                    scheduledCollectorFuture.isDone())\n                {\n                    scheduledCollectorFuture\n                        = tasksScheduler.scheduleWithFixedDelay(\n                            collector,\n                            StunServerTransaction.LIFETIME,\n                            StunServerTransaction.LIFETIME,\n                            TimeUnit.MILLISECONDS);\n                }\n            }\n        }\n\n        /**\n         * Cancels execution of scheduled expired transactions collector if\n         * it is running\n         */\n        void cancel()\n        {\n            synchronized (serverTransactions)\n            {\n                if (scheduledCollectorFuture != null)\n                {\n                    scheduledCollectorFuture.cancel(false);\n                    scheduledCollectorFuture = null;\n                }\n            }\n        }\n    }\n}", "super_interfaces": ["MessageEventHandler"], "fields": [{"attribute_expression": "private static final java.util.logging.Logger logger\n        = java.util.logging.Logger.getLogger(StunStack.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>StunStack</tt> class and its\ninstances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "java.util.logging.Logger", "name": "logger\n        = java.util.logging.Logger.getLogger(StunStack.class.getName())", "syntax_pass": true}, {"attribute_expression": "private static Mac mac;", "docstring": "\nThe indicator which determines whether\n<code>Mac.getInstance(MessageIntegrityAttribute.HMAC_SHA1_ALGORITHM)</code>\nhas been called.\n\n@see #StunStack()\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "Mac", "name": "mac", "syntax_pass": true}, {"attribute_expression": "private static final ScheduledExecutorService tasksScheduler\n        = ExecutorFactory.createSingleThreadScheduledExecutor(\n            \"ice4j.StunStack-\", 60, TimeUnit.SECONDS);", "docstring": "\n The ScheduledExecutorService to execute StunStack scheduled tasks,\n in particular - expired server transactions collector.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ScheduledExecutorService", "name": "tasksScheduler\n        = ExecutorFactory.createSingleThreadScheduledExecutor(\n            \"ice4j.StunStack-\", 60, TimeUnit.SECONDS)", "syntax_pass": true}, {"attribute_expression": "private final NetAccessManager netAccessManager;", "docstring": "\nOur network gateway.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NetAccessManager", "name": "netAccessManager", "syntax_pass": true}, {"attribute_expression": "private final CredentialsManager credentialsManager\n        = new CredentialsManager();", "docstring": "\nThe {@link CredentialsManager} that we are using for retrieving\npasswords.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CredentialsManager", "name": "credentialsManager\n        = new CredentialsManager()", "syntax_pass": true}, {"attribute_expression": "private final Hashtable<TransactionID, StunClientTransaction>\n        clientTransactions\n            = new Hashtable<>();", "docstring": "\nStores active client transactions mapped against TransactionID-s.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Hashtable<TransactionID, StunClientTransaction>", "name": "clientTransactions\n            = new Hashtable<>()", "syntax_pass": true}, {"attribute_expression": "private ExpiredServerTransactionsCollector expiredTransactionsCollector\n        = new ExpiredServerTransactionsCollector();", "docstring": "\nThe <tt>ExpiredServerTransactionsCollector</tt> which expires\nthe <tt>StunServerTransaction</tt>s of this <tt>StunStack</tt> and\nremoves them from {@link #serverTransactions}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ExpiredServerTransactionsCollector", "name": "expiredTransactionsCollector\n        = new ExpiredServerTransactionsCollector()", "syntax_pass": true}, {"attribute_expression": "private final Hashtable<TransactionID, StunServerTransaction>\n        serverTransactions\n            = new Hashtable<>();", "docstring": "\nCurrently open server transactions. The vector contains transaction ids\nfor transactions corresponding to all non-answered received requests.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Hashtable<TransactionID, StunServerTransaction>", "name": "serverTransactions\n            = new Hashtable<>()", "syntax_pass": true}, {"attribute_expression": "private final EventDispatcher eventDispatcher = new EventDispatcher();", "docstring": "\nA dispatcher for incoming requests event;\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "EventDispatcher", "name": "eventDispatcher = new EventDispatcher()", "syntax_pass": true}, {"attribute_expression": "private static PacketLogger packetLogger;", "docstring": "\nThe packet logger instance.\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "PacketLogger", "name": "packetLogger", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction", "name": "StunServerTransaction", "file_path": "src/main/java/org/ice4j/stack/StunServerTransaction.java", "superclasses": "", "methods": ["[]StunServerTransaction(StunStack,TransactionID,TransportAddress,TransportAddress)", "[void]start()", "[void]sendResponse(Response,TransportAddress,TransportAddress)", "[void]retransmitResponse()", "[void]expire()", "[boolean]isExpired()", "[boolean]isExpired(long)", "[TransactionID]getTransactionID()", "[boolean]isRetransmitting()", "[TransportAddress]getSendingAddress()", "[TransportAddress]getResponseDestinationAddress()", "[TransportAddress]getLocalListeningAddress()", "[TransportAddress]getRequestSourceAddress()", "[Response]getResponse()"], "method_uris": ["src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[]StunServerTransaction(StunStack,TransactionID,TransportAddress,TransportAddress)", "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[void]start()", "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[void]sendResponse(Response,TransportAddress,TransportAddress)", "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[void]retransmitResponse()", "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[void]expire()", "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[boolean]isExpired()", "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[boolean]isExpired(long)", "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[TransactionID]getTransactionID()", "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[boolean]isRetransmitting()", "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[TransportAddress]getSendingAddress()", "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[TransportAddress]getResponseDestinationAddress()", "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[TransportAddress]getLocalListeningAddress()", "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[TransportAddress]getRequestSourceAddress()", "src/main/java/org/ice4j/stack/StunServerTransaction.java.StunServerTransaction.[Response]getResponse()"], "overrides": null, "attributes": [], "class_docstring": "\nA STUN client retransmits requests as specified by the protocol.\n\nOnce formulated and sent, the client sends the Binding Request.  Reliability\nis accomplished through request retransmissions.  The ClientTransaction\nretransmits the request starting with an interval of 100ms, doubling\nevery retransmit until the interval reaches 1.6s.  Retransmissions\ncontinue with intervals of 1.6s until a response is received, or a\ntotal of 9 requests have been sent. If no response is received by 1.6\nseconds after the last request has been sent, the client SHOULD\nconsider the transaction to have failed. In other words, requests\nwould be sent at times 0ms, 100ms, 300ms, 700ms, 1500ms, 3100ms,\n4700ms, 6300ms, and 7900ms. At 9500ms, the client considers the\ntransaction to have failed if no response has been received.\n\nA server transaction is therefore responsible for retransmitting the same\nresponse that was saved for the original request, and not let any\nretransmissions go through to the user application.\n\n@author Emil Ivov\n", "original_string": "public class StunServerTransaction\n{\n    /**\n     * The time that we keep server transactions active.\n     */\n    static final long LIFETIME = 16000;\n\n    /**\n     * The <tt>StunStack</tt> that created us.\n     */\n    private final StunStack stackCallback;\n\n    /**\n     * The address that we are sending responses to.\n     */\n    private TransportAddress responseDestination = null;\n\n    /**\n     * The address that we are receiving requests from.\n     */\n    private final TransportAddress requestSource;\n\n    /**\n     * The response sent in response to the request.\n     */\n    private Response response = null;\n\n    /**\n     * The <tt>TransportAddress</tt> that we received our request on.\n     */\n    private final TransportAddress localListeningAddress;\n\n    /**\n     * The <tt>TransportAddress</tt> we use when sending responses\n     */\n    private TransportAddress localSendingAddress = null;\n\n    /**\n     * The id of the transaction.\n     */\n    private final TransactionID transactionID;\n\n    /**\n     * The time in milliseconds when the next retransmission should follow.\n     */\n    private long expirationTime = -1;\n\n    /**\n     * Determines whether or not the transaction has expired.\n     */\n    private boolean expired = true;\n\n    /**\n     * Determines whether or not the transaction is in a retransmitting state.\n     * In other words whether a response has already been sent once to the\n     * transaction request.\n     */\n    private boolean isRetransmitting = false;\n\n    /**\n     * Creates a server transaction\n     * @param stackCallback the stack that created us.\n     * @param tranID the transaction id contained by the request that was the\n     * cause for this transaction.\n     * @param localListeningAddress the <tt>TransportAddress</tt> that this\n     * transaction is receiving requests on.\n     * @param requestSource the <tt>TransportAddress</tt> that this\n     * transaction is receiving requests from.\n     */\n    public StunServerTransaction(StunStack        stackCallback,\n                                 TransactionID    tranID,\n                                 TransportAddress localListeningAddress,\n                                 TransportAddress requestSource)\n    {\n        this.stackCallback  = stackCallback;\n        this.transactionID  = tranID;\n        this.localListeningAddress = localListeningAddress;\n        this.requestSource = requestSource;\n    }\n\n    /**\n     * Start the transaction. This launches the countdown to the moment the\n     * transaction would expire.\n     */\n    public synchronized void start()\n    {\n        if (expirationTime == -1)\n        {\n            expired = false;\n            expirationTime = LIFETIME + System.currentTimeMillis();\n        }\n        else\n        {\n            throw new IllegalStateException(\n                    \"StunServerTransaction \" + getTransactionID()\n                        + \" has already been started!\");\n        }\n    }\n\n    /**\n     * Sends the specified response through the <code>sendThrough</code>\n     * NetAccessPoint descriptor to the specified destination and changes\n     * the transaction's state to retransmitting.\n     *\n     * @param response the response to send the transaction to.\n     * @param sendThrough the local address through which responses are to\n     * be sent\n     * @param sendTo the destination for responses of this transaction.\n     *\n     * @throws IOException  if an error occurs while sending message bytes\n     * through the network socket.\n     * @throws IllegalArgumentException if the apDescriptor references an\n     * access point that had not been installed,\n     * @throws StunException if message encoding fails,\n     */\n    public void sendResponse(Response         response,\n                             TransportAddress sendThrough,\n                             TransportAddress sendTo)\n        throws StunException,\n               IOException,\n               IllegalArgumentException\n    {\n        if (!isRetransmitting)\n        {\n            this.response = response;\n            //the transaction id might already have been set, but its our job\n            //to make sure of that\n            response.setTransactionID(this.transactionID.getBytes());\n            this.localSendingAddress   = sendThrough;\n            this.responseDestination   = sendTo;\n        }\n\n        isRetransmitting = true;\n        retransmitResponse();\n    }\n\n    /**\n     * Retransmits the response that was originally sent to the request that\n     * caused this transaction.\n     *\n     * @throws IOException  if an error occurs while sending message bytes\n     * through the network socket.\n     * @throws IllegalArgumentException if the apDescriptor references an\n     * access point that had not been installed,\n     * @throws StunException if message encoding fails,\n     */\n    protected void retransmitResponse()\n        throws StunException,\n               IOException,\n               IllegalArgumentException\n    {\n        //don't retransmit if we are expired or if the user application\n        //hasn't yet transmitted a first response\n        if (isExpired() || !isRetransmitting)\n            return;\n\n        stackCallback.getNetAccessManager().sendMessage(\n                response,\n                localSendingAddress,\n                responseDestination);\n    }\n\n    /**\n     * Cancels the transaction. Once this method is called the transaction is\n     * considered terminated and will stop retransmissions.\n     */\n    public synchronized void expire()\n    {\n        expired = true;\n        /*\n         * StunStack has a background Thread running with the purpose of\n         * removing expired StunServerTransactions.\n         */\n    }\n\n    /**\n     * Determines whether this <tt>StunServerTransaction</tt> is expired now.\n     *\n     * @return <tt>true</tt> if this <tt>StunServerTransaction</tT> is expired\n     * now; otherwise, <tt>false</tt>\n     */\n    public boolean isExpired()\n    {\n        return isExpired(System.currentTimeMillis());\n    }\n\n    /**\n     * Determines whether this <tt>StunServerTransaction</tt> will be expired at\n     * a specific point in time.\n     *\n     * @param now the time in milliseconds at which the <tt>expired</tt> state\n     * of this <tt>StunServerTransaction</tt> is to be returned\n     * @return <tt>true</tt> if this <tt>StunServerTransaction</tt> will be\n     * expired at the specified point in time; otherwise, <tt>false</tt>\n     */\n    public synchronized boolean isExpired(long now)\n    {\n        if (expirationTime == -1)\n            return false;\n        else if (expirationTime < now)\n            return true;\n        else\n            return expired;\n    }\n\n    /**\n     * Returns the ID of the current transaction.\n     *\n     * @return the ID of the transaction.\n     */\n    public TransactionID getTransactionID()\n    {\n        return transactionID;\n    }\n\n    /**\n     * Specifies whether this server transaction is in the retransmitting state.\n     * Or in other words - has it already sent a first response or not?\n     *\n     * @return <tt>true</tt> if this transaction is still retransmitting and\n     * false <tt>otherwise</tt>\n     */\n    public boolean isRetransmitting()\n    {\n        return isRetransmitting;\n    }\n\n    /**\n     * Returns the local <tt>TransportAddress</tt> that this transaction is\n     * sending responses from.\n     *\n     * @return the local <tt>TransportAddress</tt> that this transaction is\n     * sending responses from.\n     */\n    public TransportAddress getSendingAddress()\n    {\n        return localSendingAddress;\n    }\n\n    /**\n     * Returns the remote <tt>TransportAddress</tt> that this transaction is\n     * receiving requests from.\n     *\n     * @return the remote <tt>TransportAddress</tt> that this transaction is\n     * receiving requests from.\n     */\n    public TransportAddress getResponseDestinationAddress()\n    {\n        return responseDestination;\n    }\n\n    /**\n     * Returns the local <tt>TransportAddress</tt> that this transaction is\n     * receiving requests on.\n     *\n     * @return the local <tt>TransportAddress</tt> that this transaction is\n     * receiving requests on.\n     */\n    public TransportAddress getLocalListeningAddress()\n    {\n        return localListeningAddress;\n    }\n\n    /**\n     * Returns the remote <tt>TransportAddress</tt> that this transaction is\n     * receiving requests from.\n     *\n     * @return the remote <tt>TransportAddress</tt> that this transaction is\n     * receiving requests from.\n     */\n    public TransportAddress getRequestSourceAddress()\n    {\n        return requestSource;\n    }\n\n    /**\n     * Returns the <tt>Response</tt> that the <tt>StunStack</tt> has sent\n     * through this transaction or <tt>null</tt> if no <tt>Response</tt> has\n     * been sent yet.\n     *\n     * @return the <tt>Response</tt> that the <tt>StunStack</tt> has sent\n     * through this transaction or <tt>null</tt> if no <tt>Response</tt> has\n     * been sent yet.\n     */\n    protected Response getResponse()\n    {\n        return response;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final long LIFETIME = 16000;", "docstring": "\nThe time that we keep server transactions active.\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long", "name": "LIFETIME = 16000", "syntax_pass": true}, {"attribute_expression": "private final StunStack stackCallback;", "docstring": "\nThe <tt>StunStack</tt> that created us.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StunStack", "name": "stackCallback", "syntax_pass": true}, {"attribute_expression": "private TransportAddress responseDestination = null;", "docstring": "\nThe address that we are sending responses to.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransportAddress", "name": "responseDestination = null", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress requestSource;", "docstring": "\nThe address that we are receiving requests from.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "requestSource", "syntax_pass": true}, {"attribute_expression": "private Response response = null;", "docstring": "\nThe response sent in response to the request.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Response", "name": "response = null", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress localListeningAddress;", "docstring": "\nThe <tt>TransportAddress</tt> that we received our request on.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "localListeningAddress", "syntax_pass": true}, {"attribute_expression": "private TransportAddress localSendingAddress = null;", "docstring": "\nThe <tt>TransportAddress</tt> we use when sending responses\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransportAddress", "name": "localSendingAddress = null", "syntax_pass": true}, {"attribute_expression": "private final TransactionID transactionID;", "docstring": "\nThe id of the transaction.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransactionID", "name": "transactionID", "syntax_pass": true}, {"attribute_expression": "private long expirationTime = -1;", "docstring": "\nThe time in milliseconds when the next retransmission should follow.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "expirationTime = -1", "syntax_pass": true}, {"attribute_expression": "private boolean expired = true;", "docstring": "\nDetermines whether or not the transaction has expired.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "expired = true", "syntax_pass": true}, {"attribute_expression": "private boolean isRetransmitting = false;", "docstring": "\nDetermines whether or not the transaction is in a retransmitting state.\nIn other words whether a response has already been sent once to the\ntransaction request.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "isRetransmitting = false", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/stack/Connector.java.Connector", "name": "Connector", "file_path": "src/main/java/org/ice4j/stack/Connector.java", "superclasses": "", "methods": ["[]Connector(IceSocketWrapper,TransportAddress,Consumer<RawMessage>,ErrorHandler)", "[void]start()", "[IceSocketWrapper]getSocket()", "[void]run()", "[void]stop()", "[void]sendMessage(byte[],TransportAddress)", "[String]toString()", "[TransportAddress]getListenAddress()", "[TransportAddress]getRemoteAddress()"], "method_uris": ["src/main/java/org/ice4j/stack/Connector.java.Connector.[]Connector(IceSocketWrapper,TransportAddress,Consumer<RawMessage>,ErrorHandler)", "src/main/java/org/ice4j/stack/Connector.java.Connector.[void]start()", "src/main/java/org/ice4j/stack/Connector.java.Connector.[IceSocketWrapper]getSocket()", "src/main/java/org/ice4j/stack/Connector.java.Connector.[void]run()", "src/main/java/org/ice4j/stack/Connector.java.Connector.[void]stop()", "src/main/java/org/ice4j/stack/Connector.java.Connector.[void]sendMessage(byte[],TransportAddress)", "src/main/java/org/ice4j/stack/Connector.java.Connector.[String]toString()", "src/main/java/org/ice4j/stack/Connector.java.Connector.[TransportAddress]getListenAddress()", "src/main/java/org/ice4j/stack/Connector.java.Connector.[TransportAddress]getRemoteAddress()"], "overrides": null, "attributes": [], "class_docstring": "\nThe Network Access Point is the most outward part of the stack. It is\nconstructed around a datagram socket and takes care of forwarding incoming\nmessages to the provided {@link #messageConsumer} as well as sending\ndatagrams to the STUN server specified by the\noriginal NetAccessPointDescriptor.\n\n@author Emil Ivov\n", "original_string": "class Connector\n    implements Runnable\n{\n    /**\n     * Our class logger.\n     */\n    private static final Logger logger\n        = Logger.getLogger(Connector.class.getName());\n\n    /**\n     * The consumer of incoming <tt>RawMessage</tt>s\n     */\n    private final Consumer<RawMessage> messageConsumer;\n\n    /**\n     * The socket object that used by this access point to access the network.\n     */\n    private IceSocketWrapper sock;\n\n    /**\n     * The object that we use to lock socket operations (since the socket itself\n     * is often null)\n     */\n    private final Object sockLock = new Object();\n\n    /**\n     * A flag that is set to false to exit the message processor.\n     */\n    private boolean running;\n\n    /**\n     * The instance to be notified if errors occur in the network listening\n     * thread.\n     */\n    private final ErrorHandler errorHandler;\n\n    /**\n     * The address that we are listening to.\n     */\n    private final TransportAddress listenAddress;\n\n    /**\n     * The remote address of the socket of this <tt>Connector</tt> if it is\n     * a TCP socket, or <tt>null</tt> if it is UDP.\n     */\n    private final TransportAddress remoteAddress;\n\n    /**\n     * Creates a network access point.\n     * @param socket the socket that this access point is supposed to use for\n     * communication.\n     * @param remoteAddress the remote address of the socket of this\n     * {@link Connector} if it is a TCP socket, or null if it is UDP.\n     * @param messageConsumer the incoming messages consumer\n     * @param errorHandler the instance to notify when errors occur.\n     */\n    protected Connector(IceSocketWrapper socket,\n                        TransportAddress remoteAddress,\n                        Consumer<RawMessage> messageConsumer,\n                        ErrorHandler   errorHandler)\n    {\n        this.sock = socket;\n        this.messageConsumer = messageConsumer;\n        this.errorHandler = errorHandler;\n        this.remoteAddress = remoteAddress;\n\n        Transport transport\n            = socket.getUDPSocket() != null ? Transport.UDP : Transport.TCP;\n\n        listenAddress\n            = new TransportAddress(socket.getLocalAddress(),\n                                   socket.getLocalPort(),\n                                   transport);\n    }\n\n    /**\n     * Start the network listening thread.\n     */\n    void start()\n    {\n        this.running = true;\n\n        Thread thread = new Thread(this, \"IceConnector@\" + hashCode());\n\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    /**\n     * Returns the <tt>DatagramSocket</tt> that contains the port and address\n     * associated with this access point.\n     *\n     * @return the <tt>DatagramSocket</tt> associated with this AP.\n     */\n    protected IceSocketWrapper getSocket()\n    {\n        return sock;\n    }\n\n    /**\n     * The listening thread's run method.\n     */\n    @Override\n    public void run()\n    {\n        DatagramPacket packet = null;\n\n        while (this.running)\n        {\n            try\n            {\n                IceSocketWrapper localSock;\n\n                synchronized (sockLock)\n                {\n                    if (!running)\n                        return;\n\n                    localSock = this.sock;\n                }\n\n                /*\n                 * Make sure localSock's receiveBufferSize is taken into\n                 * account including after it gets changed.\n                 */\n                int receiveBufferSize = 1500;\n                /*\n                if(localSock.getTCPSocket() != null)\n                {\n                    receiveBufferSize = localSock.getTCPSocket().\n                        getReceiveBufferSize();\n                }\n                else if(localSock.getUDPSocket() != null)\n                {\n                    receiveBufferSize = localSock.getUDPSocket().\n                        getReceiveBufferSize();\n                }\n                */\n\n                if (packet == null)\n                {\n                    packet\n                        = new DatagramPacket(\n                                new byte[receiveBufferSize],\n                                receiveBufferSize);\n                }\n                else\n                {\n                    byte[] packetData = packet.getData();\n\n                    if ((packetData == null)\n                            || (packetData.length < receiveBufferSize))\n                    {\n                        packet.setData(\n                                new byte[receiveBufferSize],\n                                0,\n                                receiveBufferSize);\n                    }\n                    else\n                    {\n                        /*\n                         * XXX Tell the packet it is large enough because the\n                         * socket will not look at the length of the data array\n                         * property and will just respect the length property.\n                         */\n                        packet.setLength(receiveBufferSize);\n                    }\n                }\n\n                localSock.receive(packet);\n\n                //get lost if we are no longer running.\n                if (!running)\n                    return;\n\n                if (logger.isLoggable(Level.FINEST))\n                {\n                    logger.finest(\"received datagram packet - addr: \"\n                            + packet.getAddress() + \" port: \" + packet.getPort());\n                }\n                if (packet.getPort() < 0)\n                {\n                    logger.warning(\"Out of range packet port, resetting to 0\");\n                    // force a minimum port of 0 to prevent out of range errors\n                    packet.setPort(0);\n                }\n\n                RawMessage rawMessage\n                    = new RawMessage(\n                            packet.getData(),\n                            packet.getLength(),\n                            new TransportAddress(\n                                    packet.getAddress(),\n                                    packet.getPort(),\n                                    listenAddress.getTransport()),\n                            listenAddress);\n\n                messageConsumer.accept(rawMessage);\n            }\n            catch (SocketException ex)\n            {\n                if (running)\n                {\n                    logger.log(\n                            Level.WARNING,\n                            \"Connector died: \" + listenAddress + \" -> \"\n                                    + remoteAddress,\n                            ex);\n\n                    stop();\n                    //Something wrong has happened\n                    errorHandler.handleFatalError(\n                            this,\n                            \"A socket exception was thrown\"\n                                + \" while trying to receive a message.\",\n                            ex);\n                }\n                else\n                {\n                    //The exception was most probably caused by calling\n                    //this.stop().\n                }\n            }\n            catch (ClosedChannelException cce)\n            {\n                // The socket was closed, possibly by the remote peer.\n                // If we were already stopped, just ignore it.\n                if (running)\n                {\n                    // We could be the first thread to realize that the socket\n                    // was closed. But that's normal operation, so don't\n                    // complain too much.\n                    stop();\n                    errorHandler.handleFatalError(\n                        this,\n                        \"The socket was closed:\",\n                        null);\n                }\n            }\n            catch (IOException ex)\n            {\n                logger.log(Level.WARNING,\n                           \"A net access point has gone useless:\", ex);\n\n                errorHandler.handleError(ex.getMessage(), ex);\n                //do not stop the thread;\n            }\n            catch (Throwable ex)\n            {\n                logger.log(Level.WARNING,\n                           \"A net access point has gone useless:\", ex);\n\n                stop();\n                errorHandler.handleFatalError(\n                        this,\n                        \"Unknown error occurred while listening for messages!\",\n                        ex);\n            }\n        }\n    }\n\n    /**\n     * Makes the access point stop listening on its socket.\n     */\n    protected void stop()\n    {\n        synchronized(sockLock)\n        {\n            this.running = false;\n            if (this.sock != null)\n            {\n                this.sock.close();\n                this.sock = null;\n            }\n        }\n    }\n\n    /**\n     * Sends message through this access point's socket.\n     *\n     * @param message the bytes to send.\n     * @param address message destination.\n     *\n     * @throws IOException if an exception occurs while sending the message.\n     */\n    void sendMessage(byte[] message, TransportAddress address)\n        throws IOException\n    {\n        DatagramPacket datagramPacket\n            = new DatagramPacket(message, 0, message.length, address);\n\n        IceSocketWrapper sock = this.sock;\n        if (sock != null)\n        {\n            sock.send(datagramPacket);\n        }\n        else\n        {\n            logger.warning(\"Can not send message, Connector stopped.\");\n        }\n    }\n\n    /**\n     * Returns a String representation of the object.\n     * @return a String representation of the object.\n     */\n    @Override\n    public String toString()\n    {\n        return\n            \"ice4j.Connector@\" + listenAddress\n                + \" status: \" + (running ? \"not\" : \"\") +\" running\";\n     }\n\n     /**\n      * Returns the <tt>TransportAddress</tt> that this access point is bound\n      * on.\n      *\n      * @return the <tt>TransportAddress</tt> associated with this AP.\n      */\n     TransportAddress getListenAddress()\n     {\n         return listenAddress;\n     }\n\n    /**\n     * Returns the remote <tt>TransportAddress</tt> or <tt>null</tt> if none\n     * is specified.\n     *\n     * @return the remote <tt>TransportAddress</tt> or <tt>null</tt> if none\n     * is specified.\n     */\n    TransportAddress getRemoteAddress()\n    {\n        return remoteAddress;\n    }\n}", "super_interfaces": ["Runnable"], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(Connector.class.getName());", "docstring": "\nOur class logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(Connector.class.getName())", "syntax_pass": true}, {"attribute_expression": "private final Consumer<RawMessage> messageConsumer;", "docstring": "\nThe consumer of incoming <tt>RawMessage</tt>s\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Consumer<RawMessage>", "name": "messageConsumer", "syntax_pass": true}, {"attribute_expression": "private IceSocketWrapper sock;", "docstring": "\nThe socket object that used by this access point to access the network.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IceSocketWrapper", "name": "sock", "syntax_pass": true}, {"attribute_expression": "private final Object sockLock = new Object();", "docstring": "\nThe object that we use to lock socket operations (since the socket itself\nis often null)\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "sockLock = new Object()", "syntax_pass": true}, {"attribute_expression": "private boolean running;", "docstring": "\nA flag that is set to false to exit the message processor.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "running", "syntax_pass": true}, {"attribute_expression": "private final ErrorHandler errorHandler;", "docstring": "\nThe instance to be notified if errors occur in the network listening\nthread.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ErrorHandler", "name": "errorHandler", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress listenAddress;", "docstring": "\nThe address that we are listening to.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "listenAddress", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress remoteAddress;", "docstring": "\nThe remote address of the socket of this <tt>Connector</tt> if it is\na TCP socket, or <tt>null</tt> if it is UDP.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "remoteAddress", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID", "name": "TransactionID", "file_path": "src/main/java/org/ice4j/stack/TransactionID.java", "superclasses": "", "methods": ["[]TransactionID()", "[]TransactionID(boolean)", "[TransactionID]createNewTransactionID()", "[TransactionID]createNewRFC3489TransactionID()", "[void]generateTransactionID(TransactionID,int)", "[TransactionID]createTransactionID(StunStack,byte[])", "[byte[]]getBytes()", "[boolean]isRFC3489Compatible()", "[boolean]equals(Object)", "[boolean]equals(byte[])", "[int]hashCode()", "[String]toString()", "[String]toString(byte[])", "[void]setApplicationData(Object)", "[Object]getApplicationData()"], "method_uris": ["src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[]TransactionID()", "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[]TransactionID(boolean)", "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[TransactionID]createNewTransactionID()", "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[TransactionID]createNewRFC3489TransactionID()", "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[void]generateTransactionID(TransactionID,int)", "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[TransactionID]createTransactionID(StunStack,byte[])", "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[byte[]]getBytes()", "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[boolean]isRFC3489Compatible()", "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[boolean]equals(Object)", "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[boolean]equals(byte[])", "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[int]hashCode()", "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[String]toString()", "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[String]toString(byte[])", "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[void]setApplicationData(Object)", "src/main/java/org/ice4j/stack/TransactionID.java.TransactionID.[Object]getApplicationData()"], "overrides": null, "attributes": [], "class_docstring": "\nThis class encapsulates a STUN transaction ID. It is useful for storing\ntransaction IDs in collection objects as it implements the equals method.\nIt also provides a utility for creating unique transaction IDs.\n\n@author Emil Ivov\n", "original_string": "public class TransactionID\n{\n    /**\n     * RFC5289 Transaction ID length.\n     */\n    public static final int RFC5389_TRANSACTION_ID_LENGTH = 12;\n\n    /**\n     * RFC3489 Transaction ID length.\n     */\n    public static final int RFC3489_TRANSACTION_ID_LENGTH = 16;\n\n    /**\n     * The id itself\n     */\n    private final byte[] transactionID;\n\n    /**\n     * Any object that the application would like to correlate to a transaction.\n     */\n    private Object applicationData = null;\n\n    /**\n     * The object to use to generate the rightmost 8 bytes of the id.\n     */\n    private static final Random random\n        = new Random(System.currentTimeMillis());\n\n    /**\n     * A hashcode for hashtable storage.\n     */\n    private int hashCode = 0;\n\n    /**\n     * Limits access to <tt>TransactionID</tt> instantiation.\n     */\n    private TransactionID()\n    {\n        this(false);\n    }\n\n    /**\n     * Limits access to <tt>TransactionID</tt> instantiation.\n     *\n     * @param rfc3489Compatibility true to create a RFC3489 transaction ID\n     */\n    private TransactionID(boolean rfc3489Compatibility)\n    {\n        transactionID\n            = new byte[\n                    rfc3489Compatibility\n                        ? RFC3489_TRANSACTION_ID_LENGTH\n                        : RFC5389_TRANSACTION_ID_LENGTH];\n    }\n\n    /**\n     * Creates a transaction id object.The transaction id itself is generated\n     * using the following algorithm:\n     *\n     * The first 6 bytes of the id are given the value of\n     * <tt>System.currentTimeMillis()</tt>. Putting the right most bits first\n     * so that we get a more optimized equals() method.\n     *\n     * @return A <tt>TransactionID</tt> object with a unique transaction id.\n     */\n    public static TransactionID createNewTransactionID()\n    {\n        TransactionID tid = new TransactionID();\n\n        generateTransactionID(tid, 12);\n        return tid;\n    }\n\n    /**\n     * Creates a RFC3489 transaction id object.The transaction id itself is\n     * generated using the following algorithm:\n     *\n     * The first 8 bytes of the id are given the value of\n     * <tt>System.currentTimeMillis()</tt>. Putting the right most bits first\n     * so that we get a more optimized equals() method.\n     *\n     * @return A <tt>TransactionID</tt> object with a unique transaction id.\n     */\n    public static TransactionID createNewRFC3489TransactionID()\n    {\n        TransactionID tid = new TransactionID(true);\n\n        generateTransactionID(tid, 16);\n        return tid;\n    }\n\n    /**\n     * Generates a random transaction ID\n     *\n     * @param tid transaction ID\n     * @param nb number of bytes to generate\n     */\n    private static void generateTransactionID(TransactionID tid, int nb)\n    {\n        long left  = System.currentTimeMillis(); //the first nb/2 bytes of the id\n        long right = random.nextLong(); //the last nb/2 bytes of the id\n        int b = nb / 2;\n\n        for (int i = 0; i < b; i++)\n        {\n            tid.transactionID[i]   = (byte)((left  >> (i * 8)) & 0xFFL);\n            tid.transactionID[i + b] = (byte)((right >> (i * 8)) & 0xFFL);\n        }\n\n        //calculate hashcode for Hashtable storage.\n        tid.hashCode =   (tid.transactionID[3] << 24 & 0xFF000000)\n                       | (tid.transactionID[2] << 16 & 0x00FF0000)\n                       | (tid.transactionID[1] << 8  & 0x0000FF00)\n                       | (tid.transactionID[0]       & 0x000000FF);\n    }\n\n    /**\n     * Returns a <tt>TransactionID</tt> instance for the specified id. If\n     * <tt>transactionID</tt> is the ID of a client or a server transaction\n     * already known to the stack, then this method would return a reference\n     * to that transaction's instance so that we could use it to for storing\n     * application data.\n     *\n     * @param stunStack the <tt>StunStack</tt> in the context of which the\n     * request to create a <tt>TransactionID</tt> is being made\n     * @param transactionID the value of the ID.\n     *\n     * @return a reference to the (possibly already existing)\n     * <tt>TransactionID</tt> corresponding to the value of\n     * <tt>transactionID</tt>\n     */\n    public static TransactionID createTransactionID(\n            StunStack stunStack,\n            byte[] transactionID)\n    {\n        //first check whether we can find a client or a server tran with the\n        //specified id.\n        StunClientTransaction cliTran\n            = stunStack.getClientTransaction(transactionID);\n\n        if (cliTran != null)\n            return cliTran.getTransactionID();\n\n        StunServerTransaction serTran\n            = stunStack.getServerTransaction(transactionID);\n\n        if (serTran != null)\n            return serTran.getTransactionID();\n\n        //seems that the caller really wants a new ID\n        TransactionID tid = null;\n        tid = new TransactionID((transactionID.length == 16));\n\n        System.arraycopy(transactionID, 0, tid.transactionID, 0,\n                tid.transactionID.length);\n\n        //calculate hashcode for Hashtable storage.\n        tid.hashCode =   (tid.transactionID[3] << 24 & 0xFF000000)\n                       | (tid.transactionID[2] << 16 & 0x00FF0000)\n                       | (tid.transactionID[1] << 8  & 0x0000FF00)\n                       | (tid.transactionID[0]       & 0x000000FF);\n\n        return tid;\n    }\n\n    /**\n     * Returns the transaction id byte array (length 12 or 16 if RFC3489\n     * compatible).\n     *\n     * @return the transaction ID byte array.\n     */\n    public byte[] getBytes()\n    {\n        return transactionID;\n    }\n\n    /**\n     * If the transaction is compatible with RFC3489 (16 bytes).\n     *\n     * @return true if transaction ID is compatible with RFC3489\n     */\n    public boolean isRFC3489Compatible()\n    {\n        return (transactionID.length == 16);\n    }\n\n    /**\n     * Compares two TransactionID objects.\n     * @param obj the object to compare with.\n     * @return true if the objects are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (this == obj)\n            return true;\n        if (!(obj instanceof TransactionID))\n            return false;\n\n        byte targetBytes[] = ((TransactionID)obj).transactionID;\n\n        return Arrays.equals(transactionID, targetBytes);\n    }\n\n    /**\n     * Compares the specified byte array with this transaction id.\n     * @param targetID the id to compare with ours.\n     * @return true if targetID matches this transaction id.\n     */\n    public boolean equals(byte[] targetID)\n    {\n        return Arrays.equals(transactionID, targetID);\n    }\n\n    /**\n     * Returns the first four bytes of the transactionID to ensure proper\n     * retrieval from hashtables.\n     * @return the hashcode of this object - as advised by the Java Platform\n     * Specification\n     */\n    public int hashCode()\n    {\n        return hashCode;\n    }\n\n    /**\n     * Returns a string representation of the ID\n     *\n     * @return a hex string representing the id\n     */\n    public String toString()\n    {\n        return TransactionID.toString(transactionID);\n    }\n\n    /**\n     * Returns a string representation of the ID\n     *\n     * @param transactionID the transaction ID to convert into <tt>String</tt>.\n     *\n     * @return a hex string representing the id\n     */\n    public static String toString(byte[] transactionID)\n    {\n        StringBuilder idStr = new StringBuilder();\n\n        idStr.append(\"0x\");\n        for (int i = 0; i < transactionID.length; i++)\n        {\n\n            if ((transactionID[i] & 0xFF) <= 15)\n                idStr.append(\"0\");\n\n            idStr.append(\n                    Integer.toHexString(transactionID[i] & 0xFF).toUpperCase());\n        }\n\n        return idStr.toString();\n    }\n\n    /**\n     * Stores <tt>applicationData</tt> in this ID so that we can refer back to\n     * it if we ever need to at a later stage (e.g. when receiving a response\n     * to a {@link StunClientTransaction}).\n     *\n     * @param applicationData a reference to the {@link Object} that the\n     * application would like to correlate to the transaction represented by\n     * this ID.\n     */\n    public void setApplicationData(Object applicationData)\n    {\n        this.applicationData = applicationData;\n    }\n\n    /**\n     * Returns whatever <tt>applicationData</tt> was previously stored in this\n     * ID.\n     *\n     * @return a reference to the {@link Object} that the application may have\n     * stored in this ID's application data field.\n     */\n    public Object getApplicationData()\n    {\n        return applicationData;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final int RFC5389_TRANSACTION_ID_LENGTH = 12;", "docstring": "\nRFC5289 Transaction ID length.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "RFC5389_TRANSACTION_ID_LENGTH = 12", "syntax_pass": true}, {"attribute_expression": "public static final int RFC3489_TRANSACTION_ID_LENGTH = 16;", "docstring": "\nRFC3489 Transaction ID length.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "RFC3489_TRANSACTION_ID_LENGTH = 16", "syntax_pass": true}, {"attribute_expression": "private final byte[] transactionID;", "docstring": "\nThe id itself\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "byte[]", "name": "transactionID", "syntax_pass": true}, {"attribute_expression": "private Object applicationData = null;", "docstring": "\nAny object that the application would like to correlate to a transaction.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Object", "name": "applicationData = null", "syntax_pass": true}, {"attribute_expression": "private static final Random random\n        = new Random(System.currentTimeMillis());", "docstring": "\nThe object to use to generate the rightmost 8 bytes of the id.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Random", "name": "random\n        = new Random(System.currentTimeMillis())", "syntax_pass": true}, {"attribute_expression": "private int hashCode = 0;", "docstring": "\nA hashcode for hashtable storage.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "hashCode = 0", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/DestinationAddressAttribute.java.DestinationAddressAttribute", "name": "DestinationAddressAttribute", "file_path": "src/main/java/org/ice4j/attribute/DestinationAddressAttribute.java", "superclasses": "AddressAttribute", "methods": ["[]DestinationAddressAttribute()"], "method_uris": ["src/main/java/org/ice4j/attribute/DestinationAddressAttribute.java.DestinationAddressAttribute.[]DestinationAddressAttribute()"], "overrides": null, "attributes": [], "class_docstring": "\nThe DESTINATION-ADDRESS is present in Send Requests of old TURN versions.\nIt specifies the address and port where the data is to be sent. It is encoded\nin the same way as MAPPED-ADDRESS.\n\n@author Sebastien Vincent\n", "original_string": "public class DestinationAddressAttribute extends AddressAttribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"DESTINATION-ADDRESS\";\n\n    /**\n     * Constructor.\n     */\n    DestinationAddressAttribute()\n    {\n        super(DESTINATION_ADDRESS);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"DESTINATION-ADDRESS\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"DESTINATION-ADDRESS\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/XorRelayedAddressAttribute.java.XorRelayedAddressAttribute", "name": "XorRelayedAddressAttribute", "file_path": "src/main/java/org/ice4j/attribute/XorRelayedAddressAttribute.java", "superclasses": "XorMappedAddressAttribute", "methods": ["[]XorRelayedAddressAttribute()"], "method_uris": ["src/main/java/org/ice4j/attribute/XorRelayedAddressAttribute.java.XorRelayedAddressAttribute.[]XorRelayedAddressAttribute()"], "overrides": null, "attributes": [], "class_docstring": "\nThe XOR-RELAYED-ADDRESS attribute is given by a TURN server to\nindicates the client its relayed address.\n\nIt has the same format as XOR-MAPPED-ADDRESS.\n\n@author Sebastien Vincent\n", "original_string": "public class XorRelayedAddressAttribute extends XorMappedAddressAttribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"XOR-RELAYED-ADDRESS\";\n\n    /**\n     * Constructor.\n     */\n    XorRelayedAddressAttribute()\n    {\n        super(XOR_RELAYED_ADDRESS);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"XOR-RELAYED-ADDRESS\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"XOR-RELAYED-ADDRESS\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute", "name": "MessageIntegrityAttribute", "file_path": "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java", "superclasses": "Attribute", "methods": ["[]MessageIntegrityAttribute()", "[void]setUsername(String)", "[void]setMedia(String)", "[byte[]]getHmacSha1Content()", "[byte[]]calculateHmacSha1(byte[],int,int,byte[])", "[void]decodeAttributeBody(byte[],char,char)", "[byte[]]encode()", "[byte[]]encode(StunStack,byte[],int,int)", "[char]getDataLength()", "[String]getName()", "[boolean]equals(Object)"], "method_uris": ["src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[]MessageIntegrityAttribute()", "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[void]setUsername(String)", "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[void]setMedia(String)", "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[byte[]]getHmacSha1Content()", "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[byte[]]calculateHmacSha1(byte[],int,int,byte[])", "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[byte[]]encode(StunStack,byte[],int,int)", "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/MessageIntegrityAttribute.java.MessageIntegrityAttribute.[boolean]equals(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nThe MESSAGE-INTEGRITY attribute contains an HMAC-SHA1 [RFC2104] of\nthe STUN message.  The MESSAGE-INTEGRITY attribute can be present in\nany STUN message type.  Since it uses the SHA1 hash, the HMAC will be\n20 bytes.  The text used as input to HMAC is the STUN message,\nincluding the header, up to and including the attribute preceding the\nMESSAGE-INTEGRITY attribute.  With the exception of the FINGERPRINT\nattribute, which appears after MESSAGE-INTEGRITY, agents MUST ignore\nall other attributes that follow MESSAGE-INTEGRITY.\nThe key for the HMAC depends on whether long-term or short-term\ncredentials are in use.  For long-term credentials, the key is 16\nbytes:\n<pre>\n         key = MD5(username \":\" realm \":\" SASLprep(password))\n</pre>\nThat is, the 16-byte key is formed by taking the MD5 hash of the\nresult of concatenating the following five fields: (1) the username,\nwith any quotes and trailing nulls removed, as taken from the\nUSERNAME attribute (in which case SASLprep has already been applied);\n(2) a single colon; (3) the realm, with any quotes and trailing nulls\nremoved; (4) a single colon; and (5) the password, with any trailing\nnulls removed and after processing using SASLprep.  For example, if\nthe username was 'user', the realm was 'realm', and the password was\n'pass', then the 16-byte HMAC key would be the result of performing\nan MD5 hash on the string 'user:realm:pass', the resulting hash being\n0x8493fbc53ba582fb4c044c456bdc40eb.\n<p>\nFor short-term credentials:\n<pre>\n                       key = SASLprep(password)\n</pre>\nwhere MD5 is defined in RFC 1321 [RFC1321] and SASLprep() is defined\nin RFC 4013 [RFC4013].\n<p>\nThe structure of the key when used with long-term credentials\nfacilitates deployment in systems that also utilize SIP.  Typically,\nSIP systems utilizing SIP's digest authentication mechanism do not\nactually store the password in the database.  Rather, they store a\nvalue called H(A1), which is equal to the key defined above.\n<p>\nBased on the rules above, the hash used to construct MESSAGE-\nINTEGRITY includes the length field from the STUN message header.\nPrior to performing the hash, the MESSAGE-INTEGRITY attribute MUST be\ninserted into the message (with dummy content).  The length MUST then\nbe set to point to the length of the message up to, and including,\nthe MESSAGE-INTEGRITY attribute itself, but excluding any attributes\nafter it.  Once the computation is performed, the value of the\nMESSAGE-INTEGRITY attribute can be filled in, and the value of the\nlength in the STUN header can be set to its correct value -- the\nlength of the entire message.  Similarly, when validating the\nMESSAGE-INTEGRITY, the length field should be adjusted to point to\nthe end of the MESSAGE-INTEGRITY attribute prior to calculating the\nHMAC.  Such adjustment is necessary when attributes, such as\nFINGERPRINT, appear after MESSAGE-INTEGRITY.\n\n@author Emil Ivov\n", "original_string": "public class MessageIntegrityAttribute\n    extends Attribute\n    implements ContentDependentAttribute\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>Message</tt> class and its instances\n     * for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(MessageIntegrityAttribute.class.getName());\n\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"MESSAGE_INTEGRITY\";\n\n    /**\n     * The HMAC-SHA1 algorithm.\n     */\n    public static final String HMAC_SHA1_ALGORITHM = \"HmacSHA1\";\n\n    /**\n     * The HMAC-SHA1 algorithm.\n     */\n    public static final char DATA_LENGTH = (char)20;\n\n    /**\n     * The actual content of the message\n     */\n    private byte[] hmacSha1Content;\n\n    /**\n     * The username that we should use to obtain an encryption\n     * key (password) that the {@link #encode()} method should use when\n     * creating the content of this message.\n     */\n    private String username;\n\n    /**\n     * The media name if we use short-term authentication.\n     */\n    private String media;\n\n    /**\n     * Creates a <tt>MessageIntegrityAttribute</tt>.\n     */\n    protected MessageIntegrityAttribute()\n    {\n        super(MESSAGE_INTEGRITY);\n    }\n\n    /**\n     * Sets the username that we should use to obtain an encryption\n     * key (password) that the {@link #encode()} method should use when\n     * creating the content of this message.\n     *\n     * @param username the username that we should use to obtain an encryption\n     * key (password) that the {@link #encode()} method should use when\n     * creating the content of this message.\n     */\n    public void setUsername(String username)\n    {\n        this.username = username;\n    }\n\n    /**\n     * Sets the media name that we should use to get the corresponding remote\n     * key (short-term authentication only).\n     *\n     * @param media name\n     */\n    public void setMedia(String media)\n    {\n        this.media = media;\n    }\n\n    /**\n     * Returns the HMAC-SHA1 value stored in this attribute.\n     *\n     * @return the HMAC-SHA1 value stored in this attribute.\n     */\n    public byte[] getHmacSha1Content()\n    {\n        return hmacSha1Content;\n    }\n\n    /**\n     * Encodes <tt>message</tt> using <tt>key</tt> and the HMAC-SHA1 algorithm\n     * as per RFC 2104 and returns the resulting byte array. This is a utility\n     * method that generates content for the {@link MessageIntegrityAttribute}\n     * regardless of the credentials being used (short or long term).\n     *\n     * @param message the STUN message that the resulting content will need to\n     * travel in.\n     * @param offset the index where data starts in <tt>message</tt>.\n     * @param length the length of the data in <tt>message</tt> that the method\n     * should consider.\n     * @param key the key that we should be using for the encoding (which\n     * depends on whether we are using short or long term credentials).\n     *\n     * @return the HMAC that should be used in a\n     * <tt>MessageIntegrityAttribute</tt> transported by <tt>message</tt>.\n     *\n     * @throws IllegalArgumentException if the encoding fails for some reason.\n     */\n    public static byte[] calculateHmacSha1(byte[] message,\n                                           int    offset,\n                                           int    length,\n                                           byte[] key)\n        throws IllegalArgumentException\n    {\n        byte[] hmac;\n\n        try\n        {\n            // get an HMAC-SHA1 key from the raw key bytes\n            SecretKeySpec signingKey\n                = new SecretKeySpec(key, HMAC_SHA1_ALGORITHM);\n            // get an HMAC-SHA1 Mac instance and initialize it with the key\n            Mac mac = Mac.getInstance(HMAC_SHA1_ALGORITHM);\n\n            mac.init(signingKey);\n\n            // compute the hmac on input data bytes\n            byte[] macInput = new byte[length];\n\n            //doFinal seems incapable to only work with a part of an array\n            //so we'd need to create an array that only contains what we\n            //actually need to work with.\n            System.arraycopy(message, offset, macInput, 0, length);\n            hmac = mac.doFinal(macInput);\n        }\n        catch (Exception exc)\n        {\n            throw new IllegalArgumentException(\n                        \"Could not create HMAC-SHA1 request encoding: \", exc);\n        }\n        return hmac;\n    }\n\n    /**\n     * Sets this attribute's fields according to the message and attributeValue\n     * arrays.\n     *\n     * @param attributeValue a binary array containing this attribute's field\n     * values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     * offset is equal to the index of the first byte after length)\n     * @param length the length of the binary array.\n     * the start of this attribute.\n     */\n    public void decodeAttributeBody( byte[] attributeValue,\n                                     char offset,\n                                     char length)\n    {\n        hmacSha1Content = new byte[length];\n        System.arraycopy(attributeValue, offset, hmacSha1Content, 0, length);\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     *\n     * @return nothing\n     * @throws UnsupportedOperationException since {@link\n     * ContentDependentAttribute}s should be encoded through the content\n     * dependent encode method.\n     */\n    public byte[] encode()\n        throws UnsupportedOperationException\n    {\n        throw new UnsupportedOperationException(\n                        \"ContentDependentAttributes should be encoded \"\n                        + \"through the contend-dependent encode method\");\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     *\n     * @param stunStack the <tt>StunStack</tt> in the context of which the\n     * request to encode this <tt>ContentDependentAttribute</tt> is being made\n     * @param content the content of the message that this attribute will be\n     * transported in\n     * @param offset the <tt>content</tt>-related offset where the actual\n     * content starts.\n     * @param length the length of the content in the <tt>content</tt> array.\n     *\n     * @return a binary representation of this attribute valid for the message\n     * with the specified <tt>content</tt>.\n     */\n    public byte[] encode(\n            StunStack stunStack,\n            byte[] content, int offset, int length)\n    {\n        char type = getAttributeType();\n        byte binValue[] = new byte[HEADER_LENGTH + getDataLength()];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        byte[] key = null;\n        char msgType =\n            (char) (((content[0] & 0xFF) << 8) | (content[1] & 0xFF));\n\n        if (Message.isRequestType(msgType))\n        {\n            /* attribute part of a request, use the remote key */\n            key\n                = stunStack.getCredentialsManager()\n                    .getRemoteKey(username, media);\n        }\n        else if (Message.isResponseType(msgType))\n        {\n            /* attribute part of a response, use the local key */\n            key = stunStack.getCredentialsManager().getLocalKey(username);\n        }\n        else // msgType is Indication\n        {\n            logger.warning(\"Can not encode a message of type Indication.\");\n        }\n\n        Objects.requireNonNull(key, \"key=null; msgType=\" + String.format(\"%04X\", (int)msgType));\n        //now calculate the HMAC-SHA1\n        this.hmacSha1Content = calculateHmacSha1(content, offset, length, key);\n\n        //username\n        System.arraycopy(hmacSha1Content, 0, binValue, HEADER_LENGTH, getDataLength());\n\n        return binValue;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     *\n     * @return the length of this attribute's value.\n     */\n    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }\n\n    /**\n     * Returns the human readable name of this attribute.\n     *\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Compares two <tt>MessageIntegrityAttribute</tt>s. Two attributes are\n     * considered equal when they have the same type length and value.\n     *\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof MessageIntegrityAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        MessageIntegrityAttribute att = (MessageIntegrityAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                || !Arrays.equals( att.hmacSha1Content, hmacSha1Content))\n            return false;\n\n        return true;\n    }\n}", "super_interfaces": ["ContentDependentAttribute"], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(MessageIntegrityAttribute.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>Message</tt> class and its instances\nfor logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(MessageIntegrityAttribute.class.getName())", "syntax_pass": true}, {"attribute_expression": "public static final String NAME = \"MESSAGE_INTEGRITY\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"MESSAGE_INTEGRITY\"", "syntax_pass": true}, {"attribute_expression": "public static final String HMAC_SHA1_ALGORITHM = \"HmacSHA1\";", "docstring": "\nThe HMAC-SHA1 algorithm.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "HMAC_SHA1_ALGORITHM = \"HmacSHA1\"", "syntax_pass": true}, {"attribute_expression": "public static final char DATA_LENGTH = (char)20;", "docstring": "\nThe HMAC-SHA1 algorithm.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "DATA_LENGTH = (char)20", "syntax_pass": true}, {"attribute_expression": "private byte[] hmacSha1Content;", "docstring": "\nThe actual content of the message\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte[]", "name": "hmacSha1Content", "syntax_pass": true}, {"attribute_expression": "private String username;", "docstring": "\nThe username that we should use to obtain an encryption\nkey (password) that the {@link #encode()} method should use when\ncreating the content of this message.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "username", "syntax_pass": true}, {"attribute_expression": "private String media;", "docstring": "\nThe media name if we use short-term authentication.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "media", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute", "name": "UnknownAttributesAttribute", "file_path": "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java", "superclasses": "Attribute", "methods": ["[]UnknownAttributesAttribute()", "[String]getName()", "[char]getDataLength()", "[void]addAttributeID(char)", "[boolean]contains(char)", "[Iterator<Character>]getAttributes()", "[int]getAttributeCount()", "[char]getAttribute(int)", "[byte[]]encode()", "[boolean]equals(Object)", "[void]decodeAttributeBody(byte[],char,char)"], "method_uris": ["src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[]UnknownAttributesAttribute()", "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[void]addAttributeID(char)", "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[boolean]contains(char)", "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[Iterator<Character>]getAttributes()", "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[int]getAttributeCount()", "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[char]getAttribute(int)", "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/UnknownAttributesAttribute.java.UnknownAttributesAttribute.[void]decodeAttributeBody(byte[],char,char)"], "overrides": null, "attributes": [], "class_docstring": "\nThe UNKNOWN-ATTRIBUTES attribute is present only in a Binding Error\nResponse or Shared Secret Error Response when the response code in\nthe ERROR-CODE attribute is 420.\n\nThe attribute contains a list of 16 bit values, each of which\nrepresents an attribute type that was not understood by the server.\nIf the number of unknown attributes is an odd number, one of the\nattributes MUST be repeated in the list, so that the total length of\nthe list is a multiple of 4 bytes.\n\n0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Attribute 1 Type           |     Attribute 2 Type        |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|      Attribute 3 Type           |     Attribute 4 Type    ...\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n@author Emil Ivov\n", "original_string": "public class UnknownAttributesAttribute extends Attribute\n{\n    /**\n     * Attribute name.\n     */\n    public static String NAME = \"UNKNOWN-ATTRIBUTES\";\n\n    /**\n     * A list of attribute types that were not understood by the server.\n     */\n    private ArrayList<Character> unknownAttributes = new ArrayList<>();\n\n    /**\n     * Constructor.\n     */\n    UnknownAttributesAttribute()\n    {\n        super(UNKNOWN_ATTRIBUTES);\n    }\n\n    /**\n     * Returns the human readable name of this attribute. Attribute names do\n     * not really matter from the protocol point of view. They are only used\n     * for debugging and readability.\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return NAME;\n    }\n\n   /**\n    * Returns the length (in bytes) of this attribute's body.\n    * If the number of unknown attributes is an odd number, one of the\n    * attributes MUST be repeated in the list, so that the total length of\n    * the list is a multiple of 4 bytes.\n    * @return the length of this attribute's value (a multiple of 4).\n    */\n    public char getDataLength()\n    {\n        char len = (char)unknownAttributes.size();\n\n        if ( (len % 2 ) != 0 )\n            len++;\n\n        return (char)(len * 2);\n    }\n\n    /**\n     * Adds the specified attribute type to the list of unknown attributes.\n     * @param attributeID the id of an attribute to be listed as unknown in this\n     * attribute\n     */\n    public void addAttributeID(char attributeID)\n    {\n        //some attributes may be repeated for padding\n        //(packet length should be divisable by 4)\n        if (!contains(attributeID))\n            unknownAttributes.add(attributeID);\n    }\n\n    /**\n     * Verifies whether the specified attributeID is contained by this attribute.\n     * @param attributeID the attribute id to look for.\n     * @return true if this attribute contains the specified attribute id.\n     */\n    public boolean contains(char attributeID)\n    {\n        return unknownAttributes.contains(attributeID);\n    }\n\n    /**\n     * Returns an iterator over the list of attribute IDs contained by this\n     * attribute.\n     * @return an iterator over the list of attribute IDs contained by this\n     * attribute.\n     */\n    public Iterator<Character> getAttributes()\n    {\n        return unknownAttributes.iterator();\n    }\n\n    /**\n     * Returns the number of attribute IDs contained by this class.\n     * @return the number of attribute IDs contained by this class.\n     */\n    public int getAttributeCount()\n    {\n        return unknownAttributes.size();\n    }\n\n    /**\n     * Returns the attribute id with index i.\n     * @param index the index of the attribute id to return.\n     * @return the attribute id with index i.\n     */\n    public char getAttribute(int index )\n    {\n        return unknownAttributes.get(index);\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        byte binValue[] = new byte[getDataLength() + HEADER_LENGTH];\n        int  offset     = 0;\n\n        //Type\n        binValue[offset++] = (byte) (getAttributeType() >> 8);\n        binValue[offset++] = (byte) (getAttributeType() & 0x00FF);\n\n        //Length\n        binValue[offset++] = (byte) (getDataLength() >> 8);\n        binValue[offset++] = (byte) (getDataLength() & 0x00FF);\n\n\n        Iterator<Character> attributes = getAttributes();\n        while (attributes.hasNext())\n        {\n            char att = attributes.next();\n            binValue[offset++] = (byte)(att >> 8);\n            binValue[offset++] = (byte)(att & 0x00FF);\n        }\n\n       // If the number of unknown attributes is an odd number, one of the\n       // attributes MUST be repeated in the list, so that the total length of\n       // the list is a multiple of 4 bytes.\n       if (offset < binValue.length)\n       {\n           char att = getAttribute(0);\n           binValue[offset++] = (byte) (att >> 8);\n           binValue[offset++] = (byte) (att & 0x00FF);\n       }\n\n        return binValue;\n    }\n\n    /**\n     * Compares two STUN Attributes. Attributes are considered equal when their\n     * type, length, and all data are the same.\n     *\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof UnknownAttributesAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        UnknownAttributesAttribute att = (UnknownAttributesAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n            || att.getDataLength() != getDataLength()\n            || !unknownAttributes.equals(att.unknownAttributes)\n        )\n            return false;\n\n        return true;\n    }\n\n    /**\n     * Sets this attribute's fields according to attributeValue array.\n     *\n     * @param attributeValue a binary array containing this attribute's field\n     *                       values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *                  offset is equal to the index of the first byte after\n     *                  length)\n     * @param length the length of the binary array.\n     * @throws StunException if attrubteValue contains invalid data.\n     */\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n    throws StunException\n    {\n        if ( (length % 2 ) != 0)\n            throw new StunException(\"Attribute IDs are 2 bytes long and the \"\n                                    + \"passed binary array has an odd length \" +\n                                            \"value.\");\n        char originalOffset = offset;\n        for (int i = offset; i < originalOffset + length; i += 2)\n        {\n            char attributeID = (char) (((attributeValue[offset++] & 0xFF) << 8)\n                | (attributeValue[offset++] & 0xFF));\n            addAttributeID(attributeID);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static String NAME = \"UNKNOWN-ATTRIBUTES\";", "docstring": "\nAttribute name.\n", "modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "type": "String", "name": "NAME = \"UNKNOWN-ATTRIBUTES\"", "syntax_pass": true}, {"attribute_expression": "private ArrayList<Character> unknownAttributes = new ArrayList<>();", "docstring": "\nA list of attribute types that were not understood by the server.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ArrayList<Character>", "name": "unknownAttributes = new ArrayList<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/IceControllingAttribute.java.IceControllingAttribute", "name": "IceControllingAttribute", "file_path": "src/main/java/org/ice4j/attribute/IceControllingAttribute.java", "superclasses": "IceControlAttribute", "methods": ["[]IceControllingAttribute()"], "method_uris": ["src/main/java/org/ice4j/attribute/IceControllingAttribute.java.IceControllingAttribute.[]IceControllingAttribute()"], "overrides": null, "attributes": [], "class_docstring": "\nAn {@link IceControlAttribute} implementation representing the\nICE-CONTROLLING ICE {@link Attribute}s.\n", "original_string": "public final class IceControllingAttribute\n    extends IceControlAttribute\n{\n    /**\n     * Constructs an ICE-CONTROLLING attribute.\n     */\n    public IceControllingAttribute()\n    {\n        super(true);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute", "name": "XorMappedAddressAttribute", "file_path": "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java", "superclasses": "AddressAttribute", "methods": ["[]XorMappedAddressAttribute()", "[]XorMappedAddressAttribute(char)", "[TransportAddress]applyXor(TransportAddress,byte[])", "[TransportAddress]getAddress(byte[])", "[TransportAddress]applyXor(byte[])", "[void]setAddress(TransportAddress,byte[])"], "method_uris": ["src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute.[]XorMappedAddressAttribute()", "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute.[]XorMappedAddressAttribute(char)", "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute.[TransportAddress]applyXor(TransportAddress,byte[])", "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute.[TransportAddress]getAddress(byte[])", "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute.[TransportAddress]applyXor(byte[])", "src/main/java/org/ice4j/attribute/XorMappedAddressAttribute.java.XorMappedAddressAttribute.[void]setAddress(TransportAddress,byte[])"], "overrides": null, "attributes": [], "class_docstring": "\nThe XOR-MAPPED-ADDRESS attribute is only present in Binding\nResponses.  It provides the same information that is present in the\nMAPPED-ADDRESS attribute.  However, the information is encoded by\nperforming an exclusive or (XOR) operation between the mapped address\nand the transaction ID.  Unfortunately, some NAT devices have been\nfound to rewrite binary encoded IP addresses and ports that are\npresent in protocol payloads.  This behavior interferes with the\noperation of STUN.  By providing the mapped address in an obfuscated\nform, STUN can continue to operate through these devices.\n\nThe format of the XOR-MAPPED-ADDRESS is:\n\n\n0                   1                   2                   3\n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|x x x x x x x x|    Family     |         X-Port                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                X-Address (Variable)\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\nThe Family represents the IP address family, and is encoded\nidentically to the Family in MAPPED-ADDRESS.\n\nX-Port is equal to the port in MAPPED-ADDRESS, exclusive or'ed with\nmost significant 16 bits of the transaction ID.  If the IP address\nfamily is IPv4, X-Address is equal to the IP address in MAPPED-\nADDRESS, exclusive or'ed with the most significant 32 bits of the\ntransaction ID.  If the IP address family is IPv6, the X-Address is\nequal to the IP address in MAPPED-ADDRESS, exclusive or'ed with the\nentire 128 bit transaction ID.\n\n@author Emil Ivov\n", "original_string": "public class XorMappedAddressAttribute\n    extends AddressAttribute\n{\n    /**\n     * The name of this attribute\n     */\n    public static final String NAME = \"XOR-MAPPED-ADDRESS\";\n\n    /**\n     * Creates an instance of this attribute\n     */\n    XorMappedAddressAttribute()\n    {\n        super(XOR_MAPPED_ADDRESS);\n    }\n\n    /**\n     * Constructor.\n     * @param type other type than XOR-MAPPED-ADDRESS\n     */\n    XorMappedAddressAttribute(char type)\n    {\n      super(type);\n    }\n\n    /**\n     * Returns the result of applying XOR on the specified attribute's address.\n     * The method may be used for both encoding and decoding XorMappedAddresses.\n     *\n     * @param address the address on which XOR should be applied\n     * @param transactionID the transaction id to use for the XOR\n     *\n     * @return the XOR-ed address.\n     */\n    public static TransportAddress applyXor(TransportAddress address,\n                                       byte[] transactionID)\n    {\n        byte[] addressBytes = address.getAddressBytes();\n        char port = (char)address.getPort();\n\n        char portModifier = (char)( (transactionID[0] << 8 & 0x0000FF00)\n                                  | (transactionID[1] & 0x000000FF));\n\n        port ^= portModifier;\n\n        for (int i = 0; i < addressBytes.length; i++)\n            addressBytes[i] ^= transactionID[i];\n\n        TransportAddress xoredAdd;\n        try\n        {\n            xoredAdd = new TransportAddress(addressBytes, port, Transport.UDP);\n        }\n        catch (UnknownHostException e)\n        {\n            //shouldn't happen so just throw an illegal arg\n            throw new IllegalArgumentException(e);\n        }\n\n        return xoredAdd;\n    }\n\n    /**\n     * Returns the result of applying XOR on this attribute's address, using the\n     * specified transaction ID when converting IPv6 addresses.\n     *\n     * @param transactionID the transaction ID to use in case this attribute is\n     * encapsulating an IPv6 address.\n     *\n     * @return the XOR-ed address.\n     */\n    public TransportAddress getAddress(byte[] transactionID)\n    {\n        byte[] xorMask = new byte[16];\n\n        System.arraycopy(Message.MAGIC_COOKIE, 0, xorMask, 0, 4);\n        System.arraycopy(transactionID, 0, xorMask, 4, 12);\n\n        return applyXor(xorMask);\n    }\n\n    /**\n     * Returns the result of applying XOR on this attribute's address, using the\n     * specified XOR mask. The method may be used for both encoding and\n     * decoding <tt>XorMappedAddresses</tt>.\n     *\n     * @param xorMask the XOR mask to use when obtaining the original address.\n     *\n     * @return the XOR-ed address.\n     */\n    public TransportAddress applyXor(byte[] xorMask)\n    {\n        return applyXor(getAddress(), xorMask);\n    }\n\n    /**\n     * Applies a XOR mask to the specified address and then sets it as the value\n     * transported by this attribute.\n     *\n     * @param address the address that we should xor and then record in this\n     * attribute.\n     * @param transactionID the transaction identifier that we should use\n     * when creating the XOR mask.\n     */\n    public void setAddress(TransportAddress address, byte[] transactionID)\n    {\n        byte[] xorMask = new byte[16];\n\n        System.arraycopy(Message.MAGIC_COOKIE, 0, xorMask, 0, 4);\n        System.arraycopy(transactionID, 0, xorMask, 4, 12);\n\n        TransportAddress xorAddress = applyXor(address, xorMask);\n\n        super.setAddress(xorAddress);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"XOR-MAPPED-ADDRESS\";", "docstring": "\nThe name of this attribute\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"XOR-MAPPED-ADDRESS\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute", "name": "SoftwareAttribute", "file_path": "src/main/java/org/ice4j/attribute/SoftwareAttribute.java", "superclasses": "Attribute", "methods": ["[]SoftwareAttribute()", "[void]decodeAttributeBody(byte[],char,char)", "[byte[]]encode()", "[char]getDataLength()", "[String]getName()", "[byte[]]getSoftware()", "[void]setSoftware(byte[])", "[boolean]equals(Object)"], "method_uris": ["src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[]SoftwareAttribute()", "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[byte[]]getSoftware()", "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[void]setSoftware(byte[])", "src/main/java/org/ice4j/attribute/SoftwareAttribute.java.SoftwareAttribute.[boolean]equals(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nThe SOFTWARE attribute contains a textual description of the software\nbeing used by the software or the client, including manufacturer and version number.\nThe attribute has no impact on operation of the protocol, and serves\nonly as a tool for diagnostic and debugging purposes.\nThe value of SOFTWARE is variable length.  Its length MUST be a\nmultiple of 4 (measured in bytes) in order to guarantee alignment of\nattributes on word boundaries.\n\n@author Emil Ivov\n@author Sebastien Vincent\n", "original_string": "public class SoftwareAttribute\n    extends Attribute\n{\n    /**\n     * The value that this <tt>SoftwareAttribute</tt> is transporting.\n     */\n    private byte[] software = null;\n\n    /**\n     * Creates a new <tt>SoftwareAttribute</tt>.\n     */\n    protected SoftwareAttribute ()\n    {\n        super(SOFTWARE);\n    }\n\n    /**\n     * Copies the value of the software attribute from the specified\n     * attributeValue.\n     *\n     * @param attributeValue a binary array containing this attribute's\n     * field values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     * offset is equal to the index of the first byte after length)\n     * @param length the length of the binary array.\n     */\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n    {\n        software = new byte[length];\n        System.arraycopy(attributeValue, offset, software, 0, length);\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     *\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte binValue[] = new byte[HEADER_LENGTH + getDataLength()\n                                   //add padding\n                                   + (4 - getDataLength() % 4) % 4];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        //software\n        System.arraycopy(software, 0, binValue, 4, getDataLength());\n\n        return binValue;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     *\n     * @return the length of this attribute's value.\n     */\n    public char getDataLength()\n    {\n        return (char)software.length;\n    }\n\n    /**\n     * Returns the human readable name of this attribute.\n     *\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return \"SOFTWARE\";\n    }\n\n    /**\n     * Returns a (cloned) byte array containing the data value of the software\n     * attribute.\n     * @return the binary array containing the software.\n     */\n    public byte[] getSoftware()\n    {\n        if (software == null)\n            return null;\n\n        byte[] copy = new byte[software.length];\n        System.arraycopy(software, 0, copy, 0, software.length);\n        return copy;\n    }\n\n    /**\n     * Copies the specified binary array into the the data value of the software\n     * attribute.\n     *\n     * @param software the binary array containing the software.\n     */\n    public void setSoftware(byte[] software)\n    {\n        if (software == null)\n        {\n            this.software = null;\n            return;\n        }\n\n        this.software = new byte[software.length];\n        System.arraycopy(software, 0, this.software, 0, software.length);\n    }\n\n    /**\n     * Compares two STUN Attributes. Two attributes are considered equal when\n     * they have the same type length and value.\n     *\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof SoftwareAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        SoftwareAttribute att = (SoftwareAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                || !Arrays.equals( att.software, software))\n            return false;\n\n        return true;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private byte[] software = null;", "docstring": "\nThe value that this <tt>SoftwareAttribute</tt> is transporting.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte[]", "name": "software = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/RemoteAddressAttribute.java.RemoteAddressAttribute", "name": "RemoteAddressAttribute", "file_path": "src/main/java/org/ice4j/attribute/RemoteAddressAttribute.java", "superclasses": "AddressAttribute", "methods": ["[]RemoteAddressAttribute()"], "method_uris": ["src/main/java/org/ice4j/attribute/RemoteAddressAttribute.java.RemoteAddressAttribute.[]RemoteAddressAttribute()"], "overrides": null, "attributes": [], "class_docstring": "\nThe REMOTE-ADDRESS is present in Data Indication of old TURN versions.\nIt specifies the address and port where the data is sent. It is encoded\nin the same way as MAPPED-ADDRESS.\n\n@author Sebastien Vincent\n", "original_string": "public class RemoteAddressAttribute extends AddressAttribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"REMOTE-ADDRESS\";\n\n    /**\n     * Constructor.\n     */\n    RemoteAddressAttribute()\n    {\n        super(REMOTE_ADDRESS);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"REMOTE-ADDRESS\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"REMOTE-ADDRESS\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/SourceAddressAttribute.java.SourceAddressAttribute", "name": "SourceAddressAttribute", "file_path": "src/main/java/org/ice4j/attribute/SourceAddressAttribute.java", "superclasses": "AddressAttribute", "methods": ["[]SourceAddressAttribute()"], "method_uris": ["src/main/java/org/ice4j/attribute/SourceAddressAttribute.java.SourceAddressAttribute.[]SourceAddressAttribute()"], "overrides": null, "attributes": [], "class_docstring": "\nThe SOURCE-ADDRESS attribute is present in Binding Responses.  It\nindicates the source IP address and port that the server is sending\nthe response from.  Its syntax is identical to that of MAPPED-ADDRESS.\n\n@author Emil Ivov\n", "original_string": "public class SourceAddressAttribute extends AddressAttribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"SOURCE-ADDRESS\";\n\n    /**\n     * Creates a SOURCE-ADDRESS attribute\n     */\n    SourceAddressAttribute()\n    {\n        super(SOURCE_ADDRESS);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"SOURCE-ADDRESS\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"SOURCE-ADDRESS\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute", "name": "XorOnlyAttribute", "file_path": "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java", "superclasses": "Attribute", "methods": ["[]XorOnlyAttribute()", "[void]decodeAttributeBody(byte[],char,char)", "[byte[]]encode()", "[char]getDataLength()", "[String]getName()", "[boolean]equals(Object)"], "method_uris": ["src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute.[]XorOnlyAttribute()", "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/XorOnlyAttribute.java.XorOnlyAttribute.[boolean]equals(Object)"], "overrides": null, "attributes": [], "class_docstring": "\n This attribute is present in a Binding Request.  It is used by a\n client to request that a server compliant to this specification omit\n the MAPPED-ADDRESS from a Binding Response, and include only the XOR-\n MAPPED-ADDRESS.  This is necessary in cases where a Binding Response\n is failing integrity checks because a NAT is rewriting the contents\n of a MAPPED-ADDRESS in the Binding Response.\n\nThis attribute has a length of zero, and therefore contains no other\ninformation past the common attribute header.\n\n@author Emil Ivov\n", "original_string": "public class XorOnlyAttribute\n    extends Attribute\n{\n    /**\n     * Constructor.\n     */\n    protected XorOnlyAttribute()\n    {\n        super(Attribute.XOR_ONLY);\n    }\n\n    /**\n     * Sets this attribute's fields according to attributeValue array.\n     *\n     * @param attributeValue a binary array containing this attribute's\n     *   field values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *   offset is equal to the index of the first byte after length)\n     * @param length the length of the binary array.\n     * @throws StunException if attrubteValue contains invalid data.\n     */\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        //nothing to do cause we have 0 length\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     *\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte binValue[] = new byte[HEADER_LENGTH + getDataLength()];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        return binValue;\n    }\n\n    /**\n     * Returns the length of this attribute's body. (Which in the case of the\n     * XOR-ONLY attribute is 0);\n     *\n     * @return the length of this attribute's value.\n     */\n    public char getDataLength()\n    {\n        return 0;\n    }\n\n    /**\n     * Returns the human readable name of this attribute.\n     *\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return \"XOR-ONLY\";\n    }\n\n    /**\n     * Compares two STUN Attributes. Two attributes are considered equal when\n     * they have the same type length and value.\n     *\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof XorOnlyAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        XorOnlyAttribute att = (XorOnlyAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n            || att.getDataLength() != getDataLength())\n            return false;\n\n        return true;\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute", "name": "UsernameAttribute", "file_path": "src/main/java/org/ice4j/attribute/UsernameAttribute.java", "superclasses": "Attribute", "methods": ["[]UsernameAttribute()", "[void]decodeAttributeBody(byte[],char,char)", "[byte[]]encode()", "[char]getDataLength()", "[String]getName()", "[byte[]]getUsername()", "[void]setUsername(byte[])", "[boolean]equals(Object)"], "method_uris": ["src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[]UsernameAttribute()", "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[byte[]]getUsername()", "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[void]setUsername(byte[])", "src/main/java/org/ice4j/attribute/UsernameAttribute.java.UsernameAttribute.[boolean]equals(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nThe USERNAME attribute is used for message integrity.\nThe value of USERNAME is a variable length value.\n\n@author Sebastien Vincent\n@author Emil Ivov\n", "original_string": "public class UsernameAttribute extends Attribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"USERNAME\";\n\n    /**\n     * Username value.\n     */\n    private byte username[] = null;\n\n    /**\n     * Constructor.\n     */\n    UsernameAttribute()\n    {\n        super(USERNAME);\n    }\n\n    /**\n     * Copies the value of the username attribute from the specified\n     * attributeValue.\n     *\n     * @param attributeValue a binary array containing this attribute's\n     *   field values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *   offset is equal to the index of the first byte after length)\n     * @param length the length of the binary array.\n     */\n    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n    {\n        username = new byte[length];\n        System.arraycopy(attributeValue, offset, username, 0, length);\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     *\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte binValue[] = new byte[HEADER_LENGTH + getDataLength()\n                                   //add padding\n                                   + (4 - getDataLength() % 4) % 4];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        //username\n        System.arraycopy(username, 0, binValue, 4, getDataLength());\n\n        return binValue;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     *\n     * @return the length of this attribute's value.\n     */\n    public char getDataLength()\n    {\n        return (char)username.length;\n    }\n\n    /**\n     * Returns the human readable name of this attribute.\n     *\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Returns a (cloned) byte array containing the data value of the username\n     * attribute.\n     *\n     * @return the binary array containing the username.\n     */\n    public byte[] getUsername()\n    {\n        return (username == null) ? null : username.clone();\n    }\n\n    /**\n     * Copies the specified binary array into the the data value of the username\n     * attribute.\n     *\n     * @param username the binary array containing the username.\n     */\n    public void setUsername(byte[] username)\n    {\n        if (username == null)\n        {\n            this.username = null;\n            return;\n        }\n\n        this.username = new byte[username.length];\n        System.arraycopy(username, 0, this.username, 0, username.length);\n    }\n\n    /**\n     * Compares two STUN Attributes. Two attributes are considered equal when\n     * they have the same type length and value.\n     *\n     * @param obj the object to compare this attribute with.\n     *\n     * @return true if the attributes are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof UsernameAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        UsernameAttribute att = (UsernameAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                || !Arrays.equals( att.username, username))\n            return false;\n\n        return true;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"USERNAME\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"USERNAME\"", "syntax_pass": true}, {"attribute_expression": "private byte username[] = null;", "docstring": "\nUsername value.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte", "name": "username[] = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute", "name": "PriorityAttribute", "file_path": "src/main/java/org/ice4j/attribute/PriorityAttribute.java", "superclasses": "Attribute", "methods": ["[]PriorityAttribute()", "[void]decodeAttributeBody(byte[],char,char)", "[byte[]]encode()", "[boolean]equals(Object)", "[char]getDataLength()", "[String]getName()", "[long]getPriority()", "[void]setPriority(long)"], "method_uris": ["src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[]PriorityAttribute()", "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[long]getPriority()", "src/main/java/org/ice4j/attribute/PriorityAttribute.java.PriorityAttribute.[void]setPriority(long)"], "overrides": null, "attributes": [], "class_docstring": "\nThis class is used to represent the PRIORITY attribute used for ICE processing\nThis attribute is not in the original specification of STUN\nIt is added as an extension to STUN to be used for ICE implementations\n\nPRIORITY attribute contains a 32 bit priority value\nIt is used in stun binding requests sent from ICE-Agents to their\npeers\n\n@author Namal Senarathne\n", "original_string": "public class PriorityAttribute\n    extends Attribute\n{\n    /**\n     * The length of the Data contained in the Priority Attribute\n     */\n    private static final char DATA_LENGTH_PRIORITY = 4;\n\n    /**\n     * The priority value specified in the attribute. An int should be enough\n     * to store this value, but long is used, since candidate and candidate-pair\n     * classes use long to store priority values\n     */\n    private long priority = 0;\n\n    /**\n     * Creates a priority attribute.\n     */\n    public PriorityAttribute()\n    {\n        super(PRIORITY);\n    }\n\n     /**\n     * Reconstructs the priority value from the given byte array\n     * and stores it in the 'long' variable\n     *\n     * @param attributeValue a binary array containing this attribute's\n     *   field values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *   offset is equal to the index of the first byte after length)\n     * @param length the length of the binary array.\n     * @throws StunException if attrubteValue contains invalid data.\n     */\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n            throws StunException\n    {\n\n        // array used to hold the intermediate long values reconstructed from\n        // the attributeValue array\n        long[] values = new long[4];\n\n        // Reading in the network byte order (Big-Endian)\n        values[0] = (long)((attributeValue[offset++] & 0xff) << 24);\n        values[1] = (long)((attributeValue[offset++] & 0xff) << 16);\n        values[2] = (long)((attributeValue[offset++] & 0xff) << 8);\n        values[3] = (long)(attributeValue[offset++] & 0xff);\n\n        // reconstructing the priority value\n        this.priority = values[0] | values[1] | values[2] | values[3];\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     *\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte[] binValue = new byte[HEADER_LENGTH + getDataLength()];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        //Priority\n        binValue[4] = (byte)((priority & 0xFF000000L) >> 24);\n        binValue[5] = (byte)((priority & 0x00FF0000L) >> 16);\n        binValue[6] = (byte)((priority & 0x0000FF00L) >> 8);\n        binValue[7] = (byte)(priority & 0x000000FFL);\n\n        return binValue;\n    }\n\n    /**\n     * Compares two STUN Attributes. Two attributes are considered equal when\n     * they have the same type length and value.\n     *\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof PriorityAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        PriorityAttribute att = (PriorityAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n            || att.getDataLength() != getDataLength()\n            || (priority != att.priority))\n            return false;\n\n        return true;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     *\n     * @return the length of this attribute's value.\n     */\n    public char getDataLength()\n    {\n        return DATA_LENGTH_PRIORITY;\n    }\n\n    /**\n     * Returns the human readable name of this attribute.\n     *\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return \"PRIORITY\";\n    }\n\n    /**\n     * Returns the priority specified in the PRIORITY Attribute\n     *\n     * @return long specifying the priority\n     */\n    public long getPriority()\n    {\n        return priority;\n    }\n\n    /**\n     * Sets the priority of the PRIORITY Attribute with the specified value\n     *\n     * @param priority     the long variable specifying the priority value\n     *\n     * @throws IllegalArgumentException if indicated priority value is illegal.\n     */\n    public void setPriority(long priority)\n        throws IllegalArgumentException\n    {\n        /* Priority must be between 1 and (2^31 - 1) */\n        if (priority <= 0 || priority > 0x7FFFFFFFL)\n        {\n            throw new IllegalArgumentException(\"Priority must be \" +\n                    \"between 0 and (2**31 - 1)\");\n        }\n        else\n            this.priority = priority;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final char DATA_LENGTH_PRIORITY = 4;", "docstring": "\nThe length of the Data contained in the Priority Attribute\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "DATA_LENGTH_PRIORITY = 4", "syntax_pass": true}, {"attribute_expression": "private long priority = 0;", "docstring": "\nThe priority value specified in the attribute. An int should be enough\nto store this value, but long is used, since candidate and candidate-pair\nclasses use long to store priority values\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "priority = 0", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/IceControlledAttribute.java.IceControlledAttribute", "name": "IceControlledAttribute", "file_path": "src/main/java/org/ice4j/attribute/IceControlledAttribute.java", "superclasses": "IceControlAttribute", "methods": ["[]IceControlledAttribute()"], "method_uris": ["src/main/java/org/ice4j/attribute/IceControlledAttribute.java.IceControlledAttribute.[]IceControlledAttribute()"], "overrides": null, "attributes": [], "class_docstring": "\nAn {@link IceControlAttribute} implementation representing the\nICE-CONTROLLED ICE {@link Attribute}s.\n", "original_string": "public final class IceControlledAttribute\n    extends IceControlAttribute\n{\n    /**\n     * Constructs an ICE-CONTROLLING attribute.\n     */\n    public IceControlledAttribute()\n    {\n        super(false);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/ice4j/attribute/ReflectedFromAttribute.java.ReflectedFromAttribute", "name": "ReflectedFromAttribute", "file_path": "src/main/java/org/ice4j/attribute/ReflectedFromAttribute.java", "superclasses": "AddressAttribute", "methods": ["[]ReflectedFromAttribute()"], "method_uris": ["src/main/java/org/ice4j/attribute/ReflectedFromAttribute.java.ReflectedFromAttribute.[]ReflectedFromAttribute()"], "overrides": null, "attributes": [], "class_docstring": "\nThe REFLECTED-FROM attribute is present only in Binding Responses,\nwhen the Binding Request contained a RESPONSE-ADDRESS attribute.  The\nattribute contains the identity (in terms of IP address) of the\nsource where the request came from.  Its purpose is to provide\ntraceability, so that a STUN server cannot be used as a reflector for\ndenial-of-service attacks.\n\nIts syntax is identical to the MAPPED-ADDRESS attribute.\n\n@author Emil Ivov\n", "original_string": "public class ReflectedFromAttribute extends AddressAttribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"REFLECTED-FROM\";\n\n    /**\n     * Creates a REFLECTED-FROM attribute\n     */\n    public ReflectedFromAttribute()\n    {\n        super(REFLECTED_FROM);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"REFLECTED-FROM\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"REFLECTED-FROM\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute", "name": "ErrorCodeAttribute", "file_path": "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java", "superclasses": "Attribute", "methods": ["[]ErrorCodeAttribute()", "[void]setErrorCode(char)", "[char]getErrorCode()", "[void]setErrorNumber(byte)", "[byte]getErrorNumber()", "[void]setErrorClass(byte)", "[byte]getErrorClass()", "[String]getDefaultReasonPhrase(char)", "[void]setReasonPhrase(String)", "[String]getReasonPhrase()", "[String]getName()", "[char]getDataLength()", "[byte[]]encode()", "[boolean]equals(Object)", "[void]decodeAttributeBody(byte[],char,char)"], "method_uris": ["src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[]ErrorCodeAttribute()", "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[void]setErrorCode(char)", "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[char]getErrorCode()", "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[void]setErrorNumber(byte)", "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[byte]getErrorNumber()", "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[void]setErrorClass(byte)", "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[byte]getErrorClass()", "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[String]getDefaultReasonPhrase(char)", "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[void]setReasonPhrase(String)", "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[String]getReasonPhrase()", "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/ErrorCodeAttribute.java.ErrorCodeAttribute.[void]decodeAttributeBody(byte[],char,char)"], "overrides": null, "attributes": [], "class_docstring": "\nThe ERROR-CODE attribute is present in the Binding Error Response and\nShared Secret Error Response.  It is a numeric value in the range of\n100 to 699 plus a textual reason phrase encoded in UTF-8, and is\nconsistent in its code assignments and semantics with SIP [10] and\nHTTP [15].  The reason phrase is meant for user consumption, and can\nbe anything appropriate for the response code.  The lengths of the\nreason phrases MUST be a multiple of 4 (measured in bytes).  This can\nbe accomplished by added spaces to the end of the text, if necessary.\nRecommended reason phrases for the defined response codes are\npresented below.\n\nTo facilitate processing, the class of the error code (the hundreds\ndigit) is encoded separately from the rest of the code.\n\n  0                   1                   2                   3\n  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |                   0                     |Class|     Number    |\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n |      Reason Phrase (variable)                                ..\n +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\nThe class represents the hundreds digit of the response code.  The\nvalue MUST be between 1 and 6.  The number represents the response\ncode modulo 100, and its value MUST be between 0 and 99.\n\nThe following response codes, along with their recommended reason\nphrases (in brackets) are defined at this time:\n\n400 (Bad Request): The request was malformed.  The client should not\n     retry the request without modification from the previous\n     attempt.\n\n401 (Unauthorized): The Binding Request did not contain a MESSAGE-\n     INTEGRITY attribute.\n\n420 (Unknown Attribute): The server did not understand a mandatory\n     attribute in the request.\n\n430 (Stale Credentials): The Binding Request did contain a MESSAGE-\n     INTEGRITY attribute, but it used a shared secret that has\n     expired.  The client should obtain a new shared secret and try\n     again.\n\n431 (Integrity Check Failure): The Binding Request contained a\n     MESSAGE-INTEGRITY attribute, but the HMAC failed verification.\n     This could be a sign of a potential attack, or client\n     implementation error.\n\n432 (Missing Username): The Binding Request contained a MESSAGE-\n     INTEGRITY attribute, but not a USERNAME attribute.  Both must be\n     present for integrity checks.\n\n433 (Use TLS): The Shared Secret request has to be sent over TLS, but\n     was not received over TLS.\n\n500 (Server Error): The server has suffered a temporary error. The\n     client should try again.\n\n600 (Global Failure:) The server is refusing to fulfill the request.\n     The client should not retry.\n\n@author Emil Ivov\n@author Aakash Garg\n", "original_string": "public class ErrorCodeAttribute extends Attribute\n{\n    /**\n     * Attribute's name.\n     */\n    public static final String NAME = \"ERROR-CODE\";\n\n    // Common error codes\n   /** \n    * Try Alternate error code.\n    */\n   public static final char TRY_ALTERNATE  = 300;\n   \n    /**\n     * Bad request error code.\n     */\n    public static final char BAD_REQUEST   = 400;\n\n    /**\n     * Unauthorized error code.\n     */\n    public static final char UNAUTHORIZED  = 401;\n\n    /**\n     * Forbidden error code.\n     */\n    public static final char FORBIDDEN = 403;\n\n    /**\n     * Unknown attribute error code.\n     */\n    public static final char UNKNOWN_ATTRIBUTE = 420;\n\n    /**\n     * Stale credentials error code.\n     */\n    public static final char STALE_CREDENTIALS = 430;\n\n    /**\n     * Integrity check failure error code.\n     */\n    public static final char INTEGRITY_CHECK_FAILURE = 431;\n\n    /**\n     * Missing username error code.\n     */\n    public static final char MISSING_USERNAME = 432;\n\n    /**\n     * Use TLS error code.\n     */\n    public static final char USE_TLS = 433;\n\n    /**\n     * Allocation Mismatch error code.\n     */\n    public static final char ALLOCATION_MISMATCH  = 437;\n   \n   /**\n    * Stale Nonce error code.\n    */\n   public static final char STALE_NONCE  = 438;\n   \n    /**\n     * Address Family not Supported error code.\n     */\n    public static final char ADDRESS_FAMILY_NOT_SUPPORTED = 440;\n\n    /**\n     * Wrong Credentials error code.\n     */\n    public static final char WRONG_CREDENTIALS  = 441;\n\n    /**\n     * Unsupported Transport Protocol error code.\n     */\n    public static final char UNSUPPORTED_TRANSPORT_PROTOCOL = 442;\n\n    /**\n     * Peer Address Family Mismatch error code.\n     */\n    public static final char PEER_ADDRESS_FAMILY_MISMATCH = 443;\n    \n    /**\n     * Connection Already Exists error code.\n     */\n    public static final char CONNECTION_ALREADY_EXISTS = 446;\n    \n    /**\n     * Connection Timeout or Failure error code.\n     */\n    public static final char CONNECTION_TIMEOUT_OR_FAILURE = 447;\n    \n    /**\n     * Allocation Quota reached error code.\n     */\n    public static final char ALLOCATION_QUOTA_REACHED  = 486;\n\n    /**\n     * Role conflict error code.\n     */\n    public static final char ROLE_CONFLICT   = 487;\n\n    /**\n     * Server error code.\n     */\n    public static final char SERVER_ERROR = 500;\n\n    /**\n     * Insufficient Capacity error code.\n     */\n    public static final char INSUFFICIENT_CAPACITY  = 508;\n\n    /**\n     * Global failure error code.\n     */\n    public static final char GLOBAL_FAILURE = 600;\n    \n    /**\n     * The class represents the hundreds digit of the response code.  The\n     * value MUST be between 1 and 6.\n     */\n    private byte errorClass = 0;\n\n    /**\n     * The number represents the response\n     * code modulo 100, and its value MUST be between 0 and 99.\n     */\n    private byte errorNumber = 0;\n\n    /**\n     * The reason phrase is meant for user consumption, and can\n     * be anything appropriate for the response code.\n     */\n    private byte[] reasonPhrase = null;\n\n    /**\n     * Constructs a new ERROR-CODE attribute\n     */\n    ErrorCodeAttribute()\n    {\n        super(ERROR_CODE);\n    }\n\n    /**\n     * A convenience method that sets error class and number according to the\n     * specified errorCode.The class represents the hundreds digit of the error\n     * code. The value MUST be between 1 and 6.  The number represents the\n     * response code modulo 100, and its value MUST be between 0 and 99.\n     *\n     * @param errorCode the errorCode that this class encapsulates.\n     * @throws IllegalArgumentException if errorCode is not a valid error code.\n     */\n    public void setErrorCode(char errorCode)\n        throws IllegalArgumentException\n    {\n        setErrorClass((byte)(errorCode / 100));\n        setErrorNumber((byte)(errorCode % 100));\n    }\n\n    /**\n     * A convenience method that constructs an error code from this Attribute's\n     * class and number.\n     * @return the code of the error this attribute represents.\n     */\n    public char getErrorCode()\n    {\n        return (char)(getErrorClass() * 100 + getErrorNumber());\n    }\n\n    /**\n     * Sets this attribute's error number.\n     * @param errorNumber the error number to assign this attribute.\n     * @throws IllegalArgumentException if errorNumber is not a valid error\n     * number.\n     */\n    public void setErrorNumber(byte errorNumber)\n        throws IllegalArgumentException\n    {\n        /*\n        if(errorNumber < 0 || errorNumber > 9999)\n            throw new IllegalArgumentException(\n                            errorNumber + \" is not a valid error number!\");\n         */\n        this.errorNumber = errorNumber;\n    }\n\n    /**\n     * Returns this attribute's error number.\n     * @return  this attribute's error number.\n     */\n    public byte getErrorNumber()\n    {\n        return this.errorNumber;\n    }\n\n    /**\n     * Sets this error's error class.\n     * @param errorClass this error's error class.\n     * @throws IllegalArgumentException if errorClass is not a valid error\n     * class.\n     */\n    public void setErrorClass(byte errorClass)\n        throws IllegalArgumentException\n    {\n        if (errorClass < 0 || errorClass > 99)\n            throw new IllegalArgumentException(\n                errorClass + \" is not a valid error number!\");\n        this.errorClass = errorClass;\n    }\n\n    /**\n     * Returns this error's error class.\n     * @return this error's error class.\n     */\n    public byte getErrorClass()\n    {\n        return errorClass;\n    }\n\n    /**\n     * Returns a default reason phrase corresponding to the specified error\n     * code, as described by rfc 3489.\n     * @param errorCode the code of the error that the reason phrase must\n     *                  describe.\n     * @return a default reason phrase corresponding to the specified error\n     * code, as described by rfc 3489.\n     */\n    public static String getDefaultReasonPhrase(char errorCode)\n    {\n        switch(errorCode)\n        {\n            case 300:\n                return \"(Try Alternate): The server would like the client to\"\n                    + \" use the server specified in the ALTERNATE-SERVER\"\n                    + \" attribute instead.\";\n            case 400:\n                return \"(Bad Request): The request was malformed.  The client\"\n                    + \" should not retry the request without modification from\"\n                    + \" the previous attempt.\";\n            case 401:\n                return \"(Unauthorized): The Binding Request did not contain\"\n                    + \" a MESSAGE-INTEGRITY attribute.\";\n            case 403:\n                return \"(Forbidden): The request was valid but cannot be\"\n                    + \" performed due to administrative or similar\"\n                    + \" restrictions.\";\n            case 420:\n                return \"(Unknown Attribute): The server did not understand\"\n                    + \" a mandatory attribute in the request.\";\n            case 430:\n                return \"(Stale Credentials): The Binding Request did contain\"\n                    + \" a MESSAGE-INTEGRITY attribute, but it used a shared\"\n                    + \" secret that has expired.\";\n            case 431:\n                return \"(Integrity Check Failure): The Binding Request\"\n                    + \" contained a MESSAGE-INTEGRITY attribute, but the HMAC\"\n                    + \" failed verification.\";\n            case 432:\n                return \"(Missing Username): The Binding Request contained\"\n                    + \" a MESSAGE-INTEGRITY attribute, but not a USERNAME\"\n                    + \" attribute.\";\n            case 433:\n                return \"(Use TLS): The Shared Secret request has to be sent\"\n                    + \" over TLS, but was not received over TLS.\";\n            case 437:\n                return \"(Allocation Mismatch): A request was received by the\"\n                    + \" server that requires an allocation to be in place,\"\n                    + \" but no allocation exists, or a request was received\"\n                    + \" that requires no allocation, but an allocation exists.\";\n            case 438:\n                return \"(Stale Nonce): See the procedures for the long-term\"\n                    + \" credential mechanism.\";\n            case 440:\n                return \"(Address Family not Supported):  The server does not\"\n                    + \" support the address family requested by the client.\";\n            case 441:\n                return \"(Wrong Credentials): The credentials in the\"\n                    + \" (non-Allocate) request do not match those used\"\n                    + \" to create the allocation.\";\n            case 442:\n                return \"(Unsupported Transport Protocol): The Allocate request\"\n                    + \" asked the server to use a transport protocol between\"\n                    + \" the server and the peer that the server does not\"\n                    + \" support.\";\n            case 443:\n                return \"Peer Address Family Mismatch):  A peer address was of\"\n                    + \" a different address family than that of the relayed\"\n                    + \" transport address of the allocation.\";\n            case 446:\n                return  \"Connection Already Exists\";\n            case 447:\n                return  \"Connection Timeout or Failure\";\n            case 486:\n                return \"(Allocation Quota Reached): No more allocations using\"\n                    + \" this username can be created at the present time.\";\n            case 500:\n                return  \"(Server Error): The server has suffered a temporary\"\n                    + \" error. The client should try again.\";\n            case 508:\n                return \"(Insufficient Capacity): The server is unable to carry\"\n                    + \" out the request due to some capacity limit being\"\n                    + \" reached.\";\n            case 600:\n                return \"(Global Failure:) The server is refusing to fulfill\"\n                    + \" the request. The client should not retry.\";\n            \n            default:  return \"Unknown Error\";\n        }\n    }\n\n    /**\n     * Set's a reason phrase. The reason phrase is meant for user consumption,\n     * and can be anything appropriate for the response code.  The lengths of\n     * the reason phrases MUST be a multiple of 4 (measured in bytes).\n     *\n     * @param reasonPhrase a reason phrase that describes this error.\n     */\n    public void setReasonPhrase(String reasonPhrase)\n    {\n        this.reasonPhrase = reasonPhrase.getBytes();\n    }\n\n    /**\n     * Returns the reason phrase. The reason phrase is meant for user consumption,\n     * and can be anything appropriate for the response code.  The lengths of\n     * the reason phrases MUST be a multiple of 4 (measured in bytes).\n     *\n     * @return reasonPhrase a reason phrase that describes this error.\n     */\n    public String getReasonPhrase()\n    {\n        if (reasonPhrase == null)\n            return null;\n\n        return new String(reasonPhrase);\n    }\n\n    /**\n     * Returns the human readable name of this attribute. Attribute names do\n     * not really matter from the protocol point of view. They are only used\n     * for debugging and readability.\n     * @return this attribute's name.\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     * @return the length of this attribute's value.\n     */\n    @Override\n    public char getDataLength()\n    {\n        char len = (char)(4 //error code numbers\n           + (char)(reasonPhrase == null ? 0 : reasonPhrase.length));\n\n        return len;\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     * @return a binary representation of this attribute.\n     */\n    @Override\n    public byte[] encode()\n    {\n        byte binValue[] =  new byte[HEADER_LENGTH + getDataLength()\n                                    //add padding\n                                    + (4 - getDataLength() % 4) % 4];\n\n        //Type\n        binValue[0] = (byte) (getAttributeType() >> 8);\n        binValue[1] = (byte) (getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte) (getDataLength() >> 8);\n        binValue[3] = (byte) (getDataLength() & 0x00FF);\n\n        //Not used\n        binValue[4] = 0x00;\n        binValue[5] = 0x00;\n\n        //Error code\n        binValue[6] = getErrorClass();\n        binValue[7] = getErrorNumber();\n\n        if (reasonPhrase != null)\n            System.arraycopy(reasonPhrase, 0, binValue, 8, reasonPhrase.length);\n\n        return binValue;\n    }\n\n    /**\n     * Compares two STUN Attributes. Attributes are considered equal when their\n     * type, length, and all data are the same.\n     *\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n     @Override\n    public boolean equals(Object obj)\n     {\n         if (! (obj instanceof ErrorCodeAttribute))\n             return false;\n\n         if (obj == this)\n             return true;\n\n         ErrorCodeAttribute att = (ErrorCodeAttribute) obj;\n         if (att.getAttributeType() != getAttributeType()\n             || att.getDataLength() != getDataLength()\n             //compare data\n             || att.getErrorClass() != getErrorClass()\n             || att.getErrorNumber()!= getErrorNumber()\n             || ( att.getReasonPhrase() != null\n                  && !att.getReasonPhrase().equals(getReasonPhrase()))\n             )\n             return false;\n\n         return true;\n    }\n\n    /**\n     * Sets this attribute's fields according to attributeValue array.\n     *\n     * @param attributeValue a binary array containing this attribute's field\n     *                       values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *                  offset is equal to the index of the first byte after\n     *                  length)\n     * @param length the length of the binary array.\n     */\n    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n    {\n\n        offset += 2; //skip the 0s\n\n        //Error code\n        setErrorClass(attributeValue[offset++]);\n        setErrorNumber(attributeValue[offset++]);\n\n        //Reason Phrase\n        byte[] reasonBytes = new byte[length - 4];\n\n        System.arraycopy(attributeValue, offset, reasonBytes,\n                            0, reasonBytes.length);\n        setReasonPhrase(new String(reasonBytes));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"ERROR-CODE\";", "docstring": "\nAttribute's name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"ERROR-CODE\"", "syntax_pass": true}, {"attribute_expression": "public static final char TRY_ALTERNATE  = 300;", "docstring": " \nTry Alternate error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "TRY_ALTERNATE  = 300", "syntax_pass": true}, {"attribute_expression": "public static final char BAD_REQUEST   = 400;", "docstring": "\nBad request error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "BAD_REQUEST   = 400", "syntax_pass": true}, {"attribute_expression": "public static final char UNAUTHORIZED  = 401;", "docstring": "\nUnauthorized error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "UNAUTHORIZED  = 401", "syntax_pass": true}, {"attribute_expression": "public static final char FORBIDDEN = 403;", "docstring": "\nForbidden error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "FORBIDDEN = 403", "syntax_pass": true}, {"attribute_expression": "public static final char UNKNOWN_ATTRIBUTE = 420;", "docstring": "\nUnknown attribute error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "UNKNOWN_ATTRIBUTE = 420", "syntax_pass": true}, {"attribute_expression": "public static final char STALE_CREDENTIALS = 430;", "docstring": "\nStale credentials error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "STALE_CREDENTIALS = 430", "syntax_pass": true}, {"attribute_expression": "public static final char INTEGRITY_CHECK_FAILURE = 431;", "docstring": "\nIntegrity check failure error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "INTEGRITY_CHECK_FAILURE = 431", "syntax_pass": true}, {"attribute_expression": "public static final char MISSING_USERNAME = 432;", "docstring": "\nMissing username error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "MISSING_USERNAME = 432", "syntax_pass": true}, {"attribute_expression": "public static final char USE_TLS = 433;", "docstring": "\nUse TLS error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "USE_TLS = 433", "syntax_pass": true}, {"attribute_expression": "public static final char ALLOCATION_MISMATCH  = 437;", "docstring": "\nAllocation Mismatch error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ALLOCATION_MISMATCH  = 437", "syntax_pass": true}, {"attribute_expression": "public static final char STALE_NONCE  = 438;", "docstring": "\nStale Nonce error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "STALE_NONCE  = 438", "syntax_pass": true}, {"attribute_expression": "public static final char ADDRESS_FAMILY_NOT_SUPPORTED = 440;", "docstring": "\nAddress Family not Supported error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ADDRESS_FAMILY_NOT_SUPPORTED = 440", "syntax_pass": true}, {"attribute_expression": "public static final char WRONG_CREDENTIALS  = 441;", "docstring": "\nWrong Credentials error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "WRONG_CREDENTIALS  = 441", "syntax_pass": true}, {"attribute_expression": "public static final char UNSUPPORTED_TRANSPORT_PROTOCOL = 442;", "docstring": "\nUnsupported Transport Protocol error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "UNSUPPORTED_TRANSPORT_PROTOCOL = 442", "syntax_pass": true}, {"attribute_expression": "public static final char PEER_ADDRESS_FAMILY_MISMATCH = 443;", "docstring": "\nPeer Address Family Mismatch error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "PEER_ADDRESS_FAMILY_MISMATCH = 443", "syntax_pass": true}, {"attribute_expression": "public static final char CONNECTION_ALREADY_EXISTS = 446;", "docstring": "\nConnection Already Exists error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CONNECTION_ALREADY_EXISTS = 446", "syntax_pass": true}, {"attribute_expression": "public static final char CONNECTION_TIMEOUT_OR_FAILURE = 447;", "docstring": "\nConnection Timeout or Failure error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CONNECTION_TIMEOUT_OR_FAILURE = 447", "syntax_pass": true}, {"attribute_expression": "public static final char ALLOCATION_QUOTA_REACHED  = 486;", "docstring": "\nAllocation Quota reached error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ALLOCATION_QUOTA_REACHED  = 486", "syntax_pass": true}, {"attribute_expression": "public static final char ROLE_CONFLICT   = 487;", "docstring": "\nRole conflict error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ROLE_CONFLICT   = 487", "syntax_pass": true}, {"attribute_expression": "public static final char SERVER_ERROR = 500;", "docstring": "\nServer error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "SERVER_ERROR = 500", "syntax_pass": true}, {"attribute_expression": "public static final char INSUFFICIENT_CAPACITY  = 508;", "docstring": "\nInsufficient Capacity error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "INSUFFICIENT_CAPACITY  = 508", "syntax_pass": true}, {"attribute_expression": "public static final char GLOBAL_FAILURE = 600;", "docstring": "\nGlobal failure error code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "GLOBAL_FAILURE = 600", "syntax_pass": true}, {"attribute_expression": "private byte errorClass = 0;", "docstring": "\nThe class represents the hundreds digit of the response code.  The\nvalue MUST be between 1 and 6.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte", "name": "errorClass = 0", "syntax_pass": true}, {"attribute_expression": "private byte errorNumber = 0;", "docstring": "\nThe number represents the response\ncode modulo 100, and its value MUST be between 0 and 99.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte", "name": "errorNumber = 0", "syntax_pass": true}, {"attribute_expression": "private byte[] reasonPhrase = null;", "docstring": "\nThe reason phrase is meant for user consumption, and can\nbe anything appropriate for the response code.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte[]", "name": "reasonPhrase = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute", "name": "ReservationTokenAttribute", "file_path": "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java", "superclasses": "Attribute", "methods": ["[]ReservationTokenAttribute()", "[void]decodeAttributeBody(byte[],char,char)", "[byte[]]encode()", "[String]getName()", "[byte[]]getReservationToken()", "[void]setReservationToken(byte[])", "[char]getDataLength()", "[ReservationTokenAttribute]createNewReservationTokenAttribute()", "[void]generateReservationTokenAttribute(ReservationTokenAttribute,int)", "[boolean]equals(Object)", "[String]toString()", "[String]toString(byte[])", "[int]hashCode()"], "method_uris": ["src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[]ReservationTokenAttribute()", "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[byte[]]getReservationToken()", "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[void]setReservationToken(byte[])", "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[ReservationTokenAttribute]createNewReservationTokenAttribute()", "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[void]generateReservationTokenAttribute(ReservationTokenAttribute,int)", "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[String]toString()", "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[String]toString(byte[])", "src/main/java/org/ice4j/attribute/ReservationTokenAttribute.java.ReservationTokenAttribute.[int]hashCode()"], "overrides": null, "attributes": [], "class_docstring": "\nThe RESERVATION-TOKEN attribute contains a token that identifies a\nreservation port on a TURN server. The value is on 64 bits (8 bytes).\n\n@author Sebastien Vincent\n@author Aakash Garg\n", "original_string": "public class ReservationTokenAttribute\n    extends Attribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"RESERVATION-TOKEN\";\n\n    /**\n     * ReservationToken value.\n     */\n    private byte reservationToken[] = null;\n\n    /**\n     * A hashcode for hashtable storage.\n     */\n    private int hashCode = 0;\n\n    /**\n     * The object to use to generate the rightmost 8 bytes of the token.\n     */\n    private static final Random random\n        = new Random(System.currentTimeMillis());\n    \n    /**\n     * Constructor.\n     */\n    protected ReservationTokenAttribute ()\n    {\n        super(RESERVATION_TOKEN);\n        this.reservationToken = new byte[8];\n    }\n\n    /**\n     * Copies the value of the reservationToken attribute from the specified\n     * attributeValue.\n     * @param attributeValue a binary array containing this attribute's\n     *   field values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *   offset is equal to the index of the first byte after length)\n     * @param length the length of the binary array.\n     * @throws StunException if attributeValue contains invalid reservationToken.\n     */\n    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        if (length != 8)\n        {\n          throw new StunException(\"Length mismatch!\");\n        }\n\n        reservationToken = new byte[8];\n        System.arraycopy(attributeValue, offset, reservationToken, 0, 8);\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     * @return a binary representation of this attribute.\n     */\n    @Override\n    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte binValue[] = new byte[HEADER_LENGTH + 8];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(8 >> 8);\n        binValue[3] = (byte)(8 & 0x00FF);\n\n        //reservationToken\n        System.arraycopy(reservationToken, 0, binValue, 4, 8);\n\n        return binValue;\n      }\n\n    /**\n     * Returns the human readable name of this attribute.\n     *\n     * @return this attribute's name.\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Returns a (cloned) byte array containing the reservationToken value of\n     * the reservationToken attribute.\n     * @return the binary array containing the reservationToken.\n     */\n    public byte[] getReservationToken()\n    {\n        if (reservationToken == null)\n            return null;\n\n        byte[] copy = new byte[reservationToken.length];\n        System.arraycopy(reservationToken, 0, copy, 0, reservationToken.length);\n        return copy;\n      }\n\n    /**\n     * Copies the specified binary array into the the reservationToken value of\n     * the reservationToken attribute.\n     * @param reservationToken the binary array containing the reservationToken.\n     */\n    public void setReservationToken(byte[] reservationToken)\n    {\n        if (reservationToken == null)\n        {\n            this.reservationToken = null;\n            return;\n        }\n\n        this.reservationToken = new byte[reservationToken.length];\n        System.arraycopy(reservationToken, 0, this.reservationToken, 0,\n                reservationToken.length);\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     * @return the length of this attribute's value.\n     */\n    @Override\n    public char getDataLength()\n    {\n        return (char)reservationToken.length;\n    }\n\n    /**\n     * Creates a Reservation Token object.The Reservation Token itself is\n     * generated using the following algorithm:\n     * \n     * The first 6 bytes of the id are given the value of\n     * <tt>System.currentTimeMillis()</tt>. Putting the right most bits first so\n     * that we get a more optimized equals() method.\n     * \n     * @return A <tt>Reservation Token </tt>object with a unique token value.\n     */\n    public static ReservationTokenAttribute createNewReservationTokenAttribute()\n    {\n        ReservationTokenAttribute token = new ReservationTokenAttribute();\n\n        generateReservationTokenAttribute(token, 8);\n        return token;\n    }\n    \n    /**\n     * Generates a random ReservationTokenAttribute\n     *\n     * @param token ReservationTokenAttribute\n     * @param nb number of bytes to generate\n     */\n    private static void generateReservationTokenAttribute(\n        ReservationTokenAttribute token, int nb)\n    {\n        long left = System.currentTimeMillis(); // the first nb/2 bytes of the\n                                               // token\n        long right = random.nextLong(); // the last nb/2 bytes of the token\n        int b = nb / 2;\n\n        for (int i = 0; i < b; i++)\n        {\n            token.reservationToken[i]   = (byte)((left  >> (i * 8)) & 0xFFL);\n            token.reservationToken[i + b] = (byte)((right >> (i * 8)) & 0xFFL);\n        }\n\n        //calculate hashcode for Hashtable storage.\n        token.hashCode =   (token.reservationToken[3] << 24 & 0xFF000000)\n                       | (token.reservationToken[2] << 16 & 0x00FF0000)\n                       | (token.reservationToken[1] << 8  & 0x0000FF00)\n                       | (token.reservationToken[0]       & 0x000000FF);\n    }\n    \n    /**\n     * Compares two STUN Attributes. Two attributes are considered equal when\n     * they have the same type length and value.\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    @Override\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof ReservationTokenAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        ReservationTokenAttribute att = (ReservationTokenAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n            || att.getDataLength() != getDataLength()\n            || !Arrays.equals( att.reservationToken, reservationToken))\n            return false;\n\n        return true;\n    }\n\n\n    /**\n     * Returns a string representation of the token.\n     *\n     * @return a hex string representing the token.\n     */\n    @Override\n    public String toString()\n    {\n        return ReservationTokenAttribute.toString(this.reservationToken);\n    }\n    \n    /**\n     * Returns a string representation of the token.\n     * \n     * @param reservationToken the Reservation Token to convert into\n     *            <tt>String</tt>.\n     * \n     * @return a hex string representing the token.\n     */\n    public static String toString(byte[] reservationToken)\n    {\n        StringBuilder idStr = new StringBuilder();\n\n        idStr.append(\"0x\");\n        for (int i = 0; i < reservationToken.length; i++)\n        {\n            if ((reservationToken[i] & 0xFF) <= 15)\n                idStr.append(\"0\");\n\n            idStr.append(Integer.toHexString(\n                reservationToken[i] & 0xFF).toUpperCase());\n        }\n        return idStr.toString();\n    }\n    \n    /**\n     * Returns the hash code of this Reservation-Token.\n     */\n    @Override\n    public int hashCode()\n    {\n        return this.hashCode;\n    }\n    \n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"RESERVATION-TOKEN\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"RESERVATION-TOKEN\"", "syntax_pass": true}, {"attribute_expression": "private byte reservationToken[] = null;", "docstring": "\nReservationToken value.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte", "name": "reservationToken[] = null", "syntax_pass": true}, {"attribute_expression": "private int hashCode = 0;", "docstring": "\nA hashcode for hashtable storage.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "hashCode = 0", "syntax_pass": true}, {"attribute_expression": "private static final Random random\n        = new Random(System.currentTimeMillis());", "docstring": "\nThe object to use to generate the rightmost 8 bytes of the token.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Random", "name": "random\n        = new Random(System.currentTimeMillis())", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute", "name": "RealmAttribute", "file_path": "src/main/java/org/ice4j/attribute/RealmAttribute.java", "superclasses": "Attribute", "methods": ["[]RealmAttribute()", "[void]decodeAttributeBody(byte[],char,char)", "[byte[]]encode()", "[char]getDataLength()", "[String]getName()", "[byte[]]getRealm()", "[void]setRealm(byte[])", "[boolean]equals(Object)"], "method_uris": ["src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[]RealmAttribute()", "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[byte[]]getRealm()", "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[void]setRealm(byte[])", "src/main/java/org/ice4j/attribute/RealmAttribute.java.RealmAttribute.[boolean]equals(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nThe REALM attribute contains a text which meets the grammar for\n\"realm value\" as described in RFC3261 but without the double quotes.\n\n@author Sebastien Vincent\n", "original_string": "public class RealmAttribute extends Attribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"REALM\";\n\n    /**\n     * Realm value.\n     */\n    private byte realm[] = null;\n\n    /**\n     * Constructor.\n     */\n    RealmAttribute()\n    {\n        super(REALM);\n    }\n\n    /**\n     * Copies the value of the realm attribute from the specified\n     * attributeValue.\n     * @param attributeValue a binary array containing this attribute's\n     *   field values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *   offset is equal to the index of the first byte after length)\n     * @param length the length of the binary array.\n     * @throws StunException if attributeValue contains invalid data.\n     */\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        realm = new byte[length];\n        System.arraycopy(attributeValue, offset, realm, 0, length);\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte binValue[] = new byte[HEADER_LENGTH + getDataLength() +\n                                   (getDataLength() % 4)];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        /* realm */\n        System.arraycopy(realm, 0, binValue, 4, getDataLength());\n\n        return binValue;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     * @return the length of this attribute's value.\n     */\n    public char getDataLength()\n    {\n        return (char)realm.length;\n    }\n\n    /**\n     * Returns the human readable name of this attribute.\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Returns a (cloned) byte array containing the data value of the realm\n     * attribute.\n     * @return the binary array containing the realm.\n     */\n    public byte[] getRealm()\n    {\n        return (realm == null) ? null : realm.clone();\n    }\n\n    /**\n     * Copies the specified binary array into the the data value of the realm\n     * attribute.\n     * @param realm the binary array containing the realm.\n     */\n    public void setRealm(byte[] realm)\n    {\n        if (realm == null)\n        {\n            this.realm = null;\n            return;\n        }\n\n        this.realm = new byte[realm.length];\n        System.arraycopy(realm, 0, this.realm, 0, realm.length);\n    }\n\n    /**\n     * Compares two STUN Attributes. Two attributes are considered equal when they\n     * have the same type length and value.\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof RealmAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        RealmAttribute att = (RealmAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                || !Arrays.equals( att.realm, realm))\n            return false;\n\n        return true;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"REALM\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"REALM\"", "syntax_pass": true}, {"attribute_expression": "private byte realm[] = null;", "docstring": "\nRealm value.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte", "name": "realm[] = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute", "name": "EvenPortAttribute", "file_path": "src/main/java/org/ice4j/attribute/EvenPortAttribute.java", "superclasses": "Attribute", "methods": ["[]EvenPortAttribute()", "[boolean]equals(Object)", "[String]getName()", "[char]getDataLength()", "[byte[]]encode()", "[void]decodeAttributeBody(byte[],char,char)", "[void]setRFlag(boolean)", "[boolean]isRFlag()"], "method_uris": ["src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[]EvenPortAttribute()", "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[void]setRFlag(boolean)", "src/main/java/org/ice4j/attribute/EvenPortAttribute.java.EvenPortAttribute.[boolean]isRFlag()"], "overrides": null, "attributes": [], "class_docstring": "\nThe EVEN-PORT attribute is used to ask the TURN\nserver to allocate an even port and optionally allocate\nthe next higher port number.\n\nThere is one flag supported: <br>\nR : ask to reserve a second port.\n\n@author Sebastien Vincent\n", "original_string": "public class EvenPortAttribute extends Attribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"EVEN-PORT\";\n\n    /**\n     * The length of the data contained by this attribute.\n     */\n    public static final char DATA_LENGTH = 1;\n\n    /**\n     * R flag.\n     */\n    boolean rFlag = false;\n\n    /**\n     * Constructor.\n     */\n    EvenPortAttribute()\n    {\n        super(EVEN_PORT);\n    }\n\n    /**\n     * Compares two STUN Attributes. Attributes are considered equal when their\n     * type, length, and all data are the same.\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof EvenPortAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        EvenPortAttribute att = (EvenPortAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                /* compare data */\n                || att.rFlag != rFlag\n           )\n            return false;\n\n        return true;\n    }\n\n    /**\n     * Returns the human readable name of this attribute. Attribute names do\n     * not really matter from the protocol point of view. They are only used\n     * for debugging and readability.\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     * @return the length of this attribute's value (8 bytes).\n     */\n    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = (byte)(rFlag ? 1 << 8 : 0);\n\n        return binValue;\n    }\n\n    /**\n     * Sets this attribute's fields according to attributeValue array.\n     * @param attributeValue a binary array containing this attribute's field\n     *                       values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *          offset is equal to the index of the first byte after\n     *          length)\n     * @param length the length of the binary array.\n     * @throws StunException if attrubteValue contains invalid data.\n     */\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        if (length != 4)\n        {\n            throw new StunException(\"length invalid\");\n        }\n\n        rFlag = (attributeValue[0] & 0x80) > 0;\n    }\n\n    /**\n     * Set the R flag.\n     * @param rFlag true of false\n     */\n    public void setRFlag(boolean rFlag)\n    {\n        this.rFlag = rFlag;\n    }\n\n    /**\n     * Is the R flag set\n     * @return true if it is, false otherwise\n     */\n    public boolean isRFlag()\n    {\n        return rFlag;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"EVEN-PORT\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"EVEN-PORT\"", "syntax_pass": true}, {"attribute_expression": "public static final char DATA_LENGTH = 1;", "docstring": "\nThe length of the data contained by this attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "DATA_LENGTH = 1", "syntax_pass": true}, {"attribute_expression": "boolean rFlag = false;", "docstring": "\nR flag.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "rFlag = false", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute", "name": "ChangeRequestAttribute", "file_path": "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java", "superclasses": "Attribute", "methods": ["[]ChangeRequestAttribute()", "[String]getName()", "[boolean]equals(Object)", "[char]getDataLength()", "[byte[]]encode()", "[void]setChangeIpFlag(boolean)", "[boolean]getChangeIpFlag()", "[void]setChangePortFlag(boolean)", "[boolean]getChangePortFlag()", "[void]decodeAttributeBody(byte[],char,char)"], "method_uris": ["src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[]ChangeRequestAttribute()", "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[void]setChangeIpFlag(boolean)", "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[boolean]getChangeIpFlag()", "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[void]setChangePortFlag(boolean)", "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[boolean]getChangePortFlag()", "src/main/java/org/ice4j/attribute/ChangeRequestAttribute.java.ChangeRequestAttribute.[void]decodeAttributeBody(byte[],char,char)"], "overrides": null, "attributes": [], "class_docstring": "\nThis class represents the STUN CHANGE-REQUEST attribute. The CHANGE-REQUEST\nattribute is used by the client to request that the server use a different\naddress and/or port when sending the response.  The attribute is 32 bits\nlong, although only two bits (A and B) are used:\n<pre>\n0                   1                   2                   3    \n0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  \n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 A B 0|\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</pre>\nThe meaning of the flags is:\n\nA: This is the \"change IP\" flag.  If true, it requests the server\n   to send the Binding Response with a different IP address than the\n   one the Binding Request was received on.\n\nB: This is the \"change port\" flag.  If true, it requests the\n   server to send the Binding Response with a different port than the\n   one the Binding Request was received on.\n\n@author Emil Ivov\n", "original_string": "public class ChangeRequestAttribute\n    extends Attribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"CHANGE-REQUEST\";\n\n    /**\n     * This is the \"change IP\" flag.  If true, it requests the server\n     * to send the Binding Response with a different IP address than the\n     * one the Binding Request was received on.\n     */\n    private boolean changeIpFlag   = false;\n\n    /**\n     * This is the \"change port\" flag.  If true, it requests the\n     * server to send the Binding Response with a different port than the\n     * one the Binding Request was received on.\n     */\n    private boolean changePortFlag = false;\n\n    /**\n     * The length of the data contained by this attribute.\n     */\n    public static final char DATA_LENGTH = 4;\n\n\n    /**\n     * Creates an empty ChangeRequestAttribute.\n     */\n    ChangeRequestAttribute()\n    {\n        super(CHANGE_REQUEST);\n    }\n\n    /**\n     * Returns the human readable name of this attribute. Attribute names do\n     * not really matter from the protocol point of view. They are only used\n     * for debugging and readability.\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Compares two STUN Attributes. Attributes are considered equal when their\n     * type, length, and all data are the same.\n     *\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n     public boolean equals(Object obj)\n     {\n         if (! (obj instanceof ChangeRequestAttribute))\n             return false;\n\n         if (obj == this)\n             return true;\n\n         ChangeRequestAttribute att = (ChangeRequestAttribute) obj;\n         if (att.getAttributeType()   != getAttributeType()\n             || att.getDataLength()   != getDataLength()\n             //compare data\n             || att.getChangeIpFlag() != getChangeIpFlag()\n             || att.getChangePortFlag()       != getChangePortFlag()\n             )\n             return false;\n\n         return true;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     * @return the length of this attribute's value (8 bytes).\n     */\n    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = 0x00;\n        binValue[5] = 0x00;\n        binValue[6] = 0x00;\n        binValue[7] = (byte)((getChangeIpFlag() ? 4 : 0) +\n                (getChangePortFlag() ? 2 : 0));\n\n        return binValue;\n    }\n\n    //========================= set/get methods\n    /**\n     * Sets the value of the changeIpFlag. The \"change IP\" flag,  if true,\n     * requests the server to send the Binding Response with a different IP\n     * address than the one the Binding Request was received on.\n     *\n     * @param changeIP the new value of the changeIpFlag.\n     */\n    public void setChangeIpFlag(boolean changeIP)\n    {\n        this.changeIpFlag = changeIP;\n    }\n\n    /**\n     * Returns the value of the changeIpFlag. The \"change IP\" flag,  if true,\n     * requests the server to send the Binding Response with a different IP\n     * address than the one the Binding Request was received on.\n     *\n     * @return the value of the changeIpFlag.\n     */\n    public boolean getChangeIpFlag()\n    {\n        return changeIpFlag;\n    }\n\n    /**\n     * Sets the value of the changePortFlag. The \"change port\" flag.  If true,\n     * requests the server to send the Binding Response with a different port\n     * than the one the Binding Request was received on.\n     *\n     * @param changePort the new value of the changePort flag.\n     */\n    public void setChangePortFlag(boolean changePort)\n    {\n        this.changePortFlag = changePort;\n    }\n\n    /**\n     * Returns the value of the changePortFlag. The \"change port\" flag. If true,\n     * requests the server to send the Binding Response with a different port\n     * than the one the Binding Request was received on.\n     *\n     * @return the value of the changePort flag.\n     */\n    public boolean getChangePortFlag()\n    {\n        return changePortFlag;\n    }\n\n    /**\n      * Sets this attribute's fields according to attributeValue array.\n      *\n      * @param attributeValue a binary array containing this attribute's field\n      *                       values and NOT containing the attribute header.\n      * @param offset the position where attribute values begin (most often\n      *                  offset is equal to the index of the first byte after\n      *                  length)\n      * @param length the length of the binary array.\n      * @throws StunException if attrubteValue contains invalid data.\n      */\n     void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n         throws StunException\n     {\n         offset += 3; // first three bytes of change req att are not used\n         setChangeIpFlag((attributeValue[offset] & 4) > 0);\n         setChangePortFlag((attributeValue[offset] & 0x2) > 0);\n     }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"CHANGE-REQUEST\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"CHANGE-REQUEST\"", "syntax_pass": true}, {"attribute_expression": "private boolean changeIpFlag   = false;", "docstring": "\nThis is the \"change IP\" flag.  If true, it requests the server\nto send the Binding Response with a different IP address than the\none the Binding Request was received on.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "changeIpFlag   = false", "syntax_pass": true}, {"attribute_expression": "private boolean changePortFlag = false;", "docstring": "\nThis is the \"change port\" flag.  If true, it requests the\nserver to send the Binding Response with a different port than the\none the Binding Request was received on.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "changePortFlag = false", "syntax_pass": true}, {"attribute_expression": "public static final char DATA_LENGTH = 4;", "docstring": "\nThe length of the data contained by this attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "DATA_LENGTH = 4", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory", "name": "AttributeFactory", "file_path": "src/main/java/org/ice4j/attribute/AttributeFactory.java", "superclasses": "", "methods": ["[ChangeRequestAttribute]createChangeRequestAttribute()", "[ChangeRequestAttribute]createChangeRequestAttribute(boolean,boolean)", "[ChangedAddressAttribute]createChangedAddressAttribute(TransportAddress)", "[ErrorCodeAttribute]createErrorCodeAttribute(byte,byte)", "[ErrorCodeAttribute]createErrorCodeAttribute(byte,byte,String)", "[ErrorCodeAttribute]createErrorCodeAttribute(char)", "[ErrorCodeAttribute]createErrorCodeAttribute(char,String)", "[MappedAddressAttribute]createMappedAddressAttribute(TransportAddress)", "[ReflectedFromAttribute]createReflectedFromAttribute(TransportAddress)", "[ResponseAddressAttribute]createResponseAddressAttribute(TransportAddress)", "[SourceAddressAttribute]createSourceAddressAttribute(TransportAddress)", "[UnknownAttributesAttribute]createUnknownAttributesAttribute()", "[XorRelayedAddressAttribute]createXorRelayedAddressAttribute(TransportAddress,byte[])", "[XorPeerAddressAttribute]createXorPeerAddressAttribute(TransportAddress,byte[])", "[XorMappedAddressAttribute]createXorMappedAddressAttribute(TransportAddress,byte[])", "[UsernameAttribute]createUsernameAttribute(byte)", "[UsernameAttribute]createUsernameAttribute(String)", "[MessageIntegrityAttribute]createMessageIntegrityAttribute(String)", "[FingerprintAttribute]createFingerprintAttribute()", "[ChannelNumberAttribute]createChannelNumberAttribute(char)", "[RealmAttribute]createRealmAttribute(byte)", "[NonceAttribute]createNonceAttribute(byte)", "[SoftwareAttribute]createSoftwareAttribute(byte)", "[EvenPortAttribute]createEvenPortAttribute(boolean)", "[LifetimeAttribute]createLifetimeAttribute(int)", "[RequestedTransportAttribute]createRequestedTransportAttribute(byte)", "[ReservationTokenAttribute]createReservationTokenAttribute(byte)", "[DataAttribute]createDataAttribute(byte)", "[DataAttribute]createDataAttributeWithoutPadding(byte)", "[IceControlledAttribute]createIceControlledAttribute(long)", "[PriorityAttribute]createPriorityAttribute(long)", "[UseCandidateAttribute]createUseCandidateAttribute()", "[IceControllingAttribute]createIceControllingAttribute(long)", "[MagicCookieAttribute]createMagicCookieAttribute()", "[DestinationAddressAttribute]createDestinationAddressAttribute(TransportAddress)", "[RequestedAddressFamilyAttribute]createRequestedAddressFamilyAttribute(char)", "[ConnectionIdAttribute]createConnectionIdAttribute(int)", "[ConnectionIdAttribute]createConnectionIdAttribute()"], "method_uris": ["src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ChangeRequestAttribute]createChangeRequestAttribute()", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ChangeRequestAttribute]createChangeRequestAttribute(boolean,boolean)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ChangedAddressAttribute]createChangedAddressAttribute(TransportAddress)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ErrorCodeAttribute]createErrorCodeAttribute(byte,byte)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ErrorCodeAttribute]createErrorCodeAttribute(byte,byte,String)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ErrorCodeAttribute]createErrorCodeAttribute(char)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ErrorCodeAttribute]createErrorCodeAttribute(char,String)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[MappedAddressAttribute]createMappedAddressAttribute(TransportAddress)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ReflectedFromAttribute]createReflectedFromAttribute(TransportAddress)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ResponseAddressAttribute]createResponseAddressAttribute(TransportAddress)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[SourceAddressAttribute]createSourceAddressAttribute(TransportAddress)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[UnknownAttributesAttribute]createUnknownAttributesAttribute()", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[XorRelayedAddressAttribute]createXorRelayedAddressAttribute(TransportAddress,byte[])", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[XorPeerAddressAttribute]createXorPeerAddressAttribute(TransportAddress,byte[])", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[XorMappedAddressAttribute]createXorMappedAddressAttribute(TransportAddress,byte[])", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[UsernameAttribute]createUsernameAttribute(byte)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[UsernameAttribute]createUsernameAttribute(String)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[MessageIntegrityAttribute]createMessageIntegrityAttribute(String)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[FingerprintAttribute]createFingerprintAttribute()", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ChannelNumberAttribute]createChannelNumberAttribute(char)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[RealmAttribute]createRealmAttribute(byte)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[NonceAttribute]createNonceAttribute(byte)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[SoftwareAttribute]createSoftwareAttribute(byte)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[EvenPortAttribute]createEvenPortAttribute(boolean)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[LifetimeAttribute]createLifetimeAttribute(int)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[RequestedTransportAttribute]createRequestedTransportAttribute(byte)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ReservationTokenAttribute]createReservationTokenAttribute(byte)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[DataAttribute]createDataAttribute(byte)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[DataAttribute]createDataAttributeWithoutPadding(byte)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[IceControlledAttribute]createIceControlledAttribute(long)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[PriorityAttribute]createPriorityAttribute(long)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[UseCandidateAttribute]createUseCandidateAttribute()", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[IceControllingAttribute]createIceControllingAttribute(long)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[MagicCookieAttribute]createMagicCookieAttribute()", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[DestinationAddressAttribute]createDestinationAddressAttribute(TransportAddress)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[RequestedAddressFamilyAttribute]createRequestedAddressFamilyAttribute(char)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ConnectionIdAttribute]createConnectionIdAttribute(int)", "src/main/java/org/ice4j/attribute/AttributeFactory.java.AttributeFactory.[ConnectionIdAttribute]createConnectionIdAttribute()"], "overrides": null, "attributes": [], "class_docstring": "\nThis class provides factory methods to allow an application to create STUN /\nTURN / ICE Attributes from a particular implementation.\n\n@author Emil Ivov\n@author Sebastien Vincent\n@author Namal Senarathne\n@author Aakash Garg\n", "original_string": "public class AttributeFactory\n{\n    /**\n     * Creates a ChangeRequestAttribute with \"false\" values for the changeIP and\n     * changePort flags.\n     *\n     * @return the newly created ChangeRequestAttribute.\n     */\n    public static ChangeRequestAttribute createChangeRequestAttribute()\n    {\n        return createChangeRequestAttribute(false, false);\n    }\n\n    /**\n     * Creates a ChangeRequestAttribute with the specified flag values.\n     *\n     * @param changeIP the value of the changeIP flag.\n     * @param changePort the value of the changePort flag.\n     * @return the newly created ChangeRequestAttribute.\n     */\n    public static ChangeRequestAttribute createChangeRequestAttribute(\n                    boolean changeIP, boolean changePort)\n    {\n        ChangeRequestAttribute attribute = new ChangeRequestAttribute();\n\n        attribute.setChangeIpFlag(changeIP);\n        attribute.setChangePortFlag(changePort);\n\n        return attribute;\n    }\n\n    /**\n     * Creates a changedAddressAttribute of the specified type and with the\n     * specified address and port\n     *\n     * @param address the address value of the address attribute\n     * @return the newly created address attribute.\n     */\n    public static ChangedAddressAttribute createChangedAddressAttribute(\n                    TransportAddress address)\n    {\n        ChangedAddressAttribute attribute = new ChangedAddressAttribute();\n\n        attribute.setAddress(address);\n\n        return attribute;\n    }\n\n    /**\n     * Creates an ErrorCodeAttribute with the specified error class and number\n     * and a default reason phrase.\n     *\n     * @param errorClass a valid error class.\n     * @param errorNumber a valid error number.\n     * @return the newly created attribute.\n     * @throws StunException if the error class or number have invalid values\n     * according to rfc3489.\n     */\n    public static ErrorCodeAttribute createErrorCodeAttribute(byte errorClass,\n                    byte errorNumber)\n        throws StunException\n    {\n        return createErrorCodeAttribute(errorClass, errorNumber, null);\n    }\n\n    /**\n     * Creates an ErrorCodeAttribute with the specified error class, number and\n     * reason phrase.\n     *\n     * @param errorClass a valid error class.\n     * @param errorNumber a valid error number.\n     * @param reasonPhrase a human readable reason phrase. A null reason phrase\n     * would be replaced (if possible) by a default one as defined byte the\n     * rfc3489.\n     * @return the newly created attribute.\n     * @throws StunException if the error class or number have invalid values\n     * according to rfc3489.\n     */\n    public static ErrorCodeAttribute createErrorCodeAttribute(\n                                                        byte errorClass,\n                                                        byte errorNumber,\n                                                        String reasonPhrase)\n        throws StunException\n    {\n        ErrorCodeAttribute attribute = new ErrorCodeAttribute();\n\n        attribute.setErrorClass(errorClass);\n        attribute.setErrorNumber(errorNumber);\n\n        attribute.setReasonPhrase(reasonPhrase == null ? ErrorCodeAttribute\n                        .getDefaultReasonPhrase(attribute.getErrorCode())\n                        : reasonPhrase);\n\n        return attribute;\n    }\n\n    /**\n     * Creates an ErrorCodeAttribute with the specified error code and a default\n     * reason phrase.\n     *\n     * @param errorCode a valid error code.\n     * @return the newly created attribute.\n     * @throws StunException if errorCode is not a valid error code as defined\n     * by rfc3489\n     */\n    public static ErrorCodeAttribute createErrorCodeAttribute(char errorCode)\n                    throws StunException\n    {\n        return createErrorCodeAttribute(errorCode, null);\n    }\n\n    /**\n     * Creates an ErrorCodeAttribute with the specified error code and reason\n     * phrase.\n     *\n     * @param errorCode a valid error code.\n     * @param reasonPhrase a human readable reason phrase. A null reason phrase\n     * would be replaced (if possible) by a default one as defined byte the\n     * rfc3489.\n     *\n     * @return the newly created attribute.\n     * @throws IllegalArgumentException if errorCode is not a valid error code\n     * as defined by rfc3489\n     */\n    public static ErrorCodeAttribute createErrorCodeAttribute(\n                                                          char errorCode,\n                                                          String reasonPhrase)\n        throws IllegalArgumentException\n    {\n        ErrorCodeAttribute attribute = new ErrorCodeAttribute();\n\n        attribute.setErrorCode(errorCode);\n        attribute.setReasonPhrase(reasonPhrase == null ? ErrorCodeAttribute\n                        .getDefaultReasonPhrase(attribute.getErrorCode())\n                        : reasonPhrase);\n\n        return attribute;\n    }\n\n    /**\n     * Creates a MappedAddressAttribute of the specified type and with the\n     * specified address and port\n     *\n     * @param address the address value of the address attribute\n     * @return the newly created address attribute.\n     */\n    public static MappedAddressAttribute createMappedAddressAttribute(\n                    TransportAddress address)\n    {\n        MappedAddressAttribute attribute = new MappedAddressAttribute();\n\n        attribute.setAddress(address);\n\n        return attribute;\n    }\n\n    /**\n     * Creates a ReflectedFromAddressAttribute of the specified type and with\n     * the specified address and port\n     *\n     * @param address the address value of the address attribute\n     * @return the newly created address attribute.\n     */\n    public static ReflectedFromAttribute createReflectedFromAttribute(\n                    TransportAddress address)\n    {\n        ReflectedFromAttribute attribute = new ReflectedFromAttribute();\n\n        attribute.setAddress(address);\n\n        return attribute;\n    }\n\n    /**\n     * Creates a ResponseFromAddressAttribute of the specified type and with the\n     * specified address and port\n     *\n     * @param address the address value of the address attribute\n     * @return the newly created address attribute.\n     */\n    public static ResponseAddressAttribute createResponseAddressAttribute(\n                    TransportAddress address)\n    {\n        ResponseAddressAttribute attribute = new ResponseAddressAttribute();\n\n        attribute.setAddress(address);\n\n        return attribute;\n    }\n\n    /**\n     * Creates a SourceFromAddressAttribute of the specified type and with the\n     * specified address and port\n     *\n     * @param address the address value of the address attribute\n     * @return the newly created address attribute.\n     */\n    public static SourceAddressAttribute createSourceAddressAttribute(\n                    TransportAddress address)\n    {\n        SourceAddressAttribute attribute = new SourceAddressAttribute();\n\n        attribute.setAddress(address);\n\n        return attribute;\n    }\n\n    /**\n     * Creates an empty UnknownAttributesAttribute.\n     *\n     * @return the newly created UnknownAttributesAttribute\n     */\n    public static UnknownAttributesAttribute createUnknownAttributesAttribute()\n    {\n        UnknownAttributesAttribute attribute = new UnknownAttributesAttribute();\n\n        return attribute;\n    }\n\n    /**\n     * Creates a XorRelayedAddressAttribute of the specified type and with the\n     * specified address and port.\n     *\n     * @param address the address value of the address attribute\n     * @param tranID the ID of the transaction that we will be using for the XOR\n     * mask.\n     *\n     * @return the newly created address attribute.\n     */\n    public static XorRelayedAddressAttribute createXorRelayedAddressAttribute(\n                    TransportAddress address, byte[] tranID)\n    {\n        XorRelayedAddressAttribute attribute = new XorRelayedAddressAttribute();\n\n        // TODO (Emil): shouldn't we be XORing the address before setting it?\n        attribute.setAddress(address, tranID);\n        return attribute;\n    }\n\n    /**\n     * Creates a XorPeerAddressAttribute of the specified type and with the\n     * specified address and port\n     *\n     * @param address the address value of the address attribute\n     * @param tranID the ID of the transaction that we will be using for the XOR\n     * mask.\n     * @return the newly created address attribute.\n     */\n    public static XorPeerAddressAttribute createXorPeerAddressAttribute(\n                    TransportAddress address, byte[] tranID)\n    {\n        XorPeerAddressAttribute attribute = new XorPeerAddressAttribute();\n\n        // TODO (Emil): shouldn't we be XORing the address before setting it?\n        attribute.setAddress(address, tranID);\n        return attribute;\n    }\n\n    /**\n     * Creates a XorMappedAddressAttribute for the specified <tt>address</tt>.\n     *\n     * @param address the address value of the address attribute\n     * @param tranID the ID of the transaction that we will be using for the XOR\n     * mask.\n     *\n     * @return the newly created XOR address attribute.\n     */\n    public static XorMappedAddressAttribute createXorMappedAddressAttribute(\n                    TransportAddress address, byte[] tranID)\n    {\n        XorMappedAddressAttribute attribute = new XorMappedAddressAttribute();\n\n        attribute.setAddress(address, tranID);\n\n        return attribute;\n    }\n\n    /**\n     * Create a UsernameAttribute.\n     *\n     * @param username username value\n     *\n     * @return newly created UsernameAttribute\n     */\n    public static UsernameAttribute createUsernameAttribute(byte username[])\n    {\n        UsernameAttribute attribute = new UsernameAttribute();\n\n        attribute.setUsername(username);\n        return attribute;\n    }\n\n    /**\n     * Creates a new <tt>UsernameAttribute</tt> instance.\n     *\n     * @param username the String value of the username\n     * @return a new <tt>UsernameAttribute</tt> instance\n     */\n    public static UsernameAttribute createUsernameAttribute(String username)\n    {\n        UsernameAttribute attribute = new UsernameAttribute();\n\n        try\n        {\n            attribute.setUsername(username.getBytes(\"UTF-8\"));\n        }\n        catch (UnsupportedEncodingException ueex)\n        {\n            throw new UndeclaredThrowableException(ueex);\n        }\n        return attribute;\n    }\n\n    /**\n     * Creates an empty <tt>MessageIntegrityAttribute</tt>. When included in a\n     * message the stack would set the body of this attribute so that the\n     * the HMAC-SHA1 (RFC 2104) would correspond to the actual message that's\n     * transporting the attribute.\n     *\n     * @param username the username that we should use to obtain an encryption\n     * key (password) that the {@link Attribute#encode()} method should use when\n     * creating the content of this message.\n     *\n     * @return the newly created address attribute.\n     */\n    public static MessageIntegrityAttribute createMessageIntegrityAttribute(\n                                                    String username)\n    {\n        MessageIntegrityAttribute attribute = new MessageIntegrityAttribute();\n\n        attribute.setUsername(username);\n        return attribute;\n    }\n\n    /**\n     * Creates an empty <tt>FingerprintAttribute</tt> with a 0 check sum. Once\n     * included in a message, the value of this attribute will be calculated\n     * by the stack just before sending it.\n     *\n     * @return the newly created <tt>FingerprintAttribute</tt>.\n     */\n    public static FingerprintAttribute createFingerprintAttribute()\n    {\n        FingerprintAttribute attribute = new FingerprintAttribute();\n\n        return attribute;\n    }\n\n    /**\n     * Create a ChannelNumberAttribute.\n     *\n     * @param channelNumber channel number\n     * @return newly created ChannelNumberAttribute\n     */\n    public static ChannelNumberAttribute createChannelNumberAttribute(\n                    char channelNumber)\n    {\n        ChannelNumberAttribute attribute = new ChannelNumberAttribute();\n\n        attribute.setChannelNumber(channelNumber);\n        return attribute;\n    }\n\n    /**\n     * Create a RealmAttribute.\n     *\n     * @param realm realm value\n     * @return newly created RealmAttribute\n     */\n    public static RealmAttribute createRealmAttribute(byte realm[])\n    {\n        RealmAttribute attribute = new RealmAttribute();\n\n        attribute.setRealm(realm);\n        return attribute;\n    }\n\n    /**\n     * Create a NonceAttribute.\n     *\n     * @param nonce nonce value\n     * @return newly created NonceAttribute\n     */\n    public static NonceAttribute createNonceAttribute(byte nonce[])\n    {\n        NonceAttribute attribute = new NonceAttribute();\n\n        attribute.setNonce(nonce);\n        return attribute;\n    }\n\n    /**\n     * Create a SoftwareAttribute.\n     *\n     * @param software software value\n     * @return newly created SoftwareAttribute\n     */\n    public static SoftwareAttribute createSoftwareAttribute(byte software[])\n    {\n        SoftwareAttribute attribute = new SoftwareAttribute();\n\n        attribute.setSoftware(software);\n        return attribute;\n    }\n\n    /**\n     * Create a EventAttribute.\n     *\n     * @param rFlag R flag\n     * @return the newly created EventPortAttribute\n     */\n    public static EvenPortAttribute createEvenPortAttribute(boolean rFlag)\n    {\n        EvenPortAttribute attribute = new EvenPortAttribute();\n\n        attribute.setRFlag(rFlag);\n        return attribute;\n    }\n\n    /**\n     * Create a LifetimeAttribute.\n     *\n     * @param lifetime lifetime value\n     * @return newly created LifetimeAttribute\n     */\n    public static LifetimeAttribute createLifetimeAttribute(int lifetime)\n    {\n        LifetimeAttribute attribute = new LifetimeAttribute();\n\n        attribute.setLifetime(lifetime);\n        return attribute;\n    }\n\n    /**\n     * Create a RequestedTransportAttribute.\n     *\n     * @param protocol transport protocol requested\n     * @return newly created RequestedTransportAttribute\n     */\n    public static RequestedTransportAttribute createRequestedTransportAttribute(\n                    byte protocol)\n    {\n        RequestedTransportAttribute attribute =\n            new RequestedTransportAttribute();\n\n        attribute.setRequestedTransport(protocol);\n        return attribute;\n    }\n\n    /**\n     * Create a ReservationTokenAttribute.\n     *\n     * @param token the token\n     * @return newly created RequestedTransportAttribute\n     */\n    public static ReservationTokenAttribute createReservationTokenAttribute(\n                    byte token[])\n    {\n        ReservationTokenAttribute attribute = new ReservationTokenAttribute();\n\n        attribute.setReservationToken(token);\n        return attribute;\n    }\n\n    /**\n     * Create a DataAtttribute.\n     *\n     * @param data the data\n     * @return newly created DataAttribute\n     */\n    public static DataAttribute createDataAttribute(byte data[])\n    {\n        DataAttribute attribute = new DataAttribute();\n\n        attribute.setData(data);\n        return attribute;\n    }\n\n    /**\n     * Create a DataAtttribute.\n     *\n     * @param data the data\n     * @return newly created DataAttribute\n     */\n    public static DataAttribute createDataAttributeWithoutPadding(byte data[])\n    {\n        DataAttribute attribute = new DataAttribute(false);\n\n        attribute.setData(data);\n        return attribute;\n    }\n\n    /**\n     * Creates an IceControlledAttribute object with the specified tie-breaker\n     * value\n     *\n     * @param tieBreaker the tie-breaker value to be used\n     * @return the created IceControlledAttribute\n     */\n    public static IceControlledAttribute createIceControlledAttribute(\n                                                            long tieBreaker)\n    {\n        IceControlledAttribute attribute = new IceControlledAttribute();\n        attribute.setTieBreaker(tieBreaker);\n\n        return attribute;\n    }\n\n    /**\n     * Creates a Priority attribute with the specified priority value\n     *\n     * @param priority the priority value\n     * @return the created PriorityAttribute\n     * @throws IllegalArgumentException if priority &lt; 0 or priority &gt;\n     *             (2^31 - 1)\n     */\n    public static PriorityAttribute createPriorityAttribute(long priority)\n                    throws IllegalArgumentException\n    {\n        PriorityAttribute attribute = new PriorityAttribute();\n\n        attribute.setPriority(priority);\n\n        return attribute;\n    }\n\n    /**\n     * Creates a UseCandidateAttribute\n     *\n     * @return the created UseCandidateAttribute\n     */\n    public static UseCandidateAttribute createUseCandidateAttribute()\n    {\n        UseCandidateAttribute attribute = new UseCandidateAttribute();\n\n        return attribute;\n    }\n\n    /**\n     * Creates an IceControllingAttribute with the specified tie-breaker value\n     *\n     * @param tieBreaker the tie-breaker value to be used\n     *\n     * @return the created IceControllingAttribute\n     */\n    public static IceControllingAttribute createIceControllingAttribute(\n                    long tieBreaker)\n    {\n        IceControllingAttribute attribute = new IceControllingAttribute();\n        attribute.setTieBreaker(tieBreaker);\n\n        return attribute;\n    }\n\n    /**\n     * Creates a MagicCookieAttribute.\n     *\n     * @return the created MagicCookieAttribute\n     */\n    public static MagicCookieAttribute createMagicCookieAttribute()\n    {\n        MagicCookieAttribute attribute = new MagicCookieAttribute();\n        return attribute;\n    }\n\n    /**\n     * Creates a DestinationFromAddressAttribute of the specified type and with\n     * the specified address and port\n     *\n     * @param address the address value of the address attribute\n     * @return the newly created address attribute.\n     */\n    public static DestinationAddressAttribute createDestinationAddressAttribute(\n                    TransportAddress address)\n    {\n        DestinationAddressAttribute attribute =\n            new DestinationAddressAttribute();\n\n        attribute.setAddress(address);\n\n        return attribute;\n    }\n    \n    /**\n     * Creates a new RequestedAddressFamilyAttribute of the specified family\n     * \n     * @param family address family value as specified in the RFC\n     * @return the newly created RequestedAddressFamily attribute if family is\n     *         IPv4/IPv6 otherwise <tt>null</tt>.\n     */\n    public static RequestedAddressFamilyAttribute\n        createRequestedAddressFamilyAttribute(char family)\n    {\n        RequestedAddressFamilyAttribute attribute\n            = new RequestedAddressFamilyAttribute();\n\n        boolean isSet = attribute.setFamily(family);\n        if (!isSet)\n        {\n            attribute = null;\n        }\n\n        return attribute;\n    }\n    \n    /**\n     * Creates a new ConnectionIdAttribute of the specified connectionIdValue\n     * \n     * @param connectionIdValue the connection ID value.\n     * @return the newly created ConnectionId attribute. \n     */\n    public static ConnectionIdAttribute createConnectionIdAttribute(\n        int connectionIdValue)\n    {\n        ConnectionIdAttribute attribute = new ConnectionIdAttribute();\n\n        attribute.setConnectionIdValue(connectionIdValue);\n\n        return attribute;\n    }\n    \n    /**\n     * Creates a new ConnectionIdAttribute. The connectionId value is set as the\n     * hashcode value of the object.\n     * \n     * @return the newly created ConnectionId attribute.\n     */\n    public static ConnectionIdAttribute createConnectionIdAttribute()\n    {\n        ConnectionIdAttribute attribute = new ConnectionIdAttribute();\n        int connectionIdValue = attribute.hashCode();\n        attribute.setConnectionIdValue(connectionIdValue);\n\n        return attribute;\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute", "name": "RequestedAddressFamilyAttribute", "file_path": "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java", "superclasses": "Attribute", "methods": ["[]RequestedAddressFamilyAttribute()", "[char]getDataLength()", "[String]getName()", "[boolean]equals(Object)", "[byte[]]encode()", "[void]decodeAttributeBody(byte[],char,char)", "[char]getFamily()", "[boolean]setFamily(char)"], "method_uris": ["src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[]RequestedAddressFamilyAttribute()", "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[char]getFamily()", "src/main/java/org/ice4j/attribute/RequestedAddressFamilyAttribute.java.RequestedAddressFamilyAttribute.[boolean]setFamily(char)"], "overrides": null, "attributes": [], "class_docstring": "\nThe requested address family attribute defined in RFC 6156.\n\n@author Aakash Garg\n", "original_string": "public class RequestedAddressFamilyAttribute extends Attribute \n{\n    /**\n     * Attribute Name.\n     */\n    public static final String NAME  = \"REQUESTED-ADDRESS-FAMILY\";\n    \n    /**\n     * The length of the data contained in this attribute.\n     */\n    public static final char DATA_LENGTH = 1;\n    \n    /**\n     * The IPv4 family type.\n     */\n    public static final char IPv4 = 0x01;\n    \n    /**\n     * The IPv6 family type.\n     */\n    public static final char IPv6 = 0x02;\n\n    /**\n     * The address family value.\n     */\n    char family = IPv4;\n    \n    /**\n     * Constructor.\n     */\n    protected RequestedAddressFamilyAttribute() \n    {\n        super(REQUESTED_ADDRESS_FAMILY);\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     * @return the length of this attribute's value (1 byte).\n     */\n    @Override\n    public char getDataLength() \n    {\n        return DATA_LENGTH;\n    }\n\n    /**\n     * Returns the human readable name of this attribute. Attribute names do\n     * not really matter from the protocol point of view. They are only used\n     * for debugging and readability.\n     * @return this attribute's name.\n     */\n    @Override\n    public String getName() \n    {\n        return NAME;\n    }\n\n    /**\n     * Compares two TURN Attributes. Attributes are considered equal when their\n     * type, length, and all data are the same.\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    @Override\n    public boolean equals(Object obj) \n    {\n        if (! (obj instanceof RequestedAddressFamilyAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        RequestedAddressFamilyAttribute att\n            = (RequestedAddressFamilyAttribute) obj;\n\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                /* compare data */\n                || att.family != family\n           )\n            return false;\n\n        return true;\n    }\n\n    /**\n    * Returns a binary representation of this attribute.\n    * @return a binary representation of this attribute.\n    */\n    @Override\n    public byte[] encode() \n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = (byte) family;\n\n        return binValue;\n    }\n\n   /**\n    * Sets this attribute's fields according to attributeValue array.\n    * @param attributeValue a binary array containing this attribute's field\n    *                       values and NOT containing the attribute header.\n    * @param offset the position where attribute values begin (most often\n    *          offset is equal to the index of the first byte after\n    *          length)\n    * @param length the length of the binary array.\n    * @throws StunException if attrubteValue contains invalid data.\n    */\n    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length) \n        throws StunException\n    {\n        if (length != DATA_LENGTH)\n        {\n            throw new StunException(\"length invalid: \" + length);\n        }\n\n        family = (char)(attributeValue[offset] & 0xff);\n\n        if (family != IPv4 && family != IPv6)\n        {\n            // instead throw TurnException\n            throw new StunException(\"invalid family value: \" + family);\n        }\n    }\n\n    /**\n     * Gets the address family value\n     * @return family the address family value\n     */\n    public char getFamily() \n    {\n        return family;\n    }\n    \n    /**\n     * Sets the address family value\n     * @param family the address family value to set\n     * @return true if argument is IPv4 or IPv6 otherwise false\n     */\n    public boolean setFamily(char family) \n    {    \n        if (family == IPv4 || family == IPv6)\n        {\n            this.family = family;\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n    }\n    \n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME  = \"REQUESTED-ADDRESS-FAMILY\";", "docstring": "\nAttribute Name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME  = \"REQUESTED-ADDRESS-FAMILY\"", "syntax_pass": true}, {"attribute_expression": "public static final char DATA_LENGTH = 1;", "docstring": "\nThe length of the data contained in this attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "DATA_LENGTH = 1", "syntax_pass": true}, {"attribute_expression": "public static final char IPv4 = 0x01;", "docstring": "\nThe IPv4 family type.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "IPv4 = 0x01", "syntax_pass": true}, {"attribute_expression": "public static final char IPv6 = 0x02;", "docstring": "\nThe IPv6 family type.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "IPv6 = 0x02", "syntax_pass": true}, {"attribute_expression": "char family = IPv4;", "docstring": "\nThe address family value.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "char", "name": "family = IPv4", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute", "name": "RequestedTransportAttribute", "file_path": "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java", "superclasses": "Attribute", "methods": ["[]RequestedTransportAttribute()", "[boolean]equals(Object)", "[String]getName()", "[char]getDataLength()", "[byte[]]encode()", "[void]decodeAttributeBody(byte[],char,char)", "[void]setRequestedTransport(byte)", "[int]getRequestedTransport()"], "method_uris": ["src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[]RequestedTransportAttribute()", "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[void]setRequestedTransport(byte)", "src/main/java/org/ice4j/attribute/RequestedTransportAttribute.java.RequestedTransportAttribute.[int]getRequestedTransport()"], "overrides": null, "attributes": [], "class_docstring": "\nThe REQUESTED-TRANSPORT attribute is used to allocate a\nTURN address of certain transport protocol.\n\nIn the original TURN specification, only UDP is supported.\nSupport of TCP is detailed in draft-ietf-behave-turn-tcp-07.\n\n@author Sebastien Vincent\n@author Aakash Garg\n", "original_string": "public class RequestedTransportAttribute extends Attribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"REQUESTED-TRANSPORT\";\n\n    /**\n     * The length of the data contained by this attribute.\n     */\n    public static final char DATA_LENGTH = 4;\n\n    public static final byte UDP = 17;\n\n    public static final byte TCP = 6;\n\n    /**\n     * Transport protocol.\n     *\n     * 17 = UDP;\n     * 6 = TCP.\n     */\n    byte transportProtocol = UDP;\n    \n    /**\n     * Constructor.\n     */\n    RequestedTransportAttribute()\n    {\n        super(REQUESTED_TRANSPORT);\n    }\n\n    /**\n     * Compares two STUN Attributes. Attributes are considered equal when their\n     * type, length, and all data are the same.\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    @Override\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof RequestedTransportAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        RequestedTransportAttribute att = (RequestedTransportAttribute) obj;\n        if (att.getAttributeType()   != getAttributeType()\n                || att.getDataLength()   != getDataLength()\n                /* compare data */\n                || att.transportProtocol != transportProtocol\n           )\n            return false;\n\n        return true;\n    }\n\n    /**\n     * Returns the human readable name of this attribute. Attribute names do\n     * not really matter from the protocol point of view. They are only used\n     * for debugging and readability.\n     * @return this attribute's name.\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     * @return the length of this attribute's value (8 bytes).\n     */\n    @Override\n    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     * @return a binary representation of this attribute.\n     */\n    @Override\n    public byte[] encode()\n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = transportProtocol;\n        binValue[5] = 0x00;\n        binValue[6] = 0x00;\n        binValue[7] = 0x00;\n\n        return binValue;\n    }\n\n    /**\n     * Sets this attribute's fields according to attributeValue array.\n     * @param attributeValue a binary array containing this attribute's field\n     *                       values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *          offset is equal to the index of the first byte after\n     *          length)\n     * @param length the length of the binary array.\n     * @throws StunException if attrubteValue contains invalid data.\n     */\n    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        if (length != 4)\n        {\n            throw new StunException(\"length invalid\");\n        }\n\n        transportProtocol = attributeValue[offset];\n    }\n\n    /**\n     * Set the transport protocol.\n     * @param transportProtocol transport protocol\n     */\n    public void setRequestedTransport(byte transportProtocol)\n    {\n        this.transportProtocol = transportProtocol;\n    }\n\n    /**\n     * Get the transport protocol.\n     * @return transport protocol\n     */\n    public int getRequestedTransport()\n    {\n        return transportProtocol;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"REQUESTED-TRANSPORT\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"REQUESTED-TRANSPORT\"", "syntax_pass": true}, {"attribute_expression": "public static final char DATA_LENGTH = 4;", "docstring": "\nThe length of the data contained by this attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "DATA_LENGTH = 4", "syntax_pass": true}, {"attribute_expression": "public static final byte UDP = 17;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "UDP = 17", "syntax_pass": true}, {"attribute_expression": "public static final byte TCP = 6;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "TCP = 6", "syntax_pass": true}, {"attribute_expression": "byte transportProtocol = UDP;", "docstring": "\nTransport protocol.\n\n17 = UDP;\n6 = TCP.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "byte", "name": "transportProtocol = UDP", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/MappedAddressAttribute.java.MappedAddressAttribute", "name": "MappedAddressAttribute", "file_path": "src/main/java/org/ice4j/attribute/MappedAddressAttribute.java", "superclasses": "AddressAttribute", "methods": ["[]MappedAddressAttribute()"], "method_uris": ["src/main/java/org/ice4j/attribute/MappedAddressAttribute.java.MappedAddressAttribute.[]MappedAddressAttribute()"], "overrides": null, "attributes": [], "class_docstring": "\nThe MAPPED-ADDRESS attribute indicates the mapped IP address and\nport.  It consists of an eight bit address family, and a sixteen bit\nport, followed by a fixed length value representing the IP address.\n\n 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|x x x x x x x x|    Family     |           Port                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Address                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\nThe port is a network byte ordered representation of the mapped port.\nThe address family is always 0x01, corresponding to IPv4.  The first\n8 bits of the MAPPED-ADDRESS are ignored, for the purposes of\naligning parameters on natural boundaries.  The IPv4 address is 32\nbits.\n\n@author Emil Ivov\n", "original_string": "public class MappedAddressAttribute extends AddressAttribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"MAPPED-ADDRESS\";\n\n    /**\n     * Constructor.\n     */\n    MappedAddressAttribute()\n    {\n        super(MAPPED_ADDRESS);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"MAPPED-ADDRESS\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"MAPPED-ADDRESS\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute", "name": "OptionalAttribute", "file_path": "src/main/java/org/ice4j/attribute/OptionalAttribute.java", "superclasses": "Attribute", "methods": ["[]OptionalAttribute(char)", "[void]decodeAttributeBody(byte[],char,char)", "[byte[]]encode()", "[char]getDataLength()", "[String]getName()", "[byte[]]getBody()", "[void]setBody(byte[],int,int)", "[boolean]equals(Object)"], "method_uris": ["src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[]OptionalAttribute(char)", "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[byte[]]getBody()", "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[void]setBody(byte[],int,int)", "src/main/java/org/ice4j/attribute/OptionalAttribute.java.OptionalAttribute.[boolean]equals(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nThis class is used for representing attributes not explicitly supported by\nthe stack. Such attributes will generally be kept in  binary form and won't\nbe subdued to any processing by the stack. One could use this class for both\ndealing with attributes in received messages, and generating messages\ncontaining attributes not explicitly supported by the stack.\n\n@author Emil Ivov\n", "original_string": "public class OptionalAttribute\n    extends Attribute\n{\n    byte[] attributeValue = null;\n\n    protected OptionalAttribute(char attributeType)\n    {\n        super(attributeType);\n    }\n\n    /**\n     * Sets this attribute's fields according to attributeValue array.\n     *\n     * @param attributeValue a binary array containing this attribute's\n     *   field values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *   offset is equal to the index of the first byte after length)\n     * @param length the length of the binary array.\n     * @throws StunException if attrubteValue contains invalid data.\n     */\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        this.attributeValue = new byte[length];\n        System.arraycopy(attributeValue, offset, this.attributeValue, 0,\n                length);\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     *\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        char type = getAttributeType();\n\n        byte binValue[] = new byte[HEADER_LENGTH + attributeValue.length];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        System.arraycopy(attributeValue, 0,\n                         binValue, HEADER_LENGTH, attributeValue.length);\n\n        return binValue;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     *\n     * @return the length of this attribute's value.\n     */\n    public char getDataLength()\n    {\n        return (char)attributeValue.length;\n    }\n\n    /**\n     * Returns the human readable name of this attribute.\n     *\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return \"Unknown Attribute\";\n    }\n\n    /**\n     * Returns a reference to the unparsed body of this attribute.\n     *\n     * @return a reference to this attribute's unparsed value.\n     */\n    public byte[] getBody()\n    {\n        return attributeValue;\n    }\n\n    /**\n     * Copies the speicified byte array segment as the body of this attribute.\n     *\n     * @param body the body to copy\n     * @param offset the position to start\n     * @param length the length to copy\n     */\n    public void setBody(byte[] body, int offset, int length)\n    {\n        this.attributeValue = new byte[length];\n        System.arraycopy(body, offset, this.attributeValue, 0, length);\n    }\n\n    /**\n     * Compares two STUN Attributes. Two attributes are considered equal when they\n     * have the same type length and value.\n     *\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof OptionalAttribute) )\n            return false;\n\n        return\n            (obj == this\n             || Arrays.equals(((OptionalAttribute)obj).\n                              attributeValue, attributeValue));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "byte[] attributeValue = null;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "byte[]", "name": "attributeValue = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute", "name": "DataAttribute", "file_path": "src/main/java/org/ice4j/attribute/DataAttribute.java", "superclasses": "Attribute", "methods": ["[]DataAttribute()", "[]DataAttribute(boolean)", "[void]decodeAttributeBody(byte[],char,char)", "[byte[]]encode()", "[char]getDataLength()", "[String]getName()", "[byte[]]getData()", "[void]setData(byte[])", "[boolean]equals(Object)"], "method_uris": ["src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[]DataAttribute()", "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[]DataAttribute(boolean)", "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[byte[]]getData()", "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[void]setData(byte[])", "src/main/java/org/ice4j/attribute/DataAttribute.java.DataAttribute.[boolean]equals(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nThe DATA attribute contains the data the client wants to relay to the TURN\nserver or the TURN server to forward the response data.\n\nThe value of DATA is variable length.  Its length MUST be a\nmultiple of 4 (measured in bytes) in order to guarantee alignment of\nattributes on word boundaries.\n\n@author Sebastien Vincent\n", "original_string": "public class DataAttribute\n    extends Attribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"DATA\";\n\n    /**\n     * Data value.\n     */\n    private byte data[] = null;\n\n    /**\n     * Add padding.\n     *\n     * Some dialect does not add (and support) padding (GTalk).\n     */\n    private final boolean padding;\n\n    /**\n     * Creates a new instance of this class with padding enabled.\n     */\n    protected DataAttribute()\n    {\n        this(true);\n    }\n\n    /**\n     * Creates a new instance of this class.\n     * @param padding true to pad the data if the length is not on a word\n     * boundary.\n     */\n    protected DataAttribute(boolean padding)\n    {\n        super(DATA);\n\n        this.padding = padding;\n    }\n\n    /**\n     * Copies the value of the data attribute from the specified\n     * attributeValue.\n     * @param attributeValue a binary array containing this attribute's\n     *   field values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *   offset is equal to the index of the first byte after length)\n     * @param length the length of the binary array.\n     * @throws StunException if attributeValue contains invalid data.\n     */\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        data = new byte[length];\n          System.arraycopy(attributeValue, offset, data, 0, length);\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        char dataLength = getDataLength();\n        char type = getAttributeType();\n        byte binary[]\n            = new byte[\n                    HEADER_LENGTH\n                        + dataLength\n                        + (padding ? ((4 - dataLength % 4) % 4) : 0)];\n\n        //Type\n        binary[0] = (byte)(type >> 8);\n        binary[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binary[2] = (byte)(dataLength >> 8);\n        binary[3] = (byte)(dataLength & 0x00FF);\n\n        //data\n        System.arraycopy(data, 0, binary, 4, dataLength);\n\n        return binary;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     * @return the length of this attribute's value.\n     */\n    public char getDataLength()\n    {\n        return (char)data.length;\n    }\n\n    /**\n     * Returns the human readable name of this attribute.\n     *\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Returns a (cloned) byte array containing the data value of the data\n     * attribute.\n     * @return the binary array containing the data.\n     */\n    public byte[] getData()\n    {\n        return (data == null) ? null : data.clone();\n    }\n\n    /**\n     * Copies the specified binary array into the the data value of the data\n     * attribute.\n     *\n     * @param data the binary array containing the data.\n     */\n    public void setData(byte[] data)\n    {\n        if (data == null)\n        {\n            this.data = null;\n            return;\n        }\n\n        this.data = new byte[data.length];\n        System.arraycopy(data, 0, this.data, 0, data.length);\n    }\n\n    /**\n     * Compares two STUN Attributes. Two attributes are considered equal when\n     * they have the same type length and value.\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof DataAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        DataAttribute att = (DataAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                || !Arrays.equals( att.data, data))\n            return false;\n\n        return true;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"DATA\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"DATA\"", "syntax_pass": true}, {"attribute_expression": "private byte data[] = null;", "docstring": "\nData value.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte", "name": "data[] = null", "syntax_pass": true}, {"attribute_expression": "private final boolean padding;", "docstring": "\nAdd padding.\n\nSome dialect does not add (and support) padding (GTalk).\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "padding", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/ChangedAddressAttribute.java.ChangedAddressAttribute", "name": "ChangedAddressAttribute", "file_path": "src/main/java/org/ice4j/attribute/ChangedAddressAttribute.java", "superclasses": "AddressAttribute", "methods": ["[]ChangedAddressAttribute()"], "method_uris": ["src/main/java/org/ice4j/attribute/ChangedAddressAttribute.java.ChangedAddressAttribute.[]ChangedAddressAttribute()"], "overrides": null, "attributes": [], "class_docstring": "\nThe CHANGED-ADDRESS attribute indicates the IP address and port where\nresponses would have been sent from if the \"change IP\" and \"change\nport\" flags had been set in the CHANGE-REQUEST attribute of the\nBinding Request.  The attribute is always present in a Binding\nResponse, independent of the value of the flags.  Its syntax is\nidentical to MAPPED-ADDRESS.\n\n@author Emil Ivov\n", "original_string": "public class ChangedAddressAttribute extends AddressAttribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"CHANGED-ADDRESS\";\n\n    /**\n     * Creates a CHANGED_ADDRESS attribute\n     */\n    public ChangedAddressAttribute()\n    {\n        super(CHANGED_ADDRESS);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"CHANGED-ADDRESS\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"CHANGED-ADDRESS\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute", "name": "UseCandidateAttribute", "file_path": "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java", "superclasses": "Attribute", "methods": ["[]UseCandidateAttribute()", "[void]decodeAttributeBody(byte[],char,char)", "[byte[]]encode()", "[boolean]equals(Object)", "[char]getDataLength()", "[String]getName()"], "method_uris": ["src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute.[]UseCandidateAttribute()", "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/UseCandidateAttribute.java.UseCandidateAttribute.[String]getName()"], "overrides": null, "attributes": [], "class_docstring": "\nThis class implements the USE-CANDIDATE attribute\nThis attribute is an extension to the original STUN protocol\nThis is used only during an ICE implementation\n\nThis attribute serves as only a flag, it does not have any data\nso the data length is zero\n", "original_string": "public class UseCandidateAttribute\n    extends Attribute\n{\n    /**\n     * Data length.\n     */\n    private static final char DATA_LENGTH_USE_CANDIDATE = 0;\n\n    /**\n     * Constructor.\n     */\n    protected UseCandidateAttribute()\n    {\n        super(USE_CANDIDATE);\n    }\n\n    /**\n     * Decodes the USE-CANDIDATE attribute's body, which is empty\n     *\n     * @param attributeValue a binary array containing this attribute's\n     *   field values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *   offset is equal to the index of the first byte after length)\n     * @param length the length of the binary array.\n     * @throws StunException if attrubteValue contains invalid data.\n     */\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n            throws StunException\n    {\n        // Do nothing, empty attribute body\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     *\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte[] binValue = new byte[HEADER_LENGTH + DATA_LENGTH_USE_CANDIDATE];\n\n        // Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        // Length\n        binValue[2] = (byte)(DATA_LENGTH_USE_CANDIDATE >> 8);\n        binValue[3] = (byte)(DATA_LENGTH_USE_CANDIDATE & 0x00FF);\n\n        return binValue;\n    }\n\n    /**\n     * Compares two STUN Attributes. Two attributes are considered equal when\n     * they have the same type, length and value.\n     *\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (!(obj instanceof UseCandidateAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        UseCandidateAttribute useCandidateAtt = (UseCandidateAttribute)obj;\n        if (useCandidateAtt.getAttributeType() != getAttributeType()\n            || useCandidateAtt.getDataLength() != getDataLength())\n            return false;\n\n        return true;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     *\n     * @return the length of this attribute's value.\n     */\n    public char getDataLength()\n    {\n        return DATA_LENGTH_USE_CANDIDATE;\n    }\n\n    /**\n     * Returns the human readable name of this attribute.\n     *\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return \"USE-CANDIDATE\";\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final char DATA_LENGTH_USE_CANDIDATE = 0;", "docstring": "\nData length.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "DATA_LENGTH_USE_CANDIDATE = 0", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute", "name": "NonceAttribute", "file_path": "src/main/java/org/ice4j/attribute/NonceAttribute.java", "superclasses": "Attribute", "methods": ["[]NonceAttribute()", "[void]decodeAttributeBody(byte[],char,char)", "[byte[]]encode()", "[char]getDataLength()", "[String]getName()", "[byte[]]getNonce()", "[void]setNonce(byte[])", "[boolean]equals(Object)"], "method_uris": ["src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[]NonceAttribute()", "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[byte[]]getNonce()", "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[void]setNonce(byte[])", "src/main/java/org/ice4j/attribute/NonceAttribute.java.NonceAttribute.[boolean]equals(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nThe NONCE attribute is used for authentication.\n\n@author Sebastien Vincent\n", "original_string": "public class NonceAttribute extends Attribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"NONCE\";\n\n    /**\n     * Nonce value.\n     */\n    private byte nonce[] = null;\n\n    /**\n     * Constructor.\n     */\n    NonceAttribute()\n    {\n        super(NONCE);\n    }\n\n    /**\n     * Copies the value of the nonce attribute from the specified\n     * attributeValue.\n     * @param attributeValue a binary array containing this attribute's\n     *   field values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *   offset is equal to the index of the first byte after length)\n     * @param length the length of the binary array.\n     * @throws StunException if attributeValue contains invalid data.\n     */\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        nonce = new byte[length];\n        System.arraycopy(attributeValue, offset, nonce, 0, length);\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte binValue[]\n            = new byte[HEADER_LENGTH + getDataLength() + (getDataLength() % 4)];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        /* nonce */\n        System.arraycopy(nonce, 0, binValue, 4, (int)getDataLength());\n\n        return binValue;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     * @return the length of this attribute's value.\n     */\n    public char getDataLength()\n    {\n        return (char)nonce.length;\n    }\n\n    /**\n     * Returns the human readable name of this attribute.\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Returns a (cloned) byte array containing the data value of the nonce\n     * attribute.\n     * @return the binary array containing the nonce.\n     */\n    public byte[] getNonce()\n    {\n        return (nonce == null) ? null : nonce.clone();\n    }\n\n    /**\n     * Copies the specified binary array into the the data value of the nonce\n     * attribute.\n     * @param nonce the binary array containing the nonce.\n     */\n    public void setNonce(byte[] nonce)\n    {\n        this.nonce = (nonce == null) ? null : nonce.clone();\n    }\n\n    /**\n     * Compares two STUN Attributes. Two attributes are considered equal when they\n     * have the same type length and value.\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (obj == this)\n            return true;\n        if (! (obj instanceof NonceAttribute))\n            return false;\n\n        NonceAttribute att = (NonceAttribute) obj;\n\n        return\n            (att.getAttributeType() == getAttributeType()\n                && att.getDataLength() == getDataLength()\n                && Arrays.equals(att.nonce, nonce));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"NONCE\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"NONCE\"", "syntax_pass": true}, {"attribute_expression": "private byte nonce[] = null;", "docstring": "\nNonce value.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte", "name": "nonce[] = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/AttributeDecoder.java.AttributeDecoder", "name": "AttributeDecoder", "file_path": "src/main/java/org/ice4j/attribute/AttributeDecoder.java", "superclasses": "", "methods": ["[Attribute]decode(byte[],int,int)"], "method_uris": ["src/main/java/org/ice4j/attribute/AttributeDecoder.java.AttributeDecoder.[Attribute]decode(byte[],int,int)"], "overrides": null, "attributes": [], "class_docstring": "\nThe class provides utilities for decoding a binary stream into an Attribute\nclass.\n\n@author Emil Ivov\n@author Sebastien Vincent\n@author Aakash Garg\n", "original_string": "public class AttributeDecoder\n{\n    /**\n     * Decodes the specified binary array and returns the corresponding\n     * attribute object.\n     *\n     * @param bytes the binary array that should be decoded.\n     * @param offset the index where the message starts.\n     * @param length the number of bytes that the message is long.\n     *\n     * @return An object representing the attribute encoded in bytes or null if\n     * the attribute was not recognized.\n     *\n     * @throws StunException if bytes is not a valid STUN attribute.\n     */\n    public static Attribute decode(byte[] bytes,\n                                   int   offset,\n                                   int   length)\n        throws StunException\n    {\n        if (bytes == null || bytes.length < Attribute.HEADER_LENGTH)\n        {\n            throw new StunException( StunException.ILLEGAL_ARGUMENT,\n                         \"Could not decode the specified binary array.\");\n        }\n\n        //Discover attribute type\n        char attributeType = (char)\n            (((bytes[offset] & 0xFF) << 8) | (bytes[offset + 1] & 0xFF));\n        char attributeLength = (char)\n            (((bytes[offset + 2] & 0xFF) << 8) | (bytes[offset + 3] & 0xFF));\n\n        if (attributeLength > bytes.length - offset )\n            throw new StunException( StunException.ILLEGAL_ARGUMENT,\n                            \"Could not decode the specified binary array.\");\n\n        Attribute decodedAttribute = null;\n\n        switch(attributeType)\n        {\n            /* STUN attributes */\n            case Attribute.CHANGE_REQUEST:\n                decodedAttribute = new ChangeRequestAttribute(); break;\n            case Attribute.CHANGED_ADDRESS:\n                decodedAttribute = new ChangedAddressAttribute(); break;\n            case Attribute.MAPPED_ADDRESS:\n                decodedAttribute = new MappedAddressAttribute(); break;\n            case Attribute.ERROR_CODE:\n                decodedAttribute = new ErrorCodeAttribute(); break;\n            case Attribute.MESSAGE_INTEGRITY:\n                decodedAttribute = new MessageIntegrityAttribute(); break;\n            //case Attribute.PASSWORD: //handle as an unknown attribute\n            case Attribute.REFLECTED_FROM:\n                decodedAttribute = new ReflectedFromAttribute(); break;\n            case Attribute.RESPONSE_ADDRESS:\n                decodedAttribute = new ResponseAddressAttribute(); break;\n            case Attribute.SOURCE_ADDRESS:\n                decodedAttribute = new SourceAddressAttribute(); break;\n            case Attribute.UNKNOWN_ATTRIBUTES:\n                decodedAttribute = new UnknownAttributesAttribute(); break;\n            case Attribute.XOR_MAPPED_ADDRESS:\n                decodedAttribute = new XorMappedAddressAttribute(); break;\n            case Attribute.XOR_ONLY:\n                decodedAttribute = new XorOnlyAttribute(); break;\n            case Attribute.SOFTWARE:\n                decodedAttribute = new SoftwareAttribute(); break;\n            case Attribute.USERNAME:\n                decodedAttribute = new UsernameAttribute(); break;\n            case Attribute.REALM:\n                decodedAttribute = new RealmAttribute(); break;\n            case Attribute.NONCE:\n                decodedAttribute = new NonceAttribute(); break;\n            case Attribute.FINGERPRINT:\n                decodedAttribute = new FingerprintAttribute(); break;\n            case Attribute.ALTERNATE_SERVER:\n                decodedAttribute = new AlternateServerAttribute(); break;\n            case Attribute.CHANNEL_NUMBER:\n                decodedAttribute = new ChannelNumberAttribute(); break;\n            case Attribute.LIFETIME:\n                decodedAttribute = new LifetimeAttribute(); break;\n            case Attribute.XOR_PEER_ADDRESS:\n                decodedAttribute = new XorPeerAddressAttribute(); break;\n            case Attribute.DATA:\n                decodedAttribute = new DataAttribute(); break;\n            case Attribute.XOR_RELAYED_ADDRESS:\n                decodedAttribute = new XorRelayedAddressAttribute(); break;\n            case Attribute.EVEN_PORT:\n                decodedAttribute = new EvenPortAttribute(); break;\n            case Attribute.REQUESTED_TRANSPORT:\n                decodedAttribute = new RequestedTransportAttribute(); break;\n            case Attribute.DONT_FRAGMENT:\n                decodedAttribute = new DontFragmentAttribute(); break;\n            case Attribute.RESERVATION_TOKEN:\n                decodedAttribute = new ReservationTokenAttribute(); break;\n            case Attribute.PRIORITY:\n                decodedAttribute = new PriorityAttribute(); break;\n            case Attribute.ICE_CONTROLLING:\n                decodedAttribute = new IceControllingAttribute(); break;\n            case Attribute.ICE_CONTROLLED:\n                decodedAttribute = new IceControlledAttribute(); break;\n            case Attribute.USE_CANDIDATE:\n                decodedAttribute = new UseCandidateAttribute(); break;\n            case Attribute.REQUESTED_ADDRESS_FAMILY:\n                decodedAttribute = new RequestedAddressFamilyAttribute(); break;\n            case Attribute.CONNECTION_ID:\n                decodedAttribute = new ConnectionIdAttribute(); break;\n            //According to rfc3489 we should silently ignore unknown attributes.\n            default: decodedAttribute\n                = new OptionalAttribute( Attribute.UNKNOWN_OPTIONAL_ATTRIBUTE);\n                break;\n        }\n\n        decodedAttribute.setAttributeType(attributeType);\n        decodedAttribute.setLocationInMessage(offset);\n\n        decodedAttribute.decodeAttributeBody(bytes,\n                (char)(Attribute.HEADER_LENGTH + offset), attributeLength);\n\n        return decodedAttribute;\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/ice4j/attribute/ResponseAddressAttribute.java.ResponseAddressAttribute", "name": "ResponseAddressAttribute", "file_path": "src/main/java/org/ice4j/attribute/ResponseAddressAttribute.java", "superclasses": "AddressAttribute", "methods": ["[]ResponseAddressAttribute()"], "method_uris": ["src/main/java/org/ice4j/attribute/ResponseAddressAttribute.java.ResponseAddressAttribute.[]ResponseAddressAttribute()"], "overrides": null, "attributes": [], "class_docstring": "\nThe RESPONSE-ADDRESS attribute indicates where the response to a\nBinding Request should be sent.  Its syntax is identical to MAPPED-\nADDRESS.\n\n@author Emil Ivov\n", "original_string": "public class ResponseAddressAttribute extends AddressAttribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"RESPONSE-ADDRESS\";\n\n    /**\n     * Creates a RESPONSE_ADDRESS attribute\n     */\n    public ResponseAddressAttribute()\n    {\n        super(RESPONSE_ADDRESS);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"RESPONSE-ADDRESS\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"RESPONSE-ADDRESS\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/AlternateServerAttribute.java.AlternateServerAttribute", "name": "AlternateServerAttribute", "file_path": "src/main/java/org/ice4j/attribute/AlternateServerAttribute.java", "superclasses": "AddressAttribute", "methods": ["[]AlternateServerAttribute()"], "method_uris": ["src/main/java/org/ice4j/attribute/AlternateServerAttribute.java.AlternateServerAttribute.[]AlternateServerAttribute()"], "overrides": null, "attributes": [], "class_docstring": "\nThe ALTERNATE-SERVER attribute indicates the IP address and\nport of an alternate server the client could use. For example,\nalternate servers may contains special capabilities.\n\nIt consists of an eight bit address family, and a sixteen bit\nport, followed by a fixed length value representing the IP address.\n\n 0                   1                   2                   3\n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|x x x x x x x x|    Family     |           Port                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Address                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\nThe port is a network byte ordered representation of the mapped port.\nThe address family is always 0x01, corresponding to IPv4.  The first\n8 bits of the ALTERNATE-SERVER are ignored, for the purposes of\naligning parameters on natural boundaries.  The IPv4 address is 32\nbits.\n\n@author Sebastien Vincent\n", "original_string": "public class AlternateServerAttribute extends AddressAttribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"ALTERNATE-SERVER\";\n\n    /**\n     * Constructor.\n     */\n    AlternateServerAttribute()\n    {\n        super(ALTERNATE_SERVER);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"ALTERNATE-SERVER\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"ALTERNATE-SERVER\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute", "name": "ChannelNumberAttribute", "file_path": "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java", "superclasses": "Attribute", "methods": ["[]ChannelNumberAttribute()", "[boolean]equals(Object)", "[String]getName()", "[char]getDataLength()", "[byte[]]encode()", "[void]decodeAttributeBody(byte[],char,char)", "[void]setChannelNumber(char)", "[char]getChannelNumber()", "[boolean]isValidRange(char)"], "method_uris": ["src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[]ChannelNumberAttribute()", "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[void]setChannelNumber(char)", "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[char]getChannelNumber()", "src/main/java/org/ice4j/attribute/ChannelNumberAttribute.java.ChannelNumberAttribute.[boolean]isValidRange(char)"], "overrides": null, "attributes": [], "class_docstring": "\nThe CHANNEL-NUMBER attribute is used to known on which\nchannel the TURN client want to send data.\n\n@author Sebastien Vincent\n@author Aakash Garg\n", "original_string": "public class ChannelNumberAttribute extends Attribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"CHANNEL-NUMBER\";\n\n    /**\n     * The length of the data contained by this attribute.\n     */\n    public static final char DATA_LENGTH = 4;\n\n    /**\n     * Channel number.\n     */\n    private char channelNumber = 0;\n\n    /**\n     * Constructor.\n     */\n    ChannelNumberAttribute()\n    {\n        super(CHANNEL_NUMBER);\n    }\n\n    /**\n     * Compares two STUN Attributes. Attributes are considered equal when their\n     * type, length, and all data are the same.\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    @Override\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof ChannelNumberAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        ChannelNumberAttribute att = (ChannelNumberAttribute) obj;\n        if (att.getAttributeType()   != getAttributeType()\n                || att.getDataLength()   != getDataLength()\n                /* compare data */\n                || att.channelNumber != channelNumber\n           )\n            return false;\n\n        return true;\n    }\n\n    /**\n     * Returns the human readable name of this attribute. Attribute names do\n     * not really matter from the protocol point of view. They are only used\n     * for debugging and readability.\n     * @return this attribute's name.\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     * @return the length of this attribute's value (8 bytes).\n     */\n    @Override\n    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     * @return a binary representation of this attribute.\n     */\n    @Override\n    public byte[] encode()\n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = (byte)((channelNumber >> 8) & 0xff);\n        binValue[5] = (byte)((channelNumber) & 0xff);\n        binValue[6] = 0x00;\n        binValue[7] = 0x00;\n\n        return binValue;\n    }\n\n    /**\n     * Sets this attribute's fields according to attributeValue array.\n     * @param attributeValue a binary array containing this attribute's field\n     *                       values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *          offset is equal to the index of the first byte after\n     *          length)\n     * @param length the length of the binary array.\n     * @throws StunException if attrubteValue contains invalid data.\n     */\n    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        if (length != 4)\n        {\n            throw new StunException(\"length invalid\");\n        }\n\n        channelNumber =\n            ((char) ((attributeValue[offset] << 8) \n                | (attributeValue[offset + 1] & 0xFF)));\n    }\n\n    /**\n     * Set the channel number.\n     * @param channelNumber channel number\n     */\n    public void setChannelNumber(char channelNumber)\n    {\n        this.channelNumber = channelNumber;\n    }\n\n    /**\n     * Get the channel number.\n     * @return channel number\n     */\n    public char getChannelNumber()\n    {\n        return channelNumber;\n    }\n    \n    /**\n     * Determines if the channelNo is in valid range.\n     * @param channelNo the channelNo to validate.\n     * @return true if channnelNo is &gt;= 0x4000.\n     */\n    public static boolean isValidRange(char channelNo)\n    {\n        if (channelNo >= 0x4000)\n        {\n            return true;\n        }\n        return false;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"CHANNEL-NUMBER\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"CHANNEL-NUMBER\"", "syntax_pass": true}, {"attribute_expression": "public static final char DATA_LENGTH = 4;", "docstring": "\nThe length of the data contained by this attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "DATA_LENGTH = 4", "syntax_pass": true}, {"attribute_expression": "private char channelNumber = 0;", "docstring": "\nChannel number.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "char", "name": "channelNumber = 0", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute", "name": "ConnectionIdAttribute", "file_path": "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java", "superclasses": "Attribute", "methods": ["[]ConnectionIdAttribute()", "[char]getDataLength()", "[String]getName()", "[boolean]equals(Object)", "[byte[]]encode()", "[void]decodeAttributeBody(byte[],char,char)", "[int]getConnectionIdValue()", "[void]setConnectionIdValue(int)"], "method_uris": ["src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[]ConnectionIdAttribute()", "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[int]getConnectionIdValue()", "src/main/java/org/ice4j/attribute/ConnectionIdAttribute.java.ConnectionIdAttribute.[void]setConnectionIdValue(int)"], "overrides": null, "attributes": [], "class_docstring": "\nThe connection ID attribute defined in RFC 6062:\nTraversal Using Relays around NAT (TURN) Extensions for TCP Allocations.\n\n@author Aakash Garg\n", "original_string": "public class ConnectionIdAttribute\n    extends Attribute\n{\n   /**\n    * Attribute Name.\n   */\n    public static final String NAME  = \"CONNECTION-ID\";\n    \n    /**\n     * The length of the data contained in this attribute.\n     */\n    public static final char DATA_LENGTH = 4;\n\n    /**\n     * The connection Id value.\n     */\n    private int connectionIdValue;\n     \n    /**\n     * Constructor.\n     */\n    protected ConnectionIdAttribute() \n    {\n        super(CONNECTION_ID);\n    }\n\n    /**\n     * Returns the length of this attribute body.\n     * @return the length of this attribute value (4 bytes).\n     */\n    @Override\n    public char getDataLength() \n    {\n        return DATA_LENGTH;\n    }\n\n    /**\n     * Returns the human readable name of this attribute. Attribute names do\n     * not really matter from the protocol point of view. They are only used\n     * for debugging and readability.\n     * @return this attribute's name.\n     */\n    @Override\n    public String getName() \n    {\n        return NAME;\n    }\n\n    /**\n     * Compares two TURN Attributes. Attributes are considered equal when their\n     * type, length, and all data are the same.\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    @Override\n    public boolean equals(Object obj) \n    {\n        if (! (obj instanceof ConnectionIdAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        ConnectionIdAttribute att = (ConnectionIdAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                /* compare data */\n                || att.connectionIdValue != this.connectionIdValue\n           )\n            return false;\n\n        return true;\n    }\n\n    /**\n    * Returns a binary representation of this attribute.\n    * @return a binary representation of this attribute.\n    */\n    @Override\n    public byte[] encode() \n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = (byte) (connectionIdValue >> 24);\n        binValue[5] = (byte) ((connectionIdValue & 0x00ff0000) >> 16);\n        binValue[6] = (byte) ((connectionIdValue & 0x0000ff00) >> 8);\n        binValue[7] = (byte) (connectionIdValue & 0x000000ff);\n\n        return binValue;\n    }\n\n   /**\n    * Sets this attribute's fields according to attributeValue array.\n    * @param attributeValue a binary array containing this attribute's field\n    *                       values and NOT containing the attribute header.\n    * @param offset the position where attribute values begin (most often\n    *          offset is equal to the index of the first byte after\n    *          length)\n    * @param length the length of the binary array.\n    * @throws StunException if attributeValue contains invalid data.\n    */\n    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length) \n        throws StunException\n    {\n        if (length != DATA_LENGTH)\n        {\n            throw new StunException(\"length invalid: \" + length);\n        }\n\n        connectionIdValue = attributeValue[offset] & 0xff;\n\n        connectionIdValue = connectionIdValue << 8 |\n            (attributeValue[offset+1] & 0xff);\n\n        connectionIdValue = connectionIdValue << 8 |\n            (attributeValue[offset+2] & 0xff);\n\n        connectionIdValue = connectionIdValue << 8 |\n            (attributeValue[offset+3] & 0xff);\n    }\n\n    /**\n     * Gets the Connection-Id Value\n     * @return Connection-Id Value\n     */\n    public int getConnectionIdValue() \n    {\n        return connectionIdValue;\n    }\n    \n    /**\n     * Sets the Connection-Id Value\n     * @param connectionIdValue the connection Id value.\n     */\n    public void setConnectionIdValue(int connectionIdValue) \n    {    \n        this.connectionIdValue = connectionIdValue;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME  = \"CONNECTION-ID\";", "docstring": "\nAttribute Name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME  = \"CONNECTION-ID\"", "syntax_pass": true}, {"attribute_expression": "public static final char DATA_LENGTH = 4;", "docstring": "\nThe length of the data contained in this attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "DATA_LENGTH = 4", "syntax_pass": true}, {"attribute_expression": "private int connectionIdValue;", "docstring": "\nThe connection Id value.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "connectionIdValue", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/XorPeerAddressAttribute.java.XorPeerAddressAttribute", "name": "XorPeerAddressAttribute", "file_path": "src/main/java/org/ice4j/attribute/XorPeerAddressAttribute.java", "superclasses": "XorMappedAddressAttribute", "methods": ["[]XorPeerAddressAttribute()"], "method_uris": ["src/main/java/org/ice4j/attribute/XorPeerAddressAttribute.java.XorPeerAddressAttribute.[]XorPeerAddressAttribute()"], "overrides": null, "attributes": [], "class_docstring": "\nThe XOR-PEER-ADDRESS attribute is given by a TURN client to\nindicates the peer destination address of its relayed packet.\n\nIt has the same format as XOR-MAPPED-ADDRESS.\n\n@author Sebastien Vincent\n", "original_string": "public class XorPeerAddressAttribute extends XorMappedAddressAttribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"XOR-PEER-ADDRESS\";\n\n    /**\n     * Constructor.\n     */\n    XorPeerAddressAttribute()\n    {\n        super(XOR_PEER_ADDRESS);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"XOR-PEER-ADDRESS\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"XOR-PEER-ADDRESS\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute", "name": "MagicCookieAttribute", "file_path": "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java", "superclasses": "Attribute", "methods": ["[]MagicCookieAttribute()", "[String]getName()", "[char]getDataLength()", "[boolean]equals(Object)", "[byte[]]encode()", "[void]decodeAttributeBody(byte[],char,char)"], "method_uris": ["src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute.[]MagicCookieAttribute()", "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/MagicCookieAttribute.java.MagicCookieAttribute.[void]decodeAttributeBody(byte[],char,char)"], "overrides": null, "attributes": [], "class_docstring": "\nThe MAGIC-COOKIE attribute.\n\nIt is used with old version of TURN (Google, Live messenger variant, ...).\n\n@author Sebastien Vincent\n", "original_string": "public class MagicCookieAttribute\n    extends Attribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"MAGIC-COOKIE\";\n\n    /**\n     * The length of the data contained by this attribute.\n     */\n    public static final char DATA_LENGTH = 4;\n\n    /**\n     * Magic cookie value.\n     */\n    private int value = 0x72c64bc6;\n\n    /**\n     * Constructor.\n     */\n    MagicCookieAttribute()\n    {\n        super(MAGIC_COOKIE);\n    }\n\n    /**\n     * Returns the human readable name of this attribute. Attribute names do\n     * not really matter from the protocol point of view. They are only used\n     * for debugging and readability.\n     *\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     *\n     * @return the length of this attribute's value (8 bytes).\n     */\n    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }\n\n    /**\n     * Compares two STUN Attributes. Attributes are considered equal when their\n     * type, length, and all data are the same.\n     *\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof MagicCookieAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        MagicCookieAttribute att = (MagicCookieAttribute) obj;\n        if (att.getAttributeType()   != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                /* compare data */\n                || att.value != value\n           )\n            return false;\n\n        return true;\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     *\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = (byte)((value >> 24) & 0xff);\n        binValue[5] = (byte)((value >> 16) & 0xff);\n        binValue[6] = (byte)((value >> 8) & 0xff);\n        binValue[7] = (byte)((value) & 0xff);\n\n        return binValue;\n    }\n\n    /**\n     * Sets this attribute's fields according to attributeValue array.\n     *\n     * @param attributeValue a binary array containing this attribute's field\n     *                       values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *          offset is equal to the index of the first byte after\n     *          length)\n     * @param length the length of the binary array.\n     * @throws StunException if attrubteValue contains invalid data.\n     */\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n            throws StunException\n    {\n        if (length != 4)\n        {\n            throw new StunException(\"length invalid\");\n        }\n\n        value = ((attributeValue[0] << 24) & 0xff000000) +\n            ((attributeValue[1] << 16) & 0x00ff0000) +\n            ((attributeValue[2] << 8) & 0x0000ff00) +\n            (attributeValue[3] & 0x000000ff);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"MAGIC-COOKIE\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"MAGIC-COOKIE\"", "syntax_pass": true}, {"attribute_expression": "public static final char DATA_LENGTH = 4;", "docstring": "\nThe length of the data contained by this attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "DATA_LENGTH = 4", "syntax_pass": true}, {"attribute_expression": "private int value = 0x72c64bc6;", "docstring": "\nMagic cookie value.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "value = 0x72c64bc6", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute", "name": "DontFragmentAttribute", "file_path": "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java", "superclasses": "Attribute", "methods": ["[]DontFragmentAttribute()", "[boolean]equals(Object)", "[String]getName()", "[char]getDataLength()", "[byte[]]encode()", "[void]decodeAttributeBody(byte[],char,char)"], "method_uris": ["src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute.[]DontFragmentAttribute()", "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/DontFragmentAttribute.java.DontFragmentAttribute.[void]decodeAttributeBody(byte[],char,char)"], "overrides": null, "attributes": [], "class_docstring": "\nThe DONT-FRAGMENT attribute is used to inform TURN\nserver (if it supports this attribute) that it should set DF bit to 1\nin IPv4 headers when relaying client data.\n\n@author Sebastien Vincent\n", "original_string": "public class DontFragmentAttribute extends Attribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"DONT-FRAGMENT\";\n\n    /**\n     * The length of the data contained by this attribute.\n     */\n    public static final char DATA_LENGTH = 0;\n\n    /**\n     * Constructor.\n     */\n    DontFragmentAttribute()\n    {\n        super(DONT_FRAGMENT);\n    }\n\n    /**\n     * Compares two STUN Attributes. Attributes are considered equal when their\n     * type, length, and all data are the same.\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof DontFragmentAttribute))\n            return false;\n\n        return true;\n    }\n\n    /**\n     * Returns the human readable name of this attribute. Attribute names do\n     * not really matter from the protocol point of view. They are only used\n     * for debugging and readability.\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     * @return the length of this attribute's value (8 bytes).\n     */\n    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        /* there is no data */\n        byte binValue[] = new byte[HEADER_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        return binValue;\n    }\n\n    /**\n     * Sets this attribute's fields according to attributeValue array.\n     * @param attributeValue a binary array containing this attribute's field\n     *                       values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *          offset is equal to the index of the first byte after\n     *          length)\n     * @param length the length of the binary array.\n     * @throws StunException if attrubteValue contains invalid data.\n     */\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        if (length != 0)\n        {\n            throw new StunException(\"length invalid\");\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"DONT-FRAGMENT\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"DONT-FRAGMENT\"", "syntax_pass": true}, {"attribute_expression": "public static final char DATA_LENGTH = 0;", "docstring": "\nThe length of the data contained by this attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "DATA_LENGTH = 0", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute", "name": "FingerprintAttribute", "file_path": "src/main/java/org/ice4j/attribute/FingerprintAttribute.java", "superclasses": "Attribute", "methods": ["[]FingerprintAttribute()", "[byte[]]getChecksum()", "[char]getDataLength()", "[String]getName()", "[boolean]equals(Object)", "[byte[]]encode()", "[byte[]]encode(StunStack,byte[],int,int)", "[void]decodeAttributeBody(byte[],char,char)", "[byte[]]calculateXorCRC32(byte[],int,int)"], "method_uris": ["src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[]FingerprintAttribute()", "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[byte[]]getChecksum()", "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[byte[]]encode(StunStack,byte[],int,int)", "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/FingerprintAttribute.java.FingerprintAttribute.[byte[]]calculateXorCRC32(byte[],int,int)"], "overrides": null, "attributes": [], "class_docstring": "\nThe FINGERPRINT attribute is used to distinguish STUN packets from packets\nof other protocols. It MAY be present in all STUN messages.  The\nvalue of the attribute is computed as the CRC-32 of the STUN message\nup to (but excluding) the FINGERPRINT attribute itself, XOR'ed with\nthe 32-bit value 0x5354554e (the XOR helps in cases where an\napplication packet is also using CRC-32 in it).  The 32-bit CRC is\nthe one defined in ITU V.42 [ITU.V42.2002], which has a generator\npolynomial of x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1.\nWhen present, the FINGERPRINT attribute MUST be the last attribute in\nthe message, and thus will appear after MESSAGE-INTEGRITY.\n<p>\nThe FINGERPRINT attribute can aid in distinguishing STUN packets from\npackets of other protocols.  See Section 8.\n<p>\nAs with MESSAGE-INTEGRITY, the CRC used in the FINGERPRINT attribute\ncovers the length field from the STUN message header.  Therefore,\nthis value must be correct and include the CRC attribute as part of\nthe message length, prior to computation of the CRC.  When using the\nFINGERPRINT attribute in a message, the attribute is first placed\ninto the message with a dummy value, then the CRC is computed, and\nthen the value of the attribute is updated.  If the MESSAGE-INTEGRITY\nattribute is also present, then it must be present with the correct\nmessage-integrity value before the CRC is computed, since the CRC is\ndone over the value of the MESSAGE-INTEGRITY attribute as well.\n\n@author Sebastien Vincent\n@author Emil Ivov\n", "original_string": "public class FingerprintAttribute\n    extends Attribute\n    implements ContentDependentAttribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"FINGERPRINT\";\n\n    /**\n     * The value that we need to XOR the CRC with. The XOR helps in cases where\n     * an application packet is also using CRC-32 in it).\n     */\n    public static final byte[] XOR_MASK = { 0x53, 0x54, 0x55, 0x4e};\n\n    /**\n     * The CRC32 checksum that this attribute is carrying. Only used in incoming\n     * messages.\n     */\n    private byte[] crc;\n\n    /**\n     * Creates a <tt>FingerPrintAttribute</tt> instance.\n     */\n    FingerprintAttribute()\n    {\n        super(FINGERPRINT);\n    }\n\n    /**\n     * Returns the CRC32 checksum that this attribute is carrying. Only makes\n     * sense for incoming messages and hence only set for them.\n     *\n     * @return the CRC32 checksum that this attribute is carrying or\n     * <tt>null</tt> if it has not been set.\n     */\n    public byte[] getChecksum()\n    {\n        return crc;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     *\n     * @return the length of this attribute's value.\n     */\n    public char getDataLength()\n    {\n        return 4;\n    }\n\n    /**\n     * Returns the human readable name of this attribute.\n     *\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Compares two STUN Attributes. Two attributes are considered equal when\n     * they have the same type length and value.\n     *\n     * @param obj the object to compare this attribute with.\n     *\n     * @return true if the attributes are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof FingerprintAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        FingerprintAttribute att = (FingerprintAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength())\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     *\n     * @return nothing\n     * @throws UnsupportedOperationException since {@link\n     * ContentDependentAttribute}s should be encoded through the content\n     * dependent encode method.\n     */\n    public byte[] encode()\n        throws UnsupportedOperationException\n    {\n        throw new UnsupportedOperationException(\n                        \"ContentDependentAttributes should be encoded \"\n                        + \"through the contend-dependent encode method\");\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     *\n     * @param stunStack the <tt>StunStack</tt> in the context of which the\n     * request to encode this <tt>ContentDependentAttribute</tt> is being made\n     * @param content the content of the message that this attribute will be\n     * transported in\n     * @param offset the <tt>content</tt>-related offset where the actual\n     * content starts.\n     * @param length the length of the content in the <tt>content</tt> array.\n     *\n     * @return a binary representation of this attribute valid for the message\n     * with the specified <tt>content</tt>.\n     */\n    public byte[] encode(\n            StunStack stunStack,\n            byte[] content, int offset, int length)\n    {\n        char type = getAttributeType();\n        byte binValue[] = new byte[HEADER_LENGTH + getDataLength()];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        //calculate the check sum\n        byte[] xorCrc32 = calculateXorCRC32(content, offset, length);\n\n        //copy into the attribute;\n        binValue[4] = xorCrc32[0];\n        binValue[5] = xorCrc32[1];\n        binValue[6] = xorCrc32[2];\n        binValue[7] = xorCrc32[3];\n\n        return binValue;\n    }\n\n    /**\n     * Sets this attribute's fields according to the message and attributeValue\n     * arrays.\n     *\n     * @param attributeValue a binary array containing this attribute's field\n     * values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     * offset is equal to the index of the first byte after length)\n     * @param length the length of the binary array.\n     * the start of this attribute.\n     *\n     * @throws StunException if attrubteValue contains invalid data.\n     */\n    public void decodeAttributeBody( byte[] attributeValue,\n                                     char offset,\n                                     char length)\n        throws StunException\n    {\n        if (length != 4)\n        {\n            throw new StunException(\"length invalid\");\n        }\n\n        byte[] incomingCrcBytes = new byte[4];\n\n        incomingCrcBytes[0] = attributeValue[offset];\n        incomingCrcBytes[1] = attributeValue[offset + 1];\n        incomingCrcBytes[2] = attributeValue[offset + 2];\n        incomingCrcBytes[3] = attributeValue[offset + 3];\n\n        this.crc = incomingCrcBytes;\n    }\n\n    /**\n     * Calculates and returns the CRC32 checksum for <tt>message</tt> after\n     * applying the <tt>XOR_MASK</tt> specified by RFC 5389.\n     *\n     * @param message the message whose checksum we'd like to have\n     * @param offset the location in <tt>message</tt> where the actual message\n     * starts.\n     * @param len the number of message bytes in <tt>message</tt>\n     *\n     * @return the CRC value that should be sent in a <tt>FINGERPRINT</tt>\n     * attribute traveling in the <tt>message</tt> message.\n     */\n    public static byte[] calculateXorCRC32(byte[] message, int offset, int len)\n    {\n        //now check whether the CRC really is what it's supposed to be.\n        //re calculate the check sum\n        CRC32 checksum = new CRC32();\n        checksum.update(message, offset, len);\n\n        long crc = checksum.getValue();\n        byte[] xorCRC32 = new byte[4];\n\n        xorCRC32[0] = (byte)((byte)((crc >> 24) & 0xff) ^ XOR_MASK[0]);\n        xorCRC32[1] = (byte)((byte)((crc >> 16) & 0xff) ^ XOR_MASK[1]);\n        xorCRC32[2] = (byte)((byte)((crc >> 8)  & 0xff) ^ XOR_MASK[2]);\n        xorCRC32[3] = (byte)((byte) (crc        & 0xff) ^ XOR_MASK[3]);\n\n        return xorCRC32;\n    }\n}", "super_interfaces": ["ContentDependentAttribute"], "fields": [{"attribute_expression": "public static final String NAME = \"FINGERPRINT\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"FINGERPRINT\"", "syntax_pass": true}, {"attribute_expression": "public static final byte[] XOR_MASK = { 0x53, 0x54, 0x55, 0x4e};", "docstring": "\nThe value that we need to XOR the CRC with. The XOR helps in cases where\nan application packet is also using CRC-32 in it).\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte[]", "name": "XOR_MASK = { 0x53, 0x54, 0x55, 0x4e}", "syntax_pass": true}, {"attribute_expression": "private byte[] crc;", "docstring": "\nThe CRC32 checksum that this attribute is carrying. Only used in incoming\nmessages.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte[]", "name": "crc", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute", "name": "LifetimeAttribute", "file_path": "src/main/java/org/ice4j/attribute/LifetimeAttribute.java", "superclasses": "Attribute", "methods": ["[]LifetimeAttribute()", "[boolean]equals(Object)", "[String]getName()", "[char]getDataLength()", "[byte[]]encode()", "[void]decodeAttributeBody(byte[],char,char)", "[void]setLifetime(int)", "[int]getLifetime()"], "method_uris": ["src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[]LifetimeAttribute()", "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[void]setLifetime(int)", "src/main/java/org/ice4j/attribute/LifetimeAttribute.java.LifetimeAttribute.[int]getLifetime()"], "overrides": null, "attributes": [], "class_docstring": "\nThe LIFETIME attribute is used to know the lifetime\nof TURN allocations.\n\n@author Sebastien Vincent\n@author Aakash Garg\n", "original_string": "public class LifetimeAttribute\n    extends Attribute\n{\n    /**\n     * Attribute name.\n     */\n    public static final String NAME = \"LIFETIME\";\n\n    /**\n     * The length of the data contained by this attribute.\n     */\n    public static final char DATA_LENGTH = 4;\n\n    /**\n     * Lifetime value.\n     */\n    int lifetime = 0;\n\n    /**\n     * Constructor.\n     */\n    LifetimeAttribute()\n    {\n        super(LIFETIME);\n    }\n\n    /**\n     * Compares two STUN Attributes. Attributes are considered equal when their\n     * type, length, and all data are the same.\n     * @param obj the object to compare this attribute with.\n     * @return true if the attributes are equal and false otherwise.\n     */\n    @Override\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof LifetimeAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        LifetimeAttribute att = (LifetimeAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n                || att.getDataLength() != getDataLength()\n                /* compare data */\n                || att.lifetime != lifetime\n           )\n            return false;\n\n        return true;\n    }\n\n    /**\n     * Returns the human readable name of this attribute. Attribute names do\n     * not really matter from the protocol point of view. They are only used\n     * for debugging and readability.\n     * @return this attribute's name.\n     */\n    @Override\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     * @return the length of this attribute's value (8 bytes).\n     */\n    @Override\n    public char getDataLength()\n    {\n        return DATA_LENGTH;\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     * @return a binary representation of this attribute.\n     */\n    @Override\n    public byte[] encode()\n    {\n        byte binValue[] = new byte[HEADER_LENGTH + DATA_LENGTH];\n\n        //Type\n        binValue[0] = (byte)(getAttributeType() >> 8);\n        binValue[1] = (byte)(getAttributeType() & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Data\n        binValue[4] = (byte)((lifetime >> 24) & 0xff);\n        binValue[5] = (byte)((lifetime >> 16) & 0xff);\n        binValue[6] = (byte)((lifetime >> 8) & 0xff);\n        binValue[7] = (byte)((lifetime) & 0xff);\n\n        return binValue;\n    }\n\n    /**\n     * Sets this attribute's fields according to attributeValue array.\n     * @param attributeValue a binary array containing this attribute's field\n     *                       values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *          offset is equal to the index of the first byte after\n     *          length)\n     * @param length the length of the binary array.\n     * @throws StunException if attrubteValue contains invalid data.\n     */\n    @Override\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        if (length != 4)\n        {\n            throw new StunException(\"length invalid\");\n        }\n\n        lifetime = ((attributeValue[offset] << 24) & 0xff000000) +\n            ((attributeValue[offset + 1] << 16) & 0x00ff0000) +\n            ((attributeValue[offset + 2] << 8) & 0x0000ff00) +\n            (attributeValue[offset + 3] & 0x000000ff);\n    }\n\n    /**\n     * Set the lifetime.\n     * @param lifetime lifetime\n     */\n    public void setLifetime(int lifetime)\n    {\n        this.lifetime = lifetime;\n    }\n\n    /**\n     * Get the lifetime.\n     * @return lifetime\n     */\n    public int getLifetime()\n    {\n        return lifetime;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"LIFETIME\";", "docstring": "\nAttribute name.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"LIFETIME\"", "syntax_pass": true}, {"attribute_expression": "public static final char DATA_LENGTH = 4;", "docstring": "\nThe length of the data contained by this attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "DATA_LENGTH = 4", "syntax_pass": true}, {"attribute_expression": "int lifetime = 0;", "docstring": "\nLifetime value.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "lifetime = 0", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential", "name": "LongTermCredential", "file_path": "src/main/java/org/ice4j/security/LongTermCredential.java", "superclasses": "", "methods": ["[byte[]]getBytes(String)", "[String]toString(byte[])", "[]LongTermCredential()", "[]LongTermCredential(byte[],byte[])", "[]LongTermCredential(String,String)", "[byte[]]getPassword()", "[byte[]]getUsername()", "[int]hashCode()", "[boolean]equals(Object)"], "method_uris": ["src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[byte[]]getBytes(String)", "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[String]toString(byte[])", "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[]LongTermCredential()", "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[]LongTermCredential(byte[],byte[])", "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[]LongTermCredential(String,String)", "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[byte[]]getPassword()", "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[byte[]]getUsername()", "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[int]hashCode()", "src/main/java/org/ice4j/security/LongTermCredential.java.LongTermCredential.[boolean]equals(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents a STUN long-term credential.\n\n@author Lubomir Marinov\n@author Aakash Garg\n", "original_string": "public class LongTermCredential\n{\n\n    /**\n     * Encodes a specific <tt>String</tt> into a sequence of <tt>byte</tt>s\n     * using the UTF-8 charset, storing the result into a new <tt>byte</tt>\n     * array.\n     *\n     * @param s the <tt>String</tt> to encode\n     * @return a new array of <tt>byte</tt>s which represents the encoding of\n     * the specified <tt>String</tt> using the UTF-8 charset\n     */\n    public static byte[] getBytes(String s)\n    {\n        if (s == null)\n            return null;\n        else\n        {\n            try\n            {\n                return s.getBytes(\"UTF-8\");\n            }\n            catch (UnsupportedEncodingException ueex)\n            {\n                throw new UndeclaredThrowableException(ueex);\n            }\n        }\n    }\n\n    /**\n     * Constructs a new <tt>String</tt> by decoding a specific array of\n     * <tt>byte</tt>s using the UTF-8 charset. The length of the new\n     * <tt>String</tt> is a function of the charset, and hence may not be equal\n     * to the length of the <tt>byte</tt> array.\n     * \n     * @param bytes the <tt>byte</tt>s to be decoded into characters\n     * @return a new <tt>String</tt> which has been decoded from the specified\n     * array of <tt>byte</tt>s using the UTF-8 charset\n     */\n    public static String toString(byte[] bytes)\n    {\n        if (bytes == null)\n            return null;\n        else\n        {\n            try\n            {\n                return new String(bytes, \"UTF-8\");\n            }\n            catch (UnsupportedEncodingException ueex)\n            {\n                throw new UndeclaredThrowableException(ueex);\n            }\n        }\n    }\n\n    /**\n     * The password of this <tt>LongTermCredential</tt>.\n     */\n    private final byte[] password;\n\n    /**\n     * The username of this <tt>LongTermCredential</tt>.\n     */\n    private final byte[] username;\n\n    /**\n     * Initializes a new <tt>LongTermCredential</tt> instance with no username\n     * and no password. Extenders should override {@link #getUsername()} and\n     * {@link #getPassword()} to provide the username and the password,\n     * respectively, when requested.\n     */\n    protected LongTermCredential()\n    {\n        this((byte[]) null, (byte[]) null);\n    }\n\n    /**\n     * Initializes a new <tt>LongTermCredential</tt> instance with a specific\n     * username and a specific password.\n     *\n     * @param username the username to initialize the new instance with\n     * @param password the password to initialize the new instance with\n     */\n    public LongTermCredential(byte[] username, byte[] password)\n    {\n        this.username = (username == null) ? null : username.clone();\n        this.password = (password == null) ? null : password.clone();\n    }\n\n    /**\n     * Initializes a new <tt>LongTermCredential</tt> instance with a specific\n     * username and a specific password.\n     *\n     * @param username the username to initialize the new instance with\n     * @param password the password to initialize the new instance with\n     */\n    public LongTermCredential(String username, String password)\n    {\n        this(getBytes(username), getBytes(password));\n    }\n\n    /**\n     * Gets the password of this <tt>LongTermCredential</tt>.\n     *\n     * @return an array of <tt>byte</tt>s which represents the password of this\n     * <tt>LongTermCredential</tt>\n     */\n    public byte[] getPassword()\n    {\n        return (password == null) ? null : password.clone();\n    }\n\n    /**\n     * Gets the username of this <tt>LongTermCredential</tt>.\n     *\n     * @return an array of <tt>byte</tt>s which represents the username of this\n     * <tt>LongTermCredential</tt>\n     */\n    public byte[] getUsername()\n    {\n        return (username == null) ? null : username.clone();\n    }\n\n    @Override\n    public int hashCode()\n    {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + Arrays.hashCode(password);\n        result = prime * result + Arrays.hashCode(username);\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        if (o instanceof LongTermCredential)\n        {\n            LongTermCredential ltc = (LongTermCredential) o;\n            if (Arrays.equals(\n                this.username, ltc.username) && Arrays.equals(\n                this.password, ltc.password))\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final byte[] password;", "docstring": "\nThe password of this <tt>LongTermCredential</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "byte[]", "name": "password", "syntax_pass": true}, {"attribute_expression": "private final byte[] username;", "docstring": "\nThe username of this <tt>LongTermCredential</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "byte[]", "name": "username", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession", "name": "LongTermCredentialSession", "file_path": "src/main/java/org/ice4j/security/LongTermCredentialSession.java", "superclasses": "", "methods": ["[]LongTermCredentialSession(LongTermCredential,byte[])", "[void]addAttributes(Request)", "[boolean]checkLocalUserName(String)", "[byte[]]getLocalKey(String)", "[byte[]]getNonce()", "[byte[]]getPassword()", "[byte[]]getRealm()", "[byte[]]getRemoteKey(String,String)", "[byte[]]getUsername()", "[boolean]realmEquals(byte[])", "[void]setNonce(byte[])", "[boolean]usernameEquals(byte[])"], "method_uris": ["src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[]LongTermCredentialSession(LongTermCredential,byte[])", "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[void]addAttributes(Request)", "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[boolean]checkLocalUserName(String)", "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[byte[]]getLocalKey(String)", "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[byte[]]getNonce()", "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[byte[]]getPassword()", "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[byte[]]getRealm()", "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[byte[]]getRemoteKey(String,String)", "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[byte[]]getUsername()", "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[boolean]realmEquals(byte[])", "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[void]setNonce(byte[])", "src/main/java/org/ice4j/security/LongTermCredentialSession.java.LongTermCredentialSession.[boolean]usernameEquals(byte[])"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents a use of a <tt>LongTermCredential</tt> and implements\n<tt>CredentialsAuthority</tt> for it.\n\n@author Lubomir Marinov\n", "original_string": "public class LongTermCredentialSession\n    implements CredentialsAuthority\n{\n\n    /**\n     * The <tt>LongTermCredential</tt> a use of which is represented by this\n     * instance.\n     */\n    private final LongTermCredential longTermCredential;\n\n    /**\n     * The value of the NONCE attribute currently associated with the use of\n     * {@link #longTermCredential} represented by this instance.\n     */\n    private byte[] nonce;\n\n    /**\n     * The realm (i.e. the value of the REALM attribute) in which a use of\n     * {@link #longTermCredential} is represented by this instance.\n     */\n    private final byte[] realm;\n\n    /**\n     * Initializes a new <tt>LongTermCredentialSession</tt> instance which\n     * is to represent a use of a specific <tt>LongTermCredential</tt> in a\n     * specific realm.\n     *\n     * @param longTermCredential the <tt>LongTermCredential</tt> a use of\n     * which is to be represented by the new instance\n     * @param realm the realm in which the specified\n     * <tt>LongTermCredential</tt> is to be used\n     */\n    public LongTermCredentialSession(\n            LongTermCredential longTermCredential,\n            byte[] realm)\n    {\n        this.longTermCredential = longTermCredential;\n        this.realm = (realm == null) ? null : realm.clone();\n    }\n\n    /**\n     * Adds the <tt>Attribute</tt>s to a specific <tt>Request</tt> which support\n     * the long-term credential mechanism using the <tt>LongTermCredential</tt>\n     * associated with this instance.\n     *\n     * @param request the <tt>Request</tt> in which the <tt>Attribute</tt>\n     * supporting the STUN long-term credential mechanism are to be added\n     * @throws StunException if anything goes wrong while adding the\n     * <tt>Attribute</tt>s to <tt>request</tt> which support the STUN long-term\n     * credential mechanism\n     */\n    public void addAttributes(Request request)\n        throws StunException\n    {\n        MessageFactory.addLongTermCredentialAttributes(\n                request,\n                getUsername(), getRealm(), getNonce());\n    }\n\n    /**\n     * Determines whether <tt>username</tt> is currently known to this authority\n     *\n     * @param username the user name whose validity we'd like to check\n     * @return <tt>true</tt> if <tt>username</tt> is known to this\n     * <tt>CredentialsAuthority</tt>; <tt>false</tt>, otherwise\n     * @see CredentialsAuthority#checkLocalUserName(String)\n     */\n    public boolean checkLocalUserName(String username)\n    {\n        /*\n         * The value of USERNAME is a variable-length value. It MUST contain\n         * a UTF-8 [RFC3629] encoded sequence of less than 513 bytes, and\n         * MUST have been processed using SASLprep [RFC4013].\n         */\n        return usernameEquals(LongTermCredential.getBytes(username));\n    }\n\n    /**\n     * Returns the key (password) that corresponds to the specified local\n     * username or user frag,  an empty array if there was no password for\n     * that username or <tt>null</tt> if the username is not a local user\n     * name recognized by this <tt>CredentialsAuthority</tt>.\n     *\n     * @param username the local user name or user frag whose credentials\n     * we'd like to obtain\n     * @return the key (password) that corresponds to the specified local\n     * username or user frag,  an empty array if there was no password for\n     * that username or <tt>null</tt> if the username is not a local user\n     * name recognized by this <tt>CredentialsAuthority</tt>\n     * @see CredentialsAuthority#getLocalKey(String)\n     */\n    public byte[] getLocalKey(String username)\n    {\n        if (!checkLocalUserName(username))\n            return null;\n\n        // MD5(username \":\" realm \":\" SASLprep(password))\n        StringBuilder localKeyBuilder = new StringBuilder();\n\n        if (username != null)\n            localKeyBuilder.append(username);\n        localKeyBuilder.append(':');\n\n        String realm = LongTermCredential.toString(getRealm());\n\n        if (realm != null)\n            localKeyBuilder.append(realm);\n        localKeyBuilder.append(':');\n\n        String password = LongTermCredential.toString(getPassword());\n\n        if (password != null)\n        {\n            // TODO SASLprep\n            localKeyBuilder.append(password);\n        }\n\n        MessageDigest md5;\n\n        try\n        {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        }\n        catch (NoSuchAlgorithmException nsaex)\n        {\n            throw new UndeclaredThrowableException(nsaex);\n        }\n        return\n            md5.digest(LongTermCredential.getBytes(localKeyBuilder.toString()));\n    }\n\n    /**\n     * Gets the value of the NONCE attribute currently associated with the use\n     * of the <tt>LongTermCredential</tt> represented by this instance.\n     *\n     * @return the value of the NONCE attribute currently associated with the\n     * use of the <tt>LongTermCredential</tt> represented by this instance\n     */\n    public byte[] getNonce()\n    {\n        return (nonce == null) ? null : nonce.clone();\n    }\n\n    /**\n     * Gets the password of the <tt>LongTermCredential</tt> used by this\n     * instance.\n     *\n     * @return the password of the <tt>LongTermCredential</tt> used by this\n     * instance\n     */\n    public byte[] getPassword()\n    {\n        return longTermCredential.getPassword();\n    }\n\n    /**\n     * Gets the realm (i.e. the value of the REALM attribute) in which this\n     * instance uses the <tt>LongTermCredential</tt> associated with it.\n     *\n     * @return the realm (i.e. the value of the REALM attribute) in which this\n     * instance uses the <tt>LongTermCredential</tt> associated with it\n     */\n    public byte[] getRealm()\n    {\n        return (realm == null) ? null : realm.clone();\n    }\n\n    /**\n     * Returns the key (password) that corresponds to the specified remote\n     * username or user frag,  an empty array if there was no password for\n     * that username or <tt>null</tt> if the username is not a remote user\n     * name recognized by this <tt>CredentialsAuthority</tt>.\n     *\n     * @param username the remote user name or user frag whose credentials\n     * we'd like to obtain\n     * @param media not used\n     * @return the key (password) that corresponds to the specified remote\n     * username or user frag,  an empty array if there was no password for\n     * that username or <tt>null</tt> if the username is not a remote user\n     * name recognized by this <tt>CredentialsAuthority</tt>\n     * @see CredentialsAuthority#getRemoteKey(String, String)\n     */\n    public byte[] getRemoteKey(String username, String media)\n    {\n        // The password is the same on the local and the remote sides.\n        return getLocalKey(username);\n    }\n\n    /**\n     * Gets the username of the <tt>LongTermCredential</tt> used by this\n     * instance.\n     *\n     * @return the username of the <tt>LongTermCredential</tt> used by this\n     * instance\n     */\n    public byte[] getUsername()\n    {\n        return longTermCredential.getUsername();\n    }\n\n    /**\n     * Determines whether the realm of this <tt>LongTermCredentialSession</tt>\n     * is equal to a specific realm.\n     *\n     * @param realm the realm to compare for equality to the realm of this\n     * <tt>LongTermCredentialSession</tt>\n     * @return <tt>true</tt> if the specified <tt>realm</tt> is equal to the\n     * realm of this <tt>LongTermCredentialSession</tt>; otherwise,\n     * <tt>false</tt>\n     */\n    public boolean realmEquals(byte[] realm)\n    {\n        return\n            (realm == null)\n                ? (this.realm == null)\n                : Arrays.equals(realm, this.realm);\n    }\n\n    /**\n     * Sets the value of the NONCE attribute to be associated with the use of\n     * the <tt>LongTermCredential</tt> represented by this instance.\n     *\n     * @param nonce the value of the NONCE attribute to be associated with the\n     * use of the <tt>LongTermCredential</tt> represented by this instance\n     */\n    public void setNonce(byte[] nonce)\n    {\n        this.nonce = (nonce == null) ? null : nonce.clone();\n    }\n\n    /**\n     * Determines whether the username of the <tt>LongTermCredential</tt> used\n     * by this instance is equal to a specific username.\n     *\n     * @param username the username to compare for equality to the username of\n     * the <tt>LongTermCredential</tt> used by this instance\n     * @return <tt>true</tt> if the specified <tt>username</tt> is equal to the\n     * username of the <tt>LongTermCredential</tt> used by this instance;\n     * otherwise, <tt>false</tt>\n     */\n    public boolean usernameEquals(byte[] username)\n    {\n        byte[] thisUsername = getUsername();\n\n        return\n            (username == null)\n                ? (thisUsername == null)\n                : Arrays.equals(username, thisUsername);\n    }\n}", "super_interfaces": ["CredentialsAuthority"], "fields": [{"attribute_expression": "private final LongTermCredential longTermCredential;", "docstring": "\nThe <tt>LongTermCredential</tt> a use of which is represented by this\ninstance.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "LongTermCredential", "name": "longTermCredential", "syntax_pass": true}, {"attribute_expression": "private byte[] nonce;", "docstring": "\nThe value of the NONCE attribute currently associated with the use of\n{@link #longTermCredential} represented by this instance.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte[]", "name": "nonce", "syntax_pass": true}, {"attribute_expression": "private final byte[] realm;", "docstring": "\nThe realm (i.e. the value of the REALM attribute) in which a use of\n{@link #longTermCredential} is represented by this instance.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "byte[]", "name": "realm", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager", "name": "CredentialsManager", "file_path": "src/main/java/org/ice4j/security/CredentialsManager.java", "superclasses": "", "methods": ["[boolean]checkLocalUserName(String)", "[CredentialsAuthority[]]getAuthorities()", "[byte[]]getLocalKey(String)", "[byte[]]getRemoteKey(String,String)", "[void]registerAuthority(CredentialsAuthority)", "[void]unregisterAuthority(CredentialsAuthority)"], "method_uris": ["src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager.[boolean]checkLocalUserName(String)", "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager.[CredentialsAuthority[]]getAuthorities()", "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager.[byte[]]getLocalKey(String)", "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager.[byte[]]getRemoteKey(String,String)", "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager.[void]registerAuthority(CredentialsAuthority)", "src/main/java/org/ice4j/security/CredentialsManager.java.CredentialsManager.[void]unregisterAuthority(CredentialsAuthority)"], "overrides": null, "attributes": [], "class_docstring": "\nThe <tt>CredentialsManager</tt> allows an application to handle verification\nof incoming <tt>MessageIntegrityAttribute</tt>s by registering a\n{@link CredentialsAuthority} implementation. The point of this mechanism\nis to allow use in both applications that would handle large numbers of\npossible users (such as STUN/TURN servers) or others that would only work\nwith a few, like for example an ICE implementation.\n\nTODO: just throwing a user name at the manager and expecting it to find\nan authority that knows about it may lead to ambiguities so we may need\nto add other parameters in here that would allow us to better select an\nauthority.\n\n@author Emil Ivov\n@author Lyubomir Marinov\n", "original_string": "public class CredentialsManager\n{\n    /**\n     * The list of <tt>CredentialsAuthority</tt>s registered with this manager\n     * as being able to provide credentials.\n     */\n    private final List<CredentialsAuthority> authorities = new LinkedList<>();\n\n    /**\n     * The list of <tt>CredentialsAuthority</tt>s registered with this manager\n     * as being able to provide credentials. If non-<tt>null</tt>, represents\n     * an unmodifiable view of {@link #authorities}. The field was introduced in\n     * order to reduce the scopes of the synchronization blocks of\n     * <tt>CredentialsManager</tt> and to thus reduce the risks of deadlocks.\n     */\n    private CredentialsAuthority[] unmodifiableAuthorities;\n\n    /**\n     * Verifies whether <tt>username</tt> is currently known to any of the\n     * {@link CredentialsAuthority}s registered with this manager and\n     * and returns <tt>true</tt> if so. Returns <tt>false</tt> otherwise.\n     *\n     * @param username the user name whose validity we'd like to check.\n     *\n     * @return <tt>true</tt> if <tt>username</tt> is known to any of the\n     * <tt>CredentialsAuthority</tt>s registered here and <tt>false</tt>\n     * otherwise.\n     */\n    public boolean checkLocalUserName(String username)\n    {\n        for (CredentialsAuthority auth : getAuthorities())\n        {\n            if (auth.checkLocalUserName(username))\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     * Gets the list of <tt>CredentialsAuthority</tt>s registered with this\n     * manager as being able to provide credentials. <b>Warning</b>: the\n     * returned value is an internal state of this instance and is to be\n     * considered unmodifiable.\n     *\n     * @return the list of <tt>CredentialsAuthority</tt>s registered with this\n     * manager as being able to provide credentials. <b>Warning</b>: the\n     * returned value is an internal state of this instance and is to be\n     * considered unmodifiable.\n     */\n    private CredentialsAuthority[] getAuthorities()\n    {\n        synchronized (authorities)\n        {\n            if (unmodifiableAuthorities == null)\n            {\n                unmodifiableAuthorities\n                    = authorities.toArray(\n                            new CredentialsAuthority[authorities.size()]);\n            }\n            return unmodifiableAuthorities;\n        }\n    }\n\n    /**\n     * Queries all currently registered {@link CredentialsAuthority}s for a\n     * password corresponding to the specified local <tt>username</tt> or user\n     * frag and returns the first non-<tt>null</tt> one.\n     *\n     * @param username a local user name or user frag whose credentials we'd\n     * like to obtain.\n     *\n     * @return <tt>null</tt> if username was not a recognized local user name\n     * for none of the currently registered <tt>CredentialsAuthority</tt>s or\n     * a <tt>byte</tt> array containing the first non-<tt>null</tt> password\n     * that one of them returned.\n     */\n    public byte[] getLocalKey(String username)\n    {\n        for (CredentialsAuthority auth : getAuthorities())\n        {\n            byte[] passwd = auth.getLocalKey(username);\n\n            if (passwd != null)\n                return passwd;\n        }\n        return null;\n    }\n\n    /**\n     * Queries all currently registered {@link CredentialsAuthority}s for a\n     * password corresponding to the specified remote <tt>username</tt> or user\n     * frag and returns the first non-<tt>null</tt> one.\n     *\n     * @param username a remote user name or user frag whose credentials we'd\n     * like to obtain.\n     * @param media the media name that we want to get remote key.\n     *\n     * @return <tt>null</tt> if username was not a recognized remote user name\n     * for none of the currently registered <tt>CredentialsAuthority</tt>s or\n     * a <tt>byte</tt> array containing the first non-<tt>null</tt> password\n     * that one of them returned.\n     */\n    public byte[] getRemoteKey(String username, String media)\n    {\n        for (CredentialsAuthority auth : getAuthorities())\n        {\n            byte[] passwd = auth.getRemoteKey(username, media);\n\n            if (passwd != null)\n            {\n                /** @todo: we should probably add SASLprep here.*/\n                return passwd;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Adds <tt>authority</tt> to the list of {@link CredentialsAuthority}s\n     * registered with this manager.\n     *\n     * @param authority the {@link CredentialsAuthority} to add to this manager.\n     */\n    public void registerAuthority(CredentialsAuthority authority)\n    {\n        synchronized (authorities)\n        {\n            if (!authorities.contains(authority) && authorities.add(authority))\n                unmodifiableAuthorities = null;\n        }\n    }\n\n    /**\n     * Removes <tt>authority</tt> from the list of {@link CredentialsAuthority}s\n     * registered with this manager.\n     *\n     * @param authority the {@link CredentialsAuthority} to remove from this\n     * manager.\n     */\n    public void unregisterAuthority(CredentialsAuthority authority)\n    {\n        synchronized (authorities)\n        {\n            if (authorities.remove(authority))\n                unmodifiableAuthorities = null;\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final List<CredentialsAuthority> authorities = new LinkedList<>();", "docstring": "\nThe list of <tt>CredentialsAuthority</tt>s registered with this manager\nas being able to provide credentials.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<CredentialsAuthority>", "name": "authorities = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private CredentialsAuthority[] unmodifiableAuthorities;", "docstring": "\nThe list of <tt>CredentialsAuthority</tt>s registered with this manager\nas being able to provide credentials. If non-<tt>null</tt>, represents\nan unmodifiable view of {@link #authorities}. The field was introduced in\norder to reduce the scopes of the synchronization blocks of\n<tt>CredentialsManager</tt> and to thus reduce the risks of deadlocks.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CredentialsAuthority[]", "name": "unmodifiableAuthorities", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/util/Ice4jLogFormatter.java.Ice4jLogFormatter", "name": "Ice4jLogFormatter", "file_path": "src/main/java/org/ice4j/util/Ice4jLogFormatter.java", "superclasses": "", "methods": ["[String]format(LogRecord)", "[int]inferCaller(LogRecord)"], "method_uris": ["src/main/java/org/ice4j/util/Ice4jLogFormatter.java.Ice4jLogFormatter.[String]format(LogRecord)", "src/main/java/org/ice4j/util/Ice4jLogFormatter.java.Ice4jLogFormatter.[int]inferCaller(LogRecord)"], "overrides": null, "attributes": [], "class_docstring": "\nPrint a brief summary of the LogRecord in a human readable. The summary will\ntypically be on a single line (unless it's too long :) ... what I meant to\nsay is that we don't add any line breaks).\n\n@author Emil Ivov (originally wrote it for SIP Communicator)\n", "original_string": "public class Ice4jLogFormatter\n    extends java.util.logging.Formatter\n{\n    static long startTime = System.currentTimeMillis();\n\n    private static String lineSeparator = System.getProperty(\"line.separator\");\n    private static DecimalFormat twoDigFmt = new DecimalFormat(\"00\");\n    private static DecimalFormat threeDigFmt = new DecimalFormat(\"000\");\n\n    /**\n     * Format the given LogRecord.\n     * @param record the log record to be formatted.\n     * @return a formatted log record\n     */\n    public synchronized String format(LogRecord record)\n    {\n        StringBuffer sb = new StringBuffer();\n\n        //current time\n        Calendar cal = Calendar.getInstance();\n        int hour = cal.get(Calendar.HOUR_OF_DAY);\n        int minutes = cal.get(Calendar.MINUTE);\n        int seconds = cal.get(Calendar.SECOND);\n        int millis = cal.get(Calendar.MILLISECOND);\n\n        sb.append(twoDigFmt.format(hour)).append(':');\n        sb.append(twoDigFmt.format(minutes)).append(':');\n        sb.append(twoDigFmt.format(seconds)).append('.');\n        sb.append(threeDigFmt.format(millis)).append(' ');\n\n        //log level\n        sb.append(record.getLevel().getLocalizedName());\n        sb.append(\": \");\n\n        //caller method\n        int lineNumber = inferCaller(record);\n        String loggerName = record.getLoggerName();\n\n        if (loggerName == null)\n            loggerName = record.getSourceClassName();\n\n        if (loggerName.startsWith(\"net.java.sip.communicator.\"))\n        {\n            sb.append(loggerName.substring(\"net.java.sip.communicator.\"\n                                           .length()));\n        }\n        else\n            sb.append(record.getLoggerName());\n\n        if (record.getSourceMethodName() != null)\n        {\n            sb.append(\".\");\n            sb.append(record.getSourceMethodName());\n\n            //include the line number if we have it.\n            if (lineNumber != -1)\n                sb.append(\"().\").append(Integer.toString(lineNumber));\n            else\n                sb.append(\"()\");\n        }\n        sb.append(\" \");\n        sb.append(record.getMessage());\n        sb.append(lineSeparator);\n        if (record.getThrown() != null)\n        {\n            try\n            {\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                record.getThrown().printStackTrace(pw);\n                pw.close();\n                sb.append(sw.toString());\n            }\n            catch (Exception ex)\n            {\n            }\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Try to extract the name of the class and method that called the current\n     * log statement.\n     *\n     * @param record the logrecord where class and method name should be stored.\n     *\n     * @return the line number that the call was made from in the caller.\n     */\n    private int inferCaller(LogRecord record)\n    {\n        // Get the stack trace.\n        StackTraceElement stack[] = (new Throwable()).getStackTrace();\n\n        //the line number that the caller made the call from\n        int lineNumber = -1;\n\n        // First, search back to a method in the SIP Communicator Logger class.\n        int ix = 0;\n        while (ix < stack.length)\n        {\n            StackTraceElement frame = stack[ix];\n            String cname = frame.getClassName();\n            if (cname.equals(\"net.java.sip.communicator.util.Logger\"))\n            {\n                break;\n            }\n            ix++;\n        }\n        // Now search for the first frame before the SIP Communicator Logger class.\n        while (ix < stack.length)\n        {\n            StackTraceElement frame = stack[ix];\n            lineNumber=stack[ix].getLineNumber();\n            String cname = frame.getClassName();\n            if (!cname.equals(\"net.java.sip.communicator.util.Logger\"))\n            {\n                // We've found the relevant frame.\n                record.setSourceClassName(cname);\n                record.setSourceMethodName(frame.getMethodName());\n                break;\n            }\n            ix++;\n        }\n\n        return lineNumber;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static long startTime = System.currentTimeMillis();", "docstring": "", "modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "type": "long", "name": "startTime = System.currentTimeMillis()", "syntax_pass": true}, {"attribute_expression": "private static String lineSeparator = System.getProperty(\"line.separator\");", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String", "name": "lineSeparator = System.getProperty(\"line.separator\")", "syntax_pass": true}, {"attribute_expression": "private static DecimalFormat twoDigFmt = new DecimalFormat(\"00\");", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "DecimalFormat", "name": "twoDigFmt = new DecimalFormat(\"00\")", "syntax_pass": true}, {"attribute_expression": "private static DecimalFormat threeDigFmt = new DecimalFormat(\"000\");", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "DecimalFormat", "name": "threeDigFmt = new DecimalFormat(\"000\")", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/pseudotcp/SSegment.java.SSegment", "name": "SSegment", "file_path": "src/main/java/org/ice4j/pseudotcp/SSegment.java", "superclasses": "", "methods": ["[]SSegment(long,long,boolean)"], "method_uris": ["src/main/java/org/ice4j/pseudotcp/SSegment.java.SSegment.[]SSegment(long,long,boolean)"], "overrides": null, "attributes": [], "class_docstring": "\nClass used internally as a structure for send segments\n\n@author Pawel Domas\n", "original_string": "class SSegment\n{\n    long seq, len;\n    //uint32 tstamp;\n    short xmit;\n    boolean bCtrl;\n\n    SSegment(long s, long l, boolean c)\n    {\n        seq = s;\n        len = l;\n        xmit = 0;\n        bCtrl = c;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "long seq, len;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "seq", "syntax_pass": true}, {"attribute_expression": "short xmit;", "docstring": "uint32 tstamp;", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "short", "name": "xmit", "syntax_pass": true}, {"attribute_expression": "boolean bCtrl;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "bCtrl", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory", "name": "PseudoTcpSocketFactory", "file_path": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java", "superclasses": "SocketFactory", "methods": ["[Socket]createSocket(String,int)", "[Socket]createSocket(InetAddress,int)", "[void]connectSocket(Socket,InetSocketAddress)", "[Socket]createBoundSocket(InetSocketAddress)", "[Socket]createSocket(String,int,InetAddress,int)", "[Socket]createSocket(InetAddress,int,InetAddress,int)", "[PseudoTcpSocket]createSocket(DatagramSocket)", "[PseudoTcpSocket]createSocket()", "[SocketImpl]createSocketImpl()"], "method_uris": ["src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[Socket]createSocket(String,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[Socket]createSocket(InetAddress,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[void]connectSocket(Socket,InetSocketAddress)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[Socket]createBoundSocket(InetSocketAddress)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[Socket]createSocket(String,int,InetAddress,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[Socket]createSocket(InetAddress,int,InetAddress,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[PseudoTcpSocket]createSocket(DatagramSocket)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[PseudoTcpSocket]createSocket()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketFactory.java.PseudoTcpSocketFactory.[SocketImpl]createSocketImpl()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PseudoTcpSocketFactory\n    extends SocketFactory\n    implements SocketImplFactory\n{\n    /**\n     * Default conversation ID\n     */\n    public static final long DEFAULT_CONVERSATION_ID=0;\n\n    /**\n     * Default timeout for connect operation\n     */\n    public static final int DEFAULT_CONNECT_TIMEOUT=5000;\n\n    /**\n     * Creates a socket and connects it to the specified \n     * port number at the specified address.\n     */\n    public Socket createSocket(String host, int port)\n        throws IOException,\n               UnknownHostException\n    {\n        Socket socket = createSocket();\n        connectSocket(socket, new InetSocketAddress(host, port));\n        return socket;\n    }\n\n    /**\n     * Creates a socket and connect it to the specified remote address \n     * on the specified remote port.\n     */\n    public Socket createSocket(InetAddress host, int port) throws IOException\n    {\n        Socket socket = createSocket();\n        connectSocket(socket, new InetSocketAddress(host, port));\n        return socket;\n    }    \n\n    private void connectSocket(Socket socket, InetSocketAddress remoteSockAddr)\n        throws IOException\n    {\n        socket.connect(remoteSockAddr, DEFAULT_CONNECT_TIMEOUT);\n    }\n\n    /**\n     * Creates socket bound to local <tt>sockAddr</tt>\n     * @param sockAddr address for the pseudo socket\n     * @return socket bound to local address\n     * @throws IOException if the socket could not be opened, or the socket\n     * could not bind to the specified local port.\n     */\n    public Socket createBoundSocket(InetSocketAddress sockAddr) \n        throws IOException\n    {\n        return new PseudoTcpSocket(\n            new PseudoTcpSocketImpl(DEFAULT_CONVERSATION_ID,\n                new DatagramSocket(sockAddr)));\n    }\n\n    /**\n     *  Creates a socket and connects it to the specified remote host at the specified remote port.\n     */\n    public Socket createSocket(String host, \n                               int port, \n                               InetAddress localHost,\n                               int localPort)\n        throws IOException, \n               UnknownHostException\n    {\n        Socket socket = createBoundSocket(\n                        new InetSocketAddress(localHost, localPort));\n        connectSocket(socket, new InetSocketAddress(host, port));\n        return socket;\n    }\n\n    /**\n     * Creates a socket and connects it to the specified remote host on the specified remote port.\n     */\n    public Socket createSocket(InetAddress address, int port,\n        InetAddress localAddress, int localPort) throws IOException\n    {\n        Socket socket = createBoundSocket(\n            new InetSocketAddress(localAddress, localPort));\n        connectSocket(socket, new InetSocketAddress(address, port));\n        return socket;\n    }\n\n    /**\n     * Creates a socket that will run on given <tt>datagramSocket</tt>\n     * \n     * @param datagramSocket the socket to run on\n     * @return new socket running on given <tt>datagramSocket</tt>\n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as a TCP error.\n     */\n    public PseudoTcpSocket createSocket(DatagramSocket datagramSocket) \n        throws SocketException\n    {        \n        return new PseudoTcpSocket(\n            new PseudoTcpSocketImpl(DEFAULT_CONVERSATION_ID, datagramSocket));\n    }\n\n    /**\n     * Creates the PseudoTcp socket and binds it to any available port\n     * on the local host machine.  The socket will be bound to the\n     * {@link InetAddress#isAnyLocalAddress wildcard} address,\n     * an IP address chosen by the kernel.\n     */\n    @Override\n    public PseudoTcpSocket createSocket() \n        throws SocketException\n    {        \n        return new PseudoTcpSocket(\n            new PseudoTcpSocketImpl(DEFAULT_CONVERSATION_ID));\n    }\n\n    public SocketImpl createSocketImpl()\n    {\n        try\n        {\n            return new PseudoTcpSocketImpl(DEFAULT_CONVERSATION_ID);\n        }\n        catch (SocketException e)\n        {\n            throw new RuntimeException(e);\n        }        \n    }\n}", "super_interfaces": ["SocketImplFactory"], "fields": [{"attribute_expression": "public static final long DEFAULT_CONVERSATION_ID=0;", "docstring": "\nDefault conversation ID\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "long", "name": "DEFAULT_CONVERSATION_ID=0", "syntax_pass": true}, {"attribute_expression": "public static final int DEFAULT_CONNECT_TIMEOUT=5000;", "docstring": "\nDefault timeout for connect operation\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_CONNECT_TIMEOUT=5000", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase", "name": "PseudoTCPBase", "file_path": "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java", "superclasses": "", "methods": ["[]PseudoTCPBase(PseudoTcpNotify,long)", "[void]connect()", "[void]notifyMTU(int)", "[int]getMTU()", "[long]now()", "[long]getNextClock(long)", "[void]notifyClock(long)", "[boolean]notifyPacket(byte[],int)", "[long]getOption(Option)", "[void]setOption(Option,long)", "[long]getCongestionWindow()", "[long]getBytesInFlight()", "[long]getBytesBufferedNotSent()", "[int]getAvailable()", "[int]getAvailableSendBuffer()", "[long]getRoundTripTimeEstimateMs()", "[int]recv(byte[],int,int)", "[int]recv(byte[],int)", "[int]send(byte[],int)", "[int]send(byte[],int,int)", "[void]close(boolean)", "[int]queue(byte[],int,int,boolean)", "[WriteResult]packet(long,short,long,long)", "[Segment]parseSeg(byte[],int)", "[String]segToStr(Segment)", "[boolean]parse(byte[],int)", "[long]clock_check(long)", "[boolean]process(Segment)", "[long]timeDiff(long,long)", "[void]long_to_bytes(long,byte[],int)", "[void]short_to_bytes(int,byte[],int)", "[long]bytes_to_long(byte[],int)", "[int]bytes_to_short(byte[],int)", "[byte[]]copy_buffer(byte[],int,int)", "[long]bound(long,long,long)", "[byte[]]scrollBuffer(byte[],int)", "[boolean]transmit(SSegment,long)", "[void]attemptSend(SendFlags)", "[void]closedown(IOException)", "[void]adjustMTU()", "[boolean]isReceiveBufferFull()", "[void]disableWindowScale()", "[void]queueConnectMessage()", "[boolean]parseOptions(byte[],int,int)", "[void]applyOption(short,byte[],long)", "[void]applyWindowScaleOption(short)", "[void]resizeSendBuffer(int)", "[void]resizeReceiveBuffer(int)", "[int]getM_snd_wnd()", "[PseudoTcpState]getState()", "[int]getSendBufferSize()", "[int]getRecvBufferSize()", "[short]getM_rwnd_scale()", "[short]getM_swnd_scale()", "[Object]getAckNotify()", "[long]getConversationID()", "[void]setConversationID(long)"], "method_uris": ["src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[]PseudoTCPBase(PseudoTcpNotify,long)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]connect()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]notifyMTU(int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]getMTU()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]now()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]getNextClock(long)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]notifyClock(long)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[boolean]notifyPacket(byte[],int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]getOption(Option)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]setOption(Option,long)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]getCongestionWindow()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]getBytesInFlight()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]getBytesBufferedNotSent()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]getAvailable()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]getAvailableSendBuffer()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]getRoundTripTimeEstimateMs()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]recv(byte[],int,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]recv(byte[],int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]send(byte[],int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]send(byte[],int,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]close(boolean)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]queue(byte[],int,int,boolean)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[WriteResult]packet(long,short,long,long)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[Segment]parseSeg(byte[],int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[String]segToStr(Segment)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[boolean]parse(byte[],int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]clock_check(long)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[boolean]process(Segment)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]timeDiff(long,long)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]long_to_bytes(long,byte[],int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]short_to_bytes(int,byte[],int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]bytes_to_long(byte[],int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]bytes_to_short(byte[],int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[byte[]]copy_buffer(byte[],int,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]bound(long,long,long)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[byte[]]scrollBuffer(byte[],int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[boolean]transmit(SSegment,long)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]attemptSend(SendFlags)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]closedown(IOException)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]adjustMTU()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[boolean]isReceiveBufferFull()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]disableWindowScale()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]queueConnectMessage()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[boolean]parseOptions(byte[],int,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]applyOption(short,byte[],long)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]applyWindowScaleOption(short)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]resizeSendBuffer(int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]resizeReceiveBuffer(int)", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]getM_snd_wnd()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[PseudoTcpState]getState()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]getSendBufferSize()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[int]getRecvBufferSize()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[short]getM_rwnd_scale()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[short]getM_swnd_scale()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[Object]getAckNotify()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[long]getConversationID()", "src/main/java/org/ice4j/pseudotcp/PseudoTCPBase.java.PseudoTCPBase.[void]setConversationID(long)"], "overrides": null, "attributes": [], "class_docstring": "\nMain protocol logic class. To open connection use <tt>connect</tt> method. \nThen <tt>recv</tt> and <tt>send</tt> operations may be used for data transfer.\nTo operate this class requires implementation of <tt>PseudoTcpNotify</tt>.\nAlso it must be notified about the time progress.\nBased on https://developers.google.com/talk/libjingle/\n\n@see PseudoTCPBase#connect\n@see PseudoTCPBase#recv\n@see PseudoTCPBase#send\n@see PseudoTcpNotify\n@author Pawel Domas\n", "original_string": "public class PseudoTCPBase\n{\n    /**\n     * The logger.\n     */\n    private static final Logger logger =\n        Logger.getLogger(PseudoTCPBase.class.getName());\n    /**\n     * Keepalive - disabled by default\n     */\n    private static boolean PSEUDO_KEEPALIVE = false;\n    /**\n     * Packet maximum levels\n     */\n    static final int[] PACKET_MAXIMUMS = new int[]\n    {\n        65535, // Theoretical maximum, Hyperchannel\n        32000, // Nothing\n        17914, // 16Mb IBM Token Ring\n        8166, // IEEE 802.4\n        //4464,   // IEEE 802.5 (4Mb max)\n        4352, // FDDI\n        //2048,   // Wideband Network\n        2002, // IEEE 802.5 (4Mb recommended)\n        //1536,   // Expermental Ethernet Networks\n        //1500,   // Ethernet, Point-to-Point (default)\n        1492, // IEEE 802.3\n        1006, // SLIP, ARPANET\n        //576,    // X.25 Networks\n        //544,    // DEC IP Portal\n        //512,    // NETBIOS\n        508, // IEEE 802/Source-Rt Bridge, ARCNET\n        296, // Point-to-Point (low delay)\n        //68,     // Official minimum\n        0, // End of list marker\n    };\n    static final int MAX_PACKET = 65535;\n    // Note: we removed lowest level because packet overhead was larger!\n    static final int MIN_PACKET = 296;\n    static final int IP_HEADER_SIZE = 20; // (+ up to 40 bytes of options?)\n    static final int ICMP_HEADER_SIZE = 8;\n    static final int UDP_HEADER_SIZE = 8;\n    // TODO: Make JINGLE_HEADER_SIZE transparent to this code?\n    static final int JINGLE_HEADER_SIZE = 64; // when relay framing is in use\n    // Default size for receive and send buffer.\n    public static final int DEFAULT_RCV_BUF_SIZE = 60 * 1024;\n    public static final int DEFAULT_SND_BUF_SIZE = 90 * 1024;\n    //////////////////////////////////////////////////////////////////////\n    // Global Constants and Functions\n    //////////////////////////////////////////////////////////////////////\n    //\n    //    0                   1                   2                   3\n    //    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    //  0 |                      Conversation Number                      |\n    //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    //  4 |                        Sequence Number                        |\n    //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    //  8 |                     Acknowledgment Number                     |\n    //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    //    |               |   |U|A|P|R|S|F|                               |\n    // 12 |    Control    |   |R|C|S|S|Y|I|            Window             |\n    //    |               |   |G|K|H|T|N|N|                               |\n    //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    // 16 |                       Timestamp sending                       |\n    //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    // 20 |                      Timestamp receiving                      |\n    //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    // 24 |                             data                              |\n    //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    //\n    //////////////////////////////////////////////////////////////////////\n    static final long MAX_SEQ = 0xFFFFFFFFL;\n    static final int HEADER_SIZE = 24;\n    static final int PACKET_OVERHEAD = HEADER_SIZE + UDP_HEADER_SIZE + IP_HEADER_SIZE + JINGLE_HEADER_SIZE;\n    static final long MIN_RTO = 250; // 250 ms (RFC1122, Sec 4.2.3.1 \"fractions of a second\")\n    static final long DEF_RTO = 3000; // 3 seconds (RFC1122, Sec 4.2.3.1)\n    static final long MAX_RTO = 60000; // 60 seconds\n    static final long DEF_ACK_DELAY = 100; // 100 milliseconds\n    static final short FLAG_CTL = 0x02;\n    static final short FLAG_RST = 0x04;\n    static final short CTL_CONNECT = 0;\n    //static final short CTL_REDIRECT = 1;\n    static final short CTL_EXTRA = 255;\n    // TCP options.\n    /**\n     * End of list\n     */\n    static final short TCP_OPT_EOL = 0;\n    /**\n     * No-op\n     */\n    static final short TCP_OPT_NOOP = 1;\n    /**\n     * Maximum segment size\n     */\n    static final short TCP_OPT_MSS = 2;\n    /**\n     * Window scale factor\n     */\n    static final short TCP_OPT_WND_SCALE = 3;\n    //static final short FLAG_FIN = 0x01; static final short FLAG_SYN = 0x02;\n    //static final short FLAG_ACK = 0x10;\n    static final int CTRL_BOUND = 0x80000000;\n    /**\n     * If there are no pending clocks, wake up every 4 seconds\n     */\n    static final long DEFAULT_TIMEOUT = 4000;\n    /**\n     * If the connection is closed, once per minute\n     */\n    static final long CLOSED_TIMEOUT = 60 * 1000; // \n    /**\n     * Idle ping interval\n     */\n    static final int IDLE_PING = 20 * 1000; // 20 seconds (note: WinXP SP2 firewall udp timeout is 90 seconds)\n    /**\n     * Idle timeout(used if keepalive is enabled)\n     */\n    static final int IDLE_TIMEOUT = 90 * 1000; // 90 seconds;\n    // TCB data\n    /**\n     * Tcp state\n     */\n    PseudoTcpState m_state;\n    /**\n     * Conversation number\n     */\n    long m_conv;\n    boolean m_bReadEnable, m_bWriteEnable, m_bOutgoing;\n    /**\n     * Last traffic timestamp\n     */\n    long m_lasttraffic;\n    /**\n     * List of incoming segments. Segments store info like stream offset and\n     * control flags. If segment contains any data it is stored in the receive\n     * buffer.\n     */\n    List<RSegment> m_rlist = new ArrayList<>();\n    /**\n     * Last receive timestamp\n     */\n    long m_lastrecv;\n    /**\n     * Receive buffer length\n     */\n    int m_rbuf_len;\n    /**\n     * The sequence number of the next byte of data that is expected from the\n     * other device\n     */\n    int m_rcv_nxt;\n    /**\n     * Receive window size\n     */\n    int m_rcv_wnd;\n    /**\n     * Window scale factor\n     */\n    private short m_rwnd_scale;\n    /**\n     * The receive buffer\n     */\n    ByteFifoBuffer m_rbuf;\n    /**\n     * Outgoing segments list\n     */\n    List<SSegment> m_slist = new ArrayList<>();\n    /**\n     * Last send timestamp\n     */\n    long m_lastsend;\n    /**\n     * The sequence number of the next byte of data to be sent\n     */\n    long m_snd_nxt;\n    /**\n     * The sequence number of the first byte of data that has been sent but not\n     * yet acknowledged\n     */\n    long m_snd_una;\n    /**\n     * The send buffer's size\n     */\n    int m_sbuf_len;\n    /**\n     * Send window size\n     */\n    private int m_snd_wnd;\n    /**\n     * Send window scale factor\n     */\n    private short m_swnd_scale;\n    /**\n     * The send buffer\n     */\n    ByteFifoBuffer m_sbuf;\n    // Maximum segment size, estimated protocol level, largest segment sent\n    /**\n     *\n     */\n    long m_mss;\n    /**\n     *\n     */\n    long m_largest;\n    /**\n     *\n     */\n    long m_mtu_advise;\n    /**\n     *\n     */\n    int m_msslevel;\n    /**\n     * Retransmit timer\n     */\n    long m_rto_base;\n    /**\n     * Timestamp tracking\n     */\n    long m_ts_recent, m_ts_lastack;\n    /**\n     * Round-trip calculation\n     */\n    long m_rx_rttvar, m_rx_srtt, m_rx_rto;\n    /**\n     * Congestion avoidance, Fast retransmit/recovery, Delayed ACKs\n     */\n    long m_ssthresh, m_cwnd;\n    short m_dup_acks;\n    long m_recover;\n    long m_t_ack;\n    // Configuration options\n    /**\n     * Use nagling\n     */\n    boolean m_use_nagling;\n    /*\n     * Acknowledgment delay\n     */\n    long m_ack_delay;\n    boolean m_support_wnd_scale;\n    PseudoTcpNotify m_notify;\n    EnShutdown m_shutdown;\n    /**\n     * Debug name used to identify peers in log messages\n     */\n    String debugName = \"\";\n\n    //////////////////////////////////////////////////////////////////////\n    // PseudoTcp\n    //////////////////////////////////////////////////////////////////////\n    /**\n     *\n     * @param notify {@link PseudoTcpNotify} implementation\n     * @param conv the conversation number used by this instance\n     */\n    public PseudoTCPBase(PseudoTcpNotify notify, long conv)\n    {\n        m_notify = notify;\n        m_shutdown = EnShutdown.SD_NONE;\n        m_rbuf_len = DEFAULT_RCV_BUF_SIZE;\n        m_rbuf = new ByteFifoBuffer(m_rbuf_len);\n        m_sbuf_len = DEFAULT_SND_BUF_SIZE;\n        m_sbuf = new ByteFifoBuffer(m_sbuf_len);\n        // Sanity check on buffer sizes (needed for OnTcpWriteable notification logic)\n        assert m_rbuf_len + MIN_PACKET < m_sbuf_len;\n        long now = now();\n\n        m_state = PseudoTcpState.TCP_LISTEN;\n        m_conv = conv;\n        m_rcv_wnd = m_rbuf_len;\n        m_rwnd_scale = m_swnd_scale = 0;\n        m_snd_nxt = 0;\n        m_snd_wnd = 1;\n        m_snd_una = m_rcv_nxt = 0;\n        m_bReadEnable = true;\n        m_bWriteEnable = false;\n        m_t_ack = 0;\n\n        m_msslevel = 0;\n        m_largest = 0;\n        assert MIN_PACKET > PACKET_OVERHEAD;\n        m_mss = MIN_PACKET - PACKET_OVERHEAD;\n        m_mtu_advise = MAX_PACKET;\n\n        m_rto_base = 0;\n\n        m_cwnd = 2 * m_mss;\n        m_ssthresh = m_rbuf_len;\n        m_lastrecv = m_lastsend = m_lasttraffic = now;\n        m_bOutgoing = false;\n\n        m_dup_acks = 0;\n        m_recover = 0;\n\n        m_ts_recent = m_ts_lastack = 0;\n\n        m_rx_rto = DEF_RTO;\n        m_rx_srtt = m_rx_rttvar = 0;\n\n        m_use_nagling = true;\n        m_ack_delay = DEF_ACK_DELAY;\n        m_support_wnd_scale = false;\n    }\n\n    /**\n     * Enqueues connect message and starts connection procedure\n     *\n     * @throws IOException if the protocol is not in initial state\n     */\n    public void connect() throws IOException\n    {\n        if (m_state != PseudoTcpState.TCP_LISTEN)\n        {\n            //m_error = PseudoTcpError.EINVAL;\n            throw new IOException(\"Invalid socket state: \"+m_state);\n        }\n\n        m_state = PseudoTcpState.TCP_SYN_SENT;\n        logger.log(Level.FINE, \"State: TCP_SYN_SENT\", \"\");\n\n        queueConnectMessage();\n        attemptSend(SendFlags.sfNone);\n    }\n\n    /**\n     * Set the MTU (maximum transmission unit) value\n     *\n     * @param mtu the new MTU value\n     */\n    public void notifyMTU(int mtu)\n    {\n        m_mtu_advise = mtu;\n        if (m_state == PseudoTcpState.TCP_ESTABLISHED)\n        {\n            adjustMTU();\n        }\n    }\n    \n    /**\n     * \n     * @return MTU value\n     */\n    public int getMTU()\n    {\n        return (int)m_mtu_advise;\n    }\n\n    /**\n     * @return current timestamp limited to 32 bits\n     */\n    public static long now()\n    {\n        return (System.nanoTime() / 1000000) & 0xFFFFFFFFL;\n    }\n\n    /**\n     * Evaluate next interval between <tt>getNextClock</tt> calls.\n     * It is based on current protocol action timeout\n     *\n     * @param now current timestamp\n     * @return next interval\n     *\n     */\n    public long getNextClock(long now)\n    {\n        return clock_check(now);\n    }\n\n    /**\n     * This method should be called in time intervals retrieved \n     * from <tt>getNextClock</tt>\n     *\n     * @param now current timestamp\n     * @see PseudoTCPBase#getNextClock(long)\n     */\n    public void notifyClock(long now)\n    {\n        /*if (logger.isLoggable(Level.FINEST))\n        {\n            logger.log(Level.FINEST, debugName + \" update clock \" + now);\n        }*/\n        if (m_state == PseudoTcpState.TCP_CLOSED)\n        {\n            return;\n        }\n\n        // Check if it's time to retransmit a segment\n        if (m_rto_base > 0 && (timeDiff(m_rto_base + m_rx_rto, now) <= 0))\n        {\n            assert !m_slist.isEmpty();\n            // retransmit segments\n            if (logger.isLoggable(Level.FINER))\n            {\n                logger.log(Level.FINER, \"timeout retransmit (rto: \" + m_rx_rto\n                    + \")(rto_base: \" + m_rto_base + \") (now: \" + now + \") (dup_acks: \"\n                    + m_dup_acks + \")\");\n            }\n            if (!transmit(m_slist.get(0), now))\n            {\n                closedown(new IOException(\"Connection aborted\"));\n                return;\n            }\n\n            long nInFlight = m_snd_nxt - m_snd_una;\n            m_ssthresh = Math.max(nInFlight / 2, 2 * m_mss);\n            //Logger.Log(LS_INFO)\n            //  << \"m_ssthresh: \" << m_ssthresh << \"  nInFlight: \" << nInFlight << \"  m_mss: \" << m_mss;\n            m_cwnd = m_mss;\n\n            // Back off retransmit timer.  Note: the limit is lower when connecting.\n            long rto_limit = (m_state.ordinal() < PseudoTcpState.TCP_ESTABLISHED.ordinal())\n                ? DEF_RTO : MAX_RTO;\n            m_rx_rto = Math.min(rto_limit, m_rx_rto * 2);\n            m_rto_base = now;\n        }\n\n        // Check if it's time to probe closed windows\n        if ((getM_snd_wnd() == 0) && (timeDiff(m_lastsend + m_rx_rto, now) <= 0))\n        {\n            if (timeDiff(now, m_lastrecv) >= 15000)\n            {\n                closedown(new IOException(\"Connection aborted\"));\n                return;\n            }\n            // probe the window\n            packet(m_snd_nxt - 1, (short) 0, 0, 0);\n            m_lastsend = now;\n\n            // back off retransmit timer\n            m_rx_rto = Math.min(MAX_RTO, m_rx_rto * 2);\n        }\n\n        // Check if it's time to send delayed acks\n        long timeDiff = timeDiff(m_t_ack + m_ack_delay, now);\n        if (m_t_ack > 0 && (timeDiff <= 0))\n        {\n            packet(m_snd_nxt, (short) 0, 0, 0);\n        }\n\n        if (PSEUDO_KEEPALIVE) // Check for idle timeout\n        {\n            if ((m_state == PseudoTcpState.TCP_ESTABLISHED)\n                && (timeDiff(m_lastrecv + IDLE_TIMEOUT, now) <= 0))\n            {\n                closedown(new IOException(\"Connection aborted\"));\n                return;\n            }\n\n            // Check for ping timeout (to keep udp mapping open)\n            if ((m_state == PseudoTcpState.TCP_ESTABLISHED)\n                && (timeDiff(m_lasttraffic + (m_bOutgoing ? IDLE_PING * 3 / 2 : IDLE_PING), now) <= 0))\n            {\n                packet(m_snd_nxt, (short) 0, 0, 0);\n            }\n\n        }\n    }\n\n    /**\n     * Use this method to notify protocol about packets received from the\n     * network\n     *\n     * @param buffer packet's data\n     * @param len data length\n     * @return true if packet was successfully parsed\n     */\n    synchronized public boolean notifyPacket(byte[] buffer, int len)\n    {\n        if (len > MAX_PACKET)\n        {\n            logger.log(Level.WARNING, debugName + \" packet too large\");\n            return false;\n        }\n        return parse(buffer, len);\n    }\n\n    /**\n     * Retrieve option's value. See {@link Option} for available options\n     *\n     * @param opt option which value will be retrieved\n     * @return option's value\n     */\n    long getOption(Option opt)\n    {\n        if (opt == Option.OPT_NODELAY)\n        {\n            return m_use_nagling ? 0 : 1;\n        }\n        else\n        {\n            if (opt == Option.OPT_ACKDELAY)\n            {\n                return m_ack_delay;\n            }\n            else\n            {\n                if (opt == Option.OPT_SNDBUF)\n                {\n                    return m_sbuf_len;\n                }\n                else\n                {\n                    assert opt == Option.OPT_RCVBUF;\n                    return m_rbuf_len;\n                }\n            }\n        }\n    }\n\n    /**\n     * Sets {@link Option} value\n     *\n     * @param opt option whose value will be set\n     * @param value the value to be set\n     */\n    void setOption(Option opt, long value)\n    {\n        if (opt == Option.OPT_NODELAY)\n        {\n            m_use_nagling = value == 0;\n        }\n        else\n        {\n            if (opt == Option.OPT_ACKDELAY)\n            {\n                m_ack_delay = value;\n            }\n            else\n            {\n                if (opt == Option.OPT_SNDBUF)\n                {\n                    assert m_state == PseudoTcpState.TCP_LISTEN;\n                    resizeSendBuffer((int)value);\n                }\n                else\n                {\n                    assert opt == Option.OPT_RCVBUF;\n                    assert m_state == PseudoTcpState.TCP_LISTEN;\n                    resizeReceiveBuffer((int)value);\n                }\n            }\n        }\n    }\n\n    /**\n     *\n     * @return congestion window size\n     */\n    long getCongestionWindow()\n    {\n        return m_cwnd;\n    }\n\n    /**\n     *\n     * @return bytes in flight\n     */\n    long getBytesInFlight()\n    {\n        return m_snd_nxt - m_snd_una;\n    }\n\n    /**\n     *\n     * @return bytes buffered, but not sent yet\n     */\n    long getBytesBufferedNotSent()\n    {\n        long buffered_bytes = m_sbuf.getBuffered();\n        return m_snd_una + buffered_bytes - m_snd_nxt;\n    }\n\n    /**\n     *\n     * @return bytes available in receive buffer\n     */\n    int getAvailable()\n    {\n        return m_rbuf.getBuffered();\n    }\n\n    /**\n     *\n     * @return space available in the send buffer\n     */\n    int getAvailableSendBuffer()\n    {\n        return m_sbuf.getWriteRemaining();\n    }\n\n    /**\n     *\n     * @return round trip time estimate in ms\n     */\n    long getRoundTripTimeEstimateMs()\n    {\n        return m_rx_srtt;\n    }\n\n    /**\n     * Reads the data available in receive buffer. This method returns 0 if\n     * there's no data available at the moment.\n     *\n     * @param buffer destination buffer\n     * @param offset destination buffer's offset\n     * @param len bytes to be read\n     * @return byte count actually read\n     * @throws IOException if the protocol is not in the connected state\n     */\n    public synchronized int recv(byte[] buffer, int offset, int len) throws IOException\n    {\n        if (m_state != PseudoTcpState.TCP_ESTABLISHED)\n        {\n            throw new IOException(\"Socket not connected\");\n        }\n\n        int read = m_rbuf.read(buffer, offset, len);\n\n        // If there's no data in |m_rbuf|.\n        if (read == 0)\n        {\n            m_bReadEnable = true;\n            return 0;\n        }\n        assert read != -1;\n\n        int available_space = m_rbuf.getWriteRemaining();\n        if (available_space - m_rcv_wnd >= Math.min(m_rbuf_len / 8, m_mss))\n        {\n            boolean bWasClosed = (m_rcv_wnd == 0); // !?! Not sure about this was closed business\n            m_rcv_wnd = available_space;\n\n            if (bWasClosed)\n            {\n                attemptSend(SendFlags.sfImmediateAck);\n            }\n        }\n        return read;\n    }\n\n    /**\n     * Reads the data available in receive buffer. This method returns 0 if\n     * there's no data available at the moment.\n     * \n     * @param buffer destination buffer\n     * @param len bytes to be read\n     * @return received byte count\n     * @throws IOException if the protocol is not in the connected state\n     */\n    public int recv(byte[] buffer, int len) throws IOException\n    {\n        return recv(buffer, 0, len);\n    }\n\n    /**\n     * Enqueues data in the send buffer\n     * \n     * @param buffer source data buffer\n     * @param len bytes count to be sent\n     * @return sent byte count\n     * @throws IOException if the protocol is not in connected state\n     */\n    public int send(byte[] buffer, int len) throws IOException\n    {\n        return send(buffer, 0, len);\n    }\n\n    /**\n     * Enqueues data in the send buffer\n     *\n     * @param buffer source data buffer\n     * @param offset offset of the source data buffer\n     * @param len bytes count to be sent\n     * @return bytes count written to the send buffer\n     * @throws IOException if the protocol is not in connected state\n     */\n    public synchronized int send(byte[] buffer, int offset, int len)\n        throws IOException\n    {\n        if (m_state != PseudoTcpState.TCP_ESTABLISHED)\n        {\n            throw new IOException(\"Socket not connected\");\n        }\n\n        long available_space;\n        available_space = m_sbuf.getWriteRemaining();\n\n        if (available_space == 0)\n        {\n            m_bWriteEnable = true;\n            return 0;\n        }\n\n        int written = queue(buffer, offset, len, false);\n        attemptSend(SendFlags.sfNone);\n        return written;\n    }\n\n    /**\n     * Shuts down the protocol which enters closed state\n     *\n     * @param force if true all data received from this moment will be discarded\n     */\n    void close(boolean force)\n    {\n        logger.log(Level.FINE, debugName + \" close (\" + force + \")\");\n        m_shutdown = force ? EnShutdown.SD_FORCEFUL : EnShutdown.SD_GRACEFUL;\n        if (force)\n        {\n            m_state = PseudoTcpState.TCP_CLOSED;\n        }\n    }\n\n//\n// Internal Implementation\n//\n    /**\n     * Enqueues data segment in the send buffer\n     *\n     * @param buffer source buffer\n     * @param offset source buffer's offset\n     * @param len data length\n     * @param bCtrl true for control data\n     * @return written byte count\n     */\n    int queue(byte[] buffer, int offset, int len, boolean bCtrl)\n    {\n        int available_space;\n        available_space = m_sbuf.getWriteRemaining();\n        if (len > available_space)\n        {\n            assert !bCtrl;\n            len = available_space;\n        }\n\n        // We can concatenate data if the last segment is the same type\n        // (control v. regular data), and has not been transmitted yet\n        SSegment back = null;\n        if (!m_slist.isEmpty())\n        {\n            back = m_slist.get(m_slist.size() - 1);\n        }\n        if (back != null && (back.bCtrl == bCtrl) && (back.xmit == 0))\n        {\n            back.len += len;\n        }\n        else\n        {\n            long snd_buffered;\n            snd_buffered = m_sbuf.getBuffered();\n            SSegment sseg = new SSegment(\n                m_snd_una + snd_buffered,\n                len,\n                bCtrl);\n            //m_slist.push_back(sseg);\n            if (logger.isLoggable(Level.FINEST))\n            {\n                logger.log(Level.FINEST, debugName + \" enqueued send segment seq: \"\n                    + sseg.seq + \" len: \" + sseg.len);\n            }\n            m_slist.add(sseg);\n        }\n\n        int written = m_sbuf.write(buffer, offset, len);\n        return written;\n    }\n\n    /**\n     * Creates a packet starting at <tt>offset</tt> in the send buffer of\n     * specified length and sends it with help of <tt>PseudoTcpNotify</tt>.\n     *\n     * @param seq used sequence number\n     * @param flags\n     * @param offset in the send buffer\n     * @param len length of data from\n     * @return <tt>WriteResult</tt> returned by <tt>PseudoTcpNotify</tt>\n     * \n     * @see PseudoTcpNotify\n     * @see WriteResult\n     */\n    WriteResult packet(long seq, short flags, long offset, long len)\n    {\n        assert HEADER_SIZE + len <= MAX_PACKET;\n\n        long now = now();\n\n        byte[] buffer = new byte[HEADER_SIZE + (int)len];\n        long_to_bytes(m_conv, buffer, 0);\n        long_to_bytes(seq, buffer, 4);\n        long_to_bytes(m_rcv_nxt, buffer, 8);\n        buffer[12] = 0;\n        buffer[13] = (byte) (flags & 0xFF);\n        short_to_bytes(m_rcv_wnd >> m_rwnd_scale, buffer, 14);\n\n        // Timestamp computations\n        long_to_bytes(now, buffer, 16);\n        long_to_bytes(m_ts_recent, buffer, 20);\n        m_ts_lastack = m_rcv_nxt;\n\n        if (len > 0)\n        {\n            int bytes_read = m_sbuf.readOffset(buffer, HEADER_SIZE,\n                                               (int) len,\n                                               (int) offset);\n            assert bytes_read == len;\n        }\n        if (logger.isLoggable(Level.FINE))\n        {\n            logger.log(Level.FINE, \"<-- \" + debugName + \" <CONV=\" + m_conv + \"><FLG=\"\n                + flags + \"><SEQ=\" + seq + \":\" + (seq + len) + \"><ACK=\" + m_rcv_nxt + \">\"\n                + \"<WND=\" + m_rcv_wnd + \"><SCALE=\" + m_rwnd_scale + \"><TS=\" + now\n                + \"><TSR=\" + m_ts_recent + \"><LEN=\" + len + \">\");\n        }\n        WriteResult wres = m_notify.tcpWritePacket(this,\n                                                   buffer,\n                                                   (int) len + HEADER_SIZE);\n        /**\n         * Note: When len is 0, this is an ACK packet. We don't read the return\n         * value for those, and thus we won't retry. So go ahead and treat the\n         * packet as a success (basically simulate as if it were dropped), which\n         * will prevent our timers from being messed up.\n         */\n        if ((wres != WriteResult.WR_SUCCESS) && (0 != len))\n        {\n            return wres;\n        }\n        m_t_ack = 0;\n        if (len > 0)\n        {\n            m_lastsend = now;\n        }\n        m_lasttraffic = now;\n        m_bOutgoing = true;\n\n        return WriteResult.WR_SUCCESS;\n    }\n\n    /**\n     * Method can be used in debugging utilities to parse PTCP segment\n     * @param buffer data to parse\n     * @param size length of the data in the buffer\n     * @return the parsed segment\n     */\n    public static Segment parseSeg(byte[] buffer, int size)\n    {\n        if (size < 12)\n        {\n            return null;\n        }\n\n        Segment seg = new Segment();\n        seg.conv = bytes_to_long(buffer, 0);\n        seg.seq = bytes_to_long(buffer, 4);\n        seg.ack = bytes_to_long(buffer, 8);\n        seg.flags = buffer[13];\n        seg.wnd = bytes_to_short(buffer, 14);\n\n        seg.tsval = bytes_to_long(buffer, 16);\n        seg.tsecr = bytes_to_long(buffer, 20);\n\n        seg.data = copy_buffer(buffer, HEADER_SIZE, size - HEADER_SIZE);\n        seg.len = size - HEADER_SIZE;\n        \n        return seg;\n    }\n\n    /**\n     * Can be used to convert segments to text\n     * \n     * @param seg the {@link Segment} to format\n     * @return segment in readable text form\n     */\n    public static String segToStr(Segment seg)\n    {\n        String data=\"data: \";\n        for (byte b : seg.data)\n        {\n            data += b;\n        }\n        return \"<CONV=\" + seg.conv + \"><FLG=\" + seg.flags + \"><SEQ=\" \n            + seg.seq + \":\" + (seg.seq + seg.len) + \"><ACK=\" + seg.ack\n            + \"><WND=\" + seg.wnd + \"><TS=\" + seg.tsval\n            + \"><TSR=\" + seg.tsecr + \"><LEN=\" + seg.len + \"> \"+data;\n    }\n    \n    /**\n     * Creates new segment from the data in <tt>buffer</tt> which is processed\n     * by the protocol.\n     *\n     * @param buffer source buffer\n     * @param size data length\n     * @return true if successfully parsed the data\n     */\n    boolean parse(byte[] buffer, int size)\n    {\n        if (size < 12)\n        {\n            return false;\n        }\n\n        Segment seg = parseSeg(buffer, size);\n\n        if (logger.isLoggable(Level.FINE))\n        {\n            logger.log(Level.FINE,\n                       \"--> \" + debugName + \"<CONV=\" + seg.conv + \"><FLG=\" + seg.flags\n                + \"><SEQ=\" + seg.seq + \":\" + (seg.seq + seg.len) + \"><ACK=\" + seg.ack\n                + \"><WND=\" + seg.wnd + \"><SCALE=\" + m_swnd_scale + \"><TS=\" + seg.tsval\n                + \"><TSR=\" + seg.tsecr + \"><LEN=\" + seg.len + \">\");\n        }\n        return process(seg);\n    }\n\n    /**\n     * Calculates timeout in ms for current operation\n     *\n     * @param now current timestamp in ms\n     * @return next timeout or -1 in case of an error\n     */\n    long clock_check(long now)\n    {\n        if (m_shutdown == EnShutdown.SD_FORCEFUL)\n        {\n            return -1;\n        }\n\n        long nTimeout;\n        long snd_buffered;\n        snd_buffered = m_sbuf.getBuffered();\n        if ((m_shutdown == EnShutdown.SD_GRACEFUL)\n            && ((m_state != PseudoTcpState.TCP_ESTABLISHED)\n            || ((snd_buffered == 0) && (m_t_ack == 0))))\n        {\n            return -1;\n        }\n\n        if (m_state == PseudoTcpState.TCP_CLOSED)\n        {\n            return CLOSED_TIMEOUT;\n        }\n\n        nTimeout = DEFAULT_TIMEOUT;\n\n        if (m_t_ack > 0)\n        {\n            nTimeout = Math.min(nTimeout, timeDiff(m_t_ack + m_ack_delay, now));\n        }\n        if (m_rto_base > 0)\n        {\n            nTimeout = Math.min(nTimeout, timeDiff(m_rto_base + m_rx_rto, now));\n        }\n        if (getM_snd_wnd() == 0)\n        {\n            nTimeout = Math.min(nTimeout, timeDiff(m_lastsend + m_rx_rto, now));\n        }\n        if (PSEUDO_KEEPALIVE)\n        {\n            if (m_state == PseudoTcpState.TCP_ESTABLISHED)\n            {\n                nTimeout = Math.min(\n                    nTimeout,\n                    timeDiff(m_lasttraffic + (m_bOutgoing ? IDLE_PING * 3 / 2 : IDLE_PING), now));\n            }\n        }\n        //nTimeout is used on wait methods, so cannot be equal to 0\n        return nTimeout <= 0 ? 1 : nTimeout;\n    }\n\n    /**\n     * Process given segment\n     *\n     * @param seg\n     * @return false in case of error\n     */\n    boolean process(Segment seg)\n    {\n        // If this is the wrong conversation, send a reset!?! (with the correct conversation?)\n        if (seg.conv != m_conv)\n        {\n            //if ((seg.flags & FLAG_RST) == 0) {\n            //  packet(tcb, seg.ack, 0, FLAG_RST, 0, 0);\n            //}\n            //closedown(new IOException(\n            //    debugName + \" wrong conversation number, this: \" + m_conv\n            //    + \" remote: \" + seg.conv));\n            logger.info(debugName + \" wrong conversation number, this: \" + m_conv\n            + \" remote: \" + seg.conv);\n            return false;\n        }\n\n        long now = now();\n        m_lasttraffic = m_lastrecv = now;\n        m_bOutgoing = false;\n\n        if (m_state == PseudoTcpState.TCP_CLOSED)\n        {\n            // !?! send reset?\n            closedown(new IOException(debugName + \" in closed state\"));\n            return false;\n        }\n\n        // Check if this is a reset segment\n        if ((seg.flags & FLAG_RST) > 0)\n        {\n            //closedown(PseudoTcpError.ECONNRESET);\n            closedown(new IOException(\"Connection reset\"));\n            return false;\n        }\n\n        // Check for control data\n        boolean bConnect = false;\n        if ((seg.flags & FLAG_CTL) > 0)\n        {\n            if (seg.len == 0)\n            {\n                logger.log(Level.SEVERE, debugName + \" Missing control code\");\n                return false;\n            }\n            else\n            {\n                if (seg.data[0] == CTL_CONNECT)\n                {\n                    bConnect = true;\n\n                    // TCP options are in the remainder of the payload after CTL_CONNECT.\n                    if (!parseOptions(seg.data, 1, seg.len - 1))\n                    {\n                        return false;\n                    }\n\n                    if (m_state == PseudoTcpState.TCP_LISTEN)\n                    {\n                        m_state = PseudoTcpState.TCP_SYN_RECEIVED;\n                        logger.log(Level.FINE,\n                                   debugName + \" State: TCP_SYN_RECEIVED\");\n                        //m_notify->associate(addr);\n                        queueConnectMessage();\n                    }\n                    else\n                    {\n                        if (m_state == PseudoTcpState.TCP_SYN_SENT)\n                        {\n                            m_state = PseudoTcpState.TCP_ESTABLISHED;\n                            logger.log(Level.FINE,\n                                       debugName + \" State: TCP_ESTABLISHED\");\n                            adjustMTU();\n                            if (m_notify != null)\n                            {\n                                m_notify.onTcpOpen(this);\n                            }\n                            //notify(evOpen);\n                        }\n                    }\n                }\n                else\n                {\n                    logger.log(Level.SEVERE,\n                               debugName + \" Unknown control code: \" + seg.data[0]);\n                    return false;\n                }\n            }\n        }\n\n        // Update timestamp\n        if ((seg.seq <= m_ts_lastack) && (m_ts_lastack < seg.seq + seg.len))\n        {\n            m_ts_recent = seg.tsval;\n        }\n\n        // Check if this is a valuable ack\n        if ((seg.ack > m_snd_una) && (seg.ack <= m_snd_nxt))\n        {\n            // Calculate round-trip time\n            if (seg.tsecr > 0)\n            {\n                long rtt = timeDiff(now, seg.tsecr);\n                assert rtt >= 0;\n                if (m_rx_srtt == 0)\n                {\n                    m_rx_srtt = rtt;\n                    m_rx_rttvar = rtt / 2;\n                }\n                else\n                {\n                    m_rx_rttvar = (3 * m_rx_rttvar + Math.abs(rtt - m_rx_srtt)) / 4;\n                    m_rx_srtt = (7 * m_rx_srtt + rtt) / 8;\n                }\n                m_rx_rto = bound(MIN_RTO, m_rx_srtt\n                    + Math.max(1, 4 * m_rx_rttvar),\n                                 MAX_RTO);\n                if (logger.isLoggable(Level.FINER))\n                {\n                    logger.log(Level.FINER,\n                               \"rtt: \" + rtt + \" srtt: \" + m_rx_srtt + \" rto: \" + m_rx_rto);\n                }\n            }\n\n            m_snd_wnd = seg.wnd << m_swnd_scale;\n            //setWindowWithScale(seg.wnd, getM_swnd_scale());\n            //setM_snd_wnd(seg.wnd << m_swnd_scale);\n\n            long nAcked = seg.ack - m_snd_una;\n            synchronized (ack_notify)\n            {\n                \n                m_snd_una = seg.ack;\n\n                m_rto_base = (m_snd_una == m_snd_nxt) ? 0 : now;\n\n                m_sbuf.consumeReadData((int) nAcked);\n            \n                if (logger.isLoggable(Level.FINER))\n                {\n                    logger.log(Level.FINER,\n                               debugName + \" acked: \" + nAcked\n                        + \" m_snd_una: \" + m_snd_una);\n                }\n                ack_notify.notifyAll();\n            }\n\n            for (long nFree = nAcked; nFree > 0;)\n            {\n                assert !m_slist.isEmpty();\n                if (nFree < m_slist.get(0).len)\n                {\n                    m_slist.get(0).len -= nFree;\n                    m_slist.get(0).seq += nFree;\n                    nFree = 0;\n                }\n                else\n                {\n                    if (m_slist.get(0).len > m_largest)\n                    {\n                        m_largest = m_slist.get(0).len;\n                    }\n                    nFree -= m_slist.get(0).len;\n                    m_slist.remove(0);\n                    //m_slist.pop_front();\n                }\n            }\n\n            if (m_dup_acks >= 3)\n            {\n                if (m_snd_una >= m_recover)\n                { // NewReno\n                    long nInFlight = m_snd_nxt - m_snd_una;\n                    m_cwnd = Math.min(m_ssthresh, nInFlight + m_mss); // (Fast Retransmit)\n                    logger.log(Level.FINE, \"exit recovery\");\n                    m_dup_acks = 0;\n                }\n                else\n                {\n                    logger.log(Level.FINE, \"recovery retransmit\");\n                    if (!transmit(m_slist.get(0), now))\n                    {\n                        //closedown(PseudoTcpError.ECONNABORTED);\n                        closedown(new IOException(\"Connection aborted\"));\n                        return false;\n                    }\n                    m_cwnd += m_mss - Math.min(nAcked, m_cwnd);\n                }\n            }\n            else\n            {\n                m_dup_acks = 0;\n                // Slow start, congestion avoidance\n                if (m_cwnd < m_ssthresh)\n                {\n                    m_cwnd += m_mss;\n                }\n                else\n                {\n                    m_cwnd += Math.max(1, m_mss * m_mss / m_cwnd);\n                }\n            }\n        }\n        else\n        {\n            if (seg.ack == m_snd_una)\n            {\n                // !?! Note, tcp says don't do this... but otherwise how does a closed window become open?\n                //setWindowWithScale(seg.wnd, getM_swnd_scale());\n                m_snd_wnd = seg.wnd << m_swnd_scale;\n                //setM_snd_wnd(seg.wnd << m_swnd_scale);\n\n                // Check duplicate acks\n                if (seg.len > 0)\n                {\n                    // it's a dup ack, but with a data payload, so don't modify m_dup_acks\n                }\n                else\n                {\n                    if (m_snd_una != m_snd_nxt)\n                    {\n                        m_dup_acks += 1;\n                        if (m_dup_acks == 3)\n                        { // (Fast Retransmit)\n                            if (logger.isLoggable(Level.FINE))\n                            {\n                                logger.log(Level.FINE,\n                                           debugName + \" enter recovery\");\n                                logger.log(Level.FINE,\n                                           debugName + \" recovery retransmit\");\n                            }\n                            if (!transmit(m_slist.get(0), now))\n                            {\n                                closedown(new IOException(\"Connection aborted\"));\n                                //closedown(PseudoTcpError.ECONNABORTED);\n                                return false;\n                            }\n                            m_recover = m_snd_nxt;\n                            long nInFlight = m_snd_nxt - m_snd_una;\n                            m_ssthresh = Math.max(nInFlight / 2, 2 * m_mss);\n                            //Logger.Log(LS_INFO)\n                            //  << \"m_ssthresh: \" << m_ssthresh << \"  nInFlight: \" << nInFlight << \"  m_mss: \" << m_mss;\n                            m_cwnd = m_ssthresh + 3 * m_mss;\n                        }\n                        else\n                        {\n                            if (m_dup_acks > 3)\n                            {\n                                m_cwnd += m_mss;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        m_dup_acks = 0;\n                    }\n                }\n            }\n        }\n        // !?! A bit hacky\n        if ((m_state == PseudoTcpState.TCP_SYN_RECEIVED) && !bConnect)\n        {\n            m_state = PseudoTcpState.TCP_ESTABLISHED;\n            logger.log(Level.FINE, debugName + \" State: TCP_ESTABLISHED\");\n            adjustMTU();\n            if (m_notify != null)\n            {\n                m_notify.onTcpOpen(this);\n            }\n            //notify(evOpen);\n        }\n        // If we make room in the send queue, notify the user\n        // The goal it to make sure we always have at least enough data to fill the\n        // window.  We'd like to notify the app when we are halfway to that point.\n        long kIdealRefillSize = (m_sbuf_len + m_rbuf_len) / 2;\n        long snd_buffered = m_sbuf.getBuffered();\n        if (m_bWriteEnable && snd_buffered < kIdealRefillSize)\n        {\n            m_bWriteEnable = false;\n            if (m_notify != null)\n            {\n                m_notify.onTcpWriteable(this);\n            }\n            //notify(evWrite);\n        }\n        // Conditions were acks must be sent:\n        // 1) Segment is too old (they missed an ACK) (immediately)\n        // 2) Segment is too new (we missed a segment) (immediately)\n        // 3) Segment has data (so we need to ACK!) (delayed)\n        // ... so the only time we don't need to ACK, is an empty segment that points to rcv_nxt!\n        SendFlags sflags = SendFlags.sfNone;\n        if (seg.seq != m_rcv_nxt)\n        {\n            sflags = SendFlags.sfImmediateAck; // (Fast Recovery)\n        }\n        else\n        {\n            if (seg.len\n                != 0)\n            {\n                if (m_ack_delay == 0)\n                {\n                    sflags = SendFlags.sfImmediateAck;\n                }\n                else\n                {\n                    sflags = SendFlags.sfDelayedAck;\n                }\n            }\n        }\n\n        if (sflags == SendFlags.sfImmediateAck)\n        {\n            if (seg.seq > m_rcv_nxt)\n            {\n                logger.log(Level.FINER,\n                           \"too new, seq.seq=\" + seg.seq\n                                + \", seg.len=\" + seg.len\n                                + \", m_rcv_nxt=\" + m_rcv_nxt);\n            }\n            else\n            {\n                if (seg.seq + seg.len <= m_rcv_nxt)\n                {\n                    logger.log(Level.FINER,\n                               \"too old, seq.seq=\" + seg.seq\n                                    + \", seg.len=\" + seg.len\n                                    + \", m_rcv_nxt=\" + m_rcv_nxt);\n                }\n            }\n        }\n\n        // Adjust the incoming segment to fit our receive buffer\n        if (seg.seq < m_rcv_nxt)\n        {\n            long nAdjust = m_rcv_nxt - seg.seq;\n            if (nAdjust < seg.len)\n            {\n                seg.seq += nAdjust;\n                seg.data = scrollBuffer(seg.data, (int)nAdjust);\n                seg.len -= nAdjust;\n            }\n            else\n            {\n                seg.len = 0;\n            }\n        }\n        long available_space = m_rbuf.getWriteRemaining();\n        if ((seg.seq + seg.len - m_rcv_nxt) > available_space)\n        {\n            long nAdjust = seg.seq + seg.len - m_rcv_nxt - available_space;\n            if (nAdjust < seg.len)\n            {\n                seg.len -= nAdjust;\n            }\n            else\n            {\n                seg.len = 0;\n            }\n        }\n        boolean bIgnoreData = ((seg.flags & FLAG_CTL) > 0) || (m_shutdown != EnShutdown.SD_NONE);\n        boolean bNewData = false;\n        if (seg.len > 0)\n        {\n            if (bIgnoreData)\n            {\n                if (seg.seq == m_rcv_nxt)\n                {\n                    m_rcv_nxt += seg.len;\n                }\n            }\n            else\n            {\n                long nOffset = seg.seq - m_rcv_nxt;\n\n                int result = m_rbuf.writeOffset(seg.data, seg.len,\n                                                (int) nOffset);\n                assert result == seg.len;\n\n                if (seg.seq == m_rcv_nxt)\n                {\n                    if (logger.isLoggable(Level.FINEST))\n                    {\n                        logger.log(Level.FINEST,\n                                   \"Avail space: \" + available_space\n                            + \" seg.len: \" + seg.len);\n                    }\n                    m_rbuf.consumeWriteBuffer(seg.len);\n                    m_rcv_nxt += seg.len;\n                    m_rcv_wnd -= seg.len;\n                    bNewData = true;\n\n\n                    Iterator<RSegment> iter = m_rlist.iterator();\n                    List<RSegment> toBeRemoved = new ArrayList<>();\n                    while (iter.hasNext())\n                    {\n                        RSegment it = iter.next();\n                        if (it.seq > m_rcv_nxt)\n                        {\n                            break;\n                        }\n                        if (it.seq + it.len > m_rcv_nxt)\n                        {\n                            sflags = SendFlags.sfImmediateAck; // (Fast Recovery)\n                            long nAdjust = (it.seq + it.len) - m_rcv_nxt;\n                            if (logger.isLoggable(Level.FINE))\n                            {\n                                logger.log(Level.FINE,\n                                           \"Recovered \" + nAdjust + \" bytes (\"\n                                    + m_rcv_nxt + \" -> \" + (m_rcv_nxt + nAdjust)\n                                    + \")\");\n                            }\n                            m_rbuf.consumeWriteBuffer((int) nAdjust);\n                            m_rcv_nxt += nAdjust;\n                            m_rcv_wnd -= nAdjust;\n                        }\n                        toBeRemoved.add(it);\n                    }\n                    m_rlist.removeAll(toBeRemoved);\n                }\n                else\n                {\n                    if (logger.isLoggable(Level.FINE))\n                    {\n                        logger.log(Level.FINE,\n                                   \"Saving \" + seg.len + \" bytes (\" + seg.seq\n                            + \" -> \" + (seg.seq + seg.len) + \")\");\n                    }\n                    RSegment rseg = new RSegment(seg.seq, seg.len);\n                    int insertPos;\n                    for (insertPos = 0; insertPos < m_rlist.size(); insertPos++)\n                    {\n                        RSegment it = m_rlist.get(insertPos);\n                        if (it.seq >= rseg.seq)\n                        {\n                            break;\n                        }\n                    }\n                    m_rlist.add(insertPos, rseg);\n                }\n            }\n        }\n\n        attemptSend(sflags);\n        // If we have new data, notify the user\n        if (bNewData && m_bReadEnable)\n        {\n            m_bReadEnable = false;\n            if (m_notify != null)\n            {\n                m_notify.onTcpReadable(this);\n            }\n            //notify(evRead);\n        }\n        return true;\n    }\n\n    /**\n     * Util time method\n     *\n     * @param later timestamp in ms\n     * @param earlier timestamp in ms\n     * @return difference between <tt>later</tt> and <tt>earlier</tt>\n     */\n    private static long timeDiff(long later, long earlier)\n    {\n        return later - earlier;\n    }\n\n    /**\n     * Stores 32 bit unsigned int in a buffer at specified offset\n     *\n     * @param anUnsignedInt\n     * @param buf destination buffer\n     * @param offset destination buffer's offset\n     */\n    private static void long_to_bytes(long anUnsignedInt, byte[] buf, int offset)\n    {\n        buf[offset] = (byte) ((anUnsignedInt & 0xFF000000L) >>> 24);\n        buf[offset + 1] = (byte) ((anUnsignedInt & 0x00FF0000L) >>> 16);\n        buf[offset + 2] = (byte) ((anUnsignedInt & 0x0000FF00L) >>> 8);\n        buf[offset + 3] = (byte) ((anUnsignedInt & 0x000000FFL));\n        //java.nio.ByteBuffer.wrap(buffer, offset, 4).putInt((int) (m_conv & 0xFFFFFFFFL));\n    }\n\n    /**\n     * Stores 16 bit unsigned int in the buffer at specified offset\n     *\n     * @param anUnsignedShort\n     * @param buf destination buffer\n     * @param offset destination buffer's offset\n     */\n    private static void short_to_bytes(int anUnsignedShort, byte[] buf, int offset)\n    {\n        buf[offset] = (byte) ((anUnsignedShort & 0xFF00) >>> 8);\n        buf[offset + 1] = (byte) ((anUnsignedShort & 0x00FF));\n        //java.nio.ByteBuffer.wrap(buffer, offset, 2).putShort((short) (shrt & 0xFFFF));\n    }\n\n    /**\n     * Reads 32 bit unsigned int from the buffer at specified offset\n     *\n     * @param buffer\n     * @param offset\n     * @return 32 bit unsigned value\n     */\n    private static long bytes_to_long(byte[] buffer, int offset)\n    {\n        int fByte = (0x000000FF & ((int) buffer[offset]));\n        int sByte = (0x000000FF & ((int) buffer[offset + 1]));\n        int tByte = (0x000000FF & ((int) buffer[offset + 2]));\n        int foByte = (0x000000FF & ((int) buffer[offset + 3]));\n        return ((long) (fByte << 24\n            | sByte << 16\n            | tByte << 8\n            | foByte))\n            & 0xFFFFFFFFL;\n    }\n\n    /**\n     * Reads 16 bit unsigned int from the buffer at specified offset\n     *\n     * @param buffer\n     * @param offset\n     * @return 16 bit unsigned int\n     */\n    private static int bytes_to_short(byte[] buffer, int offset)\n    {\n        int fByte = (0x000000FF & ((int) buffer[offset]));\n        int sByte = (0x000000FF & ((int) buffer[offset + 1]));\n        return ((fByte << 8\n            | sByte))\n            & 0xFFFF;\n    }\n\n    /**\n     * Wrapped system function arrayCopy\n     *\n     * @param buffer source buffer\n     * @param sOffset source buffer offset\n     * @param len bytes count to be copied\n     * @return new buffer size of <tt>len</tt>\n     */\n    private static byte[] copy_buffer(byte[] buffer, int sOffset, int len)\n    {\n        byte[] newData = new byte[len];\n        System.arraycopy(buffer, sOffset, newData, 0, len);\n        return newData;\n    }\n\n    /**\n     *\n     * @param lower\n     * @param middle\n     * @param upper\n     * @return\n     */\n    private long bound(long lower, long middle, long upper)\n    {\n        return Math.min(Math.max(lower, middle), upper);\n    }\n\n    private byte[] scrollBuffer(byte[] data, int nAdjust)\n    {\n        byte[] newBuffer = new byte[data.length - nAdjust];\n        System.arraycopy(data, nAdjust, newBuffer, 0, newBuffer.length);\n        return newBuffer;\n    }\n\n    /**\n     * Transmits given segment\n     *\n     * @param seg segment to be sent\n     * @param now current timestamp\n     * @return false in case of error\n     */\n    boolean transmit(SSegment seg, long now)\n    {\n        //  Logger.Log(LS_INFO) << \"seg->xmit: \"<< seg->xmit;\n        if (seg.xmit >= ((m_state == PseudoTcpState.TCP_ESTABLISHED) ? 15 : 30))\n        {\n            logger.log(Level.FINE, \"too many retransmits\");\n            return false;\n        }\n\n        long nTransmit = Math.min(seg.len, m_mss);\n\n        while (true)\n        {\n            long seq = seg.seq;\n            short flags = (seg.bCtrl ? FLAG_CTL : 0);\n            WriteResult wres = packet(seq,\n                                      flags,\n                                      seg.seq - m_snd_una,\n                                      nTransmit);\n\n            if (wres == WriteResult.WR_SUCCESS)\n            {\n                break;\n            }\n\n            if (wres == WriteResult.WR_FAIL)\n            {\n                logger.log(Level.WARNING, \"packet failed\");\n                return false;\n            }\n\n            assert wres == WriteResult.WR_TOO_LARGE;\n\n            while (true)\n            {\n                if (PACKET_MAXIMUMS[(m_msslevel + 1)] == 0)\n                {\n                    logger.log(Level.INFO, \"MTU too small\");\n                    return false;\n                }\n                // !?! We need to break up all outstanding and pending packets and then retransmit!?!\n\n                m_mss = PACKET_MAXIMUMS[++m_msslevel] - PACKET_OVERHEAD;\n                m_cwnd = 2 * m_mss; // I added this... haven't researched actual formula\n                if (m_mss < nTransmit)\n                {\n                    nTransmit = m_mss;\n                    break;\n                }\n            }\n            if (logger.isLoggable(Level.INFO))\n            {\n                logger.log(Level.INFO, \"Adjusting mss to \" + m_mss + \" bytes\");\n            }\n        }\n\n        if (nTransmit < seg.len)\n        {\n            if (logger.isLoggable(Level.INFO))\n            {\n                logger.log(Level.INFO, \"mss reduced to \" + m_mss);\n            }\n            SSegment subseg = new SSegment(seg.seq + nTransmit,\n                                           seg.len - nTransmit, seg.bCtrl);\n            //subseg.tstamp = seg->tstamp;\n            subseg.xmit = seg.xmit;\n            seg.len = nTransmit;\n\n            //SList::iterator next = seg;                        \n            m_slist.add(m_slist.indexOf(seg) + 1, subseg);\n        }\n\n        if (seg.xmit == 0)\n        {\n            m_snd_nxt += seg.len;\n        }\n        seg.xmit += 1;\n        //seg->tstamp = now;\n        if (m_rto_base == 0)\n        {\n            m_rto_base = now;\n        }\n\n        return true;\n    }\n\n    /**\n     * This method checks if it's time to send a packet(ack or retransmit\n     * anything)\n     *\n     * @param sflags\n     */\n    void attemptSend(SendFlags sflags)\n    {\n        long now = now();\n\n        if (timeDiff(now, m_lastsend) > m_rx_rto)\n        {\n            m_cwnd = m_mss;\n        }\n        boolean bFirst = true;\n\n        while (true)\n        {\n            long cwnd = m_cwnd;\n            if ((m_dup_acks == 1) || (m_dup_acks == 2))\n            { // Limited Transmit\n                cwnd += m_dup_acks * m_mss;\n            }\n            long nWindow = Math.min(getM_snd_wnd(), cwnd);\n            long nInFlight = m_snd_nxt - m_snd_una;\n            long nUseable = (nInFlight < nWindow) ? (nWindow - nInFlight) : 0;\n\n            long snd_buffered = m_sbuf.getBuffered();\n            /*\n             * System.out.println(\"is available? buffered: \" + snd_buffered + \"\n             * inFlight: \" + nInFlight + \" m_mss: \" + m_mss + \" m_snd_wnd: \" +\n             * getM_snd_wnd() + \" cwnd: \" + cwnd + \" nWindow: \" + nWindow + \"\n             * nUseable: \" + nUseable);\n             */\n            long nAvailable = Math.min(snd_buffered - nInFlight, m_mss);\n\n            if (nAvailable > nUseable)\n            {\n                if (nUseable * 4 < nWindow)\n                {\n                    // RFC 813 - avoid SWS\n                    logger.log(Level.FINER,\n                               \"RFC 813 - avoid SWS(nAvailable = 0)\");\n                    nAvailable = 0;\n                }\n                else\n                {\n                    nAvailable = nUseable;\n                }\n            }\n\n            if (bFirst)\n            {\n                long available_space = m_sbuf.getWriteRemaining();\n\n                bFirst = false;\n                if (logger.isLoggable(Level.FINE))\n                {\n                    logger.log(Level.FINE,\n                               \"[cwnd: \" + m_cwnd + \" nWindow: \" + nWindow\n                        + \" nInFlight: \" + nInFlight + \" nAvailable: \" + nAvailable\n                        + \" nQueued: \" + snd_buffered + \" nEmpty: \" + available_space\n                        + \" ssthresh: \" + m_ssthresh + \"]\");\n                }\n            }\n\n            if (nAvailable == 0)\n            {\n                if (sflags == SendFlags.sfNone)\n                {\n                    logger.log(Level.FINEST, \"nAvailable == 0: quit\");\n                    return;\n                }\n\n                // If this is an immediate ack, or the second delayed ack\n                if ((sflags == SendFlags.sfImmediateAck) || (m_t_ack > 0))\n                {\n                    packet(m_snd_nxt, (short) 0, 0, 0);\n                    logger.log(Level.FINER, \"Immediate ack: \");\n                }\n                else\n                {\n                    m_t_ack = now();\n                    if (logger.isLoggable(Level.FINER))\n                    {\n                        logger.log(\n                            Level.FINER, \"Delayed ack, m_t_ack: \" + m_t_ack);\n                    }\n                }\n                return;\n            }\n\n            // Nagle's algorithm.\n            // If there is data already in-flight, and we haven't a full segment of\n            // data ready to send then hold off until we get more to send, or the\n            // in-flight data is acknowledged.\n            if (m_use_nagling && (m_snd_nxt > m_snd_una) && (nAvailable < m_mss))\n            {\n                logger.log(Level.FINER, \"wait until more data is acked\");\n                return;\n            }\n\n            // Find the next segment to transmit\n            SSegment seg = null;\n            Iterator<SSegment> iter = m_slist.iterator();\n            do\n            {\n                SSegment it = iter.next();\n                if (it.xmit == 0)\n                {\n                    seg = it;\n                    break;\n                }\n            }\n            while (iter.hasNext());\n\n            assert seg != null;\n\n            // If the segment is too large, break it into two\n            if (seg.len > nAvailable)\n            {\n                logger.log(Level.FINEST, \"Break a segment into 2\");\n                SSegment subseg = new SSegment(\n                    seg.seq + nAvailable,\n                    seg.len - nAvailable,\n                    seg.bCtrl);\n                seg.len = nAvailable;\n                //m_slist.insert(++it, subseg);\n                m_slist.add(m_slist.indexOf(seg) + 1, subseg);\n            }\n            if (logger.isLoggable(Level.FINEST))\n            {\n                logger.log(Level.FINEST,\n                           \"TRANSMIT SEGMENT seq: \" + seg.seq\n                    + \" len: \" + seg.len);\n            }\n            if (!transmit(seg, now))\n            {\n                logger.log(Level.SEVERE, \"transmit failed\");\n                // TODO: consider closing socket\n                return;\n            }\n\n            sflags = SendFlags.sfNone;\n        }\n    }\n\n    /**\n     * This metod is called in case of en error. Tcp enters closed state and\n     * notifies listener about it.\n     *\n     * @param e exception to be propagated\n     */\n    void closedown(IOException e)\n    {\n        logger.log(Level.FINE, debugName + \" State: TCP_CLOSED \");\n        m_state = PseudoTcpState.TCP_CLOSED;\n        if (m_notify != null)\n        {\n            m_notify.onTcpClosed(this, e);\n        }\n    }\n\n    /**\n     * Adjusts MTU\n     */\n    void adjustMTU()\n    {\n        // Determine our current mss level, so that we can adjust appropriately later\n        for (m_msslevel = 0; PACKET_MAXIMUMS[(m_msslevel + 1)] > 0; ++m_msslevel)\n        {\n            if (PACKET_MAXIMUMS[m_msslevel] <= m_mtu_advise)\n            {\n                break;\n            }\n        }\n        m_mss = m_mtu_advise - PACKET_OVERHEAD;\n        // !?! Should we reset m_largest here?        \n        logger.log(Level.FINE, \"Adjusting mss to \" + m_mss + \" bytes\");\n\n        // Enforce minimums on ssthresh and cwnd\n        m_ssthresh = Math.max(m_ssthresh, 2 * m_mss);\n        m_cwnd = Math.max(m_cwnd, m_mss);\n    }\n\n    /**\n     *\n     * @return true if receive buffer is full\n     */\n    boolean isReceiveBufferFull()\n    {\n        return m_rbuf.getWriteRemaining() == 0;\n    }\n\n    /**\n     * Disables window scaling. Must be called before the connection is\n     * established.\n     */\n    void disableWindowScale()\n    {\n        m_support_wnd_scale = false;\n    }\n\n    /**\n     * Enqueues connect message\n     */\n    void queueConnectMessage()\n    {\n        byte[] buff = null;        \n        if (m_support_wnd_scale)\n        {\n            buff = new byte[4];\n            buff[1] = TCP_OPT_WND_SCALE & 0xFF;\n            buff[2] = 1;\n            buff[3] = (byte) (m_rwnd_scale & 0xFF);\n        }\n        else\n        {\n            buff = new byte[1];\n        }\n        buff[0] = CTL_CONNECT & 0xFF;\n        m_snd_wnd = buff.length;\n        queue(buff, 0, buff.length, true);\n    }\n\n    /**\n     * Parse and process option in given buffer/offset/length\n     *\n     * @param data source buffer\n     * @param offset source offset\n     * @param len byte count\n     * @return true if options were properly parsed\n     */\n    boolean parseOptions(byte[] data, int offset, int len)\n    {\n        List<Short> options_specified = new ArrayList<>();\n\n        // See http://www.freesoft.org/CIE/Course/Section4/8.htm for\n        // parsing the options list.\n        java.nio.ByteBuffer buf = java.nio.ByteBuffer.wrap(data, offset, len);\n        while (buf.hasRemaining())\n        {\n            short kind = TCP_OPT_EOL;\n            short tmp = buf.get();\n            if (tmp != -1)\n            {\n                kind = tmp;\n            }\n            if (kind == TCP_OPT_EOL)\n            {\n                // End of option list.\n                break;\n            }\n            else\n            {\n                if (kind == TCP_OPT_NOOP)\n                {\n                    // No op.\n                    continue;\n                }\n            }\n\n            // Length of this option.\n            assert len != 0;\n            //UNUSED(len);\n            short opt_len = buf.get();\n\n            // Content of this option.\n            if (opt_len <= buf.remaining())\n            {\n                byte[] opt_data = new byte[opt_len];\n                buf.get(opt_data);\n                applyOption(kind, opt_data, opt_len);\n            }\n            else\n            {\n                logger.log(Level.SEVERE, \n                    \"Invalid option length received: \"+opt_len\n                    +\" data len: \"+buf.remaining());\n                return false;\n            }\n            options_specified.add(kind);\n        }\n\n        if (!options_specified.contains(TCP_OPT_WND_SCALE))\n        {\n            logger.log(Level.WARNING, \"Peer doesn't support window scaling\");\n            if (getM_rwnd_scale() > 0)\n            {\n                // Peer doesn't support TCP options and window scaling.\n                // Revert receive buffer size to default value.\n                resizeReceiveBuffer(DEFAULT_RCV_BUF_SIZE);\n                m_swnd_scale = 0;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Applies <tt>kind</tt> of option and it's data\n     *\n     * @param kind option type\n     * @param data option's data buffer\n     * @param len data length\n     */\n    void applyOption(short kind, byte[] data, long len)\n    {\n        if (kind == TCP_OPT_MSS)\n        {\n            logger.log(\n                Level.WARNING,\n                \"Peer specified MSS option which is not supported.\");\n            // TODO: Implement.\n        }\n        else\n        {\n            if (kind == TCP_OPT_WND_SCALE)\n            {\n                // Window scale factor.\n                // http://www.ietf.org/rfc/rfc1323.txt\n                if (len != 1)\n                {\n                    logger.log(Level.SEVERE, \"Invalid window scale option received.\");\n                    return;\n                }\n                applyWindowScaleOption(data[0]);\n            }\n        }\n    }\n\n    /**\n     * Applies window scale option with given <tt>scale_factor</tt>\n     *\n     * @param scale_factor\n     */\n    void applyWindowScaleOption(short scale_factor)\n    {\n        m_swnd_scale = scale_factor;\n    }\n\n    /**\n     * Resizes send buffer to <tt>new_size</tt>\n     *\n     * @param new_size\n     */\n    void resizeSendBuffer(int new_size)\n    {\n        m_sbuf_len = new_size;\n        m_sbuf.setCapacity(new_size);\n    }\n\n    /**\n     * Resizes receive buffer to <tt>new_size</tt>\n     *\n     * @param new_size\n     */\n    void resizeReceiveBuffer(int new_size)\n    {\n        short scale_factor = 0;\n\n        // Determine the scale factor such that the scaled window size can fit\n        // in a 16-bit unsigned integer.\n        while (new_size > 0xFFFF)\n        {\n            ++scale_factor;\n            new_size >>= 1;\n        }\n\n        // Determine the proper size of the buffer.\n        new_size <<= scale_factor;\n        boolean result = m_rbuf.setCapacity(new_size);\n\n        // Make sure the new buffer is large enough to contain data in the old\n        // buffer. This should always be true because this method is called either\n        // before connection is established or when peers are exchanging connect\n        // messages.\n        assert result;\n        m_rbuf_len = new_size;\n        m_rwnd_scale = scale_factor;\n        m_ssthresh = new_size;\n\n        int available_space = m_rbuf.getWriteRemaining();\n        m_rcv_wnd = available_space;\n    }\n\n    /**\n     * @return send window size\n     */\n    int getM_snd_wnd()\n    {\n        return m_snd_wnd;\n    }\n\n    /**\n     *\n     * @return current @link{PseudoTcpState}\n     */\n    public PseudoTcpState getState()\n    {\n        return m_state;\n    }\n\n    /**\n     *\n     * @return send buffer's length\n     */\n    int getSendBufferSize()\n    {\n        return m_sbuf_len;\n    }\n\n    /**\n     *\n     * @return receive buffer's length\n     */\n    int getRecvBufferSize()\n    {\n        return m_rbuf_len;\n    }\n\n    /**\n     * @return the receive window scale\n     */\n    public short getM_rwnd_scale()\n    {\n        return m_rwnd_scale;\n    }\n\n    /**\n     * @return the send window scale\n     */\n    public short getM_swnd_scale()\n    {\n        return m_swnd_scale;\n    }\n    private final Object ack_notify = new Object();\n\n    public Object getAckNotify()\n    {\n        return ack_notify;\n    }\n\n    long getConversationID()\n    {\n        return m_conv;\n    }\n\n    void setConversationID(long convID)\n    {\n        if (m_state != PseudoTcpState.TCP_LISTEN)\n            throw new IllegalStateException();\n        this.m_conv = convID;\n    }\n\n    \n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger =\n        Logger.getLogger(PseudoTCPBase.class.getName());", "docstring": "\nThe logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger =\n        Logger.getLogger(PseudoTCPBase.class.getName())", "syntax_pass": true}, {"attribute_expression": "private static boolean PSEUDO_KEEPALIVE = false;", "docstring": "\nKeepalive - disabled by default\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "boolean", "name": "PSEUDO_KEEPALIVE = false", "syntax_pass": true}, {"attribute_expression": "static final int[] PACKET_MAXIMUMS = new int[]\n    {\n        65535, // Theoretical maximum, Hyperchannel\n        32000, // Nothing\n        17914, // 16Mb IBM Token Ring\n        8166, // IEEE 802.4\n        //4464,   // IEEE 802.5 (4Mb max)\n        4352, // FDDI\n        //2048,   // Wideband Network\n        2002, // IEEE 802.5 (4Mb recommended)\n        //1536,   // Expermental Ethernet Networks\n        //1500,   // Ethernet, Point-to-Point (default)\n        1492, // IEEE 802.3\n        1006, // SLIP, ARPANET\n        //576,    // X.25 Networks\n        //544,    // DEC IP Portal\n        //512,    // NETBIOS\n        508, // IEEE 802/Source-Rt Bridge, ARCNET\n        296, // Point-to-Point (low delay)\n        //68,     // Official minimum\n        0, // End of list marker\n    };", "docstring": "\nPacket maximum levels\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int[]", "name": "PACKET_MAXIMUMS = new int[]\n    {\n        65535, // Theoretical maximum, Hyperchannel\n        32000, // Nothing\n        17914, // 16Mb IBM Token Ring\n        8166, // IEEE 802.4\n        //4464,   // IEEE 802.5 (4Mb max)\n        4352, // FDDI\n        //2048,   // Wideband Network\n        2002, // IEEE 802.5 (4Mb recommended)\n        //1536,   // Expermental Ethernet Networks\n        //1500,   // Ethernet, Point-to-Point (default)\n        1492, // IEEE 802.3\n        1006, // SLIP, ARPANET\n        //576,    // X.25 Networks\n        //544,    // DEC IP Portal\n        //512,    // NETBIOS\n        508, // IEEE 802/Source-Rt Bridge, ARCNET\n        296, // Point-to-Point (low delay)\n        //68,     // Official minimum\n        0, // End of list marker\n    }", "syntax_pass": true}, {"attribute_expression": "static final int MAX_PACKET = 65535;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "MAX_PACKET = 65535", "syntax_pass": true}, {"attribute_expression": "static final int MIN_PACKET = 296;", "docstring": " Note: we removed lowest level because packet overhead was larger!", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "MIN_PACKET = 296", "syntax_pass": true}, {"attribute_expression": "static final int IP_HEADER_SIZE = 20;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "IP_HEADER_SIZE = 20", "syntax_pass": true}, {"attribute_expression": "static final int ICMP_HEADER_SIZE = 8;", "docstring": " (+ up to 40 bytes of options?)", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "ICMP_HEADER_SIZE = 8", "syntax_pass": true}, {"attribute_expression": "static final int UDP_HEADER_SIZE = 8;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "UDP_HEADER_SIZE = 8", "syntax_pass": true}, {"attribute_expression": "static final int JINGLE_HEADER_SIZE = 64;", "docstring": " TODO: Make JINGLE_HEADER_SIZE transparent to this code?", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "JINGLE_HEADER_SIZE = 64", "syntax_pass": true}, {"attribute_expression": "public static final int DEFAULT_RCV_BUF_SIZE = 60 * 1024;", "docstring": " Default size for receive and send buffer.", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_RCV_BUF_SIZE = 60 * 1024", "syntax_pass": true}, {"attribute_expression": "public static final int DEFAULT_SND_BUF_SIZE = 90 * 1024;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_SND_BUF_SIZE = 90 * 1024", "syntax_pass": true}, {"attribute_expression": "static final long MAX_SEQ = 0xFFFFFFFFL;", "docstring": "///////////////////////////////////////////////////////////////////", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long", "name": "MAX_SEQ = 0xFFFFFFFFL", "syntax_pass": true}, {"attribute_expression": "static final int HEADER_SIZE = 24;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "HEADER_SIZE = 24", "syntax_pass": true}, {"attribute_expression": "static final int PACKET_OVERHEAD = HEADER_SIZE + UDP_HEADER_SIZE + IP_HEADER_SIZE + JINGLE_HEADER_SIZE;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "PACKET_OVERHEAD = HEADER_SIZE + UDP_HEADER_SIZE + IP_HEADER_SIZE + JINGLE_HEADER_SIZE", "syntax_pass": true}, {"attribute_expression": "static final long MIN_RTO = 250;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long", "name": "MIN_RTO = 250", "syntax_pass": true}, {"attribute_expression": "static final long DEF_RTO = 3000;", "docstring": " 250 ms (RFC1122, Sec 4.2.3.1 \"fractions of a second\")", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long", "name": "DEF_RTO = 3000", "syntax_pass": true}, {"attribute_expression": "static final long MAX_RTO = 60000;", "docstring": " 3 seconds (RFC1122, Sec 4.2.3.1)", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long", "name": "MAX_RTO = 60000", "syntax_pass": true}, {"attribute_expression": "static final long DEF_ACK_DELAY = 100;", "docstring": " 60 seconds", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long", "name": "DEF_ACK_DELAY = 100", "syntax_pass": true}, {"attribute_expression": "static final short FLAG_CTL = 0x02;", "docstring": " 100 milliseconds", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "short", "name": "FLAG_CTL = 0x02", "syntax_pass": true}, {"attribute_expression": "static final short FLAG_RST = 0x04;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "short", "name": "FLAG_RST = 0x04", "syntax_pass": true}, {"attribute_expression": "static final short CTL_CONNECT = 0;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "short", "name": "CTL_CONNECT = 0", "syntax_pass": true}, {"attribute_expression": "static final short CTL_EXTRA = 255;", "docstring": "static final short CTL_REDIRECT = 1;", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "short", "name": "CTL_EXTRA = 255", "syntax_pass": true}, {"attribute_expression": "static final short TCP_OPT_EOL = 0;", "docstring": "\nEnd of list\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "short", "name": "TCP_OPT_EOL = 0", "syntax_pass": true}, {"attribute_expression": "static final short TCP_OPT_NOOP = 1;", "docstring": "\nNo-op\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "short", "name": "TCP_OPT_NOOP = 1", "syntax_pass": true}, {"attribute_expression": "static final short TCP_OPT_MSS = 2;", "docstring": "\nMaximum segment size\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "short", "name": "TCP_OPT_MSS = 2", "syntax_pass": true}, {"attribute_expression": "static final short TCP_OPT_WND_SCALE = 3;", "docstring": "\nWindow scale factor\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "short", "name": "TCP_OPT_WND_SCALE = 3", "syntax_pass": true}, {"attribute_expression": "static final int CTRL_BOUND = 0x80000000;", "docstring": "static final short FLAG_ACK = 0x10;", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "CTRL_BOUND = 0x80000000", "syntax_pass": true}, {"attribute_expression": "static final long DEFAULT_TIMEOUT = 4000;", "docstring": "\nIf there are no pending clocks, wake up every 4 seconds\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long", "name": "DEFAULT_TIMEOUT = 4000", "syntax_pass": true}, {"attribute_expression": "static final long CLOSED_TIMEOUT = 60 * 1000;", "docstring": "\nIf the connection is closed, once per minute\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "long", "name": "CLOSED_TIMEOUT = 60 * 1000", "syntax_pass": true}, {"attribute_expression": "static final int IDLE_PING = 20 * 1000;", "docstring": "\nIdle ping interval\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "IDLE_PING = 20 * 1000", "syntax_pass": true}, {"attribute_expression": "static final int IDLE_TIMEOUT = 90 * 1000;", "docstring": "\nIdle timeout(used if keepalive is enabled)\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "IDLE_TIMEOUT = 90 * 1000", "syntax_pass": true}, {"attribute_expression": "PseudoTcpState m_state;", "docstring": "\nTcp state\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "PseudoTcpState", "name": "m_state", "syntax_pass": true}, {"attribute_expression": "long m_conv;", "docstring": "\nConversation number\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_conv", "syntax_pass": true}, {"attribute_expression": "boolean m_bReadEnable, m_bWriteEnable, m_bOutgoing;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "m_bReadEnable", "syntax_pass": true}, {"attribute_expression": "long m_lasttraffic;", "docstring": "\nLast traffic timestamp\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_lasttraffic", "syntax_pass": true}, {"attribute_expression": "List<RSegment> m_rlist = new ArrayList<>();", "docstring": "\nList of incoming segments. Segments store info like stream offset and\ncontrol flags. If segment contains any data it is stored in the receive\nbuffer.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "List<RSegment>", "name": "m_rlist = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "long m_lastrecv;", "docstring": "\nLast receive timestamp\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_lastrecv", "syntax_pass": true}, {"attribute_expression": "int m_rbuf_len;", "docstring": "\nReceive buffer length\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "m_rbuf_len", "syntax_pass": true}, {"attribute_expression": "int m_rcv_nxt;", "docstring": "\nThe sequence number of the next byte of data that is expected from the\nother device\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "m_rcv_nxt", "syntax_pass": true}, {"attribute_expression": "int m_rcv_wnd;", "docstring": "\nReceive window size\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "m_rcv_wnd", "syntax_pass": true}, {"attribute_expression": "private short m_rwnd_scale;", "docstring": "\nWindow scale factor\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "short", "name": "m_rwnd_scale", "syntax_pass": true}, {"attribute_expression": "ByteFifoBuffer m_rbuf;", "docstring": "\nThe receive buffer\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ByteFifoBuffer", "name": "m_rbuf", "syntax_pass": true}, {"attribute_expression": "List<SSegment> m_slist = new ArrayList<>();", "docstring": "\nOutgoing segments list\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "List<SSegment>", "name": "m_slist = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "long m_lastsend;", "docstring": "\nLast send timestamp\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_lastsend", "syntax_pass": true}, {"attribute_expression": "long m_snd_nxt;", "docstring": "\nThe sequence number of the next byte of data to be sent\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_snd_nxt", "syntax_pass": true}, {"attribute_expression": "long m_snd_una;", "docstring": "\nThe sequence number of the first byte of data that has been sent but not\nyet acknowledged\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_snd_una", "syntax_pass": true}, {"attribute_expression": "int m_sbuf_len;", "docstring": "\nThe send buffer's size\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "m_sbuf_len", "syntax_pass": true}, {"attribute_expression": "private int m_snd_wnd;", "docstring": "\nSend window size\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "m_snd_wnd", "syntax_pass": true}, {"attribute_expression": "private short m_swnd_scale;", "docstring": "\nSend window scale factor\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "short", "name": "m_swnd_scale", "syntax_pass": true}, {"attribute_expression": "ByteFifoBuffer m_sbuf;", "docstring": "\nThe send buffer\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ByteFifoBuffer", "name": "m_sbuf", "syntax_pass": true}, {"attribute_expression": "long m_mss;", "docstring": "\n\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_mss", "syntax_pass": true}, {"attribute_expression": "long m_largest;", "docstring": "\n\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_largest", "syntax_pass": true}, {"attribute_expression": "long m_mtu_advise;", "docstring": "\n\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_mtu_advise", "syntax_pass": true}, {"attribute_expression": "int m_msslevel;", "docstring": "\n\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "m_msslevel", "syntax_pass": true}, {"attribute_expression": "long m_rto_base;", "docstring": "\nRetransmit timer\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_rto_base", "syntax_pass": true}, {"attribute_expression": "long m_ts_recent, m_ts_lastack;", "docstring": "\nTimestamp tracking\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_ts_recent", "syntax_pass": true}, {"attribute_expression": "long m_rx_rttvar, m_rx_srtt, m_rx_rto;", "docstring": "\nRound-trip calculation\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_rx_rttvar", "syntax_pass": true}, {"attribute_expression": "long m_ssthresh, m_cwnd;", "docstring": "\nCongestion avoidance, Fast retransmit/recovery, Delayed ACKs\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_ssthresh", "syntax_pass": true}, {"attribute_expression": "short m_dup_acks;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "short", "name": "m_dup_acks", "syntax_pass": true}, {"attribute_expression": "long m_recover;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_recover", "syntax_pass": true}, {"attribute_expression": "long m_t_ack;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_t_ack", "syntax_pass": true}, {"attribute_expression": "boolean m_use_nagling;", "docstring": "\nUse nagling\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "m_use_nagling", "syntax_pass": true}, {"attribute_expression": "long m_ack_delay;", "docstring": "\nAcknowledgment delay\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "m_ack_delay", "syntax_pass": true}, {"attribute_expression": "boolean m_support_wnd_scale;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "m_support_wnd_scale", "syntax_pass": true}, {"attribute_expression": "PseudoTcpNotify m_notify;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "PseudoTcpNotify", "name": "m_notify", "syntax_pass": true}, {"attribute_expression": "EnShutdown m_shutdown;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "EnShutdown", "name": "m_shutdown", "syntax_pass": true}, {"attribute_expression": "String debugName = \"\";", "docstring": "\nDebug name used to identify peers in log messages\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "String", "name": "debugName = \"\"", "syntax_pass": true}, {"attribute_expression": "private final Object ack_notify = new Object();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "ack_notify = new Object()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/pseudotcp/Segment.java.Segment", "name": "Segment", "file_path": "src/main/java/org/ice4j/pseudotcp/Segment.java", "superclasses": "", "methods": [], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nClass used as a segment structure\n\n@author Pawel Domas\n", "original_string": "public class Segment\n{\n    long conv;\n    long seq;\n    long ack;\n    byte flags;\n    int wnd;\n    long tsval;\n    long tsecr;\n    byte[] data;\n    int len;\n}", "super_interfaces": [], "fields": [{"attribute_expression": "long conv;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "conv", "syntax_pass": true}, {"attribute_expression": "long seq;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "seq", "syntax_pass": true}, {"attribute_expression": "long ack;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "ack", "syntax_pass": true}, {"attribute_expression": "byte flags;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "byte", "name": "flags", "syntax_pass": true}, {"attribute_expression": "int wnd;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "wnd", "syntax_pass": true}, {"attribute_expression": "long tsval;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "tsval", "syntax_pass": true}, {"attribute_expression": "long tsecr;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "tsecr", "syntax_pass": true}, {"attribute_expression": "byte[] data;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "byte[]", "name": "data", "syntax_pass": true}, {"attribute_expression": "int len;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "len", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket", "name": "PseudoTcpSocket", "file_path": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java", "superclasses": "Socket", "methods": ["[]PseudoTcpSocket(PseudoTcpSocketImpl)", "[long]getConversationID()", "[void]setConversationID(long)", "[void]setMTU(int)", "[int]getMTU()", "[long]getOption(Option)", "[void]setOption(Option,long)", "[void]accept(int)", "[void]setDebugName(String)", "[PseudoTcpState]getState()", "[boolean]isConnected()", "[boolean]isConnecting()", "[boolean]isClosed()", "[void]connect(SocketAddress)", "[void]checkDestination(int)", "[void]connect(SocketAddress,int)", "[void]close()", "[OutputStream]getOutputStream()", "[void]accept(SocketAddress,int)", "[FileDescriptor]getFileDescriptor()"], "method_uris": ["src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[]PseudoTcpSocket(PseudoTcpSocketImpl)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[long]getConversationID()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]setConversationID(long)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]setMTU(int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[int]getMTU()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[long]getOption(Option)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]setOption(Option,long)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]accept(int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]setDebugName(String)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[PseudoTcpState]getState()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[boolean]isConnected()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[boolean]isConnecting()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[boolean]isClosed()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]connect(SocketAddress)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]checkDestination(int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]connect(SocketAddress,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]close()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[OutputStream]getOutputStream()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[void]accept(SocketAddress,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocket.java.PseudoTcpSocket.[FileDescriptor]getFileDescriptor()"], "overrides": null, "attributes": [], "class_docstring": "\n\n@author Pawel Domas\n", "original_string": "public class PseudoTcpSocket extends Socket \n{\n    private final PseudoTcpSocketImpl socketImpl;\n\n    private final Object connectLock = new Object();\n\n    private final Object closeLock = new Object();\n    \n    PseudoTcpSocket(PseudoTcpSocketImpl socketImpl) \n        throws SocketException \n    {\n        super(socketImpl);\n        this.socketImpl = socketImpl;\n    }\n    \n    /**\n     * \n     * @return PseudoTCP conversation ID\n     */\n    public long getConversationID()\n    {\n        return socketImpl.getConversationID();\n    }\n    \n    /**\n     * Set conversation ID for the socket\n     * Must be called on unconnected socket\n     * \n     * @param convID the conversation ID to set\n     * @throws IllegalStateException when called on connected or closed socket\n     */\n    public void setConversationID(long convID)\n        throws IllegalStateException\n    {\n        socketImpl.setConversationID(convID);\n    }\n    \n    /**\n     * Sets MTU (maximum transmission unit) value\n     * @param mtu  the MTU value\n     */\n    public void setMTU(int mtu)\n    {\n        socketImpl.setMTU(mtu);\n    }\n    \n    /**\n     * Gets MTU (maximum transmission unit) value\n     * @return MTU value\n     */\n    public int getMTU()\n    {\n        return socketImpl.getMTU();\n    }\n    \n    /**\n     * Sets an {@link Option} on this socket.\n     * @return PseudoTCP option value\n     * \n     * @param option the option to set on this socket.\n     * @see Option\n     */\n    public long getOption(Option option)\n    {\n        return socketImpl.getPTCPOption(option);\n    }\n    \n    /**\n     * \n     * @param option PseudoTCP option to set\n     * @param optValue option's value\n     * \n     * @see Option\n     */\n    public void setOption(Option option, long optValue)\n    {\n        socketImpl.setPTCPOption(option, optValue);\n    }\n    \n    /**\n     * Blocking method waits for connection.\n     *\n     * @param timeout for this operation in ms\n     * @throws IOException If socket gets closed or timeout expires\n     */\n    public void accept(int timeout) \n        throws IOException\n    {\n        socketImpl.accept(timeout);\n    }\n\n    /**\n     * Sets debug name that will be displayed in log messages for this socket\n     * @param debugName the name of this socket for debug messages\n     */\n    public void setDebugName(String debugName)\n    {\n        socketImpl.setDebugName(debugName);\n    }\n\n    /**\n     * Returns current <tt>PseudoTcpState</tt> of this socket\n     * @return current <tt>PseudoTcpState</tt>\n     * \n     * @see PseudoTcpState\n     */\n    public PseudoTcpState getState()\n    {\n        return socketImpl.getState();\n    }\n    \n    @Override\n    public boolean isConnected() \n    {\n        return getState() == PseudoTcpState.TCP_ESTABLISHED;\n    }\n    \n    /**\n     * \n     * @return true if socket is connected or is trying to connect\n     */\n    public boolean isConnecting()\n    {\n        PseudoTcpState currentState = getState();\n        return currentState == PseudoTcpState.TCP_ESTABLISHED\n            || currentState == PseudoTcpState.TCP_SYN_RECEIVED\n            || currentState == PseudoTcpState.TCP_SYN_SENT;\n    }\n    \n    @Override\n    public boolean isClosed()\n    {\n        return getState() == PseudoTcpState.TCP_CLOSED;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Connects without the timeout.\n     */\n    @Override\n    public void connect(SocketAddress endpoint)\n            throws IOException\n    {\n        this.connect(endpoint, 0);\n    }\n\n    /**\n     * Checks destination port number.\n     *\n     * @param dstPort the destination port to check.\n     */\n    private void checkDestination(int dstPort)\n    {\n        if (dstPort < 0 || dstPort > 65535)\n        {\n            throw new IllegalArgumentException(\"Port out of range: \" + dstPort);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * On Android, we must not use the default <tt>connect</tt> implementation,\n     * because that one deals directly with physical resources, while we create\n     * a socket on top of another socket.\n     *\n     */\n    @Override\n    public void connect(SocketAddress remoteAddr, int timeout)\n            throws IOException\n    {\n        if (isClosed())\n        {\n            throw new SocketException(\"Socket is closed\");\n        }\n        if (timeout < 0)\n        {\n            throw new IllegalArgumentException(\"timeout < 0\");\n        }\n        if (isConnected())\n        {\n            throw new SocketException(\"Already connected\");\n        }\n        if (remoteAddr == null)\n        {\n            throw new IllegalArgumentException(\"remoteAddr == null\");\n        }\n        if (!(remoteAddr instanceof InetSocketAddress))\n        {\n            throw new IllegalArgumentException(\n                    \"Remote address not an InetSocketAddress: \" +\n                            remoteAddr.getClass());\n        }\n        InetSocketAddress inetAddr = (InetSocketAddress) remoteAddr;\n        if (inetAddr.getAddress() == null)\n        {\n            throw new UnknownHostException(\n                    \"Host is unresolved: \" + inetAddr.getHostName());\n        }\n\n        int port = inetAddr.getPort();\n        checkDestination(port);\n\n        synchronized (connectLock)\n        {\n            try\n            {\n                socketImpl.connect(remoteAddr, timeout);\n            }\n            catch (IOException e)\n            {\n                socketImpl.close();\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public synchronized void close()\n            throws IOException\n    {\n        synchronized (closeLock)\n        {\n            if (isClosed())\n                return;\n            socketImpl.close();\n        }\n    }\n\n    @Override\n    public OutputStream getOutputStream() throws IOException\n    {\n        return socketImpl.getOutputStream();\n    }\n\n    /**\n     * Allows to set up the remote address directly.\n     * Otherwise, when using the other <tt>accept</tt> methods,\n     * the first address from which a packet is received, is considered\n     * the remote address.\n     *\n     * @param remoteAddress the one and only remote address that will be\n     *                      accepted as remote packet's source\n     * @param timeout connection accept timeout value in milliseconds, after\n     *                which the exception will be thrown.\n     * @throws IOException if socket is closed or timeout expires\n     */\n    public void accept(SocketAddress remoteAddress, int timeout)\n            throws IOException\n    {\n        socketImpl.accept(remoteAddress, timeout);\n    }\n\n    /**\n     * Return the <tt>FileDescriptor</tt> of the underlying socket.\n     * @return the <tt>FileDescriptor</tt> of the underlying socket.\n     */\n    public FileDescriptor getFileDescriptor()\n    {\n        return socketImpl.getFileDescriptor();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final PseudoTcpSocketImpl socketImpl;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PseudoTcpSocketImpl", "name": "socketImpl", "syntax_pass": true}, {"attribute_expression": "private final Object connectLock = new Object();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "connectLock = new Object()", "syntax_pass": true}, {"attribute_expression": "private final Object closeLock = new Object();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "closeLock = new Object()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl", "name": "PseudoTcpSocketImpl", "file_path": "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java", "superclasses": "SocketImpl", "methods": ["[]PseudoTcpSocketImpl(long,DatagramSocket)", "[]PseudoTcpSocketImpl(long)", "[]PseudoTcpSocketImpl(long,int)", "[]PseudoTcpSocketImpl(long,String,int)", "[void]setMTU(int)", "[int]getMTU()", "[long]getConversationID()", "[void]setConversationID(long)", "[void]setDebugName(String)", "[void]create(boolean)", "[void]connect(String,int)", "[void]connect(InetAddress,int)", "[void]connect(SocketAddress,int)", "[void]bind(InetAddress,int)", "[void]listen(int)", "[void]setOption(int,Object)", "[Object]getOption(int)", "[long]getPTCPOption(Option)", "[void]setPTCPOption(Option,long)", "[void]doConnect(InetSocketAddress,long)", "[void]accept(SocketAddress,int)", "[void]accept(int)", "[void]accept(SocketImpl)", "[PseudoTcpState]getState()", "[void]updateClock()", "[void]startThreads()", "[void]onTcpOpen(PseudoTCPBase)", "[void]onTcpReadable(PseudoTCPBase)", "[void]onTcpWriteable(PseudoTCPBase)", "[void]onTcpClosed(PseudoTCPBase,IOException)", "[void]releaseAllLocks()", "[void]joinAllThreads()", "[WriteResult]tcpWritePacket(PseudoTCPBase,byte[],int)", "[void]receivePackets()", "[void]runClock()", "[void]scheduleClockTask(long)", "[void]cancelClockTask(boolean)", "[OutputStream]getOutputStream()", "[InputStream]getInputStream()", "[int]available()", "[void]close()", "[void]sendUrgentData(int)", "[FileDescriptor]getFileDescriptor()", "[void]shutdownInput()", "[void]shutdownOutput()", "[InetAddress]getInetAddress()", "[int]getPort()", "[boolean]supportsUrgentData()", "[int]getLocalPort()", "[void]setPerformancePreferences(int,int,int)"], "method_uris": ["src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[]PseudoTcpSocketImpl(long,DatagramSocket)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[]PseudoTcpSocketImpl(long)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[]PseudoTcpSocketImpl(long,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[]PseudoTcpSocketImpl(long,String,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]setMTU(int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[int]getMTU()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[long]getConversationID()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]setConversationID(long)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]setDebugName(String)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]create(boolean)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]connect(String,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]connect(InetAddress,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]connect(SocketAddress,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]bind(InetAddress,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]listen(int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]setOption(int,Object)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[Object]getOption(int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[long]getPTCPOption(Option)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]setPTCPOption(Option,long)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]doConnect(InetSocketAddress,long)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]accept(SocketAddress,int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]accept(int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]accept(SocketImpl)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[PseudoTcpState]getState()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]updateClock()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]startThreads()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]onTcpOpen(PseudoTCPBase)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]onTcpReadable(PseudoTCPBase)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]onTcpWriteable(PseudoTCPBase)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]onTcpClosed(PseudoTCPBase,IOException)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]releaseAllLocks()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]joinAllThreads()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[WriteResult]tcpWritePacket(PseudoTCPBase,byte[],int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]receivePackets()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]runClock()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]scheduleClockTask(long)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]cancelClockTask(boolean)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[OutputStream]getOutputStream()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[InputStream]getInputStream()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[int]available()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]close()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]sendUrgentData(int)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[FileDescriptor]getFileDescriptor()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]shutdownInput()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]shutdownOutput()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[InetAddress]getInetAddress()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[int]getPort()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[boolean]supportsUrgentData()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[int]getLocalPort()", "src/main/java/org/ice4j/pseudotcp/PseudoTcpSocketImpl.java.PseudoTcpSocketImpl.[void]setPerformancePreferences(int,int,int)"], "overrides": null, "attributes": [{"original_string": "    class PseudoTcpInputStream extends InputStream\n    {\n        public PseudoTcpInputStream()\n        {\n        }\n\n        @Override\n        public boolean markSupported()\n        {\n            return false;\n        }\n\n        /**\n         * There's no end of stream detection at the moment. Method blocks until\n         * it returns any data or an exception is thrown\n         *\n         * @return read byte count\n         * @throws IOException in case of en error\n         */\n        @Override\n        public int read() throws IOException\n        {\n            byte[] buff = new byte[1];\n            int readCount = read(buff, 0, 1);\n            return readCount == 1 ? (buff[0] & 0xFF) : -1;\n        }\n\n        @Override\n        public int read(byte[] bytes) throws IOException\n        {\n            return read(bytes, 0, bytes.length);\n        }\n\n        /**\n         * This method blocks until any data is available\n         *\n         * @param buffer destination buffer\n         * @param offset destination buffer's offset\n         * @param length maximum count of bytes that can be read\n         * @return byte count actually read\n         * @throws IOException in case of error or if timeout occurs\n         */\n        @Override\n        public int read(byte[] buffer, int offset, int length)\n            throws IOException\n        {\n            long start = System.nanoTime();\n            int read;\n            while (true)\n            {\n                logger.log(Level.FINER, \"Read Recv\");\n                try\n                {\n                    read = pseudoTcp.recv(buffer, offset, length);\n                    if (logger.isLoggable(Level.FINER))\n                    {\n                        logger.log(Level.FINER,\n                                   \"Read Recv read count: \" + read);\n                    }\n                    if (read > 0)\n                    {\n                        return read;\n                    }\n                    logger.log(Level.FINER, \"Read wait for data available\");\n                    if (readTimeout > 0)\n                    {\n                        //Check for timeout\n                        long elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                        long left = readTimeout - elapsed;\n                        if (left <= 0)\n                        {\n                            IOException exc =\n                                new IOException(\"Read operation timeout\");\n                            pseudoTcp.closedown(exc);\n                            throw exc;\n                        }\n                        synchronized (read_notify)\n                        {\n                            if (pseudoTcp.getAvailable() == 0)\n                            {\n                                read_notify.wait(left);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        synchronized (read_notify)\n                        {\n                            if (pseudoTcp.getAvailable() == 0)\n                            {\n                                read_notify.wait();\n                            }\n                        }\n                    }\n                    if (logger.isLoggable(Level.FINER))\n                    {\n                        logger.log(\n                            Level.FINER,\n                            \"Read notified: \" + pseudoTcp.getAvailable());\n                    }\n                    if (exception != null)\n                    {\n                        throw exception;\n                    }\n                }\n                catch (InterruptedException ex)\n                {\n                    if (exception != null)\n                    {\n                        throw new IOException(\"Read aborted\", exception);\n                    }\n                    else\n                    {\n                        throw new IOException(\"Read aborted\");\n                    }\n                }\n            }\n        }\n\n        @Override\n        public int available() throws IOException\n        {\n            return pseudoTcp.getAvailable();\n        }\n\n        @Override\n        public void close() throws IOException\n        {\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public long skip(long n) throws IOException\n        {\n            return super.skip(n);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public synchronized void mark(int readlimit)\n        {\n            throw new UnsupportedOperationException(\"mark\");\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public synchronized void reset() throws IOException\n        {\n            throw new UnsupportedOperationException(\"reset\");\n        }\n    }", "definition": "    class PseudoTcpInputStream extends InputStream", "class_docstring": "\nThis class implements <tt>java.io.InputStream</tt>\n", "name": "PseudoTcpInputStream", "super_interfaces": [], "superclasses": "InputStream", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public PseudoTcpInputStream()\n        {\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "PseudoTcpInputStream", "params": [], "body": "        {\n        }", "signature": "public PseudoTcpInputStream()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean markSupported()\n        {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "markSupported", "params": [], "body": "        {\n            return false;\n        }", "signature": "@Override\n        public boolean markSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int read() throws IOException\n        {\n            byte[] buff = new byte[1];\n            int readCount = read(buff, 0, 1);\n            return readCount == 1 ? (buff[0] & 0xFF) : -1;\n        }", "docstring": "\nThere's no end of stream detection at the moment. Method blocks until\nit returns any data or an exception is thrown\n\n@return read byte count\n@throws IOException in case of en error\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "read", "params": [], "body": "        {\n            byte[] buff = new byte[1];\n            int readCount = read(buff, 0, 1);\n            return readCount == 1 ? (buff[0] & 0xFF) : -1;\n        }", "signature": "@Override\n        public int read()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int read(byte[] bytes) throws IOException\n        {\n            return read(bytes, 0, bytes.length);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "read", "params": [{"name": "bytes", "type": "byte[]"}], "body": "        {\n            return read(bytes, 0, bytes.length);\n        }", "signature": "@Override\n        public int read(byte[] bytes)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int read(byte[] buffer, int offset, int length)\n            throws IOException\n        {\n            long start = System.nanoTime();\n            int read;\n            while (true)\n            {\n                logger.log(Level.FINER, \"Read Recv\");\n                try\n                {\n                    read = pseudoTcp.recv(buffer, offset, length);\n                    if (logger.isLoggable(Level.FINER))\n                    {\n                        logger.log(Level.FINER,\n                                   \"Read Recv read count: \" + read);\n                    }\n                    if (read > 0)\n                    {\n                        return read;\n                    }\n                    logger.log(Level.FINER, \"Read wait for data available\");\n                    if (readTimeout > 0)\n                    {\n                        //Check for timeout\n                        long elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                        long left = readTimeout - elapsed;\n                        if (left <= 0)\n                        {\n                            IOException exc =\n                                new IOException(\"Read operation timeout\");\n                            pseudoTcp.closedown(exc);\n                            throw exc;\n                        }\n                        synchronized (read_notify)\n                        {\n                            if (pseudoTcp.getAvailable() == 0)\n                            {\n                                read_notify.wait(left);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        synchronized (read_notify)\n                        {\n                            if (pseudoTcp.getAvailable() == 0)\n                            {\n                                read_notify.wait();\n                            }\n                        }\n                    }\n                    if (logger.isLoggable(Level.FINER))\n                    {\n                        logger.log(\n                            Level.FINER,\n                            \"Read notified: \" + pseudoTcp.getAvailable());\n                    }\n                    if (exception != null)\n                    {\n                        throw exception;\n                    }\n                }\n                catch (InterruptedException ex)\n                {\n                    if (exception != null)\n                    {\n                        throw new IOException(\"Read aborted\", exception);\n                    }\n                    else\n                    {\n                        throw new IOException(\"Read aborted\");\n                    }\n                }\n            }\n        }", "docstring": "\nThis method blocks until any data is available\n\n@param buffer destination buffer\n@param offset destination buffer's offset\n@param length maximum count of bytes that can be read\n@return byte count actually read\n@throws IOException in case of error or if timeout occurs\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "read", "params": [{"name": "buffer", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "length", "type": "int"}], "body": "        {\n            long start = System.nanoTime();\n            int read;\n            while (true)\n            {\n                logger.log(Level.FINER, \"Read Recv\");\n                try\n                {\n                    read = pseudoTcp.recv(buffer, offset, length);\n                    if (logger.isLoggable(Level.FINER))\n                    {\n                        logger.log(Level.FINER,\n                                   \"Read Recv read count: \" + read);\n                    }\n                    if (read > 0)\n                    {\n                        return read;\n                    }\n                    logger.log(Level.FINER, \"Read wait for data available\");\n                    if (readTimeout > 0)\n                    {\n                        //Check for timeout\n                        long elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                        long left = readTimeout - elapsed;\n                        if (left <= 0)\n                        {\n                            IOException exc =\n                                new IOException(\"Read operation timeout\");\n                            pseudoTcp.closedown(exc);\n                            throw exc;\n                        }\n                        synchronized (read_notify)\n                        {\n                            if (pseudoTcp.getAvailable() == 0)\n                            {\n                                read_notify.wait(left);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        synchronized (read_notify)\n                        {\n                            if (pseudoTcp.getAvailable() == 0)\n                            {\n                                read_notify.wait();\n                            }\n                        }\n                    }\n                    if (logger.isLoggable(Level.FINER))\n                    {\n                        logger.log(\n                            Level.FINER,\n                            \"Read notified: \" + pseudoTcp.getAvailable());\n                    }\n                    if (exception != null)\n                    {\n                        throw exception;\n                    }\n                }\n                catch (InterruptedException ex)\n                {\n                    if (exception != null)\n                    {\n                        throw new IOException(\"Read aborted\", exception);\n                    }\n                    else\n                    {\n                        throw new IOException(\"Read aborted\");\n                    }\n                }\n            }\n        }", "signature": "@Override\n        public int read(byte[] buffer, int offset, int length)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int available() throws IOException\n        {\n            return pseudoTcp.getAvailable();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "available", "params": [], "body": "        {\n            return pseudoTcp.getAvailable();\n        }", "signature": "@Override\n        public int available()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void close() throws IOException\n        {\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "close", "params": [], "body": "        {\n        }", "signature": "@Override\n        public void close()"}, {"syntax_pass": true, "original_string": "        @Override\n        public long skip(long n) throws IOException\n        {\n            return super.skip(n);\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "name": "skip", "params": [{"name": "n", "type": "long"}], "body": "        {\n            return super.skip(n);\n        }", "signature": "@Override\n        public long skip(long n)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized void mark(int readlimit)\n        {\n            throw new UnsupportedOperationException(\"mark\");\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "mark", "params": [{"name": "readlimit", "type": "int"}], "body": "        {\n            throw new UnsupportedOperationException(\"mark\");\n        }", "signature": "@Override\n        public synchronized void mark(int readlimit)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized void reset() throws IOException\n        {\n            throw new UnsupportedOperationException(\"reset\");\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "reset", "params": [], "body": "        {\n            throw new UnsupportedOperationException(\"reset\");\n        }", "signature": "@Override\n        public synchronized void reset()"}]}, {"original_string": "    class PseudoTcpOutputStream extends OutputStream\n    {\n        @Override\n        public void write(int b) throws IOException\n        {\n            byte[] bytes = new byte[1];\n            bytes[0] = (byte) b;\n            write(bytes);\n        }\n\n        /**\n         * This method blocks until all data has been written.\n         *\n         * @param buffer source buffer\n         * @param offset source buffer's offset\n         * @param length byte count to be written\n         * @throws IOException in case of error or if timeout occurs \n         * \n         */\n        @Override\n        public void write(byte[] buffer, int offset, int length) throws IOException\n        {\n            int toSend = length;\n            int sent;\n            long start = System.nanoTime();\n            while (toSend > 0)\n            {\n                synchronized (pseudoTcp)\n                {\n                    sent = pseudoTcp.send(buffer, offset + length - toSend, toSend);\n                }\n                if (sent > 0)\n                {\n                    toSend -= sent;\n                }\n                else\n                {\n                    try\n                    {\n                        logger.log(Level.FINER, \"Write wait for notify\");                        \n                        synchronized (write_notify)\n                        {\n                            if (writeTimeout > 0)\n                            {\n                                long elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                                long left = writeTimeout - elapsed;\n                                if (left <= 0)\n                                {\n                                    IOException exc = \n                                        new IOException(\"Write operation timeout\");\n                                    pseudoTcp.closedown(exc);\n                                    throw exc;\n                                }\n                                write_notify.wait(left);\n                            }\n                            else\n                            {\n                                write_notify.wait();\n                            }\n                        }\n                        logger.log(Level.FINER,\n                                   \"Write notified, available: \"\n                            + pseudoTcp.getAvailableSendBuffer());\n                        if (exception != null)\n                        {\n                            throw exception;\n                        }\n                    }\n                    catch (InterruptedException ex)\n                    {\n                        if (exception != null)\n                        {\n                            throw new IOException(\"Write aborted\", exception);\n                        }\n                        else\n                        {\n                            throw new IOException(\"Write aborted\", ex);\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * This method block until all buffered data has been written\n         *\n         * @throws IOException in case of error or if timeout occurs\n         */\n        @Override\n        public synchronized void flush() throws IOException\n        {\n            logger.log(Level.FINE, \"Flushing...\");\n            long start = System.nanoTime();\n            final Object ackNotify = pseudoTcp.getAckNotify();\n            synchronized (ackNotify)\n            {\n                while (pseudoTcp.getBytesBufferedNotSent() > 0)\n                {   \n                    try\n                    {\n                        if (writeTimeout > 0)\n                        {\n                            //Check write timeout\n                            long elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                            long left = writeTimeout - elapsed;\n                            if (left <= 0)\n                            {\n                                IOException e = \n                                    new IOException(\"Flush operation timeout\"); \n                                pseudoTcp.closedown(e);\n                                throw e;\n                            }\n                            ackNotify.wait(left);\n                        }\n                        else\n                        {\n                            ackNotify.wait();\n                        }\n                    }\n                    catch (InterruptedException ex)\n                    {\n                        throw new IOException(\"Flush stream interrupted\", ex);\n                    }\n                }\n            }\n            logger.log(Level.FINE, \"Flushing completed\");\n        }\n\n        @Override\n        public void close() throws IOException\n        {\n            PseudoTcpSocketImpl.this.close();\n        }\n    }", "definition": "    class PseudoTcpOutputStream extends OutputStream", "class_docstring": "\nImplements <tt>java.io.OutputStream</tt>\n", "name": "PseudoTcpOutputStream", "super_interfaces": [], "superclasses": "OutputStream", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public void write(int b) throws IOException\n        {\n            byte[] bytes = new byte[1];\n            bytes[0] = (byte) b;\n            write(bytes);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "write", "params": [{"name": "b", "type": "int"}], "body": "        {\n            byte[] bytes = new byte[1];\n            bytes[0] = (byte) b;\n            write(bytes);\n        }", "signature": "@Override\n        public void write(int b)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void write(byte[] buffer, int offset, int length) throws IOException\n        {\n            int toSend = length;\n            int sent;\n            long start = System.nanoTime();\n            while (toSend > 0)\n            {\n                synchronized (pseudoTcp)\n                {\n                    sent = pseudoTcp.send(buffer, offset + length - toSend, toSend);\n                }\n                if (sent > 0)\n                {\n                    toSend -= sent;\n                }\n                else\n                {\n                    try\n                    {\n                        logger.log(Level.FINER, \"Write wait for notify\");                        \n                        synchronized (write_notify)\n                        {\n                            if (writeTimeout > 0)\n                            {\n                                long elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                                long left = writeTimeout - elapsed;\n                                if (left <= 0)\n                                {\n                                    IOException exc = \n                                        new IOException(\"Write operation timeout\");\n                                    pseudoTcp.closedown(exc);\n                                    throw exc;\n                                }\n                                write_notify.wait(left);\n                            }\n                            else\n                            {\n                                write_notify.wait();\n                            }\n                        }\n                        logger.log(Level.FINER,\n                                   \"Write notified, available: \"\n                            + pseudoTcp.getAvailableSendBuffer());\n                        if (exception != null)\n                        {\n                            throw exception;\n                        }\n                    }\n                    catch (InterruptedException ex)\n                    {\n                        if (exception != null)\n                        {\n                            throw new IOException(\"Write aborted\", exception);\n                        }\n                        else\n                        {\n                            throw new IOException(\"Write aborted\", ex);\n                        }\n                    }\n                }\n            }\n        }", "docstring": "\nThis method blocks until all data has been written.\n\n@param buffer source buffer\n@param offset source buffer's offset\n@param length byte count to be written\n@throws IOException in case of error or if timeout occurs \n\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "write", "params": [{"name": "buffer", "type": "byte[]"}, {"name": "offset", "type": "int"}, {"name": "length", "type": "int"}], "body": "        {\n            int toSend = length;\n            int sent;\n            long start = System.nanoTime();\n            while (toSend > 0)\n            {\n                synchronized (pseudoTcp)\n                {\n                    sent = pseudoTcp.send(buffer, offset + length - toSend, toSend);\n                }\n                if (sent > 0)\n                {\n                    toSend -= sent;\n                }\n                else\n                {\n                    try\n                    {\n                        logger.log(Level.FINER, \"Write wait for notify\");                        \n                        synchronized (write_notify)\n                        {\n                            if (writeTimeout > 0)\n                            {\n                                long elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                                long left = writeTimeout - elapsed;\n                                if (left <= 0)\n                                {\n                                    IOException exc = \n                                        new IOException(\"Write operation timeout\");\n                                    pseudoTcp.closedown(exc);\n                                    throw exc;\n                                }\n                                write_notify.wait(left);\n                            }\n                            else\n                            {\n                                write_notify.wait();\n                            }\n                        }\n                        logger.log(Level.FINER,\n                                   \"Write notified, available: \"\n                            + pseudoTcp.getAvailableSendBuffer());\n                        if (exception != null)\n                        {\n                            throw exception;\n                        }\n                    }\n                    catch (InterruptedException ex)\n                    {\n                        if (exception != null)\n                        {\n                            throw new IOException(\"Write aborted\", exception);\n                        }\n                        else\n                        {\n                            throw new IOException(\"Write aborted\", ex);\n                        }\n                    }\n                }\n            }\n        }", "signature": "@Override\n        public void write(byte[] buffer, int offset, int length)"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized void flush() throws IOException\n        {\n            logger.log(Level.FINE, \"Flushing...\");\n            long start = System.nanoTime();\n            final Object ackNotify = pseudoTcp.getAckNotify();\n            synchronized (ackNotify)\n            {\n                while (pseudoTcp.getBytesBufferedNotSent() > 0)\n                {   \n                    try\n                    {\n                        if (writeTimeout > 0)\n                        {\n                            //Check write timeout\n                            long elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                            long left = writeTimeout - elapsed;\n                            if (left <= 0)\n                            {\n                                IOException e = \n                                    new IOException(\"Flush operation timeout\"); \n                                pseudoTcp.closedown(e);\n                                throw e;\n                            }\n                            ackNotify.wait(left);\n                        }\n                        else\n                        {\n                            ackNotify.wait();\n                        }\n                    }\n                    catch (InterruptedException ex)\n                    {\n                        throw new IOException(\"Flush stream interrupted\", ex);\n                    }\n                }\n            }\n            logger.log(Level.FINE, \"Flushing completed\");\n        }", "docstring": "\nThis method block until all buffered data has been written\n\n@throws IOException in case of error or if timeout occurs\n", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "flush", "params": [], "body": "        {\n            logger.log(Level.FINE, \"Flushing...\");\n            long start = System.nanoTime();\n            final Object ackNotify = pseudoTcp.getAckNotify();\n            synchronized (ackNotify)\n            {\n                while (pseudoTcp.getBytesBufferedNotSent() > 0)\n                {   \n                    try\n                    {\n                        if (writeTimeout > 0)\n                        {\n                            //Check write timeout\n                            long elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                            long left = writeTimeout - elapsed;\n                            if (left <= 0)\n                            {\n                                IOException e = \n                                    new IOException(\"Flush operation timeout\"); \n                                pseudoTcp.closedown(e);\n                                throw e;\n                            }\n                            ackNotify.wait(left);\n                        }\n                        else\n                        {\n                            ackNotify.wait();\n                        }\n                    }\n                    catch (InterruptedException ex)\n                    {\n                        throw new IOException(\"Flush stream interrupted\", ex);\n                    }\n                }\n            }\n            logger.log(Level.FINE, \"Flushing completed\");\n        }", "signature": "@Override\n        public synchronized void flush()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void close() throws IOException\n        {\n            PseudoTcpSocketImpl.this.close();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "close", "params": [], "body": "        {\n            PseudoTcpSocketImpl.this.close();\n        }", "signature": "@Override\n        public void close()"}]}], "class_docstring": "", "original_string": "class PseudoTcpSocketImpl \n    extends SocketImpl\n    implements PseudoTcpNotify\n{\n    /**\n     * The logger.\n     */\n    private static final java.util.logging.Logger logger =\n        java.util.logging.Logger.getLogger(PseudoTcpSocketImpl.class.getName());\n    /**\n     * Pseudotcp logic instance\n     */\n    private final PseudoTCPBase pseudoTcp;\n    /**\n     * Datagram socket used to handle network operations\n     */\n    private DatagramSocket socket;\n    /**\n     * Current socket address of remote socket that we are connected to\n     */\n    private SocketAddress remoteAddr;\n    /**\n     * Receive buffer size used for receiving packets TODO: this should be\n     * checked with MTU ?\n     */\n    private int DATAGRAM_RCV_BUFFER_SIZE = 8000;\n    /**\n     * Monitor object used to block threads on write operation. That is when the\n     * send buffer is full.\n     */\n    private final Object write_notify = new Object();\n    /**\n     * Monitor object used to block threads on read operation. That is when\n     * there's no more data available for reading.\n     */\n    private final Object read_notify = new Object();\n    /**\n     * Monitor object used to block thread waiting for change of TCP state.\n     */\n    private final Object state_notify = new Object();\n\n    /**\n     * Exception which occurred in pseudotcp logic and must be propagated to\n     * threads blocked on any operations.\n     */\n    private IOException exception;\n    /**\n     * Read operations timeout in ms\n     */\n    private long writeTimeout;\n    /**\n     * Write operations timeout in ms\n     */\n    private long readTimeout;\n\n    private PseudoTcpInputStream inputStream;\n\n    private PseudoTcpOutputStream outputstream;\n\n    /**\n     *\n     * @param conv_id conversation id, must be the same on both sides\n     * @param sock datagram socket used for network operations\n     */\n    public PseudoTcpSocketImpl(long conv_id, DatagramSocket sock)\n    {\n        pseudoTcp = new PseudoTCPBase(this, conv_id);\n        //Default MTU\n        setMTU(1450);\n        this.socket = sock;\n        //TODO: find out if this call is required\n        /*try\n        {\n            setOption(SO_TIMEOUT, 0);\n        }\n        catch (SocketException e)\n        {\n            throw new RuntimeException(e);\n        }*/\n    }\n\n    /**\n     * This constructor creates <tt>DatagramSocket</tt> with random port. Should\n     * be used for clients.\n     *\n     * @param conv_id conversation id, must be the same on both sides\n     * @throws SocketException\n     */\n    public PseudoTcpSocketImpl(long conv_id)\n        throws SocketException\n    {\n        this(conv_id, new DatagramSocket());\n    }\n\n    /**\n     * Binds <tt>DatagramSocket</tt> to given <tt>local_port</tt>\n     *\n     * @param conv_id conversation id, must be the same on both sides\n     * @param local_port the local port that will be used for this socket\n     * @throws SocketException\n     */\n    public PseudoTcpSocketImpl(long conv_id, int local_port)\n        throws SocketException\n    {\n        this(conv_id, new DatagramSocket(local_port));\n    }\n\n    /**\n     * Creates DatagramSocket for <tt>local_ip</tt>:<tt>local_port</tt>\n     *\n     * @param conv_id conversation id, must be the same on both sides\n     * @param local_ip used by <tt>DatagramSocket</tt>\n     * @param local_port used by <tt>DatagramSocket</tt>\n     * @throws SocketException\n     * @throws UnknownHostException\n     */\n    public PseudoTcpSocketImpl(long conv_id, String local_ip, int local_port)\n        throws SocketException,\n               UnknownHostException\n    {\n        this(conv_id, new DatagramSocket(local_port,\n                                         InetAddress.getByName(local_ip)));\n    }\n    \n    /**\n     * Sets the MTU parameter for this socket\n     * @param mtu the MTU value\n     */\n    public void setMTU(int mtu)\n    {\n        this.pseudoTcp.notifyMTU(mtu);\n    }\n    \n    /**\n     * \n     * @return current MTU set\n     */\n    public int getMTU()\n    {\n        return pseudoTcp.getMTU();\n    }\n    \n    long getConversationID()\n    {\n        return pseudoTcp.getConversationID();\n    }\n    \n    void setConversationID(long convID)\n    {\n        pseudoTcp.setConversationID(convID);\n    }\n    \n    /**\n     * Sets debug name that will be displayed in log messages for this socket\n     * @param debugName the debug name to set \n     */\n    public void setDebugName(String debugName)\n    {\n        this.pseudoTcp.debugName = debugName;\n    }\n\n    /**\n     * Creates either a stream or a datagram socket.\n     * @param stream if true, create a stream socket; otherwise, create a datagram socket.\n     * @throws IOException if an I/O error occurs while creating the socket.\n     */\n    @Override\n    protected void create(boolean stream) \n        throws IOException\n    {\n        //no effect        \n    }\n\n    /**\n     * Connects this socket to the specified port on the named host.\n     * @param host the name of the remote host.\n     * @param port the port number.\n     * @throws IOException \n     */\n    @Override\n    protected void connect(String host, int port) \n        throws IOException\n    {\n        doConnect(new InetSocketAddress(InetAddress.getByName(host), port), 0);\n    }\n\n    /**\n     * Connects this socket to the specified port number on the specified host.\n     * @param address the IP address of the remote host.\n     * @param port the port number.\n     * @throws IOException if an I/O error occurs when attempting a connection.\n     */\n    @Override\n    protected void connect(InetAddress address, int port) \n        throws IOException\n    {\n        connect(address.getHostAddress(), port);\n    }\n\n    /**\n     * Connects this socket to the specified port number on the specified host. \n     * A timeout of zero is interpreted as an infinite timeout. \n     * The connection will then block until established or an error occurs.\n     * @param address the Socket address of the remote host.\n     * @param timeout the timeout value, in milliseconds, or zero for no timeout.\n     * @throws IOException if an I/O error occurs when attempting a connection.\n     */\n    @Override\n    protected void connect(SocketAddress address, int timeout) \n        throws IOException\n    {\n        InetSocketAddress inetAddr = (InetSocketAddress) address;\n        doConnect(inetAddr, timeout);\n    }\n\n    /**\n     * Binds this socket to the specified port number on the specified host.\n     * @param host the IP address of the remote host.\n     * @param port the port number.\n     * @throws IOException \n     */\n    @Override\n    public void bind(InetAddress host, int port) \n        throws IOException\n    {\n        if (socket != null)\n            socket.close();\n        InetSocketAddress newAddr = new InetSocketAddress(host.getHostAddress(), port);\n        this.socket = new DatagramSocket(newAddr);\n    }\n\n    /**\n     * Sets the maximum queue length for incoming connection \n     * indications (a request to connect) to the count argument. \n     * If a connection indication arrives when the queue is full,\n     * the connection is refused.\n     * @param backlog the maximum length of the queue.\n     * @throws IOException if an I/O error occurs when creating the queue.\n     */\n    @Override\n    protected void listen(int backlog) \n        throws IOException\n    {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    private Map<Integer, Object> options = new HashMap<>();\n    @Override\n    public void setOption(int optID, Object value) \n        throws SocketException\n    {\n        //TODO: map options to PTCP options/method calls\n        options.put(optID, value);\n    }\n\n    @Override\n    public Object getOption(int optID) \n        throws SocketException\n    {\n        //TODO: map options to PTCP options/method calls\n        if (optID == SocketOptions.TCP_NODELAY)\n        {\n            Object ret = options.get(Option.OPT_NODELAY.ordinal());\n            return ret != null;\n        }\n\n        Object option = options.get(optID);\n        if (option == null)\n        {\n            logger.warning(\"Asked for unknown optID\" + optID);\n        }\n        return option;\n    }\n    \n    public long getPTCPOption(Option opt)\n    {\n        if (Option.OPT_READ_TIMEOUT == opt)\n        {\n            return this.readTimeout;\n        }\n        else if (Option.OPT_WRITE_TIMEOUT == opt)\n        {\n            return this.writeTimeout;\n        }\n        else\n        {\n            return pseudoTcp.getOption(opt);\n        }\n    }\n    \n    public void setPTCPOption(Option opt, long optValue)\n    {\n        if (Option.OPT_WRITE_TIMEOUT == opt)\n        {\n            this.writeTimeout = optValue >= 0 ? optValue : 0;\n        }\n        else if (Option.OPT_READ_TIMEOUT == opt)\n        {\n            this.readTimeout = optValue >= 0 ? optValue : 0;\n        }\n        else\n        {\n            pseudoTcp.setOption(opt, optValue);\n        }\n    }\n    \n    \n    /**\n     * Start connection procedure\n     *\n     * @param remoteAddress to which this socket connects to\n     * @param timeout for this operation in ms\n     */\n    void doConnect(InetSocketAddress remoteAddress, long timeout)\n        throws IOException\n    {\n        logger.fine(\"Connecting to \"+remoteAddress);\n        this.remoteAddr = remoteAddress;\n        startThreads();\n        pseudoTcp.connect();\n        updateClock();\n        boolean noTimeout = timeout <= 0;\n        try\n        {\n            long elapsed = 0;\n            //Here the threads is blocked untill we reach TCP_ESTABLISHED state\n            //There's also check for timeout for that op\n            synchronized (state_notify)\n            {\n                while (pseudoTcp.getState() != PseudoTcpState.TCP_ESTABLISHED\n                    &&  (noTimeout || (elapsed < timeout)) )\n                {\n                    long start = System.nanoTime();\n                    state_notify.wait(timeout);\n                    elapsed += TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                }\n                if (pseudoTcp.getState() != PseudoTcpState.TCP_ESTABLISHED)\n                {\n                    throw new IOException(\"Connect timeout\");\n                }\n            }\n        }\n        catch (InterruptedException ex)\n        {\n            close();\n            throw new IOException(\"Connect aborted\");\n        }\n    }\n\n    /**\n     * Blocking method waits for connection.\n     *\n     * @param remoteAddress the one and only address that will be\n     *                      accepted as the source for remote packets\n     * @param timeout for this operation in ms\n     * @throws IOException If socket gets closed or timeout expires\n     */\n    void accept(SocketAddress remoteAddress, int timeout)\n        throws IOException\n    {\n        this.remoteAddr = remoteAddress;\n        accept(timeout);\n    }\n\n\n    /**\n     * Blocking method waits for connection.\n     *\n     * @param timeout for this operation in ms\n     * @throws IOException If socket gets closed or timeout expires\n     */\n    void accept(int timeout)\n        throws IOException\n    {\n        try\n        {\n            startThreads();\n            PseudoTcpState state = pseudoTcp.getState();\n            if (state == PseudoTcpState.TCP_CLOSED)\n            {\n                throw new IOException(\"Socket closed\");\n            }\n            if (pseudoTcp.getState() != PseudoTcpState.TCP_ESTABLISHED)\n            {\n                synchronized (state_notify)\n                {\n                    state_notify.wait(timeout);\n                }\n            }\n            if (pseudoTcp.getState() != PseudoTcpState.TCP_ESTABLISHED)\n            {\n                throw new IOException(\"Accept timeout\");\n            }\n        }\n        catch (InterruptedException ex)\n        {\n            IOException e = new IOException(\"Accept aborted\");\n            pseudoTcp.closedown(e);\n            throw e;\n        }\n    }\n    \n    /**\n     * Accepts a connection.\n     * @param s the accepted connection.\n     * @throws IOException if an I/O error occurs when accepting the connection.\n     */\n    @Override\n    protected void accept(SocketImpl s)\n                        throws IOException\n    {\n        //TODO: not sure how this should work\n        int timeout = 5000;\n        accept(timeout);\n    }\n    \n    /**\n     *\n     * @return current TCP state\n     */\n    public PseudoTcpState getState()\n    {\n        return pseudoTcp.getState();\n    }\n\n    /**\n     * Interrupts clock thread's wait method to force time update\n     */\n    private void updateClock()\n    {\n        scheduleClockTask(0);\n    }\n\n    /**\n     * Starts all threads required by the socket\n     */\n    private void startThreads()\n    {\n        pseudoTcp.notifyClock(PseudoTCPBase.now());\n        receiveThread = new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                receivePackets();\n            }\n        }, \"PseudoTcpReceiveThread\");\n\n        runReceive = true;\n        runClock = true;\n        receiveThread.start();\n        scheduleClockTask(0);\n    }\n\n    /**\n     * Implements <tt>PseudoTcpNotify</tt>\n     * Called when TCP enters connected state.\n     *\n     * @param tcp the {@link PseudoTCPBase} that caused an event\n     * @see PseudoTcpNotify#onTcpOpen(PseudoTCPBase)\n     */\n    @Override\n    public void onTcpOpen(PseudoTCPBase tcp)\n    {\n        logger.log(Level.FINE, \"tcp opened\");\n        //Release threads blocked at state_notify monitor object.\n        synchronized (state_notify)\n        {\n            state_notify.notifyAll();\n        }\n        //TCP is considered writeable at this point\n        onTcpWriteable(tcp);\n    }\n\n    /**\n     * Implements <tt>PseudoTcpNotify</tt>\n     *\n     * @param tcp the {@link PseudoTCPBase} that caused an event\n     * @see PseudoTcpNotify#onTcpReadable(PseudoTCPBase)\n     */\n    @Override\n    public void onTcpReadable(PseudoTCPBase tcp)\n    {\n        if (logger.isLoggable(Level.FINER))\n        {\n            logger.log(\n                Level.FINER,\n                \"TCP READABLE data available for reading: \"+tcp.getAvailable());\n        }\n        //release all thread blocked at read_notify monitor\n        synchronized (read_notify)\n        {\n            read_notify.notifyAll();\n        }\n    }\n\n    /**\n     * Implements <tt>PseudoTcpNotify</tt>\n     *\n     * @param tcp the {@link PseudoTCPBase} that caused an event\n     * @see PseudoTcpNotify#onTcpWriteable(PseudoTCPBase)\n     */\n    @Override\n    public void onTcpWriteable(PseudoTCPBase tcp)\n    {\n\n        logger.log(Level.FINER, \"stream writeable\");\n        //release all threads blocked at write monitor\n        synchronized (write_notify)\n        {\n            write_notify.notifyAll();\n        }\n        //writeSemaphore.release(1);        \n        logger.log(Level.FINER, \"write notified - now !\");\n\n    }\n\n    /**\n     * Implements <tt>PseudoTcpNotify</tt>\n     *\n     * @param tcp the {@link PseudoTCPBase} that caused an event\n     * @param e the <tt>Exception</tt> which is the reason for closing socket,\n     *  or <tt>null</tt> if there wasn't any\n     * \n     * @see PseudoTcpNotify#onTcpClosed(PseudoTCPBase, IOException)\n     */\n    @Override\n    public void onTcpClosed(PseudoTCPBase tcp, IOException e)\n    {\n        if (e != null)\n        {\n            //e.printStackTrace();\n            logger.log(Level.SEVERE, \"PseudoTcp closed: \" + e);\n        }\n        else\n        {\n            logger.log(Level.FINE, \"PseudoTcp closed\");\n        }\n        runReceive = false;\n        runClock = false;\n        this.exception = e;\n        releaseAllLocks();\n        cancelClockTask(true);\n\n    }\n\n    /**\n     * Releases all monitor objects so that the threads will check their \"run\n     * flags\"\n     */\n    private void releaseAllLocks()\n    {\n        synchronized (read_notify)\n        {\n            read_notify.notifyAll();\n        }\n        synchronized (write_notify)\n        {\n            write_notify.notifyAll();\n        }\n        synchronized (state_notify)\n        {\n            state_notify.notifyAll();\n        }\n        //this interrupt won't work for DatagramSocket read packet operation\n        //receiveThread.interrupt();\n    }\n\n    /**\n     * Joins all running threads\n     *\n     * @throws InterruptedException\n     */\n    private void joinAllThreads() throws InterruptedException\n    {\n        receiveThread.join();\n    }\n\n    /**\n     * Implements <tt>PseudoTcpNotify</tt>\n     *\n     * @param tcp the {@link PseudoTCPBase} that caused an event\n     * @param buffer the buffer containing packet data\n     * @param len packet data length in bytes\n     * @return operation result\n     * \n     * @see PseudoTcpNotify#tcpWritePacket(PseudoTCPBase, byte[], int)\n     */\n    @Override\n    public WriteResult tcpWritePacket(PseudoTCPBase tcp, byte[] buffer, int len)\n    {\n        if (logger.isLoggable(Level.FINEST))\n        {\n            logger.log(Level.FINEST,\n                       \"write packet to network length \" + len\n                            + \" address \" + remoteAddr);\n        }\n        try\n        {\n            //TODO: in case the packet is too long it should return WR_TOO_LARGE\n            DatagramPacket packet = new DatagramPacket(buffer, len, remoteAddr);\n            socket.send(packet);\n            return WriteResult.WR_SUCCESS;\n        }\n        catch (IOException ex)\n        {\n            logger.log(Level.SEVERE, \"TcpWritePacket exception: \" + ex);\n            return WriteResult.WR_FAIL;\n        }\n\n    }\n    /**\n     * Flag which enables packets receive thread\n     */\n    private boolean runReceive = false;\n    /**\n     * Thread receiving packets from the network\n     */\n    private Thread receiveThread;\n\n    /**\n     * Receives packets from the network and passes them to TCP logic class\n     */\n    private void receivePackets()\n    {\n        byte[] buffer = new byte[DATAGRAM_RCV_BUFFER_SIZE];\n        DatagramPacket packet = new DatagramPacket(buffer,\n                                                   DATAGRAM_RCV_BUFFER_SIZE);\n        while (runReceive)\n        {\n            try\n            {\n                socket.receive(packet);\n                //Here is the binding point for remote socket if wasn't\n                //specified earlier\n                if (remoteAddr == null)\n                {\n                    remoteAddr = packet.getSocketAddress();\n                    logger.log(Level.WARNING,\n                               \"Remote addr not set previously, setting to \"\n                                       + remoteAddr);\n                }\n                else\n                {\n                    if (!packet.getSocketAddress().equals(remoteAddr))\n                    {\n                        logger.log(Level.WARNING,\n                                   \"Ignoring packet from \" + packet.getAddress()\n                                    + \":\" + packet.getPort()\n                                    + \" should be: \" + remoteAddr);\n                        continue;\n                    }                    \n                }\n                synchronized (pseudoTcp)\n                {\n                    pseudoTcp.notifyPacket(buffer, packet.getLength());\n                    //we need to update the clock after new packet is receivied\n                    updateClock();\n                }\n            }\n            catch (IOException ex)\n            {\n                //this exception occurs even when the socket \n                //is closed with the close operation, so we check\n                //here if this exception is important\n                if (runReceive)\n                {\n                    logger.log(Level.SEVERE,\n                              \"ReceivePackets exception: \" + ex);\n                    pseudoTcp.closedown(ex);\n                }\n                break;\n            }\n        }\n    }\n    /**\n     * The run flag for clock thread\n     */\n    private boolean runClock = false;\n\n    // FIXME: consider larger thread pool and/or making it configurable\n    private final static ScheduledThreadPoolExecutor clockExecutor\n        = new ScheduledThreadPoolExecutor(1);\n\n    private volatile ScheduledFuture<?> currentlyScheduledClockTask = null;\n\n    /**\n     * Method runs cyclic notification about time progress for TCP logic class\n     * It runs in a separate thread\n     */\n    private void runClock()\n    {\n        if (!runClock)\n        {\n            return;\n        }\n        long sleep;\n\n        synchronized (pseudoTcp)\n        {\n            pseudoTcp.notifyClock(PseudoTCPBase.now());\n            sleep = pseudoTcp.getNextClock(PseudoTCPBase.now());\n        }\n\n        //there might be negative interval even if there's no error\n        if (sleep == -1)\n        {\n            releaseAllLocks();\n            if (exception != null)\n            {\n                logger.log(Level.SEVERE,\n                           \"STATE: \" + pseudoTcp.getState()\n                           + \" ERROR: \" + exception.getMessage());\n            }\n        }\n        else\n        {\n            //logger.log(Level.FINEST, \"Clock sleep for \" + sleep);\n            scheduleClockTask(sleep);\n        }\n    }\n\n    private final Runnable clockTaskRunner = this::runClock;\n\n    private void scheduleClockTask(long sleep)\n    {\n        synchronized (clockTaskRunner)\n        {\n            // Cancel any existing tasks, to make sure we don't run duplicates.\n            cancelClockTask(false);\n            if (runClock)\n            {\n                currentlyScheduledClockTask\n                    = clockExecutor.schedule(\n                            clockTaskRunner, sleep, TimeUnit.MILLISECONDS);\n            }\n        }\n    }\n\n    private void cancelClockTask(boolean interruptIfRunning)\n    {\n        // Copy the reference, in case it changes.\n        ScheduledFuture<?> taskToCancel = this.currentlyScheduledClockTask;\n        if (taskToCancel != null)\n        {\n            taskToCancel.cancel(interruptIfRunning);\n        }\n    }\n\n    /**\n     * Returns an output stream for this socket.\n     * @return an output stream for writing to this socket.\n     * @throws IOException if an I/O error occurs when creating the output stream.\n     */\n    @Override\n    public OutputStream getOutputStream()\n        throws IOException\n    {\n        if (outputstream == null)\n        {\n            outputstream = new PseudoTcpOutputStream();\n        }\n        return outputstream;\n    }\n    \n\n    /**\n     * Returns an input stream for this socket.\n     * @return a stream for reading from this socket.\n     * @throws IOException \n     */\n    @Override\n    public InputStream getInputStream()\n        throws IOException\n    {\n        if (inputStream == null)\n        {\n            inputStream = new PseudoTcpInputStream();\n        }\n        return inputStream;\n    }\n\n    /**\n     * Returns the number of bytes that can be read from this socket without blocking.\n     * @return the number of bytes that can be read from this socket without blocking.\n     * @throws IOException if an I/O error occurs when determining the number of bytes available.\n     */\n    @Override\n    protected int available()\n        throws IOException\n    {\n        return getInputStream().available();\n    }\n    \n    /**\n     * Closes this socket.\n     */\n    @Override\n    public void close()\n        throws IOException\n    {\n        try\n        {\n            pseudoTcp.close(true);\n            //System.out.println(\"ON CLOSE: in flight \"+pseudoTcp.getBytesInFlight());\n            //System.out.println(\"ON CLOSE: buff not sent \"+pseudoTcp.getBytesBufferedNotSent());\n            onTcpClosed(pseudoTcp, null);\n            socket.close();\n            joinAllThreads();\n            //UpdateClock();\n            //TODO: closing procedure\n            //Here the thread should be blocked until TCP\n            //reaches CLOSED state, but there's no closing procedure\n            /*\n             * synchronized(state_notify){ while(pseudoTcp.getState() !=\n             * PseudoTcpState.TCP_CLOSED){ try { state_notify.wait(); } catch\n             * (InterruptedException ex) { throw new IOException(\"Close\n             * connection aborted\"); } } }\n             */\n        }\n        catch (InterruptedException ex)\n        {\n            throw new IOException(\"Closing socket interrupted\", ex);\n        }\n    }\n    \n    /**\n     * Send one byte of urgent data on the socket. The byte to be sent is the low eight bits of the parameter\n     * @param data The byte of data to send\n     * @throws IOException if there is an error sending the data.\n     */\n    @Override\n    protected void sendUrgentData(int data)\n        throws IOException\n    {\n        throw new RuntimeException(\"Sending urgent data is not supported\");\n    }\n\n    \n    \n    /**\n     * This class implements <tt>java.io.InputStream</tt>\n     */\n    class PseudoTcpInputStream extends InputStream\n    {\n        public PseudoTcpInputStream()\n        {\n        }\n\n        @Override\n        public boolean markSupported()\n        {\n            return false;\n        }\n\n        /**\n         * There's no end of stream detection at the moment. Method blocks until\n         * it returns any data or an exception is thrown\n         *\n         * @return read byte count\n         * @throws IOException in case of en error\n         */\n        @Override\n        public int read() throws IOException\n        {\n            byte[] buff = new byte[1];\n            int readCount = read(buff, 0, 1);\n            return readCount == 1 ? (buff[0] & 0xFF) : -1;\n        }\n\n        @Override\n        public int read(byte[] bytes) throws IOException\n        {\n            return read(bytes, 0, bytes.length);\n        }\n\n        /**\n         * This method blocks until any data is available\n         *\n         * @param buffer destination buffer\n         * @param offset destination buffer's offset\n         * @param length maximum count of bytes that can be read\n         * @return byte count actually read\n         * @throws IOException in case of error or if timeout occurs\n         */\n        @Override\n        public int read(byte[] buffer, int offset, int length)\n            throws IOException\n        {\n            long start = System.nanoTime();\n            int read;\n            while (true)\n            {\n                logger.log(Level.FINER, \"Read Recv\");\n                try\n                {\n                    read = pseudoTcp.recv(buffer, offset, length);\n                    if (logger.isLoggable(Level.FINER))\n                    {\n                        logger.log(Level.FINER,\n                                   \"Read Recv read count: \" + read);\n                    }\n                    if (read > 0)\n                    {\n                        return read;\n                    }\n                    logger.log(Level.FINER, \"Read wait for data available\");\n                    if (readTimeout > 0)\n                    {\n                        //Check for timeout\n                        long elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                        long left = readTimeout - elapsed;\n                        if (left <= 0)\n                        {\n                            IOException exc =\n                                new IOException(\"Read operation timeout\");\n                            pseudoTcp.closedown(exc);\n                            throw exc;\n                        }\n                        synchronized (read_notify)\n                        {\n                            if (pseudoTcp.getAvailable() == 0)\n                            {\n                                read_notify.wait(left);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        synchronized (read_notify)\n                        {\n                            if (pseudoTcp.getAvailable() == 0)\n                            {\n                                read_notify.wait();\n                            }\n                        }\n                    }\n                    if (logger.isLoggable(Level.FINER))\n                    {\n                        logger.log(\n                            Level.FINER,\n                            \"Read notified: \" + pseudoTcp.getAvailable());\n                    }\n                    if (exception != null)\n                    {\n                        throw exception;\n                    }\n                }\n                catch (InterruptedException ex)\n                {\n                    if (exception != null)\n                    {\n                        throw new IOException(\"Read aborted\", exception);\n                    }\n                    else\n                    {\n                        throw new IOException(\"Read aborted\");\n                    }\n                }\n            }\n        }\n\n        @Override\n        public int available() throws IOException\n        {\n            return pseudoTcp.getAvailable();\n        }\n\n        @Override\n        public void close() throws IOException\n        {\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public long skip(long n) throws IOException\n        {\n            return super.skip(n);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public synchronized void mark(int readlimit)\n        {\n            throw new UnsupportedOperationException(\"mark\");\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public synchronized void reset() throws IOException\n        {\n            throw new UnsupportedOperationException(\"reset\");\n        }\n    }\n\n    /**\n     * Implements <tt>java.io.OutputStream</tt>\n     */\n    class PseudoTcpOutputStream extends OutputStream\n    {\n        @Override\n        public void write(int b) throws IOException\n        {\n            byte[] bytes = new byte[1];\n            bytes[0] = (byte) b;\n            write(bytes);\n        }\n\n        /**\n         * This method blocks until all data has been written.\n         *\n         * @param buffer source buffer\n         * @param offset source buffer's offset\n         * @param length byte count to be written\n         * @throws IOException in case of error or if timeout occurs \n         * \n         */\n        @Override\n        public void write(byte[] buffer, int offset, int length) throws IOException\n        {\n            int toSend = length;\n            int sent;\n            long start = System.nanoTime();\n            while (toSend > 0)\n            {\n                synchronized (pseudoTcp)\n                {\n                    sent = pseudoTcp.send(buffer, offset + length - toSend, toSend);\n                }\n                if (sent > 0)\n                {\n                    toSend -= sent;\n                }\n                else\n                {\n                    try\n                    {\n                        logger.log(Level.FINER, \"Write wait for notify\");                        \n                        synchronized (write_notify)\n                        {\n                            if (writeTimeout > 0)\n                            {\n                                long elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                                long left = writeTimeout - elapsed;\n                                if (left <= 0)\n                                {\n                                    IOException exc = \n                                        new IOException(\"Write operation timeout\");\n                                    pseudoTcp.closedown(exc);\n                                    throw exc;\n                                }\n                                write_notify.wait(left);\n                            }\n                            else\n                            {\n                                write_notify.wait();\n                            }\n                        }\n                        logger.log(Level.FINER,\n                                   \"Write notified, available: \"\n                            + pseudoTcp.getAvailableSendBuffer());\n                        if (exception != null)\n                        {\n                            throw exception;\n                        }\n                    }\n                    catch (InterruptedException ex)\n                    {\n                        if (exception != null)\n                        {\n                            throw new IOException(\"Write aborted\", exception);\n                        }\n                        else\n                        {\n                            throw new IOException(\"Write aborted\", ex);\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * This method block until all buffered data has been written\n         *\n         * @throws IOException in case of error or if timeout occurs\n         */\n        @Override\n        public synchronized void flush() throws IOException\n        {\n            logger.log(Level.FINE, \"Flushing...\");\n            long start = System.nanoTime();\n            final Object ackNotify = pseudoTcp.getAckNotify();\n            synchronized (ackNotify)\n            {\n                while (pseudoTcp.getBytesBufferedNotSent() > 0)\n                {   \n                    try\n                    {\n                        if (writeTimeout > 0)\n                        {\n                            //Check write timeout\n                            long elapsed = TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start);\n                            long left = writeTimeout - elapsed;\n                            if (left <= 0)\n                            {\n                                IOException e = \n                                    new IOException(\"Flush operation timeout\"); \n                                pseudoTcp.closedown(e);\n                                throw e;\n                            }\n                            ackNotify.wait(left);\n                        }\n                        else\n                        {\n                            ackNotify.wait();\n                        }\n                    }\n                    catch (InterruptedException ex)\n                    {\n                        throw new IOException(\"Flush stream interrupted\", ex);\n                    }\n                }\n            }\n            logger.log(Level.FINE, \"Flushing completed\");\n        }\n\n        @Override\n        public void close() throws IOException\n        {\n            PseudoTcpSocketImpl.this.close();\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected FileDescriptor getFileDescriptor()\n    {\n        return fd;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected void shutdownInput()\n            throws IOException\n    {\n        throw new IOException(\"Method not implemented!\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected void shutdownOutput()\n            throws IOException\n    {\n        throw new IOException(\"Method not implemented!\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected InetAddress getInetAddress()\n    {\n        return ((InetSocketAddress) remoteAddr).getAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected int getPort()\n    {\n        return ((InetSocketAddress) remoteAddr).getPort();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected boolean supportsUrgentData()\n    {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected int getLocalPort()\n    {\n        return socket.getLocalPort();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected void setPerformancePreferences(int connectionTime,\n                                             int latency,\n                                             int bandwidth)\n    {\n        throw new UnsupportedOperationException(\"setPerformancePreferences\");\n    }\n}", "super_interfaces": ["PseudoTcpNotify"], "fields": [{"attribute_expression": "private static final java.util.logging.Logger logger =\n        java.util.logging.Logger.getLogger(PseudoTcpSocketImpl.class.getName());", "docstring": "\nThe logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "java.util.logging.Logger", "name": "logger =\n        java.util.logging.Logger.getLogger(PseudoTcpSocketImpl.class.getName())", "syntax_pass": true}, {"attribute_expression": "private final PseudoTCPBase pseudoTcp;", "docstring": "\nPseudotcp logic instance\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PseudoTCPBase", "name": "pseudoTcp", "syntax_pass": true}, {"attribute_expression": "private DatagramSocket socket;", "docstring": "\nDatagram socket used to handle network operations\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DatagramSocket", "name": "socket", "syntax_pass": true}, {"attribute_expression": "private SocketAddress remoteAddr;", "docstring": "\nCurrent socket address of remote socket that we are connected to\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SocketAddress", "name": "remoteAddr", "syntax_pass": true}, {"attribute_expression": "private int DATAGRAM_RCV_BUFFER_SIZE = 8000;", "docstring": "\nReceive buffer size used for receiving packets TODO: this should be\nchecked with MTU ?\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "DATAGRAM_RCV_BUFFER_SIZE = 8000", "syntax_pass": true}, {"attribute_expression": "private final Object write_notify = new Object();", "docstring": "\nMonitor object used to block threads on write operation. That is when the\nsend buffer is full.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "write_notify = new Object()", "syntax_pass": true}, {"attribute_expression": "private final Object read_notify = new Object();", "docstring": "\nMonitor object used to block threads on read operation. That is when\nthere's no more data available for reading.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "read_notify = new Object()", "syntax_pass": true}, {"attribute_expression": "private final Object state_notify = new Object();", "docstring": "\nMonitor object used to block thread waiting for change of TCP state.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "state_notify = new Object()", "syntax_pass": true}, {"attribute_expression": "private IOException exception;", "docstring": "\nException which occurred in pseudotcp logic and must be propagated to\nthreads blocked on any operations.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IOException", "name": "exception", "syntax_pass": true}, {"attribute_expression": "private long writeTimeout;", "docstring": "\nRead operations timeout in ms\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "writeTimeout", "syntax_pass": true}, {"attribute_expression": "private long readTimeout;", "docstring": "\nWrite operations timeout in ms\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "readTimeout", "syntax_pass": true}, {"attribute_expression": "private PseudoTcpInputStream inputStream;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PseudoTcpInputStream", "name": "inputStream", "syntax_pass": true}, {"attribute_expression": "private PseudoTcpOutputStream outputstream;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "PseudoTcpOutputStream", "name": "outputstream", "syntax_pass": true}, {"attribute_expression": "private Map<Integer, Object> options = new HashMap<>();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<Integer, Object>", "name": "options = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private boolean runReceive = false;", "docstring": "\nFlag which enables packets receive thread\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "runReceive = false", "syntax_pass": true}, {"attribute_expression": "private Thread receiveThread;", "docstring": "\nThread receiving packets from the network\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Thread", "name": "receiveThread", "syntax_pass": true}, {"attribute_expression": "private boolean runClock = false;", "docstring": "\nThe run flag for clock thread\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "runClock = false", "syntax_pass": true}, {"attribute_expression": "private final static ScheduledThreadPoolExecutor clockExecutor\n        = new ScheduledThreadPoolExecutor(1);", "docstring": " FIXME: consider larger thread pool and/or making it configurable", "modifiers": "private final static", "marker_annotations": [], "non_marker_annotations": ["private", "final", "static"], "comments": [], "type": "ScheduledThreadPoolExecutor", "name": "clockExecutor\n        = new ScheduledThreadPoolExecutor(1)", "syntax_pass": true}, {"attribute_expression": "private volatile ScheduledFuture<?> currentlyScheduledClockTask = null;", "docstring": "", "modifiers": "private volatile", "marker_annotations": [], "non_marker_annotations": ["private", "volatile"], "comments": [], "type": "ScheduledFuture<?>", "name": "currentlyScheduledClockTask = null", "syntax_pass": true}, {"attribute_expression": "private final Runnable clockTaskRunner = this::runClock;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Runnable", "name": "clockTaskRunner = this::runClock", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/pseudotcp/PseudoTcpJavaSocket.java.PseudoTcpJavaSocket", "name": "PseudoTcpJavaSocket", "file_path": "src/main/java/org/ice4j/pseudotcp/PseudoTcpJavaSocket.java", "superclasses": "Socket", "methods": ["[]PseudoTcpJavaSocket(long)", "[]PseudoTcpJavaSocket(long,DatagramSocket)"], "method_uris": ["src/main/java/org/ice4j/pseudotcp/PseudoTcpJavaSocket.java.PseudoTcpJavaSocket.[]PseudoTcpJavaSocket(long)", "src/main/java/org/ice4j/pseudotcp/PseudoTcpJavaSocket.java.PseudoTcpJavaSocket.[]PseudoTcpJavaSocket(long,DatagramSocket)"], "overrides": null, "attributes": [], "class_docstring": "\n\n@author Pawel Domas\n", "original_string": "public class PseudoTcpJavaSocket extends Socket {\n    public PseudoTcpJavaSocket(long conv_id) throws SocketException {\n        super(new PseudoTcpSocketImpl(conv_id));\n    }\n\n    public PseudoTcpJavaSocket(long conv_id, DatagramSocket socket)\n            throws SocketException {\n        super(new PseudoTcpSocketImpl(conv_id, socket));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/ice4j/pseudotcp/RSegment.java.RSegment", "name": "RSegment", "file_path": "src/main/java/org/ice4j/pseudotcp/RSegment.java", "superclasses": "", "methods": ["[]RSegment(long,long)"], "method_uris": ["src/main/java/org/ice4j/pseudotcp/RSegment.java.RSegment.[]RSegment(long,long)"], "overrides": null, "attributes": [], "class_docstring": "\nClass used internally as a structure for receive segments\n\n@author Pawel\n", "original_string": "class RSegment\n{\n    public long seq, len;\n\n    public RSegment(long seq, long len)\n    {\n        this.seq = seq;\n        this.len = len;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public long seq, len;", "docstring": "", "modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "type": "long", "name": "seq", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer", "name": "ByteFifoBuffer", "file_path": "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java", "superclasses": "", "methods": ["[]ByteFifoBuffer(int)", "[int]length()", "[int]read(byte[],int)", "[int]read(byte[],int,int)", "[int]readLimit(int)", "[void]readOp(byte[],int,int,byte[],int,int)", "[int]getWriteRemaining()", "[int]getBuffered()", "[int]write(byte[],int)", "[int]write(byte[],int,int)", "[void]writeOp(byte[],int,int,byte[],int,int)", "[int]writeLimit(int)", "[void]assertWriteLimit(int)", "[void]consumeWriteBuffer(int)", "[boolean]setCapacity(int)", "[void]consumeReadData(int)", "[int]readOffset(byte[],int,int,int)", "[int]writeOffset(byte[],int,int)", "[void]resetReadPosition()", "[void]resetWritePosition()"], "method_uris": ["src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[]ByteFifoBuffer(int)", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]length()", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]read(byte[],int)", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]read(byte[],int,int)", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]readLimit(int)", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[void]readOp(byte[],int,int,byte[],int,int)", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]getWriteRemaining()", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]getBuffered()", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]write(byte[],int)", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]write(byte[],int,int)", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[void]writeOp(byte[],int,int,byte[],int,int)", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]writeLimit(int)", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[void]assertWriteLimit(int)", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[void]consumeWriteBuffer(int)", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[boolean]setCapacity(int)", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[void]consumeReadData(int)", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]readOffset(byte[],int,int,int)", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[int]writeOffset(byte[],int,int)", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[void]resetReadPosition()", "src/main/java/org/ice4j/pseudotcp/util/ByteFifoBuffer.java.ByteFifoBuffer.[void]resetWritePosition()"], "overrides": null, "attributes": [], "class_docstring": "\nFirst in - first out byte buffer\n\n@author Pawel Domas\n", "original_string": "public class ByteFifoBuffer\n{\n    /**\n     * Backing byte array\n     */\n    private byte[] array;\n    /**\n     * Current write position\n     */\n    private int write_pos = 0;\n    /**\n     * Stored bytes count\n     */\n    private int buffered = 0;\n    /**\n     * Current read position\n     */\n    private int read_pos = 0;\n    \n    /**\n     * Creates buffer of specified size\n     *\n     * @param len buffer's size\n     */\n    public ByteFifoBuffer(int len)\n    {\n        array = new byte[len];\n    }\n\n    /**\n     * @return buffer's capacity\n     */\n    public int length()\n    {\n        return array.length;\n    }\n\n    /**\n     * Reads <tt>count</tt> bytes into <tt>out_buffer</tt>. \n     * Current read position is incremented by count of bytes \n     * that has been successfully read.\n     *\n     * @param out_buffer read count bytes into this buffer\n     * @param count number of bytes to read into the out_buffer\n     * @return bytes successfully read\n     */\n    public int read(byte[] out_buffer, int count)\n    {\n        return read(out_buffer, 0, count);\n    }\n    \n    /**\n     * Read with buffer offset\n     * \n     * @param out_buffer read count bytes into this buffer\n     * @param buff_offset offset where to start writing into out_buffer\n     * @param count bytes to read\n     * @return read byte count\n     */\n    public int read(byte[] out_buffer, int buff_offset, int count) {\n        count = readLimit(count);\n        if (count > 0)\n        {\n            readOp(out_buffer, buff_offset, count, array, read_pos, array.length);\n            read_pos = (read_pos + count) % array.length;\n            buffered -= count;\n        }\n        return count;\n    }\n\n    /**\n     * Limits <tt>desiredReadCount</tt> to count that is actually available\n     * @param desiredReadCount desired amount of bytes to read\n     * @return min(buffered, desiredReadCount)\n     */\n    private int readLimit(int desiredReadCount)\n    {\n        return desiredReadCount > buffered ? buffered : desiredReadCount;\n    }\n\n    /**\n     * Utility method used for read operations\n     * @param outBuffer\n     * @param dst_buff_offset\n     * @param count\n     * @param srcBuffer\n     * @param read_pos\n     * @param buff_len \n     */\n    private static void readOp(byte[] outBuffer, int dst_buff_offset, int count,\n                               byte[] srcBuffer, int read_pos, int buff_len)\n    {\n        if (read_pos + count <= buff_len)\n        {\n            //single operation\n            System.arraycopy(srcBuffer, read_pos, outBuffer, dst_buff_offset, \n                                                             count);\n        }\n        else\n        {\n            //two operations\n            int tillEndCount = buff_len - read_pos;\n            System.arraycopy(srcBuffer, read_pos, outBuffer,\n                             dst_buff_offset, tillEndCount);\n            int fromStartCount = count - tillEndCount;\n            System.arraycopy(srcBuffer, 0, outBuffer,\n                             dst_buff_offset + tillEndCount, fromStartCount);\n        }\n    }\n\n    /**\n     *\n     * @return space left in buffer for write\n     */\n    public int getWriteRemaining()\n    {\n        return array.length - buffered;\n    }\n\n    /**\n     *\n     * @return bytes stored in buffer and available for reading\n     */\n    public int getBuffered()\n    {\n        return buffered;\n    }\n\n    /**\n     * Writes <tt>count</tt> of bytes from the <tt>buffer</tt>\n     *\n     * @param buffer data to write into the buffer\n     * @param count number of bytes to read from the buffer\n     * @return bytes successfully written to buffer\n     */\n    public int write(byte[] buffer, int count)\n    {\n        return write(buffer, 0, count);\n    }\n\n    /**\n     * Writes data into the buffer.\n     *\n     * @param data source data\n     * @param offset source buffer's offset\n     * @param count number of bytes to read from the buffer\n     * @return byte count actually read\n     */\n    public int write(byte[] data, int offset, int count)\n    {\n        /*\n         * System.out.println(\"----write \" + this + \" \" + len + \" buffered \" +\n         * GetBuffered() + \" buff avail: \" + GetWriteRemaining());\n         */\n        count = writeLimit(count);\n        writeOp(data, offset, count, array, write_pos, array.length);\n        write_pos = (write_pos + count) % array.length;\n        buffered += count;\n        /*\n         * System.out.println(\"----write \"+this+\" \"+len+\" buffered\n         * \"+GetBuffered()); for(int i=0; i < len; i++){\n         * System.out.println(\"WDATA: \"+data[i]); }\n         */\n        return count;\n    }\n\n    /**\n     * Utility method for write operations\n     * @param inBuffer\n     * @param inOffset\n     * @param count\n     * @param outBuffer\n     * @param write_pos\n     * @param buff_len \n     */\n    private static void writeOp(byte[] inBuffer,\n                                int inOffset,\n                                int count,\n                                byte[] outBuffer,\n                                int write_pos,\n                                int buff_len)\n    {\n        if ((write_pos + count) <= buff_len)\n        {\n            //single op\n            System.arraycopy(inBuffer, inOffset, outBuffer, write_pos, count);\n        }\n        else\n        {\n            //till end and from beginning\n            int tillEndCount;\n            int fromStartCount;\n            tillEndCount = buff_len - write_pos;\n            fromStartCount = count - tillEndCount;\n            System.arraycopy(inBuffer, inOffset, outBuffer,\n                             write_pos, tillEndCount);\n            System.arraycopy(inBuffer, inOffset + tillEndCount,\n                             outBuffer, 0, fromStartCount);            \n        }\n    }\n\n    /**\n     * Limits <tt>desiredWriteCount</tt> to what's actually available\n     * @param desiredWriteCount\n     * @return \n     */\n    private int writeLimit(int desiredWriteCount)\n    {\n        return desiredWriteCount > (array.length - buffered) ? \n            (array.length - buffered) : desiredWriteCount;\n    }\n\n    /**\n     * Checks if new write position is correct\n     * \n     * @param newWrPos new write position\n     */\n    private void assertWriteLimit(int newWrPos)\n        throws IllegalArgumentException\n    {\n        int spaceReq;\n        int availSpace = getWriteRemaining();\n        if (newWrPos < write_pos)\n        {\n            spaceReq = newWrPos + (array.length - write_pos);\n        }\n        else\n        {\n            spaceReq = newWrPos - write_pos;\n        }\n\n        if (spaceReq > availSpace)\n        {\n            throw new IllegalArgumentException();\n        }\n    }\n\n    /**\n     * Advances current buffer's write position by <tt>count</tt> bytes\n     * \n     * @param count number of bytes to move forward\n     */\n    public void consumeWriteBuffer(int count)\n        throws IllegalArgumentException,\n               BufferOverflowException\n    {\n        if (count > getWriteRemaining())\n        {\n            throw new BufferOverflowException();\n        }\n        if (count < 0)\n        {\n            throw new IllegalArgumentException();\n        }\n        int newPos = (write_pos + count) % array.length;\n        assertWriteLimit(newPos);\n        \n        write_pos = newPos;\n        buffered += count;\n    }\n\n    /**\n     * Sets new buffer's capacity\n     *\n     * @param new_size number of bytes\n     * @return <tt>true</tt> if operation is possible to perform, that is if new\n     * buffered data fits into new buffer\n     */\n    public boolean setCapacity(int new_size)\n    {\n        if (new_size < getBuffered())\n        {\n            return false;\n        }\n        byte[] newBuff = new byte[new_size];\n        readOp(newBuff, 0, buffered, array, read_pos, array.length);\n        this.array = newBuff;\n        return true;\n    }\n\n    /**\n     * Aligns current read position by <tt>count</tt>\n     *\n     * @param count number of bytes to move the read position\n     * @throws BufferUnderflowException if new position exceeds buffered data\n     * count\n     */\n    public void consumeReadData(int count)\n        throws IllegalArgumentException,\n               BufferUnderflowException\n    {\n        /*\n         * System.out.println(\"Consume read \" + this + \" \" + count + \" read pos:\n         * \" + read_pos);\n         */\n        if (count > buffered)\n        {\n            throw new BufferUnderflowException();\n        }\n        if (count < 0)\n        {\n            throw new IllegalArgumentException();\n        }\n        this.read_pos = (read_pos + count) % array.length;\n        buffered -= count;\n    }\n\n    /**\n     * Reads <tt>count</tt> bytes from buffer without storing new read position\n     *\n     * @param dst_buff buffer to write the read data to\n     * @param dst_buff_offset offset of destination buffer\n     * @param count bytes to read\n     * @param offset from current read position\n     * @return bytes successfully read\n     */\n    public int readOffset(byte[] dst_buff,\n                          int dst_buff_offset,\n                          int count,\n                          int offset)\n    {\n        //TODO: not sure if should decrease read count or throw an exception\n        /*\n         * System.out.println(\"Read dst offset \" + dst_buff_offset + \" offset \"\n         * + offset + \" len \" + count + \" \" + this);\n         */\n        int read_offset = (this.read_pos + offset) % array.length;\n        readOp(dst_buff, dst_buff_offset, count, array, read_offset, array.length);\n\n        return count;\n    }\n\n    /**\n     * Writes <tt>count</tt> bytes from <tt>data</tt> to the buffer without\n     * affecting buffer's write position\n     *\n     * @param data the data to write to the buffer\n     * @param count number of bytes to read from data\n     * @param nOffset from buffer's write position\n     * @return bytes successfully written\n     */\n    public int writeOffset(byte[] data, int count, int nOffset)\n        throws BufferOverflowException\n    {\n        if (count > getWriteRemaining())\n        {\n            throw new BufferOverflowException();\n        }\n        if (count < 0)\n        {\n            throw new IllegalArgumentException();\n        }\n        int offWritePos = (this.write_pos + nOffset) % array.length;\n        count = writeLimit(count);\n        assertWriteLimit(offWritePos + count);\n        writeOp(data, 0, count, array, offWritePos, array.length);\n        \n        return count;\n    }\n\n    public void resetReadPosition()\n    {\n        this.read_pos = 0;\n    }\n\n    public void resetWritePosition()\n    {\n        this.write_pos = 0;\n        this.buffered = 0;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private byte[] array;", "docstring": "\nBacking byte array\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte[]", "name": "array", "syntax_pass": true}, {"attribute_expression": "private int write_pos = 0;", "docstring": "\nCurrent write position\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "write_pos = 0", "syntax_pass": true}, {"attribute_expression": "private int buffered = 0;", "docstring": "\nStored bytes count\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "buffered = 0", "syntax_pass": true}, {"attribute_expression": "private int read_pos = 0;", "docstring": "\nCurrent read position\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "read_pos = 0", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/NetworkUtils.java.NetworkUtils", "name": "NetworkUtils", "file_path": "src/main/java/org/ice4j/ice/NetworkUtils.java", "superclasses": "", "methods": ["[boolean]isValidPortNumber(int)", "[String]stripScopeID(String)"], "method_uris": ["src/main/java/org/ice4j/ice/NetworkUtils.java.NetworkUtils.[boolean]isValidPortNumber(int)", "src/main/java/org/ice4j/ice/NetworkUtils.java.NetworkUtils.[String]stripScopeID(String)"], "overrides": null, "attributes": [], "class_docstring": "\nUtility methods and fields to use when working with network addresses.\n\n@author Emil Ivov\n@author Damian Minkov\n@author Vincent Lucas\n@author Alan Kelly\n", "original_string": "public class NetworkUtils\n{\n    /**\n     * The maximum int value that could correspond to a port number.\n     */\n    public static final int    MAX_PORT_NUMBER = 65535;\n\n    /**\n     * The minimum int value that could correspond to a port number bindable\n     * by ice4j.\n     */\n    public static final int    MIN_PORT_NUMBER = 1024;\n\n    /**\n     * Determines whether <tt>port</tt> is a valid port number bindable by an\n     * application (i.e. an integer between 1024 and 65535).\n     *\n     * @param port the port number that we'd like verified.\n     *\n     * @return <tt>true</tt> if port is a valid and bindable port number and\n     * <tt>false</tt> otherwise.\n     */\n    public static boolean isValidPortNumber(int port)\n    {\n        return MIN_PORT_NUMBER <= port && port <= MAX_PORT_NUMBER;\n    }\n\n    /**\n     * Returns a <tt>String</tt> that is guaranteed not to contain an address\n     * scope specified (i.e. removes the %scopeID at the end of IPv6 addresses\n     * returned by Java. Takes into account the presence or absence of square\n     * brackets encompassing the address.\n     *\n     * @param ipv6Address the address whose scope ID we'd like to get rid of.\n     *\n     * @return the newly form address containing no scope ID.\n     */\n    public static String stripScopeID(String ipv6Address)\n    {\n        int scopeStart = ipv6Address.indexOf('%');\n\n        if (scopeStart == -1)\n            return ipv6Address;\n\n        ipv6Address = ipv6Address.substring(0, scopeStart);\n\n        //in case this was an IPv6 literal and we remove the closing bracket,\n        //put it back in now.\n        if (ipv6Address.charAt(0) == '['\n            && ipv6Address.charAt(ipv6Address.length()-1) != ']')\n        {\n            ipv6Address += ']';\n        }\n\n        return ipv6Address;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final int    MAX_PORT_NUMBER = 65535;", "docstring": "\nThe maximum int value that could correspond to a port number.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "MAX_PORT_NUMBER = 65535", "syntax_pass": true}, {"attribute_expression": "public static final int    MIN_PORT_NUMBER = 1024;", "docstring": "\nThe minimum int value that could correspond to a port number bindable\nby ice4j.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "MIN_PORT_NUMBER = 1024", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/TcpHostCandidate.java.TcpHostCandidate", "name": "TcpHostCandidate", "file_path": "src/main/java/org/ice4j/ice/TcpHostCandidate.java", "superclasses": "HostCandidate", "methods": ["[]TcpHostCandidate(TransportAddress,Component)", "[IceSocketWrapper]getCandidateIceSocketWrapper(SocketAddress)", "[void]addSocket(IceSocketWrapper)", "[void]free()"], "method_uris": ["src/main/java/org/ice4j/ice/TcpHostCandidate.java.TcpHostCandidate.[]TcpHostCandidate(TransportAddress,Component)", "src/main/java/org/ice4j/ice/TcpHostCandidate.java.TcpHostCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper(SocketAddress)", "src/main/java/org/ice4j/ice/TcpHostCandidate.java.TcpHostCandidate.[void]addSocket(IceSocketWrapper)", "src/main/java/org/ice4j/ice/TcpHostCandidate.java.TcpHostCandidate.[void]free()"], "overrides": null, "attributes": [], "class_docstring": "\nExtends {@link org.ice4j.ice.HostCandidate} allowing the instance to have\na list of <tt>Socket</tt>s instead of just one socket. This is needed,\nbecause with TCP, connections from different remote addresses result in\ndifferent <tt>Socket</tt> instances.\n\n@author Boris Grozev\n", "original_string": "public class TcpHostCandidate\n    extends HostCandidate\n{\n    /**\n     * List of <tt>accept</tt>ed sockets for this <tt>TcpHostCandidate</tt>.\n     */\n    private final List<IceSocketWrapper> sockets = new LinkedList<>();\n\n    /**\n     * Initializes a new <tt>TcpHostCandidate</tt>.\n     *\n     * @param transportAddress the transport address of this\n     * <tt>TcpHostCandidate</tt>.\n     * @param parentComponent the <tt>Component</tt> that this candidate\n     * belongs to.\n     */\n    public TcpHostCandidate(TransportAddress transportAddress,\n                            Component parentComponent)\n    {\n        super(transportAddress, parentComponent);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected IceSocketWrapper getCandidateIceSocketWrapper(\n            SocketAddress remoteAddress)\n    {\n        for (IceSocketWrapper socket : sockets)\n        {\n            if (socket.getTCPSocket().getRemoteSocketAddress()\n                .equals(remoteAddress))\n                return socket;\n        }\n\n        return null;\n    }\n\n    public void addSocket(IceSocketWrapper socket)\n    {\n        sockets.add(socket);\n    }\n\n    @Override\n    protected void free()\n    {\n        StunStack stunStack = getStunStack();\n        TransportAddress localAddr = getTransportAddress();\n\n        for (IceSocketWrapper socket : sockets)\n        {\n            //remove our sockets from the stack.\n            Socket tcpSocket = socket.getTCPSocket();\n\n            stunStack.removeSocket(\n                    localAddr,\n                    new TransportAddress(\n                            tcpSocket.getInetAddress(),\n                            tcpSocket.getPort(),\n                            Transport.TCP));\n\n            socket.close();\n        }\n\n        super.free();\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final List<IceSocketWrapper> sockets = new LinkedList<>();", "docstring": "\nList of <tt>accept</tt>ed sockets for this <tt>TcpHostCandidate</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<IceSocketWrapper>", "name": "sockets = new LinkedList<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket", "name": "ComponentSocket", "file_path": "src/main/java/org/ice4j/ice/ComponentSocket.java", "superclasses": "MergingDatagramSocket", "methods": ["[]ComponentSocket(Component,org.jitsi.utils.logging2.Logger)", "[boolean]accept(DatagramPacket)", "[void]addAuthorizedAddress(SocketAddress)", "[void]propertyChange(PropertyChangeEvent)", "[void]close()"], "method_uris": ["src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket.[]ComponentSocket(Component,org.jitsi.utils.logging2.Logger)", "src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket.[boolean]accept(DatagramPacket)", "src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket.[void]addAuthorizedAddress(SocketAddress)", "src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket.[void]propertyChange(PropertyChangeEvent)", "src/main/java/org/ice4j/ice/ComponentSocket.java.ComponentSocket.[void]close()"], "overrides": null, "attributes": [], "class_docstring": "\nExtends {@link MergingDatagramSocket} with functionality specific to\nan ICE {@link Component}.\n", "original_string": "public class ComponentSocket\n    extends MergingDatagramSocket\n    implements PropertyChangeListener\n{\n    /**\n     * Controls access to {@link #authorizedAddresses}.\n     */\n    private final Object authorizedAddressesSyncRoot = new Object();\n\n    /**\n     * The set of remote addresses, which this socket is allowed to receive\n     * from. These should be the addresses which we have confirmed (e.g. by\n     * having received a STUN message with correct authentication fields).\n     */\n    private Set<SocketAddress> authorizedAddresses = new HashSet<>();\n\n    /**\n     * The owning {@link Component}.\n     */\n    private Component component;\n\n    /**\n     * Whether we have invoked {@link #initializeActive}.\n     */\n    private boolean initializedActive = false;\n\n    /**\n     * Used to synchronize access to {@link #initializedActive}.\n     */\n    private final Object initializedActiveSyncRoot = new Object();\n\n    /**\n     * Initializes a new {@link MergingDatagramSocket} instance.\n     * @throws SocketException\n     */\n    ComponentSocket(Component component, org.jitsi.utils.logging2.Logger parentLogger)\n        throws SocketException\n    {\n        super(parentLogger);\n\n        this.component = component;\n        component.getParentStream().addPairChangeListener(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     * </p>\n     * Verifies that the source of the packet is an authorized remote address.\n     */\n    protected boolean accept(DatagramPacket p)\n    {\n        return authorizedAddresses.contains(p.getSocketAddress());\n    }\n\n    /**\n     * Adds a specific address to the list of authorized remote addresses.\n     * @param address the address to add.\n     */\n    private void addAuthorizedAddress(SocketAddress address)\n    {\n        synchronized (authorizedAddressesSyncRoot)\n        {\n            if (authorizedAddresses.contains(address))\n            {\n                return;\n            }\n\n            logger.info(\"Adding allowed address: \" + TransportAddress.redact(address));\n\n            Set<SocketAddress> newSet = new HashSet<>();\n            newSet.addAll(authorizedAddresses);\n            newSet.add(address);\n\n            authorizedAddresses = newSet;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     * </p>\n     * Handles property change events coming from ICE pairs.\n     * @param event\n     */\n    @Override\n    public void propertyChange(PropertyChangeEvent event)\n    {\n        if (!(event.getSource() instanceof CandidatePair))\n        {\n            return;\n        }\n\n        CandidatePair pair = (CandidatePair) event.getSource();\n        if (!pair.getParentComponent().equals(component))\n        {\n            // Events are fired by the IceMediaStream, which might have\n            // multiple components. Make sure that we only handle events for\n            // our own component.\n            return;\n        }\n\n        String propertyName = event.getPropertyName();\n        if (IceMediaStream.PROPERTY_PAIR_STATE_CHANGED.equals(propertyName))\n        {\n            CandidatePairState newState\n                = (CandidatePairState) event.getNewValue();\n\n            if (CandidatePairState.SUCCEEDED.equals(newState))\n            {\n                addAuthorizedAddress(\n                        pair.getRemoteCandidate().getTransportAddress());\n            }\n        }\n        else if (IceMediaStream.PROPERTY_PAIR_NOMINATED.equals(propertyName))\n        {\n            synchronized (initializedActiveSyncRoot)\n            {\n                if (initializedActive)\n                {\n                    return;\n                }\n\n                // Find the remote address and the correct socket to be used by\n                // the pair.\n                LocalCandidate localCandidate = pair.getLocalCandidate();\n                LocalCandidate base = localCandidate.getBase();\n                if (base != null)\n                {\n                    localCandidate = base;\n                }\n\n                TransportAddress remoteAddress = null;\n                RemoteCandidate remoteCandidate = pair.getRemoteCandidate();\n                if (remoteCandidate != null)\n                {\n                    remoteAddress = remoteCandidate.getTransportAddress();\n                }\n\n                // The local candidate may have more than one associated socket.\n                // Make sure we get the one for the remote address that we are\n                // going to use.\n                IceSocketWrapper socketWrapper\n                    = localCandidate\n                    .getCandidateIceSocketWrapper(remoteAddress);\n\n                initializeActive(socketWrapper, remoteAddress);\n                initializedActive = true;\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void close()\n    {\n        try\n        {\n            super.close();\n        }\n        finally\n        {\n            Component component = this.component;\n            if (component != null)\n            {\n                component.getParentStream().removePairStateChangeListener(this);\n                this.component = null;\n            }\n        }\n    }\n}", "super_interfaces": ["PropertyChangeListener"], "fields": [{"attribute_expression": "private final Object authorizedAddressesSyncRoot = new Object();", "docstring": "\nControls access to {@link #authorizedAddresses}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "authorizedAddressesSyncRoot = new Object()", "syntax_pass": true}, {"attribute_expression": "private Set<SocketAddress> authorizedAddresses = new HashSet<>();", "docstring": "\nThe set of remote addresses, which this socket is allowed to receive\nfrom. These should be the addresses which we have confirmed (e.g. by\nhaving received a STUN message with correct authentication fields).\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Set<SocketAddress>", "name": "authorizedAddresses = new HashSet<>()", "syntax_pass": true}, {"attribute_expression": "private Component component;", "docstring": "\nThe owning {@link Component}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Component", "name": "component", "syntax_pass": true}, {"attribute_expression": "private boolean initializedActive = false;", "docstring": "\nWhether we have invoked {@link #initializeActive}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "initializedActive = false", "syntax_pass": true}, {"attribute_expression": "private final Object initializedActiveSyncRoot = new Object();", "docstring": "\nUsed to synchronize access to {@link #initializedActive}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "initializedActiveSyncRoot = new Object()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream", "name": "IceMediaStream", "file_path": "src/main/java/org/ice4j/ice/IceMediaStream.java", "superclasses": "", "methods": ["[IceMediaStream]build(Agent,String)", "[]IceMediaStream(Agent,String)", "[Component]createComponent(KeepAliveStrategy,boolean)", "[String]getName()", "[String]toString()", "[Component]getComponent(int)", "[List<Component>]getComponents()", "[int]getComponentCount()", "[List<Integer>]getComponentIDs()", "[Agent]getParentAgent()", "[void]free()", "[void]removeComponent(Component)", "[void]initCheckList()", "[void]createCheckList(List<CandidatePair>)", "[void]createCheckList(Component,List<CandidatePair>)", "[void]orderCheckList()", "[void]pruneCheckList(List<CandidatePair>)", "[CheckList]getCheckList()", "[void]setMaxCheckListSize(int)", "[LocalCandidate]findLocalCandidate(TransportAddress,LocalCandidate)", "[RemoteCandidate]findRemoteCandidate(TransportAddress)", "[CandidatePair]findCandidatePair(TransportAddress,TransportAddress)", "[CandidatePair]findCandidatePair(String,String)", "[int]countHostCandidates()", "[void]addToCheckList(CandidatePair)", "[void]addToValidList(CandidatePair)", "[boolean]validListContainsFoundation(String)", "[boolean]validListContainsNomineeForComponent(Component)", "[boolean]validListContainsAllComponents()", "[boolean]allComponentsAreNominated()", "[boolean]allComponentsHaveSelected()", "[CandidatePair]getValidPair(Component)", "[void]addPairChangeListener(PropertyChangeListener)", "[void]removePairStateChangeListener(PropertyChangeListener)", "[void]firePairPropertyChange(CandidatePair,String,Object,Object)", "[void]setRemoteUfrag(String)", "[String]getRemoteUfrag()", "[void]setRemotePassword(String)", "[String]getRemotePassword()", "[Logger]getLogger()"], "method_uris": ["src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[IceMediaStream]build(Agent,String)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[]IceMediaStream(Agent,String)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[Component]createComponent(KeepAliveStrategy,boolean)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[String]getName()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[String]toString()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[Component]getComponent(int)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[List<Component>]getComponents()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[int]getComponentCount()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[List<Integer>]getComponentIDs()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[Agent]getParentAgent()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]free()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]removeComponent(Component)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]initCheckList()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]createCheckList(List<CandidatePair>)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]createCheckList(Component,List<CandidatePair>)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]orderCheckList()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]pruneCheckList(List<CandidatePair>)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[CheckList]getCheckList()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]setMaxCheckListSize(int)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[LocalCandidate]findLocalCandidate(TransportAddress,LocalCandidate)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[RemoteCandidate]findRemoteCandidate(TransportAddress)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[CandidatePair]findCandidatePair(TransportAddress,TransportAddress)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[CandidatePair]findCandidatePair(String,String)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[int]countHostCandidates()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]addToCheckList(CandidatePair)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]addToValidList(CandidatePair)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[boolean]validListContainsFoundation(String)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[boolean]validListContainsNomineeForComponent(Component)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[boolean]validListContainsAllComponents()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[boolean]allComponentsAreNominated()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[boolean]allComponentsHaveSelected()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[CandidatePair]getValidPair(Component)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]addPairChangeListener(PropertyChangeListener)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]removePairStateChangeListener(PropertyChangeListener)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]firePairPropertyChange(CandidatePair,String,Object,Object)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]setRemoteUfrag(String)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[String]getRemoteUfrag()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[void]setRemotePassword(String)", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[String]getRemotePassword()", "src/main/java/org/ice4j/ice/IceMediaStream.java.IceMediaStream.[Logger]getLogger()"], "overrides": null, "attributes": [], "class_docstring": "\nThe class represents a media stream from the ICE perspective, i.e. a\ncollection of components.\n\n@author Emil Ivov\n@author Namal Senarathne\n", "original_string": "public class IceMediaStream\n{\n    /**\n     * The property name that we use when delivering events notifying listeners\n     * that the consent freshness of a pair has changed.\n     */\n    public static final String PROPERTY_PAIR_CONSENT_FRESHNESS_CHANGED\n        = \"PairConsentFreshnessChanged\";\n\n    /**\n     * The property name that we use when delivering events notifying listeners\n     * of newly nominated pairs.\n     */\n    public static final String PROPERTY_PAIR_NOMINATED = \"PairNominated\";\n\n    /**\n     * The property name that we use when delivering events notifying listeners\n     * that a pair has changed states.\n     */\n    public static final String PROPERTY_PAIR_STATE_CHANGED = \"PairStateChanged\";\n\n    /**\n     * The property name that we use when delivering events notifying listeners\n     * of newly validated pairs.\n     */\n    public static final String PROPERTY_PAIR_VALIDATED = \"PairValidated\";\n\n    /**\n     * Use builder pattern to provide an immutable IceMediaStream instance.\n     *\n     * @param name the name of the media stream\n     * @param parentAgent the agent that is handling the session that this\n     * media stream is a part of\n     * @return IceMediaStream\n     */\n    public static IceMediaStream build(Agent parentAgent, String name)\n    {\n        return new IceMediaStream(parentAgent, name);\n    }\n\n    /**\n     * The name of this media stream. The name is equal to the value specified\n     * in the SDP description.\n     */\n    private final String name;\n\n    /**\n     * Returns the list of components that this media stream consists of. A\n     * component is a piece of a media stream requiring a single transport\n     * address; a media stream may require multiple components, each of which\n     * has to work for the media stream as a whole to work.\n     */\n    private final Map<Integer, Component> components = new LinkedHashMap<>();\n\n    /**\n     * An ordered set of candidate pairs for a media stream that have been\n     * validated by a successful STUN transaction. This list is empty at the\n     * start of ICE processing, and fills as checks are performed, resulting in\n     * valid candidate pairs.\n     */\n    private final TreeSet<CandidatePair> validList = new TreeSet<>();\n\n    /**\n     * The id that was last assigned to a component. The next id that we give\n     * to a component would be lastComponendID + 1;\n     */\n    private int lastComponentID = 0;\n\n    /**\n     * The CHECK-LIST for this agent described in the ICE specification: There\n     * is one check list per in-use media stream resulting from the offer/answer\n     * exchange.\n     */\n    private final CheckList checkList;\n\n    /**\n     * The agent that this media stream belongs to.\n     */\n    private final Agent parentAgent;\n\n    /**\n     * Contains {@link PropertyChangeListener}s registered with this {@link\n     * Agent} and following the various events it may be generating.\n     */\n    private final List<PropertyChangeListener> streamListeners\n        = new LinkedList<>();\n\n    /**\n     * The maximum number of candidate pairs that we should have in our check\n     * list. This value depends on the total number of media streams which is\n     * why it should be set by the agent:\n     * In addition, in order to limit the attacks described in Section 18.5.2,\n     * an agent MUST limit the total number of connectivity checks they perform\n     * across all check lists to a specific value, adn this value MUST be\n     * configurable.  A default of 100 is RECOMMENDED.\n     */\n    private int maxCheckListSize = config.getMaxCheckListSize();\n\n    /**\n     * The user fragment that we received from the remote party.\n     */\n    private String remoteUfrag = null;\n\n    /**\n     * The password that we received from the remote party.\n     */\n    private String remotePassword = null;\n\n    /**\n     * The {@link Logger} used by {@link IceMediaStream} instances.\n     */\n    private Logger logger;\n\n    /**\n     * Initializes a new <tt>IceMediaStream</tt> object.\n     *\n     * @param name the name of the media stream\n     * @param parentAgent the agent that is handling the session that this\n     * media stream is a part of\n     */\n    protected IceMediaStream(Agent parentAgent, String name)\n    {\n        logger = parentAgent.getLogger().createChildLogger(\n                IceMediaStream.class.getName(),\n                Collections.singletonMap(\"name\", name));\n        this.name = name;\n        this.parentAgent = parentAgent;\n        checkList = new CheckList(this);\n    }\n\n    /**\n     * Creates and adds a component to this media-stream\n     * The component ID is incremented to the next integer value\n     * when creating the component so make sure you keep that in mind in case\n     * assigning a specific component ID is important to you.\n     *\n     * @param keepAliveStrategy the keep-alive strategy, which dictates which\n     * candidates pairs are going to be kept alive.\n     * @param useComponentSocket whether the \"component socket\" should be used\n     * or not. See {@link AgentConfig#getUseComponentSocket()}.\n     *\n     * @return the newly created stream <tt>Component</tt> after adding it to\n     * the stream first.\n     */\n    protected Component createComponent(\n            KeepAliveStrategy keepAliveStrategy,\n            boolean useComponentSocket)\n    {\n        Component component;\n\n        synchronized (components)\n        {\n            component\n                = new Component(\n                    ++lastComponentID,\n                    this,\n                    keepAliveStrategy,\n                    useComponentSocket,\n                    logger);\n            components.put(component.getComponentID(), component);\n        }\n\n        return component;\n    }\n\n    /**\n     * Returns the name of this <tt>IceMediaStream</tt>.\n     *\n     * @return the name of this <tt>IceMediaStream</tt>.\n     */\n    public String getName()\n    {\n        return name;\n    }\n\n    /**\n     * Returns a <tt>String</tt> representation of this media stream.\n     *\n     * @return a <tt>String</tt> representation of this media stream.\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff\n            = new StringBuilder( \"media stream:\")\n                .append(getName());\n\n        buff.append(\" (component count=\")\n            .append(getComponentCount())\n            .append(\")\");\n\n        for (Component cmp : getComponents())\n            buff.append(\"\\n\").append(cmp);\n\n        return buff.toString();\n    }\n\n    /**\n     * Returns the <tt>Component</tt> with the specified <tt>id</tt> or\n     * <tt>null</tt> if no such component exists in this stream.\n     *\n     * @param id the identifier of the component we are looking for.\n     *\n     * @return  the <tt>Component</tt> with the specified <tt>id</tt> or\n     * <tt>null</tt> if no such component exists in this stream.\n     */\n    public Component getComponent(int id)\n    {\n        synchronized(components)\n        {\n            return components.get(id);\n        }\n    }\n\n    /**\n     * Returns the list of <tt>Component</tt>s currently registered with this\n     * stream.\n     *\n     * @return a non-null list of <tt>Component</tt>s currently registered with\n     * this stream.\n     */\n    public List<Component> getComponents()\n    {\n        synchronized(components)\n        {\n            return new ArrayList<>(components.values());\n        }\n    }\n\n    /**\n     * Returns the number of <tt>Component</tt>s currently registered with this\n     * stream.\n     *\n     * @return the number of <tt>Component</tt>s currently registered with this\n     * stream.\n     */\n    public int getComponentCount()\n    {\n        synchronized(components)\n        {\n            return components.size();\n        }\n    }\n\n    /**\n     * Returns the IDs of all <tt>Component</tt>s currently registered with this\n     * stream.\n     *\n     * @return a non-null list of IDs corresponding to the <tt>Component</tt>s\n     * currently registered with this stream.\n     */\n    public List<Integer> getComponentIDs()\n    {\n        synchronized(components)\n        {\n            return new ArrayList<>(components.keySet());\n        }\n    }\n\n    /**\n     * Returns a reference to the <tt>Agent</tt> that this stream belongs to.\n     *\n     * @return a reference to the <tt>Agent</tt> that this stream belongs to.\n     */\n    public Agent getParentAgent()\n    {\n        return parentAgent;\n    }\n\n    /**\n     * Removes this stream and all <tt>Candidate</tt>s associated with its child\n     * <tt>Component</tt>s.\n     */\n    protected void free()\n    {\n        List<Component> components;\n\n        synchronized (this.components)\n        {\n            components = getComponents();\n            this.components.clear();\n        }\n        /*\n         * Free the components outside the synchronized block because a deadlock\n         * has been reported (by Carl Hasselskog). The execution flow is not the\n         * same as when freeing the components inside the synchronized block\n         * because in the latter case an exception thrown by Component#free()\n         * will leave subsequent components in IceMediaStream#componenets. But\n         * there is no indication that such behaviour is expected.\n         */\n        for (Component component : components)\n            component.free();\n    }\n\n    /**\n     * Removes <tt>component</tt> and all its <tt>Candidate</tt>s from the\n     * this stream and releases all associated resources that they had\n     * allocated (like sockets for example)\n     *\n     * @param component the <tt>Component</tt> we'd like to remove and free.\n     */\n    public void removeComponent(Component component)\n    {\n        synchronized (components)\n        {\n            components.remove(component.getComponentID());\n        }\n        /*\n         * There is no known reason why the component should be freed with\n         * synchronization by components. However, the freeing outside the\n         * synchronization block will surely decrease the chances of a deadlock.\n         * Besides, Component#free() has really been reported involved in a\n         * deadlock.\n         */\n        component.free();\n    }\n\n    /**\n     * Creates, initializes and orders the list of candidate pairs that would\n     * be used for the connectivity checks for all components in this stream.\n     */\n    protected void initCheckList()\n    {\n        //first init the check list.\n        synchronized(checkList)\n        {\n            checkList.clear();\n            createCheckList(checkList);\n\n            orderCheckList();\n            pruneCheckList(checkList);\n            logger.trace(() -> \"Checklist initialized.\");\n        }\n    }\n\n    /**\n     * Creates and adds to <tt>checkList</tt> all the <tt>CandidatePair</tt>s\n     * in all <tt>Component</tt>s of this stream.\n     *\n     * @param checkList the list that we need to update with the new pairs.\n     */\n    protected void createCheckList(List<CandidatePair> checkList)\n    {\n        for (Component cmp : getComponents())\n            createCheckList(cmp, checkList);\n    }\n\n    /**\n     * Creates and adds to <tt>checkList</tt> all the <tt>CandidatePair</tt>s\n     * in <tt>component</tt>.\n     *\n     * @param component the <tt>Component</tt> whose candidates we need to\n     * pair and extract.\n     * @param checkList the list that we need to update with the new pairs.\n     */\n    private void createCheckList(final Component           component,\n                                 final List<CandidatePair> checkList)\n    {\n        List<LocalCandidate> localCnds = component.getLocalCandidates();\n        List<RemoteCandidate> remoteCnds = component.getRemoteCandidates();\n        LocalCandidate upnpBase = null;\n\n        for (LocalCandidate lc : localCnds)\n        {\n            // XXX do we assume a single UPNPCandidate here?\n            if (lc instanceof UPNPCandidate)\n                upnpBase = lc.getBase();\n        }\n\n        for (LocalCandidate localCnd : localCnds)\n        {\n            // Don't take into consideration UPnP base candidate\n            if (localCnd == upnpBase)\n                continue;\n\n            for (RemoteCandidate remoteCnd : remoteCnds)\n            {\n                if (localCnd.canReach(remoteCnd)\n                        && remoteCnd.getTransportAddress().getPort() != 0)\n                {\n                    CandidatePair pair\n                        = getParentAgent()\n                            .createCandidatePair(localCnd, remoteCnd);\n                    checkList.add(pair);\n                }\n            }\n        }\n    }\n\n    /**\n     * Orders this stream's pair check list in decreasing order of pair\n     * priority. If two pairs have identical priority, the ordering amongst\n     * them is arbitrary.\n     */\n    private void orderCheckList()\n    {\n        Collections.sort(checkList, CandidatePair.comparator);\n    }\n\n    /**\n     *  Removes or, as per the ICE spec, \"prunes\" pairs that we don't need to\n     *  run checks for. For example, since we cannot send requests directly\n     *  from a reflexive candidate, but only from its base, we go through the\n     *  sorted list of candidate pairs and in every pair where the local\n     *  candidate is server reflexive, we replace the local server reflexive\n     *  candidate with its base. Once this has been done, we remove each pair\n     *  where the local and remote candidates are identical to the local and\n     *  remote candidates of a pair higher up on the priority list.\n     *  <br>\n     *  In addition, in order to limit the attacks described in Section 18.5.2\n     *  of the ICE spec, we limit the total number of pairs and hence\n     *  (connectivity checks) to a specific value, (a total of 100 by default).\n     *\n     * @param checkList the checklist to prune\n     */\n    protected void pruneCheckList(List<CandidatePair> checkList)\n    {\n        //a list that we only use for storing pairs that we've already gone\n        //through. The list is destroyed at the end of this method.\n        List<CandidatePair> tmpCheckList = new ArrayList<>(checkList.size());\n\n        Iterator<CandidatePair> ckListIter = checkList.iterator();\n\n        while (ckListIter.hasNext())\n        {\n            CandidatePair pair = ckListIter.next();\n\n            //drop all pairs above MAX_CHECK_LIST_SIZE.\n            if (tmpCheckList.size() > maxCheckListSize)\n            {\n                ckListIter.remove();\n                continue;\n            }\n\n            //replace local server reflexive candidates with their base.\n            LocalCandidate localCnd = pair.getLocalCandidate();\n            if ( localCnd.getType()\n                        == CandidateType.SERVER_REFLEXIVE_CANDIDATE)\n            {\n                pair.setLocalCandidate(localCnd.getBase());\n\n                //if the new pair corresponds to another one with a higher\n                //priority, then remove it.\n                if (tmpCheckList.contains(pair))\n                {\n                    ckListIter.remove();\n                    continue;\n                }\n            }\n\n            tmpCheckList.add(pair);\n        }\n    }\n\n    /**\n     * Returns the list of <tt>CandidatePair</tt>s to be used in checks for\n     * this stream.\n     *\n     * @return the list of <tt>CandidatePair</tt>s to be used in checks for\n     * this stream.\n     */\n    public CheckList getCheckList()\n    {\n        return checkList;\n    }\n\n    /**\n     * Sets the maximum number of pairs that we should have in our check list.\n     *\n     * @param nSize the size of our check list.\n     */\n    protected void setMaxCheckListSize(int nSize)\n    {\n        this.maxCheckListSize = nSize;\n    }\n\n    /**\n     * Returns the local <tt>LocalCandidate</tt> with the specified\n     * <tt>address</tt> if it belongs to any of this stream's components\n     * or <tt>null</tt> otherwise. If {@code base} is also specified, tries to\n     * find a candidate whose base matches {@code base}.\n     *\n     * @param address the {@link TransportAddress} we are looking for.\n     * @param base an optional base to match.\n     *\n     * @return  the local <tt>LocalCandidate</tt> with the specified\n     * <tt>address</tt> if it belongs to any of this stream's components\n     * or <tt>null</tt> otherwise.\n     */\n    public LocalCandidate findLocalCandidate(TransportAddress address, LocalCandidate base)\n    {\n        for (Component component : components.values())\n        {\n            LocalCandidate localCandidate\n                    = component.findLocalCandidate(address, base);\n\n            if (localCandidate != null)\n            {\n                return localCandidate;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the local <tt>Candidate</tt> with the specified\n     * <tt>remoteAddress</tt> if it belongs to any of this stream's {@link\n     * Component}s or <tt>null</tt> if it doesn't.\n     *\n     * @param remoteAddress the {@link TransportAddress} we are looking for.\n     *\n     * @return the local <tt>Candidate</tt> with the specified\n     * <tt>remoteAddress</tt> if it belongs to any of this stream's {@link\n     * Component}s or <tt>null</tt> if it doesn't.\n     *\n     */\n    public RemoteCandidate findRemoteCandidate(TransportAddress remoteAddress)\n    {\n        for ( Component cmp : components.values())\n        {\n            RemoteCandidate cnd = cmp.findRemoteCandidate(remoteAddress);\n\n            if (cnd != null)\n                return cnd;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the {@link CandidatePair} with the specified remote and local\n     * addresses or <tt>null</tt> if neither of the {@link CheckList}s in this\n     * stream contain such a pair.\n     *\n     * @param localAddress the local {@link TransportAddress} of the pair we\n     * are looking for.\n     * @param remoteAddress the remote {@link TransportAddress} of the pair we\n     * are looking for.\n     *\n     * @return the {@link CandidatePair} with the specified remote and local\n     * addresses or <tt>null</tt> if neither of the {@link CheckList}s in this\n     * stream contain such a pair.\n     */\n    public CandidatePair findCandidatePair(TransportAddress localAddress,\n                                           TransportAddress remoteAddress)\n    {\n        synchronized(checkList)\n        {\n            for (CandidatePair pair : checkList)\n            {\n                if (pair.getLocalCandidate().getTransportAddress()\n                            .equals(localAddress)\n                        && pair.getRemoteCandidate().getTransportAddress()\n                                .equals(remoteAddress))\n                {\n                    return pair;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the {@link CandidatePair} with the specified remote and local\n     * addresses or <tt>null</tt> if neither of the {@link CheckList}s in this\n     * stream contain such a pair.\n     *\n     * @param localUFrag local user fragment\n     * @param remoteUFrag remote user fragment\n     * @return the {@link CandidatePair} with the specified remote and local\n     * addresses or <tt>null</tt> if neither of the {@link CheckList}s in this\n     * stream contain such a pair.\n     */\n    public CandidatePair findCandidatePair(String localUFrag,\n                                           String remoteUFrag)\n    {\n        synchronized(checkList)\n        {\n            for (CandidatePair pair : checkList)\n            {\n                LocalCandidate local = pair.getLocalCandidate();\n                RemoteCandidate remote = pair.getRemoteCandidate();\n\n                if (local.getUfrag().equals(remoteUFrag)\n                        && remote.getUfrag().equals(localUFrag))\n                {\n                    return pair;\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the number of host {@link Candidate}s in this stream.\n     *\n     * @return the number of host {@link Candidate}s in this stream.\n     */\n    protected int countHostCandidates()\n    {\n        int num = 0;\n\n        synchronized (components)\n        {\n            for (Component cmp : components.values())\n                num += cmp.countLocalHostCandidates();\n        }\n\n        return num;\n    }\n\n    /**\n     * Adds <tt>candidatePair</tt> to this stream's check list. The method\n     * is meant for use during the connectivity checks phase when new pairs\n     * with remote PEER-REFLEXIVE-CANDIDATEs are discovered.\n     *\n     * @param candidatePair the pair that we'd like to add to this streams.\n     */\n    protected void addToCheckList(CandidatePair candidatePair)\n    {\n        synchronized(checkList)\n        {\n            checkList.add(candidatePair);\n        }\n    }\n\n    /**\n     * Adds <tt>pair</tt> to the <tt>valid list</tt> that this stream is\n     * maintaining.\n     *\n     * @param pair the {@link CandidatePair} to add to our valid list.\n     */\n    protected void addToValidList(CandidatePair pair)\n    {\n        synchronized (validList)\n        {\n            if (!validList.contains(pair))\n                validList.add(pair);\n        }\n\n        pair.validate();\n    }\n\n    /**\n     * Returns <tt>true</tt> if this stream's <tt>validList</tt> contains a\n     * pair with the specified <tt>foundation</tt> and <tt>false</tt> otherwise.\n     *\n     * @param foundation the foundation String we'd like to search our\n     * validList for.\n     *\n     * @return <tt>true</tt> if this stream's <tt>validList</tt> contains a\n     * pair with the specified <tt>foundation</tt> and <tt>false</tt> otherwise.\n     */\n    protected boolean validListContainsFoundation(String foundation)\n    {\n        synchronized(validList)\n        {\n            for (CandidatePair pair : validList)\n            {\n                if (pair.getFoundation().equals(foundation))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <tt>true</tt> if this stream's <tt>validList</tt> contains a\n     * pair that is nominated for the specified <tt>Component</tt> and\n     * <tt>false</tt> otherwise.\n     *\n     * @param component the <tt>Component</tt> we'd like to search our\n     * validList for.\n     *\n     * @return <tt>true</tt> if this stream's <tt>validList</tt> contains a\n     * pair that is nominated for the specified <tt>Component</tt> and\n     * <tt>false</tt> otherwise.\n     */\n    protected boolean validListContainsNomineeForComponent(Component component)\n    {\n        synchronized (validList)\n        {\n            for (CandidatePair pair : validList)\n            {\n                if (pair.isNominated()\n                        && pair.getParentComponent() == component)\n                {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <tt>true</tt> if this stream's valid list contains at least\n     * one {@link CandidatePair} for each {@link Component} of the stream and\n     * <tt>false</tt> otherwise.\n     *\n     * @return <tt>true</tt> if this stream's valid list contains at least\n     * one {@link CandidatePair} for each {@link Component} of the stream and\n     * <tt>false</tt> otherwise.\n     */\n    protected boolean validListContainsAllComponents()\n    {\n        for (Component cmp : getComponents())\n        {\n            if (getValidPair(cmp) == null)\n            {\n                //it looks like there's at least one component we don't have a\n                //valid candidate for.\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns <tt>true</tt> if there is at least one nominated {@link\n     * CandidatePair} in the valid list for every {@link Component} of this\n     * stream and <tt>false</tt> otherwise.\n     *\n     * @return <tt>true</tt> if there is at least one nominated {@link\n     * CandidatePair} in the valid list for every {@link Component} of this\n     * stream and <tt>false</tt> otherwise.\n     */\n    protected boolean allComponentsAreNominated()\n    {\n        List<Component> components = getComponents();\n\n        synchronized (validList)\n        {\n            for (CandidatePair pair : validList)\n            {\n                if (pair.isNominated())\n                    components.remove(pair.getParentComponent());\n            }\n        }\n\n        return components.isEmpty();\n    }\n\n    /**\n     * Returns <tt>false</tt> if there is at least one nominated {@link\n     * CandidatePair} who doesn't have a selected address yet, and <tt>true</tt>\n     * otherwise.\n     *\n     * @return <tt>false</tt> if there is at least one nominated {@link\n     * CandidatePair} who doesn't have a selected address yet, and <tt>true</tt>\n     * otherwise.\n     */\n    protected boolean allComponentsHaveSelected()\n    {\n        for (Component component : getComponents())\n        {\n            if (component.getSelectedPair() == null)\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the first {@link CandidatePair} stored in this stream's valid\n     * list, that belongs to the specified <tt>component</tt>.\n     *\n     * @param component the {@link Component} we'd like to obtain a valid\n     * pair for.\n     *\n     * @return a valid {@link CandidatePair} for the specified\n     * <tt>component</tt> if at least one exists, and <tt>null</tt> otherwise.\n     */\n    protected CandidatePair getValidPair(Component component)\n    {\n        synchronized (validList)\n        {\n            for (CandidatePair pair : validList)\n            {\n                if (pair.getParentComponent() == component)\n                    return pair;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Adds <tt>l</tt> to the list of listeners registered for property changes\n     * if {@link CandidatePair}s. We add such listeners in the stream, rather\n     * than having them in the candidate pair itself, because we don't want all\n     * pairs to keep lists of references to the same listeners.\n     *\n     * @param l the listener to register.\n     */\n    public void addPairChangeListener(PropertyChangeListener l)\n    {\n        synchronized (streamListeners)\n        {\n            if (!streamListeners.contains(l))\n                streamListeners.add(l);\n        }\n    }\n\n    /**\n     * Removes <tt>l</tt> from the list of listeners registered for property\n     * changes.\n     *\n     * @param l the listener to remove.\n     */\n    public void removePairStateChangeListener(PropertyChangeListener l)\n    {\n        synchronized (streamListeners)\n        {\n            streamListeners.remove(l);\n        }\n    }\n\n    /**\n     * Creates a new {@link PropertyChangeEvent} and delivers it to all\n     * currently registered state listeners.\n     *\n     * @param source the {@link CandidatePair} whose property has just changed.\n     * @param propertyName the name of the property that changed.\n     * @param oldValue the old value of the property that changed.\n     * @param newValue the new value of the property that changed.\n     */\n    protected void firePairPropertyChange(CandidatePair source,\n                                          String        propertyName,\n                                          Object        oldValue,\n                                          Object        newValue)\n    {\n        PropertyChangeListener[] ls;\n\n        synchronized (streamListeners)\n        {\n            ls\n                = streamListeners.toArray(\n                        new PropertyChangeListener[streamListeners.size()]);\n        }\n\n        PropertyChangeEvent ev\n            = new PropertyChangeEvent(source, propertyName, oldValue, newValue);\n\n        for (PropertyChangeListener l : ls)\n            l.propertyChange(ev);\n    }\n\n    /**\n     * Specifies the user name that we received from the remote peer.\n     *\n     * @param remoteUfrag the user name that we received from the remote peer.\n     */\n    public void setRemoteUfrag(String remoteUfrag)\n    {\n        this.remoteUfrag = remoteUfrag;\n    }\n\n    /**\n     * Returns the user name that we received from the remote peer or\n     * <tt>null</tt> if we haven't received a user name from them yet.\n     *\n     * @return the user name that we received from the remote peer or\n     * <tt>null</tt> if we haven't received a user name from them yet.\n     */\n    public String getRemoteUfrag()\n    {\n        return remoteUfrag;\n    }\n\n    /**\n     * Specifies the password that we received from the remote peer.\n     *\n     * @param remotePassword the user name that we received from the remote\n     * peer.\n     */\n    public void setRemotePassword(String remotePassword)\n    {\n        this.remotePassword = remotePassword;\n    }\n\n    /**\n     * Returns the password that we received from the remote peer or\n     * <tt>null</tt> if we haven't received a password from them yet.\n     *\n     * @return the password that we received from the remote peer or\n     * <tt>null</tt> if we haven't received a password from them yet.\n     */\n    public String getRemotePassword()\n    {\n        return remotePassword;\n    }\n\n    public Logger getLogger()\n    {\n        return logger;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String PROPERTY_PAIR_CONSENT_FRESHNESS_CHANGED\n        = \"PairConsentFreshnessChanged\";", "docstring": "\nThe property name that we use when delivering events notifying listeners\nthat the consent freshness of a pair has changed.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "PROPERTY_PAIR_CONSENT_FRESHNESS_CHANGED\n        = \"PairConsentFreshnessChanged\"", "syntax_pass": true}, {"attribute_expression": "public static final String PROPERTY_PAIR_NOMINATED = \"PairNominated\";", "docstring": "\nThe property name that we use when delivering events notifying listeners\nof newly nominated pairs.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "PROPERTY_PAIR_NOMINATED = \"PairNominated\"", "syntax_pass": true}, {"attribute_expression": "public static final String PROPERTY_PAIR_STATE_CHANGED = \"PairStateChanged\";", "docstring": "\nThe property name that we use when delivering events notifying listeners\nthat a pair has changed states.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "PROPERTY_PAIR_STATE_CHANGED = \"PairStateChanged\"", "syntax_pass": true}, {"attribute_expression": "public static final String PROPERTY_PAIR_VALIDATED = \"PairValidated\";", "docstring": "\nThe property name that we use when delivering events notifying listeners\nof newly validated pairs.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "PROPERTY_PAIR_VALIDATED = \"PairValidated\"", "syntax_pass": true}, {"attribute_expression": "private final String name;", "docstring": "\nThe name of this media stream. The name is equal to the value specified\nin the SDP description.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "private final Map<Integer, Component> components = new LinkedHashMap<>();", "docstring": "\nReturns the list of components that this media stream consists of. A\ncomponent is a piece of a media stream requiring a single transport\naddress; a media stream may require multiple components, each of which\nhas to work for the media stream as a whole to work.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<Integer, Component>", "name": "components = new LinkedHashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final TreeSet<CandidatePair> validList = new TreeSet<>();", "docstring": "\nAn ordered set of candidate pairs for a media stream that have been\nvalidated by a successful STUN transaction. This list is empty at the\nstart of ICE processing, and fills as checks are performed, resulting in\nvalid candidate pairs.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TreeSet<CandidatePair>", "name": "validList = new TreeSet<>()", "syntax_pass": true}, {"attribute_expression": "private int lastComponentID = 0;", "docstring": "\nThe id that was last assigned to a component. The next id that we give\nto a component would be lastComponendID + 1;\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "lastComponentID = 0", "syntax_pass": true}, {"attribute_expression": "private final CheckList checkList;", "docstring": "\nThe CHECK-LIST for this agent described in the ICE specification: There\nis one check list per in-use media stream resulting from the offer/answer\nexchange.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CheckList", "name": "checkList", "syntax_pass": true}, {"attribute_expression": "private final Agent parentAgent;", "docstring": "\nThe agent that this media stream belongs to.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Agent", "name": "parentAgent", "syntax_pass": true}, {"attribute_expression": "private final List<PropertyChangeListener> streamListeners\n        = new LinkedList<>();", "docstring": "\nContains {@link PropertyChangeListener}s registered with this {@link\nAgent} and following the various events it may be generating.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<PropertyChangeListener>", "name": "streamListeners\n        = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private int maxCheckListSize = config.getMaxCheckListSize();", "docstring": "\nThe maximum number of candidate pairs that we should have in our check\nlist. This value depends on the total number of media streams which is\nwhy it should be set by the agent:\nIn addition, in order to limit the attacks described in Section 18.5.2,\nan agent MUST limit the total number of connectivity checks they perform\nacross all check lists to a specific value, adn this value MUST be\nconfigurable.  A default of 100 is RECOMMENDED.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "maxCheckListSize = config.getMaxCheckListSize()", "syntax_pass": true}, {"attribute_expression": "private String remoteUfrag = null;", "docstring": "\nThe user fragment that we received from the remote party.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "remoteUfrag = null", "syntax_pass": true}, {"attribute_expression": "private String remotePassword = null;", "docstring": "\nThe password that we received from the remote party.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "remotePassword = null", "syntax_pass": true}, {"attribute_expression": "private Logger logger;", "docstring": "\nThe {@link Logger} used by {@link IceMediaStream} instances.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Logger", "name": "logger", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/CandidatePrioritizer.java.CandidatePrioritizer", "name": "CandidatePrioritizer", "file_path": "src/main/java/org/ice4j/ice/CandidatePrioritizer.java", "superclasses": "", "methods": ["[int]compareCandidates(Candidate<?>,Candidate<?>)", "[int]compare(Candidate<?>,Candidate<?>)", "[boolean]equals(Object)"], "method_uris": ["src/main/java/org/ice4j/ice/CandidatePrioritizer.java.CandidatePrioritizer.[int]compareCandidates(Candidate<?>,Candidate<?>)", "src/main/java/org/ice4j/ice/CandidatePrioritizer.java.CandidatePrioritizer.[int]compare(Candidate<?>,Candidate<?>)", "src/main/java/org/ice4j/ice/CandidatePrioritizer.java.CandidatePrioritizer.[boolean]equals(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nCompares candidates based on their priority.\n\n@author Emil Ivov\n", "original_string": "class CandidatePrioritizer\n    implements Comparator<Candidate<?>>\n{\n    /**\n     * Compares the two <tt>Candidate</tt>s based on their priority and\n     * returns a negative integer, zero, or a positive integer as the first\n     * <tt>Candidate</tt> has a lower, equal, or greater priority than the\n     * second.\n     *\n     * @param c1 the first <tt>Candidate</tt> to compare.\n     * @param c2 the second <tt>Candidate</tt> to compare.\n     *\n     * @return a negative integer, zero, or a positive integer as the first\n     *         <tt>Candidate</tt> has a lower, equal,\n     *         or greater priority than the\n     *         second.\n     */\n    public static int compareCandidates(Candidate<?> c1, Candidate<?> c2)\n    {\n        if (c1.getPriority() < c2.getPriority())\n            return 1;\n        else if (c1.getPriority() == c2.getPriority())\n            return 0;\n        else //if(c1.getPriority() > c2.getPriority())\n            return -1;\n    }\n\n    /**\n     * Compares the two <tt>Candidate</tt>s based on their priority and\n     * returns a negative integer, zero, or a positive integer as the first\n     * <tt>Candidate</tt> has a lower, equal, or greater priority than the\n     * second.\n     *\n     * @param c1 the first <tt>Candidate</tt> to compare.\n     * @param c2 the second <tt>Candidate</tt> to compare.\n     *\n     * @return a negative integer, zero, or a positive integer as the first\n     *         <tt>Candidate</tt> has a lower, equal,\n     *         or greater priority than the\n     *         second.\n     */\n    public int compare(Candidate<?> c1, Candidate<?> c2)\n    {\n        return CandidatePrioritizer.compareCandidates(c1, c2);\n    }\n\n    /**\n     * Indicates whether some other object is &quot;equal to&quot; this\n     * Comparator.  This method must obey the general contract of\n     * <tt>Object.equals(Object)</tt>.  Additionally, this method can return\n     * <tt>true</tt> <i>only</i> if the specified Object is also a\n     * comparator and it imposes the same ordering as this comparator. Thus,\n     * <code>comp1.equals(comp2)</code> implies that\n     * <tt>sgn(comp1.compare(o1, o2))==sgn(comp2.compare(o1, o2))</tt> for\n     * every object reference <tt>o1</tt> and <tt>o2</tt>.<p>\n     * <p>\n     * Note that it is <i>always</i> safe <i>not</i> to override\n     * <tt>Object.equals(Object)</tt>.  However, overriding this method may,\n     * in some cases, improve performance by allowing programs to determine\n     * that two distinct Comparators impose the same order.\n     * </p>\n     *\n     * @param obj the reference object with which to compare.\n     *\n     * @return <code>true</code> only if the specified object is also\n     *         a comparator and it imposes the same ordering as this\n     *         comparator.\n     *\n     * @see Object#equals(Object)\n     * @see Object#hashCode()\n     */\n    public boolean equals(Object obj)\n    {\n        return (obj instanceof CandidatePrioritizer);\n    }\n}", "super_interfaces": ["Comparator<Candidate<?>>"], "fields": []}, {"uris": "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair", "name": "CandidatePair", "file_path": "src/main/java/org/ice4j/ice/CandidatePair.java", "superclasses": "", "methods": ["[]CandidatePair(LocalCandidate,RemoteCandidate)", "[String]getFoundation()", "[LocalCandidate]getLocalCandidate()", "[void]setLocalCandidate(LocalCandidate)", "[RemoteCandidate]getRemoteCandidate()", "[void]setRemoteCandidate(RemoteCandidate)", "[CandidatePairState]getState()", "[void]setStateFailed()", "[void]setStateFrozen()", "[void]setStateInProgress(TransactionID)", "[void]setStateSucceeded()", "[void]setStateWaiting()", "[void]setState(CandidatePairState,TransactionID)", "[boolean]isFrozen()", "[Candidate<?>]getControllingAgentCandidate()", "[Candidate<?>]getControlledAgentCandidate()", "[void]computePriority()", "[long]getPriority()", "[int]compareTo(CandidatePair)", "[boolean]equals(Object)", "[int]hashCode()", "[String]toString()", "[String]toRedactedString()", "[String]toShortString()", "[String]toRedactedShortString()", "[Component]getParentComponent()", "[TransactionID]getConnectivityCheckTransaction()", "[void]setUseCandidateSent()", "[boolean]useCandidateSent()", "[void]setUseCandidateReceived()", "[boolean]useCandidateReceived()", "[void]nominate()", "[boolean]isNominated()", "[boolean]isValid()", "[void]validate()", "[long]getConsentFreshness()", "[void]setConsentFreshness()", "[void]setConsentFreshness(long)", "[DatagramSocket]getDatagramSocket()", "[Socket]getSocket()", "[IceSocketWrapper]getIceSocketWrapper()"], "method_uris": ["src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[]CandidatePair(LocalCandidate,RemoteCandidate)", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[String]getFoundation()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[LocalCandidate]getLocalCandidate()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setLocalCandidate(LocalCandidate)", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[RemoteCandidate]getRemoteCandidate()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setRemoteCandidate(RemoteCandidate)", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[CandidatePairState]getState()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setStateFailed()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setStateFrozen()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setStateInProgress(TransactionID)", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setStateSucceeded()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setStateWaiting()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setState(CandidatePairState,TransactionID)", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[boolean]isFrozen()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[Candidate<?>]getControllingAgentCandidate()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[Candidate<?>]getControlledAgentCandidate()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]computePriority()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[long]getPriority()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[int]compareTo(CandidatePair)", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[boolean]equals(Object)", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[int]hashCode()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[String]toString()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[String]toRedactedString()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[String]toShortString()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[String]toRedactedShortString()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[Component]getParentComponent()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[TransactionID]getConnectivityCheckTransaction()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setUseCandidateSent()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[boolean]useCandidateSent()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setUseCandidateReceived()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[boolean]useCandidateReceived()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]nominate()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[boolean]isNominated()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[boolean]isValid()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]validate()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[long]getConsentFreshness()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setConsentFreshness()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[void]setConsentFreshness(long)", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[DatagramSocket]getDatagramSocket()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[Socket]getSocket()", "src/main/java/org/ice4j/ice/CandidatePair.java.CandidatePair.[IceSocketWrapper]getIceSocketWrapper()"], "overrides": null, "attributes": [{"original_string": "    public static class PairComparator implements Comparator<CandidatePair>\n    {\n        /**\n         * Compares <tt>pair1</tt> and <tt>pair2</tt> for order. Returns a\n         * negative integer, zero, or a positive integer as <tt>pair1</tt>'s\n         * priority is greater than, equal to, or less than the one of the\n         * pair2, thus insuring that higher priority pairs will come first.\n         *\n         * @param pair1 the first <tt>CandidatePair</tt> to be compared.\n         * @param pair2 the second <tt>CandidatePair</tt> to be compared.\n         *\n         * @return  a negative integer, zero, or a positive integer as the first\n         * pair's priority priority is greater than, equal to, or less than\n         * the one of the second pair.\n         *\n         * @throws ClassCastException if the specified object's type prevents it\n         *         from being compared to this Object.\n         */\n        public int compare(CandidatePair pair1, CandidatePair pair2)\n        {\n            return pair1.compareTo(pair2);\n        }\n\n        /**\n         * Indicates whether some other object is &quot;equal to&quot; to this\n         * Comparator.  This method must obey the general contract of\n         * <tt>Object.equals(Object)</tt>.  Additionally, this method can return\n         * <tt>true</tt> <i>only</i> if the specified Object is also a\n         * comparator and it imposes the same ordering as this comparator. Thus,\n         * <code>comp1.equals(comp2)</code> implies that\n         * <tt>sgn(comp1.compare(o1,o2))==sgn(comp2.compare(o1, o2))</tt> for\n         * every object reference <tt>o1</tt> and <tt>o2</tt>.<p>\n         *\n         * Note that it is <i>always</i> safe <i>not</i> to override\n         * <tt>Object.equals(Object)</tt>.  However, overriding this method may,\n         * in some cases, improve performance by allowing programs to determine\n         * that two distinct Comparators impose the same order.\n         *\n         * @param   obj   the reference object with which to compare.\n         * @return  <code>true</code> only if the specified object is also\n         *      a comparator and it imposes the same ordering as this\n         *      comparator.\n         * @see     java.lang.Object#equals(java.lang.Object)\n         * @see java.lang.Object#hashCode()\n         */\n        @Override\n        public boolean equals(Object obj)\n        {\n            return obj instanceof PairComparator;\n        }\n    }", "definition": "    public static class PairComparator implements Comparator<CandidatePair>", "class_docstring": "\nA <tt>Comparator</tt> using the <tt>compareTo</tt> method of the\n<tt>CandidatePair</tt>\n", "name": "PairComparator", "super_interfaces": ["Comparator<CandidatePair>"], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public int compare(CandidatePair pair1, CandidatePair pair2)\n        {\n            return pair1.compareTo(pair2);\n        }", "docstring": "\nCompares <tt>pair1</tt> and <tt>pair2</tt> for order. Returns a\nnegative integer, zero, or a positive integer as <tt>pair1</tt>'s\npriority is greater than, equal to, or less than the one of the\npair2, thus insuring that higher priority pairs will come first.\n\n@param pair1 the first <tt>CandidatePair</tt> to be compared.\n@param pair2 the second <tt>CandidatePair</tt> to be compared.\n\n@return  a negative integer, zero, or a positive integer as the first\npair's priority priority is greater than, equal to, or less than\nthe one of the second pair.\n\n@throws ClassCastException if the specified object's type prevents it\n        from being compared to this Object.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "compare", "params": [{"name": "pair1", "type": "CandidatePair"}, {"name": "pair2", "type": "CandidatePair"}], "body": "        {\n            return pair1.compareTo(pair2);\n        }", "signature": "public int compare(CandidatePair pair1, CandidatePair pair2)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(Object obj)\n        {\n            return obj instanceof PairComparator;\n        }", "docstring": "\nIndicates whether some other object is &quot;equal to&quot; to this\nComparator.  This method must obey the general contract of\n<tt>Object.equals(Object)</tt>.  Additionally, this method can return\n<tt>true</tt> <i>only</i> if the specified Object is also a\ncomparator and it imposes the same ordering as this comparator. Thus,\n<code>comp1.equals(comp2)</code> implies that\n<tt>sgn(comp1.compare(o1,o2))==sgn(comp2.compare(o1, o2))</tt> for\nevery object reference <tt>o1</tt> and <tt>o2</tt>.<p>\n\nNote that it is <i>always</i> safe <i>not</i> to override\n<tt>Object.equals(Object)</tt>.  However, overriding this method may,\nin some cases, improve performance by allowing programs to determine\nthat two distinct Comparators impose the same order.\n\n@param   obj   the reference object with which to compare.\n@return  <code>true</code> only if the specified object is also\n     a comparator and it imposes the same ordering as this\n     comparator.\n@see     java.lang.Object#equals(java.lang.Object)\n@see java.lang.Object#hashCode()\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "        {\n            return obj instanceof PairComparator;\n        }", "signature": "@Override\n        public boolean equals(Object obj)"}]}], "class_docstring": "\n<tt>CandidatePair</tt>s map local to remote <tt>Candidate</tt>s so that they\ncould be added to check lists. Connectivity in ICE is always verified by\npairs: i.e. STUN packets are sent from the local candidate of a pair to the\nremote candidate of a pair. To see which pairs work, an agent schedules a\nseries of <tt>ConnectivityCheck</tt>s. Each check is a STUN request/response\ntransaction that the client will perform on a particular candidate pair by\nsending a STUN request from the local candidate to the remote candidate.\n\n@author Emil Ivov\n@author Lyubomir Marinov\n@author Boris Grozev\n", "original_string": "public class CandidatePair\n    implements Comparable<CandidatePair>\n{\n    /**\n     * The value of the <tt>consentFreshness</tt> property of\n     * <tt>CandidatePair</tt> which indicates that the time in milliseconds of\n     * the latest consent freshness confirmation is unknown.\n     */\n    public static final long CONSENT_FRESHNESS_UNKNOWN = -1;\n\n    /**\n     * The value of <tt>Math.pow(2, 32)</tt> calculated once for the purposes of\n     * optimizing performance.\n     */\n    private static final long MATH_POW_2_32 = 1L << 32;\n\n    /**\n     * A <tt>Comparator</tt> using the <tt>compareTo</tt> method of the\n     * <tt>CandidatePair</tt>.\n     */\n    public static final PairComparator comparator = new PairComparator();\n\n    /**\n     * The local candidate of this pair.\n     */\n    private LocalCandidate localCandidate;\n\n    /**\n     * The remote candidate of this pair.\n     */\n    private RemoteCandidate remoteCandidate;\n\n    /**\n     * Priority of the candidate-pair\n     */\n    private long priority;\n\n    /**\n     * A flag indicating whether we have seen an incoming check request that\n     * contained the USE-CANDIDATE attribute for this pair.\n     */\n    private boolean useCandidate = false;\n\n    /**\n     * A flag indicating whether we have sent a check request that\n     * contained the USE-CANDIDATE attribute for this pair. It is used in\n     * GTalk compatibility mode as it lacks USE-CANDIDATE.\n     */\n    private boolean useCandidateSent = false;\n\n    /**\n     * Indicates whether this <tt>CandidatePair</tt> is on any of this agent's\n     * valid pair lists.\n     */\n    private boolean isValid = false;\n\n    /**\n     * If a valid candidate pair has its nominated flag set, it means that it\n     * may be selected by ICE for sending and receiving media.\n     */\n    private boolean isNominated = false;\n\n    /**\n     * Each candidate pair has a state that is assigned once the check list\n     * for each media stream has been computed. The ICE RFC defines five\n     * potential values that the state can have and they are all represented\n     * in the <tt>CandidatePairState</tt> enumeration. The ICE spec stipulates\n     * that the first step of the state initialization process is: The agent\n     * sets all of the pairs in each check list to the Frozen state, and hence\n     * our default state.\n     */\n    private CandidatePairState state = CandidatePairState.FROZEN;\n\n    /**\n     * The {@link TransactionID} of the client transaction for a connectivity\n     * check over this pair in case it is in the\n     * {@link CandidatePairState#IN_PROGRESS} state.\n     */\n    private TransactionID connCheckTranID = null;\n\n    /**\n     * The time in milliseconds of the latest consent freshness confirmation.\n     */\n    private long consentFreshness = CONSENT_FRESHNESS_UNKNOWN;\n\n    /**\n     * Creates a <tt>CandidatePair</tt> instance mapping <tt>localCandidate</tt>\n     * to <tt>remoteCandidate</tt>.\n     *\n     * @param localCandidate the local candidate of the pair.\n     * @param remoteCandidate the remote candidate of the pair.\n     */\n    public CandidatePair(LocalCandidate localCandidate,\n                         RemoteCandidate remoteCandidate)\n    {\n        this.localCandidate = localCandidate;\n        this.remoteCandidate = remoteCandidate;\n\n        computePriority();\n    }\n\n    /**\n     * Returns the foundation of this <tt>CandidatePair</tt>. The foundation\n     * of a <tt>CandidatePair</tt> is just the concatenation of the foundations\n     * of its two candidates. Initially, only the candidate pairs with unique\n     * foundations are tested. The other candidate pairs are marked \"frozen\".\n     * When the connectivity checks for a candidate pair succeed, the other\n     * candidate pairs with the same foundation are unfrozen. This avoids\n     * repeated checking of components which are superficially more attractive\n     * but in fact are likely to fail.\n     *\n     * @return the foundation of this candidate pair, which is a concatenation\n     * of the foundations of the remote and local candidates.\n     */\n    public String getFoundation()\n    {\n        return localCandidate.getFoundation()\n            + remoteCandidate.getFoundation();\n    }\n\n    /**\n     * Returns the <tt>LocalCandidate</tt> of this <tt>CandidatePair</tt>.\n     *\n     * @return the local <tt>Candidate</tt> of this <tt>CandidatePair</tt>.\n     */\n    public LocalCandidate getLocalCandidate()\n    {\n        return localCandidate;\n    }\n\n    /**\n     * Sets the <tt>LocalCandidate</tt> of this <tt>CandidatePair</tt>.\n     *\n     * @param localCnd the local <tt>Candidate</tt> of this\n     * <tt>CandidatePair</tt>.\n     */\n    protected void setLocalCandidate(LocalCandidate localCnd)\n    {\n        this.localCandidate = localCnd;\n    }\n\n    /**\n     * Returns the remote candidate of this <tt>CandidatePair</tt>.\n     *\n     * @return the remote <tt>Candidate</tt> of this <tt>CandidatePair</tt>.\n     */\n    public RemoteCandidate getRemoteCandidate()\n    {\n        return remoteCandidate;\n    }\n\n    /**\n     * Sets the <tt>RemoteCandidate</tt> of this <tt>CandidatePair</tt>.\n     *\n     * @param remoteCnd the local <tt>Candidate</tt> of this\n     * <tt>CandidatePair</tt>.\n     */\n    protected void setRemoteCandidate(RemoteCandidate remoteCnd)\n    {\n        this.remoteCandidate = remoteCnd;\n    }\n\n    /**\n     * Returns the state of this <tt>CandidatePair</tt>. Each candidate pair has\n     * a state that is assigned once the check list for each media stream has\n     * been computed. The ICE RFC defines five potential values that the state\n     * can have. They are represented here with the <tt>CandidatePairState</tt>\n     * enumeration.\n     *\n     * @return the <tt>CandidatePairState</tt> that this candidate pair is\n     * currently in.\n     */\n    public CandidatePairState getState()\n    {\n        return state;\n    }\n\n    /**\n     * Sets the <tt>CandidatePairState</tt> of this pair to\n     * {@link CandidatePairState#FAILED}. This method should only be called by\n     * the ICE agent, during the execution of the ICE procedures.\n     */\n    public void setStateFailed()\n    {\n        setState(CandidatePairState.FAILED, null);\n    }\n\n    /**\n     * Sets the <tt>CandidatePairState</tt> of this pair to\n     * {@link CandidatePairState#FROZEN}. This method should only be called by\n     * the ICE agent, during the execution of the ICE procedures.\n     */\n    public void setStateFrozen()\n    {\n        setState(CandidatePairState.FROZEN, null);\n    }\n\n    /**\n     * Sets the <tt>CandidatePairState</tt> of this pair to\n     * {@link CandidatePairState#FROZEN}. This method should only be called by\n     * the ICE agent, during the execution of the ICE procedures.\n     *\n     * @param tranID the {@link TransactionID} that we are using for the\n     * connectivity check in case we are entering the <tt>In-Progress</tt>\n     * state and <tt>null</tt> otherwise.\n     */\n    public void setStateInProgress(TransactionID tranID)\n    {\n        setState(CandidatePairState.IN_PROGRESS, tranID);\n    }\n\n    /**\n     * Sets the <tt>CandidatePairState</tt> of this pair to\n     * {@link CandidatePairState#SUCCEEDED}. This method should only be called\n     * by the ICE agent, during the execution of the ICE procedures.\n     */\n    public void setStateSucceeded()\n    {\n        setState(CandidatePairState.SUCCEEDED, null);\n    }\n\n    /**\n     * Sets the <tt>CandidatePairState</tt> of this pair to\n     * {@link CandidatePairState#WAITING}. This method should only be called by\n     * the ICE agent, during the execution of the ICE procedures.\n     */\n    public void setStateWaiting()\n    {\n        setState(CandidatePairState.WAITING, null);\n    }\n\n    /**\n     * Sets the <tt>CandidatePairState</tt> of this pair to <tt>state</tt>. This\n     * method should only be called by the ice agent, during the execution of\n     * the ICE procedures. Note that passing a <tt>null</tt> transaction for the\n     * {@link CandidatePairState#IN_PROGRESS} or a non-<tt>null</tt> for any\n     * other state would cause an {@link IllegalArgumentException} to be thrown.\n     *\n     * @param newState the state that this candidate pair is to enter.\n     * @param tranID the {@link TransactionID} that we are using for the\n     * connectivity check in case we are entering the <tt>In-Progress</tt>\n     * state and <tt>null</tt> otherwise.\n     *\n     * @throws IllegalArgumentException if state is {@link CandidatePairState\n     * #IN_PROGRESS} and <tt>tranID</tt> is <tt>null</tt>.\n     */\n    private synchronized void setState(CandidatePairState newState,\n                                       TransactionID      tranID)\n        throws IllegalArgumentException\n    {\n        CandidatePairState oldState = this.state;\n\n        this.state = newState;\n\n        if (newState == CandidatePairState.IN_PROGRESS)\n        {\n            if (tranID == null)\n            {\n                throw new IllegalArgumentException(\n                        \"Putting a pair into the In-Progress state MUST be\"\n                            + \" accompanied with the TransactionID of the\"\n                            + \" connectivity check.\");\n            }\n        }\n        else\n        {\n            if (tranID != null)\n            {\n                throw new IllegalArgumentException(\n                        \"How could you have a transaction for a pair that's not\"\n                            + \" in the In-Progress state?\");\n            }\n        }\n        this.connCheckTranID = tranID;\n\n        getParentComponent().getParentStream().firePairPropertyChange(\n                this,\n                IceMediaStream.PROPERTY_PAIR_STATE_CHANGED,\n                oldState,\n                newState);\n    }\n\n    /**\n     * Determines whether this candidate pair is frozen or not. Initially, only\n     * the candidate pairs with unique foundations are tested. The other\n     * candidate pairs are marked \"frozen\". When the connectivity checks for a\n     * candidate pair succeed, the other candidate pairs with the same\n     * foundation are unfrozen.\n     *\n     * @return true if this candidate pair is frozen and false otherwise.\n     */\n    public boolean isFrozen()\n    {\n        return this.getState().equals(CandidatePairState.FROZEN);\n    }\n\n    /**\n     * Returns the candidate in this pair that belongs to the controlling agent.\n     *\n     * @return a reference to the <tt>Candidate</tt> instance that comes from\n     * the controlling agent.\n     */\n    public Candidate<?> getControllingAgentCandidate()\n    {\n        return (getLocalCandidate().getParentComponent().getParentStream()\n                        .getParentAgent().isControlling())\n                    ? getLocalCandidate()\n                    : getRemoteCandidate();\n    }\n\n    /**\n     * Returns the candidate in this pair that belongs to the controlled agent.\n     *\n     * @return a reference to the <tt>Candidate</tt> instance that comes from\n     * the controlled agent.\n     */\n    public Candidate<?> getControlledAgentCandidate()\n    {\n        return (getLocalCandidate().getParentComponent().getParentStream()\n                        .getParentAgent().isControlling())\n                    ? getRemoteCandidate()\n                    : getLocalCandidate();\n    }\n\n\n    /**\n     * A candidate pair priority is computed the following way:<br>\n     * Let G be the priority for the candidate provided by the controlling\n     * agent. Let D be the priority for the candidate provided by the\n     * controlled agent. The priority for a pair is computed as:\n     * <p>\n     * <i>pair priority = 2^32*MIN(G,D) + 2*MAX(G,D) + (G&gt;D?1:0)</i>\n     * <p>\n     * This formula ensures a unique priority for each pair. Once the priority\n     * is assigned, the agent sorts the candidate pairs in decreasing order of\n     * priority. If two pairs have identical priority, the ordering amongst\n     * them is arbitrary.\n     */\n    protected void computePriority()\n    {\n        // Use g and d as local and remote candidate priority names to fit the\n        // definition in the RFC.\n        long g = getControllingAgentCandidate().getPriority();\n        long d = getControlledAgentCandidate().getPriority();\n        long min, max, expr;\n\n        if (g > d)\n        {\n            min = d;\n            max = g;\n            expr = 1L;\n        }\n        else\n        {\n            min = g;\n            max = d;\n            expr = 0L;\n        }\n\n        this.priority = MATH_POW_2_32 * min + 2 * max + expr;\n    }\n\n    /**\n     * Returns the priority of this pair.\n     *\n     * @return the priority of this pair.\n     */\n    public long getPriority()\n    {\n        return priority;\n    }\n\n    /**\n     * Compares this <tt>CandidatePair</tt> with the specified object for order.\n     * Returns a negative integer, zero, or a positive integer as this\n     * <tt>CandidatePair</tt>'s priority is greater than, equal to, or less than\n     * the one of the specified object thus insuring that higher priority pairs\n     * will come first.<p>\n     *\n     * @param   candidatePair the Object to be compared.\n     * @return  a negative integer, zero, or a positive integer as this\n     * <tt>CandidatePair</tt>'s priority is greater than, equal to, or less than\n     * the one of the specified object.\n     *\n     * @throws ClassCastException if the specified object's type prevents it\n     *         from being compared to this Object.\n     */\n    public int compareTo(CandidatePair candidatePair)\n    {\n        long thisPri = getPriority();\n        long otherPri = candidatePair.getPriority();\n\n        return (thisPri < otherPri) ? 1 : (thisPri == otherPri) ? 0 : -1;\n    }\n\n    /**\n     * Compares this <tt>CandidatePair</tt> to <tt>obj</tt> and returns\n     * <tt>true</tt> if pairs have equal local and equal remote candidates and\n     * <tt>false</tt> otherwise.\n     *\n     * @param obj the <tt>Object</tt> that we'd like to compare this pair to.\n     * @return <tt>true</tt> if pairs have equal local and equal remote\n     * candidates and <tt>false</tt> otherwise.\n     */\n    @Override\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof CandidatePair))\n            return false;\n\n        CandidatePair candidatePair = (CandidatePair) obj;\n\n        // XXX DO NOT change this method to also depend on other pair properties\n        // because ConnectivityCheckClient counts on it only using the\n        // candidates for comparisons.\n        return\n            localCandidate.equals(candidatePair.localCandidate)\n                && remoteCandidate.equals(candidatePair.remoteCandidate);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int hashCode()\n    {\n        // Even if the following hashCode algorithm has drawbacks because of it\n        // simplicity, it is better than nothing because at least it allows\n        // CandidatePair to be used as a HashMap key.\n        // XXX While localCandidate is not final, the parentComponent is\n        // supposedly effectively final.\n        return getLocalCandidate().getParentComponent().hashCode();\n    }\n\n    /**\n     * Returns a String representation of this <tt>CandidatePair</tt>.\n     *\n     * @return a String representation of the object.\n     */\n    @Override\n    public String toString()\n    {\n        return\n            \"CandidatePair (State=\" + getState() + \" Priority=\" + getPriority()\n                + \"):\\n\\tLocalCandidate=\" + getLocalCandidate()\n                + \"\\n\\tRemoteCandidate=\" + getRemoteCandidate();\n    }\n\n    /**\n     * Returns a String representation of this <tt>CandidatePair</tt>, with the remote\n     * candidate IP address redacted if redaction is enabled.\n     *\n     * @return a String representation of the object.\n     */\n    public String toRedactedString()\n    {\n        return\n                \"CandidatePair (State=\" + getState() + \" Priority=\" + getPriority()\n                        + \"):\\n\\tLocalCandidate=\" + getLocalCandidate()\n                        + \"\\n\\tRemoteCandidate=\" + getRemoteCandidate().toRedactedString();\n    }\n\n    /**\n     * Returns a short String representation of this <tt>CandidatePair</tt>.\n     *\n     * @return a short String representation of the object.\n     */\n    public String toShortString()\n    {\n        return getLocalCandidate().toShortString()\n                + \" -> \" + getRemoteCandidate().toShortString()\n                + \" (\" + getParentComponent().toShortString() + \")\";\n    }\n\n    /**\n     * Returns a short String representation of this <tt>CandidatePair</tt>,\n     * with the remote candidate IP address redacted if redaction is enabled.\n     *\n     * @return a redacted short String representation of the object.\n     */\n    public String toRedactedShortString()\n    {\n        return getLocalCandidate().toShortString()\n                + \" -> \" + getRemoteCandidate().toRedactedShortString()\n                + \" (\" + getParentComponent().toShortString() + \")\";\n    }\n\n    /**\n     * A <tt>Comparator</tt> using the <tt>compareTo</tt> method of the\n     * <tt>CandidatePair</tt>\n     */\n    public static class PairComparator implements Comparator<CandidatePair>\n    {\n        /**\n         * Compares <tt>pair1</tt> and <tt>pair2</tt> for order. Returns a\n         * negative integer, zero, or a positive integer as <tt>pair1</tt>'s\n         * priority is greater than, equal to, or less than the one of the\n         * pair2, thus insuring that higher priority pairs will come first.\n         *\n         * @param pair1 the first <tt>CandidatePair</tt> to be compared.\n         * @param pair2 the second <tt>CandidatePair</tt> to be compared.\n         *\n         * @return  a negative integer, zero, or a positive integer as the first\n         * pair's priority priority is greater than, equal to, or less than\n         * the one of the second pair.\n         *\n         * @throws ClassCastException if the specified object's type prevents it\n         *         from being compared to this Object.\n         */\n        public int compare(CandidatePair pair1, CandidatePair pair2)\n        {\n            return pair1.compareTo(pair2);\n        }\n\n        /**\n         * Indicates whether some other object is &quot;equal to&quot; to this\n         * Comparator.  This method must obey the general contract of\n         * <tt>Object.equals(Object)</tt>.  Additionally, this method can return\n         * <tt>true</tt> <i>only</i> if the specified Object is also a\n         * comparator and it imposes the same ordering as this comparator. Thus,\n         * <code>comp1.equals(comp2)</code> implies that\n         * <tt>sgn(comp1.compare(o1,o2))==sgn(comp2.compare(o1, o2))</tt> for\n         * every object reference <tt>o1</tt> and <tt>o2</tt>.<p>\n         *\n         * Note that it is <i>always</i> safe <i>not</i> to override\n         * <tt>Object.equals(Object)</tt>.  However, overriding this method may,\n         * in some cases, improve performance by allowing programs to determine\n         * that two distinct Comparators impose the same order.\n         *\n         * @param   obj   the reference object with which to compare.\n         * @return  <code>true</code> only if the specified object is also\n         *      a comparator and it imposes the same ordering as this\n         *      comparator.\n         * @see     java.lang.Object#equals(java.lang.Object)\n         * @see java.lang.Object#hashCode()\n         */\n        @Override\n        public boolean equals(Object obj)\n        {\n            return obj instanceof PairComparator;\n        }\n    }\n\n    /**\n     * Returns the <tt>Component</tt> that this pair belongs to.\n     *\n     * @return the <tt>Component</tt> that this pair belongs to.\n     */\n    public Component getParentComponent()\n    {\n        return getLocalCandidate().getParentComponent();\n    }\n\n    /**\n     * Returns the {@link TransactionID} used in the connectivity check\n     * associated with this {@link CandidatePair} when it's in the\n     * {@link CandidatePairState#IN_PROGRESS} or <tt>null</tt> if it's in\n     * any other state.\n     *\n     * @return the {@link TransactionID} used in the connectivity check\n     * associated with this {@link CandidatePair} when it's in the\n     * {@link CandidatePairState#IN_PROGRESS} or <tt>null</tt> if it's in\n     * any other state.\n     */\n    public TransactionID getConnectivityCheckTransaction()\n    {\n        return connCheckTranID;\n    }\n\n    /**\n     * Raises the <tt>useCandidateSent</tt> flag for this pair.\n     */\n    public void setUseCandidateSent()\n    {\n        this.useCandidateSent = true;\n    }\n\n    /**\n     * Returns <tt>true</tt> if someone has previously raised this pair's\n     * <tt>useCandidateSent</tt> flag and <tt>false</tt> otherwise.\n     *\n     * @return <tt>true</tt> if someone has previously raised this pair's\n     * <tt>useCandidate</tt> flag and <tt>false</tt> otherwise.\n     */\n    public boolean useCandidateSent()\n    {\n        return useCandidateSent;\n    }\n\n    /**\n     * Raises the <tt>useCandidate</tt> flag for this pair.\n     */\n    public void setUseCandidateReceived()\n    {\n        this.useCandidate = true;\n    }\n\n    /**\n     * Returns <tt>true</tt> if someone has previously raised this pair's\n     * <tt>useCandidate</tt> flag and <tt>false</tt> otherwise.\n     *\n     * @return <tt>true</tt> if someone has previously raised this pair's\n     * <tt>useCandidate</tt> flag and <tt>false</tt> otherwise.\n     */\n    public boolean useCandidateReceived()\n    {\n        return useCandidate;\n    }\n\n    /**\n     * Sets this pair's nominated flag to <tt>true</tt>. If a valid candidate\n     * pair has its nominated flag set, it means that it may be selected by ICE\n     * for sending and receiving media.\n     */\n    public void nominate()\n    {\n        this.isNominated = true;\n        getParentComponent().getParentStream().firePairPropertyChange(\n                this,\n                IceMediaStream.PROPERTY_PAIR_NOMINATED,\n                /* oldValue */ false,\n                /* newValue */ true);\n    }\n\n    /**\n     * Returns the value of this pair's nominated flag. If a valid candidate\n     * pair has its nominated flag set, it means that it may be selected by ICE\n     * for sending and receiving media.\n     *\n     * @return <tt>true</tt> if this pair has already been nominated for\n     * selection and <tt>false</tt> otherwise.\n     */\n    public boolean isNominated()\n    {\n        return this.isNominated;\n    }\n\n    /**\n     * Returns <tt>true</tt> if this pair has been confirmed by a connectivity\n     * check response and <tt>false</tt> otherwise.\n     *\n     * @return <tt>true</tt> if this pair has been confirmed by a connectivity\n     * check response and <tt>false</tt> otherwise.\n     */\n    public boolean isValid()\n    {\n        return isValid;\n    }\n\n    /**\n     * Marks this pair as valid. Should only be used internally.\n     */\n    protected void validate()\n    {\n        this.isValid = true;\n        getParentComponent().getParentStream().firePairPropertyChange(\n                this,\n                IceMediaStream.PROPERTY_PAIR_VALIDATED,\n                false,\n                true);\n    }\n\n    /**\n     * Gets the time in milliseconds of the latest consent freshness\n     * confirmation.\n     *\n     * @return the time in milliseconds of the latest consent freshness\n     * confirmation\n     */\n    public long getConsentFreshness()\n    {\n        return consentFreshness;\n    }\n\n    /**\n     * Sets the time in milliseconds of the latest consent freshness\n     * confirmation to now.\n     */\n    void setConsentFreshness()\n    {\n        setConsentFreshness(System.currentTimeMillis());\n    }\n\n    /**\n     * Sets the time in milliseconds of the latest consent freshness\n     * confirmation to a specific time.\n     *\n     * @param consentFreshness the time in milliseconds of the latest consent\n     * freshness to be set on this <tt>CandidatePair</tt>\n     */\n    void setConsentFreshness(long consentFreshness)\n    {\n        if (this.consentFreshness != consentFreshness)\n        {\n            long oldValue = this.consentFreshness;\n\n            this.consentFreshness = consentFreshness;\n\n            long newValue = this.consentFreshness;\n\n            getParentComponent().getParentStream().firePairPropertyChange(\n                    this,\n                    IceMediaStream.PROPERTY_PAIR_CONSENT_FRESHNESS_CHANGED,\n                    oldValue,\n                    newValue);\n        }\n    }\n\n    /**\n     * Returns the UDP <tt>DatagramSocket</tt> (if any) for this\n     * <tt>CandidatePair</tt>.\n     * @return the UDP <tt>DatagramSocket</tt> (if any) for this\n     * <tt>CandidatePair</tt>.\n     */\n    @Deprecated\n    public DatagramSocket getDatagramSocket()\n    {\n        IceSocketWrapper wrapper = getIceSocketWrapper();\n        return wrapper == null ? null : wrapper.getUDPSocket();\n    }\n\n    /**\n     * Returns the TCP <tt>Socket</tt> (if any) for this <tt>CandidatePair</tt>.\n     * @return the TCP <tt>Socket</tt> (if any) for this <tt>CandidatePair</tt>.\n     */\n    @Deprecated\n    public Socket getSocket()\n    {\n        return null;\n    }\n\n    /**\n     * Returns the <tt>IceSocketWrapper</tt> for this <tt>CandidatePair</tt>.\n     * @return  the <tt>IceSocketWrapper</tt> for this <tt>CandidatePair</tt>.\n     */\n    @Deprecated\n    public IceSocketWrapper getIceSocketWrapper()\n    {\n        IceSocketWrapper componentSocket\n            = getParentComponent().getSocketWrapper();\n        // If the merging socket is used, all candidate pairs just refer to the\n        // component.\n        if (componentSocket != null)\n        {\n            return getParentComponent().getSocketWrapper();\n        }\n\n        LocalCandidate localCandidate = getLocalCandidate();\n        if (localCandidate == null)\n        {\n            return null;\n        }\n\n        LocalCandidate base = localCandidate.getBase();\n        if (base != null)\n        {\n            localCandidate = base;\n        }\n\n        RemoteCandidate remoteCandidate = getRemoteCandidate();\n        if (remoteCandidate != null)\n        {\n            SocketAddress remoteAddress\n                = remoteCandidate.getTransportAddress();\n            if (remoteAddress != null)\n            {\n                return localCandidate.getCandidateIceSocketWrapper(remoteAddress);\n            }\n        }\n\n        return localCandidate.getCandidateIceSocketWrapper();\n    }\n}", "super_interfaces": ["Comparable<CandidatePair>"], "fields": [{"attribute_expression": "public static final long CONSENT_FRESHNESS_UNKNOWN = -1;", "docstring": "\nThe value of the <tt>consentFreshness</tt> property of\n<tt>CandidatePair</tt> which indicates that the time in milliseconds of\nthe latest consent freshness confirmation is unknown.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "long", "name": "CONSENT_FRESHNESS_UNKNOWN = -1", "syntax_pass": true}, {"attribute_expression": "private static final long MATH_POW_2_32 = 1L << 32;", "docstring": "\nThe value of <tt>Math.pow(2, 32)</tt> calculated once for the purposes of\noptimizing performance.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "MATH_POW_2_32 = 1L << 32", "syntax_pass": true}, {"attribute_expression": "public static final PairComparator comparator = new PairComparator();", "docstring": "\nA <tt>Comparator</tt> using the <tt>compareTo</tt> method of the\n<tt>CandidatePair</tt>.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "PairComparator", "name": "comparator = new PairComparator()", "syntax_pass": true}, {"attribute_expression": "private LocalCandidate localCandidate;", "docstring": "\nThe local candidate of this pair.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "LocalCandidate", "name": "localCandidate", "syntax_pass": true}, {"attribute_expression": "private RemoteCandidate remoteCandidate;", "docstring": "\nThe remote candidate of this pair.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RemoteCandidate", "name": "remoteCandidate", "syntax_pass": true}, {"attribute_expression": "private long priority;", "docstring": "\nPriority of the candidate-pair\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "priority", "syntax_pass": true}, {"attribute_expression": "private boolean useCandidate = false;", "docstring": "\nA flag indicating whether we have seen an incoming check request that\ncontained the USE-CANDIDATE attribute for this pair.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "useCandidate = false", "syntax_pass": true}, {"attribute_expression": "private boolean useCandidateSent = false;", "docstring": "\nA flag indicating whether we have sent a check request that\ncontained the USE-CANDIDATE attribute for this pair. It is used in\nGTalk compatibility mode as it lacks USE-CANDIDATE.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "useCandidateSent = false", "syntax_pass": true}, {"attribute_expression": "private boolean isValid = false;", "docstring": "\nIndicates whether this <tt>CandidatePair</tt> is on any of this agent's\nvalid pair lists.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "isValid = false", "syntax_pass": true}, {"attribute_expression": "private boolean isNominated = false;", "docstring": "\nIf a valid candidate pair has its nominated flag set, it means that it\nmay be selected by ICE for sending and receiving media.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "isNominated = false", "syntax_pass": true}, {"attribute_expression": "private CandidatePairState state = CandidatePairState.FROZEN;", "docstring": "\nEach candidate pair has a state that is assigned once the check list\nfor each media stream has been computed. The ICE RFC defines five\npotential values that the state can have and they are all represented\nin the <tt>CandidatePairState</tt> enumeration. The ICE spec stipulates\nthat the first step of the state initialization process is: The agent\nsets all of the pairs in each check list to the Frozen state, and hence\nour default state.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CandidatePairState", "name": "state = CandidatePairState.FROZEN", "syntax_pass": true}, {"attribute_expression": "private TransactionID connCheckTranID = null;", "docstring": "\nThe {@link TransactionID} of the client transaction for a connectivity\ncheck over this pair in case it is in the\n{@link CandidatePairState#IN_PROGRESS} state.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransactionID", "name": "connCheckTranID = null", "syntax_pass": true}, {"attribute_expression": "private long consentFreshness = CONSENT_FRESHNESS_UNKNOWN;", "docstring": "\nThe time in milliseconds of the latest consent freshness confirmation.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "consentFreshness = CONSENT_FRESHNESS_UNKNOWN", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer", "name": "ConnectivityCheckServer", "file_path": "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java", "superclasses": "", "methods": ["[]ConnectivityCheckServer(Agent)", "[boolean]isAlive()", "[void]processRequest(StunMessageEvent)", "[long]extractPriority(Request)", "[boolean]repairRoleConflict(StunMessageEvent)", "[boolean]checkLocalUserName(String)", "[byte[]]getLocalKey(String)", "[byte[]]getRemoteKey(String,String)", "[void]start()", "[void]stop()"], "method_uris": ["src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[]ConnectivityCheckServer(Agent)", "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[boolean]isAlive()", "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[void]processRequest(StunMessageEvent)", "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[long]extractPriority(Request)", "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[boolean]repairRoleConflict(StunMessageEvent)", "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[boolean]checkLocalUserName(String)", "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[byte[]]getLocalKey(String)", "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[byte[]]getRemoteKey(String,String)", "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[void]start()", "src/main/java/org/ice4j/ice/ConnectivityCheckServer.java.ConnectivityCheckServer.[void]stop()"], "overrides": null, "attributes": [], "class_docstring": "\nThe class that would be handling and responding to incoming connectivity\nchecks.\n\n@author Emil Ivov\n@author Lyubomir Marinov\n", "original_string": "class ConnectivityCheckServer\n    implements RequestListener,\n               CredentialsAuthority\n{\n    /**\n     * The agent that created us.\n     */\n    private final Agent parentAgent;\n\n    /**\n     * The indicator which determines whether this\n     * <tt>ConnectivityCheckServer</tt> is currently started.\n     */\n    private boolean started = false;\n\n    /**\n     * The <tt>StunStack </tt> that we will use for connectivity checks.\n     */\n    private final StunStack stunStack;\n\n    /**\n     * A flag that determines whether we have received a STUN request or not.\n     */\n    private boolean alive = false;\n\n    /**\n     * The {@link Logger} used by {@link ConnectivityCheckServer} instances.\n     */\n    private Logger logger;\n\n    /**\n     * Creates a new <tt>ConnectivityCheckServer</tt> setting\n     * <tt>parentAgent</tt> as the agent that will be used for retrieving\n     * information such as user fragments for example.\n     *\n     * @param parentAgent the <tt>Agent</tt> that is creating this instance.\n     */\n    public ConnectivityCheckServer(Agent parentAgent)\n    {\n        this.parentAgent = parentAgent;\n        logger = parentAgent.getLogger().createChildLogger(this.getClass().getName());\n\n        stunStack = this.parentAgent.getStunStack();\n        stunStack.getCredentialsManager().registerAuthority(this);\n\n        start();\n    }\n\n    /**\n     * Returns a boolean value indicating whether we have received a STUN\n     * request or not.\n     *\n     * Note that this should NOT be taken as an indication that the negotiation\n     * has succeeded, it merely indicates that we have received ANY STUN\n     * request, even invalid ones (e.g. with the wrong username or ufrag). It is\n     * completely unrelated/independent from the ICE spec and it's only meant to\n     * be used for debugging purposes.\n     *\n     * @return a boolean value indicating whether we have received a STUN\n     * request or not.\n     */\n    boolean isAlive()\n    {\n        return alive;\n    }\n\n    /**\n     * Handles the {@link Request} delivered in <tt>evt</tt> by possibly\n     * queuing a triggered check and sending a success or an error response\n     * depending on how processing goes.\n     *\n     * @param evt the {@link StunMessageEvent} containing the {@link Request}\n     * that we need to process.\n     *\n     * @throws IllegalArgumentException if the request is malformed and the\n     * stack needs to reply with a 400 Bad Request response.\n     */\n    public void processRequest(StunMessageEvent evt)\n        throws IllegalArgumentException\n    {\n        logger.trace(() -> \"Received request \" + evt);\n\n        alive = true;\n\n        Request request = (Request)evt.getMessage();\n\n        //ignore incoming requests that are not meant for the local user.\n        //normally the stack will get rid of faulty user names but we could\n        //still see messages not meant for this server if both peers or running\n        //on this same instance of the stack.\n        UsernameAttribute uname = (UsernameAttribute)request\n            .getAttribute(Attribute.USERNAME);\n\n        if ( uname == null\n            || !checkLocalUserName(new String(uname.getUsername())))\n        {\n            return;\n        }\n\n        //detect role conflicts\n        if ( ( parentAgent.isControlling()\n                    && request.containsAttribute(Attribute.ICE_CONTROLLING))\n            || ( ! parentAgent.isControlling()\n                        && request.containsAttribute(Attribute.ICE_CONTROLLED)))\n        {\n            if (!repairRoleConflict(evt))\n                return;\n        }\n\n        long priority = 0;\n        boolean useCandidate\n            = request.containsAttribute(Attribute.USE_CANDIDATE);\n        String username = new String(uname.getUsername());\n        //caller gave us the entire username.\n        String remoteUfrag = null;\n        String localUFrag = null;\n\n        priority = extractPriority(request);\n        int colon = username.indexOf(\":\");\n        remoteUfrag = username.substring(0, colon);\n\n        //tell our address handler we saw a new remote address;\n        boolean respond = parentAgent.incomingCheckReceived(evt.getRemoteAddress(),\n                evt.getLocalAddress(), priority, remoteUfrag, localUFrag,\n                useCandidate);\n\n        Response response;\n\n        if (respond)\n        {\n            response = MessageFactory.createBindingResponse(request, evt.getRemoteAddress());\n        }\n        else\n        {\n            response = MessageFactory.createBindingErrorResponse(\n                    ErrorCodeAttribute.FORBIDDEN,\n                    \"Cannot add new remote candidates in current ICE state\");\n        }\n\n        /* add USERNAME and MESSAGE-INTEGRITY attribute in the response */\n\n        /* The responses utilize the same usernames and passwords as the\n         * requests\n         */\n        Attribute usernameAttribute =\n            AttributeFactory.createUsernameAttribute(uname.getUsername());\n        response.putAttribute(usernameAttribute);\n\n        Attribute messageIntegrityAttribute =\n            AttributeFactory.createMessageIntegrityAttribute(\n                    new String(uname.getUsername()));\n        response.putAttribute(messageIntegrityAttribute);\n\n        try\n        {\n            stunStack.sendResponse(evt.getTransactionID().getBytes(),\n                    response, evt.getLocalAddress(), evt.getRemoteAddress());\n        }\n        catch (Exception e)\n        {\n            logger.info(\"Failed to send \" + response\n                        + \" through \" + evt.getLocalAddress() + \"\\n\" +\n                        e.toString());\n            //try to trigger a 500 response although if this one failed,\n            //then chances are the 500 will fail too.\n            throw new RuntimeException(\"Failed to send a response\", e);\n        }\n    }\n\n    /**\n     * Returns the value of the {@link PriorityAttribute} in <tt>request</tt> if\n     * there is one or throws an <tt>IllegalArgumentException</tt> with the\n     * corresponding message.\n     *\n     * @param request the {@link Request} whose priority we'd like to obtain.\n     *\n     * @return the value of the {@link PriorityAttribute} in <tt>request</tt> if\n     * there is one\n     *\n     * @throws IllegalArgumentException if the request does not contain a\n     * PRIORITY attribute and the stack needs to respond with a 400 Bad Request\n     * {@link Response}.\n     */\n    private long extractPriority(Request request)\n        throws IllegalArgumentException\n    {\n        //make sure we have a priority attribute and ignore otherwise.\n        PriorityAttribute priorityAttr\n            = (PriorityAttribute)request.getAttribute(Attribute.PRIORITY);\n\n        //apply tie-breaking\n\n        //extract priority\n        if (priorityAttr == null)\n        {\n            logger.debug(() -> \"Received a connectivity check with\"\n                    + \"no PRIORITY attribute. Discarding.\");\n\n            throw new IllegalArgumentException(\"Missing PRIORITY attribute!\");\n        }\n\n        return priorityAttr.getPriority();\n    }\n\n    /**\n     * Resolves a role conflicts by either sending a <tt>487 Role Conflict</tt>\n     * response or by changing this server's parent agent role. The method\n     * returns <tt>true</tt> if the role conflict is silently resolved and\n     * processing can continue. It returns <tt>false</tt> if we had to reply\n     * with a 487 and processing needs to stop until a repaired request is\n     * received.\n     *\n     * @param evt the {@link StunMessageEvent} containing the\n     * <tt>ICE-CONTROLLING</tt> or <tt>ICE-CONTROLLED</tt> attribute that\n     * allowed us to detect the role conflict.\n     *\n     * @return <tt>true</tt> if the role conflict is silently resolved and\n     * processing can continue and <tt>false</tt> otherwise.\n     */\n    private boolean repairRoleConflict(StunMessageEvent evt)\n    {\n        final Message req = evt.getMessage();\n        final boolean selfIceControlling = parentAgent.isControlling();\n\n        // If the agent is in the controlling role, and the\n        // ICE-CONTROLLING attribute is present in the request:\n        final boolean bothControllingConflict = selfIceControlling &&\n            req.containsAttribute(Attribute.ICE_CONTROLLING);\n\n        // If the agent is in the controlled role, and the ICE-CONTROLLED\n        // attribute is present in the request:\n        final boolean bothControlledConflict = !selfIceControlling &&\n            req.containsAttribute(Attribute.ICE_CONTROLLED);\n\n        if (!(bothControllingConflict || bothControlledConflict))\n        {\n            // we don't have a role conflict\n            return true;\n        }\n\n        final long selfTieBreaker = parentAgent.getTieBreaker();\n\n        final IceControlAttribute theirIceControl = bothControllingConflict\n            ? (IceControlAttribute)req.getAttribute(Attribute.ICE_CONTROLLING)\n            : (IceControlAttribute)req.getAttribute(Attribute.ICE_CONTROLLED);\n\n        final long theirTieBreaker = theirIceControl.getTieBreaker();\n\n        // If the agent's tie-breaker is larger than or equal to the\n        // contents of the ICE control attribute, the agent generates\n        // a Binding error response and includes an ERROR-CODE attribute\n        // with a value of 487 (Role Conflict) but retains its role.\n        if (Long.compareUnsigned(selfTieBreaker, theirTieBreaker) >= 0)\n        {\n            final UsernameAttribute requestUserName = (UsernameAttribute)req\n                .getAttribute(Attribute.USERNAME);\n\n            final Response response =\n                MessageFactory.createBindingErrorResponse(\n                    ErrorCodeAttribute.ROLE_CONFLICT);\n\n            final Attribute messageIntegrityAttribute =\n                AttributeFactory.createMessageIntegrityAttribute(\n                    new String(requestUserName.getUsername()));\n            response.putAttribute(messageIntegrityAttribute);\n\n            try\n            {\n                stunStack.sendResponse(\n                    evt.getTransactionID().getBytes(),\n                    response,\n                    evt.getLocalAddress(),\n                    evt.getRemoteAddress());\n                return false;\n            }\n            catch(Exception exc)\n            {\n                //rethrow so that we would send a 500 response instead.\n                throw new RuntimeException(\"Failed to send a 487\", exc);\n            }\n        }\n        //If the agent's tie-breaker is less than the contents of the\n        //ICE control attribute, the agent toggles its ICE control role.\n        else\n        {\n            final String selfNextControlState\n                = selfIceControlling ? \"controlled\" : \"controlling\";\n            logger.trace(() ->\n                \"Switching to \" + selfNextControlState + \" because \" +\n                \" theirTieBreaker= \" + theirTieBreaker + \" and \" +\n                \"selfTieBreaker= \" + selfTieBreaker);\n            parentAgent.setControlling(!selfIceControlling);\n            return true;\n        }\n    }\n\n    /**\n     * Verifies whether <tt>username</tt> is currently known to this server\n     * and returns <tt>true</tt> if so. Returns <tt>false</tt> otherwise.\n     *\n     * @param username the user name whose validity we'd like to check.\n     *\n     * @return <tt>true</tt> if <tt>username</tt> is known to this\n     * <tt>ConnectivityCheckServer</tt> and <tt>false</tt> otherwise.\n     */\n    public boolean checkLocalUserName(String username)\n    {\n        String ufrag = null;\n\n        int colon = username.indexOf(\":\");\n\n        if (colon < 0)\n        {\n            //caller gave us a ufrag\n            ufrag = username;\n        }\n        else\n        {\n            //caller gave us the entire username.\n            ufrag = username.substring(0, colon);\n        }\n\n        return ufrag.equals(parentAgent.getLocalUfrag());\n    }\n\n    /**\n     * Implements the {@link CredentialsAuthority#getLocalKey(String)} method in\n     * a way that would return this handler's parent agent password if\n     * <tt>username</tt> is either the local ufrag or the username that the\n     * agent's remote peer was expected to use.\n     *\n     * @param username the local ufrag that we should return a password for.\n     *\n     * @return this handler's parent agent local password if <tt>username</tt>\n     * equals the local ufrag and <tt>null</tt> otherwise.\n     */\n    public byte[] getLocalKey(String username)\n    {\n        return\n            checkLocalUserName(username)\n                ? parentAgent.getLocalPassword().getBytes()\n                : null;\n    }\n\n    /**\n     * Implements the {@link CredentialsAuthority#getRemoteKey(String, String)}\n     * method in a way that would return this handler's parent agent remote\n     * password if <tt>username</tt> is either the remote ufrag or the username\n     * that we are expected to use when querying the remote peer.\n     *\n     * @param username the remote ufrag that we should return a password for.\n     * @param media the media name that we want to get remote key.\n     *\n     * @return this handler's parent agent remote password if <tt>username</tt>\n     * equals the remote ufrag and <tt>null</tt> otherwise.\n     */\n    public byte[] getRemoteKey(String username, String media)\n    {\n        IceMediaStream stream = parentAgent.getStream(media);\n        if (stream == null)\n        {\n            return null;\n        }\n\n        //support both the case where username is the local fragment or the\n        //entire user name.\n        int colon = username.indexOf(\":\");\n\n        if (colon < 0)\n        {\n            //caller gave us a ufrag\n            if (username.equals(stream.getRemoteUfrag()))\n                return stream.getRemotePassword().getBytes();\n        }\n        else\n        {\n            //caller gave us the entire username.\n            if (username.equals(parentAgent.generateLocalUserName(media)))\n            {\n                if (stream.getRemotePassword() != null)\n                    return stream.getRemotePassword().getBytes();\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Starts this <tt>ConnectivityCheckServer</tt>. If it is not currently\n     * running, does nothing.\n     */\n    public void start()\n    {\n        if (!started)\n        {\n            stunStack.addRequestListener(this);\n            started = true;\n        }\n    }\n\n    /**\n     * Stops this <tt>ConnectivityCheckServer</tt>. A stopped\n     * <tt>ConnectivityCheckServer</tt> can be restarted by calling\n     * {@link #start()} on it.\n     */\n    public void stop()\n    {\n        stunStack.removeRequestListener(this);\n        started = false;\n    }\n}", "super_interfaces": ["RequestListener", "CredentialsAuthority"], "fields": [{"attribute_expression": "private final Agent parentAgent;", "docstring": "\nThe agent that created us.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Agent", "name": "parentAgent", "syntax_pass": true}, {"attribute_expression": "private boolean started = false;", "docstring": "\nThe indicator which determines whether this\n<tt>ConnectivityCheckServer</tt> is currently started.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "started = false", "syntax_pass": true}, {"attribute_expression": "private final StunStack stunStack;", "docstring": "\nThe <tt>StunStack </tt> that we will use for connectivity checks.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StunStack", "name": "stunStack", "syntax_pass": true}, {"attribute_expression": "private boolean alive = false;", "docstring": "\nA flag that determines whether we have received a STUN request or not.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "alive = false", "syntax_pass": true}, {"attribute_expression": "private Logger logger;", "docstring": "\nThe {@link Logger} used by {@link ConnectivityCheckServer} instances.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Logger", "name": "logger", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/Agent.java.Agent", "name": "Agent", "file_path": "src/main/java/org/ice4j/ice/Agent.java", "superclasses": "", "methods": ["[]Agent()", "[]Agent(Logger)", "[]Agent(String,Logger)", "[void]setTieBreaker(long)", "[IceMediaStream]createMediaStream(String)", "[Component]createComponent(IceMediaStream,int,int,int)", "[Component]createComponent(IceMediaStream,int,int,int,KeepAliveStrategy)", "[Component]createComponent(IceMediaStream,int,int,int,KeepAliveStrategy,boolean)", "[Component]createComponent(IceMediaStream,KeepAliveStrategy,boolean)", "[CandidatePair]createCandidatePair(LocalCandidate,RemoteCandidate)", "[void]setUseDynamicPorts(boolean)", "[void]gatherCandidates(Component,int,int,int)", "[void]startCandidateTrickle(TrickleCallback)", "[void]startConnectivityEstablishment()", "[void]pruneNonMatchedStreams()", "[boolean]isStarted()", "[boolean]isOver()", "[IceProcessingState]getState()", "[void]addStateChangeListener(PropertyChangeListener)", "[void]removeStateChangeListener(PropertyChangeListener)", "[void]fireStateChange(IceProcessingState,IceProcessingState)", "[boolean]setState(IceProcessingState)", "[void]initCheckLists()", "[void]addCandidateHarvester(CandidateHarvester)", "[CandidateHarvesterSet]getHarvesters()", "[String]getLocalUfrag()", "[String]getLocalPassword()", "[String]generateLocalUserName(String)", "[String]generateRemoteUserName(String)", "[String]generateLocalUserName(RemoteCandidate,LocalCandidate)", "[String]generateRemoteUserName(RemoteCandidate,LocalCandidate)", "[String]generateUserName(Candidate<?>,Candidate<?>)", "[FoundationsRegistry]getFoundationsRegistry()", "[IceMediaStream]getStream(String)", "[List<String>]getStreamNames()", "[List<IceMediaStream>]getStreams()", "[int]getStreamCount()", "[List<IceMediaStream>]getStreamsWithPendingConnectivityEstablishment()", "[StunStack]getStunStack()", "[void]setStunStack(StunStack)", "[int]getActiveCheckListCount()", "[String]toString()", "[long]getTieBreaker()", "[void]setControlling(boolean)", "[void]removeStream(IceMediaStream)", "[boolean]isControlling()", "[LocalCandidate]findLocalCandidate(TransportAddress)", "[LocalCandidate]findLocalCandidate(TransportAddress,LocalCandidate)", "[RemoteCandidate]findRemoteCandidate(TransportAddress)", "[CandidatePair]findCandidatePair(TransportAddress,TransportAddress)", "[CandidatePair]findCandidatePair(String,String)", "[boolean]incomingCheckReceived(TransportAddress,TransportAddress,long,String,String,boolean)", "[boolean]triggerCheck(CandidatePair)", "[void]validatePair(CandidatePair)", "[void]nominate(CandidatePair)", "[NominationStrategy]getNominationStrategy()", "[void]setNominationStrategy(NominationStrategy)", "[void]nominationConfirmed(CandidatePair)", "[void]checkListStatesUpdated()", "[void]logCandTypes()", "[int]countHostCandidates()", "[void]setTa(long)", "[long]calculateTa()", "[long]calculateStunHarvestRTO()", "[long]calculateStunConnCheckRTO()", "[void]scheduleTermination()", "[void]scheduleStunKeepAlive()", "[void]terminate(IceProcessingState)", "[String]ensureIceAttributeLength(String,int,int)", "[void]finalize()", "[void]free()", "[int]getGeneration()", "[void]setGeneration(int)", "[CandidatePair]getSelectedPair(String)", "[LocalCandidate]getSelectedLocalCandidate(String)", "[RemoteCandidate]getSelectedRemoteCandidate(String)", "[boolean]isTrickling()", "[void]setTrickling(boolean)", "[long]getHarvestingTime(String)", "[int]getHarvestCount(String)", "[long]getTotalHarvestingTime()", "[int]getHarvestCount()", "[boolean]getPerformConsentFreshness()", "[void]setPerformConsentFreshness(boolean)", "[void]setLoggingLevel(Level)", "[Level]getLoggingLevel()", "[Logger]getLogger()"], "method_uris": ["src/main/java/org/ice4j/ice/Agent.java.Agent.[]Agent()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[]Agent(Logger)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[]Agent(String,Logger)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setTieBreaker(long)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[IceMediaStream]createMediaStream(String)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[Component]createComponent(IceMediaStream,int,int,int)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[Component]createComponent(IceMediaStream,int,int,int,KeepAliveStrategy)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[Component]createComponent(IceMediaStream,int,int,int,KeepAliveStrategy,boolean)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[Component]createComponent(IceMediaStream,KeepAliveStrategy,boolean)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[CandidatePair]createCandidatePair(LocalCandidate,RemoteCandidate)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setUseDynamicPorts(boolean)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]gatherCandidates(Component,int,int,int)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]startCandidateTrickle(TrickleCallback)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]startConnectivityEstablishment()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]pruneNonMatchedStreams()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]isStarted()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]isOver()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[IceProcessingState]getState()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]addStateChangeListener(PropertyChangeListener)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]removeStateChangeListener(PropertyChangeListener)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]fireStateChange(IceProcessingState,IceProcessingState)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]setState(IceProcessingState)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]initCheckLists()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]addCandidateHarvester(CandidateHarvester)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[CandidateHarvesterSet]getHarvesters()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]getLocalUfrag()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]getLocalPassword()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]generateLocalUserName(String)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]generateRemoteUserName(String)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]generateLocalUserName(RemoteCandidate,LocalCandidate)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]generateRemoteUserName(RemoteCandidate,LocalCandidate)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]generateUserName(Candidate<?>,Candidate<?>)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[FoundationsRegistry]getFoundationsRegistry()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[IceMediaStream]getStream(String)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[List<String>]getStreamNames()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[List<IceMediaStream>]getStreams()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[int]getStreamCount()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[List<IceMediaStream>]getStreamsWithPendingConnectivityEstablishment()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[StunStack]getStunStack()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setStunStack(StunStack)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[int]getActiveCheckListCount()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]toString()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[long]getTieBreaker()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setControlling(boolean)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]removeStream(IceMediaStream)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]isControlling()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[LocalCandidate]findLocalCandidate(TransportAddress)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[LocalCandidate]findLocalCandidate(TransportAddress,LocalCandidate)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[RemoteCandidate]findRemoteCandidate(TransportAddress)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[CandidatePair]findCandidatePair(TransportAddress,TransportAddress)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[CandidatePair]findCandidatePair(String,String)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]incomingCheckReceived(TransportAddress,TransportAddress,long,String,String,boolean)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]triggerCheck(CandidatePair)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]validatePair(CandidatePair)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]nominate(CandidatePair)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[NominationStrategy]getNominationStrategy()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setNominationStrategy(NominationStrategy)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]nominationConfirmed(CandidatePair)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]checkListStatesUpdated()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]logCandTypes()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[int]countHostCandidates()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setTa(long)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[long]calculateTa()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[long]calculateStunHarvestRTO()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[long]calculateStunConnCheckRTO()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]scheduleTermination()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]scheduleStunKeepAlive()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]terminate(IceProcessingState)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[String]ensureIceAttributeLength(String,int,int)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]finalize()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]free()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[int]getGeneration()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setGeneration(int)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[CandidatePair]getSelectedPair(String)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[LocalCandidate]getSelectedLocalCandidate(String)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[RemoteCandidate]getSelectedRemoteCandidate(String)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]isTrickling()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setTrickling(boolean)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[long]getHarvestingTime(String)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[int]getHarvestCount(String)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[long]getTotalHarvestingTime()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[int]getHarvestCount()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[boolean]getPerformConsentFreshness()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setPerformConsentFreshness(boolean)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[void]setLoggingLevel(Level)", "src/main/java/org/ice4j/ice/Agent.java.Agent.[Level]getLoggingLevel()", "src/main/java/org/ice4j/ice/Agent.java.Agent.[Logger]getLogger()"], "overrides": null, "attributes": [{"original_string": "    private final class StunKeepAliveRunner extends PeriodicRunnable\n    {\n        private final long consentFreshnessInterval = config.getConsentFreshnessInterval().toMillis();\n        private final int originalConsentFreshnessWaitInterval\n                = (int) config.getConsentFreshnessOriginalWaitInterval().toMillis();\n\n        private final int maxConsentFreshnessWaitInterval\n                = (int) config.getConsentFreshnessMaxWaitInterval().toMillis();\n\n        private final int consentFreshnessMaxRetransmissions = config.getMaxConsentFreshnessRetransmissions();\n\n        private int keepAliveSent = 0;\n\n        StunKeepAliveRunner()\n        {\n            super(agentTasksScheduler, agentTasksExecutor);\n        }\n\n        @Override\n        protected Duration getDelayUntilNextRun()\n        {\n            if (shouldRunStunKeepAlive())\n            {\n                if (keepAliveSent == 0)\n                {\n                    return Duration.ZERO;\n                }\n                else\n                {\n                    double r = 1;\n                    if (config.getRandomizeConsentFreshnessInterval())\n                    {\n                        r = 0.8d + ThreadLocalRandom.current().nextDouble() * 0.4;\n                    }\n                    return Duration.ofMillis((long) (consentFreshnessInterval * r));\n                }\n            }\n            return Duration.ofMillis(-1);\n        }\n\n        @Override\n        protected void run()\n        {\n            try\n            {\n                sendKeepAlive();\n            }\n            catch (Exception e)\n            {\n                logger.warn(\"Error while sending keep alive\", e);\n            }\n        }\n\n        private void sendKeepAlive()\n        {\n            ++keepAliveSent;\n\n            for (IceMediaStream stream : getStreams())\n            {\n                for (Component component : stream.getComponents())\n                {\n                    for (CandidatePair pair : component.getKeepAlivePairs())\n                    {\n                        if (pair != null)\n                        {\n                            if (performConsentFreshness)\n                            {\n                                connCheckClient.startCheckForPair(\n                                    pair,\n                                    originalConsentFreshnessWaitInterval,\n                                    maxConsentFreshnessWaitInterval,\n                                    consentFreshnessMaxRetransmissions);\n                            }\n                            else\n                            {\n                                connCheckClient\n                                    .sendBindingIndicationForPair(pair);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Determines whether {@link #stunKeepAliveRunner} should run.\n         *\n         * @return <tt>true</tt> if <tt>{@link #stunKeepAliveRunner}</tt>\n         * should run otherwise, <tt>false</tt>\n         */\n        boolean shouldRunStunKeepAlive()\n        {\n            IceProcessingState state = Agent.this.state;\n\n            return\n                (IceProcessingState.COMPLETED.equals(state)\n                    || IceProcessingState.TERMINATED.equals(state))\n                    && !shutdown;\n        }\n    }", "definition": "    private final class StunKeepAliveRunner extends PeriodicRunnable", "class_docstring": "\nA class to schedule and perform Stun keep-alive checks\n", "name": "StunKeepAliveRunner", "super_interfaces": [], "superclasses": "PeriodicRunnable", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private final long consentFreshnessInterval = config.getConsentFreshnessInterval().toMillis();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "long", "name": "consentFreshnessInterval = config.getConsentFreshnessInterval().toMillis()", "syntax_pass": true}, {"attribute_expression": "private final int originalConsentFreshnessWaitInterval\n                = (int) config.getConsentFreshnessOriginalWaitInterval().toMillis();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "originalConsentFreshnessWaitInterval\n                = (int) config.getConsentFreshnessOriginalWaitInterval().toMillis()", "syntax_pass": true}, {"attribute_expression": "private final int maxConsentFreshnessWaitInterval\n                = (int) config.getConsentFreshnessMaxWaitInterval().toMillis();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "maxConsentFreshnessWaitInterval\n                = (int) config.getConsentFreshnessMaxWaitInterval().toMillis()", "syntax_pass": true}, {"attribute_expression": "private final int consentFreshnessMaxRetransmissions = config.getMaxConsentFreshnessRetransmissions();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "consentFreshnessMaxRetransmissions = config.getMaxConsentFreshnessRetransmissions()", "syntax_pass": true}, {"attribute_expression": "private int keepAliveSent = 0;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "keepAliveSent = 0", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        StunKeepAliveRunner()\n        {\n            super(agentTasksScheduler, agentTasksExecutor);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "StunKeepAliveRunner", "params": [], "body": "        {\n            super(agentTasksScheduler, agentTasksExecutor);\n        }", "signature": "StunKeepAliveRunner()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected Duration getDelayUntilNextRun()\n        {\n            if (shouldRunStunKeepAlive())\n            {\n                if (keepAliveSent == 0)\n                {\n                    return Duration.ZERO;\n                }\n                else\n                {\n                    double r = 1;\n                    if (config.getRandomizeConsentFreshnessInterval())\n                    {\n                        r = 0.8d + ThreadLocalRandom.current().nextDouble() * 0.4;\n                    }\n                    return Duration.ofMillis((long) (consentFreshnessInterval * r));\n                }\n            }\n            return Duration.ofMillis(-1);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Duration", "classes": []}, "name": "getDelayUntilNextRun", "params": [], "body": "        {\n            if (shouldRunStunKeepAlive())\n            {\n                if (keepAliveSent == 0)\n                {\n                    return Duration.ZERO;\n                }\n                else\n                {\n                    double r = 1;\n                    if (config.getRandomizeConsentFreshnessInterval())\n                    {\n                        r = 0.8d + ThreadLocalRandom.current().nextDouble() * 0.4;\n                    }\n                    return Duration.ofMillis((long) (consentFreshnessInterval * r));\n                }\n            }\n            return Duration.ofMillis(-1);\n        }", "signature": "@Override\n        protected Duration getDelayUntilNextRun()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected void run()\n        {\n            try\n            {\n                sendKeepAlive();\n            }\n            catch (Exception e)\n            {\n                logger.warn(\"Error while sending keep alive\", e);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "run", "params": [], "body": "        {\n            try\n            {\n                sendKeepAlive();\n            }\n            catch (Exception e)\n            {\n                logger.warn(\"Error while sending keep alive\", e);\n            }\n        }", "signature": "@Override\n        protected void run()"}, {"syntax_pass": true, "original_string": "        private void sendKeepAlive()\n        {\n            ++keepAliveSent;\n\n            for (IceMediaStream stream : getStreams())\n            {\n                for (Component component : stream.getComponents())\n                {\n                    for (CandidatePair pair : component.getKeepAlivePairs())\n                    {\n                        if (pair != null)\n                        {\n                            if (performConsentFreshness)\n                            {\n                                connCheckClient.startCheckForPair(\n                                    pair,\n                                    originalConsentFreshnessWaitInterval,\n                                    maxConsentFreshnessWaitInterval,\n                                    consentFreshnessMaxRetransmissions);\n                            }\n                            else\n                            {\n                                connCheckClient\n                                    .sendBindingIndicationForPair(pair);\n                            }\n                        }\n                    }\n                }\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "sendKeepAlive", "params": [], "body": "        {\n            ++keepAliveSent;\n\n            for (IceMediaStream stream : getStreams())\n            {\n                for (Component component : stream.getComponents())\n                {\n                    for (CandidatePair pair : component.getKeepAlivePairs())\n                    {\n                        if (pair != null)\n                        {\n                            if (performConsentFreshness)\n                            {\n                                connCheckClient.startCheckForPair(\n                                    pair,\n                                    originalConsentFreshnessWaitInterval,\n                                    maxConsentFreshnessWaitInterval,\n                                    consentFreshnessMaxRetransmissions);\n                            }\n                            else\n                            {\n                                connCheckClient\n                                    .sendBindingIndicationForPair(pair);\n                            }\n                        }\n                    }\n                }\n            }\n        }", "signature": "private void sendKeepAlive()"}, {"syntax_pass": true, "original_string": "        boolean shouldRunStunKeepAlive()\n        {\n            IceProcessingState state = Agent.this.state;\n\n            return\n                (IceProcessingState.COMPLETED.equals(state)\n                    || IceProcessingState.TERMINATED.equals(state))\n                    && !shutdown;\n        }", "docstring": "\nDetermines whether {@link #stunKeepAliveRunner} should run.\n\n@return <tt>true</tt> if <tt>{@link #stunKeepAliveRunner}</tt>\nshould run otherwise, <tt>false</tt>\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "shouldRunStunKeepAlive", "params": [], "body": "        {\n            IceProcessingState state = Agent.this.state;\n\n            return\n                (IceProcessingState.COMPLETED.equals(state)\n                    || IceProcessingState.TERMINATED.equals(state))\n                    && !shutdown;\n        }", "signature": "boolean shouldRunStunKeepAlive()"}]}], "class_docstring": "\nAn <tt>Agent</tt> could be described as the main class (i.e. the chef\nd'orchestre) of an ICE implementation.\n<p>\nAs defined in RFC 3264, an agent is the protocol implementation involved in\nthe offer/answer exchange. There are two agents involved in an offer/answer\nexchange.\n</p>\n<p>\n<b>Note</b>: An <tt>Agent</tt> instance should be explicitly prepared for\ngarbage collection by calling {@link #free()} on it if timely freeing of the\nassociated resources is of importance; otherwise, it will wait for the\ngarbage collector to call {@link #finalize()} on it.\n</p>\n\n@author Emil Ivov\n@author Lyubomir Marinov\n@author Sebastien Vincent\n@author Aakash Garg\n@author Boris Grozev\n", "original_string": "public class Agent\n{\n    /**\n     * The constant which defines an empty array with element type\n     * <tt>PropertyChangeListener</tt> and represents the fact that there are no\n     * <tt>IceProcessingState</tt> change listeners added to an <tt>Agent</tt>\n     * (using {@link #addStateChangeListener(PropertyChangeListener)}.\n     */\n    private static final PropertyChangeListener[] NO_STATE_CHANGE_LISTENERS\n        = new PropertyChangeListener[0];\n\n    /**\n     * The name of the {@link PropertyChangeEvent} that we use to deliver\n     * events on changes in the state of ICE processing in this agent.\n     */\n    public static final String PROPERTY_ICE_PROCESSING_STATE\n                                            = \"IceProcessingState\";\n\n    /**\n     *  The ScheduledExecutorService to execute Agent's scheduled tasks\n     */\n    private static final ScheduledExecutorService agentTasksScheduler\n        = ExecutorFactory.createSingleThreadScheduledExecutor(\n            \"ice4j.Agent-timer-\", 60, TimeUnit.SECONDS);\n\n    /**\n     *  The ExecutorService to execute Agent's tasks\n     */\n    private static final ExecutorService agentTasksExecutor\n        = Executors.newCachedThreadPool(\n            new CustomizableThreadFactory(\"ice4j.Agent-executor-\", true));\n\n    /**\n     * Termination task which will be scheduled with timeout\n     */\n    private final Runnable terminationRunnable = new Runnable()\n    {\n        @Override\n        public void run()\n        {\n            terminate(IceProcessingState.TERMINATED);\n            synchronized (terminationFutureSyncRoot)\n            {\n                terminationFuture = null;\n            }\n        }\n    };\n\n    /**\n     * An instance to schedule STUN checks for selected pair.\n     */\n    private final StunKeepAliveRunner stunKeepAliveRunner\n        = new StunKeepAliveRunner();\n\n    /**\n     * The LinkedHashMap used to store the media streams\n     * This map preserves the insertion order of the media streams.\n     */\n    private final Map<String, IceMediaStream> mediaStreams\n        = new LinkedHashMap<>();\n\n    /**\n     * The candidate harvester that we use to gather candidate on the local\n     * machine.\n     */\n    private final HostCandidateHarvester hostCandidateHarvester\n                                                = new HostCandidateHarvester();\n\n    /**\n     * A list of additional <tt>CandidateHarvester</tt>s which will be used to\n     * harvest candidates synchronously, and previously to harvesting by\n     * {@link #harvesters}.\n     */\n    private final List<CandidateHarvester> hostHarvesters = new LinkedList<>();\n\n    /**\n     * The set of harvesters (i.e. STUN, TURN, and others) that the agent should\n     * use when gathering candidates for components.\n     */\n    private final CandidateHarvesterSet harvesters\n        = new CandidateHarvesterSet();\n\n    /**\n     * Manages statistics about harvesting time.\n     */\n//    private final HarvestStatistics harvestStats = new HarvestStatistics();\n\n    /**\n     * We use the <tt>FoundationsRegistry</tt> to keep track of the foundations\n     * we assign within a session (i.e. the entire life time of an\n     * <tt>Agent</tt>)\n     */\n    private final FoundationsRegistry foundationsRegistry\n                                          = new FoundationsRegistry();\n\n    /**\n     * Our internal nominator implementing several nomination strategies.\n     */\n    private final DefaultNominator nominator;\n\n    /**\n     * The value of <tt>Ta</tt> as specified by the application or <tt>-1</tt>\n     * if non was specified and we should calculate one ourselves.\n     */\n    private long taValue = -1;\n\n    /**\n     * The <tt>List</tt> of remote addresses that we have discovered through\n     * incoming connectivity checks, before actually receiving a session\n     * description from the peer and that may potentially contain peer reflexive\n     * addresses. This list is stored only if and while connectivity checks\n     * are not running. Once they start, we are able to determine whether the\n     * addresses in here are actually peer-reflexive or not, and schedule\n     * the necessary triggered checks.\n     */\n    private final List<CandidatePair> preDiscoveredPairsQueue\n        = new LinkedList<>();\n\n    /**\n     * The lock that we use while starting connectivity establishment.\n     */\n    private final Object startLock = new Object();\n\n    /**\n     * The user fragment that we should use for the ice-ufrag attribute.\n     */\n    private final String ufrag;\n\n    /**\n     * The password that we should use for the ice-pwd attribute.\n     */\n    private final String password;\n\n    /**\n     * The tie-breaker number is used in connectivity checks to detect and\n     * repair the case where both agents believe to have the controlling or the\n     * controlled role.\n     */\n    private long tieBreaker;\n\n    /**\n     * Determines whether this agent has a controlling role in an ICE interaction.\n     */\n    private boolean isControlling = true;\n\n    /**\n     * The entity that will be taking care of outgoing connectivity checks.\n     */\n    private final ConnectivityCheckClient connCheckClient;\n\n    /**\n     * The entity that will be taking care of incoming connectivity checks.\n     */\n    private final ConnectivityCheckServer connCheckServer;\n\n    /**\n     * Indicates the state of ICE processing in this <tt>Agent</tt>. An\n     * <tt>Agent</tt> is in the Waiting state until it has both sent and\n     * received candidate lists and started connectivity establishment. The\n     * difference between the Waiting and the Running states is important in\n     * cases like determining whether a remote address we've just discovered is\n     * peer reflexive or not. If iceStarted is true and we don't know about the\n     * address then we should add it to the list of candidates. Otherwise\n     * we should wait for the remote party to send their media description\n     * before being able to determine.\n     */\n    private IceProcessingState state = IceProcessingState.WAITING;\n\n    /**\n     * Object used to synchronize access to {@link #state}.\n     */\n    private final Object stateSyncRoot = new Object();\n\n    /**\n     * Contains {@link PropertyChangeListener}s registered with this {@link\n     * Agent} and following its changes of state.\n     */\n    private final List<PropertyChangeListener> stateListeners\n        = new LinkedList<>();\n\n    /**\n     * The <tt>StunStack</tt> used by this <tt>Agent</tt>.\n     */\n    private StunStack stunStack;\n\n    /**\n     * The scheduled task to terminate this <tt>Agent</tt>\n     */\n    private ScheduledFuture<?> terminationFuture;\n\n    /**\n     * The object used to synchronize access to {@link #terminationFuture}.\n     */\n    private final Object terminationFutureSyncRoot = new Object();\n\n    /**\n     * Some protocols, such as XMPP, need to be able to distinguish the separate\n     * ICE sessions that occur as a result of ICE restarts, which is why we need\n     * to keep track of generations. A generation is an index, starting at 0,\n     * that enables the parties to keep track of updates to the candidate\n     * throughout the life of the session.\n     */\n    private int generation = 0;\n\n    /**\n     * Determines whether this agent should perform trickling.\n     */\n    private boolean trickle = false;\n\n    /**\n     * Indicates that ICE will be shutdown.\n     */\n    private boolean shutdown = false;\n\n    /**\n     * Indicates that harvesting has been started at least once. Used to warn\n     * users who are trying to trickle, that they have already completed a\n     * harvest. We may use it to throw an exception at some point if it's ever\n     * a problem.\n     */\n    private boolean harvestingStarted = false;\n\n    /**\n     * The indicator which determines whether this <tt>Agent</tt> is to perform\n     * consent freshness.\n     */\n    private boolean performConsentFreshness = false;\n\n    /**\n     * The {@link Logger} used by {@link Agent} instances.\n     */\n    private final Logger logger;\n\n    /**\n     * Whether this {@link Agent} should use dynamic ports. Can be overridden via {@link #setUseDynamicPorts(boolean)}.\n     */\n    private boolean useDynamicPorts = HarvestConfig.config.useDynamicPorts();\n\n    /**\n     * Creates an empty <tt>Agent</tt> with no streams, and no address.\n     */\n    public Agent()\n    {\n        this(null, null);\n    }\n\n    public Agent(Logger parentLogger)\n    {\n        this(null, parentLogger);\n    }\n\n    /**\n     * Creates an empty <tt>Agent</tt> with no streams, and no address.\n     * @param ufragPrefix an optional prefix to the generated local ICE username\n     * fragment.\n     */\n    public Agent(String ufragPrefix, Logger parentLogger)\n    {\n        SecureRandom random = new SecureRandom();\n\n        String ufrag = ufragPrefix == null ? \"\" : ufragPrefix;\n        ufrag += new BigInteger(24, random).toString(32);\n        ufrag += BigInteger.valueOf(System.currentTimeMillis()).toString(32);\n        ufrag = ensureIceAttributeLength(ufrag, /* min */ 4, /* max */ 256);\n        this.ufrag = ufrag;\n        if (parentLogger != null)\n        {\n\n            logger = parentLogger.createChildLogger(\n                    this.getClass().getName(),\n                    Collections.singletonMap(\"ufrag\", this.ufrag));\n        }\n        else\n        {\n            logger = new LoggerImpl(Agent.class.getName(), new LogContext(\"ufrag\", this.ufrag));\n        }\n\n        connCheckServer = new ConnectivityCheckServer(this);\n        connCheckClient = new ConnectivityCheckClient(\n            this, agentTasksScheduler, agentTasksExecutor);\n\n        //add the FINGERPRINT attribute to all messages.\n        System.setProperty(StackProperties.ALWAYS_SIGN, \"true\");\n\n        password\n            = ensureIceAttributeLength(\n                    new BigInteger(128, random).toString(32),\n                    /* min */ 22, /* max */ 256);\n\n        tieBreaker = random.nextLong() & 0x7FFFFFFFFFFFFFFFL;\n        nominator = new DefaultNominator(this);\n\n        for (MappingCandidateHarvester harvester\n                    : MappingCandidateHarvesters.getHarvesters())\n        {\n            addCandidateHarvester(harvester);\n        }\n\n        logger.debug(() -> \"Created a new Agent: \" + this.toString() +\n            \" with ICE controlling role = \" + this.isControlling);\n    }\n\n    /**\n     * Sets the tie breaker value. Note that to this should be set early (before\n     * connectivity checks start).\n     * @param tieBreakerInput the value to set.\n     */\n    public void setTieBreaker(long tieBreakerInput)\n    {\n        tieBreaker = tieBreakerInput;\n    }\n\n    /**\n     * Creates a new media stream and stores it.\n     *\n     * @param mediaStreamName the name of the media stream\n     *\n     * @return the newly created and stored <tt>IceMediaStream</tt>\n     */\n    public IceMediaStream createMediaStream(String mediaStreamName)\n    {\n        logger.debug(() -> \"Create media stream for \" + mediaStreamName);\n\n        IceMediaStream mediaStream\n            = new IceMediaStream(Agent.this, mediaStreamName);\n\n        mediaStreams.put(mediaStreamName, mediaStream);\n\n        // Since we add a new stream, we must wait to add the component and the\n        // remote candidates before starting to \"RUN\" this Agent.\n        // This is useful if this Agent is already in COMPLETED state\n        // (isStarted() == true) due to a previous successful ICE procedure:\n        // this way incoming connectivity checks are registered in the\n        // preDiscoveredPairsQueue until this Agent is in RUNNING state.\n        this.setState(IceProcessingState.WAITING);\n\n        return mediaStream;\n    }\n\n    /**\n     * Creates a new {@link Component} for the specified <tt>stream</tt> and\n     * allocates potentially all local candidates that should belong to it.\n     *\n     * @param stream the {@link IceMediaStream} that the new {@link Component}\n     * should belong to.\n     * @param preferredPort the port number that should be tried first when\n     * binding local <tt>Candidate</tt> sockets for this <tt>Component</tt>.\n     * @param minPort the port number where we should first try to bind before\n     * moving to the next one (i.e. <tt>minPort + 1</tt>)\n     * @param maxPort the maximum port number where we should try binding\n     * before giving up and throwing an exception.\n     *\n     * @return the newly created {@link Component} and with a list containing\n     * all and only local candidates.\n     *\n     * @throws IllegalArgumentException if either <tt>minPort</tt> or\n     * <tt>maxPort</tt> is not a valid port number or if <tt>minPort &gt;\n     * maxPort</tt>, or if <tt>transport</tt> is not currently supported.\n     * @throws IOException if an error occurs while the underlying resolver lib\n     * is using sockets.\n     * @throws BindException if we couldn't find a free port between\n     * <tt>minPort</tt> and <tt>maxPort</tt> before reaching the maximum allowed\n     * number of retries.\n     */\n    public Component createComponent(\n            IceMediaStream stream,\n            int preferredPort,\n            int minPort,\n            int maxPort)\n        throws IllegalArgumentException,\n               IOException,\n                BindException\n    {\n        return createComponent(\n                stream,\n                preferredPort, minPort, maxPort,\n                KeepAliveStrategy.SELECTED_ONLY,\n                config.getUseComponentSocket());\n    }\n\n    /**\n     * Creates a new {@link Component} for the specified <tt>stream</tt> and\n     * allocates potentially all local candidates that should belong to it.\n     *\n     * @param stream the {@link IceMediaStream} that the new {@link Component}\n     * should belong to.\n     * @param preferredPort the port number that should be tried first when\n     * binding local <tt>Candidate</tt> sockets for this <tt>Component</tt>.\n     * @param minPort the port number where we should first try to bind before\n     * moving to the next one (i.e. <tt>minPort + 1</tt>)\n     * @param maxPort the maximum port number where we should try binding\n     * before giving up and throwing an exception.\n     * @param keepAliveStrategy the keep-alive strategy, which dictates which\n     * candidates pairs are going to be kept alive.\n     *\n     * @return the newly created {@link Component} and with a list containing\n     * all and only local candidates.\n     *\n     * @throws IllegalArgumentException if either <tt>minPort</tt> or\n     * <tt>maxPort</tt> is not a valid port number or if <tt>minPort &gt;\n     * maxPort</tt>, or if <tt>transport</tt> is not currently supported.\n     * @throws IOException if an error occurs while the underlying resolver lib\n     * is using sockets.\n     * @throws BindException if we couldn't find a free port between\n     * <tt>minPort</tt> and <tt>maxPort</tt> before reaching the maximum allowed\n     * number of retries.\n     */\n    public Component createComponent(\n        IceMediaStream stream,\n        int preferredPort,\n        int minPort,\n        int maxPort,\n        KeepAliveStrategy keepAliveStrategy)\n        throws IllegalArgumentException,\n               IOException,\n               BindException\n    {\n        return createComponent(\n            stream,\n            preferredPort,\n            minPort,\n            maxPort,\n            keepAliveStrategy,\n            true);\n    }\n\n    /**\n     * Creates a new {@link Component} for the specified <tt>stream</tt> and\n     * allocates potentially all local candidates that should belong to it.\n     *\n     * If 0, 0, 0 are specified for preferred, min and max port, an ephemeral port will be used instead.\n     *\n     * @param stream the {@link IceMediaStream} that the new {@link Component}\n     * should belong to.\n     * @param preferredPort the port number that should be tried first when\n     * binding local <tt>Candidate</tt> sockets for this <tt>Component</tt>.\n     * @param minPort the port number where we should first try to bind before\n     * moving to the next one (i.e. <tt>minPort + 1</tt>)\n     * @param maxPort the maximum port number where we should try binding\n     * before giving up and throwing an exception.\n     * @param keepAliveStrategy the keep-alive strategy, which dictates which\n     * candidates pairs are going to be kept alive.\n     * @param useComponentSocket whether to use the component socket mode (in\n     * which case the socket is available through the {@link Component} directly),\n     * or not (in which case the socket is available through the selected\n     * {@link CandidatePair}).\n     *\n     * @return the newly created {@link Component} and with a list containing\n     * all and only local candidates.\n     *\n     * @throws IllegalArgumentException if either <tt>minPort</tt> or\n     * <tt>maxPort</tt> is not a valid port number or if <tt>minPort &gt;\n     * maxPort</tt>, or if <tt>transport</tt> is not currently supported.\n     * @throws IOException if an error occurs while the underlying resolver lib\n     * is using sockets.\n     * @throws BindException if we couldn't find a free port between\n     * <tt>minPort</tt> and <tt>maxPort</tt> before reaching the maximum allowed\n     * number of retries.\n     */\n    public Component createComponent(\n        IceMediaStream stream,\n        int preferredPort,\n        int minPort,\n        int maxPort,\n        KeepAliveStrategy keepAliveStrategy,\n        boolean useComponentSocket)\n        throws IllegalArgumentException,\n               IOException,\n               BindException\n    {\n        Component component = stream.createComponent(keepAliveStrategy, useComponentSocket);\n\n        gatherCandidates(component, preferredPort, minPort, maxPort);\n\n        /*\n         * Lyubomir: After we've gathered the LocalCandidate for a Component and\n         * before we've made them available to the caller, we have to make sure\n         * that the ConnectivityCheckServer is started. If there's been a\n         * previous connectivity establishment which has completed, it has\n         * stopped the ConnectivityCheckServer. If the ConnectivityCheckServer is\n         * not started after we've made the gathered LocalCandidates available\n         * to the caller, the caller may send them and a connectivity check may\n         * arrive from the remote Agent.\n         */\n        connCheckServer.start();\n\n        return component;\n    }\n\n    /**\n     * Creates a new {@link Component} for the specified {@code stream} and allocates potentially all local\n     * candidates that should belong to it.\n     *\n     * If dynamic ports are enabled, an ephemeral port will be used.\n     *\n     * @param stream the {@link IceMediaStream} that the new {@link Component} should belong to.\n     * @param keepAliveStrategy the keep-alive strategy, which dictates which\n     * candidates pairs are going to be kept alive.\n     * @param useComponentSocket whether to use the component socket mode (in\n     * which case the socket is available through the {@link Component} directly),\n     * or not (in which case the socket is available through the selected {@link CandidatePair}).\n     *\n     * @return the newly created {@link Component} and with a list containing all and only local candidates.\n     * @throws IOException if an error occurs while the underlying resolver lib is using sockets.\n     */\n    public Component createComponent(\n            IceMediaStream stream,\n            KeepAliveStrategy keepAliveStrategy,\n            boolean useComponentSocket)\n            throws IllegalArgumentException, IOException\n    {\n        return createComponent(stream, 0, 0, 0, keepAliveStrategy, useComponentSocket);\n    }\n\n    /**\n     * Initializes a new {@link CandidatePair} instance from a\n     * {@link LocalCandidate} and a {@link RemoteCandidate}. The method\n     * represents a {@code CandidatePair} factory and is preferable to\n     * explicitly calling the {@code CandidatePair} constructor because it\n     * allows this {@code Agent} to easily track the initialization of its\n     * {@code CandidatePair}s.\n     *\n     * @param local the {@code LocalCandidate} to initialize the new instance\n     * with\n     * @param remote the {@code RemoteCandidate} to initialize the new instance\n     * with\n     * @return a new {@code CandidatePair} instance initializes with\n     * {@code local} and {@code remote}\n     */\n    protected CandidatePair createCandidatePair(\n            LocalCandidate local,\n            RemoteCandidate remote)\n    {\n        return new CandidatePair(local, remote);\n    }\n\n    /**\n     * Sets the flag for whether this {@link Agent} instance should use dynamic ports.\n     */\n    public void setUseDynamicPorts(boolean value)\n    {\n        useDynamicPorts = value;\n    }\n\n    /**\n     * Uses all <tt>CandidateHarvester</tt>s currently registered with this\n     * <tt>Agent</tt> to obtain whatever addresses they can discover.\n     * <p>\n     * Not that the method would only use existing harvesters so make sure\n     * you've registered all harvesters that you would want to use before\n     * calling it.\n     * </p>\n     * If 0, 0, 0 are specified for preferred, min and max port, an ephemeral port will be used instead.\n     *\n     * @param component the <tt>Component</tt> that we'd like to gather\n     * candidates for.\n     * @param preferredPort the port number that should be tried first when\n     * binding local <tt>Candidate</tt> sockets for this <tt>Component</tt>.\n     * @param minPort the port number where we should first try to bind before\n     * moving to the next one (i.e. <tt>minPort + 1</tt>)\n     * @param maxPort the maximum port number where we should try binding\n     * before giving up and throwing an exception.\n     *\n     * @throws IllegalArgumentException if either <tt>minPort</tt> or\n     * <tt>maxPort</tt> is not a valid port number or if <tt>minPort &gt;\n     * maxPort</tt>.\n     * @throws IOException if an error occurs while the underlying resolver lib\n     * is gathering candidates and we end up without even a single one.\n     */\n    private void gatherCandidates( Component      component,\n                                   int            preferredPort,\n                                   int            minPort,\n                                   int            maxPort)\n        throws IllegalArgumentException,\n               IOException\n    {\n        logger.info(\"Gathering candidates for component \" +\n                component.toShortString() +\".\");\n\n        if (useDynamicPorts)\n        {\n            hostCandidateHarvester.harvest(component, preferredPort, minPort, maxPort, Transport.UDP);\n        }\n        else\n        {\n            if (hostHarvesters.isEmpty())\n                logger.warn(\"No host harvesters available!\");\n        }\n\n        for (CandidateHarvester harvester : hostHarvesters)\n        {\n            harvester.harvest(component);\n        }\n\n        if (component.getLocalCandidateCount() == 0)\n            logger.warn(\"Failed to gather any host candidates!\");\n\n        //in case we are not trickling, apply other harvesters here\n        if (!isTrickling())\n        {\n            harvestingStarted = true; //raise a flag to warn on a second call.\n            harvesters.harvest(component);\n        }\n\n        logger.debug(() -> \"Candidate count in first harvest: \" +\n            component.getLocalCandidateCount());\n\n        // Emil: Because of trickle, we now assign foundations, compute\n        // priorities, and eliminate redundancies while adding candidates on a\n        // component. This means that we no longer need to do it here, where we\n        // did before.\n        //computeFoundations(component);\n        //component.prioritizeCandidates();\n        //component.eliminateRedundantCandidates();\n\n        //select the candidate to put in the media line.\n        component.selectDefaultCandidate();\n    }\n\n    /**\n     * Starts an asynchronous(?) harvest across all components and reports newly\n     * discovered candidates to <tt>trickleCallback</tt>.\n     *\n     * @param trickleCallback the callback that will be notified for all newly\n     * discovered candidates.\n     *\n     * @throws IllegalStateException if we try calling this method without being\n     * in a trickling state.\n     */\n    public void startCandidateTrickle(TrickleCallback trickleCallback)\n        throws IllegalStateException\n    {\n        if (!isTrickling())\n        {\n            throw new IllegalStateException(\n                \"Trying to start trickling without enabling it on the agent!\");\n        }\n\n        if (harvestingStarted)\n        {\n            logger.warn(\n                \"Hmmm ... why are you harvesting twice? You shouldn't be!\");\n        }\n\n        //create a list of components and start harvesting\n        List<Component> components = new LinkedList<>();\n\n        for (IceMediaStream stream : getStreams())\n        {\n            components.addAll(stream.getComponents());\n        }\n\n        harvesters.harvest(components, trickleCallback);\n\n        //tell the tricklers that we are done (the WebRTC way, with null):\n        trickleCallback.onIceCandidates(null);\n    }\n\n    /**\n     * Initializes all stream check lists and begins the checks.\n     */\n    public void startConnectivityEstablishment()\n    {\n        synchronized(startLock)\n        {\n            logger.info(\"Start ICE connectivity establishment.\");\n            shutdown = false;\n            pruneNonMatchedStreams();\n\n            try\n            {\n                initCheckLists();\n            }\n            catch(ArithmeticException e)\n            {\n                setState(IceProcessingState.FAILED);\n                return;\n            }\n\n            //change state before we actually send checks so that we don't\n            //miss responses and hence the possibility to nominate a pair.\n            setState(IceProcessingState.RUNNING);\n\n            //if we have received connectivity checks before RUNNING state,\n            //trigger a check for those candidate pairs.\n            if (this.preDiscoveredPairsQueue.size() > 0)\n            {\n                logger.info(\n                        \"Trigger checks for pairs that were received before \"\n                            + \"running state\");\n\n                for (CandidatePair cp : preDiscoveredPairsQueue)\n                {\n                    triggerCheck(cp);\n                }\n\n                preDiscoveredPairsQueue.clear();\n            }\n\n            connCheckClient.startChecks();\n        }\n    }\n\n    /**\n     * <tt>Free()</tt>s and removes from this agent components or entire streams\n     * if they do not contain remote candidates. A possible reason for this\n     * could be the fact that the remote party canceled some of the streams or\n     * that it is using rtcp-mux or bundle.\n     */\n    private void pruneNonMatchedStreams()\n    {\n        // The previous behavior allows users of ice4j to run an Agent with\n        // remote candidates for only some of the streams/components, in which\n        // case the component without remote candidates are removed here, and\n        // so they do not cause an ICE failure if they fail to connect.\n        // In order to allow operation without remote candidates, we only prune\n        // if we detect that there is at least one component with some remote\n        // candidates.\n        boolean prune = false;\n        for (IceMediaStream stream : getStreams())\n        {\n            for (Component component : stream.getComponents())\n            {\n                if (component.getRemoteCandidateCount() > 0)\n                    prune = true;\n                if (prune)\n                    break;\n            }\n        }\n\n        if (prune)\n        {\n            for (IceMediaStream stream : getStreams())\n            {\n                for (Component component : stream.getComponents())\n                {\n                    if (component.getRemoteCandidateCount() == 0)\n                        stream.removeComponent(component);\n                }\n\n                if (stream.getComponentCount() == 0)\n                    removeStream(stream);\n            }\n        }\n    }\n\n    /**\n     * Indicates whether this {@link Agent} is currently in the process of\n     * running connectivity checks and establishing connectivity. Connectivity\n     * establishment is considered to have started after both {@link Agent}s\n     * have exchanged their media descriptions. Determining whether the actual\n     * process has started is important, for example, when determining whether\n     * a remote address we've just discovered is peer reflexive or not.\n     * If ICE has started and we don't know about the address then we should\n     * add it to the list of candidates. Otherwise we should hold to it until\n     * it does and check later.\n     * <p>\n     * Note that an {@link Agent} would be ready to and will send responses to\n     * connectivity checks as soon as it streams get created, which is well\n     * before we actually start the checks.\n     *\n     * @return <tt>true</tt> after media descriptions have been exchanged both\n     * ways and connectivity checks have started (regardless of their current\n     * state) and <tt>false</tt> otherwise.\n     */\n    public boolean isStarted()\n    {\n        return state != IceProcessingState.WAITING\n            && state != IceProcessingState.COMPLETED\n            && state != IceProcessingState.TERMINATED;\n    }\n\n    /**\n     * Indicates whether this {@link Agent} has finished ICE processing.\n     *\n     * @return <tt>true</tt> if ICE processing is in the {@link\n     * IceProcessingState#FAILED}, {@link IceProcessingState#COMPLETED} or\n     * {@link IceProcessingState#TERMINATED} and <tt>false</tt> otherwise.\n     */\n    public boolean isOver()\n    {\n        IceProcessingState state = getState();\n\n        return (state != null) && state.isOver();\n    }\n\n    /**\n     * Returns the state of ICE processing for this <tt>Agent</tt>.\n     *\n     * @return the state of ICE processing for this <tt>Agent</tt>.\n     */\n    public IceProcessingState getState()\n    {\n        return state;\n    }\n\n    /**\n     * Adds <tt>l</tt> to the list of listeners tracking changes of the\n     * {@link IceProcessingState} of this <tt>Agent</tt>\n     *\n     * @param l the listener to register.\n     */\n    public void addStateChangeListener(PropertyChangeListener l)\n    {\n        synchronized (stateListeners)\n        {\n            if (!stateListeners.contains(l))\n                stateListeners.add(l);\n        }\n    }\n\n    /**\n     * Removes <tt>l</tt> from the list of listeners tracking changes of the\n     * {@link IceProcessingState} of this <tt>Agent</tt>\n     *\n     * @param l the listener to remove.\n     */\n    public void removeStateChangeListener(PropertyChangeListener l)\n    {\n        synchronized (stateListeners)\n        {\n            stateListeners.remove(l);\n        }\n    }\n\n    /**\n     * Creates a new {@link PropertyChangeEvent} and delivers it to all\n     * currently registered state listeners.\n     *\n     * @param oldState the {@link IceProcessingState} we had before the change\n     * @param newState the {@link IceProcessingState} we had after the change\n     */\n    private void fireStateChange(IceProcessingState oldState,\n                                 IceProcessingState newState)\n    {\n        PropertyChangeListener[] stateListenersCopy;\n\n        synchronized (stateListeners)\n        {\n            stateListenersCopy\n                = stateListeners.toArray(NO_STATE_CHANGE_LISTENERS);\n        }\n\n        if (stateListenersCopy.length != 0)\n        {\n            PropertyChangeEvent evt\n                = new PropertyChangeEvent(\n                        this,\n                        PROPERTY_ICE_PROCESSING_STATE,\n                        oldState, newState);\n\n            for (PropertyChangeListener l : stateListenersCopy)\n                l.propertyChange(evt);\n        }\n    }\n\n    /**\n     * Sets the {@link IceProcessingState} of this <tt>Agent</tt> to\n     * <tt>newState</tt> and triggers the corresponding change event.\n     *\n     * @param newState the new state of ICE processing for this <tt>Agent</tt>.\n     * @return <tt>true</tt> iff the state of this <tt>Agent</tt> changed as\n     * a result of this call.\n     */\n    private boolean setState(IceProcessingState newState)\n    {\n        IceProcessingState oldState;\n        synchronized (stateSyncRoot)\n        {\n            oldState = state;\n            this.state = newState;\n        }\n\n        if (!oldState.equals(newState))\n        {\n            logger.info(\"ICE state changed from \" + oldState + \" to \"\n                            + newState + \".\");\n            fireStateChange(oldState, newState);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Creates, initializes and orders the list of candidate pairs that would\n     * be used for the connectivity checks for all components in this stream.\n     */\n    protected void initCheckLists()\n    {\n        // First init the check list.\n        List<IceMediaStream> streams = getStreamsWithPendingConnectivityEstablishment();\n        int streamCount = streams.size();\n\n        if (streamCount > 0)\n        {\n            int maxCheckListSizePerStream = config.getMaxCheckListSize() / streamCount;\n\n            for (IceMediaStream stream : streams)\n            {\n                logger.info(\"Init checklist for stream \" + stream.getName());\n                stream.setMaxCheckListSize(maxCheckListSizePerStream);\n                stream.initCheckList();\n            }\n\n            // Init the states of the first media stream as per 5245\n            streams.get(0).getCheckList().computeInitialCheckListPairStates();\n        }\n    }\n\n    /**\n     * Computes and sets the foundations foundation for all <tt>Candidate</tt>s\n     * currently found in <tt>component</tt>.\n     *\n     * @param component the component whose candidate foundations we'd like to\n     * compute and assign.\n     */\n//    private void computeFoundations(Component component)\n//    {\n//        for (Candidate<?> localCandidate : component.getLocalCandidates())\n//            foundationsRegistry.assignFoundation(localCandidate);\n//    }\n\n    /**\n     * Adds <tt>harvester</tt> to the list of harvesters that this agent will\n     * use when gathering <tt>Candidate</tt>s.\n     *\n     * @param harvester a <tt>CandidateHarvester</tt> that this agent should use\n     * when gathering candidates.\n     */\n    public void addCandidateHarvester(CandidateHarvester harvester)\n    {\n        if (harvester.isHostHarvester())\n            hostHarvesters.add(harvester);\n        else\n            harvesters.add(harvester);\n    }\n\n    /**\n     * Returns the set of harvesters currently in use by this agent.\n     *\n     * @return the set of harvesters currently in use by this agent.\n     */\n    public CandidateHarvesterSet getHarvesters()\n    {\n        return harvesters;\n    }\n\n    /**\n     * Returns that user name that should be advertised in session descriptions\n     * containing ICE data from this agent.\n     *\n     * @return that user name that should be advertised in session descriptions\n     * containing ICE data from this agent.\n     */\n    public String getLocalUfrag()\n    {\n        return ufrag;\n    }\n\n    /**\n     * Returns that password that should be advertised in session descriptions\n     * containing ICE data from this agent.\n     *\n     * @return that password that should be advertised in session descriptions\n     * containing ICE data from this agent.\n     */\n    public String getLocalPassword()\n    {\n        return password;\n    }\n\n    /**\n     * Returns the user name that this <tt>Agent</tt> should use in connectivity\n     * checks for outgoing Binding Requests. According to RFC 5245, a Binding\n     * Request serving as a connectivity check MUST utilize the STUN short term\n     * credential mechanism. The username for the credential is formed by\n     * concatenating the username fragment provided by the peer with the\n     * username fragment of the agent sending the request, separated by a\n     * colon (\":\").  The password is equal to the password provided by the peer.\n     * For example, consider the case where agent L is the offerer, and agent R\n     * is the answerer.  Agent L included a username fragment of LFRAG for its\n     * candidates, and a password of LPASS.  Agent R provided a username\n     * fragment of RFRAG and a password of RPASS.  A connectivity check from L\n     * to R (and its response of course) utilize the username RFRAG:LFRAG and a\n     * password of RPASS.  A connectivity check from R to L (and its response)\n     * utilize the username LFRAG:RFRAG and a password of LPASS.\n     *\n     * @param media media name that we want to generate local username for.\n     * @return a user name that this <tt>Agent</tt> can use in connectivity\n     * check for outgoing Binding Requests.\n     */\n    public String generateLocalUserName(String media)\n    {\n        IceMediaStream stream = getStream(media);\n        String ret;\n\n        if (stream == null)\n        {\n            ret = null;\n            logger.warn(\n                    \"Agent contains no IceMediaStream with name \" + media\n                        + \"!\");\n        }\n        else\n        {\n            String remoteUfrag = stream.getRemoteUfrag();\n\n            if (remoteUfrag == null)\n            {\n                ret = null;\n                logger.warn(\n                        \"Remote ufrag of IceMediaStream with name \" + media\n                            + \" is null!\");\n            }\n            else\n            {\n                ret = remoteUfrag + \":\" + getLocalUfrag();\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Returns the user name that we should expect a peer <tt>Agent</tt> to use\n     * in connectivity checks for Binding Requests its sending our way.\n     * According to RFC 5245, a Binding Request serving as a connectivity check\n     * MUST utilize the STUN short term credential mechanism. The username for\n     * the credential is formed by concatenating the username fragment provided\n     * by the peer with the username fragment of the agent sending the request,\n     * separated by a colon (\":\").  The password is equal to the password\n     * provided by the peer. For example, consider the case where agent\n     * L is the offerer, and agent R is the answerer.  Agent L\n     * included a username fragment of LFRAG for its candidates,\n     * and a password of LPASS.  Agent R provided a username fragment\n     * of RFRAG and a password of RPASS.  A connectivity check from L\n     * to R (and its response of course) utilize the username RFRAG:LFRAG and a\n     * password of RPASS.  A connectivity check from R to L (and its response)\n     * utilize the username LFRAG:RFRAG and a password of LPASS.\n     *\n     * @param media media name that we want to generate local username for.\n     * @return a user name that a peer <tt>Agent</tt> would use in connectivity\n     * check for outgoing Binding Requests.\n     */\n    public String generateRemoteUserName(String media)\n    {\n        IceMediaStream stream = getStream(media);\n\n        return\n            (stream == null)\n                ? null\n                : (getLocalUfrag() + \":\" + stream.getRemoteUfrag());\n    }\n\n    /**\n     * Returns the user name that this <tt>Agent</tt> should use in connectivity\n     * checks for outgoing Binding Requests in a Google Talk session.\n     *\n     * @param remoteCandidate remote candidate\n     * @param localCandidate local candidate\n     * @return a user name that this <tt>Agent</tt> can use in connectivity\n     * check for outgoing Binding Requests.\n     */\n    public String generateLocalUserName(RemoteCandidate remoteCandidate,\n            LocalCandidate localCandidate)\n    {\n        return generateUserName(remoteCandidate, localCandidate);\n    }\n\n    /**\n     * Returns the user name that we should expect a peer <tt>Agent</tt> to use\n     * in connectivity checks for Binding Requests its sending our way in a\n     * Google Talk session.\n     *\n     * @param remoteCandidate remote candidate\n     * @param localCandidate local candidate\n     * @return a user name that a peer <tt>Agent</tt> would use in connectivity\n     * check for outgoing Binding Requests.\n     */\n    public String generateRemoteUserName(RemoteCandidate remoteCandidate,\n            LocalCandidate localCandidate)\n    {\n        return generateUserName(localCandidate, remoteCandidate);\n    }\n\n    /**\n     * Returns the user name that we should expect a peer <tt>Agent</tt> to use\n     * in connectivity checks for Binding Requests its sending our way in a\n     * Google Talk session.\n     *\n     * @param candidate1 The first candidate of a candidatePair.\n     * @param candidate2 The second candidate of a candidatePair.\n     * @return a user name that a peer <tt>Agent</tt> would use in connectivity\n     * check for outgoing Binding Requests.\n     */\n    private String generateUserName(\n            Candidate<?> candidate1,\n            Candidate<?> candidate2)\n    {\n        /*\n         * FIXME Are the invocations of Candidate.getUfrag() necessary for their\n         * side effects alone? For example, to make sure that neither of the\n         * Candidates is null?\n         */\n        candidate1.getUfrag();\n        candidate2.getUfrag();\n\n        return null;\n    }\n\n    /**\n     * Returns the {@link FoundationsRegistry} this agent is using to assign\n     * candidate foundations. We use the <tt>FoundationsRegistry</tt> to keep\n     * track of the foundations we assign within a session (i.e. the entire life\n     * time of an <tt>Agent</tt>)\n     * @return the {@link FoundationsRegistry} of this agent\n     */\n    public final FoundationsRegistry getFoundationsRegistry()\n    {\n        return foundationsRegistry;\n    }\n\n    /**\n     * Returns the <tt>IceMediaStream</tt> with the specified <tt>name</tt> or\n     * <tt>null</tt> if no such stream has been registered with this\n     * <tt>Agent</tt> yet.\n     *\n     * @param name the name of the stream that we'd like to obtain a reference\n     * to.\n     *\n     * @return the <tt>IceMediaStream</tt> with the specified <tt>name</tt> or\n     * <tt>null</tt> if no such stream has been registered with this\n     * <tt>Agent</tt> yet.\n     */\n    public IceMediaStream getStream(String name)\n    {\n        synchronized(mediaStreams)\n        {\n            return mediaStreams.get(name);\n        }\n    }\n\n    /**\n     * Returns a <tt>List</tt> containing the names of all currently registered\n     * media streams.\n     *\n     * @return a <tt>List</tt> containing the names of all currently registered\n     * media streams.\n     */\n    public List<String> getStreamNames()\n    {\n        synchronized(mediaStreams)\n        {\n            return new LinkedList<>(mediaStreams.keySet());\n        }\n    }\n\n    /**\n     * Returns a <tt>List</tt> containing all <tt>IceMediaStream</tt>s currently\n     * registered with this agent.\n     *\n     * @return a <tt>List</tt> containing all <tt>IceMediaStream</tt>s currently\n     * registered with this agent.\n     */\n    public List<IceMediaStream> getStreams()\n    {\n        synchronized(mediaStreams)\n        {\n            return new LinkedList<>(mediaStreams.values());\n        }\n    }\n\n    /**\n     * Returns the number of <tt>IceMediaStream</tt>s currently registered with\n     * this agent.\n     *\n     * @return  the number of <tt>IceMediaStream</tt>s currently registered with\n     * this agent.\n     *\n     */\n    public int getStreamCount()\n    {\n        synchronized(mediaStreams)\n        {\n            return mediaStreams.size();\n        }\n    }\n\n    /**\n     * Gets the <tt>IceMediaStream</tt>s registered with this <tt>Agent</tt> for\n     * which connectivity establishment is pending. For example, after a set of\n     * <tt>IceMediaStream</tt>s is registered with this <tt>Agent</tt>,\n     * connectivity establishment completes for them and then a new set of\n     * <tt>IceMediaStream</tt>s is registered with this <tt>Agent</tt>, the\n     * <tt>IceMediaStream</tt>s with pending connectivity establishment are\n     * those from the second set.\n     *\n     * @return a <tt>List</tt> of the <tt>IceMediaStream</tt>s registered with\n     * this <tt>Agent</tt> for which connectivity is pending.\n     */\n    List<IceMediaStream> getStreamsWithPendingConnectivityEstablishment()\n    {\n        /*\n         * Lyubomir: We want to support establishing connectivity for streams\n         * which have been created after connectivity has been established for\n         * previously created streams. That is why we will remove the streams\n         * which have their connectivity checks completed or failed i.e. these\n         * streams have been handled by a previous connectivity establishment.\n         */\n        List<IceMediaStream> streams = getStreams();\n        Iterator<IceMediaStream> streamIter = streams.iterator();\n\n        while (streamIter.hasNext())\n        {\n            IceMediaStream stream = streamIter.next();\n            CheckList checkList = stream.getCheckList();\n            CheckListState checkListState = checkList.getState();\n\n            if (CheckListState.COMPLETED.equals(checkListState)\n                    || CheckListState.FAILED.equals(checkListState))\n                streamIter.remove();\n        }\n        return streams;\n    }\n\n    /**\n     * Gets the <tt>StunStack</tt> used by this <tt>Agent</tt>.\n     *\n     * @return the <tt>StunStack</tt> used by this <tt>Agent</tt>\n     */\n    public synchronized StunStack getStunStack()\n    {\n        if (stunStack == null)\n            stunStack = new StunStack();\n        return stunStack;\n    }\n    \n    /**\n     * Sets the <tt>StunStack</tt> used by this <tt>Agent</tt>.\n     * \n     * @param stunStack the stunStack to be used by this Agent.\n     * \n     */\n    public void setStunStack(StunStack stunStack)\n    {\n        this.stunStack = stunStack;\n    }\n\n    /**\n     * Returns the number of {@link CheckList}s that are currently active.\n     *\n     * @return the number of {@link CheckList}s that are currently active.\n     *\n     */\n    protected int getActiveCheckListCount()\n    {\n        synchronized(mediaStreams)\n        {\n            int i=0;\n            Collection<IceMediaStream> streams = mediaStreams.values();\n\n            for (IceMediaStream stream : streams)\n            {\n                if (stream.getCheckList().isActive())\n                    i++;\n            }\n\n            return i;\n        }\n    }\n\n    /**\n     * Returns a <tt>String</tt> representation of this agent.\n     *\n     * @return a <tt>String</tt> representation of this agent.\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder(\"ICE Agent (stream-count=\");\n\n        buff.append(getStreamCount());\n        buff.append(\" ice-pwd:\").append(getLocalPassword());\n        buff.append(\" ice-ufrag:\").append(getLocalUfrag());\n        buff.append(\" tie-breaker:\").append(getTieBreaker());\n        buff.append(\"):\\n\");\n\n        for (IceMediaStream stream : getStreams())\n        {\n            buff.append(stream).append(\"\\n\");\n        }\n\n        return buff.toString();\n    }\n\n    /**\n     * Returns this agent's tie-breaker number. The tie-breaker number is used\n     * in connectivity checks to detect and repair the case where both agents\n     * believe to have the controlling or the controlled role.\n     *\n     * @return  this agent's tie-breaker number\n     */\n    public long getTieBreaker()\n    {\n        return tieBreaker;\n    }\n\n    /**\n     * Specifies whether this agent has the controlling role in an ICE exchange.\n     *\n     * @param isControlling <tt>true</tt> if this is to be the controlling\n     * <tt>Agent</tt> and <tt>false</tt> otherwise.\n     */\n    public void setControlling(boolean isControlling)\n    {\n        if (this.isControlling != isControlling)\n        {\n            this.logger.info(() -> \"Changing agent \" + this.toString() +\n                \" role from controlling = \" + this.isControlling +\n                \" to controlling = \" + isControlling);\n        }\n\n        this.isControlling = isControlling;\n\n        //in case we have already initialized our check lists we'd need to\n        //recompute pair priorities.\n        for (IceMediaStream stream : getStreams())\n        {\n            CheckList list = stream.getCheckList();\n\n            if (list != null)\n            {\n                list.recomputePairPriorities();\n            }\n        }\n    }\n\n    /**\n     * Removes <tt>stream</tt> and all its child <tt>Component</tt>s and\n     * <tt>Candidate</tt>s from the this agent and releases all resources that\n     * they had allocated (like sockets for example)\n     *\n     * @param stream the <tt>Component</tt> we'd like to remove and free.\n     */\n    public void removeStream(IceMediaStream stream)\n    {\n        synchronized (mediaStreams)\n        {\n            mediaStreams.remove(stream.getName());\n        }\n        /*\n         * XXX The invocation of IceMediaStream#free() on stream has been moved\n         * out of the synchronized block in order to reduce the chances of a\n         * deadlock. There was no obvious reason why it should stay in the\n         * synchronized block at the time of the modification.\n         */\n        stream.free();\n    }\n\n    /**\n     * Determines whether this agent has the controlling role in an ICE\n     * exchange.\n     *\n     * @return <tt>true</tt> if this is to be the controlling <tt>Agent</tt>\n     * and <tt>false</tt> otherwise.\n     */\n    public boolean isControlling()\n    {\n        return isControlling;\n    }\n\n    /**\n     * Returns the local <tt>LocalCandidate</tt> with the specified\n     * <tt>address</tt> if it belongs to any of this {@link Agent}'s\n     * streams or <tt>null</tt> if it doesn't.\n     *\n     * @param address the {@link TransportAddress} we are looking for.\n     *\n     * @return the local <tt>LocalCandidate</tt> with the specified\n     * <tt>address</tt> if it belongs to any of this {@link Agent}'s\n     * streams or <tt>null</tt> if it doesn't.\n     */\n    public LocalCandidate findLocalCandidate(TransportAddress address)\n    {\n        return findLocalCandidate(address, null);\n    }\n\n    /**\n     * Returns the local <tt>LocalCandidate</tt> with the specified\n     * <tt>address</tt> if it belongs to any of this {@link Agent}'s\n     * streams or <tt>null</tt> if it doesn't. If {@code base} is also specified,\n     * tries to find a candidate whose base matches {@code base}.\n     *\n     * @param address the {@link TransportAddress} we are looking for.\n     * @param base an optional base to match.\n     *\n     * @return the local <tt>LocalCandidate</tt> with the specified\n     * <tt>address</tt> if it belongs to any of this {@link Agent}'s\n     * streams or <tt>null</tt> if it doesn't.\n     */\n    public LocalCandidate findLocalCandidate(\n            TransportAddress address,\n            LocalCandidate base)\n    {\n        for (IceMediaStream stream : mediaStreams.values())\n        {\n            LocalCandidate localCandidate\n                    = stream.findLocalCandidate(address, base);\n\n            if (localCandidate != null)\n            {\n                return localCandidate;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the remote <tt>Candidate</tt> with the specified\n     * <tt>remoteAddress</tt> if it belongs to any of this {@link Agent}'s\n     * streams or <tt>null</tt> if it doesn't.\n     *\n     * @param remoteAddress the {@link TransportAddress} we are looking for.\n     *\n     * @return the remote <tt>Candidate</tt> with the specified\n     * <tt>remoteAddress</tt> if it belongs to any of this {@link Agent}'s\n     * streams or <tt>null</tt> if it doesn't.\n     */\n    public RemoteCandidate findRemoteCandidate(TransportAddress remoteAddress)\n    {\n        for (IceMediaStream stream : mediaStreams.values())\n        {\n            RemoteCandidate cnd = stream.findRemoteCandidate(remoteAddress);\n\n            if (cnd != null)\n            {\n                return cnd;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the {@link CandidatePair} with the specified remote and local\n     * addresses or <tt>null</tt> if neither of the {@link CheckList}s in this\n     * {@link Agent}'s streams contain such a pair.\n     *\n     * @param localAddress the local {@link TransportAddress} of the pair we\n     * are looking for.\n     * @param remoteAddress the remote {@link TransportAddress} of the pair we\n     * are looking for.\n     *\n     * @return the {@link CandidatePair} with the specified remote and local\n     * addresses or <tt>null</tt> if neither of the {@link CheckList}s in this\n     * {@link Agent}'s streams contain such a pair.\n     */\n    public CandidatePair findCandidatePair(TransportAddress localAddress,\n                                           TransportAddress remoteAddress)\n    {\n        synchronized(mediaStreams)\n        {\n            for (IceMediaStream stream : mediaStreams.values())\n            {\n                CandidatePair pair\n                    = stream.findCandidatePair(localAddress, remoteAddress);\n\n                if (pair != null )\n                    return pair;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Returns the {@link CandidatePair} with the specified remote and local\n     * addresses or <tt>null</tt> if neither of the {@link CheckList}s in this\n     * {@link Agent}'s streams contain such a pair.\n     *\n     * @param localUFrag local user fragment\n     * @param remoteUFrag remote user fragment\n     * @return the {@link CandidatePair} with the specified remote and local\n     * addresses or <tt>null</tt> if neither of the {@link CheckList}s in this\n     * {@link Agent}'s streams contain such a pair.\n     */\n    public CandidatePair findCandidatePair(String localUFrag,\n                                           String remoteUFrag)\n    {\n        synchronized(mediaStreams)\n        {\n            for (IceMediaStream stream : mediaStreams.values())\n            {\n                CandidatePair pair\n                    = stream.findCandidatePair(localUFrag, remoteUFrag);\n\n                if (pair != null )\n                    return pair;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Notifies the implementation that the {@link ConnectivityCheckServer} has\n     * just received a message on <tt>localAddress</tt> originating at\n     * <tt>remoteAddress</tt> carrying the specified <tt>priority</tt>. This\n     * will cause us to schedule a triggered check for the corresponding\n     * remote candidate and potentially to the discovery of a PEER-REFLEXIVE\n     * candidate.\n     *\n     * @param remoteAddress the address that we've just seen, and that is\n     * potentially a peer-reflexive address.\n     * @param localAddress the address that we were contacted on.\n     * @param priority the priority that the remote party assigned to\n     * @param remoteUFrag the user fragment that we should be using when and if\n     * we decide to send a check to <tt>remoteAddress</tt>.\n     * @param localUFrag local user fragment\n     * @param useCandidate indicates whether the incoming check\n     * {@link org.ice4j.message.Request} contained the USE-CANDIDATE ICE\n     * attribute.\n     * @return Whether the response to the check should get a success response\n     */\n    protected boolean incomingCheckReceived(TransportAddress remoteAddress,\n                                         TransportAddress localAddress,\n                                         long             priority,\n                                         String           remoteUFrag,\n                                         String           localUFrag,\n                                         boolean          useCandidate)\n    {\n        String ufrag = null;\n        LocalCandidate localCandidate = findLocalCandidate(localAddress);\n\n        if (localCandidate == null)\n        {\n            logger.info(\"No localAddress for this incoming checks: \" +\n                    localAddress);\n            return false;\n        }\n\n        Component parentComponent = localCandidate.getParentComponent();\n        RemoteCandidate remoteCandidate\n            = new RemoteCandidate(\n                remoteAddress,\n                parentComponent,\n                CandidateType.PEER_REFLEXIVE_CANDIDATE,\n                foundationsRegistry.obtainFoundationForPeerReflexiveCandidate(),\n                priority,\n                // We can not know the related candidate of a remote peer\n                // reflexive candidate. We must set it to \"null\".\n                null,\n                ufrag);\n\n        CandidatePair triggeredPair\n            = createCandidatePair(localCandidate, remoteCandidate);\n\n        logger.debug(() -> \"set use-candidate \" + useCandidate + \" for pair \" +\n            triggeredPair.toRedactedShortString());\n        if (useCandidate)\n        {\n            triggeredPair.setUseCandidateReceived();\n        }\n\n        synchronized(startLock)\n        {\n            if (state == IceProcessingState.WAITING)\n            {\n                logger.debug(() -> \"Receive STUN checks before our ICE has started\");\n                //we are not started yet so we'd better wait until we get the\n                //remote candidates in case we are holding to a new PR one.\n                this.preDiscoveredPairsQueue.add(triggeredPair);\n            }\n            else if (state == IceProcessingState.FAILED)\n            {\n                // Failure is permanent, currently.\n            }\n            else //Running, Connected or Terminated.\n            {\n                logger.debug(() -> \"Received check from \"\n                    + triggeredPair.toRedactedShortString() + \" triggered a check.\");\n\n                // We have been started, and have not failed (yet). If this is\n                // a new pair, handle it (even if we have already completed).\n                return triggerCheck(triggeredPair);\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Either queues a triggered check for <tt>triggeredPair</tt> or, in case\n     * there's already a pair with the specified remote and local addresses,\n     * puts it in the queue instead.\n     *\n     * @param triggerPair the pair containing the local and remote candidate\n     * that we'd need to trigger a check for.\n     * @return Whether a triggered check was started\n     */\n    private boolean triggerCheck(CandidatePair triggerPair)\n    {\n        //first check whether we already know about the remote address in case\n        //we've just discovered a peer-reflexive candidate.\n        CandidatePair knownPair\n            = findCandidatePair(\n                triggerPair.getLocalCandidate().getTransportAddress(),\n                triggerPair.getRemoteCandidate().getTransportAddress());\n\n        IceMediaStream parentStream = triggerPair.getLocalCandidate()\n            .getParentComponent().getParentStream();\n\n        if (knownPair != null)\n        {\n            boolean useCand = triggerPair.useCandidateReceived();\n\n            //if the incoming request contained a USE-CANDIDATE attribute then\n            //make sure we don't lose this piece of info.\n            if (useCand)\n                knownPair.setUseCandidateReceived();\n\n            triggerPair = knownPair;\n\n            //we already know about the remote address so we only need to\n            //trigger a check for the existing pair\n\n            if (knownPair.getState() == CandidatePairState.SUCCEEDED )\n            {\n                //7.2.1.5. Updating the Nominated Flag\n                if (!isControlling() && useCand)\n                {\n                    logger.debug(() -> \"update nominated flag\");\n                    // If the Binding request received by the agent had the\n                    // USE-CANDIDATE attribute set, and the agent is in the\n                    // controlled role, the agent looks at the state of the\n                    // pair ....\n                    // If the state of this pair is Succeeded, it means that a\n                    // previous check generated by this pair produced a\n                    // successful response. This would have caused the agent to\n                    // construct a valid pair when that success response was\n                    // received. The agent now sets the nominated flag in the\n                    // valid pair to true.\n                    nominationConfirmed( triggerPair );\n\n                    //the above may have caused us to exit, and so we need to\n                    //make the call below in order to make sure that we update\n                    //ICE processing state.\n                    checkListStatesUpdated();\n                }\n\n                return true;\n            }\n\n            // RFC 5245: If the state of that pair is In-Progress, the agent\n            // cancels the in-progress transaction.\n            if (knownPair.getState() == CandidatePairState.IN_PROGRESS )\n            {\n                TransactionID checkTransaction\n                    = knownPair.getConnectivityCheckTransaction();\n\n                getStunStack().cancelTransaction(checkTransaction);\n            }\n        }\n        else\n        {\n            //it appears that we've just discovered a peer-reflexive address.\n            // RFC 5245: If the pair is not already on the check list:\n            // The pair is inserted into the check list based on its priority\n            // Its state is set to Waiting [and it] is enqueued into the\n            // triggered check queue.\n            //\n            // Local addition: if we're already stopped, we're never going to send the\n            // check for the triggered pair, so don't enqueue it.\n            if (connCheckClient.isStopped())\n            {\n                return false;\n            }\n            if (triggerPair.getParentComponent().getSelectedPair() == null)\n                logger.info(\"Add peer CandidatePair with new reflexive \" +\n                        \"address to checkList: \" + triggerPair.toRedactedString());\n            parentStream.addToCheckList(triggerPair);\n        }\n\n        // RFC 5245: The agent MUST create a new connectivity check for that\n        // pair (representing a new STUN Binding request transaction) by\n        // enqueueing the pair in the triggered check queue.  The state of\n        // the pair is then changed to Waiting.\n        // Emil: This actually applies for all cases.\n        /*\n         * Lyubomir: The connectivity checks for a CheckList are started\n         * elsewhere as soon as and only if the CheckList changes from frozen\n         * to unfrozen. Since CheckList#scheduleTriggeredCheck will change\n         * triggerPair to Waiting and will thus unfreeze its CheckList, make\n         * sure that the connectivity checks for the CheckList are started.\n         * Otherwise, the connectivity checks for the CheckList may never be\n         * started (which may make the Agent remain running forever).\n         */\n        CheckList checkList = parentStream.getCheckList();\n        boolean wasFrozen = checkList.isFrozen();\n\n        checkList.scheduleTriggeredCheck(triggerPair);\n        if (wasFrozen && !checkList.isFrozen())\n            connCheckClient.startChecks(checkList);\n\n        return true;\n    }\n\n    /**\n     * Adds <tt>pair</tt> to that list of valid candidates for its parent\n     * stream.\n     *\n     * @param validPair the {@link CandidatePair} we'd like to validate.\n     */\n    protected void validatePair(CandidatePair validPair)\n    {\n        Component parentComponent = validPair.getParentComponent();\n        IceMediaStream parentStream = parentComponent.getParentStream();\n\n        parentStream.addToValidList(validPair);\n    }\n\n    /**\n     * Raises <tt>pair</tt>'s nomination flag and schedules a triggered check.\n     * Applications only need to use this method if they disable this\n     * <tt>Agent</tt>'s internal nomination and implement their own nominator\n     * and turn off nominations in this agent.\n     *\n     * @param pair the {@link CandidatePair} that we'd like to nominate and that\n     * we'd like to schedule a triggered check for.\n     *\n     * @throws IllegalStateException if this <tt>Agent</tt> is not a controlling\n     * agent and can therefore not nominate pairs.\n     *\n     * @see Agent#setNominationStrategy(NominationStrategy)\n     */\n    public synchronized void nominate(CandidatePair pair)\n        throws IllegalStateException\n    {\n        if (!isControlling())\n        {\n            throw new IllegalStateException(\n                    \"Only controlling agents can nominate pairs\");\n        }\n\n        Component parentComponent = pair.getParentComponent();\n        IceMediaStream parentStream = parentComponent.getParentStream();\n\n        //If the pair is not already nominated and if its parent component\n        //does not already contain a nominated pair - nominate it.\n        if (!pair.isNominated()\n              && !parentStream.validListContainsNomineeForComponent(\n                      parentComponent))\n        {\n            logger.info(\"verify if nominated pair answer again\");\n            pair.nominate();\n            parentStream.getCheckList().scheduleTriggeredCheck(pair);\n        }\n    }\n\n    /**\n     * Returns the {@link NominationStrategy} that we use in order to\n     * decide if and when we should nominate valid pairs.\n     *\n     * @return the strategy that we are using for nominating\n     * valid {@link CandidatePair}s.\n     */\n    public NominationStrategy getNominationStrategy()\n    {\n        return this.nominator.getStrategy();\n    }\n\n    /**\n     * Specifies the {@link NominationStrategy} that we should use in order to\n     * decide if and when we should nominate valid pairs.\n     *\n     * @param strategy the strategy that we'd like to use for nominating\n     * valid {@link CandidatePair}s.\n     */\n    public void setNominationStrategy(NominationStrategy strategy)\n    {\n        this.nominator.setStrategy(strategy);\n    }\n\n    /**\n     * Indicates that we have received a response to a request that either\n     * contained the <tt>USE-CANDIDATE</tt> attribute or was triggered by an\n     * incoming request that did.\n     *\n     * @param nominatedPair the {@link CandidatePair} whose nomination has\n     * just been confirmed.\n     */\n    protected void nominationConfirmed(CandidatePair nominatedPair)\n    {\n        nominatedPair.nominate();\n\n        Component parentComponent = nominatedPair.getParentComponent();\n        IceMediaStream parentStream = parentComponent.getParentStream();\n        CheckList checkList = parentStream.getCheckList();\n\n        if ( checkList.getState() == CheckListState.RUNNING )\n        {\n            checkList.handleNominationConfirmed(nominatedPair);\n        }\n\n        //Once there is at least one nominated pair in the valid list for\n        //every component of the media stream and the state of the\n        //check list is Running\n        if (parentStream.allComponentsHaveSelected()\n           && checkList.getState() == CheckListState.RUNNING)\n        {\n            //The agent MUST change the state of processing for its check\n            //list for that media stream to Completed.\n            checkList.setState(CheckListState.COMPLETED);\n        }\n    }\n\n    /**\n     * After updating check list states as a result of an incoming response\n     * or a timeout event the method goes through all check lists and tries\n     * to assess the state of ICE processing.\n     */\n    protected void checkListStatesUpdated()\n    {\n        boolean allListsEnded = true;\n        boolean atLeastOneListSucceeded = false;\n\n        if (getState().isEstablished())\n        {\n            return;\n        }\n\n        List<IceMediaStream> streams = getStreams();\n\n        for (IceMediaStream stream : streams)\n        {\n            CheckListState checkListState = stream.getCheckList().getState();\n\n            if (checkListState == CheckListState.RUNNING)\n            {\n                allListsEnded = false;\n                break;\n            }\n            else if (checkListState == CheckListState.COMPLETED)\n            {\n                logger.info(\"CheckList of stream \" + stream.getName() +\n                        \" is COMPLETED\");\n                atLeastOneListSucceeded = true;\n            }\n        }\n\n\n        if (!allListsEnded)\n        {\n            return;\n        }\n\n        if (!atLeastOneListSucceeded)\n        {\n            //all lists ended but none succeeded. No love today ;(\n            if (logger.isInfoEnabled())\n            {\n                if (connCheckClient.isAlive()\n                    || connCheckServer.isAlive())\n                {\n                    logger.info(\"Suspicious ICE connectivity failure. Checks\" +\n                        \" failed but the remote end was able to reach us.\");\n                }\n\n                logger.info(\"ICE state is FAILED\");\n            }\n\n            terminate(IceProcessingState.FAILED);\n            return;\n        }\n\n        //Once the state of each check list is Completed:\n        //The agent sets the state of ICE processing overall to Completed.\n        if (getState() != IceProcessingState.RUNNING)\n        {\n            //Oh, seems like we already did this.\n            return;\n        }\n\n        // The race condition in which another thread enters COMPLETED right\n        // under our nose here has been observed (and not in a single instance)\n        // So check that we did indeed just trigger the change.\n        if (!setState(IceProcessingState.COMPLETED))\n        {\n            return;\n        }\n\n        // keep ICE running (answer STUN Binding requests, send STUN Binding\n        // indications or requests)\n        scheduleStunKeepAlive();\n\n        scheduleTermination();\n\n        //print logs for the types of addresses we chose.\n        logCandTypes();\n    }\n\n    /**\n     * Goes through all streams and components and prints into the logs the type\n     * of local candidates that were selected as well as the server that\n     * were used (if any) to obtain them.\n     */\n    private void logCandTypes()\n    {\n        List<IceMediaStream> strms = getStreams();\n\n        for (IceMediaStream stream : strms)\n        {\n            for (Component component : stream.getComponents())\n            {\n                CandidatePair selectedPair = component.getSelectedPair();\n\n                StringBuffer buf\n                    = new StringBuffer( \"Harvester used for selected pair for \");\n                buf.append(component.toShortString());\n                buf.append(\": \");\n\n                if (selectedPair == null)\n                {\n                    buf.append(\"none (conn checks failed)\");\n                    logger.info(buf.toString());\n                    continue;\n                }\n\n                Candidate<?> localCnd = selectedPair.getLocalCandidate();\n\n                TransportAddress serverAddr = localCnd.getStunServerAddress();\n\n                buf.append(localCnd.getType());\n\n                if (serverAddr != null)\n                {\n                    buf.append(\" (STUN server = \");\n                    buf.append(serverAddr);\n                    buf.append(\")\");\n                }\n                else\n                {\n                    TransportAddress relayAddr\n                        = localCnd.getRelayServerAddress();\n\n                    if (relayAddr != null)\n                    {\n                        buf.append(\" (relay = \");\n                        buf.append(relayAddr);\n                        buf.append(\")\");\n                    }\n                }\n                logger.info(buf.toString());\n            }\n        }\n    }\n\n    /**\n     * Returns the number of host {@link Candidate}s in this {@link Agent}.\n     *\n     * @return the number of host {@link Candidate}s in this {@link Agent}.\n     */\n    protected int countHostCandidates()\n    {\n        int num = 0;\n\n        synchronized (mediaStreams)\n        {\n            Collection<IceMediaStream> streamsCol = mediaStreams.values();\n\n            for (IceMediaStream stream : streamsCol)\n            {\n                num += stream.countHostCandidates();\n            }\n        }\n\n        return num;\n    }\n\n    /**\n     * Lets the application specify a custom value for the <tt>Ta</tt> timer\n     * so that we don't calculate one.\n     *\n     * @param taValue the value of the <tt>Ta</tt> timer that the application\n     * would like us to use rather than calculate one.\n     */\n    public void setTa(long taValue)\n    {\n        this.taValue = taValue;\n    }\n\n    /**\n     * Calculates the value of the <tt>Ta</tt> pace timer according to the\n     * number and type of {@link IceMediaStream}s this agent will be using.\n     * <p>\n     * During the gathering phase of ICE (Section 4.1.1) and while ICE is\n     * performing connectivity checks (Section 7), an agent sends STUN and\n     * TURN transactions.  These transactions are paced at a rate of one\n     * every <tt>Ta</tt> milliseconds.\n     * <p>\n     * As per RFC 5245, the value of <tt>Ta</tt> should be configurable so if\n     * someone has set a value of their own, we return that value rather than\n     * calculating a new one.\n     *\n     * @return the value of the <tt>Ta</tt> pace timer according to the\n     * number and type of {@link IceMediaStream}s this agent will be using or\n     * a pre-configured value if the application has set one.\n     */\n    protected long calculateTa()\n    {\n        //if application specified a value - use it. other wise return ....\n        // eeeer ... a \"dynamically\" calculated one ;)\n        if (taValue != -1)\n            return taValue;\n\n        /* RFC 5245 says that Ta is:\n         *\n         *     Ta_i = (stun_packet_size / rtp_packet_size) * rtp_ptime\n         *\n         *                               1\n         *         Ta = MAX (20ms, ------------------- )\n         *                               k\n         *                             ----\n         *                             \\        1\n         *                              >    ------\n         *                             /       Ta_i\n         *                             ----\n         *                              i=1\n         *\n         * In this implementation we assume equal values of\n         * stun_packet_size and rtp_packet_size. rtp_ptime is also assumed to be\n         * 20ms. One day we should probably let the application modify them.\n         * Until then however the above formula would always be equal to.\n         *                            1\n         *         Ta = MAX (20ms, ------- )\n         *                            k\n         *                           ---\n         *                            20\n         * which gives us Ta = MAX (20ms, 20/k) which is always 20.\n         */\n        return 20;\n    }\n\n    /**\n     * Calculates the value of the retransmission timer to use in STUN\n     * transactions, while harvesting addresses (not to confuse with the RTO\n     * for the STUN transactions used in connectivity checks).\n     *\n     * @return the value of the retransmission timer to use in STUN\n     * transactions, while harvesting addresses.\n     */\n    protected long calculateStunHarvestRTO()\n    {\n        /* RFC 5245 says:\n         * RTO = MAX (100ms, Ta * (number of pairs))\n         * where the number of pairs refers to the number of pairs of candidates\n         * with STUN or TURN servers.\n         *\n         * Go figure what \"pairs of candidates with STUN or TURN servers\" means.\n         * Let's assume they meant the number stun transactions we'll start\n         * while harvesting.\n         */\n\n        return Math.max(100, calculateTa() * 2 * countHostCandidates());\n    }\n\n    /**\n     * Calculates the value of the retransmission timer to use in STUN\n     * transactions, used in connectivity checks (not to confused with the RTO\n     * for the STUN address harvesting).\n     *\n     * @return the value of the retransmission timer to use in STUN connectivity\n     * check transactions..\n     */\n    protected long calculateStunConnCheckRTO()\n    {\n        /* RFC 5245 says:\n         * For connectivity checks, RTO SHOULD be configurable and SHOULD have\n         * a default of:\n         *\n         * RTO = MAX (100ms, Ta*N * (Num-Waiting + Num-In-Progress))\n         *\n         * where Num-Waiting is the number of checks in the check list in the\n         * Waiting state, Num-In-Progress is the number of checks in the\n         * In-Progress state, and N is the number of checks to be performed.\n         *\n         * Emil: I am not sure I like the formula so we'll simply be returning\n         * 100 for the time being.\n         */\n        return 100;\n    }\n\n    /**\n     * Initializes and starts the {@link #terminationFuture}\n     */\n    private void scheduleTermination()\n    {\n        /*\n         * RFC 5245 says: Once ICE processing has reached the Completed state for\n         * all peers for media streams using those candidates, the agent SHOULD\n         * wait an additional three seconds, and then it MAY cease responding to\n         * checks or generating triggered checks on that candidate.  It MAY free\n         * the candidate at that time.\n         * <p>\n         * This method is scheduling such a termination.\n         */\n        boolean runTerminationImmediately = false;\n\n        synchronized (terminationFutureSyncRoot)\n        {\n            if (terminationFuture == null)\n            {\n                long terminationDelay = config.getTerminationDelay().toMillis();\n\n                if (terminationDelay > 0)\n                {\n                    terminationFuture\n                        = agentTasksScheduler.schedule(\n                            terminationRunnable,\n                            terminationDelay,\n                            TimeUnit.MILLISECONDS);\n                }\n                else\n                {\n                    runTerminationImmediately = true;\n                }\n            }\n        }\n\n        if (runTerminationImmediately)\n        {\n            terminationRunnable.run();\n        }\n    }\n\n    /**\n     * Schedules repeated background task which sends STUN keep-alives\n     * once this <tt>Agent</tt> is <tt>COMPLETED</tt>.\n     */\n    private void scheduleStunKeepAlive()\n    {\n        boolean noKeepAlives\n            = StackProperties.getBoolean(\n                StackProperties.NO_KEEP_ALIVES,\n                false);\n        if (noKeepAlives || !stunKeepAliveRunner.shouldRunStunKeepAlive())\n        {\n            return;\n        }\n\n        stunKeepAliveRunner.schedule();\n    }\n\n\n    /**\n     * Terminates this <tt>Agent</tt> by stopping the handling of connectivity\n     * checks and setting a specific termination state on it.\n     *\n     * @param terminationState the state that we'd like processing to terminate\n     * with i.e. either {@link IceProcessingState#TERMINATED} or\n     * {@link IceProcessingState#FAILED}\n     */\n    private void terminate(IceProcessingState terminationState)\n    {\n        if (!IceProcessingState.FAILED.equals(terminationState)\n                && !IceProcessingState.TERMINATED.equals(terminationState))\n            throw new IllegalArgumentException(\"terminationState\");\n\n        // stop making any checks.\n        connCheckClient.stop();\n\n        //do not stop the conn check server here because it may still need to\n        //process STUN Binding Requests that remote agents may send our way.\n        //we'll do this in \"free()\" instead.\n        //connCheckServer.stop();\n\n        setState(terminationState);\n    }\n\n    /**\n     * Adds or removes ICE characters (i.e. ALPHA, DIGIT, +, or /) to or from a\n     * specific <tt>String</tt> in order to produce a <tt>String</tt> with a\n     * length within a specific range.\n     *\n     * @param s the <tt>String</tt> to add or remove characters to or from in\n     * case its length is less than <tt>min</tt> or greater than <tt>max</tt>\n     * @param min the minimum length in (ICE) characters of the returned\n     * <tt>String</tt>\n     * @param max the maximum length in (ICE) characters of the returned\n     * <tt>String</tt>\n     * @return <tt>s</tt> if its length is greater than or equal to\n     * <tt>min</tt> and less than or equal to <tt>max</tt>; a new\n     * <tt>String</tt> which is equal to <tt>s</tt> with prepended ICE\n     * characters if the length of <tt>s</tt> is less than <tt>min</tt>; a new\n     * <tt>String</tt> which is composed of the first <tt>max</tt> characters of\n     * <tt>s</tt> if the length of <tt>s</tt> is greater than <tt>max</tt>\n     * @throws IllegalArgumentException if <tt>min</tt> is negative or\n     * <tt>max</tt> is less than <tt>min</tt>\n     * @throws NullPointerException if <tt>s</tt> is equal to <tt>null</tt>\n     */\n    private String ensureIceAttributeLength(String s, int min, int max)\n    {\n        if (s == null)\n            throw new NullPointerException(\"s\");\n        if (min < 0)\n            throw new IllegalArgumentException(\"min \" + min);\n        if (max < min)\n            throw new IllegalArgumentException(\"max \" + max);\n\n        int length = s.length();\n        int numberOfIceCharsToAdd = min - length;\n\n        if (numberOfIceCharsToAdd > 0)\n        {\n            StringBuilder sb = new StringBuilder(min);\n\n            for (; numberOfIceCharsToAdd > 0; --numberOfIceCharsToAdd)\n            {\n                sb.append('0');\n            }\n            sb.append(s);\n            s = sb.toString();\n        }\n        else if (max < length)\n        {\n            s = s.substring(0, max);\n        }\n        return s;\n    }\n\n    /**\n     * Called by the garbage collector when garbage collection determines that\n     * there are no more references to this instance. Calls {@link #free()} on\n     * this instance.\n     *\n     * @throws Throwable if anything goes wrong and the finalization of this\n     * instance is to be halted\n     * @see #free()\n     */\n    @Override\n    protected void finalize()\n        throws Throwable\n    {\n        free();\n\n        super.finalize();\n    }\n\n    /**\n     * Prepares this <tt>Agent</tt> for garbage collection by ending all related\n     * processes and freeing its <tt>IceMediaStream</tt>s, <tt>Component</tt>s\n     * and <tt>Candidate</tt>s. This method will also place the agent in the\n     * terminated state in case it wasn't already there.\n     */\n    public void free()\n    {\n        logger.debug(() -> \"Free ICE agent\");\n\n        shutdown = true;\n\n        //stop sending keep alives (STUN Binding Indications).\n        stunKeepAliveRunner.cancel();\n\n        // cancel termination timer in case agent is freed\n        // before termination timer is triggered\n        synchronized (terminationFutureSyncRoot)\n        {\n            if (terminationFuture != null)\n            {\n                terminationFuture.cancel(true);\n                terminationFuture = null;\n            }\n        }\n\n        //stop responding to STUN Binding Requests.\n        connCheckServer.stop();\n\n        /*\n         * Set the IceProcessingState#TERMINATED state on this Agent unless it\n         * is in a termination state already.\n         */\n        IceProcessingState state = getState();\n\n        if (!IceProcessingState.FAILED.equals(state)\n             && !IceProcessingState.TERMINATED.equals(state))\n        {\n            terminate(IceProcessingState.TERMINATED);\n        }\n\n        /* Stop all outstanding transactions */\n        getStunStack().shutDown();\n\n        // Free its IceMediaStreams, Components and Candidates.\n        boolean interrupted = false;\n\n        logger.debug(() -> \"remove streams\");\n        for (IceMediaStream stream : getStreams())\n        {\n            try\n            {\n                removeStream(stream);\n                logger.debug(\"remove stream \" + stream.getName());\n            }\n            catch (Throwable t)\n            {\n                logger.debug(() ->\n                        \"remove stream \" + stream.getName() + \" failed: \" + t);\n                if (t instanceof InterruptedException)\n                    interrupted = true;\n                else if (t instanceof ThreadDeath)\n                    throw (ThreadDeath) t;\n            }\n        }\n        if (interrupted)\n            Thread.currentThread().interrupt();\n\n        logger.debug(() -> \"ICE agent freed\");\n    }\n\n    /**\n     * Returns the current generation of this ICE Agent. A generation is an\n     * index, starting at 0, that enables the parties to keep track of updates\n     * to the candidate throughout the life of the session.\n     *\n     * @return the current generation of this ICE Agent\n     */\n    public int getGeneration()\n    {\n        return generation;\n    }\n\n    /**\n     * Specifies the current generation of this ICE Agent. A generation is an\n     * index, starting at 0, that enables the parties to keep track of updates\n     * to the candidate throughout the life of the session.\n     *\n     * @param generation the current generation of this ICE Agent\n     */\n    public void setGeneration(int generation)\n    {\n        this.generation = generation;\n    }\n\n    /**\n     * Returns the selected pair for the RTP component for the ICE media stream\n     * with name <tt>streamName</tt> of this Agent, or <tt>null</tt>.\n     *\n     * @param streamName The stream name.\n     *\n     * @return the selected pair for the RTP component for the ICE media stream\n     * with name <tt>streamName</tt> of this Agent, or <tt>null</tt>.\n     */\n    private CandidatePair getSelectedPair(String streamName)\n    {\n        IceMediaStream stream = getStream(streamName);\n        if (stream != null)\n        {\n            Component component = stream.getComponent(Component.RTP);\n            if (component != null)\n                return component.getSelectedPair();\n        }\n        return null;\n    }\n\n    /**\n     * Returns the selected local candidate for this Agent.\n     *\n     * @param streamName The stream name (AUDIO, VIDEO);\n     *\n     * @return The selected local candidate for this Agent. Null if no pair is\n     * selected.\n     */\n    public LocalCandidate getSelectedLocalCandidate(String streamName)\n    {\n        CandidatePair candidatePair = getSelectedPair(streamName);\n\n        return\n            (candidatePair == null) ? null : candidatePair.getLocalCandidate();\n    }\n\n    /**\n     * Returns the selected remote candidate for this Agent.\n     *\n     * @param streamName The stream name (AUDIO, VIDEO);\n     *\n     * @return The selected remote candidate for this Agent. Null if no pair is\n     * selected.\n     */\n    public RemoteCandidate getSelectedRemoteCandidate(String streamName)\n    {\n        CandidatePair candidatePair = getSelectedPair(streamName);\n\n        return\n            (candidatePair == null) ? null : candidatePair.getRemoteCandidate();\n    }\n\n    /**\n     * Indicates whether this agent is currently set to trickle candidates\n     * rather than gathering them synchronously while components are being\n     * added. When trickling is turned on, the agent will only gather host\n     * addresses for newly added components. When trickling is off, all\n     * harvesting for a specific component will be executed when that component\n     * is being added.\n     *\n     * @return <tt>false</tt> if this agent is configured to perform all\n     * harvesting when components are being added and <tt>false</tt> otherwise.\n     */\n    public boolean isTrickling()\n    {\n        return trickle;\n    }\n\n    /**\n     * Determines whether this agent will trickle candidates rather than\n     * gather them synchronously while components are being added. When\n     * trickling is turned on, the agent will only gather host addresses for\n     * newly added components. When trickling is off, all harvesting for a\n     * specific component will be executed when that component is being added.\n     *\n     * @param trickle <tt>false</tt> if this agent is configured to perform all\n     * harvesting when components are being added and <tt>false</tt> otherwise.\n     */\n    public void setTrickling(boolean trickle)\n    {\n        this.trickle = trickle;\n    }\n\n\n    /**\n     * Returns the harvesting time (in ms) for the harvester given in parameter.\n     *\n     * @param harvesterName The class name if the harvester.\n     *\n     * @return The harvesting time (in ms) for the harvester given in parameter.\n     */\n    public long getHarvestingTime(String harvesterName)\n    {\n        long harvestingTime = 0;\n\n        for (CandidateHarvester harvester : harvesters)\n        {\n            if (harvester.getClass().getName().endsWith(harvesterName))\n            {\n                harvestingTime\n                    = harvester.getHarvestStatistics().getHarvestDuration();\n                // There may be several harvester with the same class name.\n                // Thus, returns only an active one (if any).\n                if (harvestingTime != 0)\n                {\n                    return harvestingTime;\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    /**\n     * Returns the number of harvests that a harvester with a specific class\n     * name has completed so far.\n     *\n     * @param harvesterName the class name of the harvester for which the\n     * number of completed harvests is to be returned\n     * @return the number of harvests that the harvester with the specified\n     * <tt>harvesterName</tt> has completed so far if such a harvester exists\n     * and has completed at least one harvest; otherwise, zero\n     */\n    public int getHarvestCount(String harvesterName)\n    {\n        int harvestCount;\n\n        for (CandidateHarvester harvester : harvesters)\n        {\n            if (harvester.getClass().getName().endsWith(harvesterName))\n            {\n                harvestCount\n                    = harvester.getHarvestStatistics().getHarvestCount();\n                // There may be several harvester with the same class name.\n                // Thus, returns only an active one (if any).\n                if (harvestCount != 0)\n                {\n                    return harvestCount;\n                }\n            }\n        }\n\n        return 0;\n    }\n\n    /**\n     * Returns the combined harvesting time for all harvesters in this agent.\n     *\n     * @return the total time this agent has spent harvesting.\n     */\n    public long getTotalHarvestingTime()\n    {\n        long harvestDuration = 0;\n\n        for (CandidateHarvester harvester : harvesters)\n        {\n            harvestDuration\n                += harvester.getHarvestStatistics().getHarvestDuration();\n        }\n\n        return harvestDuration;\n    }\n\n    /**\n     * Returns the total number of harvests completed by this agent. Normally,\n     * this number should be equal to <tt>NB_HARVESTERS * NB_COMPONENTS</tt> but\n     * could be less, for example, if some harvesters were disabled for\n     * inefficiency.\n     *\n     * @return the number of harvests this agent has completed.\n     */\n    public int getHarvestCount()\n    {\n        int harvestCount = 0;\n\n        for (CandidateHarvester harvester : harvesters)\n        {\n            harvestCount += harvester.getHarvestStatistics().getHarvestCount();\n        }\n\n        return harvestCount;\n    }\n\n    /**\n     * Gets the indicator which determines whether this <tt>Agent</tt> is to\n     * perform consent freshness.\n     *\n     * @return <tt>true</tt> if this <tt>Agent</tt> is to perform consent\n     * freshness; otherwise, <tt>false</tt>\n     */\n    public boolean getPerformConsentFreshness()\n    {\n        return performConsentFreshness;\n    }\n\n    /**\n     * Sets the indicator which determines whether this <tt>Agent</tt> is to\n     * perform consent freshness.\n     *\n     * @param performConsentFreshness <tt>true</tt> if this <tt>Agent</tt> is to\n     * perform consent freshness; otherwise, <tt>false</tt>\n     */\n    public void setPerformConsentFreshness(boolean performConsentFreshness)\n    {\n        this.performConsentFreshness = performConsentFreshness;\n    }\n\n    /**\n     * Sets the logging level for this {@link Agent} and its components.\n     * @param level the level to set.\n     */\n    public void setLoggingLevel(Level level)\n    {\n        logger.setLevel(level);\n    }\n\n    /**\n     * Gets the logging level for this {@link Agent} and its components.\n     */\n    public Level getLoggingLevel()\n    {\n        return logger.getLevel();\n    }\n\n    /**\n     * @return this {@link Agent}'s {@link Logger}.\n     */\n    protected Logger getLogger()\n    {\n        return logger;\n    }\n\n    /**\n     * A class to schedule and perform Stun keep-alive checks\n     */\n    private final class StunKeepAliveRunner extends PeriodicRunnable\n    {\n        private final long consentFreshnessInterval = config.getConsentFreshnessInterval().toMillis();\n        private final int originalConsentFreshnessWaitInterval\n                = (int) config.getConsentFreshnessOriginalWaitInterval().toMillis();\n\n        private final int maxConsentFreshnessWaitInterval\n                = (int) config.getConsentFreshnessMaxWaitInterval().toMillis();\n\n        private final int consentFreshnessMaxRetransmissions = config.getMaxConsentFreshnessRetransmissions();\n\n        private int keepAliveSent = 0;\n\n        StunKeepAliveRunner()\n        {\n            super(agentTasksScheduler, agentTasksExecutor);\n        }\n\n        @Override\n        protected Duration getDelayUntilNextRun()\n        {\n            if (shouldRunStunKeepAlive())\n            {\n                if (keepAliveSent == 0)\n                {\n                    return Duration.ZERO;\n                }\n                else\n                {\n                    double r = 1;\n                    if (config.getRandomizeConsentFreshnessInterval())\n                    {\n                        r = 0.8d + ThreadLocalRandom.current().nextDouble() * 0.4;\n                    }\n                    return Duration.ofMillis((long) (consentFreshnessInterval * r));\n                }\n            }\n            return Duration.ofMillis(-1);\n        }\n\n        @Override\n        protected void run()\n        {\n            try\n            {\n                sendKeepAlive();\n            }\n            catch (Exception e)\n            {\n                logger.warn(\"Error while sending keep alive\", e);\n            }\n        }\n\n        private void sendKeepAlive()\n        {\n            ++keepAliveSent;\n\n            for (IceMediaStream stream : getStreams())\n            {\n                for (Component component : stream.getComponents())\n                {\n                    for (CandidatePair pair : component.getKeepAlivePairs())\n                    {\n                        if (pair != null)\n                        {\n                            if (performConsentFreshness)\n                            {\n                                connCheckClient.startCheckForPair(\n                                    pair,\n                                    originalConsentFreshnessWaitInterval,\n                                    maxConsentFreshnessWaitInterval,\n                                    consentFreshnessMaxRetransmissions);\n                            }\n                            else\n                            {\n                                connCheckClient\n                                    .sendBindingIndicationForPair(pair);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Determines whether {@link #stunKeepAliveRunner} should run.\n         *\n         * @return <tt>true</tt> if <tt>{@link #stunKeepAliveRunner}</tt>\n         * should run otherwise, <tt>false</tt>\n         */\n        boolean shouldRunStunKeepAlive()\n        {\n            IceProcessingState state = Agent.this.state;\n\n            return\n                (IceProcessingState.COMPLETED.equals(state)\n                    || IceProcessingState.TERMINATED.equals(state))\n                    && !shutdown;\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final PropertyChangeListener[] NO_STATE_CHANGE_LISTENERS\n        = new PropertyChangeListener[0];", "docstring": "\nThe constant which defines an empty array with element type\n<tt>PropertyChangeListener</tt> and represents the fact that there are no\n<tt>IceProcessingState</tt> change listeners added to an <tt>Agent</tt>\n(using {@link #addStateChangeListener(PropertyChangeListener)}.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "PropertyChangeListener[]", "name": "NO_STATE_CHANGE_LISTENERS\n        = new PropertyChangeListener[0]", "syntax_pass": true}, {"attribute_expression": "public static final String PROPERTY_ICE_PROCESSING_STATE\n                                            = \"IceProcessingState\";", "docstring": "\nThe name of the {@link PropertyChangeEvent} that we use to deliver\nevents on changes in the state of ICE processing in this agent.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "PROPERTY_ICE_PROCESSING_STATE\n                                            = \"IceProcessingState\"", "syntax_pass": true}, {"attribute_expression": "private static final ScheduledExecutorService agentTasksScheduler\n        = ExecutorFactory.createSingleThreadScheduledExecutor(\n            \"ice4j.Agent-timer-\", 60, TimeUnit.SECONDS);", "docstring": "\n The ScheduledExecutorService to execute Agent's scheduled tasks\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ScheduledExecutorService", "name": "agentTasksScheduler\n        = ExecutorFactory.createSingleThreadScheduledExecutor(\n            \"ice4j.Agent-timer-\", 60, TimeUnit.SECONDS)", "syntax_pass": true}, {"attribute_expression": "private static final ExecutorService agentTasksExecutor\n        = Executors.newCachedThreadPool(\n            new CustomizableThreadFactory(\"ice4j.Agent-executor-\", true));", "docstring": "\n The ExecutorService to execute Agent's tasks\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ExecutorService", "name": "agentTasksExecutor\n        = Executors.newCachedThreadPool(\n            new CustomizableThreadFactory(\"ice4j.Agent-executor-\", true))", "syntax_pass": true}, {"attribute_expression": "private final Runnable terminationRunnable = new Runnable()\n    {\n        @Override\n        public void run()\n        {\n            terminate(IceProcessingState.TERMINATED);\n            synchronized (terminationFutureSyncRoot)\n            {\n                terminationFuture = null;\n            }\n        }\n    };", "docstring": "\nTermination task which will be scheduled with timeout\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Runnable", "name": "terminationRunnable = new Runnable()\n    {\n        @Override\n        public void run()\n        {\n            terminate(IceProcessingState.TERMINATED);\n            synchronized (terminationFutureSyncRoot)\n            {\n                terminationFuture = null;\n            }\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "private final StunKeepAliveRunner stunKeepAliveRunner\n        = new StunKeepAliveRunner();", "docstring": "\nAn instance to schedule STUN checks for selected pair.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StunKeepAliveRunner", "name": "stunKeepAliveRunner\n        = new StunKeepAliveRunner()", "syntax_pass": true}, {"attribute_expression": "private final Map<String, IceMediaStream> mediaStreams\n        = new LinkedHashMap<>();", "docstring": "\nThe LinkedHashMap used to store the media streams\nThis map preserves the insertion order of the media streams.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, IceMediaStream>", "name": "mediaStreams\n        = new LinkedHashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final HostCandidateHarvester hostCandidateHarvester\n                                                = new HostCandidateHarvester();", "docstring": "\nThe candidate harvester that we use to gather candidate on the local\nmachine.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "HostCandidateHarvester", "name": "hostCandidateHarvester\n                                                = new HostCandidateHarvester()", "syntax_pass": true}, {"attribute_expression": "private final List<CandidateHarvester> hostHarvesters = new LinkedList<>();", "docstring": "\nA list of additional <tt>CandidateHarvester</tt>s which will be used to\nharvest candidates synchronously, and previously to harvesting by\n{@link #harvesters}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<CandidateHarvester>", "name": "hostHarvesters = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private final CandidateHarvesterSet harvesters\n        = new CandidateHarvesterSet();", "docstring": "\nThe set of harvesters (i.e. STUN, TURN, and others) that the agent should\nuse when gathering candidates for components.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CandidateHarvesterSet", "name": "harvesters\n        = new CandidateHarvesterSet()", "syntax_pass": true}, {"attribute_expression": "private final FoundationsRegistry foundationsRegistry\n                                          = new FoundationsRegistry();", "docstring": "\nWe use the <tt>FoundationsRegistry</tt> to keep track of the foundations\nwe assign within a session (i.e. the entire life time of an\n<tt>Agent</tt>)\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "FoundationsRegistry", "name": "foundationsRegistry\n                                          = new FoundationsRegistry()", "syntax_pass": true}, {"attribute_expression": "private final DefaultNominator nominator;", "docstring": "\nOur internal nominator implementing several nomination strategies.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DefaultNominator", "name": "nominator", "syntax_pass": true}, {"attribute_expression": "private long taValue = -1;", "docstring": "\nThe value of <tt>Ta</tt> as specified by the application or <tt>-1</tt>\nif non was specified and we should calculate one ourselves.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "taValue = -1", "syntax_pass": true}, {"attribute_expression": "private final List<CandidatePair> preDiscoveredPairsQueue\n        = new LinkedList<>();", "docstring": "\nThe <tt>List</tt> of remote addresses that we have discovered through\nincoming connectivity checks, before actually receiving a session\ndescription from the peer and that may potentially contain peer reflexive\naddresses. This list is stored only if and while connectivity checks\nare not running. Once they start, we are able to determine whether the\naddresses in here are actually peer-reflexive or not, and schedule\nthe necessary triggered checks.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<CandidatePair>", "name": "preDiscoveredPairsQueue\n        = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private final Object startLock = new Object();", "docstring": "\nThe lock that we use while starting connectivity establishment.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "startLock = new Object()", "syntax_pass": true}, {"attribute_expression": "private final String ufrag;", "docstring": "\nThe user fragment that we should use for the ice-ufrag attribute.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "ufrag", "syntax_pass": true}, {"attribute_expression": "private final String password;", "docstring": "\nThe password that we should use for the ice-pwd attribute.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "password", "syntax_pass": true}, {"attribute_expression": "private long tieBreaker;", "docstring": "\nThe tie-breaker number is used in connectivity checks to detect and\nrepair the case where both agents believe to have the controlling or the\ncontrolled role.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "tieBreaker", "syntax_pass": true}, {"attribute_expression": "private boolean isControlling = true;", "docstring": "\nDetermines whether this agent has a controlling role in an ICE interaction.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "isControlling = true", "syntax_pass": true}, {"attribute_expression": "private final ConnectivityCheckClient connCheckClient;", "docstring": "\nThe entity that will be taking care of outgoing connectivity checks.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ConnectivityCheckClient", "name": "connCheckClient", "syntax_pass": true}, {"attribute_expression": "private final ConnectivityCheckServer connCheckServer;", "docstring": "\nThe entity that will be taking care of incoming connectivity checks.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ConnectivityCheckServer", "name": "connCheckServer", "syntax_pass": true}, {"attribute_expression": "private IceProcessingState state = IceProcessingState.WAITING;", "docstring": "\nIndicates the state of ICE processing in this <tt>Agent</tt>. An\n<tt>Agent</tt> is in the Waiting state until it has both sent and\nreceived candidate lists and started connectivity establishment. The\ndifference between the Waiting and the Running states is important in\ncases like determining whether a remote address we've just discovered is\npeer reflexive or not. If iceStarted is true and we don't know about the\naddress then we should add it to the list of candidates. Otherwise\nwe should wait for the remote party to send their media description\nbefore being able to determine.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IceProcessingState", "name": "state = IceProcessingState.WAITING", "syntax_pass": true}, {"attribute_expression": "private final Object stateSyncRoot = new Object();", "docstring": "\nObject used to synchronize access to {@link #state}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "stateSyncRoot = new Object()", "syntax_pass": true}, {"attribute_expression": "private final List<PropertyChangeListener> stateListeners\n        = new LinkedList<>();", "docstring": "\nContains {@link PropertyChangeListener}s registered with this {@link\nAgent} and following its changes of state.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<PropertyChangeListener>", "name": "stateListeners\n        = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private StunStack stunStack;", "docstring": "\nThe <tt>StunStack</tt> used by this <tt>Agent</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StunStack", "name": "stunStack", "syntax_pass": true}, {"attribute_expression": "private ScheduledFuture<?> terminationFuture;", "docstring": "\nThe scheduled task to terminate this <tt>Agent</tt>\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ScheduledFuture<?>", "name": "terminationFuture", "syntax_pass": true}, {"attribute_expression": "private final Object terminationFutureSyncRoot = new Object();", "docstring": "\nThe object used to synchronize access to {@link #terminationFuture}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "terminationFutureSyncRoot = new Object()", "syntax_pass": true}, {"attribute_expression": "private int generation = 0;", "docstring": "\nSome protocols, such as XMPP, need to be able to distinguish the separate\nICE sessions that occur as a result of ICE restarts, which is why we need\nto keep track of generations. A generation is an index, starting at 0,\nthat enables the parties to keep track of updates to the candidate\nthroughout the life of the session.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "generation = 0", "syntax_pass": true}, {"attribute_expression": "private boolean trickle = false;", "docstring": "\nDetermines whether this agent should perform trickling.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "trickle = false", "syntax_pass": true}, {"attribute_expression": "private boolean shutdown = false;", "docstring": "\nIndicates that ICE will be shutdown.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "shutdown = false", "syntax_pass": true}, {"attribute_expression": "private boolean harvestingStarted = false;", "docstring": "\nIndicates that harvesting has been started at least once. Used to warn\nusers who are trying to trickle, that they have already completed a\nharvest. We may use it to throw an exception at some point if it's ever\na problem.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "harvestingStarted = false", "syntax_pass": true}, {"attribute_expression": "private boolean performConsentFreshness = false;", "docstring": "\nThe indicator which determines whether this <tt>Agent</tt> is to perform\nconsent freshness.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "performConsentFreshness = false", "syntax_pass": true}, {"attribute_expression": "private final Logger logger;", "docstring": "\nThe {@link Logger} used by {@link Agent} instances.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Logger", "name": "logger", "syntax_pass": true}, {"attribute_expression": "private boolean useDynamicPorts = HarvestConfig.config.useDynamicPorts();", "docstring": "\nWhether this {@link Agent} should use dynamic ports. Can be overridden via {@link #setUseDynamicPorts(boolean)}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "useDynamicPorts = HarvestConfig.config.useDynamicPorts()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator", "name": "DefaultNominator", "file_path": "src/main/java/org/ice4j/ice/DefaultNominator.java", "superclasses": "", "methods": ["[]DefaultNominator(Agent)", "[void]propertyChange(PropertyChangeEvent)", "[void]strategyNominateFirstValid(PropertyChangeEvent)", "[void]strategyNominateHighestPrio(PropertyChangeEvent)", "[NominationStrategy]getStrategy()", "[void]setStrategy(NominationStrategy)", "[void]strategyNominateFirstHostOrReflexiveValid(PropertyChangeEvent)"], "method_uris": ["src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator.[]DefaultNominator(Agent)", "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator.[void]propertyChange(PropertyChangeEvent)", "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator.[void]strategyNominateFirstValid(PropertyChangeEvent)", "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator.[void]strategyNominateHighestPrio(PropertyChangeEvent)", "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator.[NominationStrategy]getStrategy()", "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator.[void]setStrategy(NominationStrategy)", "src/main/java/org/ice4j/ice/DefaultNominator.java.DefaultNominator.[void]strategyNominateFirstHostOrReflexiveValid(PropertyChangeEvent)"], "overrides": null, "attributes": [{"original_string": "    private class RelayedCandidateTask\n        extends TimerTask\n        implements PropertyChangeListener\n    {\n        /**\n         * Wait time in milliseconds.\n         */\n        private static final int WAIT_TIME = 800;\n\n        /**\n         * The relayed candidate pair.\n         */\n        private final CandidatePair pair;\n\n        /**\n         * If the task has been cancelled.\n         */\n        private boolean cancelled = false;\n\n        /**\n         * Constructor.\n         *\n         * @param pair relayed candidate pair\n         */\n        public RelayedCandidateTask(CandidatePair pair)\n        {\n            this.pair = pair;\n            pair.getParentComponent().getParentStream().getCheckList().\n                addChecksListener(this);\n        }\n\n        /**\n         * Tracks end of checks of the {@link CheckList}.\n         *\n         * @param evt the event\n         */\n        public void propertyChange(PropertyChangeEvent evt)\n        {\n            // Make it clear that PROPERTY_CHECK_LIST_CHECKS is in use here.\n            if (!CheckList.PROPERTY_CHECK_LIST_CHECKS.equals(\n                        evt.getPropertyName()))\n            {\n                return;\n            }\n\n            // check list has run out of ordinary checks, see if all other\n            // candidates are FAILED, in which case we nominate immediately\n            // the relayed candidate\n            CheckList checkList = (CheckList)evt.getSource();\n            boolean allFailed = true;\n\n            synchronized (checkList)\n            {\n                for (CandidatePair c : checkList)\n                {\n                    if (c != pair && c.getState() != CandidatePairState.FAILED)\n                    {\n                        allFailed = false;\n                        break;\n                    }\n                }\n            }\n\n            if (allFailed && !pair.isNominated())\n            {\n                // all other pairs are failed to do not waste time, cancel\n                // timer and nominate ourself (the relayed candidate).\n                this.cancel();\n\n                logger.info(\n                        \"Nominate (first highest valid): \"\n                            + pair.toRedactedShortString());\n                parentAgent.nominate(pair);\n            }\n        }\n\n        /**\n         * Cancel task.\n         */\n        @Override\n        public boolean cancel()\n        {\n            cancelled = true;\n            return super.cancel();\n        }\n\n        /**\n         * Task entry point.\n         */\n        public void run()\n        {\n            try\n            {\n                Thread.sleep(WAIT_TIME);\n            }\n            catch (InterruptedException e)\n            {\n                cancelled = true;\n            }\n\n            Component component = pair.getParentComponent();\n\n            component.getParentStream().getCheckList().removeChecksListener(\n                    this);\n            validatedCandidates.remove(component.toShortString());\n\n            if (cancelled)\n                return;\n\n            logger.info(\n                    \"Nominate (first highest valid): \" + pair.toRedactedShortString());\n\n            // task has not been cancelled after WAIT_TIME milliseconds so\n            // nominate the pair\n            parentAgent.nominate(pair);\n        }\n    }", "definition": "    private class RelayedCandidateTask\n        extends TimerTask\n        implements PropertyChangeListener", "class_docstring": "\nTimerTask that will wait a certain amount of time to let other candidate\npair to be validated and possibly be better than the relayed candidate.\n\n@author Sebastien Vincent\n", "name": "RelayedCandidateTask", "super_interfaces": ["PropertyChangeListener"], "superclasses": "TimerTask", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [{"attribute_expression": "private static final int WAIT_TIME = 800;", "docstring": "\nWait time in milliseconds.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "WAIT_TIME = 800", "syntax_pass": true}, {"attribute_expression": "private final CandidatePair pair;", "docstring": "\nThe relayed candidate pair.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CandidatePair", "name": "pair", "syntax_pass": true}, {"attribute_expression": "private boolean cancelled = false;", "docstring": "\nIf the task has been cancelled.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "cancelled = false", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public RelayedCandidateTask(CandidatePair pair)\n        {\n            this.pair = pair;\n            pair.getParentComponent().getParentStream().getCheckList().\n                addChecksListener(this);\n        }", "docstring": "\nConstructor.\n\n@param pair relayed candidate pair\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "RelayedCandidateTask", "params": [{"name": "pair", "type": "CandidatePair"}], "body": "        {\n            this.pair = pair;\n            pair.getParentComponent().getParentStream().getCheckList().\n                addChecksListener(this);\n        }", "signature": "public RelayedCandidateTask(CandidatePair pair)"}, {"syntax_pass": true, "original_string": "        public void propertyChange(PropertyChangeEvent evt)\n        {\n            // Make it clear that PROPERTY_CHECK_LIST_CHECKS is in use here.\n            if (!CheckList.PROPERTY_CHECK_LIST_CHECKS.equals(\n                        evt.getPropertyName()))\n            {\n                return;\n            }\n\n            // check list has run out of ordinary checks, see if all other\n            // candidates are FAILED, in which case we nominate immediately\n            // the relayed candidate\n            CheckList checkList = (CheckList)evt.getSource();\n            boolean allFailed = true;\n\n            synchronized (checkList)\n            {\n                for (CandidatePair c : checkList)\n                {\n                    if (c != pair && c.getState() != CandidatePairState.FAILED)\n                    {\n                        allFailed = false;\n                        break;\n                    }\n                }\n            }\n\n            if (allFailed && !pair.isNominated())\n            {\n                // all other pairs are failed to do not waste time, cancel\n                // timer and nominate ourself (the relayed candidate).\n                this.cancel();\n\n                logger.info(\n                        \"Nominate (first highest valid): \"\n                            + pair.toRedactedShortString());\n                parentAgent.nominate(pair);\n            }\n        }", "docstring": "\nTracks end of checks of the {@link CheckList}.\n\n@param evt the event\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "propertyChange", "params": [{"name": "evt", "type": "PropertyChangeEvent"}], "body": "        {\n            // Make it clear that PROPERTY_CHECK_LIST_CHECKS is in use here.\n            if (!CheckList.PROPERTY_CHECK_LIST_CHECKS.equals(\n                        evt.getPropertyName()))\n            {\n                return;\n            }\n\n            // check list has run out of ordinary checks, see if all other\n            // candidates are FAILED, in which case we nominate immediately\n            // the relayed candidate\n            CheckList checkList = (CheckList)evt.getSource();\n            boolean allFailed = true;\n\n            synchronized (checkList)\n            {\n                for (CandidatePair c : checkList)\n                {\n                    if (c != pair && c.getState() != CandidatePairState.FAILED)\n                    {\n                        allFailed = false;\n                        break;\n                    }\n                }\n            }\n\n            if (allFailed && !pair.isNominated())\n            {\n                // all other pairs are failed to do not waste time, cancel\n                // timer and nominate ourself (the relayed candidate).\n                this.cancel();\n\n                logger.info(\n                        \"Nominate (first highest valid): \"\n                            + pair.toRedactedShortString());\n                parentAgent.nominate(pair);\n            }\n        }", "signature": "public void propertyChange(PropertyChangeEvent evt)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean cancel()\n        {\n            cancelled = true;\n            return super.cancel();\n        }", "docstring": "\nCancel task.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "cancel", "params": [], "body": "        {\n            cancelled = true;\n            return super.cancel();\n        }", "signature": "@Override\n        public boolean cancel()"}, {"syntax_pass": true, "original_string": "        public void run()\n        {\n            try\n            {\n                Thread.sleep(WAIT_TIME);\n            }\n            catch (InterruptedException e)\n            {\n                cancelled = true;\n            }\n\n            Component component = pair.getParentComponent();\n\n            component.getParentStream().getCheckList().removeChecksListener(\n                    this);\n            validatedCandidates.remove(component.toShortString());\n\n            if (cancelled)\n                return;\n\n            logger.info(\n                    \"Nominate (first highest valid): \" + pair.toRedactedShortString());\n\n            // task has not been cancelled after WAIT_TIME milliseconds so\n            // nominate the pair\n            parentAgent.nominate(pair);\n        }", "docstring": "\nTask entry point.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "run", "params": [], "body": "        {\n            try\n            {\n                Thread.sleep(WAIT_TIME);\n            }\n            catch (InterruptedException e)\n            {\n                cancelled = true;\n            }\n\n            Component component = pair.getParentComponent();\n\n            component.getParentStream().getCheckList().removeChecksListener(\n                    this);\n            validatedCandidates.remove(component.toShortString());\n\n            if (cancelled)\n                return;\n\n            logger.info(\n                    \"Nominate (first highest valid): \" + pair.toRedactedShortString());\n\n            // task has not been cancelled after WAIT_TIME milliseconds so\n            // nominate the pair\n            parentAgent.nominate(pair);\n        }", "signature": "public void run()"}]}], "class_docstring": "\nImplements ice4j internal nomination strategies.\n\n@author Emil Ivov\n", "original_string": "public class DefaultNominator\n    implements PropertyChangeListener\n{\n    /**\n     * The Agent that created us.\n     */\n    private final Agent parentAgent;\n\n    /**\n     * The strategy that this nominator should use to nominate valid pairs.\n     */\n    private NominationStrategy strategy\n        = NominationStrategy.NOMINATE_FIRST_VALID;\n\n    /**\n     * Map that will remember association between validated relayed candidate\n     * and a timer. It is used with the NOMINATE_FIRST_HIGHEST_VALID strategy.\n     */\n    private final Map<String, TimerTask> validatedCandidates = new HashMap<>();\n\n    /**\n     * The {@link Logger} used by {@link DefaultNominator} instances.\n     */\n    private Logger logger;\n\n    /**\n     * Creates a new instance of this nominator using <tt>parentAgent</tt> as\n     * a reference to the <tt>Agent</tt> instance that we should use to\n     * nominate pairs.\n     *\n     * @param parentAgent the {@link Agent} that created us.\n     */\n    public DefaultNominator(Agent parentAgent)\n    {\n        this.parentAgent = parentAgent;\n        logger = parentAgent.getLogger().createChildLogger(this.getClass().getName());\n        parentAgent.addStateChangeListener(this);\n    }\n\n    /**\n     * Tracks changes of state in {@link IceMediaStream}s and {@link\n     * CheckList}s.\n     *\n     * @param ev the event that we should use in case it means we should\n     * nominate someone.\n     */\n    public void propertyChange(PropertyChangeEvent ev)\n    {\n        String propertyName = ev.getPropertyName();\n\n        if (Agent.PROPERTY_ICE_PROCESSING_STATE.equals(propertyName))\n        {\n            if (ev.getNewValue() != IceProcessingState.RUNNING)\n                return;\n\n            for (IceMediaStream stream : parentAgent.getStreams())\n            {\n                stream.addPairChangeListener(this);\n                stream.getCheckList().addStateChangeListener(this);\n            }\n        }\n\n        if (!parentAgent.isControlling() //CONTROLLED agents cannot nominate\n                || strategy == NominationStrategy.NONE)\n        {\n            return;\n        }\n\n        if (ev.getSource() instanceof CandidatePair)\n        {\n            // STUN Usage for Consent Freshness is of no concern here.\n            if (IceMediaStream.PROPERTY_PAIR_CONSENT_FRESHNESS_CHANGED.equals(propertyName))\n            {\n                return;\n            }\n\n            CandidatePair validPair = (CandidatePair) ev.getSource();\n            Component parentComponent = validPair.getParentComponent();\n            IceMediaStream parentStream = parentComponent.getParentStream();\n\n            // do not nominate pair if there is currently a nominated pair for\n            // the component\n            if (parentStream.validListContainsNomineeForComponent(parentComponent))\n            {\n                logger.debug(() ->\n                        \"Keep-alive for pair: \" + validPair.toRedactedShortString());\n                return;\n            }\n        }\n\n        if (strategy == NominationStrategy.NOMINATE_FIRST_VALID)\n            strategyNominateFirstValid(ev);\n        else if (strategy == NominationStrategy.NOMINATE_HIGHEST_PRIO)\n            strategyNominateHighestPrio(ev);\n        else if (strategy\n                == NominationStrategy.NOMINATE_FIRST_HOST_OR_REFLEXIVE_VALID)\n            strategyNominateFirstHostOrReflexiveValid(ev);\n    }\n\n    /**\n     * Implements a basic nomination strategy that consists in nominating the\n     * first pair that has become valid for a check list.\n     *\n     * @param evt the {@link PropertyChangeEvent} containing the pair which\n     * has been validated.\n     */\n    private void strategyNominateFirstValid(PropertyChangeEvent evt)\n    {\n        if (IceMediaStream.PROPERTY_PAIR_VALIDATED\n                    .equals(evt.getPropertyName()))\n        {\n            CandidatePair validPair = (CandidatePair)evt.getSource();\n\n            logger.info(\"Nominate (first valid): \" + validPair.toRedactedShortString()\n                + \".\");\n            parentAgent.nominate(validPair);\n        }\n    }\n\n    /**\n     * Implements a nomination strategy that allows checks for several (or all)\n     * pairs in a check list to conclude before nominating the one with the\n     * highest priority.\n     *\n     * @param ev the {@link PropertyChangeEvent} containing the new state and\n     * the source {@link CheckList}.\n     */\n    private void strategyNominateHighestPrio(PropertyChangeEvent ev)\n    {\n        String pname = ev.getPropertyName();\n\n        if (IceMediaStream.PROPERTY_PAIR_VALIDATED.equals(pname)\n                || (IceMediaStream.PROPERTY_PAIR_STATE_CHANGED.equals(pname)\n                        && (ev.getNewValue() == CandidatePairState.FAILED)))\n        {\n            CandidatePair validPair = (CandidatePair) ev.getSource();\n            Component parentComponent = validPair.getParentComponent();\n            IceMediaStream parentStream = parentComponent.getParentStream();\n            CheckList parentCheckList = parentStream.getCheckList();\n\n            if (!parentCheckList.allChecksCompleted())\n                return;\n\n            for (Component component : parentStream.getComponents())\n            {\n                CandidatePair pair = parentStream.getValidPair(component);\n\n                if (pair != null)\n                {\n                    logger.info(\n                            \"Nominate (highest priority): \"\n                                + validPair.toRedactedShortString());\n                    parentAgent.nominate(pair);\n                }\n            }\n        }\n    }\n\n    /**\n     * The {@link NominationStrategy} that this nominator is using when\n     * deciding whether or not a valid {@link CandidatePair} is suitable for\n     * nomination.\n     *\n     * @return the {@link NominationStrategy} we are using.\n     */\n    public NominationStrategy getStrategy()\n    {\n        return strategy;\n    }\n\n    /**\n     * The {@link NominationStrategy} that this nominator should use when\n     * deciding whether or not a valid {@link CandidatePair} is suitable for\n     * nomination.\n     *\n     * @param strategy the {@link NominationStrategy} we should be using.\n     */\n    public void setStrategy(NominationStrategy strategy)\n    {\n        this.strategy = strategy;\n    }\n\n    /**\n     * Implements a nomination strategy that consists in nominating directly\n     * host or server reflexive pair that has become valid for a\n     * check list. For relayed pair, a timer is armed to see if no other host or\n     * server reflexive pair gets validated prior to timeout, the relayed ones\n     * gets nominated.\n     *\n     * @param evt the {@link PropertyChangeEvent} containing the pair which\n     * has been validated.\n     */\n    private void strategyNominateFirstHostOrReflexiveValid(\n            PropertyChangeEvent evt)\n    {\n        if (IceMediaStream.PROPERTY_PAIR_VALIDATED.equals(evt.getPropertyName()))\n        {\n            CandidatePair validPair = (CandidatePair) evt.getSource();\n\n            Component component = validPair.getParentComponent();\n            LocalCandidate localCandidate = validPair.getLocalCandidate();\n            boolean isRelayed\n                = (localCandidate instanceof RelayedCandidate)\n                    || localCandidate.getType().equals(\n                            CandidateType.RELAYED_CANDIDATE)\n                    || validPair.getRemoteCandidate().getType().equals(\n                            CandidateType.RELAYED_CANDIDATE);\n            boolean nominate = false;\n\n            synchronized (validatedCandidates)\n            {\n                TimerTask task\n                    = validatedCandidates.get(component.toShortString());\n\n                if (isRelayed && task == null)\n                {\n                    /* armed a timer and see if a host or server reflexive pair\n                     * gets nominated. Otherwise nominate the relayed candidate\n                     * pair\n                     */\n                    Timer timer = new Timer();\n                    task = new RelayedCandidateTask(validPair);\n\n                    logger.info(\"Wait timeout to nominate relayed candidate\");\n                    timer.schedule(task, 0);\n                    validatedCandidates.put(component.toShortString(), task);\n                }\n                else if (!isRelayed)\n                {\n                    // host or server reflexive candidate pair\n                    if (task != null)\n                    {\n                        task.cancel();\n                        logger.info(\n                                \"Found a better candidate pair to nominate for \"\n                                    + component.toShortString());\n                    }\n\n                    logger.info(\n                            \"Nominate (first highest valid): \"\n                                + validPair.toRedactedShortString());\n                    nominate = true;\n                }\n            }\n\n            if (nominate)\n                parentAgent.nominate(validPair);\n        }\n    }\n\n    /**\n     * TimerTask that will wait a certain amount of time to let other candidate\n     * pair to be validated and possibly be better than the relayed candidate.\n     *\n     * @author Sebastien Vincent\n     */\n    private class RelayedCandidateTask\n        extends TimerTask\n        implements PropertyChangeListener\n    {\n        /**\n         * Wait time in milliseconds.\n         */\n        private static final int WAIT_TIME = 800;\n\n        /**\n         * The relayed candidate pair.\n         */\n        private final CandidatePair pair;\n\n        /**\n         * If the task has been cancelled.\n         */\n        private boolean cancelled = false;\n\n        /**\n         * Constructor.\n         *\n         * @param pair relayed candidate pair\n         */\n        public RelayedCandidateTask(CandidatePair pair)\n        {\n            this.pair = pair;\n            pair.getParentComponent().getParentStream().getCheckList().\n                addChecksListener(this);\n        }\n\n        /**\n         * Tracks end of checks of the {@link CheckList}.\n         *\n         * @param evt the event\n         */\n        public void propertyChange(PropertyChangeEvent evt)\n        {\n            // Make it clear that PROPERTY_CHECK_LIST_CHECKS is in use here.\n            if (!CheckList.PROPERTY_CHECK_LIST_CHECKS.equals(\n                        evt.getPropertyName()))\n            {\n                return;\n            }\n\n            // check list has run out of ordinary checks, see if all other\n            // candidates are FAILED, in which case we nominate immediately\n            // the relayed candidate\n            CheckList checkList = (CheckList)evt.getSource();\n            boolean allFailed = true;\n\n            synchronized (checkList)\n            {\n                for (CandidatePair c : checkList)\n                {\n                    if (c != pair && c.getState() != CandidatePairState.FAILED)\n                    {\n                        allFailed = false;\n                        break;\n                    }\n                }\n            }\n\n            if (allFailed && !pair.isNominated())\n            {\n                // all other pairs are failed to do not waste time, cancel\n                // timer and nominate ourself (the relayed candidate).\n                this.cancel();\n\n                logger.info(\n                        \"Nominate (first highest valid): \"\n                            + pair.toRedactedShortString());\n                parentAgent.nominate(pair);\n            }\n        }\n\n        /**\n         * Cancel task.\n         */\n        @Override\n        public boolean cancel()\n        {\n            cancelled = true;\n            return super.cancel();\n        }\n\n        /**\n         * Task entry point.\n         */\n        public void run()\n        {\n            try\n            {\n                Thread.sleep(WAIT_TIME);\n            }\n            catch (InterruptedException e)\n            {\n                cancelled = true;\n            }\n\n            Component component = pair.getParentComponent();\n\n            component.getParentStream().getCheckList().removeChecksListener(\n                    this);\n            validatedCandidates.remove(component.toShortString());\n\n            if (cancelled)\n                return;\n\n            logger.info(\n                    \"Nominate (first highest valid): \" + pair.toRedactedShortString());\n\n            // task has not been cancelled after WAIT_TIME milliseconds so\n            // nominate the pair\n            parentAgent.nominate(pair);\n        }\n    }\n}", "super_interfaces": ["PropertyChangeListener"], "fields": [{"attribute_expression": "private final Agent parentAgent;", "docstring": "\nThe Agent that created us.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Agent", "name": "parentAgent", "syntax_pass": true}, {"attribute_expression": "private NominationStrategy strategy\n        = NominationStrategy.NOMINATE_FIRST_VALID;", "docstring": "\nThe strategy that this nominator should use to nominate valid pairs.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "NominationStrategy", "name": "strategy\n        = NominationStrategy.NOMINATE_FIRST_VALID", "syntax_pass": true}, {"attribute_expression": "private final Map<String, TimerTask> validatedCandidates = new HashMap<>();", "docstring": "\nMap that will remember association between validated relayed candidate\nand a timer. It is used with the NOMINATE_FIRST_HIGHEST_VALID strategy.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, TimerTask>", "name": "validatedCandidates = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private Logger logger;", "docstring": "\nThe {@link Logger} used by {@link DefaultNominator} instances.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Logger", "name": "logger", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/UPNPCandidate.java.UPNPCandidate", "name": "UPNPCandidate", "file_path": "src/main/java/org/ice4j/ice/UPNPCandidate.java", "superclasses": "LocalCandidate", "methods": ["[]UPNPCandidate(TransportAddress,LocalCandidate,Component,GatewayDevice)", "[void]free()", "[IceSocketWrapper]getCandidateIceSocketWrapper()", "[IceSocketWrapper]getIceSocketWrapper()"], "method_uris": ["src/main/java/org/ice4j/ice/UPNPCandidate.java.UPNPCandidate.[]UPNPCandidate(TransportAddress,LocalCandidate,Component,GatewayDevice)", "src/main/java/org/ice4j/ice/UPNPCandidate.java.UPNPCandidate.[void]free()", "src/main/java/org/ice4j/ice/UPNPCandidate.java.UPNPCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper()", "src/main/java/org/ice4j/ice/UPNPCandidate.java.UPNPCandidate.[IceSocketWrapper]getIceSocketWrapper()"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents a <tt>Candidate</tt> obtained via UPnP.\n\n@author Sebastien Vincent\n", "original_string": "public class UPNPCandidate\n    extends LocalCandidate\n{\n    /**\n     * The UPnP gateway device.\n     */\n    private GatewayDevice device = null;\n\n    /**\n     * Creates a <tt>UPNPCandidate</tt> for the specified transport, address,\n     * and base.\n     *\n     * @param transportAddress  the transport address that this candidate is\n     * encapsulating.\n     * @param base the base candidate\n     * @param parentComponent the <tt>Component</tt> that this candidate\n     * belongs to.\n     * @param device the UPnP gateway device\n     */\n    public UPNPCandidate(TransportAddress transportAddress,\n            LocalCandidate base, Component parentComponent,\n            GatewayDevice device)\n    {\n        super(  transportAddress,\n                parentComponent,\n                CandidateType.SERVER_REFLEXIVE_CANDIDATE,\n                CandidateExtendedType.UPNP_CANDIDATE,\n                base);\n\n        this.setBase(base);\n        this.device = device;\n        setStunServerAddress(transportAddress);\n    }\n\n    /**\n     * Frees resources allocated by this candidate such as its\n     * <tt>DatagramSocket</tt>, for example. The <tt>socket</tt> of this\n     * <tt>LocalCandidate</tt> is closed only if it is not the <tt>socket</tt>\n     * of the <tt>base</tt> of this <tt>LocalCandidate</tt>.\n     */\n    @Override\n    protected void free()\n    {\n        // delete the port mapping\n        try\n        {\n            device.deletePortMapping(getTransportAddress().getPort(), \"UDP\");\n        }\n        catch(Exception e)\n        {\n        }\n\n        IceSocketWrapper socket = getCandidateIceSocketWrapper();\n        if (socket != null)\n        {\n            socket.close();\n        }\n\n        device = null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IceSocketWrapper getCandidateIceSocketWrapper()\n    {\n        return getBase().getCandidateIceSocketWrapper();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected IceSocketWrapper getIceSocketWrapper()\n    {\n        return getBase().getIceSocketWrapper();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private GatewayDevice device = null;", "docstring": "\nThe UPnP gateway device.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "GatewayDevice", "name": "device = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate", "name": "RemoteCandidate", "file_path": "src/main/java/org/ice4j/ice/RemoteCandidate.java", "superclasses": "", "methods": ["[]RemoteCandidate(TransportAddress,Component,CandidateType,String,long,RemoteCandidate)", "[]RemoteCandidate(TransportAddress,Component,CandidateType,String,long,RemoteCandidate,String)", "[void]setPriority(long)", "[boolean]isDefault()", "[String]getUfrag()", "[RemoteCandidate]findRelatedCandidate(TransportAddress)"], "method_uris": ["src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate.[]RemoteCandidate(TransportAddress,Component,CandidateType,String,long,RemoteCandidate)", "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate.[]RemoteCandidate(TransportAddress,Component,CandidateType,String,long,RemoteCandidate,String)", "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate.[void]setPriority(long)", "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate.[boolean]isDefault()", "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate.[String]getUfrag()", "src/main/java/org/ice4j/ice/RemoteCandidate.java.RemoteCandidate.[RemoteCandidate]findRelatedCandidate(TransportAddress)"], "overrides": null, "attributes": [], "class_docstring": "\n<tt>RemoteCandidate</tt>s are candidates that an agent received in an offer\nor an answer from its peer, and that it would use to form candidate pairs\nafter combining them with its local candidates.\n\n@author Emil Ivov\n", "original_string": "public class RemoteCandidate\n    extends Candidate<RemoteCandidate>\n{\n    /**\n     * Ufrag for the Google Talk candidate.\n     */\n    private String ufrag = null;\n\n    /**\n     * Creates a <tt>RemoteCandidate</tt> instance for the specified transport\n     * address and properties.\n     *\n     * @param transportAddress  the transport address that this candidate is\n     * encapsulating.\n     * @param parentComponent the <tt>Component</tt> that this candidate\n     * belongs to.\n     * @param type the <tt>CandidateType</tt> for this <tt>Candidate</tt>.\n     * @param foundation the <tt>RemoteCandidate</tt>'s foundation as reported\n     * by the session description protocol.\n     * @param priority the <tt>RemoteCandidate</tt>'s priority as reported\n     * by the session description protocol.\n     * @param relatedCandidate the relatedCandidate: null for a host candidate,\n     * the base address (host candidate) for a reflexive candidate, the mapped\n     * address (the mapped address of the TURN allocate response) for a relayed\n     * candidate.\n     */\n    public RemoteCandidate(\n            TransportAddress transportAddress,\n            Component        parentComponent,\n            CandidateType    type,\n            String           foundation,\n            long             priority,\n            RemoteCandidate  relatedCandidate)\n    {\n        this(\n                transportAddress,\n                parentComponent,\n                type,\n                foundation,\n                priority,\n                relatedCandidate,\n                null);\n    }\n\n    /**\n     * Creates a <tt>RemoteCandidate</tt> instance for the specified transport\n     * address and properties.\n     *\n     * @param transportAddress  the transport address that this candidate is\n     * encapsulating.\n     * @param parentComponent the <tt>Component</tt> that this candidate\n     * belongs to.\n     * @param type the <tt>CandidateType</tt> for this <tt>Candidate</tt>.\n     * @param foundation the <tt>RemoteCandidate</tt>'s foundation as reported\n     * by the session description protocol.\n     * @param priority the <tt>RemoteCandidate</tt>'s priority as reported\n     * by the session description protocol.\n     * @param relatedCandidate the relatedCandidate: null for a host candidate,\n     * the base address (host candidate) for a reflexive candidate, the mapped\n     * address (the mapped address of the TURN allocate response) for a relayed\n     * candidate.\n     * @param ufrag ufrag for the remote candidate\n     */\n    public RemoteCandidate(\n            TransportAddress transportAddress,\n            Component        parentComponent,\n            CandidateType    type,\n            String           foundation,\n            long             priority,\n            RemoteCandidate  relatedCandidate,\n            String            ufrag)\n    {\n        super(transportAddress, parentComponent, type, relatedCandidate);\n        setFoundation(foundation);\n        setPriority(priority);\n        this.ufrag = ufrag;\n    }\n\n    /**\n     * Sets the priority of this <tt>RemoteCandidate</tt>. Priority is a unique\n     * priority number that MUST be a positive integer between 1 and\n     * (2**32 - 1). This priority will be set and used by ICE algorithms to\n     * determine the order of the connectivity checks and the relative\n     * preference for candidates.\n     *\n     * @param priority the priority number between 1 and (2**32 - 1).\n     */\n    public void setPriority(long priority)\n    {\n        super.priority = priority;\n    }\n\n    /**\n     * Determines whether this <tt>Candidate</tt> is the default one for its\n     * parent component.\n     *\n     * @return <tt>true</tt> if this <tt>Candidate</tt> is the default for its\n     * parent component and <tt>false</tt> if it isn't or if it has no parent\n     * Component yet.\n     */\n    @Override\n    public boolean isDefault()\n    {\n        Component parentCmp = getParentComponent();\n\n        if (parentCmp == null)\n            return false;\n\n        return equals(parentCmp.getDefaultRemoteCandidate());\n    }\n\n    /**\n     * Get the remote ufrag.\n     *\n     * @return remote ufrag\n     */\n    public String getUfrag()\n    {\n        return ufrag;\n    }\n\n    /**\n     * Find the candidate corresponding to the address given in parameter.\n     *\n     * @param relatedAddress The related address:\n     * - null for a host candidate,\n     * - the base address (host candidate) for a reflexive candidate,\n     * - the mapped address (the mapped address of the TURN allocate response)\n     * for a relayed candidate.\n     * - null for a peer reflexive candidate : there is no way to know the\n     * related address.\n     *\n     * @return The related candidate corresponding to the address given in\n     * parameter:\n     * - null for a host candidate,\n     * - the base address (host candidate) for a reflexive candidate,\n     * - the mapped address (the mapped address of the TURN allocate response)\n     * for a relayed candidate.\n     * - null for a peer reflexive candidate : there is no way to know the\n     * related address.\n     */\n    protected RemoteCandidate findRelatedCandidate(\n            TransportAddress relatedAddress)\n    {\n        return getParentComponent().findRemoteCandidate(relatedAddress);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private String ufrag = null;", "docstring": "\nUfrag for the Google Talk candidate.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "ufrag = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/PeerReflexiveCandidate.java.PeerReflexiveCandidate", "name": "PeerReflexiveCandidate", "file_path": "src/main/java/org/ice4j/ice/PeerReflexiveCandidate.java", "superclasses": "LocalCandidate", "methods": ["[]PeerReflexiveCandidate(TransportAddress,Component,LocalCandidate,long)", "[IceSocketWrapper]getCandidateIceSocketWrapper()"], "method_uris": ["src/main/java/org/ice4j/ice/PeerReflexiveCandidate.java.PeerReflexiveCandidate.[]PeerReflexiveCandidate(TransportAddress,Component,LocalCandidate,long)", "src/main/java/org/ice4j/ice/PeerReflexiveCandidate.java.PeerReflexiveCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper()"], "overrides": null, "attributes": [], "class_docstring": "\nPeer Reflexive Candidates are candidates whose IP address and port are a\nbinding explicitly allocated by a NAT for an agent when it sent a STUN\nBinding request through the NAT to its peer.\n<p>\nPeer Reflexive Candidates are generally allocated by NATs with endpoint\ndependent mapping also known as Symmetric NATs. PeerReflexiveCandidates\nare generally preferred to relayed ones. RFC 5245 explains this with\nbetter security ... although simply avoiding a relay would probably be\nenough of a reason for many.\n\n@author Emil Ivov\n", "original_string": "public class PeerReflexiveCandidate\n    extends LocalCandidate\n{\n    /**\n     * Creates a <tt>PeerReflexiveCandidate</tt> instance for the specified\n     * transport address and properties.\n     *\n     * @param transportAddress  the transport address that this candidate is\n     * encapsulating.\n     * @param parentComponent the <tt>Component</tt> that this candidate\n     * belongs to.\n     * @param base the base of a peer reflexive candidate base is the local\n     * candidate of the candidate pair from which the STUN check was sent.\n     * @param priority the priority of the candidate.\n     */\n    public PeerReflexiveCandidate(TransportAddress transportAddress,\n                                  Component        parentComponent,\n                                  LocalCandidate   base,\n                                  long             priority)\n    {\n        super(\n                transportAddress,\n                parentComponent,\n                CandidateType.PEER_REFLEXIVE_CANDIDATE,\n                CandidateExtendedType.STUN_PEER_REFLEXIVE_CANDIDATE,\n                base);\n        super.setBase(base);\n        super.priority = priority;\n        super.setTcpType(base.getTcpType());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IceSocketWrapper getCandidateIceSocketWrapper()\n    {\n        return getBase().getCandidateIceSocketWrapper();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient", "name": "ConnectivityCheckClient", "file_path": "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java", "superclasses": "", "methods": ["[]ConnectivityCheckClient(Agent,ScheduledExecutorService,ExecutorService)", "[boolean]isAlive()", "[void]startChecks()", "[void]startChecks(CheckList)", "[void]sendBindingIndicationForPair(CandidatePair)", "[TransactionID]startCheckForPair(CandidatePair)", "[TransactionID]startCheckForPair(CandidatePair,int,int,int)", "[void]processResponse(StunResponseEvent)", "[void]updateCheckListAndTimerStates(CandidatePair)", "[void]processSuccessResponse(StunResponseEvent)", "[boolean]checkSymmetricAddresses(StunResponseEvent)", "[void]processErrorResponse(StunResponseEvent)", "[void]processTimeout(StunTimeoutEvent)", "[void]stop()", "[boolean]isStopped()"], "method_uris": ["src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[]ConnectivityCheckClient(Agent,ScheduledExecutorService,ExecutorService)", "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[boolean]isAlive()", "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]startChecks()", "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]startChecks(CheckList)", "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]sendBindingIndicationForPair(CandidatePair)", "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[TransactionID]startCheckForPair(CandidatePair)", "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[TransactionID]startCheckForPair(CandidatePair,int,int,int)", "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]processResponse(StunResponseEvent)", "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]updateCheckListAndTimerStates(CandidatePair)", "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]processSuccessResponse(StunResponseEvent)", "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[boolean]checkSymmetricAddresses(StunResponseEvent)", "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]processErrorResponse(StunResponseEvent)", "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]processTimeout(StunTimeoutEvent)", "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[void]stop()", "src/main/java/org/ice4j/ice/ConnectivityCheckClient.java.ConnectivityCheckClient.[boolean]isStopped()"], "overrides": null, "attributes": [{"original_string": "    private final class PaceMaker extends PeriodicRunnable\n    {\n        /**\n         * The {@link CheckList} that this <tt>PaceMaker</tt> will be running\n         * checks for.\n         */\n        private final CheckList checkList;\n\n        /**\n         * Whether this is the first time this {@link PaceMaker} has been run.\n         * We want to run the initial check for a checklist as soon as connectivity\n         * checking is started, with no delay.\n         */\n        private boolean firstRun = true;\n\n        /**\n         * Creates a new {@link PaceMaker} for this\n         * <tt>ConnectivityCheckClient</tt>.\n         *\n         * @param checkList the {@link CheckList} that we'll be sending checks\n         * for\n         */\n        public PaceMaker(CheckList checkList)\n        {\n            super(scheduledExecutorService, executorService);\n            this.checkList = checkList;\n        }\n\n        /**\n         * Sends connectivity checks at the pace determined by the {@link\n         * Agent#calculateTa()} method and using either the trigger check queue\n         * or the regular check lists.\n         */\n        @Override\n        protected void run()\n        {\n            CandidatePair pairToCheck = checkList.popTriggeredCheck();\n\n            //if there are no triggered checks, go for an ordinary one.\n            if (pairToCheck == null)\n            {\n                pairToCheck = checkList.getNextOrdinaryPairToCheck();\n            }\n\n            if (pairToCheck != null)\n            {\n                /*\n                 * Since we suspect that it is possible to\n                 * startCheckForPair, processSuccessResponse and only\n                 * then setStateInProgress, we'll synchronize. The\n                 * synchronization root is the one of the\n                 * CandidatePair#setState method.\n                 */\n                synchronized (pairToCheck)\n                {\n                    TransactionID transactionID\n                        = startCheckForPair(pairToCheck);\n\n                    if (transactionID == null)\n                    {\n                        logger.info(\n                            \"Pair failed: \"\n                                + pairToCheck.toRedactedShortString());\n                        pairToCheck.setStateFailed();\n                    }\n                    else\n                    {\n                        pairToCheck.setStateInProgress(transactionID);\n                    }\n                }\n            }\n            else\n            {\n                /*\n                 * We are done sending checks for this list. We'll set\n                 * its final state in either the processResponse(),\n                 * processTimeout() or processFailure() method.\n                 */\n                logger.trace(() -> \"will skip a check beat.\");\n                checkList.fireEndOfOrdinaryChecks();\n            }\n        }\n\n        /**\n         * Returns the number milliseconds to wait before we send the next\n         * check.\n         *\n         * @return  the number milliseconds to wait before we send the next\n         * check.\n         */\n        protected Duration getDelayUntilNextRun()\n        {\n            if (firstRun)\n            {\n                /* Run first check immediately. */\n                firstRun = false;\n                return Duration.ZERO;\n            }\n\n            int activeCheckLists = parentAgent.getActiveCheckListCount();\n\n            if (activeCheckLists < 1)\n            {\n                //don't multiply by 0. even when we no longer have active check\n                //lists we may still have nomination checks to\n                activeCheckLists = 1;\n            }\n\n            return Duration.ofMillis(parentAgent.calculateTa() * activeCheckLists);\n        }\n    }", "definition": "    private final class PaceMaker extends PeriodicRunnable", "class_docstring": "\nA class to control periodically scheduled runnable that actually sends\nthe checks for a particular check list in the pace defined in RFC 5245.\n", "name": "PaceMaker", "super_interfaces": [], "superclasses": "PeriodicRunnable", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private final CheckList checkList;", "docstring": "\nThe {@link CheckList} that this <tt>PaceMaker</tt> will be running\nchecks for.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CheckList", "name": "checkList", "syntax_pass": true}, {"attribute_expression": "private boolean firstRun = true;", "docstring": "\nWhether this is the first time this {@link PaceMaker} has been run.\nWe want to run the initial check for a checklist as soon as connectivity\nchecking is started, with no delay.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "firstRun = true", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public PaceMaker(CheckList checkList)\n        {\n            super(scheduledExecutorService, executorService);\n            this.checkList = checkList;\n        }", "docstring": "\nCreates a new {@link PaceMaker} for this\n<tt>ConnectivityCheckClient</tt>.\n\n@param checkList the {@link CheckList} that we'll be sending checks\nfor\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "PaceMaker", "params": [{"name": "checkList", "type": "CheckList"}], "body": "        {\n            super(scheduledExecutorService, executorService);\n            this.checkList = checkList;\n        }", "signature": "public PaceMaker(CheckList checkList)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected void run()\n        {\n            CandidatePair pairToCheck = checkList.popTriggeredCheck();\n\n            //if there are no triggered checks, go for an ordinary one.\n            if (pairToCheck == null)\n            {\n                pairToCheck = checkList.getNextOrdinaryPairToCheck();\n            }\n\n            if (pairToCheck != null)\n            {\n                /*\n                 * Since we suspect that it is possible to\n                 * startCheckForPair, processSuccessResponse and only\n                 * then setStateInProgress, we'll synchronize. The\n                 * synchronization root is the one of the\n                 * CandidatePair#setState method.\n                 */\n                synchronized (pairToCheck)\n                {\n                    TransactionID transactionID\n                        = startCheckForPair(pairToCheck);\n\n                    if (transactionID == null)\n                    {\n                        logger.info(\n                            \"Pair failed: \"\n                                + pairToCheck.toRedactedShortString());\n                        pairToCheck.setStateFailed();\n                    }\n                    else\n                    {\n                        pairToCheck.setStateInProgress(transactionID);\n                    }\n                }\n            }\n            else\n            {\n                /*\n                 * We are done sending checks for this list. We'll set\n                 * its final state in either the processResponse(),\n                 * processTimeout() or processFailure() method.\n                 */\n                logger.trace(() -> \"will skip a check beat.\");\n                checkList.fireEndOfOrdinaryChecks();\n            }\n        }", "docstring": "\nSends connectivity checks at the pace determined by the {@link\nAgent#calculateTa()} method and using either the trigger check queue\nor the regular check lists.\n", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "run", "params": [], "body": "        {\n            CandidatePair pairToCheck = checkList.popTriggeredCheck();\n\n            //if there are no triggered checks, go for an ordinary one.\n            if (pairToCheck == null)\n            {\n                pairToCheck = checkList.getNextOrdinaryPairToCheck();\n            }\n\n            if (pairToCheck != null)\n            {\n                /*\n                 * Since we suspect that it is possible to\n                 * startCheckForPair, processSuccessResponse and only\n                 * then setStateInProgress, we'll synchronize. The\n                 * synchronization root is the one of the\n                 * CandidatePair#setState method.\n                 */\n                synchronized (pairToCheck)\n                {\n                    TransactionID transactionID\n                        = startCheckForPair(pairToCheck);\n\n                    if (transactionID == null)\n                    {\n                        logger.info(\n                            \"Pair failed: \"\n                                + pairToCheck.toRedactedShortString());\n                        pairToCheck.setStateFailed();\n                    }\n                    else\n                    {\n                        pairToCheck.setStateInProgress(transactionID);\n                    }\n                }\n            }\n            else\n            {\n                /*\n                 * We are done sending checks for this list. We'll set\n                 * its final state in either the processResponse(),\n                 * processTimeout() or processFailure() method.\n                 */\n                logger.trace(() -> \"will skip a check beat.\");\n                checkList.fireEndOfOrdinaryChecks();\n            }\n        }", "signature": "@Override\n        protected void run()"}, {"syntax_pass": true, "original_string": "        protected Duration getDelayUntilNextRun()\n        {\n            if (firstRun)\n            {\n                /* Run first check immediately. */\n                firstRun = false;\n                return Duration.ZERO;\n            }\n\n            int activeCheckLists = parentAgent.getActiveCheckListCount();\n\n            if (activeCheckLists < 1)\n            {\n                //don't multiply by 0. even when we no longer have active check\n                //lists we may still have nomination checks to\n                activeCheckLists = 1;\n            }\n\n            return Duration.ofMillis(parentAgent.calculateTa() * activeCheckLists);\n        }", "docstring": "\nReturns the number milliseconds to wait before we send the next\ncheck.\n\n@return  the number milliseconds to wait before we send the next\ncheck.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Duration", "classes": []}, "name": "getDelayUntilNextRun", "params": [], "body": "        {\n            if (firstRun)\n            {\n                /* Run first check immediately. */\n                firstRun = false;\n                return Duration.ZERO;\n            }\n\n            int activeCheckLists = parentAgent.getActiveCheckListCount();\n\n            if (activeCheckLists < 1)\n            {\n                //don't multiply by 0. even when we no longer have active check\n                //lists we may still have nomination checks to\n                activeCheckLists = 1;\n            }\n\n            return Duration.ofMillis(parentAgent.calculateTa() * activeCheckLists);\n        }", "signature": "protected Duration getDelayUntilNextRun()"}]}], "class_docstring": "\nThe class that will be generating our outgoing connectivity checks and that\nwill be handling their responses or lack thereof.\n\n@author Emil Ivov\n@author Lyubomir Marinov\n", "original_string": "class ConnectivityCheckClient\n    implements ResponseCollector\n{\n    /**\n     * The agent that created us.\n     */\n    private final Agent parentAgent;\n\n    /**\n     * A scheduled executor service to perform periodic tasks of the client\n     */\n    private final ScheduledExecutorService scheduledExecutorService;\n\n    /**\n     * An executor service to perform background tasks of the client\n     */\n    private final ExecutorService executorService;\n\n    /**\n     * The <tt>StunStack</tt> that we will use for connectivity checks.\n     */\n    private final StunStack stunStack;\n\n    /**\n     * The {@link PaceMaker}s that are currently running checks in this client.\n     */\n    private final Queue<PaceMaker> paceMakers\n        = new ConcurrentLinkedQueue<>();\n\n    /**\n     * Whether this {@link ConnectivityCheckClient} has been stopped.\n     * Synchronized by {@link #paceMakers}.\n     */\n    private boolean stopped = false;\n\n    /**\n     * Timer that is used to let some seconds before a CheckList is considered\n     * as FAILED.\n     */\n    private ConcurrentMap<String, ScheduledFuture<?>>\n        checkListCompletionCheckers = new ConcurrentHashMap<>();\n\n    /**\n     * A flag that determines whether we have received a STUN response or not.\n     */\n    private boolean alive = false;\n\n    /**\n     * The {@link Logger} used by {@link ConnectivityCheckClient} instances.\n     */\n    private Logger logger;\n\n    /**\n     * Creates a new <tt>ConnectivityCheckClient</tt> setting\n     * <tt>parentAgent</tt> as the agent that will be used for retrieving\n     * information such as user fragments for example.\n     *\n     * @param parentAgent the <tt>Agent</tt> that is creating this instance.\n     * @param scheduledExecutorService the <tt>ScheduledExecutorService</tt>\n     *                                 to execute clients tasks\n     * @param executorService the <tt>ExecutorService</tt> to execute\n     *                        background tasks of connectivity check client\n     */\n    public ConnectivityCheckClient(\n        Agent parentAgent,\n        ScheduledExecutorService scheduledExecutorService,\n        ExecutorService executorService)\n    {\n        this.parentAgent = parentAgent;\n        this.scheduledExecutorService = scheduledExecutorService;\n        this.executorService = executorService;\n        logger = parentAgent.getLogger().createChildLogger(this.getClass().getName());\n\n        stunStack = this.parentAgent.getStunStack();\n    }\n\n    /**\n     * Returns a boolean value indicating whether we have received a STUN\n     * response or not.\n     *\n     * Note that this should NOT be taken as an indication that the negotiation\n     * has succeeded, it merely indicates that we have received ANY STUN\n     * response, possibly a BINDING_ERROR_RESPONSE. It is completely\n     * unrelated/independent from the ICE spec and it's only meant to be used\n     * for debugging purposes.\n     *\n     * @return a boolean value indicating whether we have received a STUN\n     * response or not.\n     */\n    boolean isAlive()\n    {\n        return alive;\n    }\n\n    /**\n     * Starts client connectivity checks for the first {@link IceMediaStream}\n     * in our parent {@link Agent}. This method should only be called by\n     * the parent {@link Agent} when connectivity establishment starts for a\n     * particular check list.\n     */\n    public void startChecks()\n    {\n        List<IceMediaStream> streamsWithPendingConnectivityEstablishment\n            = parentAgent.getStreamsWithPendingConnectivityEstablishment();\n\n        if (streamsWithPendingConnectivityEstablishment.size() > 0)\n        {\n            logger.info(\"Start connectivity checks.\");\n            startChecks(\n                    streamsWithPendingConnectivityEstablishment\n                        .get(0).getCheckList());\n        }\n        else\n        {\n            logger.info(\"Not starting any checks, because there are no pending \"\n                                + \"streams.\");\n        }\n    }\n\n    /**\n     * Starts client connectivity checks for the {@link CandidatePair}s in\n     *  <tt>checkList</tt>\n     *\n     * @param checkList the {@link CheckList} to start client side connectivity\n     * checks for.\n     */\n    public void startChecks(CheckList checkList)\n    {\n        synchronized (paceMakers)\n        {\n            if (stopped)\n            {\n                return;\n            }\n            PaceMaker paceMaker = new PaceMaker(checkList);\n            paceMakers.add(paceMaker);\n            paceMaker.schedule();\n        }\n    }\n\n    /**\n     * Creates a STUN Binding {@link Indication} to a candidate pair. It is used\n     * as a keep-alive.\n     *\n     * @param candidatePair that {@link CandidatePair} that we'd like to send\n     * an indication\n     */\n    protected void sendBindingIndicationForPair(CandidatePair candidatePair)\n    {\n        LocalCandidate localCandidate = candidatePair.getLocalCandidate();\n        Indication indication = MessageFactory.createBindingIndication();\n\n        try\n        {\n            stunStack.sendIndication(\n                    indication,\n                    candidatePair.getRemoteCandidate().getTransportAddress(),\n                    localCandidate.getBase().getTransportAddress());\n            logger.trace(() ->\n                    \"sending binding indication to pair \" + candidatePair);\n        }\n        catch (Exception ex)\n        {\n            IceSocketWrapper stunSocket = localCandidate.getStunSocket(null);\n\n            if (stunSocket != null)\n            {\n                logger.info(\"Failed to send \" + indication + \" through \"\n                            + stunSocket.getLocalSocketAddress() + \"\\n\" +\n                        ex.toString());\n            }\n        }\n    }\n\n    /**\n     * Creates a STUN {@link Request} containing the necessary PRIORITY and\n     * CONTROLLING/CONTROLLED attributes. Also stores a reference to\n     * <tt>candidatePair</tt> in the newly created transactionID so that we\n     * could then refer back to it in subsequent response or failure events.\n     *\n     * @param candidatePair that {@link CandidatePair} that we'd like to start\n     * a check for.\n     *\n     * @return a reference to the {@link TransactionID} used in the connectivity\n     * check client transaction or <tt>null</tt> if sending the check has\n     * failed for some reason.\n     */\n    protected TransactionID startCheckForPair(CandidatePair candidatePair)\n    {\n        return startCheckForPair(candidatePair, -1, -1, -1);\n    }\n\n    /**\n     * Creates a STUN {@link Request} containing the necessary PRIORITY and\n     * CONTROLLING/CONTROLLED attributes. Also stores a reference to\n     * <tt>candidatePair</tt> in the newly created transactionID so that we\n     * could then refer back to it in subsequent response or failure events.\n     *\n     * @param candidatePair that {@link CandidatePair} that we'd like to start\n     * a check for.\n     * @param originalWaitInterval\n     * @param maxWaitInterval\n     * @param maxRetransmissions\n     * @return a reference to the {@link TransactionID} used in the connectivity\n     * check client transaction or <tt>null</tt> if sending the check has\n     * failed for some reason.\n     */\n    protected TransactionID startCheckForPair(\n            CandidatePair candidatePair,\n            int originalWaitInterval,\n            int maxWaitInterval,\n            int maxRetransmissions)\n    {\n        LocalCandidate localCandidate = candidatePair.getLocalCandidate();\n        //we don't need to do a canReach() verification here as it has been\n        //already verified during the gathering process.\n\n        Request request = MessageFactory.createBindingRequest();\n\n        //the priority we'd like the remote party to use for a peer\n        //reflexive candidate if one is discovered as a consequence of this\n        //check.\n        PriorityAttribute priority\n            = AttributeFactory.createPriorityAttribute(\n                    localCandidate.computePriorityForType(\n                            CandidateType.PEER_REFLEXIVE_CANDIDATE));\n\n        request.putAttribute(priority);\n\n        //controlling controlled\n        if (parentAgent.isControlling())\n        {\n            request.putAttribute(\n                    AttributeFactory.createIceControllingAttribute(\n                            parentAgent.getTieBreaker()));\n\n            //if we are the controlling agent then we need to indicate our\n            //nominated pairs.\n            if (candidatePair.isNominated())\n            {\n                logger.debug(() ->\n                        \"Add USE-CANDIDATE in check for: \"\n                            + candidatePair.toRedactedShortString());\n                request.putAttribute(\n                        AttributeFactory.createUseCandidateAttribute());\n            }\n        }\n        else\n        {\n            request.putAttribute(\n                    AttributeFactory.createIceControlledAttribute(\n                            parentAgent.getTieBreaker()));\n        }\n\n        //credentials\n        String media\n            = candidatePair\n                .getParentComponent().getParentStream().getName();\n        String localUserName = parentAgent.generateLocalUserName(media);\n\n        if (localUserName == null)\n            return null;\n\n        UsernameAttribute unameAttr\n            = AttributeFactory.createUsernameAttribute(localUserName);\n\n        request.putAttribute(unameAttr);\n\n        // TODO Also implement SASL prepare\n        MessageIntegrityAttribute msgIntegrity\n            = AttributeFactory.createMessageIntegrityAttribute(\n                    localUserName);\n\n        // when we will encode the MESSAGE-INTEGRITY attribute (thus\n        // generate the HMAC-SHA1 authentication), we need to know the\n        // remote key of the current stream, that why we pass the media\n        // name.\n        msgIntegrity.setMedia(media);\n        request.putAttribute(msgIntegrity);\n\n        TransactionID tran = TransactionID.createNewTransactionID();\n\n        tran.setApplicationData(candidatePair);\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\n                    \"start check for \" + candidatePair.toRedactedShortString() + \" tid \"\n                            + tran);\n        }\n        try\n        {\n            tran\n                = stunStack.sendRequest(\n                        request,\n                        candidatePair\n                            .getRemoteCandidate().getTransportAddress(),\n                        localCandidate.getBase().getTransportAddress(),\n                        this,\n                        tran,\n                        originalWaitInterval,\n                        maxWaitInterval,\n                        maxRetransmissions);\n            if (logger.isTraceEnabled())\n            {\n                logger.trace(\"checking pair \" + candidatePair.toRedactedString() + \" tid \" + tran);\n            }\n        }\n        catch (NetAccessManager.SocketNotFoundException e)\n        {\n            logger.info(\"Could not start connectivity check: \" + e.getMessage());\n        }\n        catch (Exception ex)\n        {\n            tran = null;\n\n            IceSocketWrapper stunSocket = localCandidate.getStunSocket(null);\n\n            if (stunSocket != null)\n            {\n                String msg\n                    = \"Failed to send \" + request + \" through \"\n                        + stunSocket.getLocalSocketAddress() + \".\";\n\n                if ((ex instanceof NoRouteToHostException)\n                        || (ex.getMessage() != null\n                                && ex.getMessage().equals(\"No route to host\")))\n                {\n                    msg += \" No route to host.\";\n                    ex = null;\n                }\n                logger.info(msg + (ex == null ? \"\" : \"\\n\" + ex.toString()));\n            }\n            else\n            {\n                logger.warn(\"Failed to send \" + request, ex);\n            }\n        }\n\n        return tran;\n    }\n\n    /**\n     * Handles the <tt>response</tt> as per the procedures described in RFC 5245\n     * or in other words, by either changing the state of the corresponding pair\n     * to FAILED, or SUCCEEDED, or rescheduling a check in case of a role\n     * conflict.\n     *\n     * @param ev the {@link StunResponseEvent} that contains the newly received\n     * response.\n     */\n    public void processResponse(StunResponseEvent ev)\n    {\n        alive = true;\n\n        CandidatePair checkedPair\n            = (CandidatePair) ev.getTransactionID().getApplicationData();\n\n        //make sure that the response came from the right place.\n        if (!checkSymmetricAddresses(ev))\n        {\n            logger.info(\"Received a non-symmetric response for pair: \"\n                                + checkedPair.toRedactedShortString() + \". Failing.\");\n            checkedPair.setStateFailed();\n        }\n        else\n        {\n            Response response = ev.getResponse();\n            char messageType = response.getMessageType();\n\n            //handle error responses.\n            if (messageType == Response.BINDING_ERROR_RESPONSE)\n            {\n                if (!response.containsAttribute(Attribute.ERROR_CODE))\n                {\n                    logger.debug(() -> \"Received a malformed error response.\");\n                    return; //malformed error response\n                }\n\n                processErrorResponse(ev);\n            }\n            //handle success responses.\n            else if (messageType == Response.BINDING_SUCCESS_RESPONSE)\n            {\n                processSuccessResponse(ev);\n            }\n        }\n\n        //Regardless of whether the check was successful or failed, the\n        //completion of the transaction may require updating of check list and\n        //timer states.\n        updateCheckListAndTimerStates(checkedPair);\n    }\n\n    /**\n     * Updates all check list and timer states after a check has completed\n     * (both if completion was successful or not). The method implements\n     * section \"7.1.3.3. Check List and Timer State Updates\"\n     *\n     * @param checkedPair the pair whose check has just completed.\n     */\n    private void updateCheckListAndTimerStates(CandidatePair checkedPair)\n    {\n        IceMediaStream stream\n            = checkedPair.getParentComponent().getParentStream();\n        final CheckList checkList = stream.getCheckList();\n\n        if (stream.getParentAgent().getState().isEstablished())\n            return;\n\n        //If all of the pairs in the check list are now either in the Failed or\n        //Succeeded state:\n        if (checkList.allChecksCompleted())\n        {\n            //If there is not a pair in the valid list for each component of the\n            //media stream, the state of the check list is set to Failed.\n            if ( !stream.validListContainsAllComponents())\n            {\n                final String streamName = stream.getName();\n                if (!checkListCompletionCheckers.containsKey(streamName))\n                {\n                    logger.info(\"CheckList will failed in a few seconds\" +\n                        \" if no succeeded checks come\");\n\n                    Runnable checkLickCompletedChecker = new Runnable()\n                    {\n                        @Override\n                        public void run()\n                        {\n                            if (checkList.getState() != CheckListState.COMPLETED)\n                            {\n                                logger.info(\"CheckList for stream \" +\n                                    streamName + \" FAILED\");\n\n                                checkList.setState(CheckListState.FAILED);\n                                parentAgent.checkListStatesUpdated();\n                            }\n                        }\n                    };\n\n                    final ScheduledFuture<?> scheduledCheckerFuture\n                        = scheduledExecutorService.schedule(\n                            checkLickCompletedChecker,\n                            5000,\n                            TimeUnit.MILLISECONDS);\n\n                    final ScheduledFuture<?> existingCheckerFuture\n                        = checkListCompletionCheckers\n                            .putIfAbsent(streamName, scheduledCheckerFuture);\n                    if (existingCheckerFuture != null)\n                    {\n                        scheduledCheckerFuture.cancel(false);\n                    }\n                }\n            }\n\n            //For each frozen check list, the agent groups together all of the\n            //pairs with the same foundation, and for each group, sets the\n            //state of the pair with the lowest component ID to Waiting.  If\n            //there is more than one such pair, the one with the highest\n            //priority is used.\n            List<IceMediaStream> allOtherStreams = parentAgent.getStreams();\n\n            allOtherStreams.remove(stream);\n            for (IceMediaStream anotherStream : allOtherStreams)\n            {\n                CheckList anotherCheckList = anotherStream.getCheckList();\n\n                if (anotherCheckList.isFrozen())\n                {\n                    anotherCheckList.computeInitialCheckListPairStates();\n                    startChecks(anotherCheckList);\n                }\n            }\n        }\n\n        parentAgent.checkListStatesUpdated();\n    }\n\n    /**\n     * Handles STUN success responses as per the rules in RFC 5245.\n     *\n     * @param ev the event that delivered the error response.\n     */\n    private void processSuccessResponse(StunResponseEvent ev)\n    {\n        Response response = ev.getResponse();\n        Request  request  = ev.getRequest();\n\n        CandidatePair checkedPair\n            = (CandidatePair) ev.getTransactionID().getApplicationData();\n\n        TransportAddress mappedAddress = null;\n\n        if (!response.containsAttribute(Attribute.XOR_MAPPED_ADDRESS))\n        {\n            logger.debug(() -> \"Received a success response with no \"\n                    + \"XOR_MAPPED_ADDRESS attribute.\");\n            logger.info(\"Pair failed (no XOR-MAPPED-ADDRESS): \"\n                    + checkedPair.toRedactedShortString() + \".\");\n            checkedPair.setStateFailed();\n            return; //malformed error response\n        }\n\n        XorMappedAddressAttribute mappedAddressAttr\n            = (XorMappedAddressAttribute)\n                response.getAttribute(Attribute.XOR_MAPPED_ADDRESS);\n\n        mappedAddress\n            = mappedAddressAttr.getAddress(response.getTransactionID());\n\n        // XXX AddressAttribute always returns UDP based TransportAddress\n        if (checkedPair.getLocalCandidate().getTransport() == Transport.TCP)\n        {\n            mappedAddress\n                = new TransportAddress(\n                        mappedAddress.getAddress(),\n                        mappedAddress.getPort(),\n                        Transport.TCP);\n        }\n\n        // In some situations we may have more than one local candidate matching\n        // the mapped address. In this case we want to find the that matches\n        // the socket we received the response on.\n        LocalCandidate base = checkedPair.getLocalCandidate().getBase();\n        LocalCandidate validLocalCandidate\n                = parentAgent.findLocalCandidate(mappedAddress, base);\n\n        RemoteCandidate validRemoteCandidate = checkedPair.getRemoteCandidate();\n\n        // RFC 5245: The agent checks the mapped address from the STUN\n        // response. If the transport address does not match any of the\n        // local candidates that the agent knows about, the mapped address\n        // represents a new candidate -- a peer reflexive candidate.\n        if (validLocalCandidate == null)\n        {\n            //Like other candidates, PEER-REFLEXIVE candidates have a type,\n            //base, priority, and foundation.  They are computed as follows:\n            //o The type is equal to peer reflexive.\n            //o The base is the local candidate of the candidate\n            //  pair from which the STUN check was sent.\n            //o Its priority is set equal to the value of the PRIORITY attribute\n            //  in the Binding request.\n            long priority = 0;\n            PriorityAttribute prioAttr = (PriorityAttribute)request\n                .getAttribute(Attribute.PRIORITY);\n            priority = prioAttr.getPriority();\n\n            LocalCandidate peerReflexiveCandidate\n                = new PeerReflexiveCandidate(\n                        mappedAddress,\n                        checkedPair.getParentComponent(),\n                        checkedPair.getLocalCandidate(),\n                        priority);\n\n            peerReflexiveCandidate.setBase(checkedPair.getLocalCandidate());\n\n            //This peer reflexive candidate is then added to the list of local\n            //candidates for the media stream, so that it would be available for\n            //updated offers.\n            checkedPair.getParentComponent().addLocalCandidate(\n                    peerReflexiveCandidate);\n\n            //However, the peer reflexive candidate is not paired with other\n            //remote candidates. This is not necessary; a valid pair will be\n            //generated from it momentarily\n            validLocalCandidate = peerReflexiveCandidate;\n\n            if (checkedPair.getParentComponent().getSelectedPair() == null)\n            {\n                logger.info(\"Receive a peer-reflexive candidate: \"\n                    + peerReflexiveCandidate.getTransportAddress().toRedactedString()\n                    + \".\");\n            }\n        }\n\n        //check if the resulting valid pair was already in our check lists.\n        CandidatePair existingPair\n            = parentAgent.findCandidatePair(\n                    validLocalCandidate.getTransportAddress(),\n                    validRemoteCandidate.getTransportAddress());\n\n        // RFC 5245: 7.1.3.2.2. The agent constructs a candidate pair whose\n        // local candidate equals the mapped address of the response, and whose\n        // remote candidate equals the destination address to which the request\n        // was sent. This is called a valid pair, since it has been validated\n        // by a STUN connectivity check.\n        CandidatePair validPair\n            = (existingPair == null)\n                ? parentAgent.createCandidatePair(\n                        validLocalCandidate,\n                        validRemoteCandidate)\n                : existingPair;\n\n        // we synchronize here because the same pair object can be processed (in\n        // another thread) in Agent's triggerCheck. A controlled agent select\n        // its pair here if the pair has useCandidateReceived as true (set in\n        // triggerCheck) or in triggerCheck if the pair state is succeeded (set\n        // here). So be sure that if a binding response and a binding request\n        // (for the same check) from other peer come at the very same time, that\n        // we will trigger the nominationConfirmed (that will pass the pair as\n        // as selected if it is the first time).\n        synchronized (checkedPair)\n        {\n            //The agent sets the state of the pair that *generated* the check to\n            //Succeeded.  Note that, the pair which *generated* the check may be\n            //different than the valid pair constructed above\n            if (checkedPair.getParentComponent().getSelectedPair() == null)\n            {\n                logger.info(\"Pair succeeded: \" + checkedPair.toRedactedShortString()\n                                + \".\");\n            }\n            checkedPair.setStateSucceeded();\n        }\n\n        if (!validPair.isValid())\n        {\n            if (validPair.getParentComponent().getSelectedPair() == null)\n                logger.info(\"Pair validated: \" + validPair.toRedactedShortString()\n                    + \".\");\n            parentAgent.validatePair(validPair);\n        }\n\n        //The agent changes the states for all other Frozen pairs for the\n        //same media stream and same foundation to Waiting.\n        IceMediaStream parentStream\n            = checkedPair.getParentComponent().getParentStream();\n\n        synchronized (this)\n        {\n            Vector<CandidatePair> parentCheckList\n                = new Vector<>(parentStream.getCheckList());\n\n            for (CandidatePair pair : parentCheckList)\n            {\n                if (pair.getState() == CandidatePairState.FROZEN\n                        && checkedPair.getFoundation().equals(\n                                pair.getFoundation()))\n                {\n                    pair.setStateWaiting();\n                }\n            }\n        }\n\n        // The agent examines the check list for all other streams in turn. If\n        // the check list is active, the agent changes the state of all Frozen\n        // pairs in that check list whose foundation matches a pair in the valid\n        // list under consideration to Waiting.\n        List<IceMediaStream> allOtherStreams = parentAgent.getStreams();\n        allOtherStreams.remove(parentStream);\n\n        for (IceMediaStream stream : allOtherStreams)\n        {\n            CheckList checkList = stream.getCheckList();\n            boolean wasFrozen = checkList.isFrozen();\n\n            synchronized (checkList)\n            {\n                for (CandidatePair pair : checkList)\n                {\n                    if (parentStream.validListContainsFoundation(\n                                pair.getFoundation())\n                            && pair.getState() == CandidatePairState.FROZEN)\n                    {\n                        pair.setStateWaiting();\n                    }\n                }\n            }\n\n            //if the checklList is still frozen after the above operations,\n            //the agent groups together all of the pairs with the same\n            //foundation, and for each group, sets the state of the pair with\n            //the lowest component ID to Waiting.  If there is more than one\n            //such pair, the one with the highest priority is used.\n            if (checkList.isFrozen())\n                checkList.computeInitialCheckListPairStates();\n\n            if (wasFrozen)\n            {\n                logger.info(\"Start checks for checkList of stream \" +\n                        stream.getName() + \" that was frozen\");\n                startChecks(checkList);\n            }\n        }\n\n        if (validPair.getParentComponent().getSelectedPair() == null)\n        {\n            logger.info(\"IsControlling: \"  + parentAgent.isControlling() +\n                \" USE-CANDIDATE:\" +\n                    (request.containsAttribute(Attribute.USE_CANDIDATE) ||\n                        checkedPair.useCandidateSent())\n                + \".\");\n        }\n\n        //If the agent was a controlling agent, and it had included a USE-\n        //CANDIDATE attribute in the Binding request, the valid pair generated\n        //from that check has its nominated flag set to true.\n        if (parentAgent.isControlling()\n                && request.containsAttribute(Attribute.USE_CANDIDATE))\n        {\n            if (validPair.getParentComponent().getSelectedPair() == null)\n            {\n                logger.info(\"Nomination confirmed for pair: \"\n                    + validPair.toRedactedShortString()\n                    + \".\");\n                parentAgent.nominationConfirmed( validPair );\n            }\n            else\n            {\n                logger.debug(() ->\n                        \"Keep alive for pair: \" + validPair.toRedactedShortString());\n            }\n        }\n        //If the agent is the controlled agent, the response may be the result\n        //of a triggered check that was sent in response to a request that\n        //itself had the USE-CANDIDATE attribute.  This case is described in\n        //Section 7.2.1.5, and may now result in setting the nominated flag for\n        //the pair learned from the original request.\n        else if (!parentAgent.isControlling()\n                && checkedPair.useCandidateReceived()\n                && !checkedPair.isNominated())\n        {\n            if (checkedPair.getParentComponent().getSelectedPair() == null)\n            {\n                logger.info(\n                        \"Nomination confirmed for pair: \"\n                            + validPair.toRedactedShortString());\n                parentAgent.nominationConfirmed(checkedPair);\n            }\n            else\n            {\n                logger.debug(() ->\n                        \"Keep alive for pair: \" + validPair.toRedactedShortString());\n            }\n        }\n\n        // Selected pairs get their consent freshness confirmed.\n        // XXX Should we also confirm consent freshness for non-selected pairs?\n        if (checkedPair.equals(checkedPair.getParentComponent().getSelectedPair()))\n        {\n            checkedPair.setConsentFreshness();\n        }\n    }\n\n    /**\n     * Returns <tt>true</tt> if the {@link Response} in <tt>evt</tt> had a\n     * source or a destination address that match those of the {@link Request},\n     * or <tt>false</tt> otherwise.<p>\n     * RFC 5245: The agent MUST check that the source IP address and port of\n     * the response equal the destination IP address and port to which the\n     * Binding request was sent, and that the destination IP address and\n     * port of the response match the source IP address and port from which\n     * the Binding request was sent.  In other words, the source and\n     * destination transport addresses in the request and responses are\n     * symmetric.  If they are not symmetric, the agent sets the state of\n     * the pair to Failed.\n     *\n     * @param evt the {@link StunResponseEvent} that contains the {@link\n     * Response} we need to examine\n     *\n     * @return <tt>true</tt> if the {@link Response} in <tt>evt</tt> had a\n     * source or a destination address that matched those of the\n     * {@link Request}, or <tt>false</tt> otherwise.\n     */\n    private boolean checkSymmetricAddresses(StunResponseEvent evt)\n    {\n        CandidatePair pair\n            = ((CandidatePair) evt.getTransactionID().getApplicationData());\n        TransportAddress localAddr\n            = pair.getLocalCandidate().getBase().getTransportAddress();\n\n        return\n            localAddr.equals(evt.getLocalAddress())\n                && pair.getRemoteCandidate().getTransportAddress().equals(\n                        evt.getRemoteAddress());\n    }\n\n    /**\n     * In case of a role conflict, changes the state of the agent and\n     * reschedules the check, in all other cases sets the corresponding peer\n     * state to FAILED.\n     *\n     * @param ev the event that delivered the error response.\n     */\n    private void processErrorResponse(StunResponseEvent ev)\n    {\n        Response response = ev.getResponse();\n        Request originalRequest = ev.getRequest();\n\n        ErrorCodeAttribute errorAttr\n            = (ErrorCodeAttribute) response.getAttribute(Attribute.ERROR_CODE);\n        // GTalk error code is not RFC3489/RFC5389 compliant\n        // example: 400 becomes 0x01 0x90 with GTalk\n        // RFC3489/RFC5389 gives 0x04 0x00\n        int cl = errorAttr.getErrorClass();\n        int co = errorAttr.getErrorNumber() & 0xff;\n        char errorCode = errorAttr.getErrorCode();\n\n        CandidatePair pair\n            = (CandidatePair) ev.getTransactionID().getApplicationData();\n\n        logger.trace(() -> \"Received error code \" + ((int) errorCode));\n\n        //RESOLVE ROLE_CONFLICTS\n        if (errorCode == ErrorCodeAttribute.ROLE_CONFLICT)\n        {\n            boolean wasControlling\n                = originalRequest.containsAttribute(Attribute.ICE_CONTROLLING);\n\n            logger.trace(() -> \"Switching to isControlling=\" + !wasControlling);\n            parentAgent.setControlling(!wasControlling);\n\n            pair.getParentComponent().getParentStream().getCheckList()\n                .scheduleTriggeredCheck(pair);\n        }\n        else\n        {\n            int code = cl * 100 + co;\n            String reason = errorAttr.getReasonPhrase();\n            String trimmedReason = reason != null ? reason.trim() : null;\n            logger.info(\n                    \"Error response for pair: \" + pair.toRedactedShortString() +\n                    \", failing.  Code = \" + code +\n                    \"(class=\" + cl + \"; number=\" + co + \"): \" + trimmedReason);\n            pair.setStateFailed();\n        }\n    }\n\n    /**\n     * Sets the state of the corresponding {@link CandidatePair} to\n     * {@link CandidatePairState#FAILED} and updates check list and timer\n     * states.\n     *\n     * @param ev the {@link StunTimeoutEvent} containing the original\n     * transaction and hence {@link CandidatePair} that's being checked.\n     */\n    public void processTimeout(StunTimeoutEvent ev)\n    {\n        CandidatePair pair\n            = (CandidatePair) ev.getTransactionID() .getApplicationData();\n\n        logger.info(\"timeout for pair: \" + pair.toRedactedShortString() + \", failing.\");\n        pair.setStateFailed();\n        updateCheckListAndTimerStates(pair);\n    }\n\n    /**\n     * A class to control periodically scheduled runnable that actually sends\n     * the checks for a particular check list in the pace defined in RFC 5245.\n     */\n    private final class PaceMaker extends PeriodicRunnable\n    {\n        /**\n         * The {@link CheckList} that this <tt>PaceMaker</tt> will be running\n         * checks for.\n         */\n        private final CheckList checkList;\n\n        /**\n         * Whether this is the first time this {@link PaceMaker} has been run.\n         * We want to run the initial check for a checklist as soon as connectivity\n         * checking is started, with no delay.\n         */\n        private boolean firstRun = true;\n\n        /**\n         * Creates a new {@link PaceMaker} for this\n         * <tt>ConnectivityCheckClient</tt>.\n         *\n         * @param checkList the {@link CheckList} that we'll be sending checks\n         * for\n         */\n        public PaceMaker(CheckList checkList)\n        {\n            super(scheduledExecutorService, executorService);\n            this.checkList = checkList;\n        }\n\n        /**\n         * Sends connectivity checks at the pace determined by the {@link\n         * Agent#calculateTa()} method and using either the trigger check queue\n         * or the regular check lists.\n         */\n        @Override\n        protected void run()\n        {\n            CandidatePair pairToCheck = checkList.popTriggeredCheck();\n\n            //if there are no triggered checks, go for an ordinary one.\n            if (pairToCheck == null)\n            {\n                pairToCheck = checkList.getNextOrdinaryPairToCheck();\n            }\n\n            if (pairToCheck != null)\n            {\n                /*\n                 * Since we suspect that it is possible to\n                 * startCheckForPair, processSuccessResponse and only\n                 * then setStateInProgress, we'll synchronize. The\n                 * synchronization root is the one of the\n                 * CandidatePair#setState method.\n                 */\n                synchronized (pairToCheck)\n                {\n                    TransactionID transactionID\n                        = startCheckForPair(pairToCheck);\n\n                    if (transactionID == null)\n                    {\n                        logger.info(\n                            \"Pair failed: \"\n                                + pairToCheck.toRedactedShortString());\n                        pairToCheck.setStateFailed();\n                    }\n                    else\n                    {\n                        pairToCheck.setStateInProgress(transactionID);\n                    }\n                }\n            }\n            else\n            {\n                /*\n                 * We are done sending checks for this list. We'll set\n                 * its final state in either the processResponse(),\n                 * processTimeout() or processFailure() method.\n                 */\n                logger.trace(() -> \"will skip a check beat.\");\n                checkList.fireEndOfOrdinaryChecks();\n            }\n        }\n\n        /**\n         * Returns the number milliseconds to wait before we send the next\n         * check.\n         *\n         * @return  the number milliseconds to wait before we send the next\n         * check.\n         */\n        protected Duration getDelayUntilNextRun()\n        {\n            if (firstRun)\n            {\n                /* Run first check immediately. */\n                firstRun = false;\n                return Duration.ZERO;\n            }\n\n            int activeCheckLists = parentAgent.getActiveCheckListCount();\n\n            if (activeCheckLists < 1)\n            {\n                //don't multiply by 0. even when we no longer have active check\n                //lists we may still have nomination checks to\n                activeCheckLists = 1;\n            }\n\n            return Duration.ofMillis(parentAgent.calculateTa() * activeCheckLists);\n        }\n    }\n\n    /**\n     * Stops and removes all <tt>PaceMaker</tt>s.\n     */\n    public void stop()\n    {\n        synchronized (paceMakers)\n        {\n            stopped = true;\n            while (true)\n            {\n                final PaceMaker paceMaker = paceMakers.poll();\n                if (paceMaker == null)\n                {\n                    break;\n                }\n                paceMaker.cancel();\n            }\n        }\n    }\n\n    public boolean isStopped() {\n        synchronized (paceMakers) {\n            return stopped;\n        }\n    }\n}", "super_interfaces": ["ResponseCollector"], "fields": [{"attribute_expression": "private final Agent parentAgent;", "docstring": "\nThe agent that created us.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Agent", "name": "parentAgent", "syntax_pass": true}, {"attribute_expression": "private final ScheduledExecutorService scheduledExecutorService;", "docstring": "\nA scheduled executor service to perform periodic tasks of the client\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ScheduledExecutorService", "name": "scheduledExecutorService", "syntax_pass": true}, {"attribute_expression": "private final ExecutorService executorService;", "docstring": "\nAn executor service to perform background tasks of the client\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ExecutorService", "name": "executorService", "syntax_pass": true}, {"attribute_expression": "private final StunStack stunStack;", "docstring": "\nThe <tt>StunStack</tt> that we will use for connectivity checks.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StunStack", "name": "stunStack", "syntax_pass": true}, {"attribute_expression": "private final Queue<PaceMaker> paceMakers\n        = new ConcurrentLinkedQueue<>();", "docstring": "\nThe {@link PaceMaker}s that are currently running checks in this client.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Queue<PaceMaker>", "name": "paceMakers\n        = new ConcurrentLinkedQueue<>()", "syntax_pass": true}, {"attribute_expression": "private boolean stopped = false;", "docstring": "\nWhether this {@link ConnectivityCheckClient} has been stopped.\nSynchronized by {@link #paceMakers}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "stopped = false", "syntax_pass": true}, {"attribute_expression": "private ConcurrentMap<String, ScheduledFuture<?>>\n        checkListCompletionCheckers = new ConcurrentHashMap<>();", "docstring": "\nTimer that is used to let some seconds before a CheckList is considered\nas FAILED.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ConcurrentMap<String, ScheduledFuture<?>>", "name": "checkListCompletionCheckers = new ConcurrentHashMap<>()", "syntax_pass": true}, {"attribute_expression": "private boolean alive = false;", "docstring": "\nA flag that determines whether we have received a STUN response or not.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "alive = false", "syntax_pass": true}, {"attribute_expression": "private Logger logger;", "docstring": "\nThe {@link Logger} used by {@link ConnectivityCheckClient} instances.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Logger", "name": "logger", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate", "name": "HostCandidate", "file_path": "src/main/java/org/ice4j/ice/HostCandidate.java", "superclasses": "LocalCandidate", "methods": ["[]HostCandidate(IceSocketWrapper,Component)", "[]HostCandidate(TransportAddress,Component)", "[]HostCandidate(IceSocketWrapper,Component,Transport)", "[StunDatagramPacketFilter]createStunDatagramPacketFilter(TransportAddress)", "[IceSocketWrapper]getCandidateIceSocketWrapper()"], "method_uris": ["src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate.[]HostCandidate(IceSocketWrapper,Component)", "src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate.[]HostCandidate(TransportAddress,Component)", "src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate.[]HostCandidate(IceSocketWrapper,Component,Transport)", "src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate.[StunDatagramPacketFilter]createStunDatagramPacketFilter(TransportAddress)", "src/main/java/org/ice4j/ice/HostCandidate.java.HostCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper()"], "overrides": null, "attributes": [], "class_docstring": "\n<tt>HostCandidate</tt>s are obtained by binding to a specific port from an\nIP address on the host that is running us. This includes IP addresses on\nphysical interfaces and logical ones, such as ones obtained through\nVirtual Private Networks (VPNs), Mobile IPv6, Realm Specific IP (RSIP) etc.\n<p>\nAt this point this class only supports UDP candidates. Implementation of\nsupport for other transport protocols should mean that this class should\nbecome abstract and some transport specific components like to socket for\nexample should be brought down the inheritance chain.\n</p>\n\n@author Emil Ivov\n", "original_string": "public class HostCandidate extends LocalCandidate\n{\n\n    /**\n     * If this is a local candidate the field contains the socket that is\n     * actually associated with the candidate.\n     */\n    private final IceSocketWrapper socket;\n\n    /**\n     * Creates a HostCandidate for the specified transport address.\n     *\n     * @param socket the {@link DatagramSocket} that communication associated\n     * with this <tt>Candidate</tt> will be going through.\n     * @param parentComponent the <tt>Component</tt> that this candidate\n     * belongs to.\n     */\n    public HostCandidate(IceSocketWrapper socket,\n                         Component        parentComponent)\n    {\n        this(socket,\n             parentComponent,\n             Transport.UDP);\n    }\n\n    /**\n     * Creates a HostCandidate for the specified transport address.\n     *\n     * @param transportAddress the transport address for the new\n     * <tt>HostCandidate</tt>.\n     * @param parentComponent the <tt>Component</tt> that this candidate\n     * belongs to.\n     */\n    public HostCandidate(\n            TransportAddress transportAddress,\n            Component parentComponent)\n    {\n        super(transportAddress,\n              parentComponent,\n              CandidateType.HOST_CANDIDATE,\n              CandidateExtendedType.HOST_CANDIDATE,\n              null);\n\n        this.socket = null;\n        setBase(this);\n    }\n\n    /**\n     * Creates a HostCandidate for the specified transport address.\n     *\n     * @param socket the {@link DatagramSocket} that communication associated\n     * with this <tt>Candidate</tt> will be going through.\n     * @param parentComponent the <tt>Component</tt> that this candidate\n     * belongs to.\n     * @param transport transport protocol used\n     */\n    public HostCandidate(IceSocketWrapper socket,\n                         Component        parentComponent,\n                         Transport        transport)\n    {\n        super(new TransportAddress(socket.getLocalAddress(),\n                        socket.getLocalPort(), transport),\n              parentComponent,\n              CandidateType.HOST_CANDIDATE,\n              CandidateExtendedType.HOST_CANDIDATE,\n              null);\n\n        this.socket = socket;\n        setBase(this);\n    }\n\n    /**\n     * Creates a new <tt>StunDatagramPacketFilter</tt> which is to capture STUN\n     * messages and make them available to the <tt>DatagramSocket</tt> returned\n     * by {@link #getStunSocket(TransportAddress)}.\n     *\n     * @param serverAddress the address of the source we'd like to receive\n     * packets from or <tt>null</tt> if we'd like to intercept all STUN packets\n     * @return the <tt>StunDatagramPacketFilter</tt> which is to capture STUN\n     * messages and make them available to the <tt>DatagramSocket</tt> returned\n     * by {@link #getStunSocket(TransportAddress)}\n     * @see LocalCandidate#createStunDatagramPacketFilter(TransportAddress)\n     */\n    @Override\n    protected StunDatagramPacketFilter createStunDatagramPacketFilter(\n            TransportAddress serverAddress)\n    {\n        /*\n         * Since we support TURN as well, we have to be able to receive TURN\n         * messages as well.\n         */\n        return new TurnDatagramPacketFilter(serverAddress);\n    }\n\n    /**\n     * {@inheritDoc}\n     * SHOULD NOT be used outside ice4j. Only exposed for use in the\n     * org.ice4j.socket package.\n     */\n    @Override\n    public IceSocketWrapper getCandidateIceSocketWrapper()\n    {\n        return socket;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final IceSocketWrapper socket;", "docstring": "\nIf this is a local candidate the field contains the socket that is\nactually associated with the candidate.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "IceSocketWrapper", "name": "socket", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate", "name": "GoogleRelayedCandidate", "file_path": "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java", "superclasses": "LocalCandidate", "methods": ["[]GoogleRelayedCandidate(TransportAddress,GoogleTurnCandidateHarvest,TransportAddress,String,String)", "[GoogleRelayedCandidateDatagramSocket]getRelayedCandidateDatagramSocket()", "[GoogleRelayedCandidateSocket]getRelayedCandidateSocket()", "[IceSocketWrapper]getCandidateIceSocketWrapper()", "[String]getPassword()"], "method_uris": ["src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate.[]GoogleRelayedCandidate(TransportAddress,GoogleTurnCandidateHarvest,TransportAddress,String,String)", "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate.[GoogleRelayedCandidateDatagramSocket]getRelayedCandidateDatagramSocket()", "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate.[GoogleRelayedCandidateSocket]getRelayedCandidateSocket()", "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper()", "src/main/java/org/ice4j/ice/GoogleRelayedCandidate.java.GoogleRelayedCandidate.[String]getPassword()"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents a <tt>Candidate</tt> obtained by sending a Google TURN Allocate\nrequest from a <tt>HostCandidate</tt> to a TURN server.  The Google relayed\ncandidate is resident on the TURN server, and the TURN server relays packets\nback towards the agent.\n\n@author Lubomir Marinov\n@author Sebastien Vincent\n", "original_string": "public class GoogleRelayedCandidate\n    extends LocalCandidate\n{\n    /**\n     * The <tt>RelayedCandidateDatagramSocket</tt> of this\n     * <tt>GoogleRelayedCandidate</tt>.\n     */\n    private GoogleRelayedCandidateDatagramSocket relayedCandidateDatagramSocket;\n\n    /**\n     * The <tt>RelayedCandidateSocket</tt> of this\n     * <tt>GoogleRelayedCandidate</tt>.\n     */\n    private GoogleRelayedCandidateSocket relayedCandidateSocket = null;\n\n    /**\n     * The application-purposed <tt>DatagramSocket</tt> associated with this\n     * <tt>Candidate</tt>.\n     */\n    private IceSocketWrapper socket;\n\n    /**\n     * The <tt>GoogleTurnCandidateHarvest</tt> which has harvested this\n     * <tt>GoogleRelayedCandidate</tt>.\n     */\n    private final GoogleTurnCandidateHarvest turnCandidateHarvest;\n\n    /**\n     * Username.\n     */\n    private final String username;\n\n    /**\n     * Password.\n     */\n    private final String password;\n\n    /**\n     * Initializes a new <tt>RelayedCandidate</tt> which is to represent a\n     * specific <tt>TransportAddress</tt> harvested through a specific\n     * <tt>HostCandidate</tt> and a TURN server with a specific\n     * <tt>TransportAddress</tt>.\n     *\n     * @param transportAddress the <tt>TransportAddress</tt> to be represented\n     * by the new instance\n     * @param turnCandidateHarvest the <tt>TurnCandidateHarvest</tt> which has\n     * harvested the new instance\n     * @param mappedAddress the mapped <tt>TransportAddress</tt> reported by the\n     * TURN server with the delivery of the replayed <tt>transportAddress</tt>\n     * to be represented by the new instance\n     * @param username username (Send request to the Google relay server need\n     * it)\n     * @param password password (used with XMPP gingle candidates).\n     * it)\n     */\n    public GoogleRelayedCandidate(\n            TransportAddress transportAddress,\n            GoogleTurnCandidateHarvest turnCandidateHarvest,\n            TransportAddress mappedAddress,\n            String username,\n            String password)\n    {\n        super(\n            transportAddress,\n            turnCandidateHarvest.hostCandidate.getParentComponent(),\n            CandidateType.RELAYED_CANDIDATE,\n            CandidateExtendedType.GOOGLE_TURN_RELAYED_CANDIDATE,\n            turnCandidateHarvest.hostCandidate.getParentComponent()\n                .findLocalCandidate(mappedAddress));\n\n        if (transportAddress.getTransport() == Transport.TCP)\n        {\n            super.setExtendedType(\n                    CandidateExtendedType.GOOGLE_TCP_TURN_RELAYED_CANDIDATE);\n        }\n\n        this.turnCandidateHarvest = turnCandidateHarvest;\n        this.username = username;\n        this.password = password;\n\n        // RFC 5245: The base of a relayed candidate is that candidate itself.\n        setBase(this);\n        setRelayServerAddress(turnCandidateHarvest.harvester.stunServer);\n        setMappedAddress(mappedAddress);\n    }\n\n    /**\n     * Gets the <tt>RelayedCandidateDatagramSocket</tt> of this\n     * <tt>RelayedCandidate</tt>.\n     * <p>\n     * <b>Note</b>: The method is part of the internal API of\n     * <tt>RelayedCandidate</tt> and <tt>TurnCandidateHarvest</tt> and is not\n     * intended for public use.\n     * </p>\n     *\n     * @return the <tt>RelayedCandidateDatagramSocket</tt> of this\n     * <tt>RelayedCandidate</tt>\n     */\n    private synchronized GoogleRelayedCandidateDatagramSocket\n        getRelayedCandidateDatagramSocket()\n    {\n        if (relayedCandidateDatagramSocket == null)\n        {\n            try\n            {\n                relayedCandidateDatagramSocket\n                    = new GoogleRelayedCandidateDatagramSocket(\n                            this,\n                            turnCandidateHarvest,\n                            username);\n            }\n            catch (SocketException sex)\n            {\n                throw new UndeclaredThrowableException(sex);\n            }\n        }\n        return relayedCandidateDatagramSocket;\n    }\n\n    /**\n     * Gets the <tt>RelayedCandidateDatagramSocket</tt> of this\n     * <tt>RelayedCandidate</tt>.\n     * <p>\n     * <b>Note</b>: The method is part of the internal API of\n     * <tt>RelayedCandidate</tt> and <tt>TurnCandidateHarvest</tt> and is not\n     * intended for public use.\n     * </p>\n     *\n     * @return the <tt>RelayedCandidateDatagramSocket</tt> of this\n     * <tt>RelayedCandidate</tt>\n     */\n    private synchronized GoogleRelayedCandidateSocket\n        getRelayedCandidateSocket()\n    {\n        if (relayedCandidateSocket == null)\n        {\n            try\n            {\n                relayedCandidateSocket\n                    = new GoogleRelayedCandidateSocket(\n                        this,\n                        turnCandidateHarvest,\n                        username);\n            }\n            catch (SocketException sex)\n            {\n                throw new UndeclaredThrowableException(sex);\n            }\n        }\n        return relayedCandidateSocket;\n    }\n\n    /**\n     * Gets the application-purposed <tt>DatagramSocket</tt> associated with\n     * this <tt>Candidate</tt>.\n     *\n     * @return the <tt>DatagramSocket</tt> associated with this\n     * <tt>Candidate</tt>\n     * @see LocalCandidate#getCandidateIceSocketWrapper()\n     */\n    @Override\n    public synchronized IceSocketWrapper getCandidateIceSocketWrapper()\n    {\n        if (socket == null)\n        {\n            try\n            {\n                if (getTransport() == Transport.UDP)\n                {\n                    socket\n                       = new IceUdpSocketWrapper(new MultiplexingDatagramSocket(\n                            getRelayedCandidateDatagramSocket()));\n                }\n                else if (getTransport() == Transport.TCP)\n                {\n                    final Socket s = getRelayedCandidateSocket();\n                    socket = new IceTcpSocketWrapper(new MultiplexingSocket(s));\n                }\n            }\n            catch (Exception sex)\n            {\n                throw new UndeclaredThrowableException(sex);\n            }\n        }\n        return socket;\n    }\n\n    /**\n     * Returns the password for this candidate.\n     * @return the password for this candidate.\n     */\n    public String getPassword()\n    {\n        return this.password;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private GoogleRelayedCandidateDatagramSocket relayedCandidateDatagramSocket;", "docstring": "\nThe <tt>RelayedCandidateDatagramSocket</tt> of this\n<tt>GoogleRelayedCandidate</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "GoogleRelayedCandidateDatagramSocket", "name": "relayedCandidateDatagramSocket", "syntax_pass": true}, {"attribute_expression": "private GoogleRelayedCandidateSocket relayedCandidateSocket = null;", "docstring": "\nThe <tt>RelayedCandidateSocket</tt> of this\n<tt>GoogleRelayedCandidate</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "GoogleRelayedCandidateSocket", "name": "relayedCandidateSocket = null", "syntax_pass": true}, {"attribute_expression": "private IceSocketWrapper socket;", "docstring": "\nThe application-purposed <tt>DatagramSocket</tt> associated with this\n<tt>Candidate</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IceSocketWrapper", "name": "socket", "syntax_pass": true}, {"attribute_expression": "private final GoogleTurnCandidateHarvest turnCandidateHarvest;", "docstring": "\nThe <tt>GoogleTurnCandidateHarvest</tt> which has harvested this\n<tt>GoogleRelayedCandidate</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "GoogleTurnCandidateHarvest", "name": "turnCandidateHarvest", "syntax_pass": true}, {"attribute_expression": "private final String username;", "docstring": "\nUsername.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "username", "syntax_pass": true}, {"attribute_expression": "private final String password;", "docstring": "\nPassword.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "password", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/CheckList.java.CheckList", "name": "CheckList", "file_path": "src/main/java/org/ice4j/ice/CheckList.java", "superclasses": "", "methods": ["[]CheckList(IceMediaStream)", "[CheckListState]getState()", "[void]setState(CheckListState)", "[void]scheduleTriggeredCheck(CandidatePair)", "[CandidatePair]popTriggeredCheck()", "[CandidatePair]getNextOrdinaryPairToCheck()", "[CandidatePair]findPairMatching(LocalCandidate,RemoteCandidate)", "[boolean]isActive()", "[boolean]allChecksCompleted()", "[boolean]isFrozen()", "[String]toString()", "[void]computeInitialCheckListPairStates()", "[void]recomputePairPriorities()", "[void]handleNominationConfirmed(CandidatePair)", "[String]getName()", "[boolean]containsNomineeForComponent(Component)", "[void]addStateChangeListener(PropertyChangeListener)", "[void]removeStateChangeListener(PropertyChangeListener)", "[void]fireStateChange(CheckListState,CheckListState)", "[void]addChecksListener(PropertyChangeListener)", "[void]removeChecksListener(PropertyChangeListener)", "[void]fireEndOfOrdinaryChecks()", "[IceMediaStream]getParentStream()"], "method_uris": ["src/main/java/org/ice4j/ice/CheckList.java.CheckList.[]CheckList(IceMediaStream)", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[CheckListState]getState()", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]setState(CheckListState)", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]scheduleTriggeredCheck(CandidatePair)", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[CandidatePair]popTriggeredCheck()", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[CandidatePair]getNextOrdinaryPairToCheck()", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[CandidatePair]findPairMatching(LocalCandidate,RemoteCandidate)", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[boolean]isActive()", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[boolean]allChecksCompleted()", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[boolean]isFrozen()", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[String]toString()", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]computeInitialCheckListPairStates()", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]recomputePairPriorities()", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]handleNominationConfirmed(CandidatePair)", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[String]getName()", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[boolean]containsNomineeForComponent(Component)", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]addStateChangeListener(PropertyChangeListener)", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]removeStateChangeListener(PropertyChangeListener)", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]fireStateChange(CheckListState,CheckListState)", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]addChecksListener(PropertyChangeListener)", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]removeChecksListener(PropertyChangeListener)", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[void]fireEndOfOrdinaryChecks()", "src/main/java/org/ice4j/ice/CheckList.java.CheckList.[IceMediaStream]getParentStream()"], "overrides": null, "attributes": [], "class_docstring": "\nA check list is a list of <tt>CandidatePair</tt>s with a state (i.e. a\n<tt>CheckListState</tt>). The pairs in a check list are those that an ICE\nagent will run STUN connectivity checks for. There is one check list per\nin-use media stream resulting from the offer/answer exchange.\n<p>\nGiven the asynchronous nature of ice, a check list may be accessed from\ndifferent locations. This class therefore stores pairs in a <tt>Vector</tt>\n@author Emil Ivov\n", "original_string": "public class CheckList\n    extends Vector<CandidatePair>\n{\n    /**\n     * A dummy serialization id.\n     */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * The name of the {@link PropertyChangeEvent} that we use to deliver\n     * changes on the state of this check list.\n     */\n    public static final String PROPERTY_CHECK_LIST_STATE = \"CheckListState\";\n\n    /**\n     * The name of the {@link PropertyChangeEvent} that we use to deliver\n     * changes on the end of checks of this check list.\n     */\n    public static final String PROPERTY_CHECK_LIST_CHECKS = \"CheckListChecks\";\n\n    /**\n     * The state of this check list.\n     */\n    private CheckListState state = CheckListState.RUNNING;\n\n    /**\n     * The <tt>triggeredCheckQueue</tt> is a FIFO queue containing candidate\n     * pairs for which checks are to be sent at the next available opportunity.\n     * A pair would get into a triggered check queue as soon as we receive\n     * a check on its local candidate.\n     */\n    private final List<CandidatePair> triggeredCheckQueue = new LinkedList<>();\n\n    /**\n     * A reference to the {@link IceMediaStream} that we belong to.\n     */\n    private final IceMediaStream parentStream;\n\n    /**\n     * Contains {@link PropertyChangeListener}s registered with this {@link\n     * Agent} and following its changes of state.\n     */\n    private final List<PropertyChangeListener> stateListeners\n        = new LinkedList<>();\n\n    /**\n     * Contains {@link PropertyChangeListener}s registered with this {@link\n     * Agent} and following its changes of state.\n     */\n    private final List<PropertyChangeListener> checkListeners\n        = new LinkedList<>();\n\n    /**\n     * The {@link Logger} used by {@link CheckList} instances.\n     */\n    private Logger logger;\n\n    /**\n     * Creates a check list with the specified name.\n     *\n     * @param parentStream a reference to the parent {@link IceMediaStream}\n     * that created us and that we belong to.\n     */\n    protected CheckList(IceMediaStream parentStream)\n    {\n        this.parentStream = parentStream;\n        logger = parentStream.getLogger().createChildLogger(this.getClass().getName());\n    }\n\n    /**\n     * Returns the state of this check list.\n     *\n     * @return the <tt>CheckListState</tt> of this check list.\n     */\n    public CheckListState getState()\n    {\n        return state;\n    }\n\n    /**\n     * Sets the state of this list.\n     *\n     * @param newState the <tt>CheckListState</tt> for this list.\n     */\n    protected void setState(CheckListState newState)\n    {\n        CheckListState oldState = this.state;\n        this.state = newState;\n\n        fireStateChange(oldState, newState);\n    }\n\n    /**\n     * Adds <tt>pair</tt> to the local triggered check queue unless it's already\n     * there. Additionally, the method sets the pair's state to {@link\n     * CandidatePairState#WAITING}.\n     *\n     * @param pair the pair to schedule a triggered check for.\n     */\n    protected void scheduleTriggeredCheck(CandidatePair pair)\n    {\n        synchronized(triggeredCheckQueue)\n        {\n            if (!triggeredCheckQueue.contains(pair))\n            {\n                triggeredCheckQueue.add(pair);\n                pair.setStateWaiting();\n            }\n        }\n    }\n\n    /**\n     * Returns the first {@link CandidatePair} in the triggered check queue or\n     * <tt>null</tt> if that queue is empty.\n     *\n     * @return the first {@link CandidatePair} in the triggered check queue or\n     * <tt>null</tt> if that queue is empty.\n     */\n    protected CandidatePair popTriggeredCheck()\n    {\n        synchronized(triggeredCheckQueue)\n        {\n            if (triggeredCheckQueue.size() > 0)\n                return triggeredCheckQueue.remove(0);\n        }\n        return null;\n    }\n\n    /**\n     * Returns the next {@link CandidatePair} that is eligible for a regular\n     * connectivity check. According to RFC 5245 this would be the highest\n     * priority pair that is in the <tt>Waiting</tt> state or, if there is\n     * no such pair, the highest priority <tt>Frozen</tt> {@link CandidatePair}.\n     *\n     * @return the next {@link CandidatePair} that is eligible for a regular\n     * connectivity check, which would either be the highest priority\n     * <tt>Waiting</tt> pair or, when there's no such pair, the highest priority\n     * <tt>Frozen</tt> pair or <tt>null</tt> otherwise\n     */\n    protected synchronized CandidatePair getNextOrdinaryPairToCheck()\n    {\n        if (size() < 1)\n            return null;\n\n        CandidatePair highestPriorityPair = null;\n\n        for (CandidatePair pair : this)\n        {\n            if (pair.getState() == CandidatePairState.WAITING)\n            {\n                if (highestPriorityPair == null\n                   || pair.getPriority() > highestPriorityPair.getPriority())\n                {\n                    highestPriorityPair = pair;\n                }\n            }\n        }\n\n        if (highestPriorityPair != null)\n            return highestPriorityPair;\n\n        for (CandidatePair pair : this)\n        {\n            if (pair.getState() == CandidatePairState.FROZEN)\n            {\n                if (highestPriorityPair == null\n                   || pair.getPriority() > highestPriorityPair.getPriority())\n                {\n                    highestPriorityPair = pair;\n                    pair.setStateWaiting();\n                }\n            }\n        }\n\n        return highestPriorityPair; //return even if null\n    }\n\n    /**\n     * Returns a pair which matches the specified local and remote candidates'\n     * transport addresses, if any, otherwise null.\n     */\n    public synchronized CandidatePair findPairMatching(LocalCandidate local, RemoteCandidate remote)\n    {\n        for (CandidatePair pair : this)\n        {\n            if (pair.getLocalCandidate() == local ||\n                pair.getLocalCandidate().getTransportAddress().equals(local.getTransportAddress()))\n            {\n                if (pair.getRemoteCandidate() == remote ||\n                    pair.getRemoteCandidate().getTransportAddress().equals(remote.getTransportAddress()))\n                    return pair;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Determines whether this <tt>CheckList</tt> can be considered active.\n     * RFC 5245 says: A check list with at least one pair that is Waiting is\n     * called an active check list.\n     *\n     * @return <tt>true</tt> if this list is active and <tt>false</tt>\n     * otherwise.\n     */\n    public synchronized boolean isActive()\n    {\n        for (CandidatePair pair : this)\n        {\n            if (pair.getState() == CandidatePairState.WAITING)\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     * Determines whether all checks in this <tt>CheckList</tt> have ended one\n     * way or another.\n     *\n     * @return <tt>true</tt> if all checks for pairs in this list have either\n     * succeeded or failed (but non are are currently waiting or in progress)\n     * or <tt>false</tt> otherwise..\n     */\n    public synchronized boolean allChecksCompleted()\n    {\n        for (CandidatePair pair : this)\n        {\n            CandidatePairState pairState = pair.getState();\n\n            if ((pairState != CandidatePairState.SUCCEEDED)\n                    && (pairState != CandidatePairState.FAILED))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Determines whether this <tt>CheckList</tt> can be considered frozen.\n     * RFC 5245 says: a check list with all pairs Frozen is called a frozen\n     * check list.\n     *\n     * @return <tt>true</tt> if all pairs in this list are frozen and\n     * <tt>false</tt> otherwise.\n     */\n    public synchronized boolean isFrozen()\n    {\n        for (CandidatePair pair : this)\n        {\n            if (pair.getState() != CandidatePairState.FROZEN)\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a <tt>String</tt> representation of this check list. It\n     * consists of a list of the <tt>CandidatePair</tt>s in the order they\n     * were inserted and enclosed in square brackets (<tt>\"[]\"</tt>). The method\n     * would also call and use the content returned by every member\n     * <tt>CandidatePair</tt>.\n     *\n     * @return A <tt>String</tt> representation of this collection.\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder buff = new StringBuilder(\"CheckList. (num pairs=\");\n        buff.append(size()).append(\")\\n\");\n\n        for (CandidatePair pair : this)\n            buff.append(pair).append(\"\\n\");\n\n        return buff.toString();\n    }\n\n    /**\n     * Computes and resets states of all pairs in this check list. For all pairs\n     * with the same foundation, we set the state of the pair with the lowest\n     * component ID to Waiting. If there is more than one such pair, the one\n     * with the highest priority is used.\n     */\n    protected synchronized void computeInitialCheckListPairStates()\n    {\n        Map<String, CandidatePair> pairsToWait = new Hashtable<>();\n\n        //first, determine the pairs that we'd need to put in the waiting state.\n        for (CandidatePair pair : this)\n        {\n            //we need to check whether the pair is already in the wait list. if\n            //so we'll compare it with this one and determine which of the two\n            //needs to stay.\n            CandidatePair prevPair = pairsToWait.get(pair.getFoundation());\n\n            if (prevPair == null)\n            {\n                //first pair with this foundation.\n                pairsToWait.put(pair.getFoundation(), pair);\n                continue;\n            }\n\n            //we already have a pair with the same foundation. determine which\n            //of the two has the lower component id and higher priority and\n            //keep that one in the list.\n            if ( prevPair.getParentComponent() == pair.getParentComponent())\n            {\n                if (pair.getPriority() > prevPair.getPriority())\n                {\n                    //need to replace the pair in the list.\n                    pairsToWait.put(pair.getFoundation(), pair);\n                }\n            }\n            else\n            {\n                if (pair.getParentComponent().getComponentID()\n                            < prevPair.getParentComponent().getComponentID())\n                {\n                    //need to replace the pair in the list.\n                    pairsToWait.put(pair.getFoundation(), pair);\n                }\n            }\n        }\n\n        //now put the pairs we've selected in the Waiting state.\n        for (CandidatePair pairToWait : pairsToWait.values())\n            pairToWait.setStateWaiting();\n    }\n\n    /**\n     * Recomputes priorities of all pairs in this <tt>CheckList</tt>. Method is\n     * useful when an agent changes its <tt>isControlling</tt> property as a\n     * result of a role conflict.\n     */\n    protected synchronized void recomputePairPriorities()\n    {\n        //first, determine the pairs that we'd need to put in the waiting state.\n        for (CandidatePair pair : this)\n            pair.computePriority();\n    }\n\n    /**\n     * Removes from this <tt>CheckList</tt> and its associated triggered check\n     * queue all {@link CandidatePair}s that are in the <tt>Waiting</tt> and\n     * <tt>Frozen</tt> states and that belong to the same {@link Component} as\n     * <tt>nominatedPair</tt>. Typically this will happen upon confirmation of\n     * the nomination of one pair in that component. The procedure implemented\n     * here represents one of the cases specified in RFC 5245, Section 8.1.2:\n     * <p>\n     * The agent MUST remove all Waiting and Frozen pairs in the check\n     * list and triggered check queue for the same component as the\n     * nominated pairs for that media stream.\n     * </p><p>\n     * If an In-Progress pair in the check list is for the same component as a\n     * nominated pair, the agent SHOULD cease retransmissions for its check\n     * if its pair priority is lower than the lowest-priority nominated pair\n     * for that component.\n     * </p>\n     *\n     * @param nominatedPair the {@link CandidatePair} whose nomination we need\n     * to handle.\n     */\n    protected synchronized void handleNominationConfirmed(\n                                                    CandidatePair nominatedPair)\n    {\n        Component cmp = nominatedPair.getParentComponent();\n\n        if (cmp.getSelectedPair() != null)\n        {\n            return;\n        }\n\n        logger.info(\n                \"Selected pair for stream \" + cmp.toShortString() + \": \"\n                    + nominatedPair.toRedactedShortString());\n\n        cmp.setSelectedPair(nominatedPair);\n\n        Iterator<CandidatePair> pairsIter = iterator();\n        while (pairsIter.hasNext())\n        {\n            CandidatePair pair = pairsIter.next();\n            if (pair.getParentComponent() == cmp\n                 &&( pair.getState() == CandidatePairState.WAITING\n                     || pair.getState() == CandidatePairState.FROZEN\n                     || (pair.getState() == CandidatePairState.IN_PROGRESS\n                         && pair.getPriority() < nominatedPair.getPriority())))\n            {\n                pairsIter.remove();\n            }\n        }\n\n        synchronized(triggeredCheckQueue)\n        {\n            Iterator<CandidatePair> triggeredPairsIter\n                = triggeredCheckQueue.iterator();\n            while (triggeredPairsIter.hasNext())\n            {\n                CandidatePair pair = triggeredPairsIter.next();\n                if (pair.getParentComponent() == cmp\n                    &&( pair.getState() == CandidatePairState.WAITING\n                        || pair.getState() == CandidatePairState.FROZEN\n                        || (pair.getState() == CandidatePairState.IN_PROGRESS\n                            && pair.getPriority() < nominatedPair\n                                                        .getPriority())))\n                {\n                    triggeredPairsIter.remove();\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns the name of this check list so that we could use it for debugging\n     * purposes.\n     *\n     * @return a name for this check list that we could use to distinguish it\n     * from other check lists while debugging.\n     */\n    public String getName()\n    {\n        return parentStream.getName();\n    }\n\n    /**\n     * Returns <tt>true</tt> if this <tt>CheckList</tt> already contains a\n     * nominated {@link CandidatePair} for the specified <tt>component</tt>\n     * and <tt>false</tt> otherwise.\n     *\n     * @param component the {@link Component} that we'd whose nominees we are\n     * interested in.\n     *\n     * @return <tt>true</tt> if this <tt>CheckList</tt> already contains a\n     * nominated {@link CandidatePair} for the specified <tt>component</tt>\n     * and <tt>false</tt> otherwise.\n     * @deprecated This method takes into account only candidates in the\n     * checklist. In case of peer reflexives candidates nominated, they do not\n     * appears in checklist but in valid list.\n     */\n    @Deprecated\n    public synchronized boolean containsNomineeForComponent(\n                                                        Component component)\n    {\n        for (CandidatePair pair : this)\n        {\n            if (pair.isNominated() && pair.getParentComponent() == component)\n                return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Adds <tt>l</tt> to the list of listeners tracking changes of the\n     * {@link CheckListState} of this <tt>CheckList</tt>\n     *\n     * @param l the listener to register.\n     */\n    public void addStateChangeListener(PropertyChangeListener l)\n    {\n        synchronized(stateListeners)\n        {\n            if (!stateListeners.contains(l))\n                this.stateListeners.add(l);\n        }\n    }\n\n    /**\n     * Removes <tt>l</tt> from the list of listeners tracking changes of the\n     * {@link CheckListState} of this <tt>CheckList</tt>\n     *\n     * @param l the listener to remove.\n     */\n    public void removeStateChangeListener(PropertyChangeListener l)\n    {\n        synchronized(stateListeners)\n        {\n            this.stateListeners.remove(l);\n        }\n    }\n\n    /**\n     * Creates a new {@link PropertyChangeEvent} and delivers it to all\n     * currently registered state listeners.\n     *\n     * @param oldState the {@link CheckListState} we had before the change\n     * @param newState the {@link CheckListState} we had after the change\n     */\n    private void fireStateChange(CheckListState oldState,\n                                 CheckListState newState)\n    {\n        List<PropertyChangeListener> listenersCopy;\n\n        synchronized(stateListeners)\n        {\n            listenersCopy = new LinkedList<>(stateListeners);\n        }\n\n        PropertyChangeEvent evt = new PropertyChangeEvent(\n                        this, PROPERTY_CHECK_LIST_STATE, oldState, newState);\n\n        for (PropertyChangeListener l : listenersCopy)\n        {\n            l.propertyChange(evt);\n        }\n    }\n\n    /**\n     * Add a <tt>CheckListener</tt>. It will be notified when ordinary checks\n     * ended.\n     *\n     * @param l <tt>CheckListener</tt> to add\n     */\n    public void addChecksListener(PropertyChangeListener l)\n    {\n        synchronized(checkListeners)\n        {\n            if (!checkListeners.contains(l))\n            {\n                checkListeners.add(l);\n            }\n        }\n    }\n\n    /**\n     * Remove a <tt>CheckListener</tt>.\n     *\n     * @param l <tt>CheckListener</tt> to remove\n     */\n    public void removeChecksListener(PropertyChangeListener l)\n    {\n        synchronized(checkListeners)\n        {\n            if (checkListeners.contains(l))\n            {\n                checkListeners.remove(l);\n            }\n        }\n    }\n\n    /**\n     * Creates a new {@link PropertyChangeEvent} and delivers it to all\n     * currently registered checks listeners.\n     */\n    protected void fireEndOfOrdinaryChecks()\n    {\n        List<PropertyChangeListener> listenersCopy;\n\n        synchronized(checkListeners)\n        {\n            listenersCopy = new LinkedList<>(checkListeners);\n        }\n\n        PropertyChangeEvent evt = new PropertyChangeEvent(\n                        this, PROPERTY_CHECK_LIST_CHECKS, false, true);\n\n        for (PropertyChangeListener l : listenersCopy)\n        {\n            l.propertyChange(evt);\n        }\n    }\n\n    /**\n     * Returns a reference to the {@link IceMediaStream} that created and that\n     * maintains this check list.\n     *\n     * @return a reference to the {@link IceMediaStream} that this list belongs\n     * to.\n     */\n    public IceMediaStream getParentStream()\n    {\n        return parentStream;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "\nA dummy serialization id.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "public static final String PROPERTY_CHECK_LIST_STATE = \"CheckListState\";", "docstring": "\nThe name of the {@link PropertyChangeEvent} that we use to deliver\nchanges on the state of this check list.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "PROPERTY_CHECK_LIST_STATE = \"CheckListState\"", "syntax_pass": true}, {"attribute_expression": "public static final String PROPERTY_CHECK_LIST_CHECKS = \"CheckListChecks\";", "docstring": "\nThe name of the {@link PropertyChangeEvent} that we use to deliver\nchanges on the end of checks of this check list.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "PROPERTY_CHECK_LIST_CHECKS = \"CheckListChecks\"", "syntax_pass": true}, {"attribute_expression": "private CheckListState state = CheckListState.RUNNING;", "docstring": "\nThe state of this check list.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CheckListState", "name": "state = CheckListState.RUNNING", "syntax_pass": true}, {"attribute_expression": "private final List<CandidatePair> triggeredCheckQueue = new LinkedList<>();", "docstring": "\nThe <tt>triggeredCheckQueue</tt> is a FIFO queue containing candidate\npairs for which checks are to be sent at the next available opportunity.\nA pair would get into a triggered check queue as soon as we receive\na check on its local candidate.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<CandidatePair>", "name": "triggeredCheckQueue = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private final IceMediaStream parentStream;", "docstring": "\nA reference to the {@link IceMediaStream} that we belong to.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "IceMediaStream", "name": "parentStream", "syntax_pass": true}, {"attribute_expression": "private final List<PropertyChangeListener> stateListeners\n        = new LinkedList<>();", "docstring": "\nContains {@link PropertyChangeListener}s registered with this {@link\nAgent} and following its changes of state.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<PropertyChangeListener>", "name": "stateListeners\n        = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private final List<PropertyChangeListener> checkListeners\n        = new LinkedList<>();", "docstring": "\nContains {@link PropertyChangeListener}s registered with this {@link\nAgent} and following its changes of state.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<PropertyChangeListener>", "name": "checkListeners\n        = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private Logger logger;", "docstring": "\nThe {@link Logger} used by {@link CheckList} instances.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Logger", "name": "logger", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/FoundationsRegistry.java.FoundationsRegistry", "name": "FoundationsRegistry", "file_path": "src/main/java/org/ice4j/ice/FoundationsRegistry.java", "superclasses": "", "methods": ["[void]assignFoundation(Candidate<?>)", "[String]obtainFoundationForPeerReflexiveCandidate()", "[int]size()"], "method_uris": ["src/main/java/org/ice4j/ice/FoundationsRegistry.java.FoundationsRegistry.[void]assignFoundation(Candidate<?>)", "src/main/java/org/ice4j/ice/FoundationsRegistry.java.FoundationsRegistry.[String]obtainFoundationForPeerReflexiveCandidate()", "src/main/java/org/ice4j/ice/FoundationsRegistry.java.FoundationsRegistry.[int]size()"], "overrides": null, "attributes": [], "class_docstring": "\nWe <tt>FoundationsRegistry</tt>s to keep track of and generate new\nfoundations within the lifetime of a single <tt>Agent</tt>.\n\n@author Emil Ivov\n", "original_string": "public class FoundationsRegistry\n{\n    /**\n     * The foundation number that was last assigned to a <tt>Candidate</tt>\n     */\n    private int lastAssignedFoundation = 0;\n\n    /**\n     * The foundation number that was last assigned to a PEER-REFLEXIVE\n     * <tt>RemoteCandidate</tt>\n     */\n    private int lastAssignedRemoteFoundation = 10000;\n\n    /**\n     * Contains mappings between a type+baseIP+server+transport\n     * <tt>String</tt>s and the foundation that has been assigned to them.\n     */\n    private Map<String, String> foundations = new Hashtable<>();\n\n    /**\n     * Assigns to <tt>candidate</tt> the foundation that corresponds to its\n     * base, type and transport properties or a new one if no foundation has\n     * been generated yet for the specific combination.\n     *\n     * @param candidate the <tt>Candidate</tt> that we'd like to assign a\n     * foundation to.\n     */\n    public void assignFoundation(Candidate<?> candidate)\n    {\n        //create the foundation key String\n        CandidateType candidateType = candidate.getType();\n        String type = candidateType.toString();\n        String base\n                  = candidate.getBase().getTransportAddress().getHostAddress();\n        String server;\n\n        switch (candidateType)\n        {\n        case SERVER_REFLEXIVE_CANDIDATE:\n            TransportAddress serverAddress = candidate.getStunServerAddress();\n            server = (serverAddress == null)\n                        ? \"\"\n                        : serverAddress.getHostAddress();\n            break;\n        case RELAYED_CANDIDATE:\n            server = candidate.getRelayServerAddress().getHostAddress();\n            break;\n        default:\n            server = null;\n            break;\n        }\n\n        String transport = candidate.getTransport().toString();\n\n        StringBuffer foundationStringBuff = new StringBuffer(type);\n        foundationStringBuff.append(base);\n        if (server != null)\n            foundationStringBuff.append(server);\n\n        foundationStringBuff.append(transport);\n\n        String foundationString = foundationStringBuff.toString();\n\n        String foundationValue = null;\n        synchronized(foundations)\n        {\n            foundationValue = foundations.get(foundationString);\n\n            //obtain a new foundation number if we don't have one for this kind\n            //of candidates.\n            if (foundationValue == null)\n            {\n                foundationValue = Integer.toString(++lastAssignedFoundation);\n                foundations.put(foundationString, foundationValue);\n            }\n        }\n\n        candidate.setFoundation(foundationValue);\n    }\n\n    /**\n     * Returns an (as far as you care) random foundation that could be assigned\n     * to a learned PEER-REFLEXIVE candidate.\n     *\n     * @return  a foundation <tt>String</tt> that could be assigned to a\n     * learned PEER-REFLEXIVE candidate.\n     */\n    public String obtainFoundationForPeerReflexiveCandidate()\n    {\n        return Integer.toString(lastAssignedRemoteFoundation++);\n    }\n\n    /**\n     * Returns the number of foundation <tt>String</tt>s that are currently\n     * tracked by the registry.\n     *\n     * @return the number of foundation <tt>String</tt>s that are currently\n     * tracked by this registry.\n     */\n    public int size()\n    {\n        return foundations.size();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private int lastAssignedFoundation = 0;", "docstring": "\nThe foundation number that was last assigned to a <tt>Candidate</tt>\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "lastAssignedFoundation = 0", "syntax_pass": true}, {"attribute_expression": "private int lastAssignedRemoteFoundation = 10000;", "docstring": "\nThe foundation number that was last assigned to a PEER-REFLEXIVE\n<tt>RemoteCandidate</tt>\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "lastAssignedRemoteFoundation = 10000", "syntax_pass": true}, {"attribute_expression": "private Map<String, String> foundations = new Hashtable<>();", "docstring": "\nContains mappings between a type+baseIP+server+transport\n<tt>String</tt>s and the foundation that has been assigned to them.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map<String, String>", "name": "foundations = new Hashtable<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java.ServerReflexiveCandidate", "name": "ServerReflexiveCandidate", "file_path": "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java", "superclasses": "LocalCandidate", "methods": ["[]ServerReflexiveCandidate(TransportAddress,HostCandidate,TransportAddress,CandidateExtendedType)", "[]ServerReflexiveCandidate(TransportAddress,HostCandidate,TransportAddress,StunCandidateHarvest,CandidateExtendedType)", "[IceSocketWrapper]getCandidateIceSocketWrapper()", "[void]free()"], "method_uris": ["src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java.ServerReflexiveCandidate.[]ServerReflexiveCandidate(TransportAddress,HostCandidate,TransportAddress,CandidateExtendedType)", "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java.ServerReflexiveCandidate.[]ServerReflexiveCandidate(TransportAddress,HostCandidate,TransportAddress,StunCandidateHarvest,CandidateExtendedType)", "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java.ServerReflexiveCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper()", "src/main/java/org/ice4j/ice/ServerReflexiveCandidate.java.ServerReflexiveCandidate.[void]free()"], "overrides": null, "attributes": [], "class_docstring": "\n<tt>ServerReflexiveCandidate</tt>s are candidates whose IP address and port\nare a binding allocated by a NAT for an agent when it sent a packet through\nthe NAT to a server. <tt>ServerReflexiveCandidate</tt>s can be learned by\nSTUN servers using the Binding Request, or TURN servers, which provides both\na Relayed and Server Reflexive candidate.\n<p>\nThis class does not contain a socket itself and in order to send bytes over\nthe network, one has to retrieve the socket of its base.\n</p>\n\n@author Emil Ivov\n", "original_string": "public class ServerReflexiveCandidate\n    extends LocalCandidate\n{\n    /**\n     * The STUN candidate harvest.\n     */\n    private final StunCandidateHarvest stunHarvest;\n\n    /**\n     * Creates a <tt>ServerReflexiveCandidate</tt> for the specified transport\n     * address, and base.\n     *\n     * @param address the {@link TransportAddress} that this <tt>Candidate</tt>\n     * is representing.\n     * @param base the {@link HostCandidate} that this server reflexive\n     * candidate was obtained through.\n     * @param stunSrvrAddr the {@link TransportAddress} of the stun server that\n     * reflected this candidate.\n     * @param extendedType The type of method used to discover this candidate\n     * (\"host\", \"upnp\", \"stun peer reflexive\", \"stun server reflexive\", \"turn\n     * relayed\", \"google turn relayed\", \"google tcp turn relayed\" or \"jingle\n     * node\").\n     */\n    public ServerReflexiveCandidate(TransportAddress address,\n                                    HostCandidate    base,\n                                    TransportAddress stunSrvrAddr,\n                                    CandidateExtendedType extendedType)\n    {\n        this(\n                address,\n                base,\n                stunSrvrAddr,\n                null,\n                extendedType);\n    }\n\n    /**\n     * Creates a <tt>ServerReflexiveCandidate</tt> for the specified transport\n     * address, and base.\n     *\n     * @param address the {@link TransportAddress} that this <tt>Candidate</tt>\n     * is representing.\n     * @param base the {@link HostCandidate} that this server reflexive\n     * candidate was obtained through.\n     * @param stunSrvrAddr the {@link TransportAddress} of the stun server that\n     * reflected this candidate.\n     * @param stunHarvest the {@link StunCandidateHarvest}\n     * @param extendedType The type of method used to discover this candidate\n     * (\"host\", \"upnp\", \"stun peer reflexive\", \"stun server reflexive\", \"turn\n     * relayed\", \"google turn relayed\", \"google tcp turn relayed\" or \"jingle\n     * node\").\n     */\n    public ServerReflexiveCandidate(TransportAddress address,\n                                    HostCandidate    base,\n                                    TransportAddress stunSrvrAddr,\n                                    StunCandidateHarvest stunHarvest,\n                                    CandidateExtendedType extendedType)\n    {\n        super(address,\n              base.getParentComponent(),\n              CandidateType.SERVER_REFLEXIVE_CANDIDATE,\n              extendedType,\n              base);\n\n        setBase(base);\n        setStunServerAddress(stunSrvrAddr);\n        this.stunHarvest = stunHarvest;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IceSocketWrapper getCandidateIceSocketWrapper()\n    {\n        return getBase().getCandidateIceSocketWrapper();\n    }\n\n    /**\n     * Frees resources allocated by this candidate such as its\n     * <tt>DatagramSocket</tt>, for example. The <tt>socket</tt> of this\n     * <tt>LocalCandidate</tt> is closed only if it is not the <tt>socket</tt>\n     * of the <tt>base</tt> of this <tt>LocalCandidate</tt>.\n     */\n    @Override\n    public void free()\n    {\n        super.free();\n\n        if (stunHarvest != null)\n            stunHarvest.close();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final StunCandidateHarvest stunHarvest;", "docstring": "\nThe STUN candidate harvest.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StunCandidateHarvest", "name": "stunHarvest", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/Component.java.Component", "name": "Component", "file_path": "src/main/java/org/ice4j/ice/Component.java", "superclasses": "", "methods": ["[]Component(int,IceMediaStream,KeepAliveStrategy,Logger)", "[]Component(int,IceMediaStream,KeepAliveStrategy,boolean,Logger)", "[boolean]addLocalCandidate(LocalCandidate)", "[List<LocalCandidate>]getLocalCandidates()", "[int]countLocalHostCandidates()", "[int]getLocalCandidateCount()", "[void]addRemoteCandidate(RemoteCandidate)", "[void]addUpdateRemoteCandidates(RemoteCandidate)", "[void]updateRemoteCandidates()", "[List<RemoteCandidate>]getRemoteCandidates()", "[void]addRemoteCandidates(List<RemoteCandidate>)", "[int]getRemoteCandidateCount()", "[IceMediaStream]getParentStream()", "[int]getComponentID()", "[String]toString()", "[String]toShortString()", "[void]prioritizeCandidates()", "[void]eliminateRedundantCandidates()", "[LocalCandidate]findRedundant(LocalCandidate)", "[LocalCandidate]getDefaultCandidate()", "[Candidate<?>]getDefaultRemoteCandidate()", "[void]setDefaultRemoteCandidate(Candidate<?>)", "[void]selectDefaultCandidate()", "[void]free()", "[void]free(LocalCandidate)", "[LocalCandidate]findLocalCandidate(TransportAddress)", "[LocalCandidate]findLocalCandidate(TransportAddress,LocalCandidate)", "[RemoteCandidate]findRemoteCandidate(TransportAddress)", "[void]setSelectedPair(CandidatePair)", "[CandidatePair]getSelectedPair()", "[String]getName()", "[Component]build(int,IceMediaStream,Logger)", "[ComponentSocket]getComponentSocket()", "[MultiplexingDatagramSocket]getSocket()", "[IceSocketWrapper]getSocketWrapper()", "[Set<CandidatePair>]getKeepAlivePairs()", "[void]propertyChange(PropertyChangeEvent)", "[Logger]getLogger()", "[void]send(byte[],int,int)", "[void]handleBuffer(Buffer)", "[void]setBufferCallback(BufferHandler)"], "method_uris": ["src/main/java/org/ice4j/ice/Component.java.Component.[]Component(int,IceMediaStream,KeepAliveStrategy,Logger)", "src/main/java/org/ice4j/ice/Component.java.Component.[]Component(int,IceMediaStream,KeepAliveStrategy,boolean,Logger)", "src/main/java/org/ice4j/ice/Component.java.Component.[boolean]addLocalCandidate(LocalCandidate)", "src/main/java/org/ice4j/ice/Component.java.Component.[List<LocalCandidate>]getLocalCandidates()", "src/main/java/org/ice4j/ice/Component.java.Component.[int]countLocalHostCandidates()", "src/main/java/org/ice4j/ice/Component.java.Component.[int]getLocalCandidateCount()", "src/main/java/org/ice4j/ice/Component.java.Component.[void]addRemoteCandidate(RemoteCandidate)", "src/main/java/org/ice4j/ice/Component.java.Component.[void]addUpdateRemoteCandidates(RemoteCandidate)", "src/main/java/org/ice4j/ice/Component.java.Component.[void]updateRemoteCandidates()", "src/main/java/org/ice4j/ice/Component.java.Component.[List<RemoteCandidate>]getRemoteCandidates()", "src/main/java/org/ice4j/ice/Component.java.Component.[void]addRemoteCandidates(List<RemoteCandidate>)", "src/main/java/org/ice4j/ice/Component.java.Component.[int]getRemoteCandidateCount()", "src/main/java/org/ice4j/ice/Component.java.Component.[IceMediaStream]getParentStream()", "src/main/java/org/ice4j/ice/Component.java.Component.[int]getComponentID()", "src/main/java/org/ice4j/ice/Component.java.Component.[String]toString()", "src/main/java/org/ice4j/ice/Component.java.Component.[String]toShortString()", "src/main/java/org/ice4j/ice/Component.java.Component.[void]prioritizeCandidates()", "src/main/java/org/ice4j/ice/Component.java.Component.[void]eliminateRedundantCandidates()", "src/main/java/org/ice4j/ice/Component.java.Component.[LocalCandidate]findRedundant(LocalCandidate)", "src/main/java/org/ice4j/ice/Component.java.Component.[LocalCandidate]getDefaultCandidate()", "src/main/java/org/ice4j/ice/Component.java.Component.[Candidate<?>]getDefaultRemoteCandidate()", "src/main/java/org/ice4j/ice/Component.java.Component.[void]setDefaultRemoteCandidate(Candidate<?>)", "src/main/java/org/ice4j/ice/Component.java.Component.[void]selectDefaultCandidate()", "src/main/java/org/ice4j/ice/Component.java.Component.[void]free()", "src/main/java/org/ice4j/ice/Component.java.Component.[void]free(LocalCandidate)", "src/main/java/org/ice4j/ice/Component.java.Component.[LocalCandidate]findLocalCandidate(TransportAddress)", "src/main/java/org/ice4j/ice/Component.java.Component.[LocalCandidate]findLocalCandidate(TransportAddress,LocalCandidate)", "src/main/java/org/ice4j/ice/Component.java.Component.[RemoteCandidate]findRemoteCandidate(TransportAddress)", "src/main/java/org/ice4j/ice/Component.java.Component.[void]setSelectedPair(CandidatePair)", "src/main/java/org/ice4j/ice/Component.java.Component.[CandidatePair]getSelectedPair()", "src/main/java/org/ice4j/ice/Component.java.Component.[String]getName()", "src/main/java/org/ice4j/ice/Component.java.Component.[Component]build(int,IceMediaStream,Logger)", "src/main/java/org/ice4j/ice/Component.java.Component.[ComponentSocket]getComponentSocket()", "src/main/java/org/ice4j/ice/Component.java.Component.[MultiplexingDatagramSocket]getSocket()", "src/main/java/org/ice4j/ice/Component.java.Component.[IceSocketWrapper]getSocketWrapper()", "src/main/java/org/ice4j/ice/Component.java.Component.[Set<CandidatePair>]getKeepAlivePairs()", "src/main/java/org/ice4j/ice/Component.java.Component.[void]propertyChange(PropertyChangeEvent)", "src/main/java/org/ice4j/ice/Component.java.Component.[Logger]getLogger()", "src/main/java/org/ice4j/ice/Component.java.Component.[void]send(byte[],int,int)", "src/main/java/org/ice4j/ice/Component.java.Component.[void]handleBuffer(Buffer)", "src/main/java/org/ice4j/ice/Component.java.Component.[void]setBufferCallback(BufferHandler)"], "overrides": null, "attributes": [], "class_docstring": "\nA component is a piece of a media stream requiring a single transport\naddress; a media stream may require multiple components, each of which has\nto work for the media stream as a whole to work. For media streams based on\nRTP, there are two components per media stream - one for RTP, and one for\nRTCP.\n<p>\n\n@author Emil Ivov\n@author Sebastien Vincent\n@author Boris Grozev\n", "original_string": "public class Component\n    implements PropertyChangeListener, BufferHandler\n{\n    /**\n     * The component ID to use with RTP streams.\n     */\n    public static final int RTP = 1;\n\n    /**\n     * The component ID to use with RTCP streams.\n     */\n    public static final int RTCP = 2;\n\n    /**\n     * A component id is a positive integer between 1 and 256 which identifies\n     * the specific component of the media stream for which this is a candidate.\n     * It MUST start at 1 and MUST increment by 1 for each component of a\n     * particular candidate. For media streams based on RTP, candidates for the\n     * actual RTP media MUST have a component ID of 1, and candidates for RTCP\n     * MUST have a component ID of 2. Other types of media streams which\n     * require multiple components MUST develop specifications which define the\n     * mapping of components to component IDs. See Section 14 of RFC5245 for\n     * additional discussion on extending ICE to new media streams.\n     */\n    private final int componentID;\n\n    /**\n     * The <tt>IceMediaStream</tt> that this <tt>Component</tt> belongs to.\n     */\n    private final IceMediaStream parentStream;\n\n    /**\n     * The list locally gathered candidates for this media stream.\n     */\n    private final List<LocalCandidate> localCandidates = new LinkedList<>();\n\n    /**\n     * The list of candidates that the peer agent sent for this stream.\n     */\n    private final List<RemoteCandidate> remoteCandidates = new LinkedList<>();\n\n    /**\n     * The list of candidates that the peer agent sent for this stream after\n     * connectivity establishment.\n     */\n    private final List<RemoteCandidate> remoteUpdateCandidates\n        = new LinkedList<>();\n\n    /**\n     * A <tt>Comparator</tt> that we use for sorting <tt>Candidate</tt>s by\n     * their priority.\n     */\n    private final CandidatePrioritizer candidatePrioritizer\n        = new CandidatePrioritizer();\n\n    /**\n     * The default <tt>Candidate</tt> for this component or in other words, the\n     * candidate that we would have used without ICE.\n     */\n    private LocalCandidate defaultCandidate = null;\n\n    /**\n     * The pair that has been selected for use by ICE processing\n     */\n    private CandidatePair selectedPair;\n\n    /**\n     * The default <tt>RemoteCandidate</tt> for this component or in other\n     * words, the candidate that we would have used to communicate with the\n     * remote peer if we hadn't been using ICE.\n     */\n    private Candidate<?> defaultRemoteCandidate = null;\n\n    /**\n     * The {@link Logger} used by {@link Component} instances.\n     */\n    private final Logger logger;\n\n    /**\n     * The {@link ComponentSocket} instance which, if enabled, will serve as the\n     * single socket instance for this {@link Component}, merging received\n     * packets from all of its candidates.\n     */\n    private final ComponentSocket componentSocket;\n\n    /**\n     * The public view of {@link #componentSocket}, wrapped in a\n     * {@link MultiplexingDatagramSocket} for the convenience of users of the\n     * library.\n     * This is the instance which should be used by applications for\n     * reading/writing application data.\n     */\n    private final MultiplexingDatagramSocket socket;\n\n    /**\n     * A wrapper around {@link #socket}, kept only to help preserve the old\n     * API (see {@link LocalCandidate#getIceSocketWrapper()} and\n     * {@link CandidatePair#getIceSocketWrapper()})\n     */\n    @Deprecated\n    private final IceSocketWrapper socketWrapper;\n\n    /**\n     * The {@link KeepAliveStrategy} used by this component to select which\n     * pairs are to be kept alive.\n     */\n    private final KeepAliveStrategy keepAliveStrategy;\n\n    /**\n     * The set of pairs which this component wants to keep alive.\n     */\n    private final Set<CandidatePair> keepAlivePairs = Collections.newSetFromMap(new ConcurrentHashMap<>());\n\n    /**\n     * External callback for the push API. Called with every packet received via {@link #handleBuffer(Buffer)}.\n     */\n    private BufferHandler bufferCallback = null;\n\n    /**\n     * Creates a new <tt>Component</tt> with the specified <tt>componentID</tt>\n     * as a child of the specified <tt>IceMediaStream</tt>.\n     *\n     * @param componentID the id of this component.\n     * @param mediaStream the {@link IceMediaStream} instance that would be the\n     * parent of this component.\n     * @deprecated\n     */\n    protected Component(int componentID,\n                        IceMediaStream mediaStream,\n                        KeepAliveStrategy keepAliveStrategy,\n                        Logger parentLogger)\n    {\n        this(componentID, mediaStream, keepAliveStrategy, true, parentLogger);\n    }\n\n    /**\n     * Creates a new <tt>Component</tt> with the specified <tt>componentID</tt>\n     * as a child of the specified <tt>IceMediaStream</tt>.\n     *\n     * @param componentID the id of this component.\n     * @param mediaStream the {@link IceMediaStream} instance that would be the\n     * parent of this component.\n     * @param useComponentSocket whether the component socket should be used.\n     */\n    protected Component(int componentID,\n                        IceMediaStream mediaStream,\n                        KeepAliveStrategy keepAliveStrategy,\n                        boolean useComponentSocket,\n                        Logger parentLogger)\n    {\n        // the max value for componentID is 256\n        this.componentID = componentID;\n        this.parentStream = mediaStream;\n        this.keepAliveStrategy\n            = Objects.requireNonNull(keepAliveStrategy, \"keepAliveStrategy\");\n        this.logger = parentLogger.createChildLogger(\n                this.getClass().getName(),\n                Collections.singletonMap(\"componentId\", Integer.toString(componentID))\n        );\n\n        if (useComponentSocket)\n        {\n            try\n            {\n                componentSocket = new ComponentSocket(this, logger);\n                socket = new MultiplexingDatagramSocket(componentSocket);\n                socketWrapper = new IceUdpSocketWrapper(socket);\n            }\n            catch (SocketException se)\n            {\n                throw new RuntimeException(se);\n            }\n        }\n        else\n        {\n            componentSocket = null;\n            socket = null;\n            socketWrapper = null;\n        }\n\n        mediaStream.addPairChangeListener(this);\n    }\n\n    /**\n     * Add a local candidate to this component. The method should only be\n     * accessed and local candidates added by the candidate harvesters\n     * registered with the agent.\n     *\n     * @param candidate the candidate object to be added\n     *\n     * @return <tt>true</tt> if we actually added the new candidate or\n     * <tt>false</tt> in case we didn't because it was redundant to an existing\n     * candidate.\n     */\n    public boolean addLocalCandidate(LocalCandidate candidate)\n    {\n        Agent agent = getParentStream().getParentAgent();\n\n        //assign foundation.\n        agent.getFoundationsRegistry().assignFoundation(candidate);\n\n        //compute priority\n        candidate.computePriority();\n\n        synchronized(localCandidates)\n        {\n            //check if we already have such a candidate (redundant)\n            LocalCandidate redundantCandidate = findRedundant(candidate);\n\n            if (redundantCandidate != null)\n            {\n                //if we get here, then it's clear we won't be adding anything\n                //we will just update something at best. We purposefully don't\n                //care about priorities because allowing candidate replace is\n                //tricky to handle on the signalling layer with trickle\n                return false;\n            }\n\n            localCandidates.add(candidate);\n\n            //we are done adding ... now let's just order by priority.\n            Collections.sort(localCandidates);\n\n            return true;\n        }\n    }\n\n    /**\n     * Returns a copy of the list containing all local candidates currently\n     * registered in this component.\n     *\n     * @return Returns a copy of the list containing all local candidates\n     * currently registered in this <tt>Component</tt>.\n     */\n    public List<LocalCandidate> getLocalCandidates()\n    {\n        synchronized(localCandidates)\n        {\n            return new ArrayList<>(localCandidates);\n        }\n    }\n\n    /**\n     * Returns the number of local host candidates currently registered in this\n     * <tt>Component</tt>.\n     *\n     * @return the number of local host candidates currently registered in this\n     * <tt>Component</tt>.\n     */\n    public int countLocalHostCandidates()\n    {\n        synchronized(localCandidates)\n        {\n            int count = 0;\n            for (Candidate<?> cand : localCandidates)\n            {\n                if ((cand.getType() == CandidateType.HOST_CANDIDATE)\n                        && !cand.isVirtual())\n                {\n                    count++;\n                }\n            }\n\n            return count;\n        }\n    }\n\n    /**\n     * Returns the number of all local candidates currently registered in this\n     * <tt>Component</tt>.\n     *\n     * @return the number of all local candidates currently registered in this\n     * <tt>Component</tt>.\n     */\n    public int getLocalCandidateCount()\n    {\n        synchronized(localCandidates)\n        {\n            return localCandidates.size();\n        }\n    }\n\n    /**\n     * Adds a remote <tt>Candidate</tt>s to this media-stream\n     * <tt>Component</tt>.\n     *\n     * @param candidate the <tt>Candidate</tt> instance to add.\n     */\n    public void addRemoteCandidate(RemoteCandidate candidate)\n    {\n        logger.info(\"Add remote candidate for \" + toShortString()\n                            + \": \" + candidate.toRedactedShortString());\n\n        synchronized(remoteCandidates)\n        {\n            remoteCandidates.add(candidate);\n        }\n    }\n\n    /**\n     * Update the media-stream <tt>Component</tt> with the specified\n     * <tt>Candidate</tt>s. This would happen when performing trickle ICE.\n     *\n     * @param candidate new <tt>Candidate</tt> to add.\n     */\n    public void addUpdateRemoteCandidates(RemoteCandidate candidate)\n    {\n        logger.info(\"Update remote candidate for \" + toShortString() + \": \" +\n                candidate.getTransportAddress());\n\n        List<RemoteCandidate> existingCandidates = new LinkedList<>();\n        synchronized (remoteCandidates)\n        {\n            existingCandidates.addAll(remoteCandidates);\n        }\n\n        synchronized(remoteUpdateCandidates)\n        {\n            existingCandidates.addAll(remoteUpdateCandidates);\n\n            // Make sure we add no duplicates\n            TransportAddress transportAddress = candidate.getTransportAddress();\n            CandidateType type = candidate.getType();\n            for (RemoteCandidate existingCandidate : existingCandidates)\n            {\n                if (transportAddress\n                        .equals(existingCandidate.getTransportAddress())\n                    && type == existingCandidate.getType())\n                {\n                    logger.info(\"Not adding duplicate remote candidate: \"\n                                    + candidate.getTransportAddress());\n                    return;\n                }\n            }\n\n            remoteUpdateCandidates.add(candidate);\n        }\n    }\n\n    /**\n     * Update ICE processing with new <tt>Candidate</tt>s.\n     */\n    public void updateRemoteCandidates()\n    {\n        List<CandidatePair> checkList;\n        List<RemoteCandidate> newRemoteCandidates;\n\n        synchronized(remoteUpdateCandidates)\n        {\n            if (remoteUpdateCandidates.size() == 0)\n                return;\n\n            newRemoteCandidates = new LinkedList<>(remoteUpdateCandidates);\n\n            List<LocalCandidate> localCnds = getLocalCandidates();\n\n            // remove UPnP base from local candidate\n            LocalCandidate upnpBase = null;\n            for (LocalCandidate lc : localCnds)\n            {\n                if (lc instanceof UPNPCandidate)\n                {\n                    upnpBase = lc.getBase();\n                }\n            }\n\n            checkList = new Vector<>();\n\n            for (LocalCandidate localCnd : localCnds)\n            {\n                if (localCnd == upnpBase)\n                    continue;\n\n                //pair each of the new remote candidates with each of our locals\n                for (RemoteCandidate remoteCnd : remoteUpdateCandidates)\n                {\n                    if (localCnd.canReach(remoteCnd)\n                            && remoteCnd.getTransportAddress().getPort() != 0)\n                    {\n                        // A single LocalCandidate might be/become connected\n                        // to more more than one remote address, and that's ok\n                        // (that is, we need to form pairs with them all).\n                        /*\n                        if (localCnd.getTransport() == Transport.TCP &&\n                            localCnd.getIceSocketWrapper().getTCPSocket().\n                                isConnected())\n                        {\n                            if (!localCnd.getIceSocketWrapper().getTCPSocket().\n                                getRemoteSocketAddress().equals(\n                                    remoteCnd.getTransportAddress()))\n                            {\n                                continue;\n                            }\n                        }\n                        */\n\n                        CandidatePair pair\n                            = getParentStream()\n                                .getParentAgent()\n                                    .createCandidatePair(localCnd, remoteCnd);\n                        checkList.add(pair);\n                    }\n                }\n            }\n            remoteUpdateCandidates.clear();\n        }\n\n        synchronized (remoteCandidates)\n        {\n            remoteCandidates.addAll(newRemoteCandidates);\n        }\n\n        //sort and prune update checklist\n        Collections.sort(checkList, CandidatePair.comparator);\n        parentStream.pruneCheckList(checkList);\n\n        if (parentStream.getCheckList().getState().equals(\n                CheckListState.RUNNING))\n        {\n            //add the updated CandidatePair list to the currently running\n            //checklist\n            CheckList streamCheckList = parentStream.getCheckList();\n            synchronized(streamCheckList)\n            {\n                for (CandidatePair pair : checkList)\n                {\n                    /* Check whether the pair is already in the check list.\n                     * (This can happen for pairs with remote peer-reflexive candidates,\n                     *  since those candidates aren't added to the candidate list even\n                     *  though the pair is added to the check list).\n                     */\n                    CandidatePair existingPair\n                        = streamCheckList.findPairMatching(pair.getLocalCandidate(), pair.getRemoteCandidate());\n                    if (existingPair != null)\n                    {\n                        logger.info(\"existing Pair updated: \" +\n                            existingPair.toRedactedShortString() +\n                            \" to \" + pair.toRedactedShortString() + \".\");\n                        existingPair.setRemoteCandidate(pair.getRemoteCandidate());\n                        existingPair.computePriority();\n                    }\n                    else\n                    {\n                        streamCheckList.add(pair);\n                        logger.info(\"new Pair added: \" + pair.toRedactedShortString()\n                            + \".\");\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a copy of the list containing all remote candidates currently\n     * registered in this component.\n     *\n     * @return Returns a copy of the list containing all remote candidates\n     * currently registered in this <tt>Component</tt>.\n     */\n    public List<RemoteCandidate> getRemoteCandidates()\n    {\n        synchronized(remoteCandidates)\n        {\n            return new ArrayList<>(remoteCandidates);\n        }\n    }\n\n    /**\n     * Adds a List of remote <tt>Candidate</tt>s as reported by a remote agent.\n     *\n     * @param candidates the <tt>List</tt> of <tt>Candidate</tt>s reported by\n     * the remote agent for this component.\n     */\n    public void addRemoteCandidates(List<RemoteCandidate> candidates)\n    {\n        synchronized(remoteCandidates)\n        {\n            remoteCandidates.addAll(candidates);\n        }\n    }\n\n    /**\n     * Returns the number of all remote candidates currently registered in this\n     * <tt>Component</tt>.\n     *\n     * @return the number of all remote candidates currently registered in this\n     * <tt>Component</tt>.\n     */\n    public int getRemoteCandidateCount()\n    {\n        synchronized(remoteCandidates)\n        {\n            return remoteCandidates.size();\n        }\n    }\n\n    /**\n     * Returns a reference to the <tt>IceMediaStream</tt> that this\n     * <tt>Component</tt> belongs to.\n     *\n     * @return  a reference to the <tt>IceMediaStream</tt> that this\n     * <tt>Component</tt> belongs to.\n     */\n    public IceMediaStream getParentStream()\n    {\n        return parentStream;\n    }\n\n    /**\n     * Returns the ID of this <tt>Component</tt>. For RTP/RTCP flows this would\n     * be <tt>1</tt> for RTP and 2 for <tt>RTCP</tt>.\n     *\n     * @return the ID of this <tt>Component</tt>.\n     */\n    public int getComponentID()\n    {\n        return componentID;\n    }\n\n    /**\n     * Returns a <tt>String</tt> representation of this <tt>Component</tt>\n     * containing its ID, parent stream name and any existing candidates.\n     *\n     * @return  a <tt>String</tt> representation of this <tt>Component</tt>\n     * containing its ID, parent stream name and any existing candidates.\n     */\n    public String toString()\n    {\n        StringBuffer buff\n            = new StringBuffer(\"Component id=\").append(getComponentID());\n\n        buff.append(\" parent stream=\").append(getParentStream().getName());\n\n        //local candidates\n        int localCandidatesCount = getLocalCandidateCount();\n\n        if (localCandidatesCount > 0)\n        {\n            buff.append(\"\\n\")\n                .append(localCandidatesCount)\n                .append(\" Local candidates:\");\n            buff.append(\"\\ndefault candidate: \").append(getDefaultCandidate());\n\n            synchronized(localCandidates)\n            {\n                for (Candidate<?> cand : localCandidates)\n                {\n                    buff.append('\\n').append(cand.toString());\n                }\n            }\n        }\n        else\n        {\n            buff.append(\"\\nno local candidates.\");\n        }\n\n        //remote candidates\n        int remoteCandidatesCount = getRemoteCandidateCount();\n\n        if (remoteCandidatesCount > 0)\n        {\n            buff.append(\"\\n\")\n                .append(remoteCandidatesCount)\n                .append(\" Remote candidates:\");\n            Candidate<?> defaultRemoteCandidate = getDefaultRemoteCandidate();\n            buff.append(\"\\ndefault remote candidate: \");\n            if (defaultRemoteCandidate != null)\n            {\n                buff.append(defaultRemoteCandidate.toRedactedString());\n            }\n            else\n            {\n                buff.append(\"null\");\n            }\n\n            synchronized(remoteCandidates)\n            {\n                for (RemoteCandidate cand : remoteCandidates)\n                {\n                    buff.append(\"\\n\").append(cand.toRedactedString());\n                }\n            }\n        }\n        else\n        {\n            buff.append(\"\\nno remote candidates.\");\n        }\n\n        return buff.toString();\n    }\n\n    /**\n     * Returns a short <tt>String</tt> representation of this\n     * <tt>Component</tt>.\n     *\n     * @return a short <tt>String</tt> representation of this\n     * <tt>Component</tt>.\n     */\n    public String toShortString()\n    {\n        return parentStream.getName() + \".\" + getName();\n    }\n\n    /**\n     * Computes the priorities of all <tt>Candidate</tt>s and then sorts them\n     * accordingly.\n     *\n     * @deprecated candidates are now being prioritized upon addition and\n     * calling this method is no longer necessary.\n     */\n    @Deprecated\n    protected void prioritizeCandidates()\n    {\n        synchronized(localCandidates)\n        {\n            LocalCandidate[] candidates\n                = new LocalCandidate[localCandidates.size()];\n\n            localCandidates.toArray(candidates);\n\n            //first compute the actual priorities\n            for (Candidate<?> cand : candidates)\n            {\n                cand.computePriority();\n            }\n\n            //sort\n            Arrays.sort(candidates, candidatePrioritizer);\n\n            //now re-add the candidates in the order they've been sorted in.\n            localCandidates.clear();\n            for (LocalCandidate cand : candidates)\n                localCandidates.add(cand);\n        }\n    }\n\n    /**\n     * Eliminates redundant candidates, removing them from the specified\n     * <tt>component</tt>.  A candidate is redundant if its transport address\n     * equals another candidate, and its base equals the base of that other\n     * candidate.  Note that two candidates can have the same transport address\n     * yet have different bases, and these would not be considered redundant.\n     * Frequently, a server reflexive candidate and a host candidate will be\n     * redundant when the agent is not behind a NAT.  The agent SHOULD eliminate\n     * the redundant candidate with the lower priority which is why we have to\n     * run this method only after prioritizing candidates.\n     *\n     * @deprecated redundancies are now being detected upon addition of\n     * candidates and calling this method is no longer necessary.\n     */\n    @Deprecated\n    protected void eliminateRedundantCandidates()\n    {\n        /*\n         * Find and remove all candidates that have the same address and base as\n         * cand and a lower priority. The algorithm implemented bellow does rely\n         * on localCandidates being ordered in decreasing order (as said in its\n         * javadoc that the eliminateRedundantCandidates method is called only\n         * after prioritizeCandidates.\n         */\n        synchronized (localCandidates)\n        {\n            for (int i = 0; i < localCandidates.size(); i++)\n            {\n                LocalCandidate cand = localCandidates.get(i);\n\n                for (int j = i + 1; j < localCandidates.size();)\n                {\n                    LocalCandidate cand2 = localCandidates.get(j);\n\n                    if ((cand != cand2)\n                            && cand.getTransportAddress().equals(\n                                    cand2.getTransportAddress())\n                            && cand.getBase().equals(cand2.getBase())\n                            && (cand.getPriority() >= cand2.getPriority()))\n                    {\n                        localCandidates.remove(j);\n                        logger.trace(() -> \"eliminating redundant cand: \"+ cand2);\n                    }\n                    else\n                        j++;\n                }\n            }\n        }\n    }\n\n    /**\n     * Finds and returns the first candidate that is redundant to <tt>cand</tt>.\n     * A candidate is redundant if its transport address equals another\n     * candidate, and its base equals the base of that other candidate. Note\n     * that two candidates can have the same transport address yet have\n     * different bases, and these would not be considered redundant. Frequently,\n     * a server reflexive candidate and a host candidate will be redundant when\n     * the agent is not behind a NAT. The agent SHOULD eliminate the redundant\n     * candidate with the lower priority which is why we have to run this method\n     * only after prioritizing candidates.\n     *\n     * @param cand the {@link LocalCandidate} that we'd like to check for\n     * redundancies.\n     *\n     * @return the first candidate that is redundant to <tt>cand</tt> or\n     * <tt>null</tt> if there is no such candidate.\n     */\n    private LocalCandidate findRedundant(LocalCandidate cand)\n    {\n        synchronized (localCandidates)\n        {\n            for (LocalCandidate redundantCand : localCandidates)\n            {\n                if ((cand != redundantCand)\n                        && cand.getTransportAddress().equals(\n                                redundantCand.getTransportAddress())\n                        && cand.getBase().equals(redundantCand.getBase()))\n                {\n                    return redundantCand;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the <tt>Candidate</tt> that has been selected as the default\n     * for this <tt>Component</tt> or <tt>null</tt> if no such\n     * <tt>Candidate</tt> has been selected yet. A candidate is said to be\n     * default if it would be the target of media from a non-ICE peer;\n     *\n     * @return the <tt>Candidate</tt> that has been selected as the default for\n     * this <tt>Component</tt> or <tt>null</tt> if no such <tt>Candidate</tt>\n     * has been selected yet\n     */\n    public LocalCandidate getDefaultCandidate()\n    {\n        return defaultCandidate;\n    }\n\n    /**\n     * Returns the <tt>Candidate</tt> that the remote party has reported as\n     * default for this <tt>Component</tt> or <tt>null</tt> if no such\n     * <tt>Candidate</tt> has been reported yet. A candidate is said to be\n     * default if it would be the target of media from a non-ICE peer;\n     *\n     * @return the <tt>Candidate</tt> that the remote party has reported as\n     * default for this <tt>Component</tt> or <tt>null</tt> if no such\n     * <tt>Candidate</tt> has reported yet.\n     */\n    public Candidate<?> getDefaultRemoteCandidate()\n    {\n        return defaultRemoteCandidate;\n    }\n\n    /**\n     * Sets the <tt>Candidate</tt> that the remote party has reported as\n     * default for this <tt>Component</tt>. A candidate is said to be\n     * default if it would be the target of media from a non-ICE peer;\n     *\n     * @param candidate the <tt>Candidate</tt> that the remote party has\n     * reported as default for this <tt>Component</tt>.\n     */\n    public void setDefaultRemoteCandidate(Candidate<?> candidate)\n    {\n        this.defaultRemoteCandidate = candidate;\n    }\n\n    /**\n     * Selects a <tt>Candidate</tt> that should be considered as the default\n     * for this <tt>Component</tt>. A candidate is said to be default if it\n     * would be the target of media from a non-ICE peer;\n     * <p>\n     * The ICE specification RECOMMENDEDs that default candidates be chosen\n     * based on the likelihood of those candidates to work with the peer that is\n     * being contacted. It is RECOMMENDED that the default candidates are the\n     * relayed candidates (if relayed candidates are available), server\n     * reflexive candidates (if server reflexive candidates are available), and\n     * finally host candidates.\n     * </p>\n     */\n    protected void selectDefaultCandidate()\n    {\n        synchronized(localCandidates)\n        {\n            for (LocalCandidate cand : localCandidates)\n            {\n                if ((defaultCandidate == null)\n                        || (defaultCandidate.getDefaultPreference()\n                                < cand.getDefaultPreference()))\n                {\n                    defaultCandidate = cand;\n                }\n            }\n        }\n    }\n\n    /**\n     * Releases all resources allocated by this <tt>Component</tt> and its\n     * <tt>Candidate</tt>s like sockets for example.\n     */\n    protected void free()\n    {\n        synchronized (localCandidates)\n        {\n            /*\n             * Since the sockets of the non-HostCandidate LocalCandidates may\n             * depend on the socket of the HostCandidate for which they have\n             * been harvested, order the freeing.\n             */\n            CandidateType[] candidateTypes\n                = new CandidateType[]\n                        {\n                            CandidateType.RELAYED_CANDIDATE,\n                            CandidateType.PEER_REFLEXIVE_CANDIDATE,\n                            CandidateType.SERVER_REFLEXIVE_CANDIDATE\n                        };\n\n            for (CandidateType candidateType : candidateTypes)\n            {\n                Iterator<LocalCandidate> localCandidateIter\n                    = localCandidates.iterator();\n\n                while (localCandidateIter.hasNext())\n                {\n                    LocalCandidate localCandidate = localCandidateIter.next();\n\n                    if (candidateType.equals(localCandidate.getType()))\n                    {\n                        free(localCandidate);\n                        localCandidateIter.remove();\n                    }\n                }\n            }\n\n            // Free whatever's left.\n            Iterator<LocalCandidate> localCandidateIter\n                = localCandidates.iterator();\n\n            while (localCandidateIter.hasNext())\n            {\n                LocalCandidate localCandidate = localCandidateIter.next();\n\n                free(localCandidate);\n                localCandidateIter.remove();\n            }\n        }\n\n        getParentStream().removePairStateChangeListener(this);\n        keepAlivePairs.clear();\n        if (componentSocket != null)\n        {\n            componentSocket.close();\n        }\n        if (socket != null)\n        {\n            socket.close();\n        }\n    }\n\n    /**\n     * Frees a specific <tt>LocalCandidate</tt> and swallows any\n     * <tt>Throwable</tt> it throws while freeing itself in order to prevent its\n     * failure to affect the rest of the execution.\n     *\n     * @param localCandidate the <tt>LocalCandidate</tt> to be freed\n     */\n    private void free(LocalCandidate localCandidate)\n    {\n        try\n        {\n            localCandidate.free();\n        }\n        catch (Throwable t)\n        {\n            /*\n             * Don't let the failing of a single LocalCandidate to free itself\n             * to fail the freeing of the other LocalCandidates.\n             */\n            if (t instanceof ThreadDeath)\n                throw (ThreadDeath) t;\n            logger.info(() -> \"Failed to free LocalCandidate: \" + localCandidate);\n        }\n    }\n\n    /**\n     * Returns the local <tt>LocalCandidate</tt> with the specified\n     * <tt>localAddress</tt> if it belongs to this component or <tt>null</tt>\n     * if it doesn't.\n     *\n     * @param localAddress the {@link TransportAddress} we are looking for.\n     *\n     * @return  the local <tt>LocalCandidate</tt> with the specified\n     * <tt>localAddress</tt> if it belongs to this component or <tt>null</tt>\n     * if it doesn't.\n     */\n    public LocalCandidate findLocalCandidate(TransportAddress localAddress)\n    {\n        return findLocalCandidate(localAddress, null);\n    }\n\n    /**\n     * Returns the local <tt>LocalCandidate</tt> with the specified\n     * <tt>address</tt> if it belongs to this component or <tt>null</tt>\n     * if it doesn't. If {@code base} is also specified, tries to find a\n     * candidate whose base matches {@code base}.\n     *\n     * @param address the {@link TransportAddress} we are looking for.\n     * @param base an optional base to match.\n     *\n     * @return  the local <tt>LocalCandidate</tt> with the specified\n     * <tt>address</tt> if it belongs to this component or <tt>null</tt>\n     * if it doesn't.\n     */\n    public LocalCandidate findLocalCandidate(TransportAddress address, LocalCandidate base)\n    {\n        for (LocalCandidate localCandidate : localCandidates)\n        {\n            if (localCandidate.getTransportAddress().equals(address))\n            {\n                if (base == null || base.equals(localCandidate.getBase()))\n                {\n                    return localCandidate;\n                }\n            }\n        }\n        // In case the above loop failed to find a result because `base` was\n        // specified, fallback to the original behavior and return the first\n        // candidate matching `address` regardless of `base`.\n        for (LocalCandidate localCandidate : localCandidates)\n        {\n            if (localCandidate.getTransportAddress().equals(address))\n            {\n                logger.warn(\"Returning a candidate matching the address, \"\n                        + \"while no candidates match both address (\"\n                        + address + \") and base (\" + base +\"): \" + localCandidate\n                        + \" with base \" + localCandidate.getBase());\n                return localCandidate;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the remote <tt>Candidate</tt> with the specified\n     * <tt>remoteAddress</tt> if it belongs to this {@link Component} or\n     * <tt>null</tt> if it doesn't.\n     *\n     * @param remoteAddress the {@link TransportAddress} we are looking for.\n     *\n     * @return the remote <tt>RemoteCandidate</tt> with the specified\n     * <tt>remoteAddress</tt> if it belongs to this component or <tt>null</tt>\n     * if it doesn't.\n     */\n    public RemoteCandidate findRemoteCandidate(TransportAddress remoteAddress)\n    {\n        for (RemoteCandidate remoteCnd : remoteCandidates)\n        {\n            if (remoteCnd.getTransportAddress().equals(remoteAddress))\n            {\n                return remoteCnd;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Sets the {@link CandidatePair} selected for use by ICE processing and\n     * that the application would use.\n     *\n     * @param pair the {@link CandidatePair} selected for use by ICE processing.\n     */\n    protected void setSelectedPair(CandidatePair pair)\n    {\n        if (keepAliveStrategy == KeepAliveStrategy.SELECTED_ONLY)\n        {\n            keepAlivePairs.clear();\n        }\n        keepAlivePairs.add(pair);\n\n        this.selectedPair = pair;\n    }\n\n    /**\n     * Returns the {@link CandidatePair} selected for use by ICE processing or\n     * <tt>null</tt> if no pair has been selected so far or if ICE processing\n     * has failed.\n     *\n     * @return the {@link CandidatePair} selected for use by ICE processing or\n     * <tt>null</tt> if no pair has been selected so far or if ICE processing\n     * has failed.\n     */\n    public CandidatePair getSelectedPair()\n    {\n        return selectedPair;\n    }\n\n    /**\n     * Returns a human readable name that can be used in debug logs associated\n     * with this component.\n     *\n     * @return \"RTP\" if the component ID is 1, \"RTCP\" if the component id is 2\n     * and the component id itself otherwise.\n     */\n    public String getName()\n    {\n        if (componentID == RTP)\n        {\n            return \"RTP\";\n        }\n        else if (componentID == RTCP)\n        {\n            return \"RTCP\";\n        }\n        else\n        {\n            return Integer.toString(componentID);\n        }\n    }\n\n    /**\n     * Use builder pattern to allow creation of immutable Component instances,\n     * from outside the current package.\n     *\n     * @param componentID the id of this component.\n     * @param mediaStream the {@link IceMediaStream} instance that would be the\n     * parent of this component.\n     * @return Component\n     */\n    public static Component build(int componentID, IceMediaStream mediaStream, Logger parentLogger)\n    {\n        return\n            new Component(\n                    componentID,\n                    mediaStream,\n                    KeepAliveStrategy.SELECTED_ONLY,\n                    AgentConfig.config.getUseComponentSocket(),\n                    parentLogger\n            );\n    }\n\n    /**\n     * @return the single socket for this {@link Component} which should be\n     * used for reading and writing data, if the component socket is enabled\n     * and {@code null} if it is not enabled.\n     * </p>\n     * This is for ice4j internal use only! For reading/writing application\n     * data, use {@link #getSocket()}.\n     */\n    public ComponentSocket getComponentSocket()\n    {\n        return componentSocket;\n    }\n\n    /**\n     * @return the socket for this {@link Component}, which should be used for\n     * reading/writing application data. If the component socket is not enabled,\n     * this returns {@code null} and users of the library should use the socket\n     * instance from the desired candidate pair instead.\n     */\n    public MultiplexingDatagramSocket getSocket()\n    {\n        return socket;\n    }\n\n    /**\n     * @return an {@link IceSocketWrapper} instance wrapping the socket for this\n     * candidate (see {@link #getSocket()}).\n     * @deprecated Use {@link #getSocket()} directly. This is only introduced\n     * to ease the transition of applications which are already written to use\n     * a {@link IceSocketWrapper} instance.\n     */\n    public IceSocketWrapper getSocketWrapper()\n    {\n        return socketWrapper;\n    }\n\n    /**\n     * @return the set of candidate pairs which are to be kept alive.\n     */\n    Set<CandidatePair> getKeepAlivePairs()\n    {\n        return keepAlivePairs;\n    }\n\n    /**\n     * {@inheritDoc}\n     * </p>\n     * Handles events coming from candidate pairs.\n     */\n    @Override\n    public void propertyChange(PropertyChangeEvent event)\n    {\n        String propertyName = event.getPropertyName();\n        if (!(event.getSource() instanceof CandidatePair))\n        {\n            return;\n        }\n\n        CandidatePair pair = (CandidatePair) event.getSource();\n        if (!equals(pair.getParentComponent()))\n        {\n            // Events are fired by the IceMediaStream, which might have\n            // multiple components. Make sure that we only handle events for\n            // this component.\n            return;\n        }\n\n        boolean addToKeepAlive = false;\n\n        // We handle this case in setSelectedPair\n        if (keepAliveStrategy == KeepAliveStrategy.SELECTED_ONLY)\n            return;\n\n        if (IceMediaStream.PROPERTY_PAIR_STATE_CHANGED.equals(propertyName))\n        {\n            CandidatePairState newState\n                = (CandidatePairState) event.getNewValue();\n\n            if (CandidatePairState.SUCCEEDED.equals(newState))\n            {\n                if (keepAliveStrategy == KeepAliveStrategy.ALL_SUCCEEDED)\n                {\n                    addToKeepAlive = true;\n                }\n                else if (keepAliveStrategy == KeepAliveStrategy.SELECTED_AND_TCP)\n                {\n                    Transport transport\n                        = pair.getLocalCandidate().getTransport();\n                    addToKeepAlive = transport == Transport.TCP\n                        || transport == Transport.SSLTCP;\n\n                    // Pairs with a remote TCP port 9 cannot be checked.\n                    // Instead, the corresponding pair with the peer reflexive\n                    // candidate needs to be checked. However, we observe\n                    // such pairs transitioning into the SUCCEEDED state.\n                    // Ignore them.\n                    addToKeepAlive\n                        &= pair.getRemoteCandidate()\n                                .getTransportAddress().getPort() != 9;\n                }\n            }\n        }\n\n        if (addToKeepAlive && !keepAlivePairs.contains(pair))\n        {\n            keepAlivePairs.add(pair);\n        }\n    }\n\n    public Logger getLogger()\n    {\n        return logger;\n    }\n\n    /**\n     * Send a packet to the remote side. Uses the last used candidate pair to find the right socket and remote address.\n     */\n    public void send(byte[] buffer, int offset, int length)\n            throws IOException\n    {\n        CandidatePair pair = getSelectedPair();\n        if (pair == null)\n        {\n            logger.debug(\"No selected pair, will try valid for sending\");\n            pair = parentStream.getValidPair(this);\n            if (pair == null)\n            {\n                throw new IOException(\"No valid pair.\");\n            }\n        }\n\n        LocalCandidate localCandidate = pair.getLocalCandidate();\n        if (localCandidate != null && localCandidate.getBase() != null)\n        {\n            localCandidate = localCandidate.getBase();\n        }\n        SocketAddress remoteAddress = pair.getRemoteCandidate().getTransportAddress();\n        IceSocketWrapper socket\n                = localCandidate == null ? null : localCandidate.getCandidateIceSocketWrapper(remoteAddress);\n\n        if (socket == null)\n        {\n            throw new IOException(\"No socket found to send on.\");\n        }\n\n        DatagramPacket p = new DatagramPacket(buffer, offset, length);\n        p.setSocketAddress(remoteAddress);\n        socket.send(p);\n    }\n\n    /**\n     * Handle a buffer that was received from one of the sockets and should be forwarded to the application.\n     */\n    @Override\n    public void handleBuffer(@NotNull Buffer buffer)\n    {\n        BufferHandler bufferCallback = this.bufferCallback;\n\n        if (bufferCallback == null)\n        {\n            logger.warn(\n                    \"The push API is used while no buffer callback has been set, dropping a packet (use-push-api=\"\n                            + AbstractUdpListener.USE_PUSH_API + \").\");\n            BufferPool.returnBuffer.invoke(buffer);\n            return;\n        }\n\n        try\n        {\n            bufferCallback.handleBuffer(buffer);\n        }\n        catch (Exception e)\n        {\n            logger.warn(\"Buffer handling failed\", e);\n            BufferPool.returnBuffer.invoke(buffer);\n        }\n    }\n\n    /**\n     * Set the external callback to be used for the push API.\n     * @param bufferCallback the external callback\n     */\n    public void setBufferCallback(BufferHandler bufferCallback)\n    {\n        this.bufferCallback = bufferCallback;\n    }\n}", "super_interfaces": ["PropertyChangeListener", "BufferHandler"], "fields": [{"attribute_expression": "public static final int RTP = 1;", "docstring": "\nThe component ID to use with RTP streams.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "RTP = 1", "syntax_pass": true}, {"attribute_expression": "public static final int RTCP = 2;", "docstring": "\nThe component ID to use with RTCP streams.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "RTCP = 2", "syntax_pass": true}, {"attribute_expression": "private final int componentID;", "docstring": "\nA component id is a positive integer between 1 and 256 which identifies\nthe specific component of the media stream for which this is a candidate.\nIt MUST start at 1 and MUST increment by 1 for each component of a\nparticular candidate. For media streams based on RTP, candidates for the\nactual RTP media MUST have a component ID of 1, and candidates for RTCP\nMUST have a component ID of 2. Other types of media streams which\nrequire multiple components MUST develop specifications which define the\nmapping of components to component IDs. See Section 14 of RFC5245 for\nadditional discussion on extending ICE to new media streams.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "componentID", "syntax_pass": true}, {"attribute_expression": "private final IceMediaStream parentStream;", "docstring": "\nThe <tt>IceMediaStream</tt> that this <tt>Component</tt> belongs to.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "IceMediaStream", "name": "parentStream", "syntax_pass": true}, {"attribute_expression": "private final List<LocalCandidate> localCandidates = new LinkedList<>();", "docstring": "\nThe list locally gathered candidates for this media stream.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<LocalCandidate>", "name": "localCandidates = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private final List<RemoteCandidate> remoteCandidates = new LinkedList<>();", "docstring": "\nThe list of candidates that the peer agent sent for this stream.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<RemoteCandidate>", "name": "remoteCandidates = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private final List<RemoteCandidate> remoteUpdateCandidates\n        = new LinkedList<>();", "docstring": "\nThe list of candidates that the peer agent sent for this stream after\nconnectivity establishment.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<RemoteCandidate>", "name": "remoteUpdateCandidates\n        = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private final CandidatePrioritizer candidatePrioritizer\n        = new CandidatePrioritizer();", "docstring": "\nA <tt>Comparator</tt> that we use for sorting <tt>Candidate</tt>s by\ntheir priority.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CandidatePrioritizer", "name": "candidatePrioritizer\n        = new CandidatePrioritizer()", "syntax_pass": true}, {"attribute_expression": "private LocalCandidate defaultCandidate = null;", "docstring": "\nThe default <tt>Candidate</tt> for this component or in other words, the\ncandidate that we would have used without ICE.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "LocalCandidate", "name": "defaultCandidate = null", "syntax_pass": true}, {"attribute_expression": "private CandidatePair selectedPair;", "docstring": "\nThe pair that has been selected for use by ICE processing\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CandidatePair", "name": "selectedPair", "syntax_pass": true}, {"attribute_expression": "private Candidate<?> defaultRemoteCandidate = null;", "docstring": "\nThe default <tt>RemoteCandidate</tt> for this component or in other\nwords, the candidate that we would have used to communicate with the\nremote peer if we hadn't been using ICE.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Candidate<?>", "name": "defaultRemoteCandidate = null", "syntax_pass": true}, {"attribute_expression": "private final Logger logger;", "docstring": "\nThe {@link Logger} used by {@link Component} instances.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Logger", "name": "logger", "syntax_pass": true}, {"attribute_expression": "private final ComponentSocket componentSocket;", "docstring": "\nThe {@link ComponentSocket} instance which, if enabled, will serve as the\nsingle socket instance for this {@link Component}, merging received\npackets from all of its candidates.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ComponentSocket", "name": "componentSocket", "syntax_pass": true}, {"attribute_expression": "private final MultiplexingDatagramSocket socket;", "docstring": "\nThe public view of {@link #componentSocket}, wrapped in a\n{@link MultiplexingDatagramSocket} for the convenience of users of the\nlibrary.\nThis is the instance which should be used by applications for\nreading/writing application data.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "MultiplexingDatagramSocket", "name": "socket", "syntax_pass": true}, {"attribute_expression": "@Deprecated\n    private final IceSocketWrapper socketWrapper;", "docstring": "\nA wrapper around {@link #socket}, kept only to help preserve the old\nAPI (see {@link LocalCandidate#getIceSocketWrapper()} and\n{@link CandidatePair#getIceSocketWrapper()})\n", "modifiers": "@Deprecated\n    private final", "marker_annotations": ["@Deprecated"], "non_marker_annotations": ["private", "final"], "comments": [], "type": "IceSocketWrapper", "name": "socketWrapper", "syntax_pass": true}, {"attribute_expression": "private final KeepAliveStrategy keepAliveStrategy;", "docstring": "\nThe {@link KeepAliveStrategy} used by this component to select which\npairs are to be kept alive.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "KeepAliveStrategy", "name": "keepAliveStrategy", "syntax_pass": true}, {"attribute_expression": "private final Set<CandidatePair> keepAlivePairs = Collections.newSetFromMap(new ConcurrentHashMap<>());", "docstring": "\nThe set of pairs which this component wants to keep alive.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Set<CandidatePair>", "name": "keepAlivePairs = Collections.newSetFromMap(new ConcurrentHashMap<>())", "syntax_pass": true}, {"attribute_expression": "private BufferHandler bufferCallback = null;", "docstring": "\nExternal callback for the push API. Called with every packet received via {@link #handleBuffer(Buffer)}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BufferHandler", "name": "bufferCallback = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/RelayedCandidate.java.RelayedCandidate", "name": "RelayedCandidate", "file_path": "src/main/java/org/ice4j/ice/RelayedCandidate.java", "superclasses": "LocalCandidate", "methods": ["[]RelayedCandidate(TransportAddress,TurnCandidateHarvest,TransportAddress)", "[RelayedCandidateDatagramSocket]getRelayedCandidateDatagramSocket()", "[IceSocketWrapper]getCandidateIceSocketWrapper()"], "method_uris": ["src/main/java/org/ice4j/ice/RelayedCandidate.java.RelayedCandidate.[]RelayedCandidate(TransportAddress,TurnCandidateHarvest,TransportAddress)", "src/main/java/org/ice4j/ice/RelayedCandidate.java.RelayedCandidate.[RelayedCandidateDatagramSocket]getRelayedCandidateDatagramSocket()", "src/main/java/org/ice4j/ice/RelayedCandidate.java.RelayedCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper()"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents a <tt>Candidate</tt> obtained by sending a TURN Allocate request\nfrom a <tt>HostCandidate</tt> to a TURN server.  The relayed candidate is\nresident on the TURN server, and the TURN server relays packets back towards\nthe agent.\n\n@author Lubomir Marinov\n", "original_string": "public class RelayedCandidate\n    extends LocalCandidate\n{\n\n    /**\n     * The <tt>RelayedCandidateDatagramSocket</tt> of this\n     * <tt>RelayedCandidate</tt>.\n     */\n    private RelayedCandidateDatagramSocket relayedCandidateDatagramSocket;\n\n    /**\n     * The application-purposed <tt>DatagramSocket</tt> associated with this\n     * <tt>Candidate</tt>.\n     */\n    private IceSocketWrapper socket;\n\n    /**\n     * The <tt>TurnCandidateHarvest</tt> which has harvested this\n     * <tt>RelayedCandidate</tt>.\n     */\n    private final TurnCandidateHarvest turnCandidateHarvest;\n\n    /**\n     * Initializes a new <tt>RelayedCandidate</tt> which is to represent a\n     * specific <tt>TransportAddress</tt> harvested through a specific\n     * <tt>HostCandidate</tt> and a TURN server with a specific\n     * <tt>TransportAddress</tt>.\n     *\n     * @param transportAddress the <tt>TransportAddress</tt> to be represented\n     * by the new instance\n     * @param turnCandidateHarvest the <tt>TurnCandidateHarvest</tt> which has\n     * harvested the new instance\n     * @param mappedAddress the mapped <tt>TransportAddress</tt> reported by the\n     * TURN server with the delivery of the replayed <tt>transportAddress</tt>\n     * to be represented by the new instance\n     */\n    public RelayedCandidate(\n            TransportAddress transportAddress,\n            TurnCandidateHarvest turnCandidateHarvest,\n            TransportAddress mappedAddress)\n    {\n        super(\n            transportAddress,\n            turnCandidateHarvest.hostCandidate.getParentComponent(),\n            CandidateType.RELAYED_CANDIDATE,\n            CandidateExtendedType.TURN_RELAYED_CANDIDATE,\n            turnCandidateHarvest.hostCandidate.getParentComponent()\n                .findLocalCandidate(mappedAddress));\n\n        this.turnCandidateHarvest = turnCandidateHarvest;\n\n        // RFC 5245: The base of a relayed candidate is that candidate itself.\n        setBase(this);\n        setRelayServerAddress(turnCandidateHarvest.harvester.stunServer);\n        setMappedAddress(mappedAddress);\n    }\n\n    /**\n     * Gets the <tt>RelayedCandidateDatagramSocket</tt> of this\n     * <tt>RelayedCandidate</tt>.\n     * <p>\n     * <b>Note</b>: The method is part of the internal API of\n     * <tt>RelayedCandidate</tt> and <tt>TurnCandidateHarvest</tt> and is not\n     * intended for public use.\n     * </p>\n     *\n     * @return the <tt>RelayedCandidateDatagramSocket</tt> of this\n     * <tt>RelayedCandidate</tt>\n     */\n    private synchronized RelayedCandidateDatagramSocket\n        getRelayedCandidateDatagramSocket()\n    {\n        if (relayedCandidateDatagramSocket == null)\n        {\n            try\n            {\n                relayedCandidateDatagramSocket\n                    = new RelayedCandidateDatagramSocket(\n                            this,\n                            turnCandidateHarvest);\n            }\n            catch (SocketException sex)\n            {\n                throw new UndeclaredThrowableException(sex);\n            }\n        }\n        return relayedCandidateDatagramSocket;\n    }\n\n    /**\n     * Gets the application-purposed <tt>DatagramSocket</tt> associated with\n     * this <tt>Candidate</tt>.\n     *\n     * @return the <tt>DatagramSocket</tt> associated with this\n     * <tt>Candidate</tt>\n     */\n    @Override\n    public synchronized IceSocketWrapper getCandidateIceSocketWrapper()\n    {\n        if (socket == null)\n        {\n            try\n            {\n                socket\n                    = new IceUdpSocketWrapper(new MultiplexingDatagramSocket(\n                            getRelayedCandidateDatagramSocket()));\n            }\n            catch (SocketException sex)\n            {\n                throw new UndeclaredThrowableException(sex);\n            }\n        }\n        return socket;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private RelayedCandidateDatagramSocket relayedCandidateDatagramSocket;", "docstring": "\nThe <tt>RelayedCandidateDatagramSocket</tt> of this\n<tt>RelayedCandidate</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RelayedCandidateDatagramSocket", "name": "relayedCandidateDatagramSocket", "syntax_pass": true}, {"attribute_expression": "private IceSocketWrapper socket;", "docstring": "\nThe application-purposed <tt>DatagramSocket</tt> associated with this\n<tt>Candidate</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IceSocketWrapper", "name": "socket", "syntax_pass": true}, {"attribute_expression": "private final TurnCandidateHarvest turnCandidateHarvest;", "docstring": "\nThe <tt>TurnCandidateHarvest</tt> which has harvested this\n<tt>RelayedCandidate</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TurnCandidateHarvest", "name": "turnCandidateHarvest", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetTask.java.CandidateHarvesterSetTask", "name": "CandidateHarvesterSetTask", "file_path": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetTask.java", "superclasses": "", "methods": ["[]CandidateHarvesterSetTask(CandidateHarvesterSetElement,Collection<Component>,TrickleCallback)", "[CandidateHarvesterSetElement]getHarvester()", "[void]run()"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetTask.java.CandidateHarvesterSetTask.[]CandidateHarvesterSetTask(CandidateHarvesterSetElement,Collection<Component>,TrickleCallback)", "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetTask.java.CandidateHarvesterSetTask.[CandidateHarvesterSetElement]getHarvester()", "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetTask.java.CandidateHarvesterSetTask.[void]run()"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents a task to be executed by the specified executorService and\nto call {@link CandidateHarvester#harvest(Component)} on the specified\nharvesters.\n\n@author Lyubomir Marinov\n@author  Emil Ivov\n", "original_string": "class CandidateHarvesterSetTask\n    implements Runnable\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>CandidateHarvesterSetTask</tt>\n     * class and its instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(CandidateHarvesterSetTask.class.getName());\n\n    /**\n     * The <tt>CandidateHarvester</tt> on which\n     * {@link CandidateHarvester#harvest(org.ice4j.ice.Component)} is to be or\n     * is being called.\n     */\n    private CandidateHarvesterSetElement harvester;\n\n    /**\n     * The {@link Component}s whose addresses we will be harvesting in this\n     * task.\n     */\n    private Collection<Component> components;\n\n    /**\n     * The callback that we will be notifying every time a harvester completes.\n     */\n    private final TrickleCallback trickleCallback;\n\n    /**\n     * Initializes a new <tt>CandidateHarvesterSetTask</tt> which is to\n     * call {@link CandidateHarvester#harvest(org.ice4j.ice.Component)} on a\n     * specific harvester and then as many harvesters as possible.\n     *\n     * @param harvester the <tt>CandidateHarvester</tt> on which the\n     * new instance is to call\n     * @param components the <tt>Component</tt> whose candidates we are currently\n     * gathering.\n     * <tt>CandidateHarvester#harvest(Component)</tt> first\n     */\n    public CandidateHarvesterSetTask(\n            CandidateHarvesterSetElement harvester,\n            Collection<Component>        components,\n            TrickleCallback              trickleCallback)\n    {\n        this.harvester = harvester;\n        this.components = components;\n        this.trickleCallback = trickleCallback;\n    }\n\n    /**\n     * Gets the <tt>CandidateHarvester</tt> on which\n     * {@link CandidateHarvester#harvest(org.ice4j.ice.Component)} is being\n     * called.\n     *\n     * @return the <tt>CandidateHarvester</tt> on which\n     * <tt>CandidateHarvester#harvest(Component)</tt> is being called\n     */\n    public CandidateHarvesterSetElement getHarvester()\n    {\n        return harvester;\n    }\n\n    /**\n     * Runs the actual harvesting for this component\n     */\n    public void run()\n    {\n        if (harvester == null || !harvester.isEnabled())\n            return;\n\n        for (Component component : components)\n        {\n            try\n            {\n                harvester.harvest(component, trickleCallback);\n            }\n            catch (Throwable t)\n            {\n                logger.info(\n                    \"disabling harvester due to exception: \" +\n                        t.getLocalizedMessage());\n                harvester.setEnabled(false);\n\n                if (t instanceof ThreadDeath)\n                    throw (ThreadDeath) t;\n            }\n        }\n\n        /*\n         * CandidateHarvester#harvest(Component) has been called on\n         * the harvester and its success or failure has been noted.\n         * Now forget the harvester because any failure to continue\n         * execution is surely not its fault.\n         */\n        harvester = null;\n    }\n}", "super_interfaces": ["Runnable"], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(CandidateHarvesterSetTask.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>CandidateHarvesterSetTask</tt>\nclass and its instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(CandidateHarvesterSetTask.class.getName())", "syntax_pass": true}, {"attribute_expression": "private CandidateHarvesterSetElement harvester;", "docstring": "\nThe <tt>CandidateHarvester</tt> on which\n{@link CandidateHarvester#harvest(org.ice4j.ice.Component)} is to be or\nis being called.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CandidateHarvesterSetElement", "name": "harvester", "syntax_pass": true}, {"attribute_expression": "private Collection<Component> components;", "docstring": "\nThe {@link Component}s whose addresses we will be harvesting in this\ntask.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<Component>", "name": "components", "syntax_pass": true}, {"attribute_expression": "private final TrickleCallback trickleCallback;", "docstring": "\nThe callback that we will be notifying every time a harvester completes.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TrickleCallback", "name": "trickleCallback", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest", "name": "StunCandidateHarvest", "file_path": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java", "superclasses": "AbstractResponseCollector", "methods": ["[]StunCandidateHarvest(StunCandidateHarvester,HostCandidate)", "[boolean]addCandidate(LocalCandidate)", "[boolean]addShortTermCredentialAttributes(Request)", "[boolean]completedResolvingCandidate(Request,Response)", "[boolean]containsCandidate(LocalCandidate)", "[void]createCandidates(Response)", "[Message]createKeepAliveMessage(LocalCandidate)", "[Request]createRequestToRetry(Request)", "[Request]createRequestToStartResolvingCandidate()", "[void]createSendKeepAliveMessageThread()", "[void]createServerReflexiveCandidate(Response)", "[ServerReflexiveCandidate]createServerReflexiveCandidate(TransportAddress)", "[void]exitSendKeepAliveMessageThread()", "[int]getCandidateCount()", "[LocalCandidate[]]getCandidates()", "[TransportAddress]getMappedAddress(Response)", "[boolean]processChallenge(byte[],byte[],Request,TransactionID)", "[boolean]processChallenge(Response,Request,TransactionID)", "[boolean]processErrorOrFailure(Response,Request,TransactionID)", "[void]processFailure(BaseStunMessageEvent)", "[void]processResponse(StunResponseEvent)", "[boolean]processStaleNonce(Response,Request,TransactionID)", "[void]processSuccess(Response,Request,TransactionID)", "[boolean]processUnauthorized(Response,Request,TransactionID)", "[boolean]runInSendKeepAliveMessageThread()", "[void]sendKeepAliveMessage()", "[boolean]sendKeepAliveMessage(LocalCandidate)", "[TransactionID]sendRequest(Request,boolean,TransactionID)", "[void]setSendKeepAliveMessageInterval(long)", "[boolean]startResolvingCandidate()", "[void]close()"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[]StunCandidateHarvest(StunCandidateHarvester,HostCandidate)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]addCandidate(LocalCandidate)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]addShortTermCredentialAttributes(Request)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]completedResolvingCandidate(Request,Response)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]containsCandidate(LocalCandidate)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]createCandidates(Response)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[Message]createKeepAliveMessage(LocalCandidate)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[Request]createRequestToRetry(Request)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[Request]createRequestToStartResolvingCandidate()", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]createSendKeepAliveMessageThread()", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]createServerReflexiveCandidate(Response)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[ServerReflexiveCandidate]createServerReflexiveCandidate(TransportAddress)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]exitSendKeepAliveMessageThread()", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[int]getCandidateCount()", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[LocalCandidate[]]getCandidates()", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[TransportAddress]getMappedAddress(Response)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]processChallenge(byte[],byte[],Request,TransactionID)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]processChallenge(Response,Request,TransactionID)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]processErrorOrFailure(Response,Request,TransactionID)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]processFailure(BaseStunMessageEvent)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]processResponse(StunResponseEvent)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]processStaleNonce(Response,Request,TransactionID)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]processSuccess(Response,Request,TransactionID)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]processUnauthorized(Response,Request,TransactionID)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]runInSendKeepAliveMessageThread()", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]sendKeepAliveMessage()", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]sendKeepAliveMessage(LocalCandidate)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[TransactionID]sendRequest(Request,boolean,TransactionID)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]setSendKeepAliveMessageInterval(long)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[boolean]startResolvingCandidate()", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvest.java.StunCandidateHarvest.[void]close()"], "overrides": null, "attributes": [{"original_string": "    private static class SendKeepAliveMessageThread\n        extends Thread\n    {\n        /**\n         * The <tt>StunCandidateHarvest</tt> which has initialized this\n         * instance. The <tt>StunCandidateHarvest</tt> is referenced by a\n         * <tt>WeakReference</tt> in an attempt to reduce the risk that the\n         * <tt>Thread</tt> may live regardless of the fact that the specified\n         * <tt>StunCandidateHarvest</tt> may no longer be reachable.\n         */\n        private final WeakReference<StunCandidateHarvest> harvest;\n\n        /**\n         * Initializes a new <tt>SendKeepAliveMessageThread</tt> instance with a\n         * specific <tt>StunCandidateHarvest</tt>.\n         *\n         * @param harvest the <tt>StunCandidateHarvest</tt> to initialize the\n         * new instance with\n         */\n        public SendKeepAliveMessageThread(StunCandidateHarvest harvest)\n        {\n            this.harvest = new WeakReference<>(harvest);\n        }\n\n        @Override\n        public void run()\n        {\n            try\n            {\n                do\n                {\n                    StunCandidateHarvest harvest = this.harvest.get();\n\n                    if ((harvest == null)\n                            || !harvest.runInSendKeepAliveMessageThread())\n                    {\n                        break;\n                    }\n                }\n                while (true);\n            }\n            finally\n            {\n                StunCandidateHarvest harvest = this.harvest.get();\n\n                if (harvest != null)\n                    harvest.exitSendKeepAliveMessageThread();\n            }\n        }\n    }", "definition": "    private static class SendKeepAliveMessageThread\n        extends Thread", "class_docstring": "\nSends STUN keep-alive <tt>Message</tt>s to the STUN server associated\nwith the <tt>StunCandidateHarvester</tt> of this instance.\n\n@author Lyubomir Marinov\n", "name": "SendKeepAliveMessageThread", "super_interfaces": [], "superclasses": "Thread", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final WeakReference<StunCandidateHarvest> harvest;", "docstring": "\nThe <tt>StunCandidateHarvest</tt> which has initialized this\ninstance. The <tt>StunCandidateHarvest</tt> is referenced by a\n<tt>WeakReference</tt> in an attempt to reduce the risk that the\n<tt>Thread</tt> may live regardless of the fact that the specified\n<tt>StunCandidateHarvest</tt> may no longer be reachable.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "WeakReference<StunCandidateHarvest>", "name": "harvest", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public SendKeepAliveMessageThread(StunCandidateHarvest harvest)\n        {\n            this.harvest = new WeakReference<>(harvest);\n        }", "docstring": "\nInitializes a new <tt>SendKeepAliveMessageThread</tt> instance with a\nspecific <tt>StunCandidateHarvest</tt>.\n\n@param harvest the <tt>StunCandidateHarvest</tt> to initialize the\nnew instance with\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "SendKeepAliveMessageThread", "params": [{"name": "harvest", "type": "StunCandidateHarvest"}], "body": "        {\n            this.harvest = new WeakReference<>(harvest);\n        }", "signature": "public SendKeepAliveMessageThread(StunCandidateHarvest harvest)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void run()\n        {\n            try\n            {\n                do\n                {\n                    StunCandidateHarvest harvest = this.harvest.get();\n\n                    if ((harvest == null)\n                            || !harvest.runInSendKeepAliveMessageThread())\n                    {\n                        break;\n                    }\n                }\n                while (true);\n            }\n            finally\n            {\n                StunCandidateHarvest harvest = this.harvest.get();\n\n                if (harvest != null)\n                    harvest.exitSendKeepAliveMessageThread();\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "run", "params": [], "body": "        {\n            try\n            {\n                do\n                {\n                    StunCandidateHarvest harvest = this.harvest.get();\n\n                    if ((harvest == null)\n                            || !harvest.runInSendKeepAliveMessageThread())\n                    {\n                        break;\n                    }\n                }\n                while (true);\n            }\n            finally\n            {\n                StunCandidateHarvest harvest = this.harvest.get();\n\n                if (harvest != null)\n                    harvest.exitSendKeepAliveMessageThread();\n            }\n        }", "signature": "@Override\n        public void run()"}]}], "class_docstring": "\nRepresents the harvesting of STUN <tt>Candidates</tt> for a specific\n<tt>HostCandidate</tt> performed by a specific\n<tt>StunCandidateHarvester</tt>.\n\n@author Lyubomir Marinov\n", "original_string": "public class StunCandidateHarvest\n    extends AbstractResponseCollector\n{\n\n    /**\n     * The <tt>Logger</tt> used by the <tt>StunCandidateHarvest</tt> class and\n     * its instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(StunCandidateHarvest.class.getName());\n\n    /**\n     * The constant which defines an empty array with <tt>LocalCandidate</tt>\n     * element type. Explicitly defined in order to reduce unnecessary\n     * allocations.\n     */\n    private static final LocalCandidate[] NO_CANDIDATES = new LocalCandidate[0];\n\n    /**\n     * The value of the <tt>sendKeepAliveMessage</tt> property of\n     * <tt>StunCandidateHarvest</tt> which specifies that no sending of STUN\n     * keep-alive messages is to performed for the purposes of keeping the\n     * <tt>Candidate</tt>s harvested by the <tt>StunCandidateHarvester</tt> in\n     * question alive.\n     */\n    protected static final long SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED\n        = 0;\n\n    /**\n     * The list of <tt>Candidate</tt>s harvested for {@link #hostCandidate} by\n     * this harvest.\n     */\n    private final List<LocalCandidate> candidates = new LinkedList<>();\n\n    /**\n     * The indicator which determines whether this <tt>StunCandidateHarvest</tt>\n     * has completed the harvesting of <tt>Candidate</tt>s for\n     * {@link #hostCandidate}.\n     */\n    private boolean completedResolvingCandidate = false;\n\n    /**\n     * The <tt>StunCandidateHarvester</tt> performing the harvesting of STUN\n     * <tt>Candidate</tt>s for a <tt>Component</tt> which this harvest is part\n     * of.\n     */\n    public final StunCandidateHarvester harvester;\n\n    /**\n     * The <tt>HostCandidate</tt> the STUN harvesting of which is represented by\n     * this instance.\n     */\n    public final HostCandidate hostCandidate;\n\n    /**\n     * The <tt>LongTermCredential</tt> used by this instance.\n     */\n    private LongTermCredentialSession longTermCredentialSession;\n\n    /**\n     * The STUN <tt>Request</tt>s which have been sent by this instance, have\n     * not received a STUN <tt>Response</tt> yet and have not timed out. Put in\n     * place to avoid a limitation of the <tt>ResponseCollector</tt> and its use\n     * of <tt>StunMessageEvent</tt> which do not make the STUN <tt>Request</tt>\n     * to which a STUN <tt>Response</tt> responds available though it is known\n     * in <tt>StunClientTransaction</tt>.\n     */\n    private final Map<TransactionID, Request> requests = new HashMap<>();\n\n    /**\n     * The interval in milliseconds at which a new STUN keep-alive message is to\n     * be sent to the STUN server associated with the\n     * <tt>StunCandidateHarvester</tt> of this instance in order to keep one of\n     * the <tt>Candidate</tt>s harvested by this instance alive.\n     */\n    private long sendKeepAliveMessageInterval\n        = SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED;\n\n    /**\n     * The <tt>Object</tt> used to synchronize access to the members related to\n     * the sending of STUN keep-alive messages to the STUN server associated\n     * with the <tt>StunCandidateHarvester</tt> of this instance.\n     */\n    private final Object sendKeepAliveMessageSyncRoot = new Object();\n\n    /**\n     * The <tt>Thread</tt> which sends the STUN keep-alive messages to the STUN\n     * server associated with the <tt>StunCandidateHarvester</tt> of this\n     * instance in order to keep the <tt>Candidate</tt>s harvested by this\n     * instance alive.\n     */\n    private Thread sendKeepAliveMessageThread;\n\n    /**\n     * The time (stamp) in milliseconds of the last call to\n     * {@link #sendKeepAliveMessage()} which completed without throwing an\n     * exception. <b>Note</b>: It doesn't mean that the keep-alive message was a\n     * STUN <tt>Request</tt> and it received a success STUN <tt>Response</tt>.\n     */\n    private long sendKeepAliveMessageTime = -1;\n\n    /**\n     * Initializes a new <tt>StunCandidateHarvest</tt> which is to represent the\n     * harvesting of STUN <tt>Candidate</tt>s for a specific\n     * <tt>HostCandidate</tt> performed by a specific\n     * <tt>StunCandidateHarvester</tt>.\n     *\n     * @param harvester the <tt>StunCandidateHarvester</tt> which is performing\n     * the STUN harvesting\n     * @param hostCandidate the <tt>HostCandidate</tt> for which STUN\n     * <tt>Candidate</tt>s are to be harvested\n     */\n    public StunCandidateHarvest(\n            StunCandidateHarvester harvester,\n            HostCandidate hostCandidate)\n    {\n        this.harvester = harvester;\n        this.hostCandidate = hostCandidate;\n    }\n\n    /**\n     * Adds a specific <tt>LocalCandidate</tt> to the list of\n     * <tt>LocalCandidate</tt>s harvested for {@link #hostCandidate} by this\n     * harvest.\n     *\n     * @param candidate the <tt>LocalCandidate</tt> to be added to the list of\n     * <tt>LocalCandidate</tt>s harvested for {@link #hostCandidate} by this\n     * harvest\n     * @return <tt>true</tt> if the list of <tt>LocalCandidate</tt>s changed as\n     * a result of the method invocation; otherwise, <tt>false</tt>\n     */\n    protected boolean addCandidate(LocalCandidate candidate)\n    {\n        boolean added;\n\n        //try to add the candidate to the component and then only add it to the\n        //harvest if it wasn't deemed redundant\n        if (!candidates.contains(candidate)\n                && hostCandidate.getParentComponent().addLocalCandidate(\n                        candidate))\n        {\n            added = candidates.add(candidate);\n        }\n        else\n        {\n            added = false;\n        }\n        return added;\n    }\n\n    /**\n     * Adds the <tt>Attribute</tt>s to a specific <tt>Request</tt> which support\n     * the STUN short-term credential mechanism if the mechanism in question is\n     * utilized by this <tt>StunCandidateHarvest</tt> (i.e. by the associated\n     * <tt>StunCandidateHarvester</tt>).\n     *\n     * @param request the <tt>Request</tt> to which to add the\n     * <tt>Attribute</tt>s supporting the STUN short-term credential mechanism\n     * if the mechanism in question is utilized by this\n     * <tt>StunCandidateHarvest</tt>\n     * @return <tt>true</tt> if the STUN short-term credential mechanism is\n     * actually utilized by this <tt>StunCandidateHarvest</tt> for the specified\n     * <tt>request</tt>; otherwise, <tt>false</tt>\n     */\n    protected boolean addShortTermCredentialAttributes(Request request)\n    {\n        String shortTermCredentialUsername\n            = harvester.getShortTermCredentialUsername();\n\n        if (shortTermCredentialUsername != null)\n        {\n            request.putAttribute(\n                    AttributeFactory.createUsernameAttribute(\n                            shortTermCredentialUsername));\n            request.putAttribute(\n                    AttributeFactory.createMessageIntegrityAttribute(\n                            shortTermCredentialUsername));\n            return true;\n        }\n        else\n            return false;\n    }\n\n    /**\n     * Completes the harvesting of <tt>Candidate</tt>s for\n     * {@link #hostCandidate}. Notifies {@link #harvester} about the completion\n     * of the harvesting of <tt>Candidate</tt> for <tt>hostCandidate</tt>\n     * performed by this <tt>StunCandidateHarvest</tt>.\n     *\n     * @param request the <tt>Request</tt> sent by this\n     * <tt>StunCandidateHarvest</tt> with which the harvesting of\n     * <tt>Candidate</tt>s for <tt>hostCandidate</tt> has completed\n     * @param response the <tt>Response</tt> received by this\n     * <tt>StunCandidateHarvest</tt>, if any, with which the harvesting of\n     * <tt>Candidate</tt>s for <tt>hostCandidate</tt> has completed\n     * @return <tt>true</tt> if the harvesting of <tt>Candidate</tt>s for\n     * <tt>hostCandidate</tt> performed by this <tt>StunCandidateHarvest</tt>\n     * has completed; otherwise, <tt>false</tt>\n     */\n    protected boolean completedResolvingCandidate(\n            Request request,\n            Response response)\n    {\n        if (!completedResolvingCandidate)\n        {\n            completedResolvingCandidate = true;\n            try\n            {\n                if (((response == null) || !response.isSuccessResponse())\n                        && (longTermCredentialSession != null))\n                {\n                    harvester\n                        .getStunStack()\n                            .getCredentialsManager()\n                                .unregisterAuthority(longTermCredentialSession);\n                    longTermCredentialSession = null;\n                }\n            }\n            finally\n            {\n                harvester.completedResolvingCandidate(this);\n            }\n        }\n        return completedResolvingCandidate;\n    }\n\n    /**\n     * Determines whether a specific <tt>LocalCandidate</tt> is contained in the\n     * list of <tt>LocalCandidate</tt>s harvested for {@link #hostCandidate} by\n     * this harvest.\n     *\n     * @param candidate the <tt>LocalCandidate</tt> to look for in the list of\n     * <tt>LocalCandidate</tt>s harvested for {@link #hostCandidate} by this\n     * harvest\n     * @return <tt>true</tt> if the list of <tt>LocalCandidate</tt>s contains\n     * the specified <tt>candidate</tt>; otherwise, <tt>false</tt>\n     */\n    protected boolean containsCandidate(LocalCandidate candidate)\n    {\n        if (candidate != null)\n        {\n            LocalCandidate[] candidates = getCandidates();\n\n            if ((candidates != null) && (candidates.length != 0))\n            {\n                for (LocalCandidate c : candidates)\n                {\n                    if (candidate.equals(c))\n                        return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Creates new <tt>Candidate</tt>s determined by a specific STUN\n     * <tt>Response</tt>.\n     *\n     * @param response the received STUN <tt>Response</tt>\n     */\n    protected void createCandidates(Response response)\n    {\n        createServerReflexiveCandidate(response);\n    }\n\n    /**\n     * Creates a new STUN <tt>Message</tt> to be sent to the STUN server\n     * associated with the <tt>StunCandidateHarvester</tt> of this instance in\n     * order to keep a specific <tt>LocalCandidate</tt> (harvested by this\n     * instance) alive.\n     *\n     * @param candidate the <tt>LocalCandidate</tt> (harvested by this instance)\n     * to create a new keep-alive STUN message for\n     * @return a new keep-alive STUN <tt>Message</tt> for the specified\n     * <tt>candidate</tt> or <tt>null</tt> if no keep-alive sending is to occur\n     * @throws StunException if anything goes wrong while creating the new\n     * keep-alive STUN <tt>Message</tt> for the specified <tt>candidate</tt>\n     * or the candidate is of an unsupported <tt>CandidateType</tt>\n     */\n    protected Message createKeepAliveMessage(LocalCandidate candidate)\n        throws StunException\n    {\n        /*\n         * We'll not be keeping a STUN Binding alive for now. If we decide to in\n         * the future, we'll have to create a Binding Indication and add support\n         * for sending it.\n         */\n        if (CandidateType.SERVER_REFLEXIVE_CANDIDATE.equals(\n                candidate.getType()))\n            return null;\n        else\n        {\n            throw\n                new StunException(StunException.ILLEGAL_ARGUMENT, \"candidate\");\n        }\n    }\n\n    /**\n     * Creates a new <tt>Request</tt> instance which is to be sent by this\n     * <tt>StunCandidateHarvest</tt> in order to retry a specific\n     * <tt>Request</tt>. For example, the long-term credential mechanism\n     * dictates that a <tt>Request</tt> is first sent by the client without any\n     * credential-related attributes, then it gets challenged by the server and\n     * the client retries the original <tt>Request</tt> with the appropriate\n     * credential-related attributes in response.\n     *\n     * @param request the <tt>Request</tt> which is to be retried by this\n     * <tt>StunCandidateHarvest</tt>\n     * @return the new <tt>Request</tt> instance which is to be sent by this\n     * <tt>StunCandidateHarvest</tt> in order to retry the specified\n     * <tt>request</tt>\n     */\n    protected Request createRequestToRetry(Request request)\n    {\n        switch (request.getMessageType())\n        {\n        case Message.BINDING_REQUEST:\n            return MessageFactory.createBindingRequest();\n        default:\n            throw new IllegalArgumentException(\"request.messageType\");\n        }\n    }\n\n    /**\n     * Creates a new <tt>Request</tt> which is to be sent to\n     * {@link StunCandidateHarvester#stunServer} in order to start resolving\n     * {@link #hostCandidate}.\n     *\n     * @return a new <tt>Request</tt> which is to be sent to\n     * {@link StunCandidateHarvester#stunServer} in order to start resolving\n     * {@link #hostCandidate}\n     */\n    protected Request createRequestToStartResolvingCandidate()\n    {\n        return MessageFactory.createBindingRequest();\n    }\n\n    /**\n     * Creates and starts the {@link #sendKeepAliveMessageThread} which is to\n     * send STUN keep-alive <tt>Message</tt>s to the STUN server associated with\n     * the <tt>StunCandidateHarvester</tt> of this instance in order to keep the\n     * <tt>Candidate</tt>s harvested by this instance alive.\n     */\n    private void createSendKeepAliveMessageThread()\n    {\n        synchronized (sendKeepAliveMessageSyncRoot)\n        {\n            Thread t = new SendKeepAliveMessageThread(this);\n            t.setDaemon(true);\n            t.setName(\n                    getClass().getName() + \".sendKeepAliveMessageThread: \"\n                        + hostCandidate);\n\n            boolean started = false;\n\n            sendKeepAliveMessageThread = t;\n            try\n            {\n                t.start();\n                started = true;\n            }\n            finally\n            {\n                if (!started && (sendKeepAliveMessageThread == t))\n                    sendKeepAliveMessageThread = null;\n            }\n        }\n    }\n\n    /**\n     * Creates a <tt>ServerReflexiveCandidate</tt> using {@link #hostCandidate}\n     * as its base and the <tt>XOR-MAPPED-ADDRESS</tt> attribute in\n     * <tt>response</tt> for the actual <tt>TransportAddress</tt> of the new\n     * candidate. If the message is malformed and/or does not contain the\n     * corresponding attribute, this method simply has no effect.\n     *\n     * @param response the STUN <tt>Response</tt> which is supposed to contain\n     * the address we should use for the new candidate\n     */\n    protected void createServerReflexiveCandidate(Response response)\n    {\n        TransportAddress addr = getMappedAddress(response);\n\n        if (addr != null)\n        {\n            ServerReflexiveCandidate srvrRflxCand\n                = createServerReflexiveCandidate(addr);\n\n            if (srvrRflxCand != null)\n            {\n                try\n                {\n                    addCandidate(srvrRflxCand);\n                }\n                finally\n                {\n                    // Free srvrRflxCand if it has not been consumed.\n                    if (!containsCandidate(srvrRflxCand))\n                    {\n                        try\n                        {\n                            srvrRflxCand.free();\n                        }\n                        catch (Exception ex)\n                        {\n                            if (logger.isLoggable(Level.FINE))\n                            {\n                                logger.log(\n                                        Level.FINE,\n                                        \"Failed to free\"\n                                            + \" ServerReflexiveCandidate: \"\n                                            + srvrRflxCand,\n                                        ex);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Creates a new <tt>ServerReflexiveCandidate</tt> instance which is to\n     * represent a specific <tt>TransportAddress</tt> harvested through\n     * {@link #hostCandidate} and the STUN server associated with\n     * {@link #harvester}.\n     *\n     * @param transportAddress the <tt>TransportAddress</tt> to be represented\n     * by the new <tt>ServerReflexiveCandidate</tt> instance\n     * @return a new <tt>ServerReflexiveCandidate</tt> instance which represents\n     * the specified <tt>TransportAddress</tt> harvested through\n     * {@link #hostCandidate} and the STUN server associated with\n     * {@link #harvester}\n     */\n    protected ServerReflexiveCandidate createServerReflexiveCandidate(\n            TransportAddress transportAddress)\n    {\n        return\n            new ServerReflexiveCandidate(\n                    transportAddress,\n                    hostCandidate,\n                    harvester.stunServer,\n                    CandidateExtendedType.STUN_SERVER_REFLEXIVE_CANDIDATE);\n    }\n\n    /**\n     * Runs in {@link #sendKeepAliveMessageThread} to notify this instance that\n     * <tt>sendKeepAliveMessageThread</tt> is about to exit.\n     */\n    private void exitSendKeepAliveMessageThread()\n    {\n        synchronized (sendKeepAliveMessageSyncRoot)\n        {\n            if (sendKeepAliveMessageThread == Thread.currentThread())\n                sendKeepAliveMessageThread = null;\n\n            /*\n             * Well, if the currentThread is finishing and this instance is\n             * still to send keep-alive messages, we'd better start another\n             * Thread for the purpose to continue the work that the\n             * currentThread was supposed to carry out.\n             */\n            if ((sendKeepAliveMessageThread == null)\n                    && (sendKeepAliveMessageInterval\n                         != SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED))\n            {\n                createSendKeepAliveMessageThread();\n            }\n        }\n    }\n\n    /**\n     * Gets the number of <tt>Candidate</tt>s harvested for\n     * {@link #hostCandidate} during this harvest.\n     *\n     * @return the number of <tt>Candidate</tt>s harvested for\n     * {@link #hostCandidate} during this harvest\n     */\n    int getCandidateCount()\n    {\n        return candidates.size();\n    }\n\n    /**\n     * Gets the <tt>Candidate</tt>s harvested for {@link #hostCandidate} during\n     * this harvest.\n     *\n     * @return an array containing the <tt>Candidate</tt>s harvested for\n     * {@link #hostCandidate} during this harvest\n     */\n    LocalCandidate[] getCandidates()\n    {\n        return candidates.toArray(NO_CANDIDATES);\n    }\n\n    /**\n     * Gets the <tt>TransportAddress</tt> specified in the XOR-MAPPED-ADDRESS\n     * attribute of a specific <tt>Response</tt>.\n     *\n     * @param response the <tt>Response</tt> from which the XOR-MAPPED-ADDRESS\n     * attribute is to be retrieved and its <tt>TransportAddress</tt> value is\n     * to be returned\n     * @return the <tt>TransportAddress</tt> specified in the XOR-MAPPED-ADDRESS\n     * attribute of <tt>response</tt>\n     */\n    protected TransportAddress getMappedAddress(Response response)\n    {\n        Attribute attribute\n            = response.getAttribute(Attribute.XOR_MAPPED_ADDRESS);\n\n        if (attribute instanceof XorMappedAddressAttribute)\n        {\n            return\n                ((XorMappedAddressAttribute) attribute)\n                    .getAddress(response.getTransactionID());\n        }\n\n        // old STUN servers (RFC3489) send MAPPED-ADDRESS address\n        attribute\n            = response.getAttribute(Attribute.MAPPED_ADDRESS);\n\n        if (attribute instanceof MappedAddressAttribute)\n        {\n            return\n                ((MappedAddressAttribute) attribute)\n                    .getAddress();\n        }\n        else\n            return null;\n    }\n\n    /**\n     * Notifies this <tt>StunCandidateHarvest</tt> that a specific STUN\n     * <tt>Request</tt> has been challenged for a long-term credential (as the\n     * short-term credential mechanism does not utilize challenging) in a\n     * specific <tt>realm</tt> and with a specific <tt>nonce</tt>.\n     *\n     * @param realm the realm in which the specified STUN <tt>Request</tt> has\n     * been challenged for a long-term credential\n     * @param nonce the nonce with which the specified STUN <tt>Request</tt> has\n     * been challenged for a long-term credential\n     * @param request the STUN <tt>Request</tt> which has been challenged for a\n     * long-term credential\n     * @param requestTransactionID the <tt>TransactionID</tt> of\n     * <tt>request</tt> because <tt>request</tt> only has it as a <tt>byte</tt>\n     * array and <tt>TransactionID</tt> is required for the\n     * <tt>applicationData</tt> property value\n     * @return <tt>true</tt> if the challenge has been processed and this\n     * <tt>StunCandidateHarvest</tt> is to continue processing STUN\n     * <tt>Response</tt>s; otherwise, <tt>false</tt>\n     * @throws StunException if anything goes wrong while processing the\n     * challenge\n     */\n    private boolean processChallenge(\n            byte[] realm,\n            byte[] nonce,\n            Request request,\n            TransactionID requestTransactionID)\n        throws StunException\n    {\n        UsernameAttribute usernameAttribute\n            = (UsernameAttribute) request.getAttribute(Attribute.USERNAME);\n\n        if (usernameAttribute == null)\n        {\n            if (longTermCredentialSession == null)\n            {\n                LongTermCredential longTermCredential\n                    = harvester.createLongTermCredential(this, realm);\n\n                if (longTermCredential == null)\n                {\n                    // The long-term credential mechanism is not being utilized.\n                    return false;\n                }\n                else\n                {\n                    longTermCredentialSession\n                        = new LongTermCredentialSession(\n                                longTermCredential,\n                                realm);\n                    harvester\n                        .getStunStack()\n                            .getCredentialsManager()\n                                .registerAuthority(longTermCredentialSession);\n                }\n            }\n            else\n            {\n                /*\n                 * If we're going to use the long-term credential to retry the\n                 * request, the long-term credential should be for the request\n                 * in terms of realm.\n                 */\n                if (!longTermCredentialSession.realmEquals(realm))\n                    return false;\n            }\n        }\n        else\n        {\n            /*\n             * If we sent a USERNAME in our request, then we had the long-term\n             * credential at the time we sent the request in question.\n             */\n            if (longTermCredentialSession == null)\n                return false;\n            else\n            {\n                /*\n                 * If we're going to use the long-term credential to retry the\n                 * request, the long-term credential should be for the request\n                 * in terms of username.\n                 */\n                if (!longTermCredentialSession.usernameEquals(\n                        usernameAttribute.getUsername()))\n                    return false;\n                else\n                {\n                    // And it terms of realm, of course.\n                    if (!longTermCredentialSession.realmEquals(realm))\n                        return false;\n                }\n            }\n        }\n\n        /*\n         * The nonce is either becoming known for the first time or being\n         * updated after the old one has gone stale.\n         */\n        longTermCredentialSession.setNonce(nonce);\n\n        Request retryRequest = createRequestToRetry(request);\n        TransactionID retryRequestTransactionID = null;\n\n        if (retryRequest != null)\n        {\n            if (requestTransactionID != null)\n            {\n                Object applicationData\n                    = requestTransactionID.getApplicationData();\n\n                if (applicationData != null)\n                {\n                    byte[] retryRequestTransactionIDAsBytes\n                        = retryRequest.getTransactionID();\n\n                    retryRequestTransactionID\n                        = (retryRequestTransactionIDAsBytes == null)\n                            ? TransactionID.createNewTransactionID()\n                            : TransactionID.createTransactionID(\n                                    harvester.getStunStack(),\n                                    retryRequestTransactionIDAsBytes);\n                    retryRequestTransactionID.setApplicationData(\n                            applicationData);\n                }\n            }\n            retryRequestTransactionID\n                = sendRequest(retryRequest, false, retryRequestTransactionID);\n        }\n        return (retryRequestTransactionID != null);\n    }\n\n    /**\n     * Notifies this <tt>StunCandidateHarvest</tt> that a specific STUN\n     * <tt>Response</tt> has been received and it challenges a specific STUN\n     * <tt>Request</tt> for a long-term credential (as the short-term credential\n     * mechanism does not utilize challenging).\n     *\n     * @param response the STUN <tt>Response</tt> which has been received\n     * @param request the STUN <tt>Request</tt> to which <tt>response</tt>\n     * responds and which it challenges for a long-term credential\n     * @return <tt>true</tt> if the challenge has been processed and this\n     * <tt>StunCandidateHarvest</tt> is to continue processing STUN\n     * <tt>Response</tt>s; otherwise, <tt>false</tt>\n     * @param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n     * <tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\n     * it as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\n     * the <tt>applicationData</tt> property value\n     * @throws StunException if anything goes wrong while processing the\n     * challenge\n     */\n    private boolean processChallenge(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n        throws StunException\n    {\n        boolean retried = false;\n\n        if (response.getAttributeCount() > 0)\n        {\n            /*\n             * The response SHOULD NOT contain a USERNAME or\n             * MESSAGE-INTEGRITY attribute.\n             */\n            char[] excludedResponseAttributeTypes\n                = new char[]\n                        {\n                            Attribute.USERNAME,\n                            Attribute.MESSAGE_INTEGRITY\n                        };\n            boolean challenge = true;\n\n            for (char excludedResponseAttributeType\n                    : excludedResponseAttributeTypes)\n            {\n                if (response.containsAttribute(excludedResponseAttributeType))\n                {\n                    challenge = false;\n                    break;\n                }\n            }\n            if (challenge)\n            {\n                // This response MUST include a REALM value.\n                RealmAttribute realmAttribute\n                    = (RealmAttribute) response.getAttribute(Attribute.REALM);\n\n                if (realmAttribute == null)\n                    challenge = false;\n                else\n                {\n                    // The response MUST include a NONCE.\n                    NonceAttribute nonceAttribute\n                        = (NonceAttribute)\n                            response.getAttribute(Attribute.NONCE);\n\n                    if (nonceAttribute == null)\n                        challenge = false;\n                    else\n                    {\n                        retried\n                            = processChallenge(\n                                    realmAttribute.getRealm(),\n                                    nonceAttribute.getNonce(),\n                                    request,\n                                    transactionID);\n                    }\n                }\n            }\n        }\n        return retried;\n    }\n\n    /**\n     * Notifies this <tt>StunCandidateHarvest</tt> that a specific\n     * <tt>Request</tt> has either received an error <tt>Response</tt> or has\n     * failed to receive any <tt>Response</tt>. Allows extenders to override and\n     * process unhandled error <tt>Response</tt>s or failures. The default\n     * implementation does no processing.\n     *\n     * @param response the error <tt>Response</tt> which has been received for\n     * <tt>request</tt>\n     * @param request the <tt>Request</tt> to which <tt>Response</tt> responds\n     * @param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n     * <tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\n     * it as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\n     * the <tt>applicationData</tt> property value\n     * @return <tt>true</tt> if the error or failure condition has been\n     * processed and this instance can continue its execution (e.g. the\n     * resolution of the candidate) as if it was expected; otherwise,\n     * <tt>false</tt>\n     */\n    protected boolean processErrorOrFailure(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n    {\n        return false;\n    }\n\n    /**\n     * Notifies this <tt>ResponseCollector</tt> that a transaction described by\n     * the specified <tt>BaseStunMessageEvent</tt> has failed. The possible\n     * reasons for the failure include timeouts, unreachable destination, etc.\n     *\n     * @param event the <tt>BaseStunMessageEvent</tt> which describes the failed\n     * transaction and the runtime type of which specifies the failure reason\n     * @see AbstractResponseCollector#processFailure(BaseStunMessageEvent)\n     */\n    @Override\n    protected void processFailure(BaseStunMessageEvent event)\n    {\n        TransactionID transactionID = event.getTransactionID();\n\n        logger.finest(\"A transaction expired: tranid=\" + transactionID);\n        logger.finest(\"localAddr=\" + hostCandidate);\n\n        /*\n         * Clean up for the purposes of the workaround which determines the STUN\n         * Request to which a STUN Response responds.\n         */\n        Request request;\n\n        synchronized (requests)\n        {\n            request = requests.remove(transactionID);\n        }\n        if (request == null)\n        {\n            Message message = event.getMessage();\n\n            if (message instanceof Request)\n                request = (Request) message;\n        }\n\n        boolean completedResolvingCandidate = true;\n        try\n        {\n            if (processErrorOrFailure(null, request, transactionID))\n                completedResolvingCandidate = false;\n        }\n        finally\n        {\n            if (completedResolvingCandidate)\n                completedResolvingCandidate(request, null);\n        }\n    }\n\n    /**\n     * Notifies this <tt>ResponseCollector</tt> that a STUN response described\n     * by the specified <tt>StunResponseEvent</tt> has been received.\n     *\n     * @param event the <tt>StunResponseEvent</tt> which describes the received\n     * STUN response\n     * @see ResponseCollector#processResponse(StunResponseEvent)\n     */\n    @Override\n    public void processResponse(StunResponseEvent event)\n    {\n        TransactionID transactionID = event.getTransactionID();\n\n        logger.finest(\"Received a message: tranid= \" + transactionID);\n        logger.finest(\"localCand= \" + hostCandidate);\n\n        /*\n         * Clean up for the purposes of the workaround which determines the STUN\n         * Request to which a STUN Response responds.\n         */\n        synchronized (requests)\n        {\n            requests.remove(transactionID);\n        }\n\n        // At long last, do start handling the received STUN Response.\n        Response response = event.getResponse();\n        Request request = event.getRequest();\n        boolean completedResolvingCandidate = true;\n\n        try\n        {\n            if (response.isSuccessResponse())\n            {\n                // Authentication and Message-Integrity Mechanisms\n                if (request.containsAttribute(Attribute.MESSAGE_INTEGRITY))\n                {\n                    MessageIntegrityAttribute messageIntegrityAttribute\n                        = (MessageIntegrityAttribute)\n                            response.getAttribute(Attribute.MESSAGE_INTEGRITY);\n\n                    /*\n                     * RFC 5389: If MESSAGE-INTEGRITY was absent, the response\n                     * MUST be discarded, as if it was never received.\n                     */\n                    if (messageIntegrityAttribute == null)\n                        return;\n\n                    UsernameAttribute usernameAttribute\n                        = (UsernameAttribute)\n                            request.getAttribute(Attribute.USERNAME);\n\n                    /*\n                     * For a request or indication message, the agent MUST\n                     * include the USERNAME and MESSAGE-INTEGRITY attributes in\n                     * the message.\n                     */\n                    if (usernameAttribute == null)\n                        return;\n                    if (!harvester.getStunStack().validateMessageIntegrity(\n                            messageIntegrityAttribute,\n                            LongTermCredential.toString(\n                                    usernameAttribute.getUsername()),\n                            !request.containsAttribute(Attribute.REALM)\n                                && !request.containsAttribute(Attribute.NONCE),\n                            event.getRawMessage()))\n                        return;\n                }\n\n                processSuccess(response, request, transactionID);\n            }\n            else\n            {\n                ErrorCodeAttribute errorCodeAttr\n                    = (ErrorCodeAttribute)\n                        response.getAttribute(Attribute.ERROR_CODE);\n\n                if ((errorCodeAttr != null)\n                        && (errorCodeAttr.getErrorClass() == 4))\n                {\n                    try\n                    {\n                        switch (errorCodeAttr.getErrorNumber())\n                        {\n                        case 1: // 401 Unauthorized\n                            if (processUnauthorized(\n                                    response,\n                                    request,\n                                    transactionID))\n                                completedResolvingCandidate = false;\n                            break;\n                        case 38: // 438 Stale Nonce\n                            if (processStaleNonce(\n                                    response,\n                                    request,\n                                    transactionID))\n                                completedResolvingCandidate = false;\n                            break;\n                        }\n                    }\n                    catch (StunException sex)\n                    {\n                        completedResolvingCandidate = true;\n                    }\n                }\n                if (completedResolvingCandidate\n                        && processErrorOrFailure(\n                                response,\n                                request,\n                                transactionID))\n                    completedResolvingCandidate = false;\n            }\n        }\n        finally\n        {\n            if (completedResolvingCandidate)\n                completedResolvingCandidate(request, response);\n        }\n    }\n\n    /**\n     * Handles a specific STUN error <tt>Response</tt> with error code\n     * \"438 Stale Nonce\" to a specific STUN <tt>Request</tt>.\n     *\n     * @param response the received STUN error <tt>Response</tt> with error code\n     * \"438 Stale Nonce\" which is to be handled\n     * @param request the STUN <tt>Request</tt> to which <tt>response</tt>\n     * responds\n     * @param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n     * <tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\n     * it as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\n     * the <tt>applicationData</tt> property value\n     * @return <tt>true</tt> if the specified STUN error <tt>response</tt> was\n     * successfully handled; <tt>false</tt>, otherwise\n     * @throws StunException if anything goes wrong while handling the specified\n     * \"438 Stale Nonce\" error <tt>response</tt>\n     */\n    private boolean processStaleNonce(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n        throws StunException\n    {\n        /*\n         * The request MUST contain USERNAME, REALM, NONCE and MESSAGE-INTEGRITY\n         * attributes.\n         */\n        boolean challenge;\n\n        if (request.getAttributeCount() > 0)\n        {\n            char[] includedRequestAttributeTypes\n                = new char[]\n                        {\n                            Attribute.USERNAME,\n                            Attribute.REALM,\n                            Attribute.NONCE,\n                            Attribute.MESSAGE_INTEGRITY\n                        };\n            challenge = true;\n\n            for (char includedRequestAttributeType\n                    : includedRequestAttributeTypes)\n            {\n                if (!request.containsAttribute(includedRequestAttributeType))\n                {\n                    challenge = false;\n                    break;\n                }\n            }\n        }\n        else\n            challenge = false;\n\n        return\n            (challenge && processChallenge(response, request, transactionID));\n    }\n\n    /**\n     * Handles a specific STUN success <tt>Response</tt> to a specific STUN\n     * <tt>Request</tt>.\n     *\n     * @param response the received STUN success <tt>Response</tt> which is to\n     * be handled\n     * @param request the STUN <tt>Request</tt> to which <tt>response</tt>\n     * responds\n     * @param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n     * <tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\n     * it as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\n     * the <tt>applicationData</tt> property value\n     */\n    protected void processSuccess(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n    {\n        if (!completedResolvingCandidate)\n            createCandidates(response);\n    }\n\n    /**\n     * Handles a specific STUN error <tt>Response</tt> with error code\n     * \"401 Unauthorized\" to a specific STUN <tt>Request</tt>.\n     *\n     * @param response the received STUN error <tt>Response</tt> with error code\n     * \"401 Unauthorized\" which is to be handled\n     * @param request the STUN <tt>Request</tt> to which <tt>response</tt>\n     * responds\n     * @param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n     * <tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\n     * it as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\n     * the <tt>applicationData</tt> property value\n     * @return <tt>true</tt> if the specified STUN error <tt>response</tt> was\n     * successfully handled; <tt>false</tt>, otherwise\n     * @throws StunException if anything goes wrong while handling the specified\n     * \"401 Unauthorized\" error <tt>response</tt>\n     */\n    private boolean processUnauthorized(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n        throws StunException\n    {\n        /*\n         * If the response is a challenge, retry the request with a new\n         * transaction.\n         */\n        boolean challenge = true;\n\n        /*\n         * The client SHOULD omit the USERNAME, MESSAGE-INTEGRITY, REALM, and\n         * NONCE attributes from the \"First Request\".\n         */\n        if (request.getAttributeCount() > 0)\n        {\n            char[] excludedRequestAttributeTypes\n                = new char[]\n                        {\n                            Attribute.USERNAME,\n                            Attribute.MESSAGE_INTEGRITY,\n                            Attribute.REALM,\n                            Attribute.NONCE\n                        };\n\n            for (char excludedRequestAttributeType\n                    : excludedRequestAttributeTypes)\n            {\n                if (request.containsAttribute(excludedRequestAttributeType))\n                {\n                    challenge = false;\n                    break;\n                }\n            }\n        }\n\n        return\n            (challenge && processChallenge(response, request, transactionID));\n    }\n\n    /**\n     * Runs in {@link #sendKeepAliveMessageThread} and sends STUN\n     * keep-alive <tt>Message</tt>s to the STUN server associated with the\n     * <tt>StunCandidateHarvester</tt> of this instance.\n     *\n     * @return <tt>true</tt> if the method is to be invoked again; otherwise,\n     * <tt>false</tt>\n     */\n    private boolean runInSendKeepAliveMessageThread()\n    {\n        synchronized (sendKeepAliveMessageSyncRoot)\n        {\n            // Since we're going to #wait, make sure we're not canceled yet.\n            if (sendKeepAliveMessageThread != Thread.currentThread())\n                return false;\n            if (sendKeepAliveMessageInterval\n                    == SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED)\n            {\n                return false;\n            }\n\n            // Determine the amount of milliseconds that we'll have to #wait.\n            long timeout;\n\n            if (sendKeepAliveMessageTime == -1)\n            {\n                /*\n                 * If we're just starting, don't just go and send a new STUN\n                 * keep-alive message but rather wait for the whole interval.\n                 */\n                timeout = sendKeepAliveMessageInterval;\n            }\n            else\n            {\n                timeout\n                    = sendKeepAliveMessageTime\n                        + sendKeepAliveMessageInterval\n                        - System.currentTimeMillis();\n            }\n            // At long last, #wait if necessary.\n            if (timeout > 0)\n            {\n                try\n                {\n                    sendKeepAliveMessageSyncRoot.wait(timeout);\n                }\n                catch (InterruptedException iex)\n                {\n                }\n                /*\n                 * Apart from being the time to send the STUN keep-alive\n                 * message, it could be that we've experienced a spurious\n                 * wake-up or that we've been canceled.\n                 */\n                return true;\n            }\n        }\n\n        sendKeepAliveMessageTime = System.currentTimeMillis();\n        try\n        {\n            sendKeepAliveMessage();\n        }\n        catch (StunException sex)\n        {\n            logger.log(\n                    Level.INFO,\n                    \"Failed to send STUN keep-alive message.\",\n                    sex);\n        }\n        return true;\n    }\n\n    /**\n     * Sends a new STUN <tt>Message</tt> to the STUN server associated with the\n     * <tt>StunCandidateHarvester</tt> of this instance in order to keep a\n     * <tt>LocalCandidate</tt> harvested by this instance alive.\n     *\n     * @throws StunException if anything goes wrong while sending a new\n     * keep-alive STUN <tt>Message</tt>\n     */\n    protected void sendKeepAliveMessage()\n        throws StunException\n    {\n        for (LocalCandidate candidate : getCandidates())\n            if (sendKeepAliveMessage(candidate))\n                break;\n    }\n\n    /**\n     * Sends a new STUN <tt>Message</tt> to the STUN server associated with the\n     * <tt>StunCandidateHarvester</tt> of this instance in order to keep a\n     * specific <tt>LocalCandidate</tt> alive.\n     *\n     * @param candidate the <tt>LocalCandidate</tt> to send a new keep-alive\n     * STUN <tt>Message</tt> for\n     * @return <tt>true</tt> if a new STUN <tt>Message</tt> was sent to the\n     * STUN server associated with the <tt>StunCandidateHarvester</tt> of this\n     * instance or <tt>false</tt> if the STUN kee-alive functionality was not\n     * been used for the specified <tt>candidate</tt>\n     * @throws StunException if anything goes wrong while sending the new\n     * keep-alive STUN <tt>Message</tt> for the specified <tt>candidate</tt>\n     */\n    protected boolean sendKeepAliveMessage(LocalCandidate candidate)\n        throws StunException\n    {\n        Message keepAliveMessage = createKeepAliveMessage(candidate);\n\n        /*\n         * The #createKeepAliveMessage method javadoc says it returns null when\n         * the STUN keep-alive functionality of this StunCandidateHarvest is to\n         * not be utilized.\n         */\n        if (keepAliveMessage == null)\n        {\n            return false;\n        }\n        else if (keepAliveMessage instanceof Request)\n        {\n            return\n                (sendRequest((Request) keepAliveMessage, false, null) != null);\n        }\n        else\n        {\n            throw new StunException(\n                    StunException.ILLEGAL_ARGUMENT,\n                    \"Failed to create keep-alive STUN message for candidate: \"\n                            + candidate);\n        }\n    }\n\n    /**\n     * Sends a specific <tt>Request</tt> to the STUN server associated with this\n     * <tt>StunCandidateHarvest</tt>.\n     *\n     * @param request the <tt>Request</tt> to send to the STUN server associated\n     * with this <tt>StunCandidateHarvest</tt>\n     * @param firstRequest <tt>true</tt> if the specified <tt>request</tt>\n     * should be sent as the first request in the terms of STUN; otherwise,\n     * <tt>false</tt>\n     * @return the <tt>TransactionID</tt> of the STUN client transaction through\n     * which the specified <tt>Request</tt> has been sent to the STUN server\n     * associated with this <tt>StunCandidateHarvest</tt>\n     * @param transactionID the <tt>TransactionID</tt> of <tt>request</tt>\n     * because <tt>request</tt> only has it as a <tt>byte</tt> array and\n     * <tt>TransactionID</tt> is required for the <tt>applicationData</tt>\n     * property value\n     * @throws StunException if anything goes wrong while sending the specified\n     * <tt>Request</tt> to the STUN server associated with this\n     * <tt>StunCandidateHarvest</tt>\n     */\n    protected TransactionID sendRequest(\n            Request request,\n            boolean firstRequest,\n            TransactionID transactionID)\n        throws StunException\n    {\n        if (!firstRequest && (longTermCredentialSession != null))\n            longTermCredentialSession.addAttributes(request);\n\n        StunStack stunStack = harvester.getStunStack();\n        TransportAddress stunServer = harvester.stunServer;\n        TransportAddress hostCandidateTransportAddress\n            = hostCandidate.getTransportAddress();\n\n        if (transactionID == null)\n        {\n            byte[] transactionIDAsBytes = request.getTransactionID();\n\n            transactionID\n                = (transactionIDAsBytes == null)\n                    ? TransactionID.createNewTransactionID()\n                    : TransactionID.createTransactionID(\n                            harvester.getStunStack(),\n                            transactionIDAsBytes);\n        }\n        synchronized (requests)\n        {\n            try\n            {\n                transactionID\n                    = stunStack\n                        .sendRequest(\n                            request,\n                            stunServer,\n                            hostCandidateTransportAddress,\n                            this,\n                            transactionID);\n            }\n            catch (IllegalArgumentException iaex)\n            {\n                if (logger.isLoggable(Level.INFO))\n                {\n                    logger.log(\n                            Level.INFO,\n                            \"Failed to send \"\n                                + request\n                                + \" through \" + hostCandidateTransportAddress\n                                + \" to \" + stunServer,\n                            iaex);\n                }\n                throw new StunException(\n                        StunException.ILLEGAL_ARGUMENT,\n                        iaex.getMessage(),\n                        iaex);\n            }\n            catch (IOException ioex)\n            {\n                if (logger.isLoggable(Level.INFO))\n                {\n                    logger.log(\n                            Level.INFO,\n                            \"Failed to send \"\n                                + request\n                                + \" through \" + hostCandidateTransportAddress\n                                + \" to \" + stunServer,\n                            ioex);\n                }\n                throw new StunException(\n                        StunException.NETWORK_ERROR,\n                        ioex.getMessage(),\n                        ioex);\n            }\n\n            requests.put(transactionID, request);\n        }\n        return transactionID;\n    }\n\n    /**\n     * Sets the interval in milliseconds at which a new STUN keep-alive message\n     * is to be sent to the STUN server associated with the\n     * <tt>StunCandidateHarvester</tt> of this instance in order to keep one of\n     * the <tt>Candidate</tt>s harvested by this instance alive.\n     *\n     * @param sendKeepAliveMessageInterval the interval in milliseconds at which\n     * a new STUN keep-alive message is to be sent to the STUN server associated\n     * with the <tt>StunCandidateHarvester</tt> of this instance in order to\n     * keep one of the <tt>Candidate</tt>s harvested by this instance alive or\n     * {@link #SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED} if the keep-alive\n     * functionality is to not be utilized\n     */\n    protected void setSendKeepAliveMessageInterval(\n            long sendKeepAliveMessageInterval)\n    {\n        if ((sendKeepAliveMessageInterval\n                    != SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED)\n                && (sendKeepAliveMessageInterval < 1))\n            throw new IllegalArgumentException(\"sendKeepAliveMessageInterval\");\n\n        synchronized (sendKeepAliveMessageSyncRoot)\n        {\n            this.sendKeepAliveMessageInterval = sendKeepAliveMessageInterval;\n            if (sendKeepAliveMessageThread == null)\n            {\n                if (this.sendKeepAliveMessageInterval\n                        != SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED)\n                    createSendKeepAliveMessageThread();\n            }\n            else\n                sendKeepAliveMessageSyncRoot.notify();\n        }\n    }\n\n    /**\n     * Starts the harvesting of <tt>Candidate</tt>s to be performed for\n     * {@link #hostCandidate}.\n     *\n     * @return <tt>true</tt> if this <tt>StunCandidateHarvest</tt> has started\n     * the harvesting of <tt>Candidate</tt>s for {@link #hostCandidate};\n     * otherwise, <tt>false</tt>\n     * @throws Exception if anything goes wrong while starting the harvesting of\n     * <tt>Candidate</tt>s to be performed for {@link #hostCandidate}\n     */\n    boolean startResolvingCandidate()\n        throws Exception\n    {\n        Request requestToStartResolvingCandidate;\n\n        if (!completedResolvingCandidate\n                && ((requestToStartResolvingCandidate\n                            = createRequestToStartResolvingCandidate())\n                        != null))\n        {\n            // Short-Term Credential Mechanism\n            addShortTermCredentialAttributes(requestToStartResolvingCandidate);\n\n            sendRequest(requestToStartResolvingCandidate, true, null);\n            return true;\n        }\n        else\n            return false;\n    }\n\n    /**\n     * Close the harvest.\n     */\n    public void close()\n    {\n        // stop keep alive thread\n        setSendKeepAliveMessageInterval(\n            SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED);\n    }\n\n    /**\n     * Sends STUN keep-alive <tt>Message</tt>s to the STUN server associated\n     * with the <tt>StunCandidateHarvester</tt> of this instance.\n     *\n     * @author Lyubomir Marinov\n     */\n    private static class SendKeepAliveMessageThread\n        extends Thread\n    {\n        /**\n         * The <tt>StunCandidateHarvest</tt> which has initialized this\n         * instance. The <tt>StunCandidateHarvest</tt> is referenced by a\n         * <tt>WeakReference</tt> in an attempt to reduce the risk that the\n         * <tt>Thread</tt> may live regardless of the fact that the specified\n         * <tt>StunCandidateHarvest</tt> may no longer be reachable.\n         */\n        private final WeakReference<StunCandidateHarvest> harvest;\n\n        /**\n         * Initializes a new <tt>SendKeepAliveMessageThread</tt> instance with a\n         * specific <tt>StunCandidateHarvest</tt>.\n         *\n         * @param harvest the <tt>StunCandidateHarvest</tt> to initialize the\n         * new instance with\n         */\n        public SendKeepAliveMessageThread(StunCandidateHarvest harvest)\n        {\n            this.harvest = new WeakReference<>(harvest);\n        }\n\n        @Override\n        public void run()\n        {\n            try\n            {\n                do\n                {\n                    StunCandidateHarvest harvest = this.harvest.get();\n\n                    if ((harvest == null)\n                            || !harvest.runInSendKeepAliveMessageThread())\n                    {\n                        break;\n                    }\n                }\n                while (true);\n            }\n            finally\n            {\n                StunCandidateHarvest harvest = this.harvest.get();\n\n                if (harvest != null)\n                    harvest.exitSendKeepAliveMessageThread();\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(StunCandidateHarvest.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>StunCandidateHarvest</tt> class and\nits instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(StunCandidateHarvest.class.getName())", "syntax_pass": true}, {"attribute_expression": "private static final LocalCandidate[] NO_CANDIDATES = new LocalCandidate[0];", "docstring": "\nThe constant which defines an empty array with <tt>LocalCandidate</tt>\nelement type. Explicitly defined in order to reduce unnecessary\nallocations.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "LocalCandidate[]", "name": "NO_CANDIDATES = new LocalCandidate[0]", "syntax_pass": true}, {"attribute_expression": "protected static final long SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED\n        = 0;", "docstring": "\nThe value of the <tt>sendKeepAliveMessage</tt> property of\n<tt>StunCandidateHarvest</tt> which specifies that no sending of STUN\nkeep-alive messages is to performed for the purposes of keeping the\n<tt>Candidate</tt>s harvested by the <tt>StunCandidateHarvester</tt> in\nquestion alive.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "long", "name": "SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED\n        = 0", "syntax_pass": true}, {"attribute_expression": "private final List<LocalCandidate> candidates = new LinkedList<>();", "docstring": "\nThe list of <tt>Candidate</tt>s harvested for {@link #hostCandidate} by\nthis harvest.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<LocalCandidate>", "name": "candidates = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private boolean completedResolvingCandidate = false;", "docstring": "\nThe indicator which determines whether this <tt>StunCandidateHarvest</tt>\nhas completed the harvesting of <tt>Candidate</tt>s for\n{@link #hostCandidate}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "completedResolvingCandidate = false", "syntax_pass": true}, {"attribute_expression": "public final StunCandidateHarvester harvester;", "docstring": "\nThe <tt>StunCandidateHarvester</tt> performing the harvesting of STUN\n<tt>Candidate</tt>s for a <tt>Component</tt> which this harvest is part\nof.\n", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "StunCandidateHarvester", "name": "harvester", "syntax_pass": true}, {"attribute_expression": "public final HostCandidate hostCandidate;", "docstring": "\nThe <tt>HostCandidate</tt> the STUN harvesting of which is represented by\nthis instance.\n", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "HostCandidate", "name": "hostCandidate", "syntax_pass": true}, {"attribute_expression": "private LongTermCredentialSession longTermCredentialSession;", "docstring": "\nThe <tt>LongTermCredential</tt> used by this instance.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "LongTermCredentialSession", "name": "longTermCredentialSession", "syntax_pass": true}, {"attribute_expression": "private final Map<TransactionID, Request> requests = new HashMap<>();", "docstring": "\nThe STUN <tt>Request</tt>s which have been sent by this instance, have\nnot received a STUN <tt>Response</tt> yet and have not timed out. Put in\nplace to avoid a limitation of the <tt>ResponseCollector</tt> and its use\nof <tt>StunMessageEvent</tt> which do not make the STUN <tt>Request</tt>\nto which a STUN <tt>Response</tt> responds available though it is known\nin <tt>StunClientTransaction</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<TransactionID, Request>", "name": "requests = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private long sendKeepAliveMessageInterval\n        = SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED;", "docstring": "\nThe interval in milliseconds at which a new STUN keep-alive message is to\nbe sent to the STUN server associated with the\n<tt>StunCandidateHarvester</tt> of this instance in order to keep one of\nthe <tt>Candidate</tt>s harvested by this instance alive.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "sendKeepAliveMessageInterval\n        = SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED", "syntax_pass": true}, {"attribute_expression": "private final Object sendKeepAliveMessageSyncRoot = new Object();", "docstring": "\nThe <tt>Object</tt> used to synchronize access to the members related to\nthe sending of STUN keep-alive messages to the STUN server associated\nwith the <tt>StunCandidateHarvester</tt> of this instance.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "sendKeepAliveMessageSyncRoot = new Object()", "syntax_pass": true}, {"attribute_expression": "private Thread sendKeepAliveMessageThread;", "docstring": "\nThe <tt>Thread</tt> which sends the STUN keep-alive messages to the STUN\nserver associated with the <tt>StunCandidateHarvester</tt> of this\ninstance in order to keep the <tt>Candidate</tt>s harvested by this\ninstance alive.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Thread", "name": "sendKeepAliveMessageThread", "syntax_pass": true}, {"attribute_expression": "private long sendKeepAliveMessageTime = -1;", "docstring": "\nThe time (stamp) in milliseconds of the last call to\n{@link #sendKeepAliveMessage()} which completed without throwing an\nexception. <b>Note</b>: It doesn't mean that the keep-alive message was a\nSTUN <tt>Request</tt> and it received a success STUN <tt>Response</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "sendKeepAliveMessageTime = -1", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester", "name": "SinglePortUdpHarvester", "file_path": "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java", "superclasses": "AbstractUdpListener", "methods": ["[List<SinglePortUdpHarvester>]createHarvesters(int)", "[]SinglePortUdpHarvester(TransportAddress)", "[HarvestStatistics]getHarvestStatistics()", "[MySocket]maybeAcceptNewSession(Buffer,InetSocketAddress,String)", "[Collection<LocalCandidate>]harvest(Component)", "[boolean]isHostHarvester()"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester.[List<SinglePortUdpHarvester>]createHarvesters(int)", "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester.[]SinglePortUdpHarvester(TransportAddress)", "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester.[HarvestStatistics]getHarvestStatistics()", "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester.[MySocket]maybeAcceptNewSession(Buffer,InetSocketAddress,String)", "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester.[Collection<LocalCandidate>]harvest(Component)", "src/main/java/org/ice4j/ice/harvest/SinglePortUdpHarvester.java.SinglePortUdpHarvester.[boolean]isHostHarvester()"], "overrides": null, "attributes": [{"original_string": "    private class MyCandidate\n        extends HostCandidate\n    {\n        /**\n         * The local username fragment associated with this candidate.\n         */\n        private final String ufrag;\n\n        /**\n         * The flag which indicates that this <tt>MyCandidate</tt> has been\n         * freed.\n         */\n        private boolean freed = false;\n\n        /**\n         * The collection of <tt>IceSocketWrapper</tt>s that can potentially\n         * be used by the ice4j user to read/write from/to this candidate.\n         * The keys are the remote addresses for each socket.\n         * <p>\n         * There are wrappers over <tt>MultiplexedDatagramSocket</tt>s over\n         * a corresponding socket in {@link #sockets}.\n         */\n        private final Map<SocketAddress, IceSocketWrapper> candidateSockets\n            = new HashMap<>();\n\n        /**\n         * The collection of <tt>DatagramSocket</tt>s added to this candidate.\n         * The keys are the remote addresses for each socket.\n         * <p>\n         * These are the \"raw\" sockets, before any wrappers are added for\n         * the STUN stack or the user of ice4j.\n         */\n        private final Map<SocketAddress, DatagramSocket> sockets\n            = new HashMap<>();\n\n        /**\n         * Initializes a new <tt>MyCandidate</tt> instance with the given\n         * <tt>Component</tt> and the given local username fragment.\n         *\n         * @param component the <tt>Component</tt> for which this candidate will\n         * serve.\n         * @param ufrag the local ICE username fragment for this candidate (and\n         * its <tt>Component</tt> and <tt>Agent</tt>).\n         */\n        private MyCandidate(Component component, String ufrag)\n        {\n            super(localAddress, component);\n            this.ufrag = ufrag;\n        }\n\n        /**\n         * {@inheritDoc}\n         * <p>\n         * Closes all sockets in use by this <tt>LocalCandidate</tt>.\n         */\n        @Override\n        public void free()\n        {\n            synchronized (this)\n            {\n                if (freed)\n                    return;\n                freed = true;\n            }\n\n            candidates.remove(ufrag);\n\n            synchronized (sockets)\n            {\n                StunStack stunStack = getStunStack();\n\n                for (Map.Entry<SocketAddress, DatagramSocket> e\n                    : sockets.entrySet())\n                {\n                    DatagramSocket socket = e.getValue();\n\n                    if (stunStack != null)\n                    {\n                        TransportAddress localAddress\n                            = new TransportAddress(socket.getLocalAddress(),\n                                                   socket.getLocalPort(),\n                                                   Transport.UDP);\n                        TransportAddress remoteAddress\n                            = new TransportAddress(\n                            (InetSocketAddress) e.getKey(),\n\n                            Transport.UDP);\n\n                        stunStack.removeSocket(localAddress, remoteAddress);\n                    }\n\n                    socket.close();\n                }\n\n                sockets.clear();\n            }\n\n            synchronized (candidateSockets)\n            {\n                for (IceSocketWrapper wrapper : candidateSockets.values())\n                {\n                    wrapper.close();\n                }\n\n                candidateSockets.clear();\n            }\n\n            super.free();\n        }\n\n        /**\n         * Adds a new <tt>Socket</tt> to this candidate, which is associated\n         * with a particular remote address.\n         *\n         * @param socket the socket to add.\n         * @param remoteAddress the remote address for the socket.\n         */\n        private synchronized void addSocket(DatagramSocket socket,\n                                            InetSocketAddress remoteAddress)\n            throws IOException\n        {\n            if (freed)\n            {\n                throw new IOException(\"Candidate freed\");\n            }\n\n            Component component = getParentComponent();\n            if (component == null)\n            {\n                throw new IOException(\"No parent component\");\n            }\n\n            IceProcessingState state\n                = component.getParentStream().getParentAgent().getState();\n            if (state == IceProcessingState.FAILED)\n            {\n                throw new IOException(\n                    \"Cannot add socket to an Agent in state FAILED.\");\n            }\n            else if (state != null && state.isOver()\n                && logger.isLoggable(Level.FINE))\n            {\n                logger.fine(\n                    \"Adding a socket to a completed Agent, state=\" + state);\n            }\n\n            MultiplexingDatagramSocket multiplexing\n                = new MultiplexingDatagramSocket(socket);\n\n            // Socket to add to the candidate\n            IceSocketWrapper candidateSocket\n                = new IceUdpSocketWrapper(multiplexing);\n\n            // STUN-only filtered socket to add to the StunStack\n            IceSocketWrapper stunSocket\n                = new IceUdpSocketWrapper(\n                multiplexing.getSocket(new StunDatagramPacketFilter()));\n\n            component.getParentStream().getParentAgent().getStunStack()\n                .addSocket(\n                    stunSocket,\n                    new TransportAddress(remoteAddress, Transport.UDP));\n\n            MergingDatagramSocket componentSocket\n                = component.getComponentSocket();\n            if (componentSocket != null)\n            {\n                componentSocket.add(multiplexing);\n            }\n\n            synchronized (candidateSockets)\n            {\n                IceSocketWrapper oldSocket\n                    = candidateSockets.put(remoteAddress, candidateSocket);\n                if (oldSocket != null)\n                {\n                    logger.warning(\"Replacing the socket for remote address \"\n                                       + remoteAddress);\n                    oldSocket.close();\n                }\n            }\n\n            // XXX is this necessary?\n            synchronized (sockets)\n            {\n                sockets.put(remoteAddress, socket);\n            }\n        }\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected IceSocketWrapper getCandidateIceSocketWrapper(\n            SocketAddress remoteAddress)\n        {\n            synchronized (candidateSockets)\n            {\n                return candidateSockets.get(remoteAddress);\n            }\n        }\n    }", "definition": "    private class MyCandidate\n        extends HostCandidate", "class_docstring": "\nImplements a <tt>Candidate</tt> for the purposes of this\n<tt>SinglePortUdpHarvester</tt>.\n", "name": "MyCandidate", "super_interfaces": [], "superclasses": "HostCandidate", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [{"attribute_expression": "private final String ufrag;", "docstring": "\nThe local username fragment associated with this candidate.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "ufrag", "syntax_pass": true}, {"attribute_expression": "private boolean freed = false;", "docstring": "\nThe flag which indicates that this <tt>MyCandidate</tt> has been\nfreed.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "freed = false", "syntax_pass": true}, {"attribute_expression": "private final Map<SocketAddress, IceSocketWrapper> candidateSockets\n            = new HashMap<>();", "docstring": "\nThe collection of <tt>IceSocketWrapper</tt>s that can potentially\nbe used by the ice4j user to read/write from/to this candidate.\nThe keys are the remote addresses for each socket.\n<p>\nThere are wrappers over <tt>MultiplexedDatagramSocket</tt>s over\na corresponding socket in {@link #sockets}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<SocketAddress, IceSocketWrapper>", "name": "candidateSockets\n            = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<SocketAddress, DatagramSocket> sockets\n            = new HashMap<>();", "docstring": "\nThe collection of <tt>DatagramSocket</tt>s added to this candidate.\nThe keys are the remote addresses for each socket.\n<p>\nThese are the \"raw\" sockets, before any wrappers are added for\nthe STUN stack or the user of ice4j.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<SocketAddress, DatagramSocket>", "name": "sockets\n            = new HashMap<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private MyCandidate(Component component, String ufrag)\n        {\n            super(localAddress, component);\n            this.ufrag = ufrag;\n        }", "docstring": "\nInitializes a new <tt>MyCandidate</tt> instance with the given\n<tt>Component</tt> and the given local username fragment.\n\n@param component the <tt>Component</tt> for which this candidate will\nserve.\n@param ufrag the local ICE username fragment for this candidate (and\nits <tt>Component</tt> and <tt>Agent</tt>).\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "MyCandidate", "params": [{"name": "component", "type": "Component"}, {"name": "ufrag", "type": "String"}], "body": "        {\n            super(localAddress, component);\n            this.ufrag = ufrag;\n        }", "signature": "private MyCandidate(Component component, String ufrag)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void free()\n        {\n            synchronized (this)\n            {\n                if (freed)\n                    return;\n                freed = true;\n            }\n\n            candidates.remove(ufrag);\n\n            synchronized (sockets)\n            {\n                StunStack stunStack = getStunStack();\n\n                for (Map.Entry<SocketAddress, DatagramSocket> e\n                    : sockets.entrySet())\n                {\n                    DatagramSocket socket = e.getValue();\n\n                    if (stunStack != null)\n                    {\n                        TransportAddress localAddress\n                            = new TransportAddress(socket.getLocalAddress(),\n                                                   socket.getLocalPort(),\n                                                   Transport.UDP);\n                        TransportAddress remoteAddress\n                            = new TransportAddress(\n                            (InetSocketAddress) e.getKey(),\n\n                            Transport.UDP);\n\n                        stunStack.removeSocket(localAddress, remoteAddress);\n                    }\n\n                    socket.close();\n                }\n\n                sockets.clear();\n            }\n\n            synchronized (candidateSockets)\n            {\n                for (IceSocketWrapper wrapper : candidateSockets.values())\n                {\n                    wrapper.close();\n                }\n\n                candidateSockets.clear();\n            }\n\n            super.free();\n        }", "docstring": "\n{@inheritDoc}\n<p>\nCloses all sockets in use by this <tt>LocalCandidate</tt>.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "free", "params": [], "body": "        {\n            synchronized (this)\n            {\n                if (freed)\n                    return;\n                freed = true;\n            }\n\n            candidates.remove(ufrag);\n\n            synchronized (sockets)\n            {\n                StunStack stunStack = getStunStack();\n\n                for (Map.Entry<SocketAddress, DatagramSocket> e\n                    : sockets.entrySet())\n                {\n                    DatagramSocket socket = e.getValue();\n\n                    if (stunStack != null)\n                    {\n                        TransportAddress localAddress\n                            = new TransportAddress(socket.getLocalAddress(),\n                                                   socket.getLocalPort(),\n                                                   Transport.UDP);\n                        TransportAddress remoteAddress\n                            = new TransportAddress(\n                            (InetSocketAddress) e.getKey(),\n\n                            Transport.UDP);\n\n                        stunStack.removeSocket(localAddress, remoteAddress);\n                    }\n\n                    socket.close();\n                }\n\n                sockets.clear();\n            }\n\n            synchronized (candidateSockets)\n            {\n                for (IceSocketWrapper wrapper : candidateSockets.values())\n                {\n                    wrapper.close();\n                }\n\n                candidateSockets.clear();\n            }\n\n            super.free();\n        }", "signature": "@Override\n        public void free()"}, {"syntax_pass": true, "original_string": "        private synchronized void addSocket(DatagramSocket socket,\n                                            InetSocketAddress remoteAddress)\n            throws IOException\n        {\n            if (freed)\n            {\n                throw new IOException(\"Candidate freed\");\n            }\n\n            Component component = getParentComponent();\n            if (component == null)\n            {\n                throw new IOException(\"No parent component\");\n            }\n\n            IceProcessingState state\n                = component.getParentStream().getParentAgent().getState();\n            if (state == IceProcessingState.FAILED)\n            {\n                throw new IOException(\n                    \"Cannot add socket to an Agent in state FAILED.\");\n            }\n            else if (state != null && state.isOver()\n                && logger.isLoggable(Level.FINE))\n            {\n                logger.fine(\n                    \"Adding a socket to a completed Agent, state=\" + state);\n            }\n\n            MultiplexingDatagramSocket multiplexing\n                = new MultiplexingDatagramSocket(socket);\n\n            // Socket to add to the candidate\n            IceSocketWrapper candidateSocket\n                = new IceUdpSocketWrapper(multiplexing);\n\n            // STUN-only filtered socket to add to the StunStack\n            IceSocketWrapper stunSocket\n                = new IceUdpSocketWrapper(\n                multiplexing.getSocket(new StunDatagramPacketFilter()));\n\n            component.getParentStream().getParentAgent().getStunStack()\n                .addSocket(\n                    stunSocket,\n                    new TransportAddress(remoteAddress, Transport.UDP));\n\n            MergingDatagramSocket componentSocket\n                = component.getComponentSocket();\n            if (componentSocket != null)\n            {\n                componentSocket.add(multiplexing);\n            }\n\n            synchronized (candidateSockets)\n            {\n                IceSocketWrapper oldSocket\n                    = candidateSockets.put(remoteAddress, candidateSocket);\n                if (oldSocket != null)\n                {\n                    logger.warning(\"Replacing the socket for remote address \"\n                                       + remoteAddress);\n                    oldSocket.close();\n                }\n            }\n\n            // XXX is this necessary?\n            synchronized (sockets)\n            {\n                sockets.put(remoteAddress, socket);\n            }\n        }", "docstring": "\nAdds a new <tt>Socket</tt> to this candidate, which is associated\nwith a particular remote address.\n\n@param socket the socket to add.\n@param remoteAddress the remote address for the socket.\n", "attributes": {"modifiers": "private synchronized", "marker_annotations": [], "non_marker_annotations": ["private", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "addSocket", "params": [{"name": "socket", "type": "DatagramSocket"}, {"name": "remoteAddress", "type": "InetSocketAddress"}], "body": "        {\n            if (freed)\n            {\n                throw new IOException(\"Candidate freed\");\n            }\n\n            Component component = getParentComponent();\n            if (component == null)\n            {\n                throw new IOException(\"No parent component\");\n            }\n\n            IceProcessingState state\n                = component.getParentStream().getParentAgent().getState();\n            if (state == IceProcessingState.FAILED)\n            {\n                throw new IOException(\n                    \"Cannot add socket to an Agent in state FAILED.\");\n            }\n            else if (state != null && state.isOver()\n                && logger.isLoggable(Level.FINE))\n            {\n                logger.fine(\n                    \"Adding a socket to a completed Agent, state=\" + state);\n            }\n\n            MultiplexingDatagramSocket multiplexing\n                = new MultiplexingDatagramSocket(socket);\n\n            // Socket to add to the candidate\n            IceSocketWrapper candidateSocket\n                = new IceUdpSocketWrapper(multiplexing);\n\n            // STUN-only filtered socket to add to the StunStack\n            IceSocketWrapper stunSocket\n                = new IceUdpSocketWrapper(\n                multiplexing.getSocket(new StunDatagramPacketFilter()));\n\n            component.getParentStream().getParentAgent().getStunStack()\n                .addSocket(\n                    stunSocket,\n                    new TransportAddress(remoteAddress, Transport.UDP));\n\n            MergingDatagramSocket componentSocket\n                = component.getComponentSocket();\n            if (componentSocket != null)\n            {\n                componentSocket.add(multiplexing);\n            }\n\n            synchronized (candidateSockets)\n            {\n                IceSocketWrapper oldSocket\n                    = candidateSockets.put(remoteAddress, candidateSocket);\n                if (oldSocket != null)\n                {\n                    logger.warning(\"Replacing the socket for remote address \"\n                                       + remoteAddress);\n                    oldSocket.close();\n                }\n            }\n\n            // XXX is this necessary?\n            synchronized (sockets)\n            {\n                sockets.put(remoteAddress, socket);\n            }\n        }", "signature": "private synchronized void addSocket(DatagramSocket socket,\n                                            InetSocketAddress remoteAddress)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected IceSocketWrapper getCandidateIceSocketWrapper(\n            SocketAddress remoteAddress)\n        {\n            synchronized (candidateSockets)\n            {\n                return candidateSockets.get(remoteAddress);\n            }\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "IceSocketWrapper", "classes": []}, "name": "getCandidateIceSocketWrapper", "params": [{"name": "remoteAddress", "type": "SocketAddress"}], "body": "        {\n            synchronized (candidateSockets)\n            {\n                return candidateSockets.get(remoteAddress);\n            }\n        }", "signature": "@Override\n        protected IceSocketWrapper getCandidateIceSocketWrapper(\n            SocketAddress remoteAddress)"}]}], "class_docstring": "\nA harvester implementation which binds to a single <tt>DatagramSocket</tt>\nand provides local candidates of type \"host\". It runs a thread which perpetually reads from the socket.\n\nWhen {@link #harvest(org.ice4j.ice.Component)} is called, this harvester\ncreates and adds to the component a\n{@link org.ice4j.ice.harvest.SinglePortUdpHarvester.MyCandidate} instance,\nand associates the component's local username fragment (ufrag) with this\ncandidate.\n\nWhen a STUN Binding Request with a given ufrag is received, if the ufrag\nmatches one of the registered candidates, then a new socket is created, which\nis to receive further packets from the remote address, and the socket is\nadded to the candidate.\n\n@author Boris Grozev\n", "original_string": "public class SinglePortUdpHarvester\n        extends AbstractUdpListener\n        implements CandidateHarvester\n{\n    /**\n     * Our class logger.\n     */\n    private static final Logger logger\n            = Logger.getLogger(SinglePortUdpHarvester.class.getName());\n\n    /**\n     * Creates a new <tt>SinglePortUdpHarvester</tt> instance for each allowed\n     * IP address found on each allowed network interface, with the given port.\n     *\n     * @param port the UDP port number to use.\n     * @return the list of created <tt>SinglePortUdpHarvester</tt>s.\n     */\n    public static List<SinglePortUdpHarvester> createHarvesters(int port)\n    {\n        List<SinglePortUdpHarvester> harvesters = new LinkedList<>();\n\n        for (TransportAddress address\n                : AbstractUdpListener.getAllowedAddresses(port))\n        {\n            try\n            {\n                harvesters.add(\n                    new SinglePortUdpHarvester(address));\n            }\n            catch (IOException ioe)\n            {\n                logger.info(\"Failed to create SinglePortUdpHarvester for \"\n                                + \"address \" + address + \": \" + ioe);\n            }\n        }\n\n        return harvesters;\n    }\n\n    /**\n     * The map which keeps all currently active <tt>Candidate</tt>s created by\n     * this harvester. The keys are the local username fragments (ufrags) of\n     * the components for which the candidates are harvested.\n     */\n    private final Map<String, MyCandidate> candidates\n            = new ConcurrentHashMap<>();\n\n    /**\n     * Manages statistics about harvesting time.\n     */\n    private HarvestStatistics harvestStatistics = new HarvestStatistics();\n\n    /**\n     * Initializes a new <tt>SinglePortUdpHarvester</tt> instance which is to\n     * bind on the specified local address.\n     * @param localAddress the address to bind to. If the port is 0 an ephemeral port is chosen by the OS and the\n     *                     SinglePortUdpHarvester.localAddress will reflect the allocated port number.\n     * @throws IOException if initialization fails.\n     */\n    public SinglePortUdpHarvester(TransportAddress localAddress)\n        throws IOException\n    {\n        super(localAddress);\n        logger.info(\"Initialized SinglePortUdpHarvester with address \"\n                            + this.localAddress);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public HarvestStatistics getHarvestStatistics()\n    {\n        return harvestStatistics;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Looks for an ICE candidate registered with this harvester, which has a\n     * local ufrag of {@code ufrag}, and if one is found it accepts the new\n     * socket and adds it to the candidate.\n     */\n    protected MySocket maybeAcceptNewSession(Buffer buf,\n                                         InetSocketAddress remoteAddress,\n                                         String ufrag)\n    {\n        MyCandidate candidate = candidates.get(ufrag);\n        if (candidate == null)\n        {\n            // A STUN Binding Request with an unknown USERNAME. Drop it.\n            return null;\n        }\n\n        // This is a STUN Binding Request destined for this\n        // specific Candidate/Component/Agent.\n        try\n        {\n            // 1. Create a socket for this remote address\n            // 2. Set-up de-multiplexing for future datagrams with this address to this socket.\n            MySocket newSocket = addSocket(\n                    remoteAddress,\n                    ufrag,\n                    candidate.getParentComponent());\n\n            // 3. Let the candidate and its STUN stack no about the\n            // new socket.\n            candidate.addSocket(newSocket, remoteAddress);\n\n            return newSocket;\n        }\n        catch (SocketException se)\n        {\n            logger.info(\"Could not create a socket: \" + se);\n            return null;\n        }\n        catch (IOException ioe)\n        {\n            logger.info(\"Failed to handle new socket: \" + ioe);\n            return null;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Collection<LocalCandidate> harvest(Component component)\n    {\n        IceMediaStream stream = component.getParentStream();\n        Agent agent = stream.getParentAgent();\n        String ufrag = agent.getLocalUfrag();\n\n        if (stream.getComponentCount() != 1 || agent.getStreamCount() != 1)\n        {\n            /*\n             * SinglePortUdpHarvester only works with streams with a\n             * single component, and agents with a single stream. This is\n             * because we use the local \"ufrag\" from an incoming STUN packet\n             * to setup de-multiplexing based on remote transport address.\n             */\n            logger.info(\n                    \"More than one Component for an Agent, cannot harvest.\");\n            return new LinkedList<>();\n        }\n\n        MyCandidate candidate = new MyCandidate(component, ufrag);\n\n        candidates.put(ufrag, candidate);\n        component.addLocalCandidate(candidate);\n\n        return new ArrayList<LocalCandidate>(Arrays.asList(candidate));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isHostHarvester()\n    {\n        return true;\n    }\n\n    /**\n     * Implements a <tt>Candidate</tt> for the purposes of this\n     * <tt>SinglePortUdpHarvester</tt>.\n     */\n    private class MyCandidate\n        extends HostCandidate\n    {\n        /**\n         * The local username fragment associated with this candidate.\n         */\n        private final String ufrag;\n\n        /**\n         * The flag which indicates that this <tt>MyCandidate</tt> has been\n         * freed.\n         */\n        private boolean freed = false;\n\n        /**\n         * The collection of <tt>IceSocketWrapper</tt>s that can potentially\n         * be used by the ice4j user to read/write from/to this candidate.\n         * The keys are the remote addresses for each socket.\n         * <p>\n         * There are wrappers over <tt>MultiplexedDatagramSocket</tt>s over\n         * a corresponding socket in {@link #sockets}.\n         */\n        private final Map<SocketAddress, IceSocketWrapper> candidateSockets\n            = new HashMap<>();\n\n        /**\n         * The collection of <tt>DatagramSocket</tt>s added to this candidate.\n         * The keys are the remote addresses for each socket.\n         * <p>\n         * These are the \"raw\" sockets, before any wrappers are added for\n         * the STUN stack or the user of ice4j.\n         */\n        private final Map<SocketAddress, DatagramSocket> sockets\n            = new HashMap<>();\n\n        /**\n         * Initializes a new <tt>MyCandidate</tt> instance with the given\n         * <tt>Component</tt> and the given local username fragment.\n         *\n         * @param component the <tt>Component</tt> for which this candidate will\n         * serve.\n         * @param ufrag the local ICE username fragment for this candidate (and\n         * its <tt>Component</tt> and <tt>Agent</tt>).\n         */\n        private MyCandidate(Component component, String ufrag)\n        {\n            super(localAddress, component);\n            this.ufrag = ufrag;\n        }\n\n        /**\n         * {@inheritDoc}\n         * <p>\n         * Closes all sockets in use by this <tt>LocalCandidate</tt>.\n         */\n        @Override\n        public void free()\n        {\n            synchronized (this)\n            {\n                if (freed)\n                    return;\n                freed = true;\n            }\n\n            candidates.remove(ufrag);\n\n            synchronized (sockets)\n            {\n                StunStack stunStack = getStunStack();\n\n                for (Map.Entry<SocketAddress, DatagramSocket> e\n                    : sockets.entrySet())\n                {\n                    DatagramSocket socket = e.getValue();\n\n                    if (stunStack != null)\n                    {\n                        TransportAddress localAddress\n                            = new TransportAddress(socket.getLocalAddress(),\n                                                   socket.getLocalPort(),\n                                                   Transport.UDP);\n                        TransportAddress remoteAddress\n                            = new TransportAddress(\n                            (InetSocketAddress) e.getKey(),\n\n                            Transport.UDP);\n\n                        stunStack.removeSocket(localAddress, remoteAddress);\n                    }\n\n                    socket.close();\n                }\n\n                sockets.clear();\n            }\n\n            synchronized (candidateSockets)\n            {\n                for (IceSocketWrapper wrapper : candidateSockets.values())\n                {\n                    wrapper.close();\n                }\n\n                candidateSockets.clear();\n            }\n\n            super.free();\n        }\n\n        /**\n         * Adds a new <tt>Socket</tt> to this candidate, which is associated\n         * with a particular remote address.\n         *\n         * @param socket the socket to add.\n         * @param remoteAddress the remote address for the socket.\n         */\n        private synchronized void addSocket(DatagramSocket socket,\n                                            InetSocketAddress remoteAddress)\n            throws IOException\n        {\n            if (freed)\n            {\n                throw new IOException(\"Candidate freed\");\n            }\n\n            Component component = getParentComponent();\n            if (component == null)\n            {\n                throw new IOException(\"No parent component\");\n            }\n\n            IceProcessingState state\n                = component.getParentStream().getParentAgent().getState();\n            if (state == IceProcessingState.FAILED)\n            {\n                throw new IOException(\n                    \"Cannot add socket to an Agent in state FAILED.\");\n            }\n            else if (state != null && state.isOver()\n                && logger.isLoggable(Level.FINE))\n            {\n                logger.fine(\n                    \"Adding a socket to a completed Agent, state=\" + state);\n            }\n\n            MultiplexingDatagramSocket multiplexing\n                = new MultiplexingDatagramSocket(socket);\n\n            // Socket to add to the candidate\n            IceSocketWrapper candidateSocket\n                = new IceUdpSocketWrapper(multiplexing);\n\n            // STUN-only filtered socket to add to the StunStack\n            IceSocketWrapper stunSocket\n                = new IceUdpSocketWrapper(\n                multiplexing.getSocket(new StunDatagramPacketFilter()));\n\n            component.getParentStream().getParentAgent().getStunStack()\n                .addSocket(\n                    stunSocket,\n                    new TransportAddress(remoteAddress, Transport.UDP));\n\n            MergingDatagramSocket componentSocket\n                = component.getComponentSocket();\n            if (componentSocket != null)\n            {\n                componentSocket.add(multiplexing);\n            }\n\n            synchronized (candidateSockets)\n            {\n                IceSocketWrapper oldSocket\n                    = candidateSockets.put(remoteAddress, candidateSocket);\n                if (oldSocket != null)\n                {\n                    logger.warning(\"Replacing the socket for remote address \"\n                                       + remoteAddress);\n                    oldSocket.close();\n                }\n            }\n\n            // XXX is this necessary?\n            synchronized (sockets)\n            {\n                sockets.put(remoteAddress, socket);\n            }\n        }\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        protected IceSocketWrapper getCandidateIceSocketWrapper(\n            SocketAddress remoteAddress)\n        {\n            synchronized (candidateSockets)\n            {\n                return candidateSockets.get(remoteAddress);\n            }\n        }\n    }\n}", "super_interfaces": ["CandidateHarvester"], "fields": [{"attribute_expression": "private static final Logger logger\n            = Logger.getLogger(SinglePortUdpHarvester.class.getName());", "docstring": "\nOur class logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n            = Logger.getLogger(SinglePortUdpHarvester.class.getName())", "syntax_pass": true}, {"attribute_expression": "private final Map<String, MyCandidate> candidates\n            = new ConcurrentHashMap<>();", "docstring": "\nThe map which keeps all currently active <tt>Candidate</tt>s created by\nthis harvester. The keys are the local username fragments (ufrags) of\nthe components for which the candidates are harvested.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, MyCandidate>", "name": "candidates\n            = new ConcurrentHashMap<>()", "syntax_pass": true}, {"attribute_expression": "private HarvestStatistics harvestStatistics = new HarvestStatistics();", "docstring": "\nManages statistics about harvesting time.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HarvestStatistics", "name": "harvestStatistics = new HarvestStatistics()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester", "name": "HostCandidateHarvester", "file_path": "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java", "superclasses": "", "methods": ["[List<InetAddress>]getAllAllowedAddresses()", "[void]harvest(Component,int,int,int,Transport)", "[boolean]isInterfaceAllowed(NetworkInterface)", "[List<NetworkInterface>]getAllowedInterfaces()", "[boolean]isAddressAllowed(InetAddress)", "[IceSocketWrapper]createServerSocket(InetAddress,int,int,int,Component)", "[IceSocketWrapper]createDatagramSocket(InetAddress,int,int,int)", "[void]createAndRegisterStunSocket(HostCandidate)", "[boolean]checkPorts(int,int,int)", "[HarvestStatistics]getHarvestStatistics()"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[List<InetAddress>]getAllAllowedAddresses()", "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[void]harvest(Component,int,int,int,Transport)", "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[boolean]isInterfaceAllowed(NetworkInterface)", "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[List<NetworkInterface>]getAllowedInterfaces()", "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[boolean]isAddressAllowed(InetAddress)", "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[IceSocketWrapper]createServerSocket(InetAddress,int,int,int,Component)", "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[IceSocketWrapper]createDatagramSocket(InetAddress,int,int,int)", "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[void]createAndRegisterStunSocket(HostCandidate)", "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[boolean]checkPorts(int,int,int)", "src/main/java/org/ice4j/ice/harvest/HostCandidateHarvester.java.HostCandidateHarvester.[HarvestStatistics]getHarvestStatistics()"], "overrides": null, "attributes": [], "class_docstring": "\nA <tt>HostCandidateHarvester</tt> gathers host <tt>Candidate</tt>s for a\nspecified {@link org.ice4j.ice.Component}. Most <tt>CandidateHarvester</tt>s\nwould rely on the output of the host harvester, that is all host addresses,\nto be already present and bound in a <tt>Component</tt> before being able to\nharvest the type of addresses that they are responsible for.\n\n@author Emil Ivov\n@author George Politis\n@author Boris Grozev\n", "original_string": "public class HostCandidateHarvester\n{\n    /**\n     * Our class logger.\n     */\n    private static final Logger logger\n        = Logger.getLogger(HostCandidateHarvester.class.getName());\n\n    /**\n     * Manages statistics about harvesting time.\n     */\n    private HarvestStatistics harvestStatistics = new HarvestStatistics();\n\n    /**\n     * @return the list of all local IP addresses from all allowed network\n     * interfaces, which are allowed addresses.\n     */\n    public static List<InetAddress> getAllAllowedAddresses()\n    {\n        List<InetAddress> addresses = new LinkedList<>();\n        for (NetworkInterface iface : getAllowedInterfaces())\n        {\n            Enumeration<InetAddress> ifaceAddresses = iface.getInetAddresses();\n            while (ifaceAddresses.hasMoreElements())\n            {\n                InetAddress address = ifaceAddresses.nextElement();\n                if (isAddressAllowed(address))\n                {\n                    addresses.add(address);\n                }\n            }\n        }\n\n        return addresses;\n    }\n\n    /**\n     * Gathers all candidate addresses on the local machine, binds sockets on\n     * them and creates {@link HostCandidate}s. The harvester would always\n     * try to bind the sockets on the specified <tt>preferredPort</tt> first.\n     * If that fails we will move through all ports between <tt>minPort</tt> and\n     * <tt>maxPort</tt> and give up if still can't find a free port.\n     *\n     * If 0, 0, 0 are specified for preferred, min and max port, an ephemeral port will be used instead.\n     *\n     * @param component the {@link Component} that we'd like to gather candidate\n     * addresses for.\n     * @param preferredPort the port number that should be tried first when\n     * binding local <tt>Candidate</tt> sockets for this <tt>Component</tt>.\n     * @param minPort the port number where we should first try to bind before\n     * moving to the next one (i.e. <tt>minPort + 1</tt>)\n     * @param maxPort the maximum port number where we should try binding\n     * before giving up and throwing an exception.\n     * @param transport transport protocol used\n     *\n     * @throws IllegalArgumentException if either <tt>minPort</tt> or\n     * <tt>maxPort</tt> is not a valid port number, <tt>minPort &gt;\n     * maxPort</tt> or if transport is not supported.\n     * @throws IOException if an error occurs while the underlying resolver lib\n     * is using sockets.\n     */\n    public void harvest(Component component,\n                        int       preferredPort,\n                        int       minPort,\n                        int       maxPort,\n                        Transport transport)\n        throws IllegalArgumentException,\n               IOException\n    {\n        harvestStatistics.startHarvestTiming();\n\n        if (transport != Transport.UDP && transport != Transport.TCP)\n        {\n            throw new IllegalArgumentException(\"Transport protocol not supported: \" + transport);\n        }\n\n        boolean boundAtLeastOneSocket = false;\n        boolean foundAtLeastOneUsableInterface = false;\n        boolean foundAtLeastOneUsableAddress = false;\n        for (NetworkInterface iface: getAllowedInterfaces())\n        {\n            foundAtLeastOneUsableInterface = true;\n\n            Enumeration<InetAddress> addresses = iface.getInetAddresses();\n\n            while (addresses.hasMoreElements())\n            {\n                InetAddress addr = addresses.nextElement();\n\n                if (!isAddressAllowed(addr))\n                {\n                    continue;\n                }\n\n                foundAtLeastOneUsableAddress = true;\n\n                IceSocketWrapper sock = null;\n                try\n                {\n                    if (transport == Transport.UDP)\n                    {\n                        sock = createDatagramSocket(addr, preferredPort, minPort, maxPort);\n                        boundAtLeastOneSocket = true;\n                    }\n                    else if (transport == Transport.TCP)\n                    {\n                        if (addr instanceof Inet6Address)\n                        {\n                            continue;\n                        }\n                        sock = createServerSocket(\n                                addr,\n                                preferredPort,\n                                minPort,\n                                maxPort,\n                                component);\n                        boundAtLeastOneSocket = true;\n                    }\n                }\n                catch (IOException exc)\n                {\n                    // There seems to be a problem with this particular\n                    // address let's just move on for now and hope we will\n                    // find better\n                    if (logger.isLoggable(Level.WARNING))\n                    {\n                        logger.warning(\n                                \"Failed to create a socket for:\"\n                                        + \"\\naddr:\" + addr\n                                        + \"\\npreferredPort:\" + preferredPort\n                                        + \"\\nminPort:\" + minPort\n                                        + \"\\nmaxPort:\" + maxPort\n                                        + \"\\nprotocol:\" + transport\n                                        + \"\\nContinuing with next address\");\n                    }\n                    continue;\n                }\n\n                HostCandidate candidate = new HostCandidate(sock, component, transport);\n                candidate.setVirtual(iface.isVirtual());\n                component.addLocalCandidate(candidate);\n\n                if (transport == Transport.TCP)\n                {\n                    // have to wait a client connection to add a STUN socket\n                    // to the StunStack\n                    continue;\n                }\n\n                // We are most certainly going to use all local host\n                // candidates for sending and receiving STUN connectivity\n                // checks. In case we have enabled STUN, we are going to use\n                // them as well while harvesting reflexive candidates.\n                createAndRegisterStunSocket(candidate);\n\n                ComponentSocket componentSocket = component.getComponentSocket();\n                if (componentSocket != null)\n                {\n                    componentSocket.add(sock);\n                }\n            }\n        }\n\n        if (!boundAtLeastOneSocket)\n        {\n            throw new IOException(\n                \"Failed to bind even a single host candidate for component:\"\n                            + component\n                            + \" preferredPort=\" + preferredPort\n                            + \" minPort=\" + minPort\n                            + \" maxPort=\" + maxPort\n                            + \" foundAtLeastOneUsableInterface=\"\n                            + foundAtLeastOneUsableInterface\n                            + \" foundAtLeastOneUsableAddress=\"\n                            + foundAtLeastOneUsableAddress);\n        }\n\n        this.harvestStatistics.stopHarvestTiming(component.getLocalCandidateCount());\n    }\n\n    /**\n     * Returns a boolean value indicating whether ice4j should allocate a host candidate for the specified interface.\n     * <p/>\n     * Returns <code>false</code> if the interface is loopback, is not currently up, or is not allowed by the\n     * configuration.\n     *\n     * @param iface The {@link NetworkInterface}.\n     */\n    public static boolean isInterfaceAllowed(NetworkInterface iface)\n    {\n        Objects.requireNonNull(iface);\n        try\n        {\n            if (iface.isLoopback() || !iface.isUp())\n            {\n                return false;\n            }\n        }\n        catch (SocketException se)\n        {\n            logger.warning(\"Failed to check state of interface: \" + se);\n            return false;\n        }\n\n        // gp: use getDisplayName() on Windows and getName() on Linux. Also\n        // see NetworkAddressManagementServiceImpl in Jitsi.\n        String ifName = (System.getProperty(\"os.name\") == null\n                || System.getProperty(\"os.name\").startsWith(\"Windows\"))\n                ? iface.getDisplayName()\n                : iface.getName();\n\n        if (!config.getAllowedInterfaces().isEmpty())\n        {\n            // If an allowlist is configured, just check against it.\n            return config.getAllowedInterfaces().contains(ifName);\n        }\n        else\n        {\n            // Otherwise, check against the blocked list.\n            return !config.getBlockedInterfaces().contains(ifName);\n        }\n    }\n\n    /**\n     * Get the list of network interfaces suitable for host candidate harvesting, that is they are up, non-loopback\n     * and are allowed by configuration.\n     */\n    public static List<NetworkInterface> getAllowedInterfaces()\n    {\n        try\n        {\n            return NetworkInterface.networkInterfaces()\n                    .filter(HostCandidateHarvester::isInterfaceAllowed).collect(Collectors.toList());\n        }\n        catch (IOException ioe)\n        {\n            logger.warning(\"Failed to get network interfaces: \" + ioe.getMessage());\n            return Collections.emptyList();\n        }\n    }\n\n    /**\n     * Returns <tt>true</tt> if <tt>address</tt> is allowed to be used for the purposes of candidate allocation, and\n     * <tt>false</tt> otherwise.\n     * <p/>\n     * An address is considered allowed, if:\n     * 1. It is not a loopback address.\n     * 2. Link-local addresses are allowed or the address is not link-local.\n     * 3. IPv6 addresses are allowed or the address is not IPv6\n     * 4. It is allowed by configuration, that is, it either:\n     *      -- Is present in the allowlist\n     *      -- No allowlist is configured and it isn't present in the block list.\n     *\n     * @param address the address to check\n     * @return <tt>true</tt> if <tt>address</tt> is allowed to be used by this <tt>HostCandidateHarvester</tt>.\n     */\n    static boolean isAddressAllowed(InetAddress address)\n    {\n        if (address.isLoopbackAddress())\n        {\n            return false;\n        }\n        if (!config.useLinkLocalAddresses() && address.isLinkLocalAddress())\n        {\n            return false;\n        }\n        if (!config.useIpv6() && address instanceof Inet6Address)\n        {\n            return false;\n        }\n\n        if (!config.getAllowedAddresses().isEmpty())\n        {\n            return config.getAllowedAddresses().contains(address);\n        }\n        return !config.getBlockedAddresses().contains(address);\n    }\n\n    /**\n     * Creates a <tt>ServerSocket</tt> and binds it to the specified\n     * <tt>localAddress</tt> and a port in the range specified by the\n     * <tt>minPort</tt> and <tt>maxPort</tt> parameters.\n     *\n     * If 0, 0, 0 are specified for preferred, min and max port, an ephemeral port will be used instead.\n     *\n     * @param laddr the address that we'd like to bind the socket on.\n     * @param preferredPort the port number that we should try to bind to first.\n     * @param minPort the port number where we should first try to bind before\n     * moving to the next one (i.e. <tt>minPort + 1</tt>)\n     * @param maxPort the maximum port number where we should try binding\n     * before giving up and throwing an exception.\n     *\n     * @return the newly created <tt>DatagramSocket</tt>.\n     *\n     * @throws IllegalArgumentException if either <tt>minPort</tt> or\n     * <tt>maxPort</tt> is not a valid port number or if <tt>minPort &gt;\n     * maxPort</tt>.\n     * @throws IOException if an error occurs while the underlying resolver lib\n     * is using sockets.\n     * @throws BindException if we couldn't find a free port between\n     * <tt>minPort</tt> and <tt>maxPort</tt> before reaching the maximum allowed\n     * number of retries.\n     */\n    private IceSocketWrapper createServerSocket(InetAddress laddr,\n        int preferredPort, int minPort, int maxPort,\n        Component component)\n        throws IllegalArgumentException,\n               IOException,\n               BindException\n    {\n        // make sure port numbers are valid\n        boolean ephemeral = checkPorts(preferredPort, minPort, maxPort);\n        if (ephemeral)\n        {\n            ServerSocket socket = new ServerSocket();\n            socket.setReuseAddress(true);\n            socket.bind(new InetSocketAddress(laddr, 0));\n            if (logger.isLoggable(Level.FINEST))\n            {\n                logger.finest(\"Bound using an ephemeral port to \" + socket.getLocalSocketAddress());\n            }\n            return new IceTcpServerSocketWrapper(new DelegatingServerSocket(socket), component);\n        }\n\n        int bindRetries = StackProperties.getInt(\n                        StackProperties.BIND_RETRIES,\n                        StackProperties.BIND_RETRIES_DEFAULT_VALUE);\n\n        int port = preferredPort;\n        for (int i = 0; i < bindRetries; i++)\n        {\n            try\n            {\n                ServerSocket sock = new ServerSocket();\n                sock.setReuseAddress(true);\n                sock.bind(new InetSocketAddress(laddr, port));\n                IceSocketWrapper socket\n                    = new IceTcpServerSocketWrapper(\n                            new DelegatingServerSocket(sock),\n                            component);\n\n                if (logger.isLoggable(Level.FINEST))\n                {\n                    logger.log(\n                            Level.FINEST,\n                            \"just bound to: \" + sock.getLocalSocketAddress());\n                }\n                return socket;\n            }\n            catch (SocketException se)\n            {\n                logger.log(\n                        Level.INFO,\n                        \"Retrying a bind because of a failure to bind to\"\n                            + \" address \" + laddr\n                            + \" and port \" + port\n                            + \" (\" + se.getMessage() +\")\");\n                logger.log(Level.INFO, \"\", se);\n            }\n\n            port ++;\n\n            if (port > maxPort)\n                port = minPort;\n        }\n\n        throw new BindException(\"Could not bind to any port between \" + minPort + \" and \" + (port - 1));\n    }\n\n    /**\n     * Creates a <tt>DatagramSocket</tt> and binds it to the specified\n     * <tt>localAddress</tt> and a port in the range specified by the\n     * <tt>minPort</tt> and <tt>maxPort</tt> parameters. We first try to bind\n     * the newly created socket on the <tt>preferredPort</tt> port number\n     * (unless it is outside the <tt>[minPort, maxPort]</tt> range in which case\n     * we first try the <tt>minPort</tt>) and then proceed incrementally upwards\n     * until we succeed or reach the bind retries limit. If we reach the\n     * <tt>maxPort</tt> port number before the bind retries limit, we will then\n     * start over again at <tt>minPort</tt> and keep going until we run out of\n     * retries.\n     *\n     * If 0, 0, 0 are specified for preferred, min and max port, an ephemeral port will be used instead.\n     *\n     * @param laddr the address that we'd like to bind the socket on.\n     * @param preferredPort the port number that we should try to bind to first.\n     * @param minPort the port number where we should first try to bind before\n     * moving to the next one (i.e. <tt>minPort + 1</tt>)\n     * @param maxPort the maximum port number where we should try binding\n     * before giving up and throwing an exception.\n     *\n     * @return the newly created <tt>DatagramSocket</tt>.\n     *\n     * @throws IllegalArgumentException if either <tt>minPort</tt> or\n     * <tt>maxPort</tt> is not a valid port number or if <tt>minPort &gt;\n     * maxPort</tt>.\n     * @throws IOException if an error occurs while the underlying resolver lib\n     * is using sockets.\n     * @throws BindException if we couldn't find a free port between\n     * <tt>minPort</tt> and <tt>maxPort</tt> before reaching the maximum allowed\n     * number of retries.\n     */\n    private IceSocketWrapper createDatagramSocket(InetAddress laddr,\n                                                int preferredPort,\n                                                int minPort,\n                                                int maxPort)\n        throws IllegalArgumentException,\n               IOException,\n               BindException\n    {\n        // make sure port numbers are valid.\n        boolean ephemeral = checkPorts(preferredPort, minPort, maxPort);\n        if (ephemeral)\n        {\n            DatagramSocket socket = new MultiplexingDatagramSocket(0, laddr);\n            if (logger.isLoggable(Level.FINEST))\n            {\n                logger.finest(\"Bound using ephemeral port to \" + socket.getLocalSocketAddress());\n            }\n            return new IceUdpSocketWrapper(socket);\n        }\n\n        int bindRetries = StackProperties.getInt(\n                        StackProperties.BIND_RETRIES,\n                        StackProperties.BIND_RETRIES_DEFAULT_VALUE);\n\n        int port = preferredPort;\n        for (int i = 0; i < bindRetries; i++)\n        {\n            try\n            {\n                IceSocketWrapper sock\n                                = new IceUdpSocketWrapper(new\n                                    MultiplexingDatagramSocket(port, laddr));\n\n                if (logger.isLoggable(Level.FINEST))\n                {\n                    logger.log(\n                            Level.FINEST,\n                            \"just bound to: \" + sock.getLocalSocketAddress());\n                }\n                return sock;\n            }\n            catch (SocketException se)\n            {\n                logger.log(\n                        Level.INFO,\n                        \"Retrying a bind because of a failure to bind to\"\n                            + \" address \" + laddr\n                            + \" and port \" + port\n                            + \" (\" + se.getMessage() +\")\");\n                logger.log(Level.FINEST, \"\", se);\n            }\n\n            port ++;\n\n            if (port > maxPort)\n                port = minPort;\n        }\n\n        throw new BindException(\"Could not bind to any port between \"\n                        + minPort + \" and \" + (port - 1));\n    }\n\n    /**\n     * Since we are most certainly going to use all local host candidates for\n     * sending and receiving STUN connectivity checks, and possibly for STUN\n     * harvesting too, we might as well create their STUN sockets here and\n     * register them with the StunStack. This allows us to avoid conflicts\n     * between the STUN harvester and the connectivity checks later on.\n     *\n     * @param candidate the candidate whose stun socket we'd like to initialize\n     * and register with the StunStack.\n     */\n    private void createAndRegisterStunSocket(HostCandidate candidate)\n    {\n        IceSocketWrapper stunSocket = candidate.getStunSocket(null);\n\n        candidate.getStunStack().addSocket(stunSocket);\n    }\n\n    /**\n     * Checks if the different ports are correctly set. If not, throws {@link IllegalArgumentException}. The\n     * special values 0, 0, 0 for the parameters are interpreted as \"use an ephemeral port\".\n     *\n     * @return {@code true} if the params specify that an ephemeral port should be used, and {@code false} otherwise.\n     *\n     * @param preferredPort the port number that we should try to bind to first.\n     * @param minPort the port number where we should first try to bind before\n     * moving to the next one (i.e. <tt>minPort + 1</tt>)\n     * @param maxPort the maximum port number where we should try binding\n     * before giving up and throwing an exception.\n     *\n     * @throws IllegalArgumentException if either <tt>minPort</tt> or\n     * <tt>maxPort</tt> is not a valid port number or if <tt>minPort</tt> is\n     * greater than <tt>maxPort</tt>.\n     */\n    private static boolean checkPorts(int preferredPort, int minPort, int maxPort)\n        throws IllegalArgumentException\n    {\n        if (preferredPort == 0 && minPort == 0 && maxPort == 0)\n        {\n            return true;\n        }\n\n        // make sure port numbers are valid\n        if (!NetworkUtils.isValidPortNumber(minPort)\n                        || !NetworkUtils.isValidPortNumber(maxPort))\n        {\n            throw new IllegalArgumentException(\"minPort (\" + minPort\n                            + \") and maxPort (\" + maxPort + \") \"\n                            + \"should be integers between 1024 and 65535.\");\n        }\n\n        // make sure minPort comes before maxPort.\n        if (minPort > maxPort)\n        {\n            throw new IllegalArgumentException(\"minPort (\" + minPort\n                            + \") should be less than or \"\n                            + \"equal to maxPort (\" + maxPort + \")\");\n        }\n\n        // if preferredPort is not  in the allowed range, place it at min.\n        if (minPort > preferredPort || preferredPort > maxPort)\n        {\n            throw new IllegalArgumentException(\"preferredPort (\"+preferredPort\n                            +\") must be between minPort (\" + minPort\n                            + \") and maxPort (\" + maxPort + \")\");\n        }\n\n        return false;\n    }\n\n    /**\n     * Returns the statistics describing how well the various harvests of this\n     * harvester went.\n     *\n     * @return The {@link HarvestStatistics} describing this harvester's\n     * harvests.\n     */\n    public HarvestStatistics getHarvestStatistics()\n    {\n        return harvestStatistics;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(HostCandidateHarvester.class.getName());", "docstring": "\nOur class logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(HostCandidateHarvester.class.getName())", "syntax_pass": true}, {"attribute_expression": "private HarvestStatistics harvestStatistics = new HarvestStatistics();", "docstring": "\nManages statistics about harvesting time.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HarvestStatistics", "name": "harvestStatistics = new HarvestStatistics()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest", "name": "TurnCandidateHarvest", "file_path": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java", "superclasses": "StunCandidateHarvest", "methods": ["[]TurnCandidateHarvest(TurnCandidateHarvester,HostCandidate)", "[void]close(RelayedCandidateDatagramSocket)", "[boolean]completedResolvingCandidate(Request,Response)", "[void]createCandidates(Response)", "[Message]createKeepAliveMessage(LocalCandidate)", "[void]createRelayedCandidate(Response)", "[RelayedCandidate]createRelayedCandidate(TransportAddress,TransportAddress)", "[Request]createRequestToRetry(Request)", "[Request]createRequestToStartResolvingCandidate()", "[boolean]processErrorOrFailure(Response,Request,TransactionID)", "[void]processSuccess(Response,Request,TransactionID)", "[byte[]]sendRequest(RelayedCandidateDatagramSocket,Request)"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[]TurnCandidateHarvest(TurnCandidateHarvester,HostCandidate)", "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[void]close(RelayedCandidateDatagramSocket)", "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[boolean]completedResolvingCandidate(Request,Response)", "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[void]createCandidates(Response)", "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[Message]createKeepAliveMessage(LocalCandidate)", "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[void]createRelayedCandidate(Response)", "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[RelayedCandidate]createRelayedCandidate(TransportAddress,TransportAddress)", "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[Request]createRequestToRetry(Request)", "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[Request]createRequestToStartResolvingCandidate()", "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[boolean]processErrorOrFailure(Response,Request,TransactionID)", "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[void]processSuccess(Response,Request,TransactionID)", "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvest.java.TurnCandidateHarvest.[byte[]]sendRequest(RelayedCandidateDatagramSocket,Request)"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents the harvesting of TURN <tt>Candidates</tt> for a specific\n<tt>HostCandidate</tt> performed by a specific\n<tt>TurnCandidateHarvester</tt>.\n\n@author Lyubomir Marinov\n", "original_string": "public class TurnCandidateHarvest\n    extends StunCandidateHarvest\n{\n\n    /**\n     * The <tt>Logger</tt> used by the <tt>TurnCandidateHarvest</tt> class and\n     * its instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(TurnCandidateHarvest.class.getName());\n\n    /**\n     * The <tt>Request</tt> created by the last call to\n     * {@link #createRequestToStartResolvingCandidate()}.\n     */\n    private Request requestToStartResolvingCandidate;\n\n    /**\n     * Initializes a new <tt>TurnCandidateHarvest</tt> which is to represent the\n     * harvesting of TURN <tt>Candidate</tt>s for a specific\n     * <tt>HostCandidate</tt> performed by a specific\n     * <tt>TurnCandidateHarvester</tt>.\n     *\n     * @param harvester the <tt>TurnCandidateHarvester</tt> which is performing\n     * the TURN harvesting\n     * @param hostCandidate the <tt>HostCandidate</tt> for which TURN\n     * <tt>Candidate</tt>s are to be harvested\n     */\n    public TurnCandidateHarvest(\n            TurnCandidateHarvester harvester,\n            HostCandidate hostCandidate)\n    {\n        super(harvester, hostCandidate);\n    }\n\n    /**\n     * Notifies this <tt>TurnCandidateHarvest</tt> that a specific\n     * <tt>RelayedCandidateDatagramSocket</tt> is closing and that this instance\n     * is to delete the associated TURN Allocation.\n     * <p>\n     * <b>Note</b>: The method is part of the internal API of\n     * <tt>RelayedCandidateDatagramSocket</tt> and <tt>TurnCandidateHarvest</tt>\n     * and is not intended for public use.\n     * </p>\n     *\n     * @param relayedCandidateSocket the <tt>RelayedCandidateDatagramSocket</tt>\n     * which notifies this instance and which requests that the associated TURN\n     * Allocation be deleted\n     */\n    public void close(RelayedCandidateDatagramSocket relayedCandidateSocket)\n    {\n        /*\n         * FIXME As far as logic goes, it seems that it is possible to send a\n         * TURN Refresh, cancel the STUN keep-alive functionality here and only\n         * then receive the response to the TURN Refresh which will enable the\n         * STUN keep-alive functionality again.\n         */\n        setSendKeepAliveMessageInterval(\n                SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED);\n\n        /*\n         * TURN Refresh with a LIFETIME value equal to zero deletes the TURN\n         * Allocation.\n         */\n        try\n        {\n            sendRequest(MessageFactory.createRefreshRequest(0), false, null);\n        }\n        catch (StunException sex)\n        {\n            logger.log(\n                    Level.INFO,\n                    \"Failed to send TURN Refresh request to delete Allocation\",\n                    sex);\n        }\n    }\n\n    /**\n     * Completes the harvesting of <tt>Candidate</tt>s for\n     * {@link #hostCandidate}. Notifies {@link #harvester} about the completion\n     * of the harvesting of <tt>Candidate</tt> for <tt>hostCandidate</tt>\n     * performed by this <tt>StunCandidateHarvest</tt>.\n     *\n     * @param request the <tt>Request</tt> sent by this\n     * <tt>StunCandidateHarvest</tt> with which the harvesting of\n     * <tt>Candidate</tt>s for <tt>hostCandidate</tt> has completed\n     * @param response the <tt>Response</tt> received by this\n     * <tt>StunCandidateHarvest</tt>, if any, with which the harvesting of\n     * <tt>Candidate</tt>s for <tt>hostCandidate</tt> has completed\n     * @return <tt>true</tt> if the harvesting of <tt>Candidate</tt>s for\n     * <tt>hostCandidate</tt> performed by this <tt>StunCandidateHarvest</tt>\n     * has completed; otherwise, <tt>false</tt>\n     * @see StunCandidateHarvest#completedResolvingCandidate(Request, Response)\n     */\n    @Override\n    protected boolean completedResolvingCandidate(\n            Request request,\n            Response response)\n    {\n        /*\n         * TODO If the Allocate request is rejected because the server lacks\n         * resources to fulfill it, the agent SHOULD instead send a Binding\n         * request to obtain a server reflexive candidate.\n         */\n        if ((response == null)\n                || (!response.isSuccessResponse()\n                        && (request.getMessageType()\n                                == Message.ALLOCATE_REQUEST)))\n        {\n            try\n            {\n                if (startResolvingCandidate())\n                    return false;\n            }\n            catch (Exception ex)\n            {\n                /*\n                 * Complete the harvesting of Candidates for hostCandidate\n                 * because the new attempt has just failed.\n                 */\n            }\n        }\n        return super.completedResolvingCandidate(request, response);\n    }\n\n    /**\n     * Creates new <tt>Candidate</tt>s determined by a specific STUN\n     * <tt>Response</tt>.\n     *\n     * @param response the received STUN <tt>Response</tt>\n     * @see StunCandidateHarvest#createCandidates(Response)\n     */\n    @Override\n    protected void createCandidates(Response response)\n    {\n        createRelayedCandidate(response);\n\n        // Let the super create the ServerReflexiveCandidate.\n        super.createCandidates(response);\n    }\n\n    /**\n     * Creates a new STUN <tt>Message</tt> to be sent to the STUN server\n     * associated with the <tt>StunCandidateHarvester</tt> of this instance in\n     * order to keep a specific <tt>LocalCandidate</tt> (harvested by this\n     * instance) alive.\n     *\n     * @param candidate the <tt>LocalCandidate</tt> (harvested by this instance)\n     * to create a new keep-alive STUN message for\n     * @return a new keep-alive STUN <tt>Message</tt> for the specified\n     * <tt>candidate</tt> or <tt>null</tt> if no keep-alive sending is to occur\n     * @throws StunException if anything goes wrong while creating the new\n     * keep-alive STUN <tt>Message</tt> for the specified <tt>candidate</tt>\n     * or the candidate is of an unsupported <tt>CandidateType</tt>\n     * @see StunCandidateHarvest#createKeepAliveMessage(LocalCandidate)\n     */\n    @Override\n    protected Message createKeepAliveMessage(LocalCandidate candidate)\n        throws StunException\n    {\n        switch (candidate.getType())\n        {\n        case RELAYED_CANDIDATE:\n            return MessageFactory.createRefreshRequest();\n        case SERVER_REFLEXIVE_CANDIDATE:\n            /*\n             * RFC 5245: The Refresh requests will also refresh the server\n             * reflexive candidate.\n             */\n            boolean existsRelayedCandidate = false;\n\n            for (Candidate<?> aCandidate : getCandidates())\n            {\n                if (CandidateType.RELAYED_CANDIDATE.equals(\n                        aCandidate.getType()))\n                {\n                    existsRelayedCandidate = true;\n                    break;\n                }\n            }\n            return\n                existsRelayedCandidate\n                    ? null\n                    : super.createKeepAliveMessage(candidate);\n        default:\n            return super.createKeepAliveMessage(candidate);\n        }\n    }\n\n    /**\n     * Creates a <tt>RelayedCandidate</tt> using the\n     * <tt>XOR-RELAYED-ADDRESS</tt> attribute in a specific STUN\n     * <tt>Response</tt> for the actual <tt>TransportAddress</tt> of the new\n     * candidate. If the message is malformed and/or does not contain the\n     * corresponding attribute, this method simply has no effect.\n     *\n     * @param response the STUN <tt>Response</tt> which is supposed to contain\n     * the address we should use for the new candidate\n     */\n    private void createRelayedCandidate(Response response)\n    {\n        Attribute attribute\n            = response.getAttribute(Attribute.XOR_RELAYED_ADDRESS);\n\n        if (attribute instanceof XorRelayedAddressAttribute)\n        {\n            TransportAddress relayedAddress\n                = ((XorRelayedAddressAttribute) attribute).getAddress(\n                        response.getTransactionID());\n            RelayedCandidate relayedCandidate\n                = createRelayedCandidate(\n                        relayedAddress,\n                        getMappedAddress(response));\n\n            if (relayedCandidate != null)\n            {\n                /*\n                 * The ICE connectivity checks will utilize STUN on the\n                 * (application-purposed) socket of the RelayedCandidate and\n                 * will not add it to the StunStack so we have to do it.\n                 */\n                harvester.getStunStack().addSocket(\n                        relayedCandidate.getStunSocket(null));\n\n                ComponentSocket componentSocket\n                    = relayedCandidate.getParentComponent().getComponentSocket();\n                if (componentSocket != null)\n                {\n                    componentSocket.add(\n                        relayedCandidate.getCandidateIceSocketWrapper());\n                }\n                addCandidate(relayedCandidate);\n            }\n        }\n    }\n\n    /**\n     * Creates a new <tt>RelayedCandidate</tt> instance which is to represent a\n     * specific <tt>TransportAddress</tt> harvested through\n     * {@link #hostCandidate} and the TURN server associated with\n     * {@link #harvester}.\n     *\n     * @param transportAddress the <tt>TransportAddress</tt> to be represented\n     * by the new <tt>RelayedCandidate</tt> instance\n     * @param mappedAddress the mapped <tt>TransportAddress</tt> reported by the\n     * TURN server with the delivery of the relayed <tt>transportAddress</tt> to\n     * be represented by the new <tt>RelayedCandidate</tt> instance\n     * @return a new <tt>RelayedCandidate</tt> instance which represents the\n     * specified <tt>TransportAddress</tt> harvested through\n     * {@link #hostCandidate} and the TURN server associated with\n     * {@link #harvester}\n     */\n    protected RelayedCandidate createRelayedCandidate(\n            TransportAddress transportAddress,\n            TransportAddress mappedAddress)\n    {\n        return\n            new RelayedCandidate(\n                    transportAddress,\n                    this,\n                    mappedAddress);\n    }\n\n    /**\n     * Creates a new <tt>Request</tt> instance which is to be sent by this\n     * <tt>StunCandidateHarvest</tt> in order to retry a specific\n     * <tt>Request</tt>. For example, the long-term credential mechanism\n     * dictates that a <tt>Request</tt> is first sent by the client without any\n     * credential-related attributes, then it gets challenged by the server and\n     * the client retries the original <tt>Request</tt> with the appropriate\n     * credential-related attributes in response.\n     *\n     * @param request the <tt>Request</tt> which is to be retried by this\n     * <tt>StunCandidateHarvest</tt>\n     * @return the new <tt>Request</tt> instance which is to be sent by this\n     * <tt>StunCandidateHarvest</tt> in order to retry the specified\n     * <tt>request</tt>\n     * @see StunCandidateHarvest#createRequestToRetry(Request)\n     */\n    @Override\n    protected Request createRequestToRetry(Request request)\n    {\n        switch (request.getMessageType())\n        {\n        case Message.ALLOCATE_REQUEST:\n        {\n            RequestedTransportAttribute requestedTransportAttribute\n                = (RequestedTransportAttribute)\n                    request.getAttribute(Attribute.REQUESTED_TRANSPORT);\n            int requestedTransport\n                = (requestedTransportAttribute == null)\n                    ? 17 /* User Datagram Protocol */\n                    : requestedTransportAttribute.getRequestedTransport();\n            EvenPortAttribute evenPortAttribute\n                = (EvenPortAttribute) request.getAttribute(Attribute.EVEN_PORT);\n            boolean rFlag\n                = (evenPortAttribute != null) && evenPortAttribute.isRFlag();\n\n            return\n                MessageFactory.createAllocateRequest(\n                        (byte) requestedTransport,\n                        rFlag);\n        }\n\n        case Message.CHANNELBIND_REQUEST:\n        {\n            ChannelNumberAttribute channelNumberAttribute\n                = (ChannelNumberAttribute)\n                    request.getAttribute(Attribute.CHANNEL_NUMBER);\n            char channelNumber = channelNumberAttribute.getChannelNumber();\n            XorPeerAddressAttribute peerAddressAttribute\n                = (XorPeerAddressAttribute)\n                    request.getAttribute(Attribute.XOR_PEER_ADDRESS);\n            TransportAddress peerAddress\n                = peerAddressAttribute.getAddress(request.getTransactionID());\n            byte[] retryTransactionID\n                = TransactionID.createNewTransactionID().getBytes();\n            Request retryChannelBindRequest\n                = MessageFactory.createChannelBindRequest(\n                        channelNumber,\n                        peerAddress,\n                        retryTransactionID);\n\n            try\n            {\n                retryChannelBindRequest.setTransactionID(retryTransactionID);\n            }\n            catch (StunException sex)\n            {\n                throw new UndeclaredThrowableException(sex);\n            }\n            return retryChannelBindRequest;\n        }\n\n        case Message.CREATEPERMISSION_REQUEST:\n        {\n            XorPeerAddressAttribute peerAddressAttribute\n                = (XorPeerAddressAttribute)\n                    request.getAttribute(Attribute.XOR_PEER_ADDRESS);\n            TransportAddress peerAddress\n                = peerAddressAttribute.getAddress(request.getTransactionID());\n            byte[] retryTransactionID\n                = TransactionID.createNewTransactionID().getBytes();\n            Request retryCreatePermissionRequest\n                = MessageFactory.createCreatePermissionRequest(\n                        peerAddress,\n                        retryTransactionID);\n\n            try\n            {\n                retryCreatePermissionRequest.setTransactionID(\n                        retryTransactionID);\n            }\n            catch (StunException sex)\n            {\n                throw new UndeclaredThrowableException(sex);\n            }\n            return retryCreatePermissionRequest;\n        }\n\n        case Message.REFRESH_REQUEST:\n        {\n            LifetimeAttribute lifetimeAttribute\n                = (LifetimeAttribute) request.getAttribute(Attribute.LIFETIME);\n\n            if (lifetimeAttribute == null)\n                return MessageFactory.createRefreshRequest();\n            else\n            {\n                return\n                    MessageFactory.createRefreshRequest(\n                            lifetimeAttribute.getLifetime());\n            }\n        }\n\n        default:\n            return super.createRequestToRetry(request);\n        }\n    }\n\n    /**\n     * Creates a new <tt>Request</tt> which is to be sent to\n     * {@link TurnCandidateHarvester#stunServer} in order to start resolving\n     * {@link #hostCandidate}.\n     *\n     * @return a new <tt>Request</tt> which is to be sent to\n     * {@link TurnCandidateHarvester#stunServer} in order to start resolving\n     * {@link #hostCandidate}\n     * @see StunCandidateHarvest#createRequestToStartResolvingCandidate()\n     */\n    @Override\n    protected Request createRequestToStartResolvingCandidate()\n    {\n        if (requestToStartResolvingCandidate == null)\n        {\n            requestToStartResolvingCandidate\n                = MessageFactory.createAllocateRequest(\n                        (byte) 17 /* User Datagram Protocol */,\n                        false);\n            return requestToStartResolvingCandidate;\n        }\n        else if (requestToStartResolvingCandidate.getMessageType()\n                == Message.ALLOCATE_REQUEST)\n        {\n            requestToStartResolvingCandidate\n                = super.createRequestToStartResolvingCandidate();\n            return requestToStartResolvingCandidate;\n        }\n        else\n            return null;\n    }\n\n    /**\n     * Notifies this <tt>StunCandidateHarvest</tt> that a specific\n     * <tt>Request</tt> has either received an error <tt>Response</tt> or has\n     * failed to receive any <tt>Response</tt>.\n     *\n     * @param response the error <tt>Response</tt> which has been received for\n     * <tt>request</tt>\n     * @param request the <tt>Request</tt> to which <tt>Response</tt> responds\n     * @param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n     * <tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\n     * it as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\n     * the <tt>applicationData</tt> property value\n     * @return <tt>true</tt> if the error or failure condition has been\n     * processed and this instance can continue its execution (e.g. the\n     * resolution of the candidate) as if it was expected; otherwise,\n     * <tt>false</tt>\n     * @see StunCandidateHarvest#processErrorOrFailure(Response, Request,\n     * TransactionID)\n     */\n    @Override\n    protected boolean processErrorOrFailure(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n    {\n\n        /*\n         * TurnCandidateHarvest uses the applicationData of TransactionID to\n         * deliver the results of Requests sent by\n         * RelayedCandidateDatagramSocket back to it.\n         */\n        Object applicationData = transactionID.getApplicationData();\n\n        if ((applicationData instanceof RelayedCandidateDatagramSocket)\n                && ((RelayedCandidateDatagramSocket) applicationData)\n                        .processErrorOrFailure(response, request))\n            return true;\n\n        return super.processErrorOrFailure(response, request, transactionID);\n    }\n\n    /**\n     * Handles a specific STUN success <tt>Response</tt> to a specific STUN\n     * <tt>Request</tt>.\n     *\n     * @param response the received STUN success <tt>Response</tt> which is to\n     * be handled\n     * @param request the STUN <tt>Request</tt> to which <tt>response</tt>\n     * responds\n     * @param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n     * <tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\n     * it as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\n     * the <tt>applicationData</tt> property value\n     * @see StunCandidateHarvest#processSuccess(Response, Request,\n     * TransactionID)\n     */\n    @Override\n    protected void processSuccess(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n    {\n        super.processSuccess(response, request, transactionID);\n\n        LifetimeAttribute lifetimeAttribute;\n        int lifetime /* minutes */ = -1;\n\n        switch (response.getMessageType())\n        {\n        case Message.ALLOCATE_RESPONSE:\n            // The default lifetime of an allocation is 10 minutes.\n            lifetimeAttribute\n                = (LifetimeAttribute) response.getAttribute(Attribute.LIFETIME);\n            lifetime\n                = (lifetimeAttribute == null)\n                    ? (10 * 60)\n                    : lifetimeAttribute.getLifetime();\n            break;\n        case Message.REFRESH_RESPONSE:\n            lifetimeAttribute\n                = (LifetimeAttribute) response.getAttribute(Attribute.LIFETIME);\n            if (lifetimeAttribute != null)\n                lifetime = lifetimeAttribute.getLifetime();\n            break;\n        }\n        if (lifetime >= 0)\n        {\n            setSendKeepAliveMessageInterval(\n                    /* milliseconds */ 1000L * lifetime);\n        }\n\n        /*\n         * TurnCandidateHarvest uses the applicationData of TransactionID to\n         * deliver the results of Requests sent by\n         * RelayedCandidateDatagramSocket back to it.\n         */\n        Object applicationData = transactionID.getApplicationData();\n\n        if (applicationData instanceof RelayedCandidateDatagramSocket)\n        {\n            ((RelayedCandidateDatagramSocket) applicationData)\n                .processSuccess(response, request);\n        }\n    }\n\n    /**\n     * Sends a specific <tt>Request</tt> on behalf of a specific\n     * <tt>RelayedCandidateDatagramSocket</tt> to the TURN server associated\n     * with this <tt>TurnCandidateHarvest</tt>.\n     *\n     * @param relayedCandidateDatagramSocket the\n     * <tt>RelayedCandidateDatagramSocket</tt> which sends the specified\n     * <tt>Request</tt> and which is to be notified of the result\n     * @param request the <tt>Request</tt> to be sent to the TURN server\n     * associated with this <tt>TurnCandidateHarvest</tt>\n     * @return an array of <tt>byte</tt>s which represents the ID of the\n     * transaction with which the specified <tt>Request</tt> has been sent to\n     * the TURN server\n     * @throws StunException if anything goes wrong while sending the specified\n     * <tt>Request</tt>\n     */\n    public byte[] sendRequest(\n            RelayedCandidateDatagramSocket relayedCandidateDatagramSocket,\n            Request request)\n        throws StunException\n    {\n        TransactionID transactionID = TransactionID.createNewTransactionID();\n\n        transactionID.setApplicationData(relayedCandidateDatagramSocket);\n        transactionID = sendRequest(request, false, transactionID);\n        return (transactionID == null) ? null : transactionID.getBytes();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(TurnCandidateHarvest.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>TurnCandidateHarvest</tt> class and\nits instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(TurnCandidateHarvest.class.getName())", "syntax_pass": true}, {"attribute_expression": "private Request requestToStartResolvingCandidate;", "docstring": "\nThe <tt>Request</tt> created by the last call to\n{@link #createRequestToStartResolvingCandidate()}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Request", "name": "requestToStartResolvingCandidate", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester", "name": "GoogleTurnSSLCandidateHarvester", "file_path": "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java", "superclasses": "GoogleTurnCandidateHarvester", "methods": ["[]GoogleTurnSSLCandidateHarvester(TransportAddress)", "[]GoogleTurnSSLCandidateHarvester(TransportAddress,String,String)", "[GoogleTurnCandidateHarvest]createHarvest(HostCandidate)", "[HostCandidate]getHostCandidate(HostCandidate)", "[boolean]sslHandshake(InputStream,OutputStream)"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester.[]GoogleTurnSSLCandidateHarvester(TransportAddress)", "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester.[]GoogleTurnSSLCandidateHarvester(TransportAddress,String,String)", "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester.[GoogleTurnCandidateHarvest]createHarvest(HostCandidate)", "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester.[HostCandidate]getHostCandidate(HostCandidate)", "src/main/java/org/ice4j/ice/harvest/GoogleTurnSSLCandidateHarvester.java.GoogleTurnSSLCandidateHarvester.[boolean]sslHandshake(InputStream,OutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a <tt>CandidateHarvester</tt> which gathers Google TURN SSLTCP\ndialect <tt>Candidate</tt>s for a specified {@link Component}.\n\nThis dialect exchanges a SSL v2.0 client-hello answered by a TLS v1.0\nserver-hello, before TURN data is exchanged. The data is SSL-spec compliant,\nbut use hard-coded values for data that typically aught to be generated\n(for example: challenge, session-id and random fields).\n\n@author Sebastien Vincent\n", "original_string": "public class GoogleTurnSSLCandidateHarvester\n    extends GoogleTurnCandidateHarvester\n{\n    /**\n     * Data for the SSL message sent by the server ('server-hello').\n     */\n    static final byte SSL_SERVER_HANDSHAKE[] =\n    {\n        // Content type: Handshake\n        0x16,\n\n        // Version: TLS 1.0\n        0x03, 0x01,\n\n        // Length: 74\n        0x00, 0x4a,\n\n        // Handshake Layer starts here\n\n        // Handshake type: Server Hello\n        0x02,\n\n        // Length: 70\n        0x00, 0x00, 0x46,\n\n        // Version: TLS 1.0\n        0x03, 0x01,\n\n        // 32 bytes random (well, obviously hardcoded here)\n        0x42, (byte)0x85, 0x45, (byte)0xa7, 0x27, (byte)0xa9,\n        0x5d, (byte)0xa0, (byte)0xb3, (byte)0xc5, (byte)0xe7,\n        0x53, (byte)0xda, 0x48, 0x2b, 0x3f, (byte)0xc6, 0x5a,\n        (byte)0xca, (byte)0x89, (byte)0xc1, 0x58, 0x52,\n        (byte)0xa1, 0x78, 0x3c, 0x5b, 0x17, 0x46, 0x00,\n        (byte)0x85, 0x3f,\n\n        // Session-ID length: 32\n        0x20,\n\n        // Session-ID\n        0x0e, (byte)0xd3, 0x06, 0x72, 0x5b, 0x5b, 0x1b, 0x5f,\n        0x15, (byte)0xac, 0x13, (byte)0xf9, (byte)0x88, 0x53,\n        (byte)0x9d, (byte)0x9b, (byte)0xe8, 0x3d, 0x7b, 0x0c,\n        0x30, 0x32, 0x6e, 0x38, 0x4d, (byte)0xa2, 0x75, 0x57,\n        0x41, 0x6c, 0x34, 0x5c,\n\n        // Selected Cipher suite\n        0x00, 0x04, // TLS_RSA_WITH_RC4_128_MD5\n\n        // Compression method: null\n        0x00\n    };\n\n    /**\n     * Data for the SSL message sent by the client (client-hello).\n     */\n    public static final byte SSL_CLIENT_HANDSHAKE[] =\n    {\n        // Version: SSL 2.0 (0x0002) and length: 70\n        (byte)0x80, 0x46,\n\n        // Handshake message type: Client Hello\n        0x01,\n\n        // Version TLS 1.0\n        0x03, 0x01,\n\n        // Cipher Spec Length: 45\n        0x00, 0x2d,\n\n        // Session ID: 0\n        0x00, 0x00,\n\n        // Challenge length: 16\n        0x00, 0x10,\n\n        // Cipher spec (15 cyphers)\n        0x01, 0x00, (byte)0x80,       // SSL2_RC4_128_WITH_MD5\n        0x03, 0x00, (byte)0x80,       // SSL2_rc2_128_CBC_WITH_MD5\n        0x07, 0x00, (byte)0xc0,       // SSL2_DES_192_EDE3_CBC_WITH_MD5\n        0x06, 0x00, 0x40,             // SSL2_DES_64_CBC_WITH_MD5\n        0x02, 0x00, (byte)0x80,       // SSL2_RC4_128_EXPORT40_WITH_MD5\n        0x04, 0x00, (byte)0x80,       // SSL2_RC2_128_CBC_EXPORT40_WITH_MD5\n        0x00, 0x00, 0x04,             // TLS_RSA_WITH_RC4_128_MD5\n        0x00, (byte)0xfe, (byte)0xff, // SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA\n        0x00, 0x00, 0x0a,             // TLS_RSA_WITH_3DES_EDE_CBC_SHA\n        0x00, (byte)0xfe, (byte)0xfe, // SSL_RSA_FIPS_WITH_DES_CBC_SHA\n        0x00, 0x00, 0x09,             // TLS_RSA_WITH_DES_CBC_SHA\n        0x00, 0x00, 0x64,             // TLS_RSA_EXPORT1024_WITH_RC4_56_SHA\n        0x00, 0x00, 0x62,             // TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA\n        0x00, 0x00, 0x03,             // TLS_RSA_EXPORT_WITH_RC4_40_MD5\n        0x00, 0x00, 0x06,             // TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5\n\n        // Challenge\n        0x1f, 0x17, 0x0c, (byte)0xa6, 0x2f, 0x00, 0x78, (byte)0xfc, 0x46,\n        0x55, 0x2e, (byte)0xb1, (byte)0x83, 0x39, (byte)0xf1, (byte)0xea\n    };\n\n    /**\n     * Initializes a new <tt>GoogleTurnSSLCandidateHarvester</tt> instance which\n     * is to work with a specific Google TURN server.\n     *\n     * @param turnServer the <tt>TransportAddress</tt> of the TURN server the\n     * new instance is to work with\n     */\n    public GoogleTurnSSLCandidateHarvester(TransportAddress turnServer)\n    {\n        this(turnServer, null, null);\n    }\n\n    /**\n     * Initializes a new <tt>GoogleTurnSSLCandidateHarvester</tt> instance which is\n     * to work with a specific TURN server using a specific username for the\n     * purposes of the STUN short-term credential mechanism.\n     *\n     * @param turnServer the <tt>TransportAddress</tt> of the TURN server the\n     * new instance is to work with\n     * @param shortTermCredentialUsername the username to be used by the new\n     * instance for the purposes of the STUN short-term credential mechanism or\n     * <tt>null</tt> if the use of the STUN short-term credential mechanism is\n     * not determined at the time of the construction of the new instance\n     * @param password The gingle candidates password necessary to use this TURN\n     * server.\n     */\n    public GoogleTurnSSLCandidateHarvester(TransportAddress turnServer,\n            String shortTermCredentialUsername,\n            String password)\n    {\n        super(turnServer, shortTermCredentialUsername, password);\n    }\n\n    /**\n     * Creates a new <tt>GoogleTurnSSLCandidateHarvest</tt> instance which is to\n     * perform TURN harvesting of a specific <tt>HostCandidate</tt>.\n     *\n     * @param hostCandidate the <tt>HostCandidate</tt> for which harvesting is\n     * to be performed by the new <tt>TurnCandidateHarvest</tt> instance\n     * @return a new <tt>GoogleTurnSSLCandidateHarvest</tt> instance which is to\n     * perform TURN harvesting of the specified <tt>hostCandidate</tt>\n     * @see StunCandidateHarvester#createHarvest(HostCandidate)\n     */\n    @Override\n    protected GoogleTurnCandidateHarvest createHarvest(\n            HostCandidate hostCandidate)\n    {\n        return\n            new GoogleTurnCandidateHarvest(this, hostCandidate, getPassword());\n    }\n\n    /**\n     * Returns the host candidate.\n     * For UDP it simply returns the candidate passed as parameter\n     *\n     * However for TCP, we cannot return the same hostCandidate because in Java\n     * a  \"server\" socket cannot connect to a destination with the same local\n     * address/port (i.e. a Java Socket cannot act as both server/client).\n     *\n     * @param hostCand HostCandidate\n     * @return HostCandidate\n     */\n    @Override\n    protected HostCandidate getHostCandidate(HostCandidate hostCand)\n    {\n        HostCandidate cand = null;\n        Socket sock = null;\n\n        try\n        {\n            sock = new Socket(stunServer.getAddress(), stunServer.getPort());\n\n            OutputStream outputStream = sock.getOutputStream();\n            InputStream inputStream = sock.getInputStream();\n\n            if (sslHandshake(inputStream, outputStream))\n            {\n                Component parentComponent = hostCand.getParentComponent();\n                MultiplexingSocket multiplexing = new MultiplexingSocket(sock);\n\n                cand\n                    = new HostCandidate(\n                            new IceTcpSocketWrapper(multiplexing),\n                            parentComponent,\n                            Transport.TCP);\n                parentComponent\n                    .getParentStream()\n                        .getParentAgent()\n                            .getStunStack()\n                                .addSocket(cand.getStunSocket(null));\n                ComponentSocket componentSocket\n                    = parentComponent.getComponentSocket();\n                if (componentSocket != null)\n                {\n                    componentSocket.add(multiplexing);\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            cand = null;\n        }\n        finally\n        {\n            if ((cand == null) && (sock != null))\n            {\n                try\n                {\n                    sock.close();\n                }\n                catch (IOException ioe)\n                {\n                    /*\n                     * We failed to close sock but that should not be much of a\n                     * problem because we were not closing it in earlier\n                     * revisions.\n                     */\n                }\n            }\n        }\n        return cand;\n    }\n\n    /**\n     * Do the SSL handshake (send client certificate and wait for receive server\n     * certificate). We explicitly need <tt>InputStream</tt> and\n     * <tt>OutputStream</tt> because some <tt>Socket</tt> may redefine\n     * getInputStream()/getOutputStream() and we need the original stream.\n     *\n     * @param inputStream <tt>InputStream</tt> of the socket\n     * @param outputStream <tt>OutputStream</tt> of the socket\n     * @return true if the SSL handshake is done\n     * @throws IOException if something goes wrong\n     */\n    public static boolean sslHandshake(InputStream inputStream, OutputStream\n        outputStream) throws IOException\n    {\n        byte data[] = new byte[SSL_SERVER_HANDSHAKE.length];\n\n        outputStream.write(SSL_CLIENT_HANDSHAKE);\n        inputStream.read(data);\n\n        outputStream = null;\n        inputStream = null;\n\n        if (Arrays.equals(data, SSL_SERVER_HANDSHAKE))\n        {\n            return true;\n        }\n\n        return false;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final byte SSL_SERVER_HANDSHAKE[] =\n    {\n        // Content type: Handshake\n        0x16,\n\n        // Version: TLS 1.0\n        0x03, 0x01,\n\n        // Length: 74\n        0x00, 0x4a,\n\n        // Handshake Layer starts here\n\n        // Handshake type: Server Hello\n        0x02,\n\n        // Length: 70\n        0x00, 0x00, 0x46,\n\n        // Version: TLS 1.0\n        0x03, 0x01,\n\n        // 32 bytes random (well, obviously hardcoded here)\n        0x42, (byte)0x85, 0x45, (byte)0xa7, 0x27, (byte)0xa9,\n        0x5d, (byte)0xa0, (byte)0xb3, (byte)0xc5, (byte)0xe7,\n        0x53, (byte)0xda, 0x48, 0x2b, 0x3f, (byte)0xc6, 0x5a,\n        (byte)0xca, (byte)0x89, (byte)0xc1, 0x58, 0x52,\n        (byte)0xa1, 0x78, 0x3c, 0x5b, 0x17, 0x46, 0x00,\n        (byte)0x85, 0x3f,\n\n        // Session-ID length: 32\n        0x20,\n\n        // Session-ID\n        0x0e, (byte)0xd3, 0x06, 0x72, 0x5b, 0x5b, 0x1b, 0x5f,\n        0x15, (byte)0xac, 0x13, (byte)0xf9, (byte)0x88, 0x53,\n        (byte)0x9d, (byte)0x9b, (byte)0xe8, 0x3d, 0x7b, 0x0c,\n        0x30, 0x32, 0x6e, 0x38, 0x4d, (byte)0xa2, 0x75, 0x57,\n        0x41, 0x6c, 0x34, 0x5c,\n\n        // Selected Cipher suite\n        0x00, 0x04, // TLS_RSA_WITH_RC4_128_MD5\n\n        // Compression method: null\n        0x00\n    };", "docstring": "\nData for the SSL message sent by the server ('server-hello').\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "byte", "name": "SSL_SERVER_HANDSHAKE[] =\n    {\n        // Content type: Handshake\n        0x16,\n\n        // Version: TLS 1.0\n        0x03, 0x01,\n\n        // Length: 74\n        0x00, 0x4a,\n\n        // Handshake Layer starts here\n\n        // Handshake type: Server Hello\n        0x02,\n\n        // Length: 70\n        0x00, 0x00, 0x46,\n\n        // Version: TLS 1.0\n        0x03, 0x01,\n\n        // 32 bytes random (well, obviously hardcoded here)\n        0x42, (byte)0x85, 0x45, (byte)0xa7, 0x27, (byte)0xa9,\n        0x5d, (byte)0xa0, (byte)0xb3, (byte)0xc5, (byte)0xe7,\n        0x53, (byte)0xda, 0x48, 0x2b, 0x3f, (byte)0xc6, 0x5a,\n        (byte)0xca, (byte)0x89, (byte)0xc1, 0x58, 0x52,\n        (byte)0xa1, 0x78, 0x3c, 0x5b, 0x17, 0x46, 0x00,\n        (byte)0x85, 0x3f,\n\n        // Session-ID length: 32\n        0x20,\n\n        // Session-ID\n        0x0e, (byte)0xd3, 0x06, 0x72, 0x5b, 0x5b, 0x1b, 0x5f,\n        0x15, (byte)0xac, 0x13, (byte)0xf9, (byte)0x88, 0x53,\n        (byte)0x9d, (byte)0x9b, (byte)0xe8, 0x3d, 0x7b, 0x0c,\n        0x30, 0x32, 0x6e, 0x38, 0x4d, (byte)0xa2, 0x75, 0x57,\n        0x41, 0x6c, 0x34, 0x5c,\n\n        // Selected Cipher suite\n        0x00, 0x04, // TLS_RSA_WITH_RC4_128_MD5\n\n        // Compression method: null\n        0x00\n    }", "syntax_pass": true}, {"attribute_expression": "public static final byte SSL_CLIENT_HANDSHAKE[] =\n    {\n        // Version: SSL 2.0 (0x0002) and length: 70\n        (byte)0x80, 0x46,\n\n        // Handshake message type: Client Hello\n        0x01,\n\n        // Version TLS 1.0\n        0x03, 0x01,\n\n        // Cipher Spec Length: 45\n        0x00, 0x2d,\n\n        // Session ID: 0\n        0x00, 0x00,\n\n        // Challenge length: 16\n        0x00, 0x10,\n\n        // Cipher spec (15 cyphers)\n        0x01, 0x00, (byte)0x80,       // SSL2_RC4_128_WITH_MD5\n        0x03, 0x00, (byte)0x80,       // SSL2_rc2_128_CBC_WITH_MD5\n        0x07, 0x00, (byte)0xc0,       // SSL2_DES_192_EDE3_CBC_WITH_MD5\n        0x06, 0x00, 0x40,             // SSL2_DES_64_CBC_WITH_MD5\n        0x02, 0x00, (byte)0x80,       // SSL2_RC4_128_EXPORT40_WITH_MD5\n        0x04, 0x00, (byte)0x80,       // SSL2_RC2_128_CBC_EXPORT40_WITH_MD5\n        0x00, 0x00, 0x04,             // TLS_RSA_WITH_RC4_128_MD5\n        0x00, (byte)0xfe, (byte)0xff, // SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA\n        0x00, 0x00, 0x0a,             // TLS_RSA_WITH_3DES_EDE_CBC_SHA\n        0x00, (byte)0xfe, (byte)0xfe, // SSL_RSA_FIPS_WITH_DES_CBC_SHA\n        0x00, 0x00, 0x09,             // TLS_RSA_WITH_DES_CBC_SHA\n        0x00, 0x00, 0x64,             // TLS_RSA_EXPORT1024_WITH_RC4_56_SHA\n        0x00, 0x00, 0x62,             // TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA\n        0x00, 0x00, 0x03,             // TLS_RSA_EXPORT_WITH_RC4_40_MD5\n        0x00, 0x00, 0x06,             // TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5\n\n        // Challenge\n        0x1f, 0x17, 0x0c, (byte)0xa6, 0x2f, 0x00, 0x78, (byte)0xfc, 0x46,\n        0x55, 0x2e, (byte)0xb1, (byte)0x83, 0x39, (byte)0xf1, (byte)0xea\n    };", "docstring": "\nData for the SSL message sent by the client (client-hello).\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "SSL_CLIENT_HANDSHAKE[] =\n    {\n        // Version: SSL 2.0 (0x0002) and length: 70\n        (byte)0x80, 0x46,\n\n        // Handshake message type: Client Hello\n        0x01,\n\n        // Version TLS 1.0\n        0x03, 0x01,\n\n        // Cipher Spec Length: 45\n        0x00, 0x2d,\n\n        // Session ID: 0\n        0x00, 0x00,\n\n        // Challenge length: 16\n        0x00, 0x10,\n\n        // Cipher spec (15 cyphers)\n        0x01, 0x00, (byte)0x80,       // SSL2_RC4_128_WITH_MD5\n        0x03, 0x00, (byte)0x80,       // SSL2_rc2_128_CBC_WITH_MD5\n        0x07, 0x00, (byte)0xc0,       // SSL2_DES_192_EDE3_CBC_WITH_MD5\n        0x06, 0x00, 0x40,             // SSL2_DES_64_CBC_WITH_MD5\n        0x02, 0x00, (byte)0x80,       // SSL2_RC4_128_EXPORT40_WITH_MD5\n        0x04, 0x00, (byte)0x80,       // SSL2_RC2_128_CBC_EXPORT40_WITH_MD5\n        0x00, 0x00, 0x04,             // TLS_RSA_WITH_RC4_128_MD5\n        0x00, (byte)0xfe, (byte)0xff, // SSL_RSA_FIPS_WITH_3DES_EDE_CBC_SHA\n        0x00, 0x00, 0x0a,             // TLS_RSA_WITH_3DES_EDE_CBC_SHA\n        0x00, (byte)0xfe, (byte)0xfe, // SSL_RSA_FIPS_WITH_DES_CBC_SHA\n        0x00, 0x00, 0x09,             // TLS_RSA_WITH_DES_CBC_SHA\n        0x00, 0x00, 0x64,             // TLS_RSA_EXPORT1024_WITH_RC4_56_SHA\n        0x00, 0x00, 0x62,             // TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA\n        0x00, 0x00, 0x03,             // TLS_RSA_EXPORT_WITH_RC4_40_MD5\n        0x00, 0x00, 0x06,             // TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5\n\n        // Challenge\n        0x1f, 0x17, 0x0c, (byte)0xa6, 0x2f, 0x00, 0x78, (byte)0xfc, 0x46,\n        0x55, 0x2e, (byte)0xb1, (byte)0x83, 0x39, (byte)0xf1, (byte)0xea\n    }", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester", "name": "TcpHarvester", "file_path": "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java", "superclasses": "AbstractTcpListener", "methods": ["[]TcpHarvester(int)", "[]TcpHarvester(int,boolean)", "[]TcpHarvester(int,List<NetworkInterface>,boolean)", "[]TcpHarvester(List<TransportAddress>)", "[]TcpHarvester(List<TransportAddress>,boolean)", "[void]addMappedAddresses()", "[void]addMappedAddress(InetAddress,InetAddress)", "[void]addMappedPort(int)", "[List<LocalCandidate>]createLocalCandidates(Component)", "[Component]getComponent(String)", "[Collection<LocalCandidate>]harvest(Component)", "[void]purgeComponents()", "[void]acceptSession(Socket,String,DatagramPacket)", "[void]addSocketToComponent(Socket,Component,DatagramPacket)", "[TcpHostCandidate]findCandidate(Component,Socket)", "[boolean]isHostHarvester()", "[HarvestStatistics]getHarvestStatistics()"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[]TcpHarvester(int)", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[]TcpHarvester(int,boolean)", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[]TcpHarvester(int,List<NetworkInterface>,boolean)", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[]TcpHarvester(List<TransportAddress>)", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[]TcpHarvester(List<TransportAddress>,boolean)", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[void]addMappedAddresses()", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[void]addMappedAddress(InetAddress,InetAddress)", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[void]addMappedPort(int)", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[List<LocalCandidate>]createLocalCandidates(Component)", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[Component]getComponent(String)", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[Collection<LocalCandidate>]harvest(Component)", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[void]purgeComponents()", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[void]acceptSession(Socket,String,DatagramPacket)", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[void]addSocketToComponent(Socket,Component,DatagramPacket)", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[TcpHostCandidate]findCandidate(Component,Socket)", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[boolean]isHostHarvester()", "src/main/java/org/ice4j/ice/harvest/TcpHarvester.java.TcpHarvester.[HarvestStatistics]getHarvestStatistics()"], "overrides": null, "attributes": [], "class_docstring": "\nAn implementation of {@link AbstractTcpListener} which acts as a\n{@link CandidateHarvester}. Sessions are accepted if their ufrag matches\na {@link Component} registered with this harvester, and the known addresses\nof {@link AbstractTcpListener} are added as local host candidates (with type\n\"tcp\" and tcptype \"passive\") when harvesting.\n\n@author Boris Grozev\n@author Lyubomir Marinov\n", "original_string": "public class TcpHarvester\n    extends AbstractTcpListener\n    implements CandidateHarvester\n{\n    /**\n     * Our class logger.\n     */\n    private static final Logger logger\n        = Logger.getLogger(TcpHarvester.class.getName());\n\n    /**\n     * The constant which specifies how often to perform purging on\n     * {@link #components}.\n     */\n    private static final int PURGE_INTERVAL = 20;\n\n    /**\n     * Maps a local \"ufrag\" to the single <tt>Component</tt> instance with that\n     * \"ufrag\".\n     *\n     * We only keep weak references, because we do not want to prevent\n     * <tt>Component</tt>s from being freed.\n     */\n    private final Map<String, WeakReference<Component>> components\n        = new HashMap<>();\n\n    /**\n     * Maps a public address to a local address. Used to add additional\n     * candidates with type \"srflx\" when harvesting.\n     */\n    private final Map<InetAddress, InetAddress> mappedAddresses\n        = new HashMap<>();\n\n    /**\n     * Sets of additional ports, for which server reflexive candidates will be\n     * added.\n     */\n    private final Set<Integer> mappedPorts = new HashSet<>();\n\n    /**\n     * A counter used to decide when to purge {@link #components}.\n     */\n    private int purgeCounter = 0;\n\n    /**\n     * Whether to advertise candidates with type \"ssltcp\" (if true) or \"tcp\"\n     * (if false).\n     */\n    private final boolean ssltcp;\n\n    /**\n     * Manages statistics about harvesting time.\n     */\n    private HarvestStatistics harvestStatistics = new HarvestStatistics();\n\n    /**\n     * Initializes a new <tt>TcpHarvester</tt>, which is to\n     * listen on port number <tt>port</tt> on all IP addresses on all available\n     * interfaces.\n     *\n     * @param port the port to listen on.\n     * @throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n     * {@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\n     * if an I/O error occurs.\n     */\n    public TcpHarvester(int port)\n        throws IOException\n    {\n        super(port);\n        this.ssltcp = false;\n        addMappedAddresses();\n    }\n\n    /**\n     * Initializes a new <tt>TcpHarvester</tt>, which is to\n     * listen on port number <tt>port</tt> on all IP addresses on all available\n     * interfaces.\n     *\n     * @param port the port to listen on.\n     * @param ssltcp <tt>true</tt> to use ssltcp; otherwise, <tt>false</tt>\n     * @throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n     * {@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\n     * if an I/O error occurs.\n     */\n    public TcpHarvester(int port, boolean ssltcp)\n            throws IOException\n    {\n        super(port, Collections.list(NetworkInterface.getNetworkInterfaces()));\n        this.ssltcp = ssltcp;\n        addMappedAddresses();\n    }\n\n    /**\n     * Initializes a new <tt>TcpHarvester</tt>, which is to\n     * listen on port number <tt>port</tt> on all the IP addresses on the\n     * specified <tt>NetworkInterface</tt>s.\n     *\n     * @param port the port to listen on.\n     * @param interfaces the interfaces to listen on.\n     * @param ssltcp <tt>true</tt> to use ssltcp; otherwise, <tt>false</tt>\n     * @throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n     * {@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\n     * if an I/O error occurs.\n     */\n    public TcpHarvester(\n            int port,\n            List<NetworkInterface> interfaces,\n            boolean ssltcp)\n        throws IOException\n    {\n        super(port, interfaces);\n        this.ssltcp = ssltcp;\n        addMappedAddresses();\n    }\n\n    /**\n     * Initializes a new <tt>TcpHarvester</tt>, which is to\n     * listen on the specified list of <tt>TransportAddress</tt>es.\n     *\n     * @param transportAddresses the transport addresses to listen on.\n     * @throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n     * {@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\n     * if an I/O error occurs.\n     */\n    public TcpHarvester(List<TransportAddress> transportAddresses)\n        throws IOException\n    {\n        super(transportAddresses);\n        this.ssltcp = false;\n        addMappedAddresses();\n    }\n\n    /**\n     * Initializes a new <tt>TcpHarvester</tt>, which is to\n     * listen on the specified list of <tt>TransportAddress</tt>es.\n     *\n     * @param transportAddresses the transport addresses to listen on.\n     * @param ssltcp <tt>true</tt> to use ssltcp; otherwise, <tt>false</tt>\n     * @throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n     * {@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\n     * if an I/O error occurs.\n     */\n    public TcpHarvester(\n            List<TransportAddress> transportAddresses,\n            boolean ssltcp)\n        throws IOException\n    {\n        super(transportAddresses);\n        this.ssltcp = ssltcp;\n        addMappedAddresses();\n    }\n\n    /**\n     * Adds the mapped addresses known from {@link MappingCandidateHarvesters}.\n     */\n    private void addMappedAddresses()\n    {\n        for (MappingCandidateHarvester harvester\n                    : MappingCandidateHarvesters.getHarvesters())\n        {\n            addMappedAddress(\n                    harvester.getMask().getAddress(),\n                    harvester.getFace().getAddress());\n        }\n    }\n\n    /**\n     * Adds a mapping between <tt>publicAddress</tt> and <tt>localAddress</tt>.\n     * This means that on harvest, along with any host candidates that have\n     * <tt>publicAddress</tt>, a server reflexive candidate will be added (with\n     * the same port as the host candidate).\n     *\n     * @param publicAddress the public address.\n     * @param localAddress the local address.\n     */\n    public void addMappedAddress(InetAddress publicAddress,\n                                 InetAddress localAddress)\n    {\n        if (logger.isLoggable(Level.FINE))\n        {\n            logger.fine(\"Adding a mapped address: \" + localAddress\n                            + \" => \" + publicAddress);\n        }\n        mappedAddresses.put(publicAddress, localAddress);\n    }\n\n    /**\n     * Adds port as an additional port. When harvesting, additional server\n     * reflexive candidates will be added with this port.\n     *\n     * @param port the port to add.\n     */\n    public void addMappedPort(int port)\n    {\n        mappedPorts.add(port);\n    }\n\n    /**\n     * Creates and returns the list of <tt>LocalCandidate</tt>s which are to be\n     * added by this <tt>TcpHarvester</tt> to a specific\n     * <tt>Component</tt>.\n     *\n     * @param component the <tt>Component</tt> for which to create candidates.\n     * @return the list of <tt>LocalCandidate</tt>s which are to be added by\n     * this <tt>TcpHarvester</tt> to a specific\n     * <tt>Component</tt>.\n     */\n    private List<LocalCandidate> createLocalCandidates(Component component)\n    {\n        List<TcpHostCandidate> hostCandidates = new LinkedList<>();\n\n        // Add the host candidates for the addresses we really listen on\n        for (TransportAddress transportAddress : localAddresses)\n        {\n            TcpHostCandidate candidate\n                = new TcpHostCandidate(transportAddress, component);\n\n            candidate.setTcpType(CandidateTcpType.PASSIVE);\n            if (ssltcp)\n                candidate.setSSL(true);\n\n            hostCandidates.add(candidate);\n        }\n\n        // Add srflx candidates for any mapped addresses\n        List<LocalCandidate> mappedCandidates = new LinkedList<>();\n\n        for (Map.Entry<InetAddress, InetAddress> mapping\n                : mappedAddresses.entrySet())\n        {\n            InetAddress localAddress = mapping.getValue();\n\n            for (TcpHostCandidate base : hostCandidates)\n            {\n                TransportAddress baseTransportAddress\n                    = base.getTransportAddress();\n\n                if (localAddress.equals(baseTransportAddress.getAddress()))\n                {\n                    InetAddress publicAddress = mapping.getKey();\n                    ServerReflexiveCandidate mappedCandidate\n                        = new ServerReflexiveCandidate(\n                            new TransportAddress(publicAddress,\n                                                 baseTransportAddress.getPort(),\n                                                 Transport.TCP),\n                            base,\n                            base.getStunServerAddress(),\n                            CandidateExtendedType.STATICALLY_MAPPED_CANDIDATE);\n\n                    if (base.isSSL())\n                        mappedCandidate.setSSL(true);\n                    mappedCandidate.setTcpType(CandidateTcpType.PASSIVE);\n\n                    mappedCandidates.add(mappedCandidate);\n                }\n            }\n        }\n\n        // Add srflx candidates for mapped ports\n        List<LocalCandidate> portMappedCandidates = new LinkedList<>();\n\n        for (TcpHostCandidate base : hostCandidates)\n        {\n            for (Integer port : mappedPorts)\n            {\n                ServerReflexiveCandidate portMappedCandidate\n                    = new ServerReflexiveCandidate(\n                        new TransportAddress(\n                            base.getTransportAddress().getAddress(),\n                            port,\n                            Transport.TCP),\n                        base,\n                        base.getStunServerAddress(),\n                        CandidateExtendedType.STATICALLY_MAPPED_CANDIDATE);\n\n                if (base.isSSL())\n                    portMappedCandidate.setSSL(true);\n                portMappedCandidate.setTcpType(CandidateTcpType.PASSIVE);\n\n                portMappedCandidates.add(portMappedCandidate);\n            }\n        }\n        // Mapped ports for mapped addresses\n        for (LocalCandidate mappedCandidate : mappedCandidates)\n        {\n            TcpHostCandidate base\n                = (TcpHostCandidate) mappedCandidate.getBase();\n\n            for (Integer port : mappedPorts)\n            {\n                ServerReflexiveCandidate portMappedCandidate\n                    = new ServerReflexiveCandidate(\n                        new TransportAddress(\n                                mappedCandidate.getTransportAddress()\n                                        .getAddress(),\n                                port,\n                                Transport.TCP),\n                        base,\n                        base.getStunServerAddress(),\n                        CandidateExtendedType.STATICALLY_MAPPED_CANDIDATE);\n\n                if (base.isSSL())\n                    portMappedCandidate.setSSL(true);\n                portMappedCandidate.setTcpType(CandidateTcpType.PASSIVE);\n\n                portMappedCandidates.add(portMappedCandidate);\n            }\n        }\n\n        LinkedList<LocalCandidate> allCandidates = new LinkedList<>();\n\n        allCandidates.addAll(hostCandidates);\n        allCandidates.addAll(mappedCandidates);\n        allCandidates.addAll(portMappedCandidates);\n        return allCandidates;\n    }\n\n    /**\n     * Returns the <tt>Component</tt> instance, if any, for a given local\n     * &quot;ufrag&quot;.\n     *\n     * @param localUfrag the local &quot;ufrag&quot;\n     * @return the <tt>Component</tt> instance, if any, for a given local\n     * &quot;ufrag&quot;.\n     */\n    private Component getComponent(String localUfrag)\n    {\n        synchronized (components)\n        {\n            WeakReference<Component> wr = components.get(localUfrag);\n\n            if (wr != null)\n            {\n                Component component = wr.get();\n\n                if (component == null)\n                {\n                    components.remove(localUfrag);\n                }\n\n                return component;\n            }\n            return null;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Saves a (weak) reference to <tt>Component</tt>, so that it can be\n     * notified if/when a socket for one of it <tt>LocalCandidate</tt>s is\n     * accepted.\n     * <p>\n     * The method does not perform any network operations and should return\n     * quickly.\n     * </p>\n     */\n    @Override\n    public Collection<LocalCandidate> harvest(Component component)\n    {\n        IceMediaStream stream = component.getParentStream();\n        Agent agent = stream.getParentAgent();\n\n        if (stream.getComponentCount() != 1 || agent.getStreamCount() != 1)\n        {\n            /*\n             * TcpHarvester only works with streams with a\n             * single component, and agents with a single stream. This is\n             * because we use the local \"ufrag\" to de-multiplex the accept()-ed\n             * sockets between the known components.\n             */\n            logger.info(\n                    \"More than one Component for an Agent, cannot harvest.\");\n            return new LinkedList<>();\n        }\n\n        List<LocalCandidate> candidates = createLocalCandidates(component);\n\n        for (LocalCandidate candidate : candidates)\n            component.addLocalCandidate(candidate);\n\n        synchronized (components)\n        {\n            components.put(\n                    agent.getLocalUfrag(),\n                    new WeakReference<>(component));\n            purgeComponents();\n        }\n\n        return candidates;\n    }\n\n    /**\n     * Removes entries from {@link #components} for which the\n     * <tt>WeakReference</tt> has been cleared.\n     */\n    private void purgeComponents()\n    {\n        ++purgeCounter;\n        if (purgeCounter % PURGE_INTERVAL == 0)\n        {\n            synchronized (components)\n            {\n                for (Iterator<WeakReference<Component>> i\n                            = components.values().iterator();\n                        i.hasNext();)\n                {\n                    if (i.next().get() == null)\n                        i.remove();\n                }\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected void acceptSession(Socket socket, String ufrag,\n                                 DatagramPacket pushback)\n        throws IOException, IllegalStateException\n    {\n        Component component = getComponent(ufrag);\n        if (component == null)\n        {\n            throw new IllegalStateException(\n                    \"No component found for ufrag \" + ufrag);\n        }\n\n        addSocketToComponent(socket, component, pushback);\n    }\n\n    /**\n     * Makes <tt>socket</tt> available to <tt>component</tt> and pushes back\n     * <tt>datagramPacket</tt> into the STUN socket.\n     *\n     * @param socket the <tt>Socket</tt>.\n     * @param component the <tt>Component</tt>.\n     * @param datagramPacket the <tt>DatagramPacket</tt> to push back.\n     * @throws IllegalStateException if the ICE state is incorrect, or an\n     * appropriate candidate could not be found.\n     * @throws IOException if creation of some of the required socket instances\n     * failed.\n     */\n    private void addSocketToComponent(\n            Socket socket, Component component, DatagramPacket datagramPacket)\n        throws IOException, IllegalStateException\n    {\n        IceProcessingState state\n            = component.getParentStream().getParentAgent().getState();\n\n        if (!IceProcessingState.WAITING.equals(state)\n            && !IceProcessingState.RUNNING.equals(state))\n        {\n            // If we are using the merging socket, we can still make use of the\n            // new socket. Otherwise, we have no use for it, so we better close\n            // it (and log a warning) early.\n            if (component.getComponentSocket() == null)\n            {\n                throw new IllegalStateException(\n                    \"The associated Agent is in state \" + state +\n                        \" and we are not using a component socket\");\n            }\n            else if (logger.isLoggable(Level.FINE))\n            {\n                logger.fine(\"Adding a socket to an Agent in state \" + state);\n            }\n        }\n\n        // Socket to add to the candidate\n        IceSocketWrapper candidateSocket = null;\n        // STUN-only filtered socket to add to the StunStack\n        IceSocketWrapper stunSocket = null;\n\n        MultiplexingSocket multiplexing = new MultiplexingSocket(socket);\n        candidateSocket = new IceTcpSocketWrapper(multiplexing);\n\n        stunSocket\n            = new IceTcpSocketWrapper(\n                multiplexing.getSocket(new StunDatagramPacketFilter()));\n        stunSocket = new PushBackIceSocketWrapper(stunSocket, datagramPacket);\n\n        TcpHostCandidate candidate = findCandidate(component, socket);\n        if (candidate == null)\n        {\n            throw new IOException(\n                    \"Failed to find the local candidate for socket: \" + socket);\n        }\n\n        component.getParentStream().getParentAgent().getStunStack()\n                .addSocket(stunSocket);\n        candidate.addSocket(candidateSocket);\n\n        MergingDatagramSocket componentSocket = component.getComponentSocket();\n        if (componentSocket != null)\n        {\n            componentSocket.add(multiplexing);\n        }\n        // the socket is not our responsibility anymore. It is up to\n        // the candidate/component to close/free it.\n    }\n\n    /**\n     * Searches among the local candidates of <tt>Component</tt> for a\n     * <tt>TcpHostCandidate</tt> with the same transport address as the\n     * local transport address of <tt>socket</tt>.\n     *\n     * We expect to find such a candidate, which has been added by this\n     * <tt>TcpHarvester</tt> while harvesting.\n     *\n     * @param component the <tt>Component</tt> to search.\n     * @param socket the <tt>Socket</tt> to match the local transport\n     * address of.\n     * @return a <tt>TcpHostCandidate</tt> among the local candidates of\n     * <tt>Component</tt> with the same transport address as the local\n     * address of <tt>Socket</tt>, or <tt>null</tt> if no such candidate\n     * exists.\n     */\n    private TcpHostCandidate findCandidate(\n        Component component,\n        Socket socket)\n    {\n        InetAddress localAddress = socket.getLocalAddress();\n        int localPort = socket.getLocalPort();\n\n        for (LocalCandidate candidate : component.getLocalCandidates())\n        {\n            TransportAddress transportAddress\n                = candidate.getTransportAddress();\n\n            if (candidate instanceof TcpHostCandidate\n                && Transport.TCP.equals(transportAddress.getTransport())\n                && localPort == transportAddress.getPort()\n                && localAddress.equals(transportAddress.getAddress()))\n            {\n                return (TcpHostCandidate) candidate;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isHostHarvester()\n    {\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public HarvestStatistics getHarvestStatistics()\n    {\n        return harvestStatistics;\n    }\n\n}", "super_interfaces": ["CandidateHarvester"], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(TcpHarvester.class.getName());", "docstring": "\nOur class logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(TcpHarvester.class.getName())", "syntax_pass": true}, {"attribute_expression": "private static final int PURGE_INTERVAL = 20;", "docstring": "\nThe constant which specifies how often to perform purging on\n{@link #components}.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "PURGE_INTERVAL = 20", "syntax_pass": true}, {"attribute_expression": "private final Map<String, WeakReference<Component>> components\n        = new HashMap<>();", "docstring": "\nMaps a local \"ufrag\" to the single <tt>Component</tt> instance with that\n\"ufrag\".\n\nWe only keep weak references, because we do not want to prevent\n<tt>Component</tt>s from being freed.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, WeakReference<Component>>", "name": "components\n        = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<InetAddress, InetAddress> mappedAddresses\n        = new HashMap<>();", "docstring": "\nMaps a public address to a local address. Used to add additional\ncandidates with type \"srflx\" when harvesting.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<InetAddress, InetAddress>", "name": "mappedAddresses\n        = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final Set<Integer> mappedPorts = new HashSet<>();", "docstring": "\nSets of additional ports, for which server reflexive candidates will be\nadded.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Set<Integer>", "name": "mappedPorts = new HashSet<>()", "syntax_pass": true}, {"attribute_expression": "private int purgeCounter = 0;", "docstring": "\nA counter used to decide when to purge {@link #components}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "purgeCounter = 0", "syntax_pass": true}, {"attribute_expression": "private final boolean ssltcp;", "docstring": "\nWhether to advertise candidates with type \"ssltcp\" (if true) or \"tcp\"\n(if false).\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "ssltcp", "syntax_pass": true}, {"attribute_expression": "private HarvestStatistics harvestStatistics = new HarvestStatistics();", "docstring": "\nManages statistics about harvesting time.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HarvestStatistics", "name": "harvestStatistics = new HarvestStatistics()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester", "name": "TurnCandidateHarvester", "file_path": "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java", "superclasses": "StunCandidateHarvester", "methods": ["[]TurnCandidateHarvester(TransportAddress)", "[]TurnCandidateHarvester(TransportAddress,LongTermCredential)", "[]TurnCandidateHarvester(TransportAddress,String)", "[TurnCandidateHarvest]createHarvest(HostCandidate)", "[LongTermCredential]createLongTermCredential(StunCandidateHarvest,byte[])"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester.[]TurnCandidateHarvester(TransportAddress)", "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester.[]TurnCandidateHarvester(TransportAddress,LongTermCredential)", "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester.[]TurnCandidateHarvester(TransportAddress,String)", "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester.[TurnCandidateHarvest]createHarvest(HostCandidate)", "src/main/java/org/ice4j/ice/harvest/TurnCandidateHarvester.java.TurnCandidateHarvester.[LongTermCredential]createLongTermCredential(StunCandidateHarvest,byte[])"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a <tt>CandidateHarvester</tt> which gathers TURN\n<tt>Candidate</tt>s for a specified {@link Component}.\n\n@author Emil Ivov\n@author Lubomir Marinov\n", "original_string": "public class TurnCandidateHarvester\n    extends StunCandidateHarvester\n{\n\n    /**\n     * The <tt>LongTermCredential</tt> to be used with the TURN server with\n     * which this instance works.\n     */\n    private final LongTermCredential longTermCredential;\n\n    /**\n     * Initializes a new <tt>TurnCandidateHarvester</tt> instance which is to\n     * work with a specific TURN server.\n     *\n     * @param turnServer the <tt>TransportAddress</tt> of the TURN server the\n     * new instance is to work with\n     */\n    public TurnCandidateHarvester(TransportAddress turnServer)\n    {\n        this(turnServer, (LongTermCredential) null);\n    }\n\n    /**\n     * Initializes a new <tt>TurnCandidateHarvester</tt> instance which is to\n     * work with a specific TURN server using a specific\n     * <tt>LongTermCredential</tt>.\n     *\n     * @param turnServer the <tt>TransportAddress</tt> of the TURN server the\n     * new instance is to work with\n     * @param longTermCredential the <tt>LongTermCredential</tt> to use with the\n     * specified <tt>turnServer</tt> or <tt>null</tt> if the use of the\n     * long-term credential mechanism is not determined at the time of the\n     * initialization of the new <tt>TurnCandidateHarvester</tt> instance\n     */\n    public TurnCandidateHarvester(\n            TransportAddress turnServer,\n            LongTermCredential longTermCredential)\n    {\n        super(turnServer);\n\n        this.longTermCredential = longTermCredential;\n    }\n\n    /**\n     * Initializes a new <tt>TurnCandidateHarvester</tt> instance which is to\n     * work with a specific TURN server using a specific username for the\n     * purposes of the STUN short-term credential mechanism.\n     *\n     * @param turnServer the <tt>TransportAddress</tt> of the TURN server the\n     * new instance is to work with\n     * @param shortTermCredentialUsername the username to be used by the new\n     * instance for the purposes of the STUN short-term credential mechanism or\n     * <tt>null</tt> if the use of the STUN short-term credential mechanism is\n     * not determined at the time of the construction of the new instance\n     */\n    public TurnCandidateHarvester(\n            TransportAddress turnServer,\n            String shortTermCredentialUsername)\n    {\n        super(turnServer, shortTermCredentialUsername);\n\n        this.longTermCredential = null;\n    }\n\n    /**\n     * Creates a new <tt>TurnCandidateHarvest</tt> instance which is to perform\n     * TURN harvesting of a specific <tt>HostCandidate</tt>.\n     *\n     * @param hostCandidate the <tt>HostCandidate</tt> for which harvesting is\n     * to be performed by the new <tt>TurnCandidateHarvest</tt> instance\n     * @return a new <tt>TurnCandidateHarvest</tt> instance which is to perform\n     * TURN harvesting of the specified <tt>hostCandidate</tt>\n     * @see StunCandidateHarvester#createHarvest(HostCandidate)\n     */\n    @Override\n    protected TurnCandidateHarvest createHarvest(HostCandidate hostCandidate)\n    {\n        return new TurnCandidateHarvest(this, hostCandidate);\n    }\n\n    /**\n     * Creates a <tt>LongTermCredential</tt> to be used by a specific\n     * <tt>StunCandidateHarvest</tt> for the purposes of the long-term\n     * credential mechanism in a specific <tt>realm</tt> of the TURN server\n     * associated with this <tt>TurnCandidateHarvester</tt>. The default\n     * implementation returns <tt>null</tt> and allows extenders to override in\n     * order to support the long-term credential mechanism.\n     *\n     * @param harvest the <tt>StunCandidateHarvest</tt> which asks for the\n     * <tt>LongTermCredential</tt>\n     * @param realm the realm of the TURN server associated with this\n     * <tt>TurnCandidateHarvester</tt> in which <tt>harvest</tt> will use the\n     * returned <tt>LongTermCredential</tt>\n     * @return a <tt>LongTermCredential</tt> to be used by <tt>harvest</tt> for\n     * the purposes of the long-term credential mechanism in the specified\n     * <tt>realm</tt> of the TURN server associated with this\n     * <tt>TurnsCandidateHarvester</tt>\n     * @see StunCandidateHarvester#createLongTermCredential(\n     * StunCandidateHarvest,byte[])\n     */\n    @Override\n    protected LongTermCredential createLongTermCredential(\n            StunCandidateHarvest harvest,\n            byte[] realm)\n    {\n        return longTermCredential;\n    }\n }", "super_interfaces": [], "fields": [{"attribute_expression": "private final LongTermCredential longTermCredential;", "docstring": "\nThe <tt>LongTermCredential</tt> to be used with the TURN server with\nwhich this instance works.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "LongTermCredential", "name": "longTermCredential", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java.StunMappingCandidateHarvester", "name": "StunMappingCandidateHarvester", "file_path": "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java", "superclasses": "MappingCandidateHarvester", "methods": ["[]StunMappingCandidateHarvester(TransportAddress,TransportAddress)", "[void]discover()", "[TransportAddress]getFace()", "[TransportAddress]getMask()"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java.StunMappingCandidateHarvester.[]StunMappingCandidateHarvester(TransportAddress,TransportAddress)", "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java.StunMappingCandidateHarvester.[void]discover()", "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java.StunMappingCandidateHarvester.[TransportAddress]getFace()", "src/main/java/org/ice4j/ice/harvest/StunMappingCandidateHarvester.java.StunMappingCandidateHarvester.[TransportAddress]getMask()"], "overrides": null, "attributes": [], "class_docstring": "\nA {@link MappingCandidateHarvester} which uses a STUN servers to discover its public IP address.\n\n@author Damian Minkov\n@author Boris Grozev\n", "original_string": "public class StunMappingCandidateHarvester\n    extends MappingCandidateHarvester\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>StunMappingCandidateHarvester</tt>\n     * class and its instances for logging output.\n     */\n    private static final Logger logger = Logger.getLogger(StunMappingCandidateHarvester.class.getName());\n\n    /**\n     * The list of servers we will use to discover our public address.\n     */\n    private final TransportAddress stunServerAddress;\n\n    /**\n     * The local address this {@link StunMappingCandidateHarvester} was initialized with, and which will be used to\n     * communicate to STUN servers.\n     */\n    @NotNull\n    private TransportAddress localAddress;\n\n    /**\n     * The public address discovered through STUN, if any.\n     */\n    private TransportAddress publicAddress = null;\n\n    /**\n     * Initializes a new {@link StunMappingCandidateHarvester} instance with\n     * a given local address and a STUN server address. Note that the actual\n     * discovery of the public address needs to be initiated to a separate call\n     * to {@link #discover()}.\n     * @param localAddress The local address.\n     * @param stunServerAddress The address of the STUN server.\n     */\n    public StunMappingCandidateHarvester(\n            @NotNull TransportAddress localAddress,\n            TransportAddress stunServerAddress)\n    {\n        super(\"stun\");\n        this.localAddress = localAddress;\n        this.stunServerAddress = stunServerAddress;\n    }\n\n    /**\n     * Attempts to discover the the public address (mask) via the STUN server.\n     * Note that this will block until we either receive a response from the\n     * STUN server, or a timeout occurs.\n     */\n    public void discover()\n    {\n        try\n        {\n            SimpleAddressDetector sad\n                = new SimpleAddressDetector(stunServerAddress);\n            sad.start();\n\n            IceSocketWrapper localSocket = new IceUdpSocketWrapper(new DatagramSocket(localAddress));\n\n            publicAddress = sad.getMappingFor(localSocket);\n\n            /* Record bound address as face. */\n            SocketAddress boundAddr = localSocket.getLocalSocketAddress();\n            if (boundAddr instanceof InetSocketAddress)\n            {\n                localAddress = new TransportAddress((InetSocketAddress)boundAddr, localAddress.getTransport());\n            }\n\n            if (publicAddress != null)\n            {\n                logger.info(\"Discovered public address \" + publicAddress\n                                + \" from STUN server \" + stunServerAddress\n                                + \" using local address \" + localSocket);\n            }\n        }\n        catch (Exception exc)\n        {\n            //whatever happens, we just log\n            logger.log(Level.INFO, \"We failed to obtain addresses for the following reason: \", exc);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Nullable\n    @Override\n    public TransportAddress getFace()\n    {\n        return localAddress;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Nullable\n    @Override\n    public TransportAddress getMask()\n    {\n        return publicAddress;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger = Logger.getLogger(StunMappingCandidateHarvester.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>StunMappingCandidateHarvester</tt>\nclass and its instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger = Logger.getLogger(StunMappingCandidateHarvester.class.getName())", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress stunServerAddress;", "docstring": "\nThe list of servers we will use to discover our public address.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "stunServerAddress", "syntax_pass": true}, {"attribute_expression": "@NotNull\n    private TransportAddress localAddress;", "docstring": "\nThe local address this {@link StunMappingCandidateHarvester} was initialized with, and which will be used to\ncommunicate to STUN servers.\n", "modifiers": "@NotNull\n    private", "marker_annotations": ["@NotNull"], "non_marker_annotations": ["private"], "comments": [], "type": "TransportAddress", "name": "localAddress", "syntax_pass": true}, {"attribute_expression": "private TransportAddress publicAddress = null;", "docstring": "\nThe public address discovered through STUN, if any.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransportAddress", "name": "publicAddress = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement", "name": "CandidateHarvesterSetElement", "file_path": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java", "superclasses": "", "methods": ["[]CandidateHarvesterSetElement(CandidateHarvester)", "[void]harvest(Component,TrickleCallback)", "[boolean]harvesterEquals(CandidateHarvester)", "[boolean]isEnabled()", "[void]setEnabled(boolean)", "[CandidateHarvester]getHarvester()", "[void]startHarvestTiming()", "[void]stopHarvestTiming(Collection<LocalCandidate>)"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[]CandidateHarvesterSetElement(CandidateHarvester)", "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[void]harvest(Component,TrickleCallback)", "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[boolean]harvesterEquals(CandidateHarvester)", "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[boolean]isEnabled()", "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[void]setEnabled(boolean)", "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[CandidateHarvester]getHarvester()", "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[void]startHarvestTiming()", "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSetElement.java.CandidateHarvesterSetElement.[void]stopHarvestTiming(Collection<LocalCandidate>)"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents a <tt>CandidateHarvester</tt> as an element in a\n<tt>CandidateHarvesterSet</tt>.\n\n@author Lyubomir Marinov\n@author Emil Ivov\n", "original_string": "class CandidateHarvesterSetElement\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>CandidateHarvesterSetElement</tt>\n     * class and its instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(CandidateHarvesterSetElement.class.getName());\n\n    /**\n     * The indicator which determines whether\n     * {@link CandidateHarvester#harvest(org.ice4j.ice.Component)} is to be\n     * called on {@link #harvester}.\n     */\n    private boolean enabled = true;\n\n    /**\n     * The <tt>CandidateHarvester</tt> which is an element in a\n     * <tt>CandidateHarvesterSet</tt>.\n     */\n    private final CandidateHarvester harvester;\n\n    /**\n     * Initializes a new <tt>CandidateHarvesterSetElement</tt> instance\n     * which is to represent a specific <tt>CandidateHarvester</tt> as an\n     * element in a <tt>CandidateHarvesterSet</tt>.\n     *\n     * @param harvester the <tt>CandidateHarvester</tt> which is to be\n     * represented as an element in a <tt>CandidateHarvesterSet</tt> by the\n     * new instance\n     */\n    public CandidateHarvesterSetElement(CandidateHarvester harvester)\n    {\n        this.harvester = harvester;\n        harvester.getHarvestStatistics().harvesterName = harvester.toString();\n    }\n\n    /**\n     * Calls {@link CandidateHarvester#harvest(org.ice4j.ice.Component)} on the\n     * associated <tt>CandidateHarvester</tt> if <tt>enabled</tt>.\n     *\n     * @param component the <tt>Component</tt> to gather candidates for\n     * @param trickleCallback the {@link TrickleCallback} that we will be\n     * feeding candidates to, or <tt>null</tt> in case the application doesn't\n     * want us trickling any candidates\n     */\n    public void harvest(Component       component,\n                        TrickleCallback trickleCallback)\n    {\n        if (!isEnabled())\n            return;\n\n        startHarvestTiming();\n\n        Collection<LocalCandidate> candidates = harvester.harvest(component);\n\n        stopHarvestTiming(candidates);\n\n        /*\n         * If the CandidateHarvester has not gathered any candidates, it\n         * is considered failed and will not be used again in order to\n         * not risk it slowing down the overall harvesting.\n         */\n        if ((candidates == null) || candidates.isEmpty())\n        {\n            setEnabled(false);\n        }\n        else if (trickleCallback != null)\n        {\n            trickleCallback.onIceCandidates(candidates);\n        }\n\n    }\n\n    /**\n     * Determines whether the associated <tt>CandidateHarvester</tt> is\n     * considered to be the same as a specific <tt>CandidateHarvester</tt>.\n     *\n     * @param harvester the <tt>CandidateHarvester</tt> to be compared to\n     * the associated <tt>CandidateHarvester</tt>\n     * @return <tt>true</tt> if the associated <tt>CandidateHarvester</tt>\n     * is considered to be the same as the specified <tt>harvester</tt>;\n     * otherwise, <tt>false</tt>\n     */\n    public boolean harvesterEquals(CandidateHarvester harvester)\n    {\n        return this.harvester.equals(harvester);\n    }\n\n    /**\n     * Gets the indicator which determines whether\n     * {@link CandidateHarvester#harvest(Component)} is to be called on the\n     * associated <tt>CandidateHarvester</tt>.\n     *\n     * @return <tt>true</tt> if\n     * <tt>CandidateHarvester#harvest(Component)</tt> is to be called on the\n     * associated <tt>CandidateHarvester</tt>; otherwise, <tt>false</tt>\n     */\n    public boolean isEnabled()\n    {\n        return enabled;\n    }\n\n    /**\n     * Sets the indicator which determines whether\n     * {@link CandidateHarvester#harvest(Component)} is to be called on the\n     * associated <tt>CandidateHarvester</tt>.\n     *\n     * @param enabled <tt>true</tt> if\n     * <tt>CandidateHarvester#harvest(Component)</tt> is to be called on the\n     * associated <tt>CandidateHarvester</tt>; otherwise, <tt>false</tt>\n     */\n    public void setEnabled(boolean enabled)\n    {\n        logger.fine((enabled ? \"Enabling: \" : \"Disabling: \") + harvester);\n        this.enabled = enabled;\n    }\n\n    /**\n     * Returns the <tt>CandidateHarvester</tt> encapsulated by this element.\n     *\n     * @return the <tt>CandidateHarvester</tt> encapsulated by this element.\n     */\n    public CandidateHarvester getHarvester()\n    {\n        return harvester;\n    }\n\n    /**\n     * Starts the harvesting timer. Called when the harvest begins.\n     */\n    private void startHarvestTiming()\n    {\n        harvester.getHarvestStatistics().startHarvestTiming();\n    }\n\n    /**\n     * Stops the harvesting timer. Called when the harvest ends.\n     *\n     * @param harvest the harvest that we just concluded.\n     */\n    private void stopHarvestTiming(Collection<LocalCandidate> harvest)\n    {\n        harvester.getHarvestStatistics().stopHarvestTiming(harvest);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(CandidateHarvesterSetElement.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>CandidateHarvesterSetElement</tt>\nclass and its instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(CandidateHarvesterSetElement.class.getName())", "syntax_pass": true}, {"attribute_expression": "private boolean enabled = true;", "docstring": "\nThe indicator which determines whether\n{@link CandidateHarvester#harvest(org.ice4j.ice.Component)} is to be\ncalled on {@link #harvester}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "enabled = true", "syntax_pass": true}, {"attribute_expression": "private final CandidateHarvester harvester;", "docstring": "\nThe <tt>CandidateHarvester</tt> which is an element in a\n<tt>CandidateHarvesterSet</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CandidateHarvester", "name": "harvester", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters", "name": "MappingCandidateHarvesters", "file_path": "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java", "superclasses": "", "methods": ["[MappingCandidateHarvester[]]getHarvesters()", "[MappingCandidateHarvester]findHarvesterForAddress(TransportAddress)", "[void]initialize()", "[List<MappingCandidateHarvester>]prune(List<MappingCandidateHarvester>)", "[void]maybeAdd(MappingCandidateHarvester,List<MappingCandidateHarvester>)", "[List<StunMappingCandidateHarvester>]createStunHarvesters(List<String>)", "[]MappingCandidateHarvesters()"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters.[MappingCandidateHarvester[]]getHarvesters()", "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters.[MappingCandidateHarvester]findHarvesterForAddress(TransportAddress)", "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters.[void]initialize()", "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters.[List<MappingCandidateHarvester>]prune(List<MappingCandidateHarvester>)", "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters.[void]maybeAdd(MappingCandidateHarvester,List<MappingCandidateHarvester>)", "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters.[List<StunMappingCandidateHarvester>]createStunHarvesters(List<String>)", "src/main/java/org/ice4j/ice/harvest/MappingCandidateHarvesters.java.MappingCandidateHarvesters.[]MappingCandidateHarvesters()"], "overrides": null, "attributes": [], "class_docstring": "\nManages a static list of {@link MappingCandidateHarvester} instances, created\naccording to configuration provided as system properties.\n\nThe instances in the set are safe to use by any {@code Agent}s.\n\n@author Damian Minkov\n@author Boris Grozev\n", "original_string": "public class MappingCandidateHarvesters\n{\n    /**\n     * The {@link Logger} used by the {@link MappingCandidateHarvesters}\n     * class for logging output.\n     */\n    private static final Logger logger = Logger.getLogger(MappingCandidateHarvesters.class.getName());\n\n    /**\n     * Whether {@link #harvesters} has been initialized.\n     */\n    private static boolean initialized = false;\n\n    /**\n     * The list of already configured harvesters.\n     */\n    private static MappingCandidateHarvester[] harvesters\n            = new MappingCandidateHarvester[0];\n\n    /**\n     * Whether the discovery of a public address via STUN has failed.\n     * It is considered failed if the configuration included at least one STUN\n     * server, but we failed to receive at least one valid response.\n     * Note that this defaults to false and is only raised after we are certain\n     * we failed (i.e. after our STUN transactions timeout).\n     */\n    public static boolean stunDiscoveryFailed = false;\n\n    /**\n     * @return the list of configured harvesters.\n     */\n    public static MappingCandidateHarvester[] getHarvesters()\n    {\n        initialize();\n        return harvesters;\n    }\n\n    /**\n     * @return  the (first) mapping harvester which matches a given public address, or {@code null} if none match it.\n     */\n    public static MappingCandidateHarvester findHarvesterForAddress(TransportAddress publicAddress)\n    {\n        for (MappingCandidateHarvester harvester : harvesters)\n        {\n            if (harvester.publicAddressMatches(publicAddress))\n            {\n                return harvester;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Initializes {@link #harvesters}.\n     * First it reads the configuration and instantiates harvesters accordingly,\n     * waiting for their initialization (which may include network communication\n     * and thus take a long time). Then it removes harvesters which failed to\n     * initialize properly and remove any harvesters with duplicate addresses.\n     *\n     * Three types of mapping harvesters are supported: NAT (with\n     * pre-configured addresses), AWS and STUN.\n     */\n    public static synchronized void initialize()\n    {\n        if (initialized)\n            return;\n        initialized = true;\n\n        long start = System.currentTimeMillis();\n        List<MappingCandidateHarvester> harvesterList = new LinkedList<>();\n\n        for (HarvestConfig.StaticMapping staticMapping : config.getStaticMappings())\n        {\n            logger.info(\"Adding a static mapping: \" + staticMapping);\n            // If the configuration has no port, then the port value is not used in any way. We put 9 (for \"discard\")\n            // as a filler.\n            int localPort = staticMapping.getLocalPort() != null ? staticMapping.getLocalPort() : 9;\n            int publicPort = staticMapping.getPublicPort() != null ? staticMapping.getPublicPort() : 9;\n            TransportAddress localAddress\n                    = new TransportAddress(staticMapping.getLocalAddress(), localPort, Transport.UDP);\n            TransportAddress publicAddress\n                    = new TransportAddress(staticMapping.getPublicAddress(), publicPort, Transport.UDP);\n\n            harvesterList.add(new StaticMappingCandidateHarvester(\n                    publicAddress,\n                    localAddress,\n                    staticMapping.getName(),\n                    staticMapping.getLocalPort() != null));\n        }\n\n        // AWS harvester\n        boolean enableAwsHarvester = config.enableAwsHarvester();\n        if (enableAwsHarvester && (config.forceAwsHarvester() || AwsCandidateHarvester.smellsLikeAnEC2()))\n        {\n            logger.info(\"Using AwsCandidateHarvester.\");\n            harvesterList.add(new AwsCandidateHarvester());\n        }\n\n        // STUN harvesters\n        List<String> stunServers = config.stunMappingCandidateHarvesterAddresses();\n        if (!stunServers.isEmpty())\n        {\n            // Create STUN harvesters (and wait for all of their discovery to finish).\n            List<StunMappingCandidateHarvester> stunHarvesters = createStunHarvesters(stunServers);\n\n            // We have STUN servers configured, so flag failure if none of them were able to discover an address.\n            stunDiscoveryFailed = stunHarvesters.isEmpty();\n\n            harvesterList.addAll(stunHarvesters);\n        }\n\n        harvesterList = prune(harvesterList);\n        harvesters = harvesterList.toArray(new MappingCandidateHarvester[harvesterList.size()]);\n\n        for (MappingCandidateHarvester harvester : harvesters)\n        {\n            logger.info(\"Using \" + harvester);\n        }\n        logger.info(\"Initialized mapping harvesters (delay=\"\n                        + (System.currentTimeMillis() - start) + \"ms). \"\n                        + \" stunDiscoveryFailed=\" + stunDiscoveryFailed);\n    }\n\n    /**\n     * Prunes a list of mapping harvesters, removing the ones without valid\n     * addresses and those with duplicate addresses.\n     * @param harvesters the list of harvesters.\n     * @return the pruned list.\n     */\n    private static List<MappingCandidateHarvester> prune(\n        List<MappingCandidateHarvester> harvesters)\n    {\n        List<MappingCandidateHarvester> pruned = new LinkedList<>();\n        for (MappingCandidateHarvester harvester : harvesters)\n        {\n            maybeAdd(harvester, pruned);\n        }\n        return pruned;\n    }\n\n    /**\n     * Adds {@code harvester} to {@code harvesters}, if it has valid addresses\n     * and {@code harvesters} doesn't already contain a harvester with the same\n     * addresses.\n     * @param harvester the harvester to add.\n     * @param harvesters the list to add to.\n     */\n    private static void maybeAdd(\n        MappingCandidateHarvester harvester,\n        List<MappingCandidateHarvester> harvesters)\n    {\n        TransportAddress face = harvester.getFace();\n        TransportAddress mask = harvester.getMask();\n        if (face == null || mask == null || face.equals(mask))\n        {\n            logger.info(\"Discarding a mapping harvester: \" + harvester);\n            return;\n        }\n\n        for (MappingCandidateHarvester h : harvesters)\n        {\n            if (face.getAddress().equals(h.getFace().getAddress())\n                && mask.getAddress().equals(h.getMask().getAddress()))\n            {\n                logger.info(\"Discarding a mapping harvester with duplicate addresses: \" + harvester + \". Kept: \" + h);\n                return;\n            }\n        }\n\n        harvesters.add(harvester);\n    }\n\n    /**\n     * Creates STUN mapping harvesters for each of the given STUN servers, and\n     * waits for address discovery to finish for all of them.\n     * @param stunServers an array of STUN server addresses (ip_address:port\n     * pairs).\n     * @return  the list of those who were successful in discovering an address.\n     */\n    private static List<StunMappingCandidateHarvester> createStunHarvesters(@NotNull List<String> stunServers)\n    {\n        List<StunMappingCandidateHarvester> stunHarvesters = new LinkedList<>();\n\n        List<Callable<StunMappingCandidateHarvester>> tasks = new LinkedList<>();\n\n        // Create a StunMappingCandidateHarvester for each local:remote address pair.\n        List<InetAddress> localAddresses = HostCandidateHarvester.getAllAllowedAddresses();\n        for (String stunServer : stunServers)\n        {\n            String[] addressAndPort = stunServer.split(\":\");\n            if (addressAndPort.length < 2)\n            {\n                logger.severe(\"Failed to parse STUN server address: \" + stunServer);\n                continue;\n            }\n            int port;\n            try\n            {\n                port = Integer.parseInt(addressAndPort[1]);\n            }\n            catch (NumberFormatException nfe)\n            {\n                logger.severe(\"Invalid STUN server port: \" + addressAndPort[1]);\n                continue;\n            }\n\n            TransportAddress remoteAddress\n                = new TransportAddress(\n                addressAndPort[0],\n                port,\n                Transport.UDP);\n\n            for (InetAddress localInetAddress : localAddresses)\n            {\n                if (localInetAddress instanceof Inet6Address)\n                {\n                    // This is disabled, because it is broken for an unknown\n                    // reason and it is not currently needed.\n                    continue;\n                }\n\n                TransportAddress localAddress = new TransportAddress(localInetAddress, 0, Transport.UDP);\n\n                logger.info(\"Using \" + remoteAddress + \" for StunMappingCandidateHarvester (localAddress=\"\n                        + localAddress + \").\");\n                final StunMappingCandidateHarvester stunHarvester\n                    = new StunMappingCandidateHarvester(localAddress, remoteAddress);\n\n                Callable<StunMappingCandidateHarvester> task = () ->\n                {\n                    stunHarvester.discover();\n                    return stunHarvester;\n                };\n                tasks.add(task);\n            }\n        }\n\n        if (tasks.isEmpty())\n        {\n            logger.warning(\"STUN mapping harvesters are configured, but no allowed local addresses were found.\" +\n                    \" Not using STUN.\");\n            return stunHarvesters;\n        }\n\n        // Now run discover() on all created harvesters in parallel and pick the ones which succeeded.\n        ExecutorService es = ExecutorFactory.createFixedThreadPool(tasks.size(), \"ice4j.Harvester-executor-\");\n\n        try\n        {\n            List<Future<StunMappingCandidateHarvester>> futures;\n            try\n            {\n                futures = es.invokeAll(tasks);\n            }\n            catch (InterruptedException ie)\n            {\n                Thread.currentThread().interrupt();\n                return stunHarvesters;\n            }\n\n            for (Future<StunMappingCandidateHarvester> future : futures)\n            {\n                try\n                {\n                    StunMappingCandidateHarvester harvester = future.get();\n\n                    // The STUN server replied successfully.\n                    if (harvester.getMask() != null)\n                    {\n                        stunHarvesters.add(harvester);\n                    }\n                }\n                catch (ExecutionException ee)\n                {\n                    // The harvester failed for some reason, discard it.\n                }\n                catch (InterruptedException ie)\n                {\n                    Thread.currentThread().interrupt();\n                    throw new RuntimeException(ie);\n                }\n            }\n        }\n        finally\n        {\n            es.shutdown();\n        }\n        return stunHarvesters;\n    }\n\n    /**\n     * Prevent instance creation.\n     */\n    private MappingCandidateHarvesters()\n    {\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger = Logger.getLogger(MappingCandidateHarvesters.class.getName());", "docstring": "\nThe {@link Logger} used by the {@link MappingCandidateHarvesters}\nclass for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger = Logger.getLogger(MappingCandidateHarvesters.class.getName())", "syntax_pass": true}, {"attribute_expression": "private static boolean initialized = false;", "docstring": "\nWhether {@link #harvesters} has been initialized.\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "boolean", "name": "initialized = false", "syntax_pass": true}, {"attribute_expression": "private static MappingCandidateHarvester[] harvesters\n            = new MappingCandidateHarvester[0];", "docstring": "\nThe list of already configured harvesters.\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "MappingCandidateHarvester[]", "name": "harvesters\n            = new MappingCandidateHarvester[0]", "syntax_pass": true}, {"attribute_expression": "public static boolean stunDiscoveryFailed = false;", "docstring": "\nWhether the discovery of a public address via STUN has failed.\nIt is considered failed if the configuration included at least one STUN\nserver, but we failed to receive at least one valid response.\nNote that this defaults to false and is only raised after we are certain\nwe failed (i.e. after our STUN transactions timeout).\n", "modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "type": "boolean", "name": "stunDiscoveryFailed = false", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics", "name": "HarvestStatistics", "file_path": "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java", "superclasses": "", "methods": ["[void]startHarvestTiming()", "[void]stopHarvestTiming(Collection<LocalCandidate>)", "[void]stopHarvestTiming(int)", "[long]getHarvestDuration()", "[int]getTotalCandidateCount()", "[int]getHarvestCount()", "[void]setName(String)", "[String]getName()", "[String]toString()"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[void]startHarvestTiming()", "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[void]stopHarvestTiming(Collection<LocalCandidate>)", "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[void]stopHarvestTiming(int)", "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[long]getHarvestDuration()", "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[int]getTotalCandidateCount()", "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[int]getHarvestCount()", "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[void]setName(String)", "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[String]getName()", "src/main/java/org/ice4j/ice/harvest/HarvestStatistics.java.HarvestStatistics.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nManages statistics about harvesting time.\n\n@author Vincent Lucas\n@author Emil Ivov\n", "original_string": "public class HarvestStatistics\n{\n    /**\n     * The number of harvesting for this harvester.\n     */\n    private int harvestCount = 0;\n\n    /**\n     * The last harvest start time for this harvester. -1 if this harvester is\n     * not currently harvesting.\n     */\n    private long lastStartHarvestingTime = -1;\n\n    /**\n     * The last ended harvesting time for this harvester. -1 if this harvester\n     * has never harvested yet.\n     */\n    private long lastHarvestingTime = 0;\n\n    /**\n     * The number of non-redundant candidates that this harvester has discovered\n     * during all its harvests.\n     */\n    private int totalCandidateCount = 0;\n\n    /**\n     * The name of the harvester associated with these stats.\n     */\n    protected String harvesterName;\n\n    /**\n     * Starts the harvesting timer. Called when the harvest begins.\n     */\n    protected void startHarvestTiming()\n    {\n        harvestCount++;\n        // Remember the start date of this harvester.\n        this.lastStartHarvestingTime = System.currentTimeMillis();\n    }\n\n    /**\n     * Stops the harvesting timer. Called when the harvest ends.\n     *\n     * @param harvest the harvest that we just concluded.\n     */\n    protected void stopHarvestTiming(Collection<LocalCandidate> harvest)\n    {\n        //count total candidates\n        if (harvest != null)\n            stopHarvestTiming(harvest.size());\n        else\n            stopHarvestTiming(0);\n\n    }\n\n    /**\n     * Stops the harvesting timer. Called when the harvest ends.\n     *\n     * @param candidateCount the number of candidates we harvested.\n     */\n    protected void stopHarvestTiming(int candidateCount)\n    {\n        // Remember the last harvesting time.\n        this.lastHarvestingTime = this.getHarvestDuration();\n        // Stops the current timer (must be done after setting the\n        // lastHarvestingTime).\n        this.lastStartHarvestingTime = -1;\n\n        //count total candidates\n        this.totalCandidateCount += candidateCount;\n    }\n\n    /**\n     * Returns the current harvesting time in ms. If this harvester is not\n     * currently harvesting, then returns the value of the last harvesting time.\n     * 0 if this harvester has never harvested.\n     *\n     * @return The current harvesting time in ms.\n     */\n    public long getHarvestDuration()\n    {\n        if (this.lastStartHarvestingTime != -1)\n        {\n            long currentHarvestingTime\n                = System.currentTimeMillis() - lastStartHarvestingTime;\n            // Retest here, while the harvesting may be end while computing the\n            // harvesting time.\n            if (this.lastStartHarvestingTime != -1)\n            {\n                return this.lastHarvestingTime + currentHarvestingTime;\n            }\n        }\n        // If we are ont currently harvesting, then returns the value of the\n        // last harvesting time.\n        return this.lastHarvestingTime;\n    }\n\n    /**\n     * Returns the number of candidates gathered  by the associated harvester.\n     *\n     * @return the total number of candidates gatherer by this harvester.\n     */\n    public int getTotalCandidateCount()\n    {\n        return totalCandidateCount;\n    }\n\n    /**\n     * Returns the number of harvests that the harvester associated with these\n     * statistics has completed so far.\n     *\n     * @return the number of harvests that the associated harvester has engaged\n     * in.\n     */\n    public int getHarvestCount()\n    {\n        return this.harvestCount;\n    }\n\n    /**\n     * Specifies the name of the associated harvester.\n     *\n     * @param harvesterName the name of the associated harvester.\n     */\n    protected void setName(String harvesterName)\n    {\n        this.harvesterName = harvesterName;\n    }\n\n    /**\n     * Returns the name of the associated harvester.\n     *\n     * @return the name of the associated harvester.\n     */\n    public String getName()\n    {\n        return harvesterName;\n    }\n\n    /**\n     * Returns a string representation of these statistics in a concise format.\n     *\n     * @return a string representation of these stats.\n     */\n    @Override\n    public String toString()\n    {\n        return harvesterName\n            + \": time=\"+getHarvestDuration()\n            + \"ms harvests=\"+getHarvestCount()\n            +\" candidates=\" + getTotalCandidateCount() ;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private int harvestCount = 0;", "docstring": "\nThe number of harvesting for this harvester.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "harvestCount = 0", "syntax_pass": true}, {"attribute_expression": "private long lastStartHarvestingTime = -1;", "docstring": "\nThe last harvest start time for this harvester. -1 if this harvester is\nnot currently harvesting.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "lastStartHarvestingTime = -1", "syntax_pass": true}, {"attribute_expression": "private long lastHarvestingTime = 0;", "docstring": "\nThe last ended harvesting time for this harvester. -1 if this harvester\nhas never harvested yet.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "lastHarvestingTime = 0", "syntax_pass": true}, {"attribute_expression": "private int totalCandidateCount = 0;", "docstring": "\nThe number of non-redundant candidates that this harvester has discovered\nduring all its harvests.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "totalCandidateCount = 0", "syntax_pass": true}, {"attribute_expression": "protected String harvesterName;", "docstring": "\nThe name of the harvester associated with these stats.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "harvesterName", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest", "name": "GoogleTurnCandidateHarvest", "file_path": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java", "superclasses": "StunCandidateHarvest", "methods": ["[]GoogleTurnCandidateHarvest(GoogleTurnCandidateHarvester,HostCandidate,String)", "[void]createCandidates(Response)", "[void]createRelayedCandidate(Response)", "[GoogleRelayedCandidate]createRelayedCandidate(TransportAddress,TransportAddress)", "[Request]createRequestToStartResolvingCandidate()", "[boolean]addShortTermCredentialAttributes(Request)", "[boolean]completedResolvingCandidate(Request,Response)", "[void]close(GoogleRelayedCandidateDatagramSocket)", "[boolean]processErrorOrFailure(Response,Request,TransactionID)", "[void]processSuccess(Response,Request,TransactionID)"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[]GoogleTurnCandidateHarvest(GoogleTurnCandidateHarvester,HostCandidate,String)", "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[void]createCandidates(Response)", "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[void]createRelayedCandidate(Response)", "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[GoogleRelayedCandidate]createRelayedCandidate(TransportAddress,TransportAddress)", "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[Request]createRequestToStartResolvingCandidate()", "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[boolean]addShortTermCredentialAttributes(Request)", "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[boolean]completedResolvingCandidate(Request,Response)", "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[void]close(GoogleRelayedCandidateDatagramSocket)", "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[boolean]processErrorOrFailure(Response,Request,TransactionID)", "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvest.java.GoogleTurnCandidateHarvest.[void]processSuccess(Response,Request,TransactionID)"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents the harvesting of Google TURN <tt>Candidates</tt> for a specific\n<tt>HostCandidate</tt> performed by a specific\n<tt>GoogleTurnCandidateHarvester</tt>.\n\n@author Lyubomir Marinov\n@author Sebastien Vincent\n", "original_string": "public class GoogleTurnCandidateHarvest\n    extends StunCandidateHarvest\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>TurnCandidateHarvest</tt> class and\n     * its instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(GoogleTurnCandidateHarvest.class.getName());\n\n    /**\n     * The <tt>Request</tt> created by the last call to\n     * {@link #createRequestToStartResolvingCandidate()}.\n     */\n    private Request requestToStartResolvingCandidate;\n\n    /**\n     * The gingle candidates password necessary to use the TURN server.\n     */\n    private String password;\n\n    /**\n     * Initializes a new <tt>TurnCandidateHarvest</tt> which is to represent the\n     * harvesting of TURN <tt>Candidate</tt>s for a specific\n     * <tt>HostCandidate</tt> performed by a specific\n     * <tt>TurnCandidateHarvester</tt>.\n     *\n     * @param harvester the <tt>TurnCandidateHarvester</tt> which is performing\n     * the TURN harvesting\n     * @param hostCandidate the <tt>HostCandidate</tt> for which TURN\n     * <tt>Candidate</tt>s are to be harvested\n     * @param password The gingle candidates password necessary to use this TURN\n     * server.\n     */\n    public GoogleTurnCandidateHarvest(\n            GoogleTurnCandidateHarvester harvester,\n            HostCandidate hostCandidate,\n            String password)\n    {\n        super(harvester, hostCandidate);\n        this.password = password;\n    }\n\n    /**\n     * Creates new <tt>Candidate</tt>s determined by a specific STUN\n     * <tt>Response</tt>.\n     *\n     * @param response the received STUN <tt>Response</tt>\n     * @see StunCandidateHarvest#createCandidates(Response)\n     */\n    @Override\n    protected void createCandidates(Response response)\n    {\n        createRelayedCandidate(response);\n    }\n\n    /**\n     * Creates a <tt>RelayedCandidate</tt> using the\n     * <tt>XOR-RELAYED-ADDRESS</tt> attribute in a specific STUN\n     * <tt>Response</tt> for the actual <tt>TransportAddress</tt> of the new\n     * candidate. If the message is malformed and/or does not contain the\n     * corresponding attribute, this method simply has no effect.\n     *\n     * @param response the STUN <tt>Response</tt> which is supposed to contain\n     * the address we should use for the new candidate\n     */\n    private void createRelayedCandidate(Response response)\n    {\n        Attribute attribute\n            = response.getAttribute(Attribute.MAPPED_ADDRESS);\n\n        if (attribute != null)\n        {\n            TransportAddress relayedAddress\n                = ((MappedAddressAttribute) attribute).getAddress();\n\n            if (harvester.stunServer.getTransport() == Transport.TCP)\n            {\n                relayedAddress = new TransportAddress(\n                    relayedAddress.getAddress(),\n                    harvester.stunServer.getPort(),\n                    //relayedAddress.getPort() - 1,\n                    Transport.TCP);\n            }\n            GoogleRelayedCandidate relayedCandidate\n                = createRelayedCandidate(\n                        relayedAddress,\n                        getMappedAddress(response));\n\n            if (relayedCandidate != null)\n            {\n                /*\n                 * The ICE connectivity checks will utilize STUN on the\n                 * (application-purposed) socket of the RelayedCandidate and\n                 * will not add it to the StunStack so we have to do it.\n                 */\n                harvester.getStunStack().addSocket(\n                        relayedCandidate.getStunSocket(null));\n\n                // Make the relayed candidate's socket available for reading\n                // by the component.\n                IceSocketWrapper candidateSocket\n                    = relayedCandidate.getCandidateIceSocketWrapper();\n\n                ComponentSocket componentSocket\n                    = relayedCandidate.getParentComponent().getComponentSocket();\n                if (componentSocket != null)\n                {\n                    componentSocket.add(candidateSocket);\n                }\n\n                addCandidate(relayedCandidate);\n            }\n        }\n    }\n\n    /**\n     * Creates a new <tt>RelayedCandidate</tt> instance which is to represent a\n     * specific <tt>TransportAddress</tt> harvested through\n     * {@link #hostCandidate} and the TURN server associated with\n     * {@link #harvester}.\n     *\n     * @param transportAddress the <tt>TransportAddress</tt> to be represented\n     * by the new <tt>RelayedCandidate</tt> instance\n     * @param mappedAddress the mapped <tt>TransportAddress</tt> reported by the\n     * TURN server with the delivery of the relayed <tt>transportAddress</tt> to\n     * be represented by the new <tt>RelayedCandidate</tt> instance\n     * @return a new <tt>RelayedCandidate</tt> instance which represents the\n     * specified <tt>TransportAddress</tt> harvested through\n     * {@link #hostCandidate} and the TURN server associated with\n     * {@link #harvester}\n     */\n    protected GoogleRelayedCandidate createRelayedCandidate(\n            TransportAddress transportAddress,\n            TransportAddress mappedAddress)\n    {\n        GoogleRelayedCandidate candidate =\n            new GoogleRelayedCandidate(\n                    transportAddress,\n                    this,\n                    mappedAddress,\n                    harvester.getShortTermCredentialUsername(),\n                    this.password);\n\n        candidate.setUfrag(harvester.getShortTermCredentialUsername());\n        return candidate;\n    }\n\n    /**\n     * Creates a new <tt>Request</tt> which is to be sent to\n     * {@link TurnCandidateHarvester#stunServer} in order to start resolving\n     * {@link #hostCandidate}.\n     *\n     * @return a new <tt>Request</tt> which is to be sent to\n     * {@link TurnCandidateHarvester#stunServer} in order to start resolving\n     * {@link #hostCandidate}\n     * @see StunCandidateHarvest#createRequestToStartResolvingCandidate()\n     */\n    @Override\n    protected Request createRequestToStartResolvingCandidate()\n    {\n        if (requestToStartResolvingCandidate == null)\n        {\n            requestToStartResolvingCandidate\n                = MessageFactory.createGoogleAllocateRequest(\n                        harvester.getShortTermCredentialUsername());\n\n            return requestToStartResolvingCandidate;\n        }\n        else\n            return null;\n    }\n\n    /**\n     * Adds the <tt>Attribute</tt>s to a specific <tt>Request</tt> which support\n     * the STUN short-term credential mechanism if the mechanism in question is\n     * utilized by this <tt>StunCandidateHarvest</tt> (i.e. by the associated\n     * <tt>StunCandidateHarvester</tt>).\n     *\n     * @param request the <tt>Request</tt> to which to add the\n     * <tt>Attribute</tt>s supporting the STUN short-term credential mechanism\n     * if the mechanism in question is utilized by this\n     * <tt>StunCandidateHarvest</tt>\n     * @return <tt>true</tt> if the STUN short-term credential mechanism is\n     * actually utilized by this <tt>StunCandidateHarvest</tt> for the specified\n     * <tt>request</tt>; otherwise, <tt>false</tt>\n     */\n    @Override\n    protected boolean addShortTermCredentialAttributes(Request request)\n    {\n        return false;\n    }\n\n    /**\n     * Completes the harvesting of <tt>Candidate</tt>s for\n     * {@link #hostCandidate}. Notifies {@link #harvester} about the completion\n     * of the harvesting of <tt>Candidate</tt> for <tt>hostCandidate</tt>\n     * performed by this <tt>StunCandidateHarvest</tt>.\n     *\n     * @param request the <tt>Request</tt> sent by this\n     * <tt>StunCandidateHarvest</tt> with which the harvesting of\n     * <tt>Candidate</tt>s for <tt>hostCandidate</tt> has completed\n     * @param response the <tt>Response</tt> received by this\n     * <tt>StunCandidateHarvest</tt>, if any, with which the harvesting of\n     * <tt>Candidate</tt>s for <tt>hostCandidate</tt> has completed\n     * @return <tt>true</tt> if the harvesting of <tt>Candidate</tt>s for\n     * <tt>hostCandidate</tt> performed by this <tt>StunCandidateHarvest</tt>\n     * has completed; otherwise, <tt>false</tt>\n     * @see StunCandidateHarvest#completedResolvingCandidate(Request, Response)\n     */\n    @Override\n    protected boolean completedResolvingCandidate(\n            Request request,\n            Response response)\n    {\n        if ((response == null)\n                || (!response.isSuccessResponse()\n                        && (request.getMessageType()\n                                == Message.ALLOCATE_REQUEST)))\n        {\n            try\n            {\n                if (startResolvingCandidate())\n                    return false;\n            }\n            catch (Exception ex)\n            {\n                /*\n                 * Complete the harvesting of Candidates for hostCandidate\n                 * because the new attempt has just failed.\n                 */\n            }\n        }\n        return super.completedResolvingCandidate(request, response);\n    }\n\n    /**\n     * Notifies this <tt>TurnCandidateHarvest</tt> that a specific\n     * <tt>RelayedCandidateDatagramSocket</tt> is closing and that this instance\n     * is to delete the associated TURN Allocation.\n     * <p>\n     * <b>Note</b>: The method is part of the internal API of\n     * <tt>RelayedCandidateDatagramSocket</tt> and <tt>TurnCandidateHarvest</tt>\n     * and is not intended for public use.\n     * </p>\n     *\n     * @param relayedCandidateSocket the <tt>RelayedCandidateDatagramSocket</tt>\n     * which notifies this instance and which requests that the associated TURN\n     * Allocation be deleted\n     */\n    public void close(\n            GoogleRelayedCandidateDatagramSocket relayedCandidateSocket)\n    {\n        /*\n         * FIXME As far as logic goes, it seems that it is possible to send a\n         * TURN Refresh, cancel the STUN keep-alive functionality here and only\n         * then receive the response to the TURN Refresh which will enable the\n         * STUN keep-alive functionality again.\n         */\n        setSendKeepAliveMessageInterval(\n                SEND_KEEP_ALIVE_MESSAGE_INTERVAL_NOT_SPECIFIED);\n    }\n\n    /**\n     * Notifies this <tt>StunCandidateHarvest</tt> that a specific\n     * <tt>Request</tt> has either received an error <tt>Response</tt> or has\n     * failed to receive any <tt>Response</tt>.\n     *\n     * @param response the error <tt>Response</tt> which has been received for\n     * <tt>request</tt>\n     * @param request the <tt>Request</tt> to which <tt>Response</tt> responds\n     * @param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n     * <tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\n     * it as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\n     * the <tt>applicationData</tt> property value\n     * @return <tt>true</tt> if the error or failure condition has been\n     * processed and this instance can continue its execution (e.g. the\n     * resolution of the candidate) as if it was expected; otherwise,\n     * <tt>false</tt>\n     * @see StunCandidateHarvest#processErrorOrFailure(Response, Request,\n     * TransactionID)\n     */\n    @Override\n    protected boolean processErrorOrFailure(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n    {\n        logger.info(\"Google TURN processErrorOrFailure\");\n        /*\n         * TurnCandidateHarvest uses the applicationData of TransactionID to\n         * deliver the results of Requests sent by\n         * RelayedCandidateDatagramSocket back to it.\n         */\n        Object applicationData = transactionID.getApplicationData();\n\n        if ((applicationData instanceof GoogleRelayedCandidateDatagramSocket)\n                && ((RelayedCandidateDatagramSocket) applicationData)\n                        .processErrorOrFailure(response, request))\n            return true;\n        else if ((applicationData instanceof\n            GoogleRelayedCandidateDatagramSocket)\n            && ((RelayedCandidateDatagramSocket) applicationData)\n                    .processErrorOrFailure(response, request))\n        return true;\n\n        return super.processErrorOrFailure(response, request, transactionID);\n    }\n\n    /**\n     * Handles a specific STUN success <tt>Response</tt> to a specific STUN\n     * <tt>Request</tt>.\n     *\n     * @param response the received STUN success <tt>Response</tt> which is to\n     * be handled\n     * @param request the STUN <tt>Request</tt> to which <tt>response</tt>\n     * responds\n     * @param transactionID the <tt>TransactionID</tt> of <tt>response</tt> and\n     * <tt>request</tt> because <tt>response</tt> and <tt>request</tt> only have\n     * it as a <tt>byte</tt> array and <tt>TransactionID</tt> is required for\n     * the <tt>applicationData</tt> property value\n     * @see StunCandidateHarvest#processSuccess(Response, Request,\n     * TransactionID)\n     */\n    @Override\n    protected void processSuccess(\n            Response response,\n            Request request,\n            TransactionID transactionID)\n    {\n        super.processSuccess(response, request, transactionID);\n\n        LifetimeAttribute lifetimeAttribute;\n        int lifetime /* minutes */ = -1;\n\n        switch (response.getMessageType())\n        {\n        case Message.ALLOCATE_RESPONSE:\n            // The default lifetime of an allocation is 10 minutes.\n            // The default lifetime of an allocation is 10 minutes.\n            lifetimeAttribute\n                = (LifetimeAttribute) response.getAttribute(Attribute.LIFETIME);\n            lifetime\n                = (lifetimeAttribute == null)\n                    ? (10 * 60)\n                    : lifetimeAttribute.getLifetime();\n            logger.info(\"Successful Google TURN allocate\");\n            break;\n        default:\n            break;\n        }\n\n        if (lifetime >= 0)\n        {\n            setSendKeepAliveMessageInterval(\n                    /* milliseconds */ 1000L * lifetime);\n        }\n\n        /*\n         * TurnCandidateHarvest uses the applicationData of TransactionID to\n         * deliver the results of Requests sent by\n         * RelayedCandidateDatagramSocket back to it.\n         */\n        Object applicationData = transactionID.getApplicationData();\n\n        if (applicationData instanceof GoogleRelayedCandidateDatagramSocket)\n        {\n            ((GoogleRelayedCandidateDatagramSocket) applicationData)\n                .processSuccess(response, request);\n        }\n        else if (applicationData instanceof GoogleRelayedCandidateSocket)\n        {\n            ((GoogleRelayedCandidateSocket) applicationData)\n                .processSuccess(response, request);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(GoogleTurnCandidateHarvest.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>TurnCandidateHarvest</tt> class and\nits instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(GoogleTurnCandidateHarvest.class.getName())", "syntax_pass": true}, {"attribute_expression": "private Request requestToStartResolvingCandidate;", "docstring": "\nThe <tt>Request</tt> created by the last call to\n{@link #createRequestToStartResolvingCandidate()}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Request", "name": "requestToStartResolvingCandidate", "syntax_pass": true}, {"attribute_expression": "private String password;", "docstring": "\nThe gingle candidates password necessary to use the TURN server.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "password", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester", "name": "StunCandidateHarvester", "file_path": "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java", "superclasses": "AbstractCandidateHarvester", "methods": ["[]StunCandidateHarvester(TransportAddress)", "[]StunCandidateHarvester(TransportAddress,String)", "[void]completedResolvingCandidate(StunCandidateHarvest)", "[StunCandidateHarvest]createHarvest(HostCandidate)", "[LongTermCredential]createLongTermCredential(StunCandidateHarvest,byte[])", "[String]getShortTermCredentialUsername()", "[StunStack]getStunStack()", "[Collection<LocalCandidate>]harvest(Component)", "[String]listCandidates(Collection<? extends Candidate<?>>)", "[void]startResolvingCandidate(HostCandidate)", "[void]waitForResolutionEnd()", "[String]toString()", "[HostCandidate]getHostCandidate(HostCandidate)"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[]StunCandidateHarvester(TransportAddress)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[]StunCandidateHarvester(TransportAddress,String)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[void]completedResolvingCandidate(StunCandidateHarvest)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[StunCandidateHarvest]createHarvest(HostCandidate)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[LongTermCredential]createLongTermCredential(StunCandidateHarvest,byte[])", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[String]getShortTermCredentialUsername()", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[StunStack]getStunStack()", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[Collection<LocalCandidate>]harvest(Component)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[String]listCandidates(Collection<? extends Candidate<?>>)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[void]startResolvingCandidate(HostCandidate)", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[void]waitForResolutionEnd()", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[String]toString()", "src/main/java/org/ice4j/ice/harvest/StunCandidateHarvester.java.StunCandidateHarvester.[HostCandidate]getHostCandidate(HostCandidate)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a <tt>CandidateHarvester</tt> which gathers <tt>Candidate</tt>s\nfor a specified {@link Component} using STUN as defined in RFC 5389 \"Session\nTraversal Utilities for NAT (STUN)\" only.\n\n@author Emil Ivov\n@author Lyubomir Marinov\n", "original_string": "public class StunCandidateHarvester\n    extends AbstractCandidateHarvester\n{\n\n    /**\n     * The <tt>Logger</tt> used by the <tt>StunCandidateHarvester</tt> class and\n     * its instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(StunCandidateHarvester.class.getName());\n\n    /**\n     * The list of <tt>StunCandidateHarvest</tt>s which have been successfully\n     * completed i.e. have harvested <tt>Candidate</tt>s.\n     */\n    private final List<StunCandidateHarvest> completedHarvests\n        = new LinkedList<>();\n\n    /**\n     * The username used by this <tt>StunCandidateHarvester</tt> for the\n     * purposes of the STUN short-term credential mechanism.\n     */\n    private final String shortTermCredentialUsername;\n\n    /**\n     * The list of <tt>StunCandidateHarvest</tt>s which have been started to\n     * harvest <tt>Candidate</tt>s for <tt>HostCandidate</tt>s and which have\n     * not completed yet so {@link #harvest(Component)} has to wait for them.\n     */\n    private final List<StunCandidateHarvest> startedHarvests\n        = new LinkedList<>();\n\n    /**\n     * The address of the STUN server that we will be sending our requests to.\n     */\n    public final TransportAddress stunServer;\n\n    /**\n     * The <tt>StunStack</tt> used by this instance for the purposes of STUN\n     * communication.\n     */\n    private StunStack stunStack;\n\n    /**\n     * Creates a new STUN harvester that will be running against the specified\n     * <tt>stunServer</tt> using a specific username for the purposes of the\n     * STUN short-term credential mechanism.\n     *\n     * @param stunServer the address of the STUN server that we will be querying\n     * for our public bindings\n     */\n    public StunCandidateHarvester(TransportAddress stunServer)\n    {\n        this(stunServer, null);\n    }\n\n    /**\n     * Creates a new STUN harvester that will be running against the specified\n     * <tt>stunServer</tt> using a specific username for the purposes of the\n     * STUN short-term credential mechanism.\n     *\n     * @param stunServer the address of the STUN server that we will be querying\n     * for our public bindings\n     * @param shortTermCredentialUsername the username to be used by the new\n     * instance for the purposes of the STUN short-term credential mechanism or\n     * <tt>null</tt> if the use of the STUN short-term credential mechanism is\n     * not determined at the time of the construction of the new instance\n     */\n    public StunCandidateHarvester(\n            TransportAddress stunServer,\n            String shortTermCredentialUsername)\n    {\n        this.stunServer = stunServer;\n        this.shortTermCredentialUsername = shortTermCredentialUsername;\n\n        //these should be configurable.\n        if (System.getProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER) == null)\n            System.setProperty(StackProperties.MAX_CTRAN_RETRANS_TIMER, \"400\");\n        if (System.getProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS) == null)\n            System.setProperty(StackProperties.MAX_CTRAN_RETRANSMISSIONS, \"3\");\n    }\n\n    /**\n     * Notifies this <tt>StunCandidateHarvester</tt> that a specific\n     * <tt>StunCandidateHarvest</tt> has been completed. If the specified\n     * harvest has harvested <tt>Candidates</tt>, it is moved from\n     * {@link #startedHarvests} to {@link #completedHarvests}. Otherwise, it is\n     * just removed from {@link #startedHarvests}.\n     *\n     * @param harvest the <tt>StunCandidateHarvest</tt> which has been completed\n     */\n    void completedResolvingCandidate(StunCandidateHarvest harvest)\n    {\n        boolean doNotify = false;\n\n        synchronized (startedHarvests)\n        {\n            startedHarvests.remove(harvest);\n\n            // If this was the last candidate, we are done with the STUN\n            // resolution and need to notify the waiters.\n            if (startedHarvests.isEmpty())\n                doNotify = true;\n        }\n\n        synchronized (completedHarvests)\n        {\n            if (harvest.getCandidateCount() < 1)\n                completedHarvests.remove(harvest);\n            else if (!completedHarvests.contains(harvest))\n                completedHarvests.add(harvest);\n        }\n\n        synchronized(startedHarvests)\n        {\n            if (doNotify)\n                startedHarvests.notify();\n        }\n    }\n\n    /**\n     * Creates a new <tt>StunCandidateHarvest</tt> instance which is to perform\n     * STUN harvesting of a specific <tt>HostCandidate</tt>.\n     *\n     * @param hostCandidate the <tt>HostCandidate</tt> for which harvesting is\n     * to be performed by the new <tt>StunCandidateHarvest</tt> instance\n     * @return a new <tt>StunCandidateHarvest</tt> instance which is to perform\n     * STUN harvesting of the specified <tt>hostCandidate</tt>\n     */\n    protected StunCandidateHarvest createHarvest(HostCandidate hostCandidate)\n    {\n        return new StunCandidateHarvest(this, hostCandidate);\n    }\n\n    /**\n     * Creates a <tt>LongTermCredential</tt> to be used by a specific\n     * <tt>StunCandidateHarvest</tt> for the purposes of the long-term\n     * credential mechanism in a specific <tt>realm</tt> of the STUN server\n     * associated with this <tt>StunCandidateHarvester</tt>. The default\n     * implementation returns <tt>null</tt> and allows extenders to override in\n     * order to support the long-term credential mechanism.\n     *\n     * @param harvest the <tt>StunCandidateHarvest</tt> which asks for the\n     * <tt>LongTermCredential</tt>\n     * @param realm the realm of the STUN server associated with this\n     * <tt>StunCandidateHarvester</tt> in which <tt>harvest</tt> will use the\n     * returned <tt>LongTermCredential</tt>\n     * @return a <tt>LongTermCredential</tt> to be used by <tt>harvest</tt> for\n     * the purposes of the long-term credential mechanism in the specified\n     * <tt>realm</tt> of the STUN server associated with this\n     * <tt>StunCandidateHarvester</tt>\n     */\n    protected LongTermCredential createLongTermCredential(\n            StunCandidateHarvest harvest,\n            byte[] realm)\n    {\n        // The long-term credential mechanism is not utilized by default.\n        return null;\n    }\n\n    /**\n     * Gets the username to be used by this <tt>StunCandidateHarvester</tt> for\n     * the purposes of the STUN short-term credential mechanism.\n     *\n     * @return the username to be used by this <tt>StunCandidateHarvester</tt>\n     * for the purposes of the STUN short-term credential mechanism or\n     * <tt>null</tt> if the STUN short-term credential mechanism is not to be\n     * utilized\n     */\n    protected String getShortTermCredentialUsername()\n    {\n        return shortTermCredentialUsername;\n    }\n\n    /**\n     * Gets the <tt>StunStack</tt> used by this <tt>CandidateHarvester</tt> for\n     * the purposes of STUN communication. It is guaranteed to be available only\n     * during the execution of {@link CandidateHarvester#harvest(Component)}.\n     *\n     * @return the <tt>StunStack</tt> used by this <tt>CandidateHarvester</tt>\n     * for the purposes of STUN communication\n     * @see CandidateHarvester#harvest(Component)\n     */\n    public StunStack getStunStack()\n    {\n        return stunStack;\n    }\n\n    /**\n     * Gathers STUN candidates for all host <tt>Candidate</tt>s that are already\n     * present in the specified <tt>component</tt>. This method relies on the\n     * specified <tt>component</tt> to already contain all its host candidates\n     * so that it would resolve them.\n     *\n     * @param component the {@link Component} that we'd like to gather candidate\n     * STUN <tt>Candidate</tt>s for\n     * @return  the <tt>LocalCandidate</tt>s gathered by this\n     * <tt>CandidateHarvester</tt>\n     */\n    @Override\n    public Collection<LocalCandidate> harvest(Component component)\n    {\n        if (logger.isLoggable(Level.FINE))\n        {\n            logger.fine(\"starting \" + component.toShortString()\n                            + \" harvest for: \" + toString());\n        }\n        stunStack = component.getParentStream().getParentAgent().getStunStack();\n\n        for (Candidate<?> cand : component.getLocalCandidates())\n        {\n            if ((cand instanceof HostCandidate)\n                    && (cand.getTransport() == stunServer.getTransport()))\n            {\n                startResolvingCandidate((HostCandidate) cand);\n            }\n        }\n\n        waitForResolutionEnd();\n\n        /*\n         * Report the LocalCandidates gathered by this CandidateHarvester so\n         * that the harvest is sure to be considered successful.\n         */\n        Collection<LocalCandidate> candidates = new HashSet<>();\n\n        synchronized (completedHarvests)\n        {\n            for (StunCandidateHarvest completedHarvest : completedHarvests)\n            {\n                LocalCandidate[] completedHarvestCandidates\n                    = completedHarvest.getCandidates();\n\n                if ((completedHarvestCandidates != null)\n                        && (completedHarvestCandidates.length != 0))\n                {\n                    candidates.addAll(\n                            Arrays.asList(completedHarvestCandidates));\n                }\n            }\n\n            completedHarvests.clear();\n        }\n\n        logger.finest(\n                \"Completed \" + component.toShortString() + \" harvest: \"\n                    + toString() + \". Found \" + candidates.size()\n                    + \" candidates: \" + listCandidates(candidates));\n\n        return candidates;\n    }\n\n    private String listCandidates(Collection<? extends Candidate<?>> candidates)\n    {\n        StringBuilder retval = new StringBuilder();\n        for (Candidate<?> candidate : candidates)\n        {\n            retval.append(candidate.toShortString());\n        }\n        return retval.toString();\n    }\n\n    /**\n     * Sends a binding request to our stun server through the specified\n     * <tt>hostCand</tt> candidate and adds it to the list of addresses still\n     * waiting for resolution.\n     *\n     * @param hostCand the <tt>HostCandidate</tt> that we'd like to resolve.\n     */\n    private void startResolvingCandidate(HostCandidate hostCand)\n    {\n        //first of all, make sure that the STUN server and the Candidate\n        //address are of the same type and that they can communicate.\n        if (!hostCand.getTransportAddress().canReach(stunServer))\n            return;\n\n        HostCandidate cand = getHostCandidate(hostCand);\n\n        if (cand == null)\n        {\n            logger.info(\n                    \"server/candidate address type mismatch,\"\n                        + \" skipping candidate in this harvester\");\n            return;\n        }\n\n        StunCandidateHarvest harvest = createHarvest(cand);\n\n        if (harvest == null)\n        {\n            logger.warning(\"failed to create harvest\");\n            return;\n        }\n\n        synchronized (startedHarvests)\n        {\n            startedHarvests.add(harvest);\n\n            boolean started = false;\n\n            try\n            {\n                started = harvest.startResolvingCandidate();\n            }\n            catch (Exception ex)\n            {\n                started = false;\n                if (logger.isLoggable(Level.INFO))\n                {\n                    logger.log(\n                            Level.INFO,\n                            \"Failed to start resolving host candidate \"\n                                + hostCand,\n                            ex);\n                }\n            }\n            finally\n            {\n                if (!started)\n                {\n                    try\n                    {\n                        startedHarvests.remove(harvest);\n                        logger.warning(\n                                \"harvest did not start, removed: \" + harvest);\n                    }\n                    finally\n                    {\n                        /*\n                         * For the sake of completeness, explicitly close the\n                         * harvest.\n                         */\n                        try\n                        {\n                            harvest.close();\n                        }\n                        catch (Exception ex)\n                        {\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Blocks the current thread until all resolutions in this harvester\n     * have terminated one way or another.\n     */\n    private void waitForResolutionEnd()\n    {\n        synchronized(startedHarvests)\n        {\n            boolean interrupted = false;\n\n            // Handle spurious wakeups.\n            while (!startedHarvests.isEmpty())\n            {\n                try\n                {\n                    startedHarvests.wait();\n                }\n                catch (InterruptedException iex)\n                {\n                    logger.info(\n                            \"interrupted waiting for harvests to complete,\"\n                                + \" no. startedHarvests = \"\n                                + startedHarvests.size());\n                    interrupted = true;\n                }\n            }\n            // Restore the interrupted status.\n            if (interrupted)\n                Thread.currentThread().interrupt();\n        }\n    }\n\n    /**\n     * Returns a <tt>String</tt> representation of this harvester containing its\n     * type and server address.\n     *\n     * @return a <tt>String</tt> representation of this harvester containing its\n     * type and server address.\n     */\n    @Override\n    public String toString()\n    {\n        String proto = (this instanceof TurnCandidateHarvester)\n                                ? \"TURN\"\n                                : \"STUN\";\n        return proto + \" harvester(srvr: \" + this.stunServer + \")\";\n    }\n\n    /**\n     * Returns the host candidate.\n     * For UDP it simply returns the candidate passed as a parameter.\n     *\n     * However for TCP, we cannot return the same hostCandidate because in Java\n     * a  \"server\" socket cannot connect to a destination with the same local\n     * address/port (i.e. a Java Socket cannot act as both server/client).\n     *\n     * @param hostCand HostCandidate\n     * @return HostCandidate\n     */\n    protected HostCandidate getHostCandidate(HostCandidate hostCand)\n    {\n        HostCandidate cand;\n\n        // create a new TCP HostCandidate\n        if (hostCand.getTransport() == Transport.TCP)\n        {\n            try\n            {\n                Socket sock = new Socket(stunServer.getAddress(),\n                    stunServer.getPort());\n                MultiplexingSocket multiplexing = new MultiplexingSocket(sock);\n                Component component = hostCand.getParentComponent();\n                cand\n                    = new HostCandidate(\n                            new IceTcpSocketWrapper(multiplexing),\n                            component,\n                            Transport.TCP);\n                component.getParentStream().\n                    getParentAgent().getStunStack().addSocket(\n                        cand.getStunSocket(null));\n\n                ComponentSocket componentSocket\n                    = component.getComponentSocket();\n                if (componentSocket != null)\n                {\n                    componentSocket.add(multiplexing);\n                }\n            }\n            catch(Exception io)\n            {\n                logger.info(\"Exception TCP client connect: \" + io);\n                return null;\n            }\n        }\n        else\n        {\n            cand = hostCand;\n        }\n\n        return cand;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(StunCandidateHarvester.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>StunCandidateHarvester</tt> class and\nits instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(StunCandidateHarvester.class.getName())", "syntax_pass": true}, {"attribute_expression": "private final List<StunCandidateHarvest> completedHarvests\n        = new LinkedList<>();", "docstring": "\nThe list of <tt>StunCandidateHarvest</tt>s which have been successfully\ncompleted i.e. have harvested <tt>Candidate</tt>s.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<StunCandidateHarvest>", "name": "completedHarvests\n        = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private final String shortTermCredentialUsername;", "docstring": "\nThe username used by this <tt>StunCandidateHarvester</tt> for the\npurposes of the STUN short-term credential mechanism.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "shortTermCredentialUsername", "syntax_pass": true}, {"attribute_expression": "private final List<StunCandidateHarvest> startedHarvests\n        = new LinkedList<>();", "docstring": "\nThe list of <tt>StunCandidateHarvest</tt>s which have been started to\nharvest <tt>Candidate</tt>s for <tt>HostCandidate</tt>s and which have\nnot completed yet so {@link #harvest(Component)} has to wait for them.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<StunCandidateHarvest>", "name": "startedHarvests\n        = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "public final TransportAddress stunServer;", "docstring": "\nThe address of the STUN server that we will be sending our requests to.\n", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "TransportAddress", "name": "stunServer", "syntax_pass": true}, {"attribute_expression": "private StunStack stunStack;", "docstring": "\nThe <tt>StunStack</tt> used by this instance for the purposes of STUN\ncommunication.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StunStack", "name": "stunStack", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet", "name": "CandidateHarvesterSet", "file_path": "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java", "superclasses": "", "methods": ["[]CandidateHarvesterSet()", "[boolean]add(CandidateHarvester)", "[void]harvest(Component)", "[void]harvest(List<Component>,TrickleCallback)", "[void]harvest(Iterator<CandidateHarvesterSetElement>,List<Component>,ExecutorService,TrickleCallback)", "[Iterator<CandidateHarvester>]iterator()", "[int]size()"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet.[]CandidateHarvesterSet()", "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet.[boolean]add(CandidateHarvester)", "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet.[void]harvest(Component)", "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet.[void]harvest(List<Component>,TrickleCallback)", "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet.[void]harvest(Iterator<CandidateHarvesterSetElement>,List<Component>,ExecutorService,TrickleCallback)", "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet.[Iterator<CandidateHarvester>]iterator()", "src/main/java/org/ice4j/ice/harvest/CandidateHarvesterSet.java.CandidateHarvesterSet.[int]size()"], "overrides": null, "attributes": [], "class_docstring": "\nImplements {@link Set} of <tt>CandidateHarvester</tt>s which runs the\ngathering of candidate addresses performed by its elements in parallel.\n\n@author Lyubomir Marinov\n", "original_string": "public class CandidateHarvesterSet\n    extends AbstractSet<CandidateHarvester>\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>Agent</tt> class and its instances\n     * for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(CandidateHarvesterSet.class.getName());\n\n    /**\n     * The <tt>CandidateHarvester</tt>s which are the elements of this\n     * <tt>Set</tt>.\n     */\n    private final Collection<CandidateHarvesterSetElement> elements\n        = new LinkedList<>();\n\n    /**\n     * A pool of thread used for gathering process.\n     */\n    private static ExecutorService threadPool = Executors.newCachedThreadPool();\n\n    /**\n     * Initializes a new <tt>CandidateHarvesterSet</tt> instance.\n     */\n    public CandidateHarvesterSet()\n    {\n    }\n\n    /**\n     * Adds a specific <tt>CandidateHarvester</tt> to this\n     * <tt>CandidateHarvesterSet</tt> and returns <tt>true</tt> if it is not\n     * already present. Otherwise, leaves this set unchanged and returns\n     * <tt>false</tt>.\n     *\n     * @param harvester the <tt>CandidateHarvester</tt> to be added to this\n     * <tt>CandidateHarvesterSet</tt>\n     * @return <tt>true</tt> if this <tt>CandidateHarvesterSet</tt> did not\n     * already contain the specified <tt>harvester</tt>; otherwise,\n     * <tt>false</tt>\n     * @see Set#add(Object)\n     */\n    @Override\n    public boolean add(CandidateHarvester harvester)\n    {\n        synchronized (elements)\n        {\n            for (CandidateHarvesterSetElement element : elements)\n                if (element.harvesterEquals(harvester))\n                    return false;\n\n            elements.add(new CandidateHarvesterSetElement(harvester));\n            return true;\n        }\n    }\n\n    /**\n     * Gathers candidate addresses for a specific <tt>Component</tt>.\n     * <tt>CandidateHarvesterSet</tt> delegates to the\n     * <tt>CandidateHarvester</tt>s which are its <tt>Set</tt> elements.\n     *\n     * @param component the <tt>Component</tt> to gather candidate addresses for\n     * @see CandidateHarvester#harvest(Component)\n     */\n    public void harvest(Component component)\n    {\n        harvest(Arrays.asList(component), null);\n    }\n\n\n    /**\n     * Gathers candidate addresses for a specific <tt>Component</tt>.\n     * <tt>CandidateHarvesterSet</tt> delegates to the\n     * <tt>CandidateHarvester</tt>s which are its <tt>Set</tt> elements.\n     *\n     * @param components the <tt>Component</tt> to gather candidate addresses for\n     * @see CandidateHarvester#harvest(Component)\n     * @param trickleCallback the {@link TrickleCallback} that we will be\n     * feeding candidates to, or <tt>null</tt> in case the application doesn't\n     * want us trickling any candidates\n     */\n    public void harvest(final List<Component> components,\n                              TrickleCallback trickleCallback)\n    {\n        synchronized (elements)\n        {\n            harvest(\n                elements.iterator(), components, threadPool, trickleCallback);\n        }\n    }\n\n    /**\n     * Gathers candidate addresses for a specific <tt>Component</tt> using\n     * specific <tt>CandidateHarvester</tt>s.\n     *\n     * @param harvesters the <tt>CandidateHarvester</tt>s to gather candidate\n     * addresses for the specified <tt>Component</tt>\n     * @param components the <tt>Component</tt>s to gather candidate addresses\n     * for.\n     * @param executorService the <tt>ExecutorService</tt> to schedule the\n     * execution of the gathering of candidate addresses performed by the\n     * specified <tt>harvesters</tt>\n     * @param trickleCallback the {@link TrickleCallback} that we will be\n     * feeding candidates to, or <tt>null</tt> in case the application doesn't\n     * want us trickling any candidates\n     */\n    private void harvest(\n            final Iterator<CandidateHarvesterSetElement> harvesters,\n            final List<Component>                        components,\n                  ExecutorService                        executorService,\n            final TrickleCallback                        trickleCallback)\n    {\n        /*\n         * Start asynchronously executing the\n         * CandidateHarvester#harvest(Component) method of the harvesters.\n         */\n        Map<CandidateHarvesterSetTask, Future<?>> tasks = new HashMap<>();\n\n        while (true)\n        {\n            /*\n             * Find the next CandidateHarvester which is to start gathering\n             * candidates.\n             */\n            CandidateHarvesterSetElement harvester;\n\n            synchronized (harvesters)\n            {\n                if (harvesters.hasNext())\n                    harvester = harvesters.next();\n                else\n                    break;\n            }\n\n            if (!harvester.isEnabled())\n                continue;\n\n            List<Component> componentsCopy;\n\n            synchronized (components)\n            {\n                componentsCopy = new ArrayList<>(components);\n            }\n\n            // Asynchronously start gathering candidates using the harvester.\n            CandidateHarvesterSetTask task = new CandidateHarvesterSetTask(\n                harvester, componentsCopy, trickleCallback);\n\n            tasks.put(task, executorService.submit(task));\n        }\n\n        /*\n         * Wait for all harvesters to be given a chance to execute their\n         * CandidateHarvester#harvest(Component) method.\n         */\n        Iterator<Map.Entry<CandidateHarvesterSetTask, Future<?>>> taskIter\n            = tasks.entrySet().iterator();\n\n        while (taskIter.hasNext())\n        {\n            Map.Entry<CandidateHarvesterSetTask, Future<?>> task\n                = taskIter.next();\n            Future<?> future = task.getValue();\n\n            do\n            {\n                try\n                {\n                    future.get(HarvestConfig.config.timeout().toMillis(), TimeUnit.MILLISECONDS);\n                    break;\n                }\n                catch (TimeoutException te)\n                {\n                    CandidateHarvesterSetElement harvester = task.getKey().getHarvester();\n                    if (harvester != null)\n                    {\n                        harvester.setEnabled(false);\n                    }\n                    logger.warning(\"timed out while harvesting from \" + harvester);\n                    break;\n                }\n                catch (CancellationException ce)\n                {\n                    logger.info(\"harvester cancelled\");\n                    /*\n                     * It got cancelled so we cannot say that the fault is with\n                     * its current harvester.\n                     */\n                    break;\n                }\n                catch (ExecutionException ee)\n                {\n                    CandidateHarvesterSetElement harvester\n                        = task.getKey().getHarvester();\n\n                    /*\n                     * A problem appeared during the execution of the task.\n                     * CandidateHarvesterSetTask clears its harvester property\n                     * for the purpose of determining whether the problem has\n                     * appeared while working with a harvester.\n                     */\n                    logger.info(\n                        \"disabling harvester \"+ harvester.getHarvester()\n                            + \" due to ExecutionException: \" +\n                            ee.getLocalizedMessage());\n\n                    if (harvester != null)\n                        harvester.setEnabled(false);\n                    break;\n                }\n                catch (InterruptedException ie)\n                {\n                }\n            }\n            while (true);\n            taskIter.remove();\n        }\n    }\n\n    /**\n     * Returns an <tt>Iterator</tt> over the <tt>CandidateHarvester</tt>s which\n     * are elements in this <tt>CandidateHarvesterSet</tt>. The elements are\n     * returned in no particular order.\n     *\n     * @return an <tt>Iterator</tt> over the <tt>CandidateHarvester</tt>s which\n     * are elements in this <tt>CandidateHarvesterSet</tt>\n     * @see Set#iterator()\n     */\n    public Iterator<CandidateHarvester> iterator()\n    {\n        final Iterator<CandidateHarvesterSetElement> elementIter\n            = elements.iterator();\n\n        return\n            new Iterator<CandidateHarvester>()\n            {\n                /**\n                 * Determines whether this iteration has more elements.\n                 *\n                 * @return <tt>true</tt> if this iteration has more elements;\n                 * otherwise, <tt>false</tt>\n                 * @see Iterator#hasNext()\n                 */\n                public boolean hasNext()\n                {\n                    return elementIter.hasNext();\n                }\n\n                /**\n                 * Returns the next element in this iteration.\n                 *\n                 * @return the next element in this iteration\n                 * @throws NoSuchElementException if this iteration has no more\n                 * elements\n                 * @see Iterator#next()\n                 */\n                public CandidateHarvester next()\n                    throws NoSuchElementException\n                {\n                    return elementIter.next().getHarvester();\n                }\n\n                /**\n                 * Removes from the underlying <tt>CandidateHarvesterSet</tt>\n                 * the last <tt>CandidateHarvester</tt> (element) returned by\n                 * this <tt>Iterator</tt>. <tt>CandidateHarvestSet</tt> does not\n                 * implement the <tt>remove</tt> operation at the time of this\n                 * writing i.e. it always throws\n                 * <tt>UnsupportedOperationException</tt>.\n                 *\n                 * @throws IllegalStateException if the <tt>next</tt> method has\n                 * not yet been called, or the <tt>remove</tt> method has\n                 * already been called after the last call to the <tt>next</tt>\n                 * method\n                 * @throws UnsupportedOperationException if the <tt>remove</tt>\n                 * operation is not supported by this <tt>Iterator</tt>\n                 * @see Iterator#remove()\n                 */\n                public void remove()\n                    throws IllegalStateException,\n                           UnsupportedOperationException\n                {\n                    throw new UnsupportedOperationException(\"remove\");\n                }\n            };\n    }\n\n    /**\n     * Returns the number of <tt>CandidateHarvester</tt>s which are elements in\n     * this <tt>CandidateHarvesterSet</tt>.\n     *\n     * @return the number of <tt>CandidateHarvester</tt>s which are elements in\n     * this <tt>CandidateHarvesterSet</tt>\n     * @see Set#size()\n     */\n    public int size()\n    {\n        synchronized (elements)\n        {\n            return elements.size();\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(CandidateHarvesterSet.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>Agent</tt> class and its instances\nfor logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(CandidateHarvesterSet.class.getName())", "syntax_pass": true}, {"attribute_expression": "private final Collection<CandidateHarvesterSetElement> elements\n        = new LinkedList<>();", "docstring": "\nThe <tt>CandidateHarvester</tt>s which are the elements of this\n<tt>Set</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Collection<CandidateHarvesterSetElement>", "name": "elements\n        = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private static ExecutorService threadPool = Executors.newCachedThreadPool();", "docstring": "\nA pool of thread used for gathering process.\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "ExecutorService", "name": "threadPool = Executors.newCachedThreadPool()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester", "name": "AwsCandidateHarvester", "file_path": "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java", "superclasses": "MappingCandidateHarvester", "methods": ["[]AwsCandidateHarvester()", "[void]obtainEC2Addresses()", "[TransportAddress]getMask()", "[TransportAddress]getFace()", "[boolean]smellsLikeAnEC2()", "[boolean]doTestEc2()", "[String]fetch(String)"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester.[]AwsCandidateHarvester()", "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester.[void]obtainEC2Addresses()", "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester.[TransportAddress]getMask()", "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester.[TransportAddress]getFace()", "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester.[boolean]smellsLikeAnEC2()", "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester.[boolean]doTestEc2()", "src/main/java/org/ice4j/ice/harvest/AwsCandidateHarvester.java.AwsCandidateHarvester.[String]fetch(String)"], "overrides": null, "attributes": [], "class_docstring": "\nUses the Amazon AWS APIs to retrieve the public and private IPv4 addresses\nfor an EC2 instance.\n\n@author Emil Ivov\n", "original_string": "public class AwsCandidateHarvester\n    extends MappingCandidateHarvester\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>AwsCandidateHarvester</tt>\n     * class and its instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(AwsCandidateHarvester.class.getName());\n\n    /**\n     * The URL where one obtains AWS public addresses.\n     */\n    private static final String PUBLIC_IP_URL\n        = \"http://169.254.169.254/latest/meta-data/public-ipv4\";\n\n    /**\n     * The URL where one obtains AWS private/local addresses.\n     */\n    private static final String LOCAL_IP_URL\n        = \"http://169.254.169.254/latest/meta-data/local-ipv4\";\n\n    /**\n     * The URL to use to test whether we are running on Amazon EC2.\n     */\n    private static final String EC2_TEST_URL\n        = \"http://169.254.169.254/latest/meta-data/\";\n\n    /**\n     * Whether we are running on Amazon EC2.\n     */\n    private static Boolean RUNNING_ON_EC2 = null;\n\n    /**\n     * The addresses that we will use as a mask\n     */\n    private static TransportAddress mask;\n\n    /**\n     * The addresses that we will be masking\n     */\n    private static TransportAddress face;\n\n    /**\n     * Whether we have already checked and found the mapping addresses.\n     */\n    private static boolean addressChecked = false;\n\n    /**\n     * Creates an AWS harvester. The actual addresses wil be retrieved later,\n     * during the first harvest.\n     */\n    public AwsCandidateHarvester()\n    {\n        super(\"aws\");\n    }\n\n    /**\n     * Sends HTTP GET queries to\n     * <tt>http://169.254.169.254/latest/meta-data/local-ipv4</tt> and\n     * <tt>http://169.254.169.254/latest/meta-data/public-ipv4</tt> to learn the\n     * private (face) and public (mask) addresses of this EC2 instance.\n     */\n    private static synchronized void obtainEC2Addresses()\n    {\n        if (addressChecked)\n            return;\n        addressChecked = true;\n\n        String localIPStr = null;\n        String publicIPStr = null;\n\n        try\n        {\n            localIPStr = fetch(LOCAL_IP_URL);\n            publicIPStr = fetch(PUBLIC_IP_URL);\n\n            //now let's cross our fingers and hope that what we got above are\n            //real IP addresses\n            face = new TransportAddress(localIPStr, 9, Transport.UDP);\n            mask = new TransportAddress(publicIPStr, 9, Transport.UDP);\n\n            logger.info(\"Detected AWS local IP: \" + face);\n            logger.info(\"Detected AWS public IP: \" + mask);\n\n\n        }\n        catch (Exception exc)\n        {\n            //whatever happens, we just log and fail\n            logger.log(Level.INFO, \"We failed to obtain EC2 instance addresses \"\n                + \"for the following reason: \", exc);\n            logger.info(\"String for local IP: \" + localIPStr);\n            logger.info(\"String for public IP: \" + publicIPStr);\n        }\n    }\n\n    /**\n     * Returns the public (mask) address, or null.\n     * @return the public (mask) address, or null.\n     */\n    @Override\n    public TransportAddress getMask()\n    {\n        if (smellsLikeAnEC2())\n        {\n            obtainEC2Addresses();\n            return mask;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the local (face) address, or null.\n     * @return the local (face) address, or null.\n     */\n    @Override\n    public TransportAddress getFace()\n    {\n        if (smellsLikeAnEC2())\n        {\n            obtainEC2Addresses();\n            return face;\n        }\n        return null;\n    }\n\n    /**\n     * Determines if there is a decent chance for the box executing this\n     * application to be an AWS EC2 instance and returns <tt>true</tt> if so.\n     *\n     * @return <tt>true</tt> if there appear to be decent chances for this\n     * machine to be an AWS EC2 and <tt>false</tt> otherwise.\n     */\n    public synchronized static boolean smellsLikeAnEC2()\n    {\n        if (RUNNING_ON_EC2 == null)\n        {\n            RUNNING_ON_EC2 = doTestEc2();\n        }\n        return RUNNING_ON_EC2;\n    }\n\n    /**\n     * Tries to connect to an Amazon EC2-specific URL in order to determine\n     * whether we are running on EC2.\n     *\n     * @return <tt>true</tt> if the connection succeeded, <tt>false</tt>\n     * otherwise.\n     */\n    private static boolean doTestEc2()\n    {\n        try\n        {\n            URLConnection conn = new URL(EC2_TEST_URL).openConnection();\n            conn.setConnectTimeout(500); //don't hang for too long\n            conn.getContent();\n\n            return true;\n        }\n        catch(Exception exc)\n        {\n            //ah! I knew you weren't one of those ...\n            return false;\n        }\n    }\n\n    /**\n     * Retrieves the content at the specified <tt>url</tt>. No more, no less.\n     *\n     * @param url the URL we'd like to open and query.\n     *\n     * @return the String we retrieved from the URL.\n     *\n     * @throws Exception if anything goes wrong.\n     */\n    private static String fetch(String url)\n        throws Exception\n    {\n        URLConnection conn = new URL(url).openConnection();\n        BufferedReader in = new BufferedReader(new InputStreamReader(\n                    conn.getInputStream(), \"UTF-8\"));\n\n        String retString = in.readLine();\n\n        in.close();\n\n        return retString;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(AwsCandidateHarvester.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>AwsCandidateHarvester</tt>\nclass and its instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(AwsCandidateHarvester.class.getName())", "syntax_pass": true}, {"attribute_expression": "private static final String PUBLIC_IP_URL\n        = \"http://169.254.169.254/latest/meta-data/public-ipv4\";", "docstring": "\nThe URL where one obtains AWS public addresses.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PUBLIC_IP_URL\n        = \"http://169.254.169.254/latest/meta-data/public-ipv4\"", "syntax_pass": true}, {"attribute_expression": "private static final String LOCAL_IP_URL\n        = \"http://169.254.169.254/latest/meta-data/local-ipv4\";", "docstring": "\nThe URL where one obtains AWS private/local addresses.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "LOCAL_IP_URL\n        = \"http://169.254.169.254/latest/meta-data/local-ipv4\"", "syntax_pass": true}, {"attribute_expression": "private static final String EC2_TEST_URL\n        = \"http://169.254.169.254/latest/meta-data/\";", "docstring": "\nThe URL to use to test whether we are running on Amazon EC2.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "EC2_TEST_URL\n        = \"http://169.254.169.254/latest/meta-data/\"", "syntax_pass": true}, {"attribute_expression": "private static Boolean RUNNING_ON_EC2 = null;", "docstring": "\nWhether we are running on Amazon EC2.\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "Boolean", "name": "RUNNING_ON_EC2 = null", "syntax_pass": true}, {"attribute_expression": "private static TransportAddress mask;", "docstring": "\nThe addresses that we will use as a mask\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "TransportAddress", "name": "mask", "syntax_pass": true}, {"attribute_expression": "private static TransportAddress face;", "docstring": "\nThe addresses that we will be masking\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "TransportAddress", "name": "face", "syntax_pass": true}, {"attribute_expression": "private static boolean addressChecked = false;", "docstring": "\nWhether we have already checked and found the mapping addresses.\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "boolean", "name": "addressChecked = false", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java.GoogleTurnCandidateHarvester", "name": "GoogleTurnCandidateHarvester", "file_path": "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java", "superclasses": "StunCandidateHarvester", "methods": ["[]GoogleTurnCandidateHarvester(TransportAddress)", "[]GoogleTurnCandidateHarvester(TransportAddress,String,String)", "[GoogleTurnCandidateHarvest]createHarvest(HostCandidate)", "[String]getPassword()"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java.GoogleTurnCandidateHarvester.[]GoogleTurnCandidateHarvester(TransportAddress)", "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java.GoogleTurnCandidateHarvester.[]GoogleTurnCandidateHarvester(TransportAddress,String,String)", "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java.GoogleTurnCandidateHarvester.[GoogleTurnCandidateHarvest]createHarvest(HostCandidate)", "src/main/java/org/ice4j/ice/harvest/GoogleTurnCandidateHarvester.java.GoogleTurnCandidateHarvester.[String]getPassword()"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a <tt>CandidateHarvester</tt> which gathers Google TURN dialect\n<tt>Candidate</tt>s for a specified {@link Component}.\n\n@author Sebastien Vincent\n", "original_string": "public class GoogleTurnCandidateHarvester\n    extends StunCandidateHarvester\n{\n    /**\n     * The gingle candidates password necessary to use the TURN server.\n     */\n    private String password = null;\n\n    /**\n     * Initializes a new <tt>GoogleTurnCandidateHarvester</tt> instance which\n     * is to work with a specific Google TURN server.\n     *\n     * @param turnServer the <tt>TransportAddress</tt> of the TURN server the\n     * new instance is to work with\n     */\n    public GoogleTurnCandidateHarvester(TransportAddress turnServer)\n    {\n        this(turnServer, null, null);\n    }\n\n    /**\n     * Initializes a new <tt>GoogleTurnCandidateHarvester</tt> instance which is\n     * to work with a specific TURN server using a specific username for the\n     * purposes of the STUN short-term credential mechanism.\n     *\n     * @param turnServer the <tt>TransportAddress</tt> of the TURN server the\n     * new instance is to work with\n     * @param shortTermCredentialUsername the username to be used by the new\n     * instance for the purposes of the STUN short-term credential mechanism or\n     * <tt>null</tt> if the use of the STUN short-term credential mechanism is\n     * not determined at the time of the construction of the new instance\n     * @param password The gingle candidates password necessary to use this TURN\n     * server.\n     */\n    public GoogleTurnCandidateHarvester(TransportAddress turnServer,\n            String shortTermCredentialUsername,\n            String password)\n    {\n        super(turnServer, shortTermCredentialUsername);\n        this.password = password;\n    }\n\n    /**\n     * Creates a new <tt>GoogleTurnCandidateHarvest</tt> instance which is to\n     * perform TURN harvesting of a specific <tt>HostCandidate</tt>.\n     *\n     * @param hostCandidate the <tt>HostCandidate</tt> for which harvesting is\n     * to be performed by the new <tt>TurnCandidateHarvest</tt> instance\n     * @return a new <tt>GoogleTurnCandidateHarvest</tt> instance which is to\n     * perform TURN harvesting of the specified <tt>hostCandidate</tt>\n     * @see StunCandidateHarvester#createHarvest(HostCandidate)\n     */\n    @Override\n    protected GoogleTurnCandidateHarvest createHarvest(\n            HostCandidate hostCandidate)\n    {\n        return\n            new GoogleTurnCandidateHarvest(this, hostCandidate, getPassword());\n    }\n\n    /**\n     * Returns the password for this candidate.\n     * @return the password for this candidate.\n     */\n    public String getPassword()\n    {\n        return this.password;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private String password = null;", "docstring": "\nThe gingle candidates password necessary to use the TURN server.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "password = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/UPNPHarvester.java.UPNPHarvester", "name": "UPNPHarvester", "file_path": "src/main/java/org/ice4j/ice/harvest/UPNPHarvester.java", "superclasses": "AbstractCandidateHarvester", "methods": ["[Collection<LocalCandidate>]harvest(Component)", "[List<LocalCandidate>]createUPNPCandidate(IceSocketWrapper,String,int,Component,GatewayDevice)", "[String]toString()"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/UPNPHarvester.java.UPNPHarvester.[Collection<LocalCandidate>]harvest(Component)", "src/main/java/org/ice4j/ice/harvest/UPNPHarvester.java.UPNPHarvester.[List<LocalCandidate>]createUPNPCandidate(IceSocketWrapper,String,int,Component,GatewayDevice)", "src/main/java/org/ice4j/ice/harvest/UPNPHarvester.java.UPNPHarvester.[String]toString()"], "overrides": null, "attributes": [{"original_string": "    private class UPNPThread\n        extends Thread\n    {\n        /**\n         * Gateway device.\n         */\n        private GatewayDevice device = null;\n\n        /**\n         * ST search field.\n         */\n        private final String st;\n\n        /**\n         * Constructor.\n         *\n         * @param st ST search field\n         */\n        public UPNPThread(String st)\n        {\n            this.st = st;\n        }\n\n        /**\n         * Returns gateway device.\n         *\n         * @return gateway device\n         */\n        public GatewayDevice getDevice()\n        {\n            return device;\n        }\n\n        /**\n         * Thread Entry point.\n         */\n        public void run()\n        {\n            try\n            {\n                GatewayDiscover gd = new GatewayDiscover(st);\n\n                gd.discover();\n\n                if (gd.getValidGateway() != null)\n                {\n                    device = gd.getValidGateway();\n                }\n            }\n            catch(Throwable e)\n            {\n                logger.info(\"Failed to harvest UPnP: \" + e);\n\n                /*\n                 * The Javadoc on ThreadDeath says: If ThreadDeath is caught by\n                 * a method, it is important that it be rethrown so that the\n                 * thread actually dies.\n                 */\n                if (e instanceof ThreadDeath)\n                    throw (ThreadDeath)e;\n            }\n            finally\n            {\n                synchronized(rootSync)\n                {\n                    finishThreads++;\n                    rootSync.notify();\n                }\n            }\n        }\n    }", "definition": "    private class UPNPThread\n        extends Thread", "class_docstring": "\nUPnP discover thread.\n", "name": "UPNPThread", "super_interfaces": [], "superclasses": "Thread", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [{"attribute_expression": "private GatewayDevice device = null;", "docstring": "\nGateway device.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "GatewayDevice", "name": "device = null", "syntax_pass": true}, {"attribute_expression": "private final String st;", "docstring": "\nST search field.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "st", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public UPNPThread(String st)\n        {\n            this.st = st;\n        }", "docstring": "\nConstructor.\n\n@param st ST search field\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "UPNPThread", "params": [{"name": "st", "type": "String"}], "body": "        {\n            this.st = st;\n        }", "signature": "public UPNPThread(String st)"}, {"syntax_pass": true, "original_string": "        public GatewayDevice getDevice()\n        {\n            return device;\n        }", "docstring": "\nReturns gateway device.\n\n@return gateway device\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "GatewayDevice", "classes": []}, "name": "getDevice", "params": [], "body": "        {\n            return device;\n        }", "signature": "public GatewayDevice getDevice()"}, {"syntax_pass": true, "original_string": "        public void run()\n        {\n            try\n            {\n                GatewayDiscover gd = new GatewayDiscover(st);\n\n                gd.discover();\n\n                if (gd.getValidGateway() != null)\n                {\n                    device = gd.getValidGateway();\n                }\n            }\n            catch(Throwable e)\n            {\n                logger.info(\"Failed to harvest UPnP: \" + e);\n\n                /*\n                 * The Javadoc on ThreadDeath says: If ThreadDeath is caught by\n                 * a method, it is important that it be rethrown so that the\n                 * thread actually dies.\n                 */\n                if (e instanceof ThreadDeath)\n                    throw (ThreadDeath)e;\n            }\n            finally\n            {\n                synchronized(rootSync)\n                {\n                    finishThreads++;\n                    rootSync.notify();\n                }\n            }\n        }", "docstring": "\nThread Entry point.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "run", "params": [], "body": "        {\n            try\n            {\n                GatewayDiscover gd = new GatewayDiscover(st);\n\n                gd.discover();\n\n                if (gd.getValidGateway() != null)\n                {\n                    device = gd.getValidGateway();\n                }\n            }\n            catch(Throwable e)\n            {\n                logger.info(\"Failed to harvest UPnP: \" + e);\n\n                /*\n                 * The Javadoc on ThreadDeath says: If ThreadDeath is caught by\n                 * a method, it is important that it be rethrown so that the\n                 * thread actually dies.\n                 */\n                if (e instanceof ThreadDeath)\n                    throw (ThreadDeath)e;\n            }\n            finally\n            {\n                synchronized(rootSync)\n                {\n                    finishThreads++;\n                    rootSync.notify();\n                }\n            }\n        }", "signature": "public void run()"}]}], "class_docstring": "\nImplements a <tt>CandidateHarvester</tt> which gathers <tt>Candidate</tt>s\nfor a specified {@link Component} using UPnP.\n\n@author Sebastien Vincent\n", "original_string": "public class UPNPHarvester\n    extends AbstractCandidateHarvester\n{\n    /**\n     * The logger.\n     */\n    private static final Logger logger =\n        Logger.getLogger(UPNPHarvester.class.getName());\n\n    /**\n     * Maximum port to try to allocate.\n     */\n    private static final int MAX_RETRIES = 5;\n\n    /**\n     * ST search field for WANIPConnection.\n     */\n    private static final String stIP =\n        \"urn:schemas-upnp-org:service:WANIPConnection:1\";\n\n    /**\n     * ST search field for WANPPPConnection.\n     */\n    private static final String stPPP =\n        \"urn:schemas-upnp-org:service:WANPPPConnection:1\";\n\n    /**\n     * Synchronization object.\n     */\n    private final Object rootSync = new Object();\n\n    /**\n     * Gateway device.\n     */\n    private GatewayDevice device = null;\n\n    /**\n     * Number of UPnP discover threads that have finished.\n     */\n    private int finishThreads = 0;\n\n    /**\n     * Gathers UPnP candidates for all host <tt>Candidate</tt>s that are\n     * already present in the specified <tt>component</tt>. This method relies\n     * on the specified <tt>component</tt> to already contain all its host\n     * candidates so that it would resolve them.\n     *\n     * @param component the {@link Component} that we'd like to gather candidate\n     * UPnP <tt>Candidate</tt>s for\n     * @return  the <tt>LocalCandidate</tt>s gathered by this\n     * <tt>CandidateHarvester</tt>\n     */\n    public synchronized Collection<LocalCandidate> harvest(Component component)\n    {\n        Collection<LocalCandidate> candidates = new HashSet<>();\n        int retries = 0;\n\n        logger.fine(\"Begin UPnP harvesting\");\n        try\n        {\n            if (device == null)\n            {\n                // do it only once\n                if (finishThreads == 0)\n                {\n                    try\n                    {\n                        UPNPThread wanIPThread = new UPNPThread(stIP);\n                        UPNPThread wanPPPThread = new UPNPThread(stPPP);\n\n                        wanIPThread.start();\n                        wanPPPThread.start();\n\n                        synchronized(rootSync)\n                        {\n                            while (finishThreads != 2)\n                            {\n                                rootSync.wait();\n                            }\n                        }\n\n                        if (wanIPThread.getDevice() != null)\n                        {\n                            device = wanIPThread.getDevice();\n                        }\n                        else if (wanPPPThread.getDevice() != null)\n                        {\n                            device = wanPPPThread.getDevice();\n                        }\n\n                    }\n                    catch(Throwable e)\n                    {\n                        logger.info(\"UPnP discovery failed: \" + e);\n                    }\n                }\n\n                if (device == null)\n                    return candidates;\n            }\n\n            InetAddress localAddress = device.getLocalAddress();\n            String externalIPAddress = device.getExternalIPAddress();\n            PortMappingEntry portMapping = new PortMappingEntry();\n\n            IceSocketWrapper socket = new IceUdpSocketWrapper(\n                new MultiplexingDatagramSocket(0, localAddress));\n            int port = socket.getLocalPort();\n            int externalPort = socket.getLocalPort();\n\n            while (retries < MAX_RETRIES)\n            {\n                if (!device.getSpecificPortMappingEntry(port, \"UDP\",\n                        portMapping))\n                {\n                    if (device.addPortMapping(\n                            externalPort,\n                            port,\n                            localAddress.getHostAddress(),\n                            \"UDP\",\n                            \"ice4j.org: \" + port))\n                    {\n                        List<LocalCandidate> cands = createUPNPCandidate(socket,\n                            externalIPAddress, externalPort, component, device);\n\n                        logger.info(\"Add UPnP port mapping: \" +\n                                externalIPAddress + \" \" + externalPort);\n\n                        // we have to add the UPNPCandidate and also the base.\n                        // if we don't add the base, we won't be able to add\n                        // peer reflexive candidate if someone contact us on the\n                        // UPNPCandidate\n                        for (LocalCandidate cand : cands)\n                        {\n                            //try to add the candidate to the component and then\n                            //only add it to the harvest not redundant\n                            if (component.addLocalCandidate(cand))\n                            {\n                                candidates.add(cand);\n                            }\n                        }\n\n                        break;\n                    }\n                    else\n                    {\n                        port++;\n                    }\n                }\n                else\n                {\n                    port++;\n                }\n                retries++;\n            }\n        }\n        catch(Throwable e)\n        {\n            logger.info(\"Exception while gathering UPnP candidates: \" + e);\n        }\n\n        return candidates;\n    }\n\n    /**\n     * Create a UPnP candidate.\n     *\n     * @param socket local socket\n     * @param externalIP external IP address\n     * @param port local port\n     * @param component parent component\n     * @param device the UPnP gateway device\n     * @return a new <tt>UPNPCandidate</tt> instance which\n     * represents the specified <tt>TransportAddress</tt>\n     */\n    private List<LocalCandidate> createUPNPCandidate(IceSocketWrapper socket,\n            String externalIP, int port, Component component, GatewayDevice device)\n    {\n        List<LocalCandidate> ret = new ArrayList<>();\n        TransportAddress addr\n            = new TransportAddress(externalIP, port, Transport.UDP);\n\n        HostCandidate base = new HostCandidate(socket, component);\n\n        UPNPCandidate candidate\n            = new UPNPCandidate(addr, base, component, device);\n        IceSocketWrapper stunSocket = candidate.getStunSocket(null);\n        candidate.getStunStack().addSocket(stunSocket);\n        ComponentSocket componentSocket = component.getComponentSocket();\n        if (componentSocket != null)\n        {\n            componentSocket.add(candidate.getCandidateIceSocketWrapper());\n        }\n\n        ret.add(candidate);\n        ret.add(base);\n\n        return ret;\n    }\n\n    /**\n     * UPnP discover thread.\n     */\n    private class UPNPThread\n        extends Thread\n    {\n        /**\n         * Gateway device.\n         */\n        private GatewayDevice device = null;\n\n        /**\n         * ST search field.\n         */\n        private final String st;\n\n        /**\n         * Constructor.\n         *\n         * @param st ST search field\n         */\n        public UPNPThread(String st)\n        {\n            this.st = st;\n        }\n\n        /**\n         * Returns gateway device.\n         *\n         * @return gateway device\n         */\n        public GatewayDevice getDevice()\n        {\n            return device;\n        }\n\n        /**\n         * Thread Entry point.\n         */\n        public void run()\n        {\n            try\n            {\n                GatewayDiscover gd = new GatewayDiscover(st);\n\n                gd.discover();\n\n                if (gd.getValidGateway() != null)\n                {\n                    device = gd.getValidGateway();\n                }\n            }\n            catch(Throwable e)\n            {\n                logger.info(\"Failed to harvest UPnP: \" + e);\n\n                /*\n                 * The Javadoc on ThreadDeath says: If ThreadDeath is caught by\n                 * a method, it is important that it be rethrown so that the\n                 * thread actually dies.\n                 */\n                if (e instanceof ThreadDeath)\n                    throw (ThreadDeath)e;\n            }\n            finally\n            {\n                synchronized(rootSync)\n                {\n                    finishThreads++;\n                    rootSync.notify();\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns a <tt>String</tt> representation of this harvester containing its\n     * name.\n     *\n     * @return a <tt>String</tt> representation of this harvester containing its\n     * name.\n     */\n    @Override\n    public String toString()\n    {\n        return getClass().getSimpleName();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger =\n        Logger.getLogger(UPNPHarvester.class.getName());", "docstring": "\nThe logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger =\n        Logger.getLogger(UPNPHarvester.class.getName())", "syntax_pass": true}, {"attribute_expression": "private static final int MAX_RETRIES = 5;", "docstring": "\nMaximum port to try to allocate.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "MAX_RETRIES = 5", "syntax_pass": true}, {"attribute_expression": "private static final String stIP =\n        \"urn:schemas-upnp-org:service:WANIPConnection:1\";", "docstring": "\nST search field for WANIPConnection.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "stIP =\n        \"urn:schemas-upnp-org:service:WANIPConnection:1\"", "syntax_pass": true}, {"attribute_expression": "private static final String stPPP =\n        \"urn:schemas-upnp-org:service:WANPPPConnection:1\";", "docstring": "\nST search field for WANPPPConnection.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "stPPP =\n        \"urn:schemas-upnp-org:service:WANPPPConnection:1\"", "syntax_pass": true}, {"attribute_expression": "private final Object rootSync = new Object();", "docstring": "\nSynchronization object.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "rootSync = new Object()", "syntax_pass": true}, {"attribute_expression": "private GatewayDevice device = null;", "docstring": "\nGateway device.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "GatewayDevice", "name": "device = null", "syntax_pass": true}, {"attribute_expression": "private int finishThreads = 0;", "docstring": "\nNumber of UPnP discover threads that have finished.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "finishThreads = 0", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java.IceSdpUtils", "name": "IceSdpUtils", "file_path": "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java", "superclasses": "", "methods": ["[void]setIceCredentials(SessionDescription,String,String)", "[void]initMediaDescription(MediaDescription,IceMediaStream)", "[void]initSessionDescription(SessionDescription,Agent)", "[Collection<Attribute>]createTrickleUpdate(Collection<LocalCandidate>)"], "method_uris": ["src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java.IceSdpUtils.[void]setIceCredentials(SessionDescription,String,String)", "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java.IceSdpUtils.[void]initMediaDescription(MediaDescription,IceMediaStream)", "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java.IceSdpUtils.[void]initSessionDescription(SessionDescription,Agent)", "src/main/java/org/ice4j/ice/sdp/IceSdpUtils.java.IceSdpUtils.[Collection<Attribute>]createTrickleUpdate(Collection<LocalCandidate>)"], "overrides": null, "attributes": [], "class_docstring": "\nA number of utility methods that WebRTC or SIP applications may find useful\nin case they are also fine with using jain-sdp\n\n@author Emil Ivov\n", "original_string": "public class IceSdpUtils\n{\n    /**\n     * The name of the SDP attribute that contains an ICE user fragment.\n     */\n    public static final String ICE_UFRAG = \"ice-ufrag\";\n\n    /**\n     * The name of the SDP attribute that contains an ICE password.\n     */\n    public static final String ICE_PWD = \"ice-pwd\";\n\n    /**\n     * The name of the SDP attribute that contains an ICE options.\n     */\n    public static final String ICE_OPTIONS = \"ice-options\";\n\n    /**\n     * The name of the ICE SDP option that indicates support for trickle.\n     */\n    public static final String ICE_OPTION_TRICKLE = \"trickle\";\n\n    /**\n     * The name of the \"mid\" SDP attribute.\n     */\n    public static final String MID = \"mid\";\n\n    /**\n     * The name of the SDP attribute that contains RTCP address and port.\n     */\n    private static final String RTCP = \"rtcp\";\n\n    /**\n     * The name of the SDP attribute that indicates an end of candidate\n     * trickling: \"end-of-candidates\".\n     */\n    private static final String END_OF_CANDIDATES = \"end-of-candidates\";\n\n    /**\n     * A reference to the currently valid SDP factory instance.\n     */\n    private static final SdpFactory sdpFactory = new NistSdpFactory();\n\n    /**\n     * The <tt>Logger</tt> used by the <tt>IceSdpUtils</tt>\n     * class and its instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(IceSdpUtils.class.getName());\n\n    /**\n     * Sets the specified ICE user fragment and password as attributes of the\n     * specified session description.\n     *\n     * @param sDes the session description where we'd like to set a user\n     * fragment and a password.\n     * @param uFrag the ICE user name fragment that we'd like to set on the\n     * session description\n     * @param pwd the ICE password that we'd like to set on the session\n     * description\n     *\n     * @throws NullPointerException if the either of the parameters is null\n     */\n    @SuppressWarnings(\"unchecked\") // SDP legacy\n    public static void setIceCredentials(SessionDescription sDes,\n                                         String             uFrag,\n                                         String             pwd)\n        throws NullPointerException\n    {\n        if (sDes == null || uFrag == null || pwd == null)\n        {\n            throw new NullPointerException(\n                \"sDes, uFrag and pwd, cannot be null\");\n        }\n\n        try\n        {\n            Vector<Attribute> sessionAttributes = sDes.getAttributes(true);\n\n            //ice u-frag and password\n            sessionAttributes.add(sdpFactory.createAttribute(ICE_UFRAG, uFrag));\n            sessionAttributes.add(sdpFactory.createAttribute(ICE_PWD, pwd));\n\n            sDes.setAttributes(sessionAttributes);\n        }\n        catch (Exception cause)\n        {\n           // this is very unlikely to happen but we should still log.\n           // Just in case.\n           logger.log(Level.INFO,\n               \"Failed to set ICE credentials for some weird reason\",\n               cause);\n        }\n    }\n\n    /**\n     * Reflects the candidates from the various components in\n     * <tt>iceMediaStream</tt> into the specified m-line. Also sets default\n     * candidates into m= lines and c= lines. This method uses media level\n     * c= lines. They override session level making them pointless. This\n     * shouldn't be causing problems, but for good taste, make sure you don't\n     * include session level ones and avoid duplication.\n     *\n     * @param mediaDescription the media descriptions that we'd like to add\n     * candidates to.\n     * @param iceMediaStream the media stream where we should extract candidates\n     * from.\n     */\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public static void initMediaDescription(MediaDescription mediaDescription,\n                                            IceMediaStream   iceMediaStream)\n    {\n        try\n        {\n            //set mid-s\n            mediaDescription.setAttribute(MID, iceMediaStream.getName());\n\n            Component firstComponent = null;\n\n            //add candidates\n            for (Component component : iceMediaStream.getComponents())\n            {\n                //if this is the first component, remember it so that we can\n                //later use it for default candidates.\n                if (firstComponent == null)\n                    firstComponent = component;\n\n                Vector attributes = mediaDescription.getAttributes(true);\n                for (Candidate<?> candidate : component.getLocalCandidates())\n                {\n                    attributes.add(new CandidateAttribute(candidate));\n                }\n            }\n\n            //set the default candidate\n            TransportAddress defaultAddress = firstComponent\n                .getDefaultCandidate().getTransportAddress();\n\n            mediaDescription.getMedia().setMediaPort(\n                defaultAddress.getPort());\n\n            String addressFamily = defaultAddress.isIPv6()\n                                ? Connection.IP6\n                                : Connection.IP4;\n\n            mediaDescription.setConnection(sdpFactory.createConnection(\n                \"IN\", addressFamily, defaultAddress.getHostAddress()));\n\n            //now check if the RTCP port for the default candidate is different\n            //than RTP.port +1, in which case we need to mention it.\n            Component rtcpComponent\n                = iceMediaStream.getComponent(Component.RTCP);\n\n            if ( rtcpComponent != null )\n            {\n                TransportAddress defaultRtcpCandidate = rtcpComponent\n                    .getDefaultCandidate().getTransportAddress();\n\n                if (defaultRtcpCandidate.getPort() != defaultAddress.getPort()+1)\n                {\n                    mediaDescription.setAttribute(\n                        RTCP, Integer.toString(defaultRtcpCandidate.getPort()));\n                }\n            }\n        }\n        catch (SdpException exc)\n        {\n            //this shouldn't happen but let's rethrow an SDP exception just\n            //in case.\n            throw new IllegalArgumentException(\n                \"Something went wrong when setting default candidates\",\n                exc);\n        }\n    }\n\n    /**\n     * Sets ice credentials, ICE options, media lines and candidates from agent,\n     * on the specified session description.\n     *\n     * @param sDes the {@link SessionDescription} that we'd like to setup as per\n     * the specified agent.\n     * @param agent the {@link Agent} that we need to use when initializing\n     * the session description.\n     *\n     * @throws  IllegalArgumentException Obviously, if there's a problem with\n     * the arguments ... duh!\n     */\n    @SuppressWarnings(\"unchecked\") // jain-sdp legacy\n    public static void initSessionDescription(SessionDescription sDes,\n                                              Agent              agent)\n        throws IllegalArgumentException\n    {\n        //now add ICE options\n        StringBuilder allOptionsBuilder = new StringBuilder();\n\n        //if(agent.supportsTrickle())\n            allOptionsBuilder.append(ICE_OPTION_TRICKLE).append(\" \");\n\n        String allOptions = allOptionsBuilder.toString().trim();\n\n        try\n        {\n            if (allOptions.length() > 0)\n            {\n                //get the attributes so that we could easily modify them\n                Vector<Attribute> sessionAttributes = sDes.getAttributes(true);\n\n                sessionAttributes.add(\n                    sdpFactory.createAttribute(ICE_OPTIONS, allOptions));\n            }\n\n            //take care of the origin: first extract one of the default\n            // addresses so that we could set the origin.\n            TransportAddress defaultAddress = agent.getStreams().get(0)\n                .getComponent(Component.RTP).getDefaultCandidate()\n                    .getTransportAddress();\n\n            String addressFamily = defaultAddress.isIPv6()\n                                        ? Connection.IP6\n                                        : Connection.IP4;\n\n            //origin\n            Origin o = sDes.getOrigin();\n\n            if ( o == null || \"user\".equals(o.getUsername()))\n            {\n                //looks like there wasn't any origin set: jain-sdp creates a\n                //default origin that has \"user\" as the user name so we use this\n                //to detect it. it's quite hacky but couldn't fine another way.\n                o = sdpFactory.createOrigin(\"ice4j.org\", 0, 0, \"IN\",\n                        addressFamily, defaultAddress.getHostAddress());\n            }\n            else\n            {\n                //if an origin existed, we just make sure it has the right\n                // address now and are care ful not to touch anything else.\n                o.setAddress(defaultAddress.getHostAddress());\n                o.setAddressType(addressFamily);\n            }\n\n            sDes.setOrigin(o);\n\n            //m lines\n            List<IceMediaStream> streams = agent.getStreams();\n            Vector<MediaDescription> mDescs\n                = new Vector<>(agent.getStreamCount());\n            for (IceMediaStream stream : streams)\n            {\n               MediaDescription mLine = sdpFactory.createMediaDescription(\n                               stream.getName(), 0, //default port comes later\n                               1, SdpConstants.RTP_AVP, new int[]{0});\n\n               IceSdpUtils.initMediaDescription(mLine, stream);\n\n               mDescs.add(mLine);\n            }\n\n            sDes.setMediaDescriptions(mDescs);\n        }\n        catch (SdpException exc)\n        {\n            //this shouldn't happen but let's rethrow an SDP exception just\n            //in case.\n            throw new IllegalArgumentException(\n                \"Something went wrong when setting ICE options\",\n                exc);\n        }\n\n        //first set credentials\n        setIceCredentials(\n            sDes, agent.getLocalUfrag(), agent.getLocalPassword());\n    }\n\n\n    /**\n     * Generates and returns a set of attributes that can be used for a trickle\n     * update, such as a SIP INFO, with the specified <tt>localCandidates</tt>.\n     *\n     * @param localCandidates the list of {@link LocalCandidate}s that we'd like\n     * to generate the update for.\n     *\n     * @return a collection of {@link CandidateAttribute}s and an MID attribute\n     * that we can use in a SIP INFO trickle update.\n     */\n    public static Collection<Attribute> createTrickleUpdate(\n                                Collection<LocalCandidate> localCandidates)\n    {\n        List<Attribute> trickleUpdate = null;\n\n        if (localCandidates == null || localCandidates.size() == 0)\n        {\n            trickleUpdate = new ArrayList<>(1);\n            trickleUpdate.add(\n                sdpFactory.createAttribute(END_OF_CANDIDATES, null));\n\n            return trickleUpdate;\n        }\n\n        trickleUpdate = new ArrayList<>(localCandidates.size() + 1);\n\n        String streamName = null;\n\n        for (LocalCandidate candidate : localCandidates)\n        {\n           streamName = candidate.getParentComponent()\n               .getParentStream().getName();\n\n            trickleUpdate.add(new CandidateAttribute(candidate));\n        }\n\n        trickleUpdate.add(0, sdpFactory.createAttribute(MID, streamName));\n\n        return trickleUpdate;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String ICE_UFRAG = \"ice-ufrag\";", "docstring": "\nThe name of the SDP attribute that contains an ICE user fragment.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "ICE_UFRAG = \"ice-ufrag\"", "syntax_pass": true}, {"attribute_expression": "public static final String ICE_PWD = \"ice-pwd\";", "docstring": "\nThe name of the SDP attribute that contains an ICE password.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "ICE_PWD = \"ice-pwd\"", "syntax_pass": true}, {"attribute_expression": "public static final String ICE_OPTIONS = \"ice-options\";", "docstring": "\nThe name of the SDP attribute that contains an ICE options.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "ICE_OPTIONS = \"ice-options\"", "syntax_pass": true}, {"attribute_expression": "public static final String ICE_OPTION_TRICKLE = \"trickle\";", "docstring": "\nThe name of the ICE SDP option that indicates support for trickle.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "ICE_OPTION_TRICKLE = \"trickle\"", "syntax_pass": true}, {"attribute_expression": "public static final String MID = \"mid\";", "docstring": "\nThe name of the \"mid\" SDP attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "MID = \"mid\"", "syntax_pass": true}, {"attribute_expression": "private static final String RTCP = \"rtcp\";", "docstring": "\nThe name of the SDP attribute that contains RTCP address and port.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "RTCP = \"rtcp\"", "syntax_pass": true}, {"attribute_expression": "private static final String END_OF_CANDIDATES = \"end-of-candidates\";", "docstring": "\nThe name of the SDP attribute that indicates an end of candidate\ntrickling: \"end-of-candidates\".\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "END_OF_CANDIDATES = \"end-of-candidates\"", "syntax_pass": true}, {"attribute_expression": "private static final SdpFactory sdpFactory = new NistSdpFactory();", "docstring": "\nA reference to the currently valid SDP factory instance.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "SdpFactory", "name": "sdpFactory = new NistSdpFactory()", "syntax_pass": true}, {"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(IceSdpUtils.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>IceSdpUtils</tt>\nclass and its instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(IceSdpUtils.class.getName())", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute", "name": "CandidateAttribute", "file_path": "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java", "superclasses": "AttributeField", "methods": ["[]CandidateAttribute()", "[]CandidateAttribute(Candidate<?>)", "[NameValue]getAttribute()", "[String]getName()", "[void]setName(String)", "[boolean]hasValue()", "[String]getValue()", "[void]setValue(String)", "[char]getTypeChar()", "[CandidateAttribute]clone()", "[String]encode()"], "method_uris": ["src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[]CandidateAttribute()", "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[]CandidateAttribute(Candidate<?>)", "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[NameValue]getAttribute()", "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[String]getName()", "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[void]setName(String)", "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[boolean]hasValue()", "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[String]getValue()", "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[void]setValue(String)", "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[char]getTypeChar()", "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[CandidateAttribute]clone()", "src/main/java/org/ice4j/ice/sdp/CandidateAttribute.java.CandidateAttribute.[String]encode()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CandidateAttribute extends AttributeField\n{\n    /**\n     * The SDP name of candidate attributes.\n     */\n    public static final String NAME = \"candidate\";\n\n    /**\n     * This class's serial version uid.\n     */\n    private static final long serialVersionUID = 1L;\n\n    /**\n     * The Candidate that we will be encapsulating.\n     */\n    private Candidate<?> candidate;\n\n    protected CandidateAttribute()\n    {\n        this(null);\n    }\n\n    /**\n     * Creates an attribute instance\n     *\n     * @param candidate the Candidate\n     */\n    public CandidateAttribute(Candidate<?> candidate)\n    {\n        this.candidate = candidate;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public NameValue getAttribute()\n    {\n        // We've overridden the method getValue() of AttributeField. The\n        // NameValue pair of the method getAttribute() should return the value of\n        // the method getValue() of AttributeField then. Unfortunately, NameValue\n        // accesses its field value in multiple places so it is not a question of\n        // simply overriding a method or two. As a compromise, initialize a new\n        // NameValue with the current name and value upon each invocation.\n        NameValue attribute = super.getAttribute();\n        String name = getName();\n\n        if ((attribute == null)\n                || (name.equals(attribute.getName())\n                        && (attribute.getValue() == null)))\n        {\n            attribute = new NameValue(name, getValue());\n        }\n        return attribute;\n    }\n\n    /**\n     * Returns the name of this attribute\n     *\n     * @return a String identity.\n     */\n    public String getName()\n    {\n        return NAME;\n    }\n\n    /**\n     * Does nothing .\n     *\n     * @param name ignored.\n     */\n    public void setName(String name)\n    {\n    }\n\n    /**\n     * Always returns <tt>true</tt> as this attribute always has a value.\n     *\n     * @return true if the attribute has a value.\n     */\n    public boolean hasValue()\n    {\n        return true;\n    }\n\n    /**\n     * Returns the value of this attribute.\n     *\n     * @return the value\n     */\n    public String getValue()\n    {\n        StringBuffer buff = new StringBuffer();\n\n        buff.append(candidate.getFoundation());\n        buff.append(\" \").append(\n            candidate.getParentComponent().getComponentID());\n        buff.append(\" \").append(candidate.getTransport());\n        buff.append(\" \").append(candidate.getPriority());\n        buff.append(\" \").append(\n            candidate.getTransportAddress().getHostAddress());\n        buff.append(\" \").append(\n            candidate.getTransportAddress().getPort());\n        buff.append(\" typ \").append(\n            candidate.getType());\n\n        TransportAddress relAddr = candidate.getRelatedAddress();\n\n        if (relAddr != null)\n        {\n            buff.append(\" raddr \").append(relAddr.getHostAddress());\n            buff.append(\" rport \").append(relAddr.getPort());\n        }\n\n        return buff.toString();\n    }\n\n    /**\n     * Parses the value of this attribute.\n     *\n     * @param value the - attribute value\n     *\n     * @throws javax.sdp.SdpException if there's a problem with the <tt>value\n     * String</tt>.\n     */\n    public void setValue(String value)\n        throws SdpException\n    {\n    }\n\n    /**\n     * Returns the type character for the field.\n     *\n     * @return the type character for the field.\n     */\n    public char getTypeChar()\n    {\n        return 'a';\n    }\n\n    /**\n     * Returns a reference to this attribute.\n     *\n     * @return a reference to this attribute.\n     */\n    public CandidateAttribute clone()\n    {\n        CandidateAttribute clone = (CandidateAttribute) super.clone();\n\n        clone.candidate = candidate;\n        return clone;\n    }\n\n    /**\n     * Returns the string encoded version of this object\n     *\n     * @return the string encoded version of this object\n     */\n     public String encode()\n     {\n         StringBuffer sbuff = new StringBuffer(ATTRIBUTE_FIELD);\n         sbuff.append(getName()).append(Separators.COLON);\n         sbuff.append(getValue());\n         return sbuff.append(Separators.NEWLINE).toString();\n     }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String NAME = \"candidate\";", "docstring": "\nThe SDP name of candidate attributes.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "NAME = \"candidate\"", "syntax_pass": true}, {"attribute_expression": "private static final long serialVersionUID = 1L;", "docstring": "\nThis class's serial version uid.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1L", "syntax_pass": true}, {"attribute_expression": "private Candidate<?> candidate;", "docstring": "\nThe Candidate that we will be encapsulating.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Candidate<?>", "name": "candidate", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket", "name": "MultiplexingSocket", "file_path": "src/main/java/org/ice4j/socket/MultiplexingSocket.java", "superclasses": "DelegatingSocket", "methods": ["[]MultiplexingSocket()", "[]MultiplexingSocket(InetAddress,int)", "[]MultiplexingSocket(InetAddress,int,InetAddress,int)", "[]MultiplexingSocket(Proxy)", "[]MultiplexingSocket(Socket)", "[]MultiplexingSocket(SocketImpl)", "[]MultiplexingSocket(String,int)", "[]MultiplexingSocket(String,int,InetAddress,int)", "[void]close(MultiplexedSocket)", "[InputStream]getInputStream()", "[InputStream]getOriginalInputStream()", "[OutputStream]getOriginalOutputStream()", "[OutputStream]getOutputStream()", "[MultiplexedSocket]getSocket(DatagramPacketFilter)", "[int]getSoTimeout()", "[void]multiplexingXXXSocketSupportDoReceive(DatagramPacket)", "[void]multiplexingXXXSocketSupportDoSetReceiveBufferSize(int)", "[void]receive(DatagramPacket)", "[void]receive(MultiplexedSocket,DatagramPacket)", "[void]setSoTimeout(int)"], "method_uris": ["src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket()", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket(InetAddress,int)", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket(InetAddress,int,InetAddress,int)", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket(Proxy)", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket(Socket)", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket(SocketImpl)", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket(String,int)", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[]MultiplexingSocket(String,int,InetAddress,int)", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[void]close(MultiplexedSocket)", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[InputStream]getInputStream()", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[InputStream]getOriginalInputStream()", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[OutputStream]getOriginalOutputStream()", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[OutputStream]getOutputStream()", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[MultiplexedSocket]getSocket(DatagramPacketFilter)", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[int]getSoTimeout()", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[void]multiplexingXXXSocketSupportDoReceive(DatagramPacket)", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[void]multiplexingXXXSocketSupportDoSetReceiveBufferSize(int)", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[void]receive(DatagramPacket)", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[void]receive(MultiplexedSocket,DatagramPacket)", "src/main/java/org/ice4j/socket/MultiplexingSocket.java.MultiplexingSocket.[void]setSoTimeout(int)"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents a <tt>Socket</tt> which allows filtering <tt>DatagramPacket</tt>s\nit reads from the network using <tt>DatagramPacketFilter</tt>s so that the\n<tt>DatagramPacket</tt>s do not get received through it but through\nassociated <tt>MultiplexedSocket</tt>s.\n\n@author Sebastien Vincent\n@author Lyubomir Marinov\n", "original_string": "public class MultiplexingSocket\n    extends DelegatingSocket\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>MultiplexingSocket</tt> class and its\n     * instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(MultiplexingSocket.class.getName());\n\n    /**\n     * Custom <tt>InputStream</tt> for this <tt>Socket</tt>.\n     */\n    private final InputStream inputStream = new TCPInputStream(this);\n\n    /**\n     * The {@code MultiplexingXXXSocketSupport} which implements functionality\n     * common to TCP and UDP sockets in order to facilitate implementers such as\n     * this instance.\n     */\n    private final MultiplexingXXXSocketSupport<MultiplexedSocket>\n        multiplexingXXXSocketSupport\n            = new MultiplexingXXXSocketSupport<MultiplexedSocket>()\n            {\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected MultiplexedSocket createSocket(\n                        DatagramPacketFilter filter)\n                    throws SocketException\n                {\n                    return\n                        new MultiplexedSocket(MultiplexingSocket.this, filter);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected void doReceive(DatagramPacket p)\n                    throws IOException\n                {\n                    multiplexingXXXSocketSupportDoReceive(p);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected void doSetReceiveBufferSize(int receiveBufferSize)\n                    throws SocketException\n                {\n                    multiplexingXXXSocketSupportDoSetReceiveBufferSize(\n                            receiveBufferSize);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected SocketReceiveBuffer getReceived()\n                {\n                    return received;\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected SocketReceiveBuffer getReceived(\n                        MultiplexedSocket socket)\n                {\n                    return socket.received;\n                }\n            };\n\n    /**\n     * Custom <tt>OutputStream</tt> for this <tt>Socket</tt>.\n     */\n    private TCPOutputStream outputStream = null;\n\n    /**\n     * The list of <tt>DatagramPacket</tt>s to be received through this\n     * <tt>Socket</tt> i.e. not accepted by the <tt>DatagramFilter</tt>s of\n     * {@link #sockets} at the time of the reading from the network.\n     */\n    private final SocketReceiveBuffer received\n        = new SocketReceiveBuffer(this::getReceiveBufferSize);\n\n    /**\n     * Buffer variable for storing the SO_TIMEOUT value set by the last\n     * <tt>setSoTimeout()</tt> call. Although not strictly needed, getting the\n     * locally stored value as opposed to retrieving it from a parent\n     * <tt>getSoTimeout()</tt> call seems to significantly improve efficiency,\n     * at least on some platforms.\n     */\n    private int soTimeout = 0;\n\n    /**\n     * Initializes a new <tt>MultiplexingSocket</tt> instance.\n     *\n     * @see Socket#Socket()\n     */\n    public MultiplexingSocket()\n    {\n        this((Socket) null);\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingSocket</tt> instance.\n     *\n     * @param address not used\n     * @param port not used\n     * @see Socket#Socket(InetAddress, int)\n     */\n    public MultiplexingSocket(InetAddress address, int port)\n    {\n        this((Socket) null);\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingSocket</tt> instance.\n     *\n     * @param address not used\n     * @param port not used\n     * @param localAddr not used\n     * @param localPort not used\n     * @see Socket#Socket(InetAddress, int, InetAddress, int)\n     */\n    public MultiplexingSocket(\n            InetAddress address, int port,\n            InetAddress localAddr, int localPort)\n    {\n        this((Socket) null);\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingSocket</tt> instance.\n     *\n     * @param proxy not used\n     * @see Socket#Socket(Proxy)\n     */\n    public MultiplexingSocket(Proxy proxy)\n    {\n        this((Socket) null);\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingSocket</tt> instance.\n     *\n     * @param socket delegate socket\n     */\n    public MultiplexingSocket(Socket socket)\n    {\n        super(socket);\n\n        try\n        {\n            setTcpNoDelay(true);\n        }\n        catch (SocketException ex)\n        {\n            logger.info(\"Cannot SO_TCPNODELAY\");\n        }\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingSocket</tt> instance.\n     *\n     * @param impl not used\n     * @see Socket#Socket(SocketImpl)\n     */\n    protected MultiplexingSocket(SocketImpl impl)\n    {\n        this((Socket) null);\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingSocket</tt> instance.\n     *\n     * @param host not used\n     * @param port not used\n     * @see Socket#Socket(String, int)\n     */\n    public MultiplexingSocket(String host, int port)\n    {\n        this((Socket) null);\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingSocket</tt> instance.\n     *\n     * @param host not used\n     * @param port not used\n     * @param localAddr not used\n     * @param localPort not used\n     * @see Socket#Socket(String, int, InetAddress, int)\n     */\n    public MultiplexingSocket(\n            String host, int port,\n            InetAddress localAddr, int localPort)\n    {\n        this((Socket) null);\n    }\n\n    /**\n     * Closes a specific <tt>MultiplexedSocket</tt> which filters\n     * <tt>DatagramPacket</tt>s away from this <tt>Socket</tt>.\n     *\n     * @param multiplexed the <tt>MultiplexedSocket</tt> to close\n     */\n    void close(MultiplexedSocket multiplexed)\n    {\n        multiplexingXXXSocketSupport.close(multiplexed);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InputStream getInputStream()\n        throws IOException\n    {\n        return inputStream;\n    }\n\n    /**\n     * Get original <tt>InputStream</tt>.\n     *\n     * @return original <tt>InputStream</tt>\n     * @throws IOException if something goes wrong\n     */\n    public InputStream getOriginalInputStream()\n        throws IOException\n    {\n        return super.getInputStream();\n    }\n\n    /**\n     * Get original <tt>OutputStream</tt>.\n     *\n     * @return original <tt>OutputStream</tt>\n     * @throws IOException if something goes wrong\n     */\n    public OutputStream getOriginalOutputStream()\n        throws IOException\n    {\n        return super.getOutputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public OutputStream getOutputStream()\n        throws IOException\n    {\n        if (outputStream == null)\n            outputStream = new TCPOutputStream(super.getOutputStream());\n        return outputStream;\n    }\n\n    /**\n     * Gets a <tt>MultiplexedDatagramSocket</tt> which filters\n     * <tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using a\n     * specific <tt>DatagramPacketFilter</tt>. If such a\n     * <tt>MultiplexedDatagramSocket</tt> does not exist in this instance, it is\n     * created.\n     *\n     * @param filter the <tt>DatagramPacketFilter</tt> to get a\n     * <tt>MultiplexedDatagramSocket</tt> for\n     * @return a <tt>MultiplexedDatagramSocket</tt> which filters\n     * <tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using the\n     * specified <tt>filter</tt>\n     * @throws SocketException if creating the\n     * <tt>MultiplexedDatagramSocket</tt> for the specified <tt>filter</tt>\n     * fails\n     */\n    public MultiplexedSocket getSocket(DatagramPacketFilter filter)\n        throws SocketException\n    {\n        return multiplexingXXXSocketSupport.getSocket(filter);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getSoTimeout()\n    {\n        return soTimeout;\n    }\n\n    /**\n     * Implements {@link MultiplexingXXXSocketSupport#doReceive(DatagramPacket)}\n     * on behalf of {@link #multiplexingXXXSocketSupport}. Receives a\n     * {@code DatagramPacket} from this socket.\n     *\n     * @param p the {@code DatagramPacket} into which to place the incoming data\n     * @throws IOException if an I/O error occurs\n     */\n    private void multiplexingXXXSocketSupportDoReceive(DatagramPacket p)\n        throws IOException\n    {\n        super.receive(p);\n    }\n\n    /**\n     * Implements\n     * {@link MultiplexingXXXSocketSupport#doSetReceiveBufferSize(int)} on\n     * behalf of {@link #multiplexingXXXSocketSupport}. Sets the\n     * {@code SO_RCVBUF} option to the specified value for this\n     * {@code DatagramSocket}. The {@code SO_RCVBUF} option is used by the\n     * network implementation as a hint to size the underlying network I/O\n     * buffers. The {@code SO_RCVBUF} setting may also be used by the network\n     * implementation to determine the maximum size of the packet that can be\n     * received on this socket.\n     *\n     * @param receiveBufferSize the size to which to set the receive buffer size\n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as a TCP error\n     */\n    private void multiplexingXXXSocketSupportDoSetReceiveBufferSize(\n            int receiveBufferSize)\n        throws SocketException\n    {\n        super.setReceiveBufferSize(receiveBufferSize);\n    }\n\n    /**\n     * Receives a datagram packet from this socket. The <tt>DatagramPacket</tt>s\n     * returned by this method do not match any of the\n     * <tt>DatagramPacketFilter</tt>s of the <tt>MultiplexedDatagramSocket</tt>s\n     * associated with this instance at the time of their receipt. When this\n     * method returns, the <tt>DatagramPacket</tt>'s buffer is filled with the\n     * data received. The datagram packet also contains the sender's IP address,\n     * and the port number on the sender's machine.\n     * <p>\n     * This method blocks until a datagram is received. The <tt>length</tt>\n     * field of the datagram packet object contains the length of the received\n     * message. If the message is longer than the packet's length, the message\n     * is truncated.\n     * </p>\n     *\n     * @param p the <tt>DatagramPacket</tt> into which to place the incoming\n     * data\n     * @throws IOException if an I/O error occurs\n     * @see DelegatingSocket#receive(DatagramPacket)\n     */\n    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        try\n        {\n            setOriginalInputStream(super.getInputStream());\n        }\n        catch(Exception e)\n        {\n        }\n\n        multiplexingXXXSocketSupport.receive(received, p, soTimeout);\n    }\n\n    /**\n     * Receives a <tt>DatagramPacket</tt> from this <tt>Socket</tt> upon\n     * request from a specific <tt>MultiplexedSocket</tt>.\n     *\n     * @param multiplexed the <tt>MultiplexedSocket</tt> which requests\n     * the receipt of a <tt>DatagramPacket</tt> from the network\n     * @param p the <tt>DatagramPacket</tt> to receive the data from the network\n     * @throws IOException if an I/O error occurs\n     */\n    void receive(MultiplexedSocket multiplexed, DatagramPacket p)\n        throws IOException\n    {\n        try\n        {\n            setOriginalInputStream(super.getInputStream());\n        }\n        catch(Exception e)\n        {\n        }\n\n        multiplexingXXXSocketSupport.receive(\n                multiplexed.received,\n                p,\n                multiplexed.getSoTimeout());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setSoTimeout(int timeout)\n        throws SocketException\n    {\n        super.setSoTimeout(timeout);\n\n        soTimeout = timeout;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(MultiplexingSocket.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>MultiplexingSocket</tt> class and its\ninstances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(MultiplexingSocket.class.getName())", "syntax_pass": true}, {"attribute_expression": "private final InputStream inputStream = new TCPInputStream(this);", "docstring": "\nCustom <tt>InputStream</tt> for this <tt>Socket</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "InputStream", "name": "inputStream = new TCPInputStream(this)", "syntax_pass": true}, {"attribute_expression": "private final MultiplexingXXXSocketSupport<MultiplexedSocket>\n        multiplexingXXXSocketSupport\n            = new MultiplexingXXXSocketSupport<MultiplexedSocket>()\n            {\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected MultiplexedSocket createSocket(\n                        DatagramPacketFilter filter)\n                    throws SocketException\n                {\n                    return\n                        new MultiplexedSocket(MultiplexingSocket.this, filter);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected void doReceive(DatagramPacket p)\n                    throws IOException\n                {\n                    multiplexingXXXSocketSupportDoReceive(p);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected void doSetReceiveBufferSize(int receiveBufferSize)\n                    throws SocketException\n                {\n                    multiplexingXXXSocketSupportDoSetReceiveBufferSize(\n                            receiveBufferSize);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected SocketReceiveBuffer getReceived()\n                {\n                    return received;\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected SocketReceiveBuffer getReceived(\n                        MultiplexedSocket socket)\n                {\n                    return socket.received;\n                }\n            };", "docstring": "\nThe {@code MultiplexingXXXSocketSupport} which implements functionality\ncommon to TCP and UDP sockets in order to facilitate implementers such as\nthis instance.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "MultiplexingXXXSocketSupport<MultiplexedSocket>", "name": "multiplexingXXXSocketSupport\n            = new MultiplexingXXXSocketSupport<MultiplexedSocket>()\n            {\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected MultiplexedSocket createSocket(\n                        DatagramPacketFilter filter)\n                    throws SocketException\n                {\n                    return\n                        new MultiplexedSocket(MultiplexingSocket.this, filter);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected void doReceive(DatagramPacket p)\n                    throws IOException\n                {\n                    multiplexingXXXSocketSupportDoReceive(p);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected void doSetReceiveBufferSize(int receiveBufferSize)\n                    throws SocketException\n                {\n                    multiplexingXXXSocketSupportDoSetReceiveBufferSize(\n                            receiveBufferSize);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected SocketReceiveBuffer getReceived()\n                {\n                    return received;\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected SocketReceiveBuffer getReceived(\n                        MultiplexedSocket socket)\n                {\n                    return socket.received;\n                }\n            }", "syntax_pass": true}, {"attribute_expression": "private TCPOutputStream outputStream = null;", "docstring": "\nCustom <tt>OutputStream</tt> for this <tt>Socket</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TCPOutputStream", "name": "outputStream = null", "syntax_pass": true}, {"attribute_expression": "private final SocketReceiveBuffer received\n        = new SocketReceiveBuffer(this::getReceiveBufferSize);", "docstring": "\nThe list of <tt>DatagramPacket</tt>s to be received through this\n<tt>Socket</tt> i.e. not accepted by the <tt>DatagramFilter</tt>s of\n{@link #sockets} at the time of the reading from the network.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "SocketReceiveBuffer", "name": "received\n        = new SocketReceiveBuffer(this::getReceiveBufferSize)", "syntax_pass": true}, {"attribute_expression": "private int soTimeout = 0;", "docstring": "\nBuffer variable for storing the SO_TIMEOUT value set by the last\n<tt>setSoTimeout()</tt> call. Although not strictly needed, getting the\nlocally stored value as opposed to retrieving it from a parent\n<tt>getSoTimeout()</tt> call seems to significantly improve efficiency,\nat least on some platforms.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "soTimeout = 0", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper", "name": "IceTcpSocketWrapper", "file_path": "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java", "superclasses": "IceSocketWrapper", "methods": ["[]IceTcpSocketWrapper(Socket)", "[void]close()", "[InetAddress]getLocalAddress()", "[int]getLocalPort()", "[SocketAddress]getLocalSocketAddress()", "[Socket]getTCPSocket()", "[DatagramSocket]getUDPSocket()", "[void]receive(DatagramPacket)", "[void]send(DatagramPacket)"], "method_uris": ["src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[]IceTcpSocketWrapper(Socket)", "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[void]close()", "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[InetAddress]getLocalAddress()", "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[int]getLocalPort()", "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[SocketAddress]getLocalSocketAddress()", "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[Socket]getTCPSocket()", "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[DatagramSocket]getUDPSocket()", "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[void]receive(DatagramPacket)", "src/main/java/org/ice4j/socket/IceTcpSocketWrapper.java.IceTcpSocketWrapper.[void]send(DatagramPacket)"], "overrides": null, "attributes": [], "class_docstring": "\nTCP implementation of the <tt>IceSocketWrapper</tt>.\n\n@author Sebastien Vincent\n", "original_string": "public class IceTcpSocketWrapper\n    extends IceSocketWrapper\n{\n    /**\n     * InputStream for this socket.\n     */\n    private final InputStream inputStream;\n\n    /**\n     * OutputStream for this socket.\n     */\n    private final OutputStream outputStream;\n\n    /**\n     * Delegate TCP <tt>Socket</tt>.\n     */\n    private final Socket socket;\n\n    /**\n     * A <tt>DelegatingSocket</tt> view of {@link #socket} if the latter\n     * implements the former; otherwise, <tt>null</tt>.\n     */\n    private final DelegatingSocket socketAsDelegatingSocket;\n\n    /**\n     * Constructor.\n     *\n     * @param delegate delegate <tt>Socket</tt>\n     *\n     * @throws IOException if something goes wrong during initialization\n     */\n    public IceTcpSocketWrapper(Socket delegate)\n        throws IOException\n    {\n        socket = delegate;\n\n        if (delegate instanceof DelegatingSocket)\n        {\n            inputStream = null;\n            outputStream = null;\n            socketAsDelegatingSocket = (DelegatingSocket) delegate;\n        }\n        else\n        {\n            inputStream = delegate.getInputStream();\n            outputStream = delegate.getOutputStream();\n            socketAsDelegatingSocket = null;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void close()\n    {\n        try\n        {\n            socket.close();\n        }\n        catch(IOException e)\n        {\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InetAddress getLocalAddress()\n    {\n        return socket.getLocalAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getLocalPort()\n    {\n        return socket.getLocalPort();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SocketAddress getLocalSocketAddress()\n    {\n        return socket.getLocalSocketAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Socket getTCPSocket()\n    {\n        return socket;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public DatagramSocket getUDPSocket()\n    {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void receive(DatagramPacket p) throws IOException\n    {\n        if (socketAsDelegatingSocket != null)\n        {\n            socketAsDelegatingSocket.receive(p);\n        }\n        else\n        {\n            DelegatingSocket.receiveFromInputStream(\n                    p,\n                    inputStream,\n                    getLocalAddress(), getLocalPort());\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void send(DatagramPacket p)\n        throws IOException\n    {\n        if (socketAsDelegatingSocket != null)\n        {\n            socketAsDelegatingSocket.send(p);\n        }\n        else\n        {\n            int len = p.getLength();\n            int off = p.getOffset();\n            byte data[] = new byte[len + 2];\n\n            data[0] = (byte)((len >> 8) & 0xff);\n            data[1] = (byte)(len & 0xff);\n            System.arraycopy(p.getData(), off, data, 2, len);\n            outputStream.write(data, 0, len + 2);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final InputStream inputStream;", "docstring": "\nInputStream for this socket.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "InputStream", "name": "inputStream", "syntax_pass": true}, {"attribute_expression": "private final OutputStream outputStream;", "docstring": "\nOutputStream for this socket.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OutputStream", "name": "outputStream", "syntax_pass": true}, {"attribute_expression": "private final Socket socket;", "docstring": "\nDelegate TCP <tt>Socket</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Socket", "name": "socket", "syntax_pass": true}, {"attribute_expression": "private final DelegatingSocket socketAsDelegatingSocket;", "docstring": "\nA <tt>DelegatingSocket</tt> view of {@link #socket} if the latter\nimplements the former; otherwise, <tt>null</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DelegatingSocket", "name": "socketAsDelegatingSocket", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/TurnDatagramPacketFilter.java.TurnDatagramPacketFilter", "name": "TurnDatagramPacketFilter", "file_path": "src/main/java/org/ice4j/socket/TurnDatagramPacketFilter.java", "superclasses": "StunDatagramPacketFilter", "methods": ["[]TurnDatagramPacketFilter(TransportAddress)", "[boolean]accept(DatagramPacket)", "[boolean]acceptMethod(char)"], "method_uris": ["src/main/java/org/ice4j/socket/TurnDatagramPacketFilter.java.TurnDatagramPacketFilter.[]TurnDatagramPacketFilter(TransportAddress)", "src/main/java/org/ice4j/socket/TurnDatagramPacketFilter.java.TurnDatagramPacketFilter.[boolean]accept(DatagramPacket)", "src/main/java/org/ice4j/socket/TurnDatagramPacketFilter.java.TurnDatagramPacketFilter.[boolean]acceptMethod(char)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a <tt>DatagramPacketFilter</tt> which accepts\n<tt>DatagramPacket</tt>s which represent TURN messages defined in\nRFC 5766 \"Traversal Using Relays around NAT (TURN): Relay Extensions to\nSession Traversal Utilities for NAT (STUN)\" and which are part of the\ncommunication with a specific TURN server. <tt>TurnDatagramPacketFilter</tt>\ndoes not accept TURN ChannelData messages because they require knowledge of\nthe value of the \"Channel Number\" field.\n\n@author Lubomir Marinov\n", "original_string": "public class TurnDatagramPacketFilter\n    extends StunDatagramPacketFilter\n{\n\n    /**\n     * Initializes a new <tt>TurnDatagramPacketFilter</tt> which will accept\n     * <tt>DatagramPacket</tt>s which represent TURN messages and which are part\n     * of the communication with a specific TURN server.\n     *\n     * @param turnServer the <tt>TransportAddress</tt> of the TURN server\n     * <tt>DatagramPacket</tt>s representing TURN messages from and to which\n     * will be accepted by the new instance\n     */\n    public TurnDatagramPacketFilter(TransportAddress turnServer)\n    {\n        super(turnServer);\n    }\n\n    /**\n     * Determines whether a specific <tt>DatagramPacket</tt> represents a TURN\n     * message which is part of the communication with the TURN server\n     * associated with this instance.\n     *\n     * @param p the <tt>DatagramPacket</tt> to be checked whether it represents\n     * a TURN message which is part of the communicator with the TURN server\n     * associated with this instance\n     * @return <tt>true</tt> if the specified <tt>DatagramPacket</tt> represents\n     * a TURN message which is part of the communication with the TURN server\n     * associated with this instance; otherwise, <tt>false</tt>\n     */\n    @Override\n    public boolean accept(DatagramPacket p)\n    {\n        if (super.accept(p))\n        {\n            /*\n             * The specified DatagramPacket represents a STUN message with a\n             * TURN method.\n             */\n            return true;\n        }\n        else\n        {\n\n            /*\n             * The specified DatagramPacket does not come from or is not being\n             * sent to the TURN server associated with this instance or is a\n             * ChannelData message which is not supported by\n             * TurnDatagramPacketFilter.\n             */\n            return false;\n        }\n    }\n\n    /**\n     * Determines whether this <tt>DatagramPacketFilter</tt> accepts a\n     * <tt>DatagramPacket</tt> which represents a STUN message with a specific\n     * STUN method. <tt>TurnDatagramPacketFilter</tt> accepts TURN methods.\n     *\n     * @param method the STUN method of a STUN message represented by a\n     * <tt>DatagramPacket</tt> to be checked whether it is accepted by this\n     * <tt>DatagramPacketFilter</tt>\n     * @return <tt>true</tt> if this <tt>DatagramPacketFilter</tt> accepts the\n     * <tt>DatagramPacket</tt> which represents a STUN message with the\n     * specified STUN method; otherwise, <tt>false</tt>\n     * @see StunDatagramPacketFilter#acceptMethod(char)\n     */\n    @Override\n    protected boolean acceptMethod(char method)\n    {\n        if (super.acceptMethod(method))\n            return true;\n        else\n        {\n            switch (method)\n            {\n            case Message.TURN_METHOD_ALLOCATE:\n            case Message.TURN_METHOD_CHANNELBIND:\n            case Message.TURN_METHOD_CREATEPERMISSION:\n            case Message.TURN_METHOD_DATA:\n            case Message.TURN_METHOD_REFRESH:\n            case Message.TURN_METHOD_SEND:\n            case 0x0005: /* old TURN DATA indication */\n                return true;\n            default:\n                return false;\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper", "name": "IceUdpSocketWrapper", "file_path": "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java", "superclasses": "IceSocketWrapper", "methods": ["[]IceUdpSocketWrapper(DatagramSocket)", "[void]send(DatagramPacket)", "[void]receive(DatagramPacket)", "[void]close()", "[InetAddress]getLocalAddress()", "[int]getLocalPort()", "[SocketAddress]getLocalSocketAddress()", "[Socket]getTCPSocket()", "[DatagramSocket]getUDPSocket()"], "method_uris": ["src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[]IceUdpSocketWrapper(DatagramSocket)", "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[void]send(DatagramPacket)", "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[void]receive(DatagramPacket)", "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[void]close()", "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[InetAddress]getLocalAddress()", "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[int]getLocalPort()", "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[SocketAddress]getLocalSocketAddress()", "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[Socket]getTCPSocket()", "src/main/java/org/ice4j/socket/IceUdpSocketWrapper.java.IceUdpSocketWrapper.[DatagramSocket]getUDPSocket()"], "overrides": null, "attributes": [], "class_docstring": "\nUDP implementation of the <tt>IceSocketWrapper</tt>.\n\n@author Sebastien Vincent\n", "original_string": "public class IceUdpSocketWrapper\n    extends IceSocketWrapper\n{\n    /**\n     * Delegate UDP <tt>DatagramSocket</tt>.\n     */\n    private final DatagramSocket socket;\n\n    /**\n     * Constructor.\n     *\n     * @param delegate delegate <tt>DatagramSocket</tt>\n     */\n    public IceUdpSocketWrapper(DatagramSocket delegate)\n    {\n        this.socket = delegate;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void send(DatagramPacket p)\n        throws IOException\n    {\n        socket.send(p);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void receive(DatagramPacket p) throws IOException\n    {\n        socket.receive(p);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void close()\n    {\n        socket.close();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InetAddress getLocalAddress()\n    {\n        return socket.getLocalAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getLocalPort()\n    {\n        return socket.getLocalPort();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SocketAddress getLocalSocketAddress()\n    {\n        return socket.getLocalSocketAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Socket getTCPSocket()\n    {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public DatagramSocket getUDPSocket()\n    {\n        return socket;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final DatagramSocket socket;", "docstring": "\nDelegate UDP <tt>DatagramSocket</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DatagramSocket", "name": "socket", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel", "name": "BaseDelegatingServerSocketChannel", "file_path": "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java", "superclasses": "ServerSocketChannel", "methods": ["[]BaseDelegatingServerSocketChannel(T)", "[SocketChannel]accept()", "[ServerSocketChannel]bind(SocketAddress,int)", "[SocketAddress]getLocalAddress()", "[U]getOption(SocketOption<U>)", "[SocketChannel]implAccept(SocketChannel)", "[void]implCloseSelectableChannel()", "[void]implConfigureBlocking(boolean)", "[ServerSocket]implSocket(ServerSocket)", "[boolean]isBound()", "[ServerSocketChannel]setOption(SocketOption<U>,U)", "[ServerSocket]socket()", "[Set<SocketOption<?>>]supportedOptions()"], "method_uris": ["src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[]BaseDelegatingServerSocketChannel(T)", "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[SocketChannel]accept()", "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[ServerSocketChannel]bind(SocketAddress,int)", "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[SocketAddress]getLocalAddress()", "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[U]getOption(SocketOption<U>)", "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[SocketChannel]implAccept(SocketChannel)", "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[void]implCloseSelectableChannel()", "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[void]implConfigureBlocking(boolean)", "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[ServerSocket]implSocket(ServerSocket)", "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[boolean]isBound()", "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[ServerSocketChannel]setOption(SocketOption<U>,U)", "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[ServerSocket]socket()", "src/main/java/org/ice4j/socket/BaseDelegatingServerSocketChannel.java.BaseDelegatingServerSocketChannel.[Set<SocketOption<?>>]supportedOptions()"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a {@code ServerSocketChannel} which delegates (its method calls)\nto another {@code ServerSocketChannel}. In other words, the former wraps the\nlatter.\n\n@author Lyubomir Marinov\n", "original_string": "public class BaseDelegatingServerSocketChannel<T extends ServerSocketChannel>\n    extends ServerSocketChannel\n{\n    /**\n     * The {@link ServerSocketChannel} this instance delegates (its method\n     * calls) to.\n     */\n    protected final T delegate;\n\n    /**\n     * The {@code ServerSocket} to be reported by this instance.\n     */\n    private ServerSocket socket;\n\n    /**\n     * The <tt>Object</tt> which synchronizes the access to {@link #socket}.\n     */\n    private final Object socketSyncRoot = new Object();\n\n    /**\n     * Initializes a new {@code BaseDelegatingServerSocketChannel} instance\n     * which is to delegate (its method calls) to a specific\n     * {@code ServerSocketChannel}.\n     *\n     * @param delegate the {@code ServerSocketChannel} the new instance is to\n     * delegate (its method calls) to\n     */\n    public BaseDelegatingServerSocketChannel(T delegate)\n    {\n        super(delegate.provider());\n\n        this.delegate = delegate;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public SocketChannel accept()\n        throws IOException\n    {\n        SocketChannel channel = delegate.accept();\n\n        return (channel == null) ? null : implAccept(channel);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate} and returns {@code this}.\n     */\n    @Override\n    public ServerSocketChannel bind(SocketAddress local, int backlog)\n        throws IOException\n    {\n        delegate.bind(local, backlog);\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public SocketAddress getLocalAddress()\n        throws IOException\n    {\n        return delegate.getLocalAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public <U> U getOption(SocketOption<U> name)\n        throws IOException\n    {\n        return delegate.getOption(name);\n    }\n\n    /**\n     * Allows extenders to optionally configure (e.g. wrap) a\n     * <tt>SocketChannel</tt> which has been accepted by {@link #delegate} and\n     * before it is returned by {@link #accept()}.\n     *\n     * @param accepted the <tt>SocketChannel</tt> accepted by <tt>delegate</tt>\n     * @return the <tt>SocketChannel</tt> to be returned by {@link #accept()}\n     * (in place of <tt>accepted</tt>)\n     * @throws IOException if an I/O error occurs\n     */\n    protected SocketChannel implAccept(SocketChannel accepted)\n        throws IOException\n    {\n        return accepted;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    protected void implCloseSelectableChannel()\n        throws IOException\n    {\n        delegate.close();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    protected void implConfigureBlocking(boolean block)\n        throws IOException\n    {\n        delegate.configureBlocking(block);\n    }\n\n    /**\n     * Allows extenders to optionally configure (e.g. wrap) the\n     * {@code ServerSocket} of {@link #delegate} and before it is returned by\n     * {@link #socket()}.\n     *\n     * @param socket the {@code ServerSocket} of {@code delegate}\n     * @return the {@code ServerSocket} to be returned by {@link #socket()} (in\n     * place of {@code socket})\n     * @throws IOException if an I/O error occurs\n     */\n    protected ServerSocket implSocket(ServerSocket socket)\n        throws IOException\n    {\n        return new DelegatingServerSocket(socket, this);\n    }\n\n    /**\n     * Determines whether this {@code BaseDelegatingServerSocketChannel} is\n     * bound.\n     *\n     * @return {@code true} if this instancei bound; otherwise, {@code false}\n     */\n    public boolean isBound()\n    {\n        try\n        {\n            return getLocalAddress() != null;\n        }\n        catch (IOException ioe)\n        {\n            return false;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate} and returns {@code this}.\n     */\n    @Override\n    public <U> ServerSocketChannel setOption(SocketOption<U> name, U value)\n        throws IOException\n    {\n        delegate.setOption(name, value);\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Allows wrapping the {@code socket} of {@link #delegate}.\n     */\n    @Override\n    public ServerSocket socket()\n    {\n        ServerSocket socket = delegate.socket();\n\n        synchronized (socketSyncRoot)\n        {\n            if (this.socket == null)\n            {\n                if (socket != null)\n                {\n                    try\n                    {\n                        this.socket = implSocket(socket);\n                    }\n                    catch (IOException ioe)\n                    {\n                        throw new RuntimeException(ioe);\n                    }\n                }\n            }\n            else if (socket == null)\n            {\n                this.socket = null;\n            }\n            else\n            {\n                // TODO For the sake of completeness, maybe check that the\n                // value of this.socket still delegates to the latest value of\n                // socket. However, the value of socket is very likely final so\n                // do not bother with it at the time of this writing.\n            }\n            return this.socket;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public Set<SocketOption<?>> supportedOptions()\n    {\n        return delegate.supportedOptions();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected final T delegate;", "docstring": "\nThe {@link ServerSocketChannel} this instance delegates (its method\ncalls) to.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "T", "name": "delegate", "syntax_pass": true}, {"attribute_expression": "private ServerSocket socket;", "docstring": "\nThe {@code ServerSocket} to be reported by this instance.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ServerSocket", "name": "socket", "syntax_pass": true}, {"attribute_expression": "private final Object socketSyncRoot = new Object();", "docstring": "\nThe <tt>Object</tt> which synchronizes the access to {@link #socket}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "socketSyncRoot = new Object()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket", "name": "SafeCloseDatagramSocket", "file_path": "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java", "superclasses": "DelegatingDatagramSocket", "methods": ["[]SafeCloseDatagramSocket()", "[]SafeCloseDatagramSocket(DatagramSocket)", "[]SafeCloseDatagramSocket(int)", "[]SafeCloseDatagramSocket(int,InetAddress)", "[]SafeCloseDatagramSocket(SocketAddress)", "[void]close()", "[void]receive(DatagramPacket)"], "method_uris": ["src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket.[]SafeCloseDatagramSocket()", "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket.[]SafeCloseDatagramSocket(DatagramSocket)", "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket.[]SafeCloseDatagramSocket(int)", "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket.[]SafeCloseDatagramSocket(int,InetAddress)", "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket.[]SafeCloseDatagramSocket(SocketAddress)", "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket.[void]close()", "src/main/java/org/ice4j/socket/SafeCloseDatagramSocket.java.SafeCloseDatagramSocket.[void]receive(DatagramPacket)"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents a <tt>DatagramSocket</tt> which fixes the following problem: when\n{@link DatagramSocket#close()} is called while another thread is blocked in\nits {@link DatagramSocket#receive(DatagramPacket)}, calling\n{@link DatagramSocket#bind(SocketAddress)} throws an \"Already bound\"\nexception until (the native counterpart of) the <tt>receive</tt> method\nreturns.\n\n@author Lubomir Marinov\n@author Yura Yaroshevich\n", "original_string": "public class SafeCloseDatagramSocket\n    extends DelegatingDatagramSocket\n{\n    /**\n     * A reader-writer lock to prevent {@link #close()} completion if any thread\n     * is blocked within {@link #receive(DatagramPacket)}.\n     */\n    private final ReadWriteLock receiveCloseLock\n        = new ReentrantReadWriteLock();\n\n    /**\n     * Initializes a new <tt>SafeCloseDatagramSocket</tt> instance and binds it\n     * to any available port on the local host machine.  The socket will be\n     * bound to the wildcard address, an IP address chosen by the kernel.\n     *\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     * @see DatagramSocket#DatagramSocket()\n     */\n    public SafeCloseDatagramSocket()\n        throws SocketException\n    {\n        super();\n    }\n\n    /**\n     * Initializes a new <tt>SafeCloseDatagramSocket</tt> instance which to\n     * implement the <tt>DatagramSocket</tt> functionality by delegating to a\n     * specific <tt>DatagramSocket</tt>.\n     *\n     * @param delegate the <tt>DatagramSocket</tt> to which the new instance is\n     * to delegate\n     * @throws SocketException if anything goes wrong while initializing the new\n     * <tt>SafeCloseDatagramSocket</tt> instance\n     */\n    public SafeCloseDatagramSocket(DatagramSocket delegate)\n        throws SocketException\n    {\n        super(delegate);\n    }\n\n    /**\n     * Initializes a new <tt>SafeCloseDatagramSocket</tt> instance  and binds it\n     * to the specified port on the local host machine.  The socket will be\n     * bound to the wildcard address, an IP address chosen by the kernel.\n     *\n     * @param port the port to bind the new socket to\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     * @see DatagramSocket#DatagramSocket(int)\n     */\n    public SafeCloseDatagramSocket(int port)\n        throws SocketException\n    {\n        super(port);\n    }\n\n    /**\n     * Initializes a new <tt>SafeCloseDatagramSocket</tt> instance bound to the\n     * specified local address.  The local port must be between 0 and 65535\n     * inclusive. If the IP address is 0.0.0.0, the socket will be bound to the\n     * wildcard address, an IP address chosen by the kernel.\n     *\n     * @param port the local port to bind the new socket to\n     * @param laddr the local address to bind the new socket to\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     * @see DatagramSocket#DatagramSocket(int, InetAddress)\n     */\n    public SafeCloseDatagramSocket(int port, InetAddress laddr)\n        throws SocketException\n    {\n        super(port, laddr);\n    }\n\n    /**\n     * Creates a datagram socket, bound to the specified local socket address.\n     * <p>\n     * If, if the address is <tt>null</tt>, creates an unbound socket.\n     * </p>\n     *\n     * @param bindaddr local socket address to bind, or <tt>null</tt> for an\n     * unbound socket\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     */\n    public SafeCloseDatagramSocket(SocketAddress bindaddr)\n        throws SocketException\n    {\n        super(bindaddr);\n    }\n\n    /**\n     * Closes this datagram socket.\n     * <p>\n     * Any thread currently blocked in {@link #receive} upon this socket will\n     * throw a {@link SocketException} and this datagram socket will wait for it\n     * to return.\n     * </p>\n     *\n     * @see DatagramSocket#close()\n     */\n    @Override\n    public void close()\n    {\n        super.close();\n\n        final Lock closeLock = receiveCloseLock.writeLock();\n        closeLock.lock();\n        // we now know all read threads have finished\n        closeLock.unlock();\n    }\n\n    /**\n     * Receives a datagram packet from this socket. When this method returns,\n     * the <tt>DatagramPacket</tt>'s buffer is filled with the data received.\n     * The datagram packet also contains the sender's IP address, and the port\n     * number on the sender's machine.\n     * <p>\n     * This method blocks until a datagram is received. The <tt>length</tt>\n     * field of the datagram packet object contains the length of the received\n     * message. If the message is longer than the packet's length, the message\n     * is truncated.\n     * </p>\n     *\n     * @param p the <tt>DatagramPacket</tt> into which to place the incoming\n     * data\n     * @throws  IOException if an I/O error occurs\n     * @see DatagramSocket#receive(DatagramPacket)\n     */\n    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        final Lock receiveLock = receiveCloseLock.readLock();\n        receiveLock.lock();\n        try\n        {\n            super.receive(p);\n        }\n        finally\n        {\n            receiveLock.unlock();\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final ReadWriteLock receiveCloseLock\n        = new ReentrantReadWriteLock();", "docstring": "\nA reader-writer lock to prevent {@link #close()} completion if any thread\nis blocked within {@link #receive(DatagramPacket)}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ReadWriteLock", "name": "receiveCloseLock\n        = new ReentrantReadWriteLock()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket", "name": "GoogleRelayedCandidateSocket", "file_path": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java", "superclasses": "DelegatingSocket", "methods": ["[]GoogleRelayedCandidateSocket(GoogleRelayedCandidate,GoogleTurnCandidateHarvest,String)", "[void]close()", "[InetAddress]getLocalAddress()", "[int]getLocalPort()", "[InetSocketAddress]getLocalSocketAddress()", "[GoogleRelayedCandidate]getRelayedCandidate()", "[void]processSuccess(Response,Request)", "[void]processResponse(StunResponseEvent)", "[void]receive(DatagramPacket)", "[void]send(DatagramPacket)", "[OutputStream]getOutputStream()"], "method_uris": ["src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[]GoogleRelayedCandidateSocket(GoogleRelayedCandidate,GoogleTurnCandidateHarvest,String)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[void]close()", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[InetAddress]getLocalAddress()", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[int]getLocalPort()", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[InetSocketAddress]getLocalSocketAddress()", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[GoogleRelayedCandidate]getRelayedCandidate()", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[void]processSuccess(Response,Request)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[void]processResponse(StunResponseEvent)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[void]receive(DatagramPacket)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[void]send(DatagramPacket)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateSocket.java.GoogleRelayedCandidateSocket.[OutputStream]getOutputStream()"], "overrides": null, "attributes": [{"original_string": "    protected class TCPOutputStream\n        extends OutputStream\n    {\n        /**\n         * Target transport address.\n         */\n        private final TransportAddress target;\n\n        /**\n         * Initializes a new <tt>TCPOutputStream</tt>.\n         *\n         * @param target <tt>TransportAddress</tt>\n         */\n        public TCPOutputStream(TransportAddress target)\n        {\n            this.target = target;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void close()\n            throws IOException\n        {\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void flush()\n            throws IOException\n        {\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void write(byte[] b)\n            throws IOException\n        {\n            write(b, 0, b.length);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void write(byte[] b, int off, int len)\n            throws IOException\n        {\n            DatagramPacket p = new DatagramPacket(\n                b,\n                off,\n                len,\n                target);\n\n            send(p);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void write(int arg0) throws IOException\n        {\n            // TODO Auto-generated method stub\n        }\n    }", "definition": "    protected class TCPOutputStream\n        extends OutputStream", "class_docstring": "\nTCP output stream for TCP socket. It is used to multiplex sockets and keep\nthe <tt>OutputStream</tt> interface to users.\n\n@author Sebastien Vincent\n", "name": "TCPOutputStream", "super_interfaces": [], "superclasses": "OutputStream", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "fields": [{"attribute_expression": "private final TransportAddress target;", "docstring": "\nTarget transport address.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "target", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TCPOutputStream(TransportAddress target)\n        {\n            this.target = target;\n        }", "docstring": "\nInitializes a new <tt>TCPOutputStream</tt>.\n\n@param target <tt>TransportAddress</tt>\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TCPOutputStream", "params": [{"name": "target", "type": "TransportAddress"}], "body": "        {\n            this.target = target;\n        }", "signature": "public TCPOutputStream(TransportAddress target)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void close()\n            throws IOException\n        {\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "close", "params": [], "body": "        {\n        }", "signature": "@Override\n        public void close()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void flush()\n            throws IOException\n        {\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "flush", "params": [], "body": "        {\n        }", "signature": "@Override\n        public void flush()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void write(byte[] b)\n            throws IOException\n        {\n            write(b, 0, b.length);\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "write", "params": [{"name": "b", "type": "byte[]"}], "body": "        {\n            write(b, 0, b.length);\n        }", "signature": "@Override\n        public void write(byte[] b)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void write(byte[] b, int off, int len)\n            throws IOException\n        {\n            DatagramPacket p = new DatagramPacket(\n                b,\n                off,\n                len,\n                target);\n\n            send(p);\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "write", "params": [{"name": "b", "type": "byte[]"}, {"name": "off", "type": "int"}, {"name": "len", "type": "int"}], "body": "        {\n            DatagramPacket p = new DatagramPacket(\n                b,\n                off,\n                len,\n                target);\n\n            send(p);\n        }", "signature": "@Override\n        public void write(byte[] b, int off, int len)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void write(int arg0) throws IOException\n        {\n            // TODO Auto-generated method stub\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "write", "params": [{"name": "arg0", "type": "int"}], "body": "        {\n            // TODO Auto-generated method stub\n        }", "signature": "@Override\n        public void write(int arg0)"}]}], "class_docstring": "\nRepresents an application-purposed (as opposed to an ICE-specific)\n<tt>Socket</tt> for a <tt>RelayedCandidate</tt> harvested by a\n<tt>TurnCandidateHarvest</tt> (and its associated\n<tt>TurnCandidateHarvester</tt>, of course).\n<tt>GoogleRelayedCandidateSocket</tt> is associated with a successful\nAllocation on a TURN server and implements sends and receives through it\nusing TURN messages to and from that TURN server.\n\n@author Lyubomir Marinov\n@author Sebastien Vincent\n", "original_string": "public class GoogleRelayedCandidateSocket\n    extends DelegatingSocket\n{\n    /**\n     * The <tt>Logger</tt> used by the\n     * <tt>GoogleRelayedCandidateSocket</tt> class and its instances for\n     * logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(\n                GoogleRelayedCandidateSocket.class.getName());\n\n    /**\n     * The indicator which determines whether this instance has started\n     * executing or has executed its {@link #close()} method.\n     */\n    private boolean closed = false;\n\n    /**\n     * The <tt>GoogleRelayedCandidate</tt> which uses this instance as the value\n     * of its <tt>socket</tt> property.\n     */\n    private final GoogleRelayedCandidate relayedCandidate;\n\n    /**\n     * The <tt>GoogleTurnCandidateDelegage</tt> which will handle send/receive\n     * operations.\n     */\n    private final GoogleRelayedCandidateDelegate socketDelegate;\n\n    /**\n     * The <tt>OutputStream</tt>.\n     */\n    private TCPOutputStream outputStream = null;\n\n    /**\n     * Initializes a new <tt>GoogleRelayedCandidateSocket</tt> instance\n     * which is to be the <tt>socket</tt> of a specific\n     * <tt>RelayedCandidate</tt> harvested by a specific\n     * <tt>TurnCandidateHarvest</tt>.\n     *\n     * @param relayedCandidate the <tt>RelayedCandidate</tt> which is to use the\n     * new instance as the value of its <tt>socket</tt> property\n     * @param turnCandidateHarvest the <tt>TurnCandidateHarvest</tt> which has\n     * harvested <tt>relayedCandidate</tt>\n     * @param username username\n     * @throws SocketException if anything goes wrong while initializing the new\n     * <tt>GoogleRelayedCandidateSocket</tt> instance\n     */\n    public GoogleRelayedCandidateSocket(\n            GoogleRelayedCandidate relayedCandidate,\n            GoogleTurnCandidateHarvest turnCandidateHarvest,\n            String username)\n        throws SocketException\n    {\n        super();\n\n        this.relayedCandidate = relayedCandidate;\n        socketDelegate = new GoogleRelayedCandidateDelegate(\n            turnCandidateHarvest, username);\n\n        logger.finest(\"Create new GoogleRelayedCandidateSocket\");\n    }\n\n    /**\n     * Closes this datagram socket.\n     *\n     * @see Socket#close()\n     */\n    @Override\n    public void close()\n    {\n        synchronized (this)\n        {\n            if (this.closed)\n                return;\n            else\n                this.closed = true;\n        }\n        socketDelegate.close();\n    }\n\n    /**\n     * Gets the local address to which the socket is bound.\n     * <tt>GoogleRelayedCandidateSocket</tt> returns the\n     * <tt>address</tt> of its <tt>localSocketAddress</tt>.\n     * <p>\n     * If there is a security manager, its <tt>checkConnect</tt> method is first\n     * called with the host address and <tt>-1</tt> as its arguments to see if\n     * the operation is allowed.\n     * </p>\n     *\n     * @return the local address to which the socket is bound, or an\n     * <tt>InetAddress</tt> representing any local address if either the socket\n     * is not bound, or the security manager <tt>checkConnect</tt> method does\n     * not allow the operation\n     * @see #getLocalSocketAddress()\n     * @see Socket#getLocalAddress()\n     */\n    @Override\n    public InetAddress getLocalAddress()\n    {\n        return getLocalSocketAddress().getAddress();\n    }\n\n    /**\n     * Returns the port number on the local host to which this socket is bound.\n     * <tt>GoogleRelayedCandidateSocket</tt> returns the <tt>port</tt>\n     * of its <tt>localSocketAddress</tt>.\n     *\n     * @return the port number on the local host to which this socket is bound\n     * @see #getLocalSocketAddress()\n     * @see Socket#getLocalPort()\n     */\n    @Override\n    public int getLocalPort()\n    {\n        return getLocalSocketAddress().getPort();\n    }\n\n    /**\n     * Returns the address of the endpoint this socket is bound to, or\n     * <tt>null</tt> if it is not bound yet. Since\n     * <tt>GoogleRelayedCandidateSocket</tt> represents an\n     * application-purposed <tt>Socket</tt> relaying data to and from a\n     * TURN server, the <tt>localSocketAddress</tt> is the\n     * <tt>transportAddress</tt> of the respective <tt>RelayedCandidate</tt>.\n     *\n     * @return a <tt>SocketAddress</tt> representing the local endpoint of this\n     * socket, or <tt>null</tt> if it is not bound yet\n     * @see Socket#getLocalSocketAddress()\n     */\n    @Override\n    public InetSocketAddress getLocalSocketAddress()\n    {\n        return getRelayedCandidate().getTransportAddress();\n    }\n\n    /**\n     * Gets the <tt>RelayedCandidate</tt> which uses this instance as the value\n     * of its <tt>socket</tt> property.\n     *\n     * @return the <tt>RelayedCandidate</tt> which uses this instance as the\n     * value of its <tt>socket</tt> property\n     */\n    public final GoogleRelayedCandidate getRelayedCandidate()\n    {\n        return relayedCandidate;\n    }\n\n    /**\n     * Notifies this <tt>GoogleRelayedCandidateSocket</tt> that a\n     * specific <tt>Request</tt> it has sent has received a STUN success\n     * <tt>Response</tt>.\n     *\n     * @param response the <tt>Response</tt> which responds to <tt>request</tt>\n     * @param request the <tt>Request</tt> sent by this instance to which\n     * <tt>response</tt> responds\n     */\n    public void processSuccess(Response response, Request request)\n    {\n        socketDelegate.processSuccess(response, request);\n    }\n\n    /**\n     * Dispatch the specified response.\n     *\n     * @param response the response to dispatch.\n     */\n    public void processResponse(StunResponseEvent response)\n    {\n        socketDelegate.processResponse(response);\n    }\n\n    /**\n     * Receives a datagram packet from this socket. When this method returns,\n     * the <tt>DatagramPacket</tt>'s buffer is filled with the data received.\n     * The datagram packet also contains the sender's IP address, and the port\n     * number on the sender's machine.\n     *\n     * @param p the <tt>DatagramPacket</tt> into which to place the incoming\n     * data\n     * @throws IOException if an I/O error occurs\n     */\n    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        socketDelegate.receive(p);\n    }\n\n    /**\n     * Sends a datagram packet from this socket. The <tt>DatagramPacket</tt>\n     * includes information indicating the data to be sent, its length, the IP\n     * address of the remote host, and the port number on the remote host.\n     *\n     * @param p the <tt>DatagramPacket</tt> to be sent\n     * @throws IOException if an I/O error occurs\n     */\n    public void send(DatagramPacket p)\n        throws IOException\n    {\n        socketDelegate.send(p);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public OutputStream getOutputStream()\n        throws IOException\n    {\n        if (outputStream == null)\n        {\n            CandidatePair pair =\n                relayedCandidate.getParentComponent().getSelectedPair();\n\n            if (pair.getLocalCandidate() == relayedCandidate)\n            {\n                TransportAddress target = pair.getRemoteCandidate().\n                    getTransportAddress();\n                outputStream = new TCPOutputStream(target);\n            }\n            else\n                throw new IOException(\"TURN-TCP socket is not selected\");\n        }\n\n        return outputStream;\n    }\n\n    /**\n     * TCP output stream for TCP socket. It is used to multiplex sockets and keep\n     * the <tt>OutputStream</tt> interface to users.\n     *\n     * @author Sebastien Vincent\n     */\n    protected class TCPOutputStream\n        extends OutputStream\n    {\n        /**\n         * Target transport address.\n         */\n        private final TransportAddress target;\n\n        /**\n         * Initializes a new <tt>TCPOutputStream</tt>.\n         *\n         * @param target <tt>TransportAddress</tt>\n         */\n        public TCPOutputStream(TransportAddress target)\n        {\n            this.target = target;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void close()\n            throws IOException\n        {\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void flush()\n            throws IOException\n        {\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void write(byte[] b)\n            throws IOException\n        {\n            write(b, 0, b.length);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void write(byte[] b, int off, int len)\n            throws IOException\n        {\n            DatagramPacket p = new DatagramPacket(\n                b,\n                off,\n                len,\n                target);\n\n            send(p);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void write(int arg0) throws IOException\n        {\n            // TODO Auto-generated method stub\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(\n                GoogleRelayedCandidateSocket.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the\n<tt>GoogleRelayedCandidateSocket</tt> class and its instances for\nlogging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(\n                GoogleRelayedCandidateSocket.class.getName())", "syntax_pass": true}, {"attribute_expression": "private boolean closed = false;", "docstring": "\nThe indicator which determines whether this instance has started\nexecuting or has executed its {@link #close()} method.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "closed = false", "syntax_pass": true}, {"attribute_expression": "private final GoogleRelayedCandidate relayedCandidate;", "docstring": "\nThe <tt>GoogleRelayedCandidate</tt> which uses this instance as the value\nof its <tt>socket</tt> property.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "GoogleRelayedCandidate", "name": "relayedCandidate", "syntax_pass": true}, {"attribute_expression": "private final GoogleRelayedCandidateDelegate socketDelegate;", "docstring": "\nThe <tt>GoogleTurnCandidateDelegage</tt> which will handle send/receive\noperations.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "GoogleRelayedCandidateDelegate", "name": "socketDelegate", "syntax_pass": true}, {"attribute_expression": "private TCPOutputStream outputStream = null;", "docstring": "\nThe <tt>OutputStream</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TCPOutputStream", "name": "outputStream = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/RtcpDemuxPacketFilter.java.RtcpDemuxPacketFilter", "name": "RtcpDemuxPacketFilter", "file_path": "src/main/java/org/ice4j/socket/RtcpDemuxPacketFilter.java", "superclasses": "", "methods": ["[boolean]isRtcpPacket(DatagramPacket)", "[boolean]accept(DatagramPacket)"], "method_uris": ["src/main/java/org/ice4j/socket/RtcpDemuxPacketFilter.java.RtcpDemuxPacketFilter.[boolean]isRtcpPacket(DatagramPacket)", "src/main/java/org/ice4j/socket/RtcpDemuxPacketFilter.java.RtcpDemuxPacketFilter.[boolean]accept(DatagramPacket)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a <tt>DatagramPacketFilter</tt> which only accepts\n<tt>DatagramPacket</tt>s which represent RTCP messages according to the rules\ndescribed in RFC5761.\n\n@author Emil Ivov\n@author Boris Grozev\n", "original_string": "public class RtcpDemuxPacketFilter\n    implements DatagramPacketFilter\n{\n    /**\n     * Determines whether a specific <tt>DatagramPacket</tt> is an RTCP.\n     * <tt>DatagramPacket</tt> in a selection based on this filter.\n     *\n     * RTP/RTCP packets are distinguished from other packets (such as STUN,\n     * DTLS or ZRTP) by the value of their first byte. See\n     * <a href=\"http://tools.ietf.org/html/rfc5764#section-5.1.2\">\n     * RFC5764, Section 5.1.2</a> and\n     * <a href=\"http://tools.ietf.org/html/rfc6189#section-5\">RFC6189,\n     * Section 5</a>.\n     *\n     * RTCP packets are distinguished from RTP packet based on the second byte\n     * (either Packet Type (RTCP) or M-bit and Payload Type (RTP). See\n     * <a href=\"http://tools.ietf.org/html/rfc5761#section-4\">RFC5761, Section\n     * 4</a>\n     *\n     * We assume that RTCP packets have a packet type in [200, 211]. This means\n     * that RTP packets with Payload Types in [72, 83] (which should not\n     * appear, because these PTs are reserved or unassigned by IANA, see\n     * <a href=\"http://www.iana.org/assignments/rtp-parameters/rtp-parameters.xhtml\">\n     * IANA RTP Parameters</a>) with the M-bit set will be misidentified as\n     * RTCP packets.\n     * \n     * Also, any RTCP packets with Packet Types not in [200, 211] will be\n     * misidentified as RTP packets.\n     *\n     * @param p the <tt>DatagramPacket</tt> whose protocol we'd like to\n     * determine.\n     * @return <tt>true</tt> if <tt>p</tt> is an RTCP and this filter accepts it\n     * and <tt>false</tt> otherwise.\n     */\n    public static boolean isRtcpPacket(DatagramPacket p)\n    {\n        int len = p.getLength();\n\n        if (len >= 4) //minimum RTCP message length\n        {\n            byte[] data = p.getData();\n            int off = p.getOffset();\n\n            if (((data[off] & 0xc0) >> 6) == 2) //RTP/RTCP version field\n            {\n                int pt = data[off + 1] & 0xff;\n\n                return (200 <= pt && pt <= 211);\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns <tt>true</tt> if this <tt>RtcpDemuxPacketFilter</tt> should\n     * accept <tt>p</tt>, that is, if <tt>p</tt> looks like an RTCP packet.\n     * See {@link #isRtcpPacket(java.net.DatagramPacket)}\n     * @return <tt>true</tt> if <tt>p</tt> looks like an RTCP packet.\n     */\n    public boolean accept(DatagramPacket p)\n    {\n        return isRtcpPacket(p);\n    }\n\n}", "super_interfaces": ["DatagramPacketFilter"], "fields": []}, {"uris": "src/main/java/org/ice4j/socket/HttpDemuxFilter.java.HttpDemuxFilter", "name": "HttpDemuxFilter", "file_path": "src/main/java/org/ice4j/socket/HttpDemuxFilter.java", "superclasses": "", "methods": ["[boolean]accept(DatagramPacket)"], "method_uris": ["src/main/java/org/ice4j/socket/HttpDemuxFilter.java.HttpDemuxFilter.[boolean]accept(DatagramPacket)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a {@link DatagramPacketFilter} which allows demultiplexing HTTP(S)\nout of {@code MuxServerSocketChannel}. Accepts HTTP, SSL v2, and TLS. Rejects\nGoogle TURN SSLTCP.\n\n@author Lyubomir Marinov\n", "original_string": "public class HttpDemuxFilter\n    implements DatagramPacketFilter\n{\n    /**\n     * The US-ASCII {@code byte}s of {@link #REQUEST_METHOD_STRINGS}. Explicitly\n     * defined for the purposes of performance.\n     */\n    private static byte[][] REQUEST_METHOD_BYTES;\n\n    /**\n     * The maximum US-ASCII character with which an element of\n     * {@link #REQUEST_METHOD_STRINGS} starts.\n     */\n    private static final char REQUEST_METHOD_MAX_CHAR;\n\n    /**\n     * The maximum length in {@code byte}s of a US-ASCII representation of an\n     * HTTP request method supported by the class {@code HttpDemuxFilter}.\n     */\n    public static final int REQUEST_METHOD_MAX_LENGTH;\n\n    /**\n     * The minimum US-ASCII character with which an element of\n     * {@link #REQUEST_METHOD_STRINGS} starts.\n     */\n    private static final char REQUEST_METHOD_MIN_CHAR;\n\n    /**\n     * The HTTP request methods recognized by the class {@code HttpDemuxFilter}.\n     */\n    private static String[] REQUEST_METHOD_STRINGS\n        = {\n            \"CONNECT\",\n            \"DELETE\",\n            \"GET\",\n            \"HEAD\",\n            \"MOVE\",\n            \"OPTIONS\",\n            \"PATCH\",\n            \"POST\",\n            \"PRI\",\n            \"PROXY\",\n            \"PUT\",\n            \"TRACE\"\n        };\n\n    /**\n     * The minimum number of bytes required by the class {@code HttpDemuxFilter}\n     * in order to declare that (the data of) a specific {@link DatagramPacket}\n     * represents TLS. \n     */\n    public static final int TLS_MIN_LENGTH = 11;\n\n    static\n    {\n        // Gather statistics about the supported HTTP request methods in order\n        // to speed up the analysis of DatagramPackets later on.\n        char maxChar = 'A';\n        int maxLength = Integer.MIN_VALUE;\n        char minChar = 'Z';\n        Charset ascii = Charset.forName(\"US-ASCII\");\n\n        REQUEST_METHOD_BYTES = new byte[REQUEST_METHOD_STRINGS.length][];\n        for (int i = 0; i < REQUEST_METHOD_STRINGS.length; i++)\n        {\n            String s = REQUEST_METHOD_STRINGS[i];\n\n            if (s != null && s.length() != 0)\n            {\n                char ch = s.charAt(0);\n                byte[] bytes = s.getBytes(ascii);\n                int length = bytes.length;\n\n                if (maxChar < ch)\n                    maxChar = ch;\n                if (maxLength < length)\n                    maxLength = length;\n                if (minChar > ch)\n                    minChar = ch;\n\n                REQUEST_METHOD_BYTES[i] = bytes;\n            }\n            else\n            {\n                REQUEST_METHOD_BYTES[i] = new byte[0];\n            }\n        }\n        REQUEST_METHOD_MAX_CHAR = maxChar;\n        REQUEST_METHOD_MAX_LENGTH = maxLength;\n        REQUEST_METHOD_MIN_CHAR = minChar;\n    }\n\n    /**\n     * Determines whether a specific {@link DatagramPacket} looks like the\n     * beginning of HTTP(S) client communication. Accepts HTTP, SSL v2, and\n     * TLS. Rejects Google TURN SSLTCP.\n     *\n     * @param p the {@code DatagramPacket} to analyze\n     * @return {@code true} if {@code p} looks like the beginning of HTTP(S)\n     * client communication; otherwise, {@code false}\n     */\n    @Override\n    public boolean accept(DatagramPacket p)\n    {\n        int len = p.getLength();\n        boolean accept = false;\n\n        if (len > 0)\n        {\n            byte[] buf = p.getData();\n            int off = p.getOffset();\n            // The first bytes of HTTP, SSL v2, and TLS are different so quickly\n            // determine which one of the three is possible and, respectively,\n            // which two of the three are impossible.\n            int b0 = 0xFF & buf[off];\n            boolean http, sslv2, tls;\n\n            if (b0 == 22 /* TLS handshake */)\n            {\n                http = false;\n                sslv2 = false;\n                tls = true;\n            }\n            else if (b0 > 0x80 /* SSL v2 client hello */)\n            {\n                http = false;\n                sslv2 = true;\n                tls = false;\n            }\n            else\n            {\n                http = true;\n                sslv2 = false;\n                tls = false;\n            }\n\n            // HTTP\n            if (http)\n            {\n                // Request-Line = Method SP Request-URI SP HTTP-Version CRLF\n                // HTTP-Version = \"HTTP\" \"/\" 1*DIGIT \".\" 1*DIGIT\n                if (b0 >= REQUEST_METHOD_MIN_CHAR\n                        && b0 <= REQUEST_METHOD_MAX_CHAR\n                        && len >= REQUEST_METHOD_MAX_LENGTH + 1 /* SP */)\n                {\n                    // Match a supported HTTP request method.\n                    for (byte[] bytes : REQUEST_METHOD_BYTES)\n                    {\n                        int length = bytes.length;\n\n                        if (buf[off + length] == ' ' /* SP */)\n                        {\n                            boolean equals = true;\n\n                            for (int i = 1, j = off + 1; i < length; i++, j++)\n                            {\n                                if (bytes[i] != buf[j])\n                                {\n                                    equals = false;\n                                    break;\n                                }\n                            }\n                            if (equals)\n                            {\n                                accept = true;\n                                break;\n                            }\n                        }\n                    }\n                }\n                // Only one of HTTP, SSL v2, and TLS was deemed possible by\n                // looking at the first byte. If p didn't look like HTTP here,\n                // then it will not look like SSL v2 or TLS.\n                return accept;\n            }\n\n            // HTTPS\n            if (tls)\n            {\n                // 1 byte   ContentType type = handshake(22)\n                // 2 bytes  ProtocolVersion version = { major(3) , minor<1..3> }\n                // 2 bytes  uint16 length\n                // 1 byte   HandshakeType msg_type = client_hello(1)\n                // 3 bytes  uint24 length\n                // 2 bytes  ProtocolVersion client_version\n                if (len >= TLS_MIN_LENGTH\n                        && /* major */ (0xFF & buf[off + 1]) == 3)\n                {\n                    int minor = 0xFF & buf[off + 2];\n\n                    if (1 <= minor\n                            && minor <= 3\n                            && /* msg_type */ (0xFF & buf[off + 5])\n                                == /* client_hello */ 1\n                            && /* major */ (0xFF & buf[off + 9]) == 3)\n                    {\n                        minor = 0xFF & buf[off + 10];\n                        if (1 <= minor && minor <= 3)\n                            accept = true;\n                    }\n                }\n                // Only one of HTTP, SSL v2, and TLS was deemed possible by\n                // looking at the first byte. If p didn't look like TLS here,\n                // then it will not look like HTTP or SSL v2.\n                return accept;\n            }\n            if (sslv2)\n            {\n                final byte[] googleTurnSslTcp\n                    = GoogleTurnSSLCandidateHarvester.SSL_CLIENT_HANDSHAKE;\n\n                // 2 bytes  uint15 length\n                // 1 byte   uint8 msg_type = 1\n                // 2 bytes  Version version\n                if (len > 5\n                        && len >= googleTurnSslTcp.length\n                        && /* msg_type */ (0xFF & buf[off + 2]) == 1\n                        && /* major */ (0xFF & buf[off + 3]) == 3)\n                {\n                    int minor = 0xFF & buf[off + 4];\n\n                    if (1 <= minor && minor <= 3)\n                    {\n                        // Reject Google TURN SSLTCP.\n                        boolean equals = true;\n\n                        for (int i = 0, iEnd = googleTurnSslTcp.length, j = off;\n                                i < iEnd;\n                                i++, j++)\n                        {\n                            if (googleTurnSslTcp[i] != buf[j])\n                            {\n                                equals = false;\n                                break;\n                            }\n                        }\n                        accept = !equals;\n                    }\n                }\n                // Only one of HTTP, SSL v2, and TLS was deemed possible by\n                // looking at the first byte. If p didn't look like SSL v2 here,\n                // then it will not look like HTTP or TLS.\n                return accept;\n            }\n        }\n        return accept;\n    }\n}", "super_interfaces": ["DatagramPacketFilter"], "fields": [{"attribute_expression": "private static byte[][] REQUEST_METHOD_BYTES;", "docstring": "\nThe US-ASCII {@code byte}s of {@link #REQUEST_METHOD_STRINGS}. Explicitly\ndefined for the purposes of performance.\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "byte[][]", "name": "REQUEST_METHOD_BYTES", "syntax_pass": true}, {"attribute_expression": "private static final char REQUEST_METHOD_MAX_CHAR;", "docstring": "\nThe maximum US-ASCII character with which an element of\n{@link #REQUEST_METHOD_STRINGS} starts.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "REQUEST_METHOD_MAX_CHAR", "syntax_pass": true}, {"attribute_expression": "public static final int REQUEST_METHOD_MAX_LENGTH;", "docstring": "\nThe maximum length in {@code byte}s of a US-ASCII representation of an\nHTTP request method supported by the class {@code HttpDemuxFilter}.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "REQUEST_METHOD_MAX_LENGTH", "syntax_pass": true}, {"attribute_expression": "private static final char REQUEST_METHOD_MIN_CHAR;", "docstring": "\nThe minimum US-ASCII character with which an element of\n{@link #REQUEST_METHOD_STRINGS} starts.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "REQUEST_METHOD_MIN_CHAR", "syntax_pass": true}, {"attribute_expression": "private static String[] REQUEST_METHOD_STRINGS\n        = {\n            \"CONNECT\",\n            \"DELETE\",\n            \"GET\",\n            \"HEAD\",\n            \"MOVE\",\n            \"OPTIONS\",\n            \"PATCH\",\n            \"POST\",\n            \"PRI\",\n            \"PROXY\",\n            \"PUT\",\n            \"TRACE\"\n        };", "docstring": "\nThe HTTP request methods recognized by the class {@code HttpDemuxFilter}.\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "String[]", "name": "REQUEST_METHOD_STRINGS\n        = {\n            \"CONNECT\",\n            \"DELETE\",\n            \"GET\",\n            \"HEAD\",\n            \"MOVE\",\n            \"OPTIONS\",\n            \"PATCH\",\n            \"POST\",\n            \"PRI\",\n            \"PROXY\",\n            \"PUT\",\n            \"TRACE\"\n        }", "syntax_pass": true}, {"attribute_expression": "public static final int TLS_MIN_LENGTH = 11;", "docstring": "\nThe minimum number of bytes required by the class {@code HttpDemuxFilter}\nin order to declare that (the data of) a specific {@link DatagramPacket}\nrepresents TLS. \n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "TLS_MIN_LENGTH = 11", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/SocketClosedException.java.SocketClosedException", "name": "SocketClosedException", "file_path": "src/main/java/org/ice4j/socket/SocketClosedException.java", "superclasses": "SocketException", "methods": ["[]SocketClosedException()"], "method_uris": ["src/main/java/org/ice4j/socket/SocketClosedException.java.SocketClosedException.[]SocketClosedException()"], "overrides": null, "attributes": [], "class_docstring": "\nAn exception that indicates that a socket is closed.\n", "original_string": "public class SocketClosedException\n    extends SocketException\n{\n    /**\n     * Initializes a new {@link SocketClosedException}.\n     */\n    public SocketClosedException()\n    {\n        // Keep the same message as the one used by jdk, since existing code\n        // might be matching against the string.\n        super(\"Socket closed\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket", "name": "DelegatingSocket", "file_path": "src/main/java/org/ice4j/socket/DelegatingSocket.java", "superclasses": "Socket", "methods": ["[void]receiveFromInputStream(DatagramPacket,InputStream,InetAddress,int)", "[]DelegatingSocket()", "[]DelegatingSocket(InetAddress,int)", "[]DelegatingSocket(InetAddress,int,InetAddress,int)", "[]DelegatingSocket(Proxy)", "[]DelegatingSocket(Socket)", "[]DelegatingSocket(Socket,SocketChannel)", "[]DelegatingSocket(SocketImpl)", "[]DelegatingSocket(String,int)", "[]DelegatingSocket(String,int,InetAddress,int)", "[void]bind(SocketAddress)", "[void]close()", "[void]connect(SocketAddress)", "[void]connect(SocketAddress,int)", "[SocketChannel]getChannel()", "[InetAddress]getInetAddress()", "[InputStream]getInputStream()", "[boolean]getKeepAlive()", "[InetAddress]getLocalAddress()", "[int]getLocalPort()", "[SocketAddress]getLocalSocketAddress()", "[boolean]getOOBInline()", "[OutputStream]getOutputStream()", "[int]getPort()", "[int]getReceiveBufferSize()", "[SocketAddress]getRemoteSocketAddress()", "[boolean]getReuseAddress()", "[int]getSendBufferSize()", "[int]getSoLinger()", "[int]getSoTimeout()", "[boolean]getTcpNoDelay()", "[int]getTrafficClass()", "[boolean]isBound()", "[boolean]isClosed()", "[boolean]isConnected()", "[boolean]isInputShutdown()", "[boolean]isOutputShutdown()", "[void]receive(DatagramPacket)", "[void]receiveFromChannel(SocketChannel,DatagramPacket)", "[void]send(DatagramPacket)", "[void]sendUrgentData(int)", "[void]setKeepAlive(boolean)", "[void]setOOBInline(boolean)", "[void]setOriginalInputStream(InputStream)", "[void]setPerformancePreferences(int,int,int)", "[void]setReceiveBufferSize(int)", "[void]setReuseAddress(boolean)", "[void]setSendBufferSize(int)", "[void]setSoLinger(boolean,int)", "[void]setSoTimeout(int)", "[void]setTcpNoDelay(boolean)", "[void]setTrafficClass(int)", "[void]shutdownInput()", "[void]shutdownOutput()", "[String]toString()"], "method_uris": ["src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]receiveFromInputStream(DatagramPacket,InputStream,InetAddress,int)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(InetAddress,int)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(InetAddress,int,InetAddress,int)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(Proxy)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(Socket)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(Socket,SocketChannel)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(SocketImpl)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(String,int)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[]DelegatingSocket(String,int,InetAddress,int)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]bind(SocketAddress)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]close()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]connect(SocketAddress)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]connect(SocketAddress,int)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[SocketChannel]getChannel()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[InetAddress]getInetAddress()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[InputStream]getInputStream()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]getKeepAlive()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[InetAddress]getLocalAddress()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[int]getLocalPort()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[SocketAddress]getLocalSocketAddress()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]getOOBInline()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[OutputStream]getOutputStream()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[int]getPort()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[int]getReceiveBufferSize()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[SocketAddress]getRemoteSocketAddress()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]getReuseAddress()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[int]getSendBufferSize()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[int]getSoLinger()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[int]getSoTimeout()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]getTcpNoDelay()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[int]getTrafficClass()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]isBound()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]isClosed()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]isConnected()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]isInputShutdown()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[boolean]isOutputShutdown()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]receive(DatagramPacket)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]receiveFromChannel(SocketChannel,DatagramPacket)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]send(DatagramPacket)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]sendUrgentData(int)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setKeepAlive(boolean)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setOOBInline(boolean)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setOriginalInputStream(InputStream)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setPerformancePreferences(int,int,int)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setReceiveBufferSize(int)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setReuseAddress(boolean)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setSendBufferSize(int)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setSoLinger(boolean,int)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setSoTimeout(int)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setTcpNoDelay(boolean)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]setTrafficClass(int)", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]shutdownInput()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[void]shutdownOutput()", "src/main/java/org/ice4j/socket/DelegatingSocket.java.DelegatingSocket.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a <tt>Socket</tt> which delegates its calls to a specific\n<tt>Socket</tt>.\n\n@author Sebastien Vincent\n@author Lyubomir Marinov\n", "original_string": "public class DelegatingSocket\n    extends Socket\n{\n    /**\n     * Receives an RFC4571-formatted frame from <tt>inputStream</tt> into\n     * <tt>p</tt>, and sets <tt>p</tt>'s port and address to <tt>port</tt> and\n     * <tt>inetAddress</tt>.\n     *\n     * @param p the <tt>DatagramPacket</tt> into which to place the incoming\n     * data.\n     * @param inputStream The TCP stream to be read.\n     * @param inetAddress The receiver address (local address) to set to the\n     * datagram packet.\n     * @param port The receiver port (local port) to set to the datagram packet.\n     *\n     * @throws IOException if an I/O error occurs\n     * @see #receive(DatagramPacket)\n     */\n    public static void receiveFromInputStream(\n            DatagramPacket p,\n            InputStream inputStream,\n            InetAddress inetAddress, int port)\n        throws IOException\n    {\n        int b0 = inputStream.read();\n        int b1 = inputStream.read();\n\n        // If we do not achieve to read the first bytes, then it was just a hole\n        // punch packet.\n        if (b0 == -1 || b1 == -1)\n        {\n            p.setLength(0);\n            throw new SocketException(\"read failed\");\n        }\n\n        int frameLen = ((b0 & 0xFF) << 8) | (b1 & 0xFF);\n        int readLen = 0;\n        byte[] data = p.getData();\n        int off = 0;\n\n        while (readLen < frameLen)\n        {\n            int len = inputStream.read(data, off, frameLen - off);\n\n            if (len == -1)\n            {\n                throw new SocketException(\"read failed\");\n            }\n            else\n            {\n                off += len;\n                readLen += len;\n            }\n        }\n\n        if (readLen == frameLen)\n        {\n            p.setAddress(inetAddress);\n            p.setData(data, 0, frameLen);\n            p.setPort(port);\n        }\n        else\n        {\n            throw new SocketException(\"Failed to receive data from socket\");\n        }\n    }\n\n    /**\n     * The <tt>SocketChannel</tt> (to be) returned by {@link #getChannel()}. If\n     * <tt>null</tt>, <tt>getChannel()</tt> forwards to {@link #delegate}. (If\n     * <tt>delegate</tt> is <tt>null</tt>, <tt>getChannel()</tt> invokes the\n     * super implementation.\n     */\n    protected final SocketChannel channel;\n\n    /**\n     * Delegate <tt>Socket</tt>.\n     */\n    protected final Socket delegate;\n\n    /**\n     * A <tt>DelegatingSocket</tt> view of {@link #delegate} if the latter\n     * implements the former; otherwise, <tt>null</tt>.\n     */\n    private final DelegatingSocket delegateAsDelegatingSocket;\n\n    /**\n     * The <tt>ByteBuffer</tt> instance used in\n     * {@link #receiveFromChannel(java.nio.channels.SocketChannel,\n     * java.net.DatagramPacket)} to read the 2-byte length field into.\n     */\n    private final ByteBuffer frameLengthByteBuffer = ByteBuffer.allocate(2);\n\n    /**\n     * InputStream for this socket.\n     */\n    private InputStream inputStream = null;\n\n    /**\n     * The number of non-STUN packets received for this socket.\n     */\n    private long nbReceivedPackets = 0;\n\n    /**\n     * The number of non-STUN packets sent for this socket.\n     */\n    private long nbSentPackets = 0;\n\n    /**\n     * OutputStream for this socket.\n     */\n    private OutputStream outputStream = null;\n\n    /**\n     * Initializes a new <tt>DelegatingSocket</tt>.\n     */\n    public DelegatingSocket()\n    {\n        this((Socket) null);\n    }\n\n    /**\n     * Initializes a new <tt>DelegatingSocket</tt>.\n     *\n     * @param address ignored\n     * @param port ignored\n     * @throws IOException never thrown\n     * @see Socket#Socket(InetAddress, int)\n     */\n    public DelegatingSocket(InetAddress address, int port)\n        throws IOException\n    {\n        this((Socket) null);\n    }\n\n    /**\n     * Initializes a new <tt>DelegatingSocket</tt>.\n     *\n     * @param address ignored\n     * @param port ignored\n     * @param localAddr ignored\n     * @param localPort ignored\n     * @see Socket#Socket(InetAddress, int, InetAddress, int)\n     * @throws IOException never thrown\n     */\n    public DelegatingSocket(\n            InetAddress address, int port,\n            InetAddress localAddr, int localPort)\n        throws IOException\n    {\n        this((Socket) null);\n    }\n\n    /**\n     * Initializes a new <tt>DelegatingSocket</tt>.\n     *\n     * @param proxy ignored\n     * @see Socket#Socket(Proxy)\n     */\n    public DelegatingSocket(Proxy proxy)\n    {\n        this((Socket) null);\n    }\n\n    /**\n     * Initializes a new <tt>DelegatingSocket</tt> instance which is to delegate\n     * (i.e. forwards) method calls to a specific <tt>Socket</tt>.\n     *\n     * @param delegate the <tt>Socket</tt> the new instance is to delegate to\n     */\n    public DelegatingSocket(Socket delegate)\n    {\n        this(delegate, (delegate == null) ? null : delegate.getChannel());\n    }\n\n    /**\n     * Initializes a new <tt>DelegatingSocket</tt> instance which is to delegate\n     * (i.e. forward) method calls to a specific <tt>Socket</tt> and to report\n     * (i.e. return) an association with a specific <tt>SocketChannel</tt>.\n     *\n     * @param delegate the <tt>Socket</tt> the new instance is to delegate to\n     * @param channel the <tt>SocketChannel</tt> to be returned by\n     * {@link #getChannel()}. If <tt>null</tt>, <tt>getChannel()</tt> forwards\n     * to <tt>delegate</tt>.\n     */\n    public DelegatingSocket(Socket delegate, SocketChannel channel)\n    {\n        this.delegate = delegate;\n        this.channel = channel;\n\n        if (delegate instanceof DelegatingSocket)\n        {\n            // FIXME BaseDelegatingSocketChannel was in need of a Socket which\n            // wraps another Socket and reports a specific SocketChannel. Since\n            // DelegatingSocket does that, BaseDelegatingSocketChannel used it.\n            // Unfortunately, it turned out after much debugging that\n            // DelegatingSocket has the additional function of flagging where\n            // UDP packets sent over TCP are to be framed. As a temporary fix,\n            // do not treat the sockets of DelegatingSocketChannel as\n            // DelegatingSockets.\n            if (channel instanceof BaseDelegatingSocketChannel)\n                delegateAsDelegatingSocket = null;\n            else\n                delegateAsDelegatingSocket = (DelegatingSocket) delegate;\n        }\n        else\n        {\n            delegateAsDelegatingSocket = null;\n        }\n    }\n\n    /**\n     * Initializes a new <tt>DelegatingSocket</tt>.\n     *\n     * @param impl  ignored\n     * @throws SocketException never thrown\n     * @see Socket#Socket(SocketImpl)\n     */\n    protected DelegatingSocket(SocketImpl impl)\n        throws SocketException\n    {\n        this((Socket) null);\n    }\n\n    /**\n     * Initializes a new <tt>DelegatingSocket</tt>.\n     *\n     * @param host ignored\n     * @param port ignored\n     * @throws UnknownHostException never thrown\n     * @throws IOException never thrown\n     * @see Socket#Socket(String, int)\n     */\n    public DelegatingSocket(String host, int port)\n        throws UnknownHostException, IOException\n    {\n        this((Socket) null);\n    }\n\n    /**\n     * Initializes a new <tt>DelegatingSocket</tt>.\n     *\n     * @param host ignored\n     * @param port ignored\n     * @param localAddr ignored\n     * @param localPort ignored\n     * @see Socket#Socket(String, int, InetAddress, int)\n     */\n    public DelegatingSocket(\n            String host, int port,\n            InetAddress localAddr, int localPort)\n    {\n        this((Socket) null);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void bind(SocketAddress bindpoint) throws IOException\n    {\n        if (delegate == null)\n            super.bind(bindpoint);\n        else\n            delegate.bind(bindpoint);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void close() throws IOException\n    {\n        if (delegate == null)\n            super.close();\n        else\n            delegate.close();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void connect(SocketAddress endpoint) throws IOException\n    {\n        if (delegate == null)\n            super.connect(endpoint);\n        else\n            delegate.connect(endpoint);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void connect(SocketAddress endpoint, int timeout) throws IOException\n    {\n        if (delegate == null)\n            super.connect(endpoint, timeout);\n        else\n            delegate.connect(endpoint, timeout);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SocketChannel getChannel()\n    {\n        SocketChannel channel = this.channel;\n\n        if (channel == null)\n        {\n            Socket delegate = this.delegate;\n\n            channel\n                = (delegate == null)\n                    ? super.getChannel()\n                    : delegate.getChannel();\n        }\n        return channel;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InetAddress getInetAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getInetAddress()\n                : delegate.getInetAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InputStream getInputStream() throws IOException\n    {\n        return\n            (delegate == null)\n                ? super.getInputStream()\n                : delegate.getInputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean getKeepAlive() throws SocketException\n    {\n        return\n            (delegate == null) ? super.getKeepAlive() : delegate.getKeepAlive();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InetAddress getLocalAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getLocalAddress()\n                : delegate.getLocalAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getLocalPort()\n    {\n        return\n            (delegate == null) ? super.getLocalPort() : delegate.getLocalPort();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SocketAddress getLocalSocketAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getLocalSocketAddress()\n                : delegate.getLocalSocketAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean getOOBInline() throws SocketException\n    {\n        return\n            (delegate == null) ? super.getOOBInline() : delegate.getOOBInline();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public OutputStream getOutputStream() throws IOException\n    {\n        return\n            (delegate == null)\n                ? super.getOutputStream()\n                : delegate.getOutputStream();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getPort()\n    {\n        return (delegate == null) ? super.getPort() : delegate.getPort();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getReceiveBufferSize() throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getReceiveBufferSize()\n                : delegate.getReceiveBufferSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SocketAddress getRemoteSocketAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getRemoteSocketAddress()\n                : delegate.getRemoteSocketAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean getReuseAddress() throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getReuseAddress()\n                : delegate.getReuseAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getSendBufferSize() throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getSendBufferSize()\n                : delegate.getSendBufferSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getSoLinger() throws SocketException\n    {\n        return\n            (delegate == null) ? super.getSoLinger() : delegate.getSoLinger();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getSoTimeout() throws SocketException\n    {\n        return\n            (delegate == null) ? super.getSoTimeout() : delegate.getSoTimeout();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean getTcpNoDelay() throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getTcpNoDelay()\n                : delegate.getTcpNoDelay();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getTrafficClass() throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getTrafficClass()\n                : delegate.getTrafficClass();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isBound()\n    {\n        return (delegate == null) ? super.isBound() : delegate.isBound();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isClosed()\n    {\n        return (delegate == null) ? super.isClosed() : delegate.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isConnected()\n    {\n        return\n            (delegate == null) ? super.isConnected() : delegate.isConnected();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isInputShutdown()\n    {\n        return\n            (delegate == null)\n                ? super.isInputShutdown()\n                : delegate.isInputShutdown();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isOutputShutdown()\n    {\n        return\n            (delegate == null)\n                ? super.isOutputShutdown()\n                : delegate.isOutputShutdown();\n    }\n\n    /**\n     * Receives a datagram packet from this socket. The <tt>DatagramPacket</tt>s\n     * returned by this method do not match any of the\n     * <tt>DatagramPacketFilter</tt>s of the <tt>MultiplexedSocket</tt>s\n     * associated with this instance at the time of their receipt. When this\n     * method returns, the <tt>DatagramPacket</tt>'s buffer is filled with the\n     * data received. The datagram packet also contains the sender's IP address,\n     * and the port number on the sender's machine.\n     * <p>\n     * This method blocks until a datagram is received. The <tt>length</tt>\n     * field of the datagram packet object contains the length of the received\n     * message. If the message is longer than the packet's length, the message\n     * is truncated.\n     * </p>\n     *\n     * @param p the <tt>DatagramPacket</tt> into which to place the incoming\n     *            data\n     * @throws IOException if an I/O error occurs\n     * @see #receive(DatagramPacket)\n     */\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        if (delegateAsDelegatingSocket != null)\n        {\n            delegateAsDelegatingSocket.receive(p);\n        }\n        else\n        {\n            SocketChannel channel = getChannel();\n\n            if (channel == null)\n            {\n                // Read from our InputStream\n                if (inputStream == null)\n                    inputStream = getInputStream();\n\n                DelegatingSocket.receiveFromInputStream(\n                        p,\n                        inputStream,\n                        getInetAddress(), getPort());\n            }\n            else\n            {\n                // For nio SocketChannel-s, the read() from the InputStream and\n                // the write() to the OutputStream both lock on the same object.\n                // So, read from the Channel directly in order to avoid\n                // preventing any writing threads from proceeding.\n                receiveFromChannel(channel, p);\n            }\n\n            InetSocketAddress localAddress\n                = (InetSocketAddress) super.getLocalSocketAddress();\n\n            if (StunDatagramPacketFilter.isStunPacket(p)\n                || DelegatingDatagramSocket.logNonStun(++nbReceivedPackets))\n            {\n                StunStack.logPacketToPcap(\n                        p,\n                        false,\n                        localAddress.getAddress(),\n                        localAddress.getPort());\n            }\n        }\n    }\n\n    /**\n     * Receives an RFC4571-formatted frame from <tt>channel</tt> into\n     * <tt>p</tt>, and sets <tt>p</tt>'s port and address to the remote port\n     * and address of this <tt>Socket</tt>.\n     *\n     * @param channel\n     * @param p\n     * @throws IOException\n     */\n    private synchronized void receiveFromChannel(\n            SocketChannel channel,\n            DatagramPacket p)\n        throws IOException\n    {\n        while (frameLengthByteBuffer.hasRemaining())\n        {\n            int read = channel.read(frameLengthByteBuffer);\n\n            if (read == -1)\n            {\n                throw new SocketException(\n                        \"Failed to receive data from socket.\");\n            }\n        }\n        frameLengthByteBuffer.flip();\n\n        int b0 = frameLengthByteBuffer.get();\n        int b1 = frameLengthByteBuffer.get();\n        int frameLength = ((b0 & 0xFF) << 8) | (b1 & 0xFF);\n\n        frameLengthByteBuffer.flip();\n\n        byte[] data = p.getData();\n\n        if (data == null || data.length < frameLength)\n            data = new byte[frameLength];\n\n        ByteBuffer byteBuffer = ByteBuffer.wrap(data, 0, frameLength);\n\n        while (byteBuffer.hasRemaining())\n        {\n            int read = channel.read(byteBuffer);\n\n            if (read == -1)\n            {\n                throw new SocketException(\n                        \"Failed to receive data from socket.\");\n            }\n        }\n\n        p.setAddress(getInetAddress());\n        p.setData(data, 0, frameLength);\n        p.setPort(getPort());\n    }\n\n    /**\n     * Send a datagram packet from this socket.\n     *\n     * @param p <tt>DatagramPacket</tt> to sent\n     * @throws IOException if something goes wrong during send\n     */\n    public void send(DatagramPacket p) throws IOException\n    {\n        // The delegate socket will encapsulate the packet.\n        if (delegateAsDelegatingSocket != null)\n        {\n            delegateAsDelegatingSocket.send(p);\n        }\n        else\n        {\n            if (outputStream == null)\n                outputStream = getOutputStream();\n\n            // Else, sends the packet to the final socket (outputStream).\n            outputStream.write(p.getData(), p.getOffset(), p.getLength());\n\n            if (DelegatingDatagramSocket.logNonStun(++nbSentPackets))\n            {\n                InetSocketAddress localAddress\n                    = (InetSocketAddress) super.getLocalSocketAddress();\n\n                StunStack.logPacketToPcap(\n                        p,\n                        true,\n                        localAddress.getAddress(),\n                        localAddress.getPort());\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void sendUrgentData(int data) throws IOException\n    {\n        if (delegate == null)\n            super.sendUrgentData(data);\n        else\n            delegate.sendUrgentData(data);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setKeepAlive(boolean on) throws SocketException\n    {\n        if (delegate == null)\n            super.setKeepAlive(on);\n        else\n            delegate.setKeepAlive(on);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setOOBInline(boolean on) throws SocketException\n    {\n        if (delegate == null)\n            super.setOOBInline(on);\n        else\n            delegate.setOOBInline(on);\n    }\n\n    /**\n     * Set original <tt>InputStream</tt>.\n     *\n     * @param inputStream <tt>InputStream</tt>\n     */\n    public void setOriginalInputStream(InputStream inputStream)\n    {\n        if (this.inputStream == null && inputStream != null)\n            this.inputStream = inputStream;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setPerformancePreferences(\n            int connectionTime,\n            int latency,\n            int bandwidth)\n    {\n        if (delegate == null)\n        {\n            super.setPerformancePreferences(connectionTime, latency, bandwidth);\n        }\n        else\n        {\n            delegate.setPerformancePreferences(\n                    connectionTime,\n                    latency,\n                    bandwidth);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setReceiveBufferSize(int size) throws SocketException\n    {\n        if (delegate == null)\n            super.setReceiveBufferSize(size);\n        else\n            delegate.setReceiveBufferSize(size);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setReuseAddress(boolean on) throws SocketException\n    {\n        if (delegate == null)\n            super.setReuseAddress(on);\n        else\n            delegate.setReuseAddress(on);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setSendBufferSize(int size) throws SocketException\n    {\n        if (delegate == null)\n            super.setSendBufferSize(size);\n        else\n            delegate.setSendBufferSize(size);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setSoLinger(boolean on, int linger) throws SocketException\n    {\n        if (delegate == null)\n            super.setSoLinger(on, linger);\n        else\n            delegate.setSoLinger(on, linger);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setSoTimeout(int timeout) throws SocketException\n    {\n        if (delegate == null)\n            super.setSoTimeout(timeout);\n        else\n            delegate.setSoTimeout(timeout);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setTcpNoDelay(boolean on) throws SocketException\n    {\n        if (delegate == null)\n            super.setTcpNoDelay(on);\n        else\n            delegate.setTcpNoDelay(on);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setTrafficClass(int tc) throws SocketException\n    {\n        if (delegate == null)\n            super.setTrafficClass(tc);\n        else\n            delegate.setTrafficClass(tc);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void shutdownInput() throws IOException\n    {\n        if (delegate == null)\n            super.shutdownInput();\n        else\n            delegate.shutdownInput();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void shutdownOutput() throws IOException\n    {\n        if (delegate == null)\n            super.shutdownOutput();\n        else\n            delegate.shutdownOutput();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString()\n    {\n        return (delegate == null) ? super.toString() : delegate.toString();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected final SocketChannel channel;", "docstring": "\nThe <tt>SocketChannel</tt> (to be) returned by {@link #getChannel()}. If\n<tt>null</tt>, <tt>getChannel()</tt> forwards to {@link #delegate}. (If\n<tt>delegate</tt> is <tt>null</tt>, <tt>getChannel()</tt> invokes the\nsuper implementation.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "SocketChannel", "name": "channel", "syntax_pass": true}, {"attribute_expression": "protected final Socket delegate;", "docstring": "\nDelegate <tt>Socket</tt>.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Socket", "name": "delegate", "syntax_pass": true}, {"attribute_expression": "private final DelegatingSocket delegateAsDelegatingSocket;", "docstring": "\nA <tt>DelegatingSocket</tt> view of {@link #delegate} if the latter\nimplements the former; otherwise, <tt>null</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DelegatingSocket", "name": "delegateAsDelegatingSocket", "syntax_pass": true}, {"attribute_expression": "private final ByteBuffer frameLengthByteBuffer = ByteBuffer.allocate(2);", "docstring": "\nThe <tt>ByteBuffer</tt> instance used in\n{@link #receiveFromChannel(java.nio.channels.SocketChannel,\njava.net.DatagramPacket)} to read the 2-byte length field into.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ByteBuffer", "name": "frameLengthByteBuffer = ByteBuffer.allocate(2)", "syntax_pass": true}, {"attribute_expression": "private InputStream inputStream = null;", "docstring": "\nInputStream for this socket.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "InputStream", "name": "inputStream = null", "syntax_pass": true}, {"attribute_expression": "private long nbReceivedPackets = 0;", "docstring": "\nThe number of non-STUN packets received for this socket.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "nbReceivedPackets = 0", "syntax_pass": true}, {"attribute_expression": "private long nbSentPackets = 0;", "docstring": "\nThe number of non-STUN packets sent for this socket.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "nbSentPackets = 0", "syntax_pass": true}, {"attribute_expression": "private OutputStream outputStream = null;", "docstring": "\nOutputStream for this socket.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "OutputStream", "name": "outputStream = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate", "name": "GoogleRelayedCandidateDelegate", "file_path": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java", "superclasses": "", "methods": ["[]GoogleRelayedCandidateDelegate(GoogleTurnCandidateHarvest,String)", "[void]close()", "[void]handleMessageEvent(StunMessageEvent)", "[boolean]processErrorOrFailure(Response,Request)", "[void]processSuccess(Response,Request)", "[void]processResponse(StunResponseEvent)", "[void]processTimeout(StunTimeoutEvent)", "[void]receive(DatagramPacket)", "[void]send(DatagramPacket)", "[void]createSendThread()", "[void]runInSendThread()"], "method_uris": ["src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[]GoogleRelayedCandidateDelegate(GoogleTurnCandidateHarvest,String)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]close()", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]handleMessageEvent(StunMessageEvent)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[boolean]processErrorOrFailure(Response,Request)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]processSuccess(Response,Request)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]processResponse(StunResponseEvent)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]processTimeout(StunTimeoutEvent)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]receive(DatagramPacket)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]send(DatagramPacket)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]createSendThread()", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDelegate.java.GoogleRelayedCandidateDelegate.[void]runInSendThread()"], "overrides": null, "attributes": [], "class_docstring": "\nGoogle TURN delegate object that will handle GTalk TURN send/receive\noperations.\n\n@author Sebastien Vincent\n", "original_string": "public class GoogleRelayedCandidateDelegate\n    implements MessageEventHandler,\n               ResponseCollector\n{\n    /**\n     * The <tt>Logger</tt> used by the\n     * <tt>GoogleRelayedCandidateDatagramSocket</tt> class and its instances for\n     * logging output.\n     */\n    private static final Logger logger = Logger\n        .getLogger(GoogleRelayedCandidateDelegate.class.getName());\n\n    /**\n     * The indicator which determines whether this instance has started\n     * executing or has executed its {@link #close()} method.\n     */\n    private boolean closed = false;\n\n    /**\n     * The <tt>DatagramPacket</tt>s which are to be received through this\n     * <tt>DatagramSocket</tt> upon calls to its\n     * {@link #receive(DatagramPacket)} method. They have been received from the\n     * TURN server in the form of Data indications.\n     */\n    private final List<DatagramPacket> packetsToReceive = new LinkedList<>();\n\n    /**\n     * The <tt>DatagramSocket</tt>s which have been sent through this\n     * <tt>DatagramSocket</tt> using its {@link #send(DatagramPacket)} method\n     * and which are to be relayed through its associated TURN server in the\n     * form of Send indications.\n     */\n    private final List<DatagramPacket> packetsToSend = new LinkedList<>();\n\n    /**\n     * The <tt>Thread</tt> which is to send the {@link #packetsToSend} to the\n     * associated TURN server.\n     */\n    private Thread sendThread;\n\n    /**\n     * The <tt>GoogleTurnCandidateHarvest</tt> which has harvested\n     * {@link #relayedCandidate}.\n     */\n    private final GoogleTurnCandidateHarvest turnCandidateHarvest;\n\n    /**\n     * Username.\n     */\n    private final String username;\n\n    /**\n     * Initializes a new <tt>GoogleRelayedCandidateDatagramSocket</tt> instance\n     * which is to be the <tt>socket</tt> of a specific\n     * <tt>RelayedCandidate</tt> harvested by a specific\n     * <tt>TurnCandidateHarvest</tt>.\n     *\n     * @param turnCandidateHarvest the <tt>TurnCandidateHarvest</tt> which has\n     * harvested <tt>relayedCandidate</tt>\n     * @param username username\n     * @throws SocketException if anything goes wrong while initializing the new\n     * <tt>GoogleRelayedCandidateDatagramSocket</tt> instance\n     */\n    public GoogleRelayedCandidateDelegate(\n        GoogleTurnCandidateHarvest turnCandidateHarvest, String username)\n        throws SocketException\n    {\n        this.turnCandidateHarvest = turnCandidateHarvest;\n        this.username = username;\n\n        this.turnCandidateHarvest.harvester.getStunStack()\n            .addOldIndicationListener(\n                this.turnCandidateHarvest.hostCandidate.getTransportAddress(),\n                this);\n    }\n\n    /**\n     * Closes this datagram socket.\n     *\n     * @see DatagramSocket#close()\n     */\n    public void close()\n    {\n        synchronized (this)\n        {\n            if (this.closed)\n                return;\n            else\n                this.closed = true;\n        }\n        synchronized (packetsToReceive)\n        {\n            packetsToReceive.notifyAll();\n        }\n        synchronized (packetsToSend)\n        {\n            packetsToSend.notifyAll();\n        }\n\n        turnCandidateHarvest.harvester.getStunStack().removeIndicationListener(\n            turnCandidateHarvest.hostCandidate.getTransportAddress(), this);\n    }\n\n    /**\n     * Notifies this <tt>MessageEventHandler</tt> that a specific STUN message\n     * has been received, parsed and is ready for delivery.\n     * <tt>GoogleRelayedCandidateDatagramSocket</tt> handles STUN indications\n     * sent from the associated TURN server and received at the associated local\n     * <tt>TransportAddress</tt>.\n     *\n     * @param e a <tt>StunMessageEvent</tt> which encapsulates the received STUN\n     *            message\n     */\n    public void handleMessageEvent(StunMessageEvent e)\n    {\n        Message message = e.getMessage();\n        char messageType = message.getMessageType();\n\n        if (messageType != Message.OLD_DATA_INDICATION)\n            return;\n\n        if (!turnCandidateHarvest.hostCandidate.getTransportAddress().equals(\n            e.getLocalAddress()))\n            return;\n\n        // Is it from our TURN server?\n        if (!turnCandidateHarvest.harvester.stunServer.equals(e\n            .getRemoteAddress()))\n            return;\n\n        logger.finest(\"handle old DATA Indication\");\n\n        /*\n         * as REMOTE-ADDRESS and XOR-PEER-ADDRESS has the same attribute type we\n         * cast it to XorPeerAddressAttribute but we do not apply XOR to get the\n         * address\n         */\n        XorPeerAddressAttribute peerAddressAttribute =\n            (XorPeerAddressAttribute) message\n                .getAttribute(Attribute.REMOTE_ADDRESS);\n\n        if (peerAddressAttribute == null)\n        {\n            logger.info(\"peerAddressAttribute is null\");\n            return;\n        }\n\n        DataAttribute dataAttribute =\n            (DataAttribute) message.getAttribute(Attribute.DATA);\n\n        if (dataAttribute == null)\n        {\n            logger.info(\"data is null\");\n            return;\n        }\n\n        TransportAddress peerAddress = peerAddressAttribute.getAddress();\n        if (peerAddress == null)\n            return;\n\n        byte[] data = dataAttribute.getData();\n\n        if (data == null)\n            return;\n\n        DatagramPacket packetToReceive;\n\n        try\n        {\n            packetToReceive\n                = new DatagramPacket(data, 0, data.length, peerAddress);\n        }\n        catch (Throwable t)\n        {\n            /*\n             * The signature of the DatagramPacket constructor was changed\n             * in JDK 8 to not declare that it may throw a SocketException.\n             */\n            if (t instanceof SocketException)\n            {\n                packetToReceive = null;\n            }\n            else if (t instanceof Error)\n            {\n                throw (Error) t;\n            }\n            else if (t instanceof RuntimeException)\n            {\n                throw (RuntimeException) t;\n            }\n            else\n            {\n                /*\n                 * Unfortunately, we cannot re-throw it. Anyway, it was\n                 * unlikely to occur on JDK 7.\n                 */\n                if (t instanceof InterruptedException)\n                {\n                    Thread.currentThread().interrupt();\n                }\n                packetToReceive = null;\n            }\n        }\n        if (packetToReceive != null)\n        {\n            synchronized (packetsToReceive)\n            {\n                packetsToReceive.add(packetToReceive);\n                packetsToReceive.notifyAll();\n            }\n        }\n    }\n\n    /**\n     * Notifies this <tt>GoogleRelayedCandidateDatagramSocket</tt> that a\n     * specific <tt>Request</tt> it has sent has either failed or received a\n     * STUN error <tt>Response</tt>.\n     *\n     * @param response the <tt>Response</tt> which responds to <tt>request</tt>\n     * @param request the <tt>Request</tt> sent by this instance to which\n     *            <tt>response</tt> responds\n     * @return <tt>true</tt> if the failure or error condition has been handled\n     *         and the caller should assume this instance has recovered from it;\n     *         otherwise, <tt>false</tt>\n     */\n    public boolean processErrorOrFailure(Response response, Request request)\n    {\n        return false;\n    }\n\n    /**\n     * Notifies this <tt>GoogleRelayedCandidateDatagramSocket</tt> that a\n     * specific <tt>Request</tt> it has sent has received a STUN success\n     * <tt>Response</tt>.\n     *\n     * @param response the <tt>Response</tt> which responds to <tt>request</tt>\n     * @param request the <tt>Request</tt> sent by this instance to which\n     *            <tt>response</tt> responds\n     */\n    public void processSuccess(Response response, Request request)\n    {\n    }\n\n    /**\n     * Dispatch the specified response.\n     *\n     * @param response the response to dispatch.\n     */\n    public void processResponse(StunResponseEvent response)\n    {\n    }\n\n    /**\n     * Notifies this collector that no response had been received after repeated\n     * retransmissions of the original request (as described by rfc3489) and\n     * that the request should be considered unanswered.\n     *\n     * @param event the <tt>StunTimeoutEvent</tt> containing a reference to the\n     *            transaction that has just failed.\n     */\n    public void processTimeout(StunTimeoutEvent event)\n    {\n    }\n\n    /**\n     * Receives a datagram packet from this socket. When this method returns,\n     * the <tt>DatagramPacket</tt>'s buffer is filled with the data received.\n     * The datagram packet also contains the sender's IP address, and the port\n     * number on the sender's machine.\n     *\n     * @param p the <tt>DatagramPacket</tt> into which to place the incoming\n     *            data\n     * @throws IOException if an I/O error occurs\n     * @see DatagramSocket#receive(DatagramPacket)\n     */\n    public void receive(DatagramPacket p) throws IOException\n    {\n        synchronized (packetsToReceive)\n        {\n            do\n            {\n                /*\n                 * According to the javadoc of DatagramSocket#close(), any\n                 * thread currently blocked in #receive(DatagramPacket) upon\n                 * this socket will throw a SocketException.\n                 */\n                if (closed)\n                {\n                    throw new SocketException(\n                        GoogleRelayedCandidateDatagramSocket.class\n                            .getSimpleName() + \" has been closed.\");\n                }\n                else if (packetsToReceive.isEmpty())\n                {\n                    try\n                    {\n                        packetsToReceive.wait();\n                    }\n                    catch (InterruptedException iex)\n                    {\n                    }\n                }\n                else\n                {\n                    DatagramPacket packetToReceive = packetsToReceive.remove(0);\n\n                    MultiplexingXXXSocketSupport.copy(packetToReceive, p);\n                    packetsToReceive.notifyAll();\n                    break;\n                }\n            }\n            while (true);\n        }\n    }\n\n    /**\n     * Sends a datagram packet from this socket. The <tt>DatagramPacket</tt>\n     * includes information indicating the data to be sent, its length, the IP\n     * address of the remote host, and the port number on the remote host.\n     *\n     * @param p the <tt>DatagramPacket</tt> to be sent\n     * @throws IOException if an I/O error occurs\n     * @see DatagramSocket#send(DatagramPacket)\n     */\n    public void send(DatagramPacket p) throws IOException\n    {\n        synchronized (packetsToSend)\n        {\n            if (closed)\n            {\n                throw new IOException(\n                    GoogleRelayedCandidateDatagramSocket.class.getSimpleName()\n                        + \" has been closed.\");\n            }\n            else\n            {\n                packetsToSend.add(MultiplexingXXXSocketSupport.clone(p));\n                if (sendThread == null)\n                    createSendThread();\n                else\n                    packetsToSend.notifyAll();\n            }\n        }\n    }\n\n    /**\n     * Creates {@link #sendThread} which is to send {@link #packetsToSend} to\n     * the associated TURN server.\n     */\n    private void createSendThread()\n    {\n        sendThread = new Thread()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    runInSendThread();\n                }\n                finally\n                {\n                    /*\n                     * If sendThread is dying and there are packetsToSend, then\n                     * spawn a new sendThread.\n                     */\n                    synchronized (packetsToSend)\n                    {\n                        if (sendThread == Thread.currentThread())\n                            sendThread = null;\n                        if ((sendThread == null) && !closed\n                            && !packetsToSend.isEmpty())\n                            createSendThread();\n                    }\n                }\n            }\n        };\n        sendThread.start();\n    }\n\n    /**\n     * Runs in {@link #sendThread} to send {@link #packetsToSend} to the\n     * associated TURN server.\n     */\n    private void runInSendThread()\n    {\n        synchronized (packetsToSend)\n        {\n            while (!closed)\n            {\n                if (packetsToSend.isEmpty())\n                {\n                    try\n                    {\n                        packetsToSend.wait();\n                    }\n                    catch (InterruptedException iex)\n                    {\n                    }\n                    continue;\n                }\n\n                int packetToSendCount = packetsToSend.size();\n\n                for (int packetToSendIndex = 0; packetToSendIndex < packetToSendCount; packetToSendIndex++)\n                {\n                    DatagramPacket packetToSend = packetsToSend.remove(0);\n                    TransportAddress peerAddress =\n                        new TransportAddress(packetToSend.getAddress(),\n                            packetToSend.getPort(), Transport.UDP);\n                    byte[] pData = packetToSend.getData();\n                    int pOffset = packetToSend.getOffset();\n                    int pLength = packetToSend.getLength();\n                    byte[] data;\n\n                    if ((pOffset == 0) && (pLength == pData.length))\n                        data = pData;\n                    else\n                    {\n                        data = new byte[pLength];\n                        System.arraycopy(pData, pOffset, data, 0, pLength);\n                    }\n\n                    byte[] transactionID =\n                        TransactionID.createNewTransactionID().getBytes();\n                    Request sendRequest =\n                        MessageFactory.createSendRequest(username, peerAddress,\n                            data);\n\n                    try\n                    {\n                        sendRequest.setTransactionID(transactionID);\n                        turnCandidateHarvest.harvester.getStunStack()\n                            .sendRequest(\n                                sendRequest,\n                                turnCandidateHarvest.harvester.stunServer,\n                                turnCandidateHarvest.hostCandidate\n                                    .getTransportAddress(), this);\n                    }\n                    catch (Exception e)\n                    {\n                        logger.fine(\"Failed to send TURN Send request: \" + e);\n                    }\n                }\n\n                /*\n                 * If no packetToSend has been sent by the current iteration,\n                 * then we must be waiting for some condition to change in order\n                 * to be able to send.\n                 */\n                if (packetsToSend.size() == packetToSendCount)\n                {\n                    try\n                    {\n                        packetsToSend.wait();\n                    }\n                    catch (InterruptedException iex)\n                    {\n                    }\n                }\n            }\n        }\n    }\n}", "super_interfaces": ["MessageEventHandler", "ResponseCollector"], "fields": [{"attribute_expression": "private static final Logger logger = Logger\n        .getLogger(GoogleRelayedCandidateDelegate.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the\n<tt>GoogleRelayedCandidateDatagramSocket</tt> class and its instances for\nlogging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger = Logger\n        .getLogger(GoogleRelayedCandidateDelegate.class.getName())", "syntax_pass": true}, {"attribute_expression": "private boolean closed = false;", "docstring": "\nThe indicator which determines whether this instance has started\nexecuting or has executed its {@link #close()} method.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "closed = false", "syntax_pass": true}, {"attribute_expression": "private final List<DatagramPacket> packetsToReceive = new LinkedList<>();", "docstring": "\nThe <tt>DatagramPacket</tt>s which are to be received through this\n<tt>DatagramSocket</tt> upon calls to its\n{@link #receive(DatagramPacket)} method. They have been received from the\nTURN server in the form of Data indications.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<DatagramPacket>", "name": "packetsToReceive = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private final List<DatagramPacket> packetsToSend = new LinkedList<>();", "docstring": "\nThe <tt>DatagramSocket</tt>s which have been sent through this\n<tt>DatagramSocket</tt> using its {@link #send(DatagramPacket)} method\nand which are to be relayed through its associated TURN server in the\nform of Send indications.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<DatagramPacket>", "name": "packetsToSend = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private Thread sendThread;", "docstring": "\nThe <tt>Thread</tt> which is to send the {@link #packetsToSend} to the\nassociated TURN server.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Thread", "name": "sendThread", "syntax_pass": true}, {"attribute_expression": "private final GoogleTurnCandidateHarvest turnCandidateHarvest;", "docstring": "\nThe <tt>GoogleTurnCandidateHarvest</tt> which has harvested\n{@link #relayedCandidate}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "GoogleTurnCandidateHarvest", "name": "turnCandidateHarvest", "syntax_pass": true}, {"attribute_expression": "private final String username;", "docstring": "\nUsername.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "username", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer", "name": "SocketReceiveBuffer", "file_path": "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java", "superclasses": "", "methods": ["[]SocketReceiveBuffer(Callable<Integer>)", "[boolean]isEmpty()", "[void]add(DatagramPacket)", "[DatagramPacket]poll()", "[List<DatagramPacket>]scan(DatagramPacketFilter)"], "method_uris": ["src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer.[]SocketReceiveBuffer(Callable<Integer>)", "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer.[boolean]isEmpty()", "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer.[void]add(DatagramPacket)", "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer.[DatagramPacket]poll()", "src/main/java/org/ice4j/socket/SocketReceiveBuffer.java.SocketReceiveBuffer.[List<DatagramPacket>]scan(DatagramPacketFilter)"], "overrides": null, "attributes": [{"original_string": "    private final class DatagramSizeTracker\n    {\n        /**\n         * The value of the <tt>SO_RCVBUF</tt> option for the associated\n         * <tt>DatagramSocket</tt> or <tt>Socket</tt>. Cached for the sake of\n         * performance.\n         */\n        private int cachedReceiveBufferSize;\n\n        /**\n         * The (total) size in bytes of this receive buffer.\n         */\n        private int totalBuffersByteSize;\n\n        /**\n         * Counts total number of datagrams added to buffer.\n         */\n        private int totalDatagramsAdded;\n\n        /**\n         * A user provided getter of receive buffer size, might\n         * fail with {@link Exception} when called.\n         */\n        private final Callable<Integer> receiveBufferSizeSupplier;\n\n        /**\n         * Create a tracker of datagram packet size stored in buffer.\n         * @param receiveBufferSizeSupplier a function to obtain receive buffer\n         * size from associated socket.\n         */\n        public DatagramSizeTracker(\n            Callable<Integer> receiveBufferSizeSupplier)\n        {\n            this.receiveBufferSizeSupplier = receiveBufferSizeSupplier;\n        }\n\n        /**\n         * Check if total bytes stored in {@link #buffer} exceeds socket's\n         * receive buffer size.\n         * @return true if size exceeded, false - otherwise\n         */\n        boolean isExceedReceiveBufferSize()\n        {\n            return totalBuffersByteSize > cachedReceiveBufferSize;\n        }\n\n        /**\n         * Updates computed value of total datagrams size in bytes\n         * stored in {@link #buffer} with datagram just added to buffer.\n         * @param p datagram packed added to {@link #buffer}\n         */\n        void trackDatagramAdded(DatagramPacket p)\n        {\n            ++totalDatagramsAdded;\n\n            final int pSize = p.getLength();\n            if (pSize <= 0)\n            {\n                return;\n            }\n\n            totalBuffersByteSize += pSize;\n\n            // If the added packet is the only element of this list, do not\n            // drop it because of the enforcement of SO_RCVBUF.\n            if (buffer.size() > 1)\n            {\n                // For the sake of performance, do not invoke the method\n                // getReceiveBufferSize() of DatagramSocket or Socket on\n                // every packet added to this buffer.\n                int receiveBufferSize = this.cachedReceiveBufferSize;\n\n                if ((receiveBufferSize <= 0)\n                    || (totalDatagramsAdded % 1000 == 0))\n                {\n                    try\n                    {\n                        receiveBufferSize\n                            = this.receiveBufferSizeSupplier.call();\n                    }\n                    catch (Exception e)\n                    {\n                        // nothing to do\n                    }\n\n                    if (receiveBufferSize <= 0)\n                    {\n                        receiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;\n                    }\n                    else if (receiveBufferSize\n                        < DEFAULT_RECEIVE_BUFFER_SIZE)\n                    {\n                        // Well, a manual page on SO_RCVBUF talks about\n                        // doubling. In order to stay on the safe side and\n                        // given that there was no limit on the size of the\n                        // buffer before, double the receive buffer size.\n                        receiveBufferSize *= 2;\n                        if (receiveBufferSize <= 0)\n                        {\n                            receiveBufferSize\n                                = DEFAULT_RECEIVE_BUFFER_SIZE;\n                        }\n                    }\n                    this.cachedReceiveBufferSize = receiveBufferSize;\n                }\n            }\n        }\n\n        /**\n         * Updates computed value of total datagrams size in bytes\n         * stored in {@link #buffer} with datagram just removed from buffer.\n         * @param p datagram packed removed from {@link #buffer}\n         */\n        void trackDatagramRemoved(DatagramPacket p)\n        {\n            final int pSize = p.getLength();\n            if (pSize <= 0)\n            {\n                return;\n            }\n\n            totalBuffersByteSize -= pSize;\n            if (totalBuffersByteSize < 0)\n            {\n                totalBuffersByteSize = 0;\n            }\n        }\n    }", "definition": "    private final class DatagramSizeTracker", "class_docstring": "\nA helper class to keep track of total size in bytes of all\n{@link DatagramPacket} instances stored in {@link #buffer} to\nbe able to enforce SO_RCVBUF.\n", "name": "DatagramSizeTracker", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private int cachedReceiveBufferSize;", "docstring": "\nThe value of the <tt>SO_RCVBUF</tt> option for the associated\n<tt>DatagramSocket</tt> or <tt>Socket</tt>. Cached for the sake of\nperformance.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "cachedReceiveBufferSize", "syntax_pass": true}, {"attribute_expression": "private int totalBuffersByteSize;", "docstring": "\nThe (total) size in bytes of this receive buffer.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "totalBuffersByteSize", "syntax_pass": true}, {"attribute_expression": "private int totalDatagramsAdded;", "docstring": "\nCounts total number of datagrams added to buffer.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "totalDatagramsAdded", "syntax_pass": true}, {"attribute_expression": "private final Callable<Integer> receiveBufferSizeSupplier;", "docstring": "\nA user provided getter of receive buffer size, might\nfail with {@link Exception} when called.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Callable<Integer>", "name": "receiveBufferSizeSupplier", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public DatagramSizeTracker(\n            Callable<Integer> receiveBufferSizeSupplier)\n        {\n            this.receiveBufferSizeSupplier = receiveBufferSizeSupplier;\n        }", "docstring": "\nCreate a tracker of datagram packet size stored in buffer.\n@param receiveBufferSizeSupplier a function to obtain receive buffer\nsize from associated socket.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "DatagramSizeTracker", "params": [{"name": "receiveBufferSizeSupplier", "type": "Callable<Integer>"}], "body": "        {\n            this.receiveBufferSizeSupplier = receiveBufferSizeSupplier;\n        }", "signature": "public DatagramSizeTracker(\n            Callable<Integer> receiveBufferSizeSupplier)"}, {"syntax_pass": true, "original_string": "        boolean isExceedReceiveBufferSize()\n        {\n            return totalBuffersByteSize > cachedReceiveBufferSize;\n        }", "docstring": "\nCheck if total bytes stored in {@link #buffer} exceeds socket's\nreceive buffer size.\n@return true if size exceeded, false - otherwise\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "isExceedReceiveBufferSize", "params": [], "body": "        {\n            return totalBuffersByteSize > cachedReceiveBufferSize;\n        }", "signature": "boolean isExceedReceiveBufferSize()"}, {"syntax_pass": true, "original_string": "        void trackDatagramAdded(DatagramPacket p)\n        {\n            ++totalDatagramsAdded;\n\n            final int pSize = p.getLength();\n            if (pSize <= 0)\n            {\n                return;\n            }\n\n            totalBuffersByteSize += pSize;\n\n            // If the added packet is the only element of this list, do not\n            // drop it because of the enforcement of SO_RCVBUF.\n            if (buffer.size() > 1)\n            {\n                // For the sake of performance, do not invoke the method\n                // getReceiveBufferSize() of DatagramSocket or Socket on\n                // every packet added to this buffer.\n                int receiveBufferSize = this.cachedReceiveBufferSize;\n\n                if ((receiveBufferSize <= 0)\n                    || (totalDatagramsAdded % 1000 == 0))\n                {\n                    try\n                    {\n                        receiveBufferSize\n                            = this.receiveBufferSizeSupplier.call();\n                    }\n                    catch (Exception e)\n                    {\n                        // nothing to do\n                    }\n\n                    if (receiveBufferSize <= 0)\n                    {\n                        receiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;\n                    }\n                    else if (receiveBufferSize\n                        < DEFAULT_RECEIVE_BUFFER_SIZE)\n                    {\n                        // Well, a manual page on SO_RCVBUF talks about\n                        // doubling. In order to stay on the safe side and\n                        // given that there was no limit on the size of the\n                        // buffer before, double the receive buffer size.\n                        receiveBufferSize *= 2;\n                        if (receiveBufferSize <= 0)\n                        {\n                            receiveBufferSize\n                                = DEFAULT_RECEIVE_BUFFER_SIZE;\n                        }\n                    }\n                    this.cachedReceiveBufferSize = receiveBufferSize;\n                }\n            }\n        }", "docstring": "\nUpdates computed value of total datagrams size in bytes\nstored in {@link #buffer} with datagram just added to buffer.\n@param p datagram packed added to {@link #buffer}\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "trackDatagramAdded", "params": [{"name": "p", "type": "DatagramPacket"}], "body": "        {\n            ++totalDatagramsAdded;\n\n            final int pSize = p.getLength();\n            if (pSize <= 0)\n            {\n                return;\n            }\n\n            totalBuffersByteSize += pSize;\n\n            // If the added packet is the only element of this list, do not\n            // drop it because of the enforcement of SO_RCVBUF.\n            if (buffer.size() > 1)\n            {\n                // For the sake of performance, do not invoke the method\n                // getReceiveBufferSize() of DatagramSocket or Socket on\n                // every packet added to this buffer.\n                int receiveBufferSize = this.cachedReceiveBufferSize;\n\n                if ((receiveBufferSize <= 0)\n                    || (totalDatagramsAdded % 1000 == 0))\n                {\n                    try\n                    {\n                        receiveBufferSize\n                            = this.receiveBufferSizeSupplier.call();\n                    }\n                    catch (Exception e)\n                    {\n                        // nothing to do\n                    }\n\n                    if (receiveBufferSize <= 0)\n                    {\n                        receiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;\n                    }\n                    else if (receiveBufferSize\n                        < DEFAULT_RECEIVE_BUFFER_SIZE)\n                    {\n                        // Well, a manual page on SO_RCVBUF talks about\n                        // doubling. In order to stay on the safe side and\n                        // given that there was no limit on the size of the\n                        // buffer before, double the receive buffer size.\n                        receiveBufferSize *= 2;\n                        if (receiveBufferSize <= 0)\n                        {\n                            receiveBufferSize\n                                = DEFAULT_RECEIVE_BUFFER_SIZE;\n                        }\n                    }\n                    this.cachedReceiveBufferSize = receiveBufferSize;\n                }\n            }\n        }", "signature": "void trackDatagramAdded(DatagramPacket p)"}, {"syntax_pass": true, "original_string": "        void trackDatagramRemoved(DatagramPacket p)\n        {\n            final int pSize = p.getLength();\n            if (pSize <= 0)\n            {\n                return;\n            }\n\n            totalBuffersByteSize -= pSize;\n            if (totalBuffersByteSize < 0)\n            {\n                totalBuffersByteSize = 0;\n            }\n        }", "docstring": "\nUpdates computed value of total datagrams size in bytes\nstored in {@link #buffer} with datagram just removed from buffer.\n@param p datagram packed removed from {@link #buffer}\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "void", "classes": []}, "name": "trackDatagramRemoved", "params": [{"name": "p", "type": "DatagramPacket"}], "body": "        {\n            final int pSize = p.getLength();\n            if (pSize <= 0)\n            {\n                return;\n            }\n\n            totalBuffersByteSize -= pSize;\n            if (totalBuffersByteSize < 0)\n            {\n                totalBuffersByteSize = 0;\n            }\n        }", "signature": "void trackDatagramRemoved(DatagramPacket p)"}]}], "class_docstring": "\nImplements a buffer of <tt>DatagramPacket</tt>s received by a\n<tt>DatagramSocket</tt> or a <tt>Socket</tt>. The list enforces the\n<tt>SO_RCVBUF</tt> option for the associated <tt>DatagramSocket</tt> or\n<tt>Socket</tt>.\n\n@author Lyubomir Marinov\n@author Yura Yaroshevich\n", "original_string": "class SocketReceiveBuffer\n{\n    /**\n     * Default size in bytes of socket receive buffer.\n     */\n    private static final int DEFAULT_RECEIVE_BUFFER_SIZE = 1024 * 1024;\n\n    /**\n     * Maxumum number of datagrams buffer is capable to store regardless\n     * of total datagram size in bytes.\n     */\n    private static final int DATAGRAMS_BUFFER_CAPACITY = 10000;\n\n    /**\n     * Queue to store received datagrams.\n     */\n    private final BlockingQueue<DatagramPacket> buffer\n        = new ArrayBlockingQueue<>(DATAGRAMS_BUFFER_CAPACITY);\n\n    /**\n     * An instance of datagram size tracker to compute total number of bytes\n     * stored in datagrams witin {@link #buffer}.\n     */\n    private final DatagramSizeTracker tracker;\n\n    /**\n     * Constructs {@link SocketReceiveBuffer} with user-provided\n     * @param receiveBufferSizeSupplier a function to obtain receive buffer\n     * size from associated socket.\n     */\n    public SocketReceiveBuffer(Callable<Integer> receiveBufferSizeSupplier)\n    {\n        this.tracker = new DatagramSizeTracker(receiveBufferSizeSupplier);\n    }\n\n    /**\n     * Check if receive buffer is empty\n     * @return true if buffer is empty, false - otherwise.\n     */\n    public boolean isEmpty()\n    {\n        return buffer.isEmpty();\n    }\n\n    /**\n     * Adds {@link DatagramPacket} at the end of the socket receive buffer.\n     * @param p datagram to add into receive buffer\n     */\n    public void add(DatagramPacket p)\n    {\n        while (!buffer.offer(p))\n        {\n            // ensure buffer capacity restriction enforced\n            poll();\n        }\n\n        tracker.trackDatagramAdded(p);\n\n        while (tracker.isExceedReceiveBufferSize() && buffer.size() > 1)\n        {\n            // enforce SO_RCVBUF restriction\n            poll();\n        }\n    }\n\n    /**\n     * Polls socket receive buffer for already stored {@link DatagramPacket}\n     * @return the first datagram in the buffer, or {@code null} if buffer\n     * is empty.\n     */\n    public DatagramPacket poll()\n    {\n        DatagramPacket p = buffer.poll();\n\n        // Keep track of the (total) size in bytes of this receive buffer in\n        // order to be able to enforce SO_RCVBUF restriction.\n        if (p != null)\n        {\n            tracker.trackDatagramRemoved(p);\n        }\n\n        return p;\n    }\n\n    /**\n     * Scans buffer of received {@link DatagramPacket}s and move\n     * datagrams which matches the {@code filter} into returned list.\n     * @param filter a predicate to filter {@link DatagramPacket} stored\n     * in receive buffer.\n     * @return list of datagrams matched to {@code filter}.\n     */\n    public List<DatagramPacket> scan(DatagramPacketFilter filter)\n    {\n        List<DatagramPacket> matchedDatagrams = null;\n        final Iterator<DatagramPacket> it = buffer.iterator();\n\n        while (it.hasNext())\n        {\n            final DatagramPacket p = it.next();\n\n            if (filter.accept(p))\n            {\n                if (matchedDatagrams == null)\n                {\n                    matchedDatagrams = new ArrayList<>();\n                }\n                matchedDatagrams.add(p);\n\n                it.remove();\n\n                tracker.trackDatagramRemoved(p);\n            }\n        }\n\n        if (matchedDatagrams != null)\n        {\n            return matchedDatagrams;\n        }\n        return Collections.emptyList();\n    }\n\n    /**\n     * A helper class to keep track of total size in bytes of all\n     * {@link DatagramPacket} instances stored in {@link #buffer} to\n     * be able to enforce SO_RCVBUF.\n     */\n    private final class DatagramSizeTracker\n    {\n        /**\n         * The value of the <tt>SO_RCVBUF</tt> option for the associated\n         * <tt>DatagramSocket</tt> or <tt>Socket</tt>. Cached for the sake of\n         * performance.\n         */\n        private int cachedReceiveBufferSize;\n\n        /**\n         * The (total) size in bytes of this receive buffer.\n         */\n        private int totalBuffersByteSize;\n\n        /**\n         * Counts total number of datagrams added to buffer.\n         */\n        private int totalDatagramsAdded;\n\n        /**\n         * A user provided getter of receive buffer size, might\n         * fail with {@link Exception} when called.\n         */\n        private final Callable<Integer> receiveBufferSizeSupplier;\n\n        /**\n         * Create a tracker of datagram packet size stored in buffer.\n         * @param receiveBufferSizeSupplier a function to obtain receive buffer\n         * size from associated socket.\n         */\n        public DatagramSizeTracker(\n            Callable<Integer> receiveBufferSizeSupplier)\n        {\n            this.receiveBufferSizeSupplier = receiveBufferSizeSupplier;\n        }\n\n        /**\n         * Check if total bytes stored in {@link #buffer} exceeds socket's\n         * receive buffer size.\n         * @return true if size exceeded, false - otherwise\n         */\n        boolean isExceedReceiveBufferSize()\n        {\n            return totalBuffersByteSize > cachedReceiveBufferSize;\n        }\n\n        /**\n         * Updates computed value of total datagrams size in bytes\n         * stored in {@link #buffer} with datagram just added to buffer.\n         * @param p datagram packed added to {@link #buffer}\n         */\n        void trackDatagramAdded(DatagramPacket p)\n        {\n            ++totalDatagramsAdded;\n\n            final int pSize = p.getLength();\n            if (pSize <= 0)\n            {\n                return;\n            }\n\n            totalBuffersByteSize += pSize;\n\n            // If the added packet is the only element of this list, do not\n            // drop it because of the enforcement of SO_RCVBUF.\n            if (buffer.size() > 1)\n            {\n                // For the sake of performance, do not invoke the method\n                // getReceiveBufferSize() of DatagramSocket or Socket on\n                // every packet added to this buffer.\n                int receiveBufferSize = this.cachedReceiveBufferSize;\n\n                if ((receiveBufferSize <= 0)\n                    || (totalDatagramsAdded % 1000 == 0))\n                {\n                    try\n                    {\n                        receiveBufferSize\n                            = this.receiveBufferSizeSupplier.call();\n                    }\n                    catch (Exception e)\n                    {\n                        // nothing to do\n                    }\n\n                    if (receiveBufferSize <= 0)\n                    {\n                        receiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;\n                    }\n                    else if (receiveBufferSize\n                        < DEFAULT_RECEIVE_BUFFER_SIZE)\n                    {\n                        // Well, a manual page on SO_RCVBUF talks about\n                        // doubling. In order to stay on the safe side and\n                        // given that there was no limit on the size of the\n                        // buffer before, double the receive buffer size.\n                        receiveBufferSize *= 2;\n                        if (receiveBufferSize <= 0)\n                        {\n                            receiveBufferSize\n                                = DEFAULT_RECEIVE_BUFFER_SIZE;\n                        }\n                    }\n                    this.cachedReceiveBufferSize = receiveBufferSize;\n                }\n            }\n        }\n\n        /**\n         * Updates computed value of total datagrams size in bytes\n         * stored in {@link #buffer} with datagram just removed from buffer.\n         * @param p datagram packed removed from {@link #buffer}\n         */\n        void trackDatagramRemoved(DatagramPacket p)\n        {\n            final int pSize = p.getLength();\n            if (pSize <= 0)\n            {\n                return;\n            }\n\n            totalBuffersByteSize -= pSize;\n            if (totalBuffersByteSize < 0)\n            {\n                totalBuffersByteSize = 0;\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final int DEFAULT_RECEIVE_BUFFER_SIZE = 1024 * 1024;", "docstring": "\nDefault size in bytes of socket receive buffer.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_RECEIVE_BUFFER_SIZE = 1024 * 1024", "syntax_pass": true}, {"attribute_expression": "private static final int DATAGRAMS_BUFFER_CAPACITY = 10000;", "docstring": "\nMaxumum number of datagrams buffer is capable to store regardless\nof total datagram size in bytes.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "DATAGRAMS_BUFFER_CAPACITY = 10000", "syntax_pass": true}, {"attribute_expression": "private final BlockingQueue<DatagramPacket> buffer\n        = new ArrayBlockingQueue<>(DATAGRAMS_BUFFER_CAPACITY);", "docstring": "\nQueue to store received datagrams.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BlockingQueue<DatagramPacket>", "name": "buffer\n        = new ArrayBlockingQueue<>(DATAGRAMS_BUFFER_CAPACITY)", "syntax_pass": true}, {"attribute_expression": "private final DatagramSizeTracker tracker;", "docstring": "\nAn instance of datagram size tracker to compute total number of bytes\nstored in datagrams witin {@link #buffer}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DatagramSizeTracker", "name": "tracker", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket", "name": "RelayedCandidateDatagramSocket", "file_path": "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java", "superclasses": "DatagramSocket", "methods": ["[]RelayedCandidateDatagramSocket(RelayedCandidate,TurnCandidateHarvest)", "[boolean]channelDataSocketAccept(DatagramPacket)", "[boolean]channelDataSocketAcceptMethod(char)", "[void]close()", "[void]createReceiveChannelDataThread()", "[void]createSendThread()", "[InetAddress]getLocalAddress()", "[int]getLocalPort()", "[InetSocketAddress]getLocalSocketAddress()", "[char]getNextChannelNumber()", "[RelayedCandidate]getRelayedCandidate()", "[void]handleMessageEvent(StunMessageEvent)", "[boolean]processErrorOrFailure(Response,Request)", "[void]processSuccess(Response,Request)", "[void]receive(DatagramPacket)", "[void]runInReceiveChannelDataThread()", "[void]runInSendThread()", "[void]send(DatagramPacket)", "[void]setChannelBound(Request,boolean)", "[void]setChannelNumberIsConfirmed(Request,boolean)"], "method_uris": ["src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[]RelayedCandidateDatagramSocket(RelayedCandidate,TurnCandidateHarvest)", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[boolean]channelDataSocketAccept(DatagramPacket)", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[boolean]channelDataSocketAcceptMethod(char)", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]close()", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]createReceiveChannelDataThread()", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]createSendThread()", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[InetAddress]getLocalAddress()", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[int]getLocalPort()", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[InetSocketAddress]getLocalSocketAddress()", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[char]getNextChannelNumber()", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[RelayedCandidate]getRelayedCandidate()", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]handleMessageEvent(StunMessageEvent)", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[boolean]processErrorOrFailure(Response,Request)", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]processSuccess(Response,Request)", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]receive(DatagramPacket)", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]runInReceiveChannelDataThread()", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]runInSendThread()", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]send(DatagramPacket)", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]setChannelBound(Request,boolean)", "src/main/java/org/ice4j/socket/RelayedCandidateDatagramSocket.java.RelayedCandidateDatagramSocket.[void]setChannelNumberIsConfirmed(Request,boolean)"], "overrides": null, "attributes": [{"original_string": "    private class Channel\n    {\n        /**\n         * The time stamp in milliseconds at which {@link #bindingTransactionID}\n         * has been used to bind/install this <tt>Channel</tt>.\n         */\n        private long bindingTimeStamp = -1;\n\n        /**\n         * The ID of the transaction with which a CreatePermission\n         * <tt>Request</tt> has been sent to bind/install this <tt>Channel</tt>.\n         */\n        private byte[] bindingTransactionID;\n\n        /**\n         * The indication which determines whether a confirmation has been\n         * received that this <tt>Channel</tt> has been bound.\n         */\n        private boolean bound = false;\n\n        /**\n         * The value of the <tt>data</tt> property of\n         * {@link #channelDataPacket}.\n         */\n        private byte[] channelData;\n\n        /**\n         * The indicator which determines whether this <tt>Channel</tt> is set\n         * to prefer sending <tt>DatagramPacket</tt>s using TURN ChannelData\n         * messages instead of Send indications.\n         */\n        private boolean channelDataIsPreferred = false;\n\n        /**\n         * The <tt>DatagramPacket</tt> in which this <tt>Channel</tt> sends TURN\n         * ChannelData messages through\n         * {@link RelayedCandidateDatagramSocket#channelDataSocket}.\n         */\n        private DatagramPacket channelDataPacket;\n\n        /**\n         * The TURN channel number of this <tt>Channel</tt> which is to be or\n         * has been allocated using a ChannelBind <tt>Request</tt>.\n         */\n        private char channelNumber = CHANNEL_NUMBER_NOT_SPECIFIED;\n\n        /**\n         * The indicator which determines whether the associated TURN server has\n         * confirmed the allocation of {@link #channelNumber} by us receiving a\n         * success <tt>Response</tt> to our ChannelBind <tt>Request</tt>.\n         */\n        private boolean channelNumberIsConfirmed;\n\n        /**\n         * The <tt>TransportAddress</tt> of the peer to which this\n         * <tt>Channel</tt> provides a permission of this\n         * <tt>RelayedCandidateDatagramSocket</tt> to send data to.\n         */\n        public final TransportAddress peerAddress;\n\n        /**\n         * Initializes a new <tt>Channel</tt> instance which is to provide this\n         * <tt>RelayedCandidateDatagramSocket</tt> with a permission to send\n         * to a specific peer <tt>TransportAddress</tt>.\n         *\n         * @param peerAddress the <tt>TransportAddress</tt> of the peer to which\n         * the new instance is to provide a permission of this\n         * <tt>RelayedCandidateDatagramSocket</tt> to send data to\n         */\n        public Channel(TransportAddress peerAddress)\n        {\n            this.peerAddress = peerAddress;\n        }\n\n        /**\n         * Binds/installs this channel so that it provides this\n         * <tt>RelayedCandidateDatagramSocket</tt> with a permission to send\n         * data to the <tt>TransportAddress</tt> associated with this instance.\n         *\n         * @throws StunException if anything goes wrong while binding/installing\n         * this channel\n         */\n        public void bind()\n            throws StunException\n        {\n            byte[] createPermissionTransactionID\n                = TransactionID.createNewTransactionID().getBytes();\n            Request createPermissionRequest\n                = MessageFactory.createCreatePermissionRequest(\n                        peerAddress,\n                        createPermissionTransactionID);\n\n            createPermissionRequest.setTransactionID(\n                    createPermissionTransactionID);\n            turnCandidateHarvest.sendRequest(\n                    RelayedCandidateDatagramSocket.this,\n                    createPermissionRequest);\n\n            bindingTransactionID = createPermissionTransactionID;\n            bindingTimeStamp = System.currentTimeMillis();\n\n            if (channelDataIsPreferred)\n            {\n                if (channelNumber == CHANNEL_NUMBER_NOT_SPECIFIED)\n                {\n                    channelNumber = getNextChannelNumber();\n                    channelNumberIsConfirmed = false;\n                }\n                if (channelNumber != CHANNEL_NUMBER_NOT_SPECIFIED)\n                {\n                    byte[] channelBindTransactionID\n                        = TransactionID.createNewTransactionID().getBytes();\n                    Request channelBindRequest\n                        = MessageFactory.createChannelBindRequest(\n                                channelNumber,\n                                peerAddress,\n                                channelBindTransactionID);\n\n                    channelBindRequest.setTransactionID(\n                            channelBindTransactionID);\n\n                    /*\n                     * We have to be prepared to receive ChannelData messages\n                     * from the TURN server as soon as we've sent the\n                     * ChannelBind request and before we've received a success\n                     * response to it.\n                     */\n                    synchronized (packetsToReceive)\n                    {\n                        if (!closed && (receiveChannelDataThread == null))\n                            createReceiveChannelDataThread();\n                    }\n\n                    turnCandidateHarvest.sendRequest(\n                            RelayedCandidateDatagramSocket.this,\n                            channelBindRequest);\n                }\n            }\n        }\n\n        /**\n         * Determines whether the channel number of this <tt>Channel</tt> is\n         * value equal to a specific channel number.\n         *\n         * @param channelNumber the channel number to be compared to the channel\n         * number of this <tt>Channel</tt> for value equality\n         * @return <tt>true</tt> if the specified <tt>channelNumber</tt> is\n         * equal to the channel number of this <tt>Channel</tt>\n         */\n        public boolean channelNumberEquals(char channelNumber)\n        {\n            return (this.channelNumber == channelNumber);\n        }\n\n        /**\n         * Gets the indicator which determines whether this <tt>Channel</tt> is\n         * set to prefer sending <tt>DatagramPacket</tt>s using TURN ChannelData\n         * messages instead of Send indications.\n         *\n         * @return the indicator which determines whether this <tt>Channel</tt>\n         * is set to prefer sending <tt>DatagramPacket</tt>s using TURN\n         * ChannelData messages instead of Send indications\n         */\n        public boolean getChannelDataIsPreferred()\n        {\n            return channelDataIsPreferred;\n        }\n\n        /**\n         * Gets the indicator which determines whether this instance has started\n         * binding/installing itself and has not received a confirmation that it\n         * has succeeded in doing so yet.\n         *\n         * @return <tt>true</tt> if this instance has started binding/installing\n         * itself and has not received a confirmation that it has succeeded in\n         * doing so yet; otherwise, <tt>false</tt>\n         */\n        public boolean isBinding()\n        {\n            return (bindingTransactionID != null);\n        }\n\n        /**\n         * Gets the indication which determines whether this instance is\n         * currently considered bound/installed.\n         *\n         * @return <tt>true</tt> if this instance is currently considered\n         * bound/installed; otherwise, <tt>false</tt>\n         */\n        public boolean isBound()\n        {\n            if ((bindingTimeStamp == -1)\n                    || (bindingTimeStamp\n                                + PERMISSION_LIFETIME\n                                - PERMISSION_LIFETIME_LEEWAY)\n                            < System.currentTimeMillis())\n                return false;\n            return (bindingTransactionID == null) && bound;\n        }\n\n        /**\n         * Determines whether the <tt>peerAddress</tt> property of this instance\n         * is considered by this <tt>Channel</tt> to be equal to a specific\n         * <tt>TransportAddress</tt>.\n         *\n         * @param peerAddress the <tt>TransportAddress</tt> which is to be\n         * checked for equality (as defined by this <tt>Channel</tt> and not\n         * necessarily by the <tt>TransportAddress</tt> class)\n         * @return <tt>true</tt> if the specified <tt>TransportAddress</tt> is\n         * considered by this <tt>Channel</tt> to be equal to its\n         * <tt>peerAddress</tt> property; otherwise, <tt>false</tt>\n         */\n        public boolean peerAddressEquals(TransportAddress peerAddress)\n        {\n            /*\n             * CreatePermission installs a permission for the IP address and the\n             * port is ignored. But ChannelBind creates a channel for the\n             * peerAddress only. So if there is a chance that ChannelBind will\n             * be used, have a Channel instance per peerAddress and\n             * CreatePermission more often than really necessary (as a side\n             * effect).\n             */\n            if (channelDataSocket != null)\n                return this.peerAddress.equals(peerAddress);\n            else\n            {\n                return\n                    this.peerAddress.getAddress().equals(\n                            peerAddress.getAddress());\n            }\n        }\n\n        /**\n         * Sends a specific <tt>DatagramPacket</tt> through this\n         * <tt>Channel</tt> to a specific peer <tt>TransportAddress</tt>.\n         *\n         * @param p the <tt>DatagramPacket</tt> to be sent\n         * @param peerAddress the <tt>TransportAddress</tt> of the peer to which\n         * the <tt>DatagramPacket</tt> is to be sent\n         * @throws StunException if anything goes wrong while sending the\n         * specified <tt>DatagramPacket</tt> to the specified peer\n         * <tt>TransportAddress</tt>\n         */\n        public void send(DatagramPacket p, TransportAddress peerAddress)\n            throws StunException\n        {\n            byte[] pData = p.getData();\n            int pOffset = p.getOffset();\n            int pLength = p.getLength();\n            byte[] data;\n\n            if ((pOffset == 0) && (pLength == pData.length))\n                data = pData;\n            else\n            {\n                data = new byte[pLength];\n                System.arraycopy(pData, pOffset, data, 0, pLength);\n            }\n\n            if (channelDataIsPreferred\n                    && (channelNumber != CHANNEL_NUMBER_NOT_SPECIFIED)\n                    && channelNumberIsConfirmed)\n            {\n                char length = (char) data.length;\n                int channelDataLength\n                    = CHANNELDATA_CHANNELNUMBER_LENGTH\n                        + CHANNELDATA_LENGTH_LENGTH\n                        + length;\n\n                if ((channelData == null)\n                        || (channelData.length < channelDataLength))\n                {\n                    channelData = new byte[channelDataLength];\n                    if (channelDataPacket != null)\n                        channelDataPacket.setData(channelData);\n                }\n\n                // Channel Number\n                channelData[0] = (byte) (channelNumber >> 8);\n                channelData[1] = (byte) (channelNumber & 0xFF);\n                // Length\n                channelData[2] = (byte) (length >> 8);\n                channelData[3] = (byte) (length & 0xFF);\n                // Application Data\n                System.arraycopy(\n                        data,\n                        0,\n                        channelData,\n                        CHANNELDATA_CHANNELNUMBER_LENGTH\n                            + CHANNELDATA_LENGTH_LENGTH,\n                        length);\n\n                try\n                {\n                    if (channelDataPacket == null)\n                    {\n                        channelDataPacket\n                            = new DatagramPacket(\n                                    channelData, 0, channelDataLength,\n                                    turnCandidateHarvest.harvester.stunServer);\n                    }\n                    else\n                        channelDataPacket.setData(channelData, 0,\n                                channelDataLength);\n\n                    channelDataSocket.send(channelDataPacket);\n                }\n                catch (IOException ioex)\n                {\n                    throw\n                        new StunException(\n                                StunException.NETWORK_ERROR,\n                                \"Failed to send TURN ChannelData message\",\n                                ioex);\n                }\n            }\n            else\n            {\n                byte[] transactionID\n                    = TransactionID.createNewTransactionID().getBytes();\n                Indication sendIndication\n                    = MessageFactory.createSendIndication(\n                            peerAddress,\n                            data,\n                            transactionID);\n\n                sendIndication.setTransactionID(transactionID);\n                turnCandidateHarvest.harvester.getStunStack().sendIndication(\n                        sendIndication,\n                        turnCandidateHarvest.harvester.stunServer,\n                        turnCandidateHarvest\n                            .hostCandidate.getTransportAddress());\n            }\n        }\n\n        /**\n         * Sets the indicator which determines whether this <tt>Channel</tt> is\n         * bound/installed.\n         *\n         * @param bound <tt>true</tt> if this <tt>Channel</tt> is to be marked\n         * as bound/installed; otherwise, <tt>false</tt>\n         * @param boundTransactionID an array of <tt>byte</tt>s which represents\n         * the ID of the transaction with which the confirmation about the\n         * binding/installing has arrived\n         */\n        public void setBound(boolean bound, byte[] boundTransactionID)\n        {\n            if (bindingTransactionID != null)\n            {\n                bindingTransactionID = null;\n                this.bound = bound;\n            }\n        }\n\n        /**\n         * Sets the indicator which determines whether this <tt>Channel</tt> is\n         * set to prefer sending <tt>DatagramPacket</tt>s using TURN ChannelData\n         * messages instead of Send indications.\n         *\n         * @param channelDataIsPreferred <tt>true</tt> if this <tt>Channel</tt>\n         * is to be set to prefer sending <tt>DatagramPacket</tt>s using TURN\n         * ChannelData messages instead of Send indications\n         */\n        public void setChannelDataIsPreferred(boolean channelDataIsPreferred)\n        {\n            this.channelDataIsPreferred = channelDataIsPreferred;\n        }\n\n        /**\n         * Sets the indicator which determines whether the associated TURN\n         * server has confirmed the allocation of the <tt>channelNumber</tt> of\n         * this <tt>Channel</tt> by us receiving a success <tt>Response</tt> to\n         * our ChannelBind <tt>Request</tt>.\n         *\n         * @param channelNumberIsConfirmed <tt>true</tt> if allocation of the\n         * channel number has been confirmed by a success <tt>Response</tt> to\n         * our ChannelBind <tt>Request</tt>\n         * @param channelNumberIsConfirmedTransactionID an array of\n         * <tt>byte</tt>s which represents the ID of the transaction with which\n         * the confirmation about the allocation of the channel number has\n         * arrived\n         */\n        public void setChannelNumberIsConfirmed(\n                boolean channelNumberIsConfirmed,\n                byte[] channelNumberIsConfirmedTransactionID)\n        {\n            this.channelNumberIsConfirmed = channelNumberIsConfirmed;\n        }\n    }", "definition": "    private class Channel", "class_docstring": "\nRepresents a channel which relays data sent through this\n<tt>RelayedCandidateDatagramSocket</tt> to a specific\n<tt>TransportAddress</tt> via the TURN server associated with this\n<tt>RelayedCandidateDatagramSocket</tt>.\n", "name": "Channel", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [{"attribute_expression": "private long bindingTimeStamp = -1;", "docstring": "\nThe time stamp in milliseconds at which {@link #bindingTransactionID}\nhas been used to bind/install this <tt>Channel</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "bindingTimeStamp = -1", "syntax_pass": true}, {"attribute_expression": "private byte[] bindingTransactionID;", "docstring": "\nThe ID of the transaction with which a CreatePermission\n<tt>Request</tt> has been sent to bind/install this <tt>Channel</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte[]", "name": "bindingTransactionID", "syntax_pass": true}, {"attribute_expression": "private boolean bound = false;", "docstring": "\nThe indication which determines whether a confirmation has been\nreceived that this <tt>Channel</tt> has been bound.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "bound = false", "syntax_pass": true}, {"attribute_expression": "private byte[] channelData;", "docstring": "\nThe value of the <tt>data</tt> property of\n{@link #channelDataPacket}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte[]", "name": "channelData", "syntax_pass": true}, {"attribute_expression": "private boolean channelDataIsPreferred = false;", "docstring": "\nThe indicator which determines whether this <tt>Channel</tt> is set\nto prefer sending <tt>DatagramPacket</tt>s using TURN ChannelData\nmessages instead of Send indications.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "channelDataIsPreferred = false", "syntax_pass": true}, {"attribute_expression": "private DatagramPacket channelDataPacket;", "docstring": "\nThe <tt>DatagramPacket</tt> in which this <tt>Channel</tt> sends TURN\nChannelData messages through\n{@link RelayedCandidateDatagramSocket#channelDataSocket}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DatagramPacket", "name": "channelDataPacket", "syntax_pass": true}, {"attribute_expression": "private char channelNumber = CHANNEL_NUMBER_NOT_SPECIFIED;", "docstring": "\nThe TURN channel number of this <tt>Channel</tt> which is to be or\nhas been allocated using a ChannelBind <tt>Request</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "char", "name": "channelNumber = CHANNEL_NUMBER_NOT_SPECIFIED", "syntax_pass": true}, {"attribute_expression": "private boolean channelNumberIsConfirmed;", "docstring": "\nThe indicator which determines whether the associated TURN server has\nconfirmed the allocation of {@link #channelNumber} by us receiving a\nsuccess <tt>Response</tt> to our ChannelBind <tt>Request</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "channelNumberIsConfirmed", "syntax_pass": true}, {"attribute_expression": "public final TransportAddress peerAddress;", "docstring": "\nThe <tt>TransportAddress</tt> of the peer to which this\n<tt>Channel</tt> provides a permission of this\n<tt>RelayedCandidateDatagramSocket</tt> to send data to.\n", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "TransportAddress", "name": "peerAddress", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Channel(TransportAddress peerAddress)\n        {\n            this.peerAddress = peerAddress;\n        }", "docstring": "\nInitializes a new <tt>Channel</tt> instance which is to provide this\n<tt>RelayedCandidateDatagramSocket</tt> with a permission to send\nto a specific peer <tt>TransportAddress</tt>.\n\n@param peerAddress the <tt>TransportAddress</tt> of the peer to which\nthe new instance is to provide a permission of this\n<tt>RelayedCandidateDatagramSocket</tt> to send data to\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Channel", "params": [{"name": "peerAddress", "type": "TransportAddress"}], "body": "        {\n            this.peerAddress = peerAddress;\n        }", "signature": "public Channel(TransportAddress peerAddress)"}, {"syntax_pass": true, "original_string": "        public void bind()\n            throws StunException\n        {\n            byte[] createPermissionTransactionID\n                = TransactionID.createNewTransactionID().getBytes();\n            Request createPermissionRequest\n                = MessageFactory.createCreatePermissionRequest(\n                        peerAddress,\n                        createPermissionTransactionID);\n\n            createPermissionRequest.setTransactionID(\n                    createPermissionTransactionID);\n            turnCandidateHarvest.sendRequest(\n                    RelayedCandidateDatagramSocket.this,\n                    createPermissionRequest);\n\n            bindingTransactionID = createPermissionTransactionID;\n            bindingTimeStamp = System.currentTimeMillis();\n\n            if (channelDataIsPreferred)\n            {\n                if (channelNumber == CHANNEL_NUMBER_NOT_SPECIFIED)\n                {\n                    channelNumber = getNextChannelNumber();\n                    channelNumberIsConfirmed = false;\n                }\n                if (channelNumber != CHANNEL_NUMBER_NOT_SPECIFIED)\n                {\n                    byte[] channelBindTransactionID\n                        = TransactionID.createNewTransactionID().getBytes();\n                    Request channelBindRequest\n                        = MessageFactory.createChannelBindRequest(\n                                channelNumber,\n                                peerAddress,\n                                channelBindTransactionID);\n\n                    channelBindRequest.setTransactionID(\n                            channelBindTransactionID);\n\n                    /*\n                     * We have to be prepared to receive ChannelData messages\n                     * from the TURN server as soon as we've sent the\n                     * ChannelBind request and before we've received a success\n                     * response to it.\n                     */\n                    synchronized (packetsToReceive)\n                    {\n                        if (!closed && (receiveChannelDataThread == null))\n                            createReceiveChannelDataThread();\n                    }\n\n                    turnCandidateHarvest.sendRequest(\n                            RelayedCandidateDatagramSocket.this,\n                            channelBindRequest);\n                }\n            }\n        }", "docstring": "\nBinds/installs this channel so that it provides this\n<tt>RelayedCandidateDatagramSocket</tt> with a permission to send\ndata to the <tt>TransportAddress</tt> associated with this instance.\n\n@throws StunException if anything goes wrong while binding/installing\nthis channel\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "bind", "params": [], "body": "        {\n            byte[] createPermissionTransactionID\n                = TransactionID.createNewTransactionID().getBytes();\n            Request createPermissionRequest\n                = MessageFactory.createCreatePermissionRequest(\n                        peerAddress,\n                        createPermissionTransactionID);\n\n            createPermissionRequest.setTransactionID(\n                    createPermissionTransactionID);\n            turnCandidateHarvest.sendRequest(\n                    RelayedCandidateDatagramSocket.this,\n                    createPermissionRequest);\n\n            bindingTransactionID = createPermissionTransactionID;\n            bindingTimeStamp = System.currentTimeMillis();\n\n            if (channelDataIsPreferred)\n            {\n                if (channelNumber == CHANNEL_NUMBER_NOT_SPECIFIED)\n                {\n                    channelNumber = getNextChannelNumber();\n                    channelNumberIsConfirmed = false;\n                }\n                if (channelNumber != CHANNEL_NUMBER_NOT_SPECIFIED)\n                {\n                    byte[] channelBindTransactionID\n                        = TransactionID.createNewTransactionID().getBytes();\n                    Request channelBindRequest\n                        = MessageFactory.createChannelBindRequest(\n                                channelNumber,\n                                peerAddress,\n                                channelBindTransactionID);\n\n                    channelBindRequest.setTransactionID(\n                            channelBindTransactionID);\n\n                    /*\n                     * We have to be prepared to receive ChannelData messages\n                     * from the TURN server as soon as we've sent the\n                     * ChannelBind request and before we've received a success\n                     * response to it.\n                     */\n                    synchronized (packetsToReceive)\n                    {\n                        if (!closed && (receiveChannelDataThread == null))\n                            createReceiveChannelDataThread();\n                    }\n\n                    turnCandidateHarvest.sendRequest(\n                            RelayedCandidateDatagramSocket.this,\n                            channelBindRequest);\n                }\n            }\n        }", "signature": "public void bind()"}, {"syntax_pass": true, "original_string": "        public boolean channelNumberEquals(char channelNumber)\n        {\n            return (this.channelNumber == channelNumber);\n        }", "docstring": "\nDetermines whether the channel number of this <tt>Channel</tt> is\nvalue equal to a specific channel number.\n\n@param channelNumber the channel number to be compared to the channel\nnumber of this <tt>Channel</tt> for value equality\n@return <tt>true</tt> if the specified <tt>channelNumber</tt> is\nequal to the channel number of this <tt>Channel</tt>\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "channelNumberEquals", "params": [{"name": "channelNumber", "type": "char"}], "body": "        {\n            return (this.channelNumber == channelNumber);\n        }", "signature": "public boolean channelNumberEquals(char channelNumber)"}, {"syntax_pass": true, "original_string": "        public boolean getChannelDataIsPreferred()\n        {\n            return channelDataIsPreferred;\n        }", "docstring": "\nGets the indicator which determines whether this <tt>Channel</tt> is\nset to prefer sending <tt>DatagramPacket</tt>s using TURN ChannelData\nmessages instead of Send indications.\n\n@return the indicator which determines whether this <tt>Channel</tt>\nis set to prefer sending <tt>DatagramPacket</tt>s using TURN\nChannelData messages instead of Send indications\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "getChannelDataIsPreferred", "params": [], "body": "        {\n            return channelDataIsPreferred;\n        }", "signature": "public boolean getChannelDataIsPreferred()"}, {"syntax_pass": true, "original_string": "        public boolean isBinding()\n        {\n            return (bindingTransactionID != null);\n        }", "docstring": "\nGets the indicator which determines whether this instance has started\nbinding/installing itself and has not received a confirmation that it\nhas succeeded in doing so yet.\n\n@return <tt>true</tt> if this instance has started binding/installing\nitself and has not received a confirmation that it has succeeded in\ndoing so yet; otherwise, <tt>false</tt>\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isBinding", "params": [], "body": "        {\n            return (bindingTransactionID != null);\n        }", "signature": "public boolean isBinding()"}, {"syntax_pass": true, "original_string": "        public boolean isBound()\n        {\n            if ((bindingTimeStamp == -1)\n                    || (bindingTimeStamp\n                                + PERMISSION_LIFETIME\n                                - PERMISSION_LIFETIME_LEEWAY)\n                            < System.currentTimeMillis())\n                return false;\n            return (bindingTransactionID == null) && bound;\n        }", "docstring": "\nGets the indication which determines whether this instance is\ncurrently considered bound/installed.\n\n@return <tt>true</tt> if this instance is currently considered\nbound/installed; otherwise, <tt>false</tt>\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isBound", "params": [], "body": "        {\n            if ((bindingTimeStamp == -1)\n                    || (bindingTimeStamp\n                                + PERMISSION_LIFETIME\n                                - PERMISSION_LIFETIME_LEEWAY)\n                            < System.currentTimeMillis())\n                return false;\n            return (bindingTransactionID == null) && bound;\n        }", "signature": "public boolean isBound()"}, {"syntax_pass": true, "original_string": "        public boolean peerAddressEquals(TransportAddress peerAddress)\n        {\n            /*\n             * CreatePermission installs a permission for the IP address and the\n             * port is ignored. But ChannelBind creates a channel for the\n             * peerAddress only. So if there is a chance that ChannelBind will\n             * be used, have a Channel instance per peerAddress and\n             * CreatePermission more often than really necessary (as a side\n             * effect).\n             */\n            if (channelDataSocket != null)\n                return this.peerAddress.equals(peerAddress);\n            else\n            {\n                return\n                    this.peerAddress.getAddress().equals(\n                            peerAddress.getAddress());\n            }\n        }", "docstring": "\nDetermines whether the <tt>peerAddress</tt> property of this instance\nis considered by this <tt>Channel</tt> to be equal to a specific\n<tt>TransportAddress</tt>.\n\n@param peerAddress the <tt>TransportAddress</tt> which is to be\nchecked for equality (as defined by this <tt>Channel</tt> and not\nnecessarily by the <tt>TransportAddress</tt> class)\n@return <tt>true</tt> if the specified <tt>TransportAddress</tt> is\nconsidered by this <tt>Channel</tt> to be equal to its\n<tt>peerAddress</tt> property; otherwise, <tt>false</tt>\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "peerAddressEquals", "params": [{"name": "peerAddress", "type": "TransportAddress"}], "body": "        {\n            /*\n             * CreatePermission installs a permission for the IP address and the\n             * port is ignored. But ChannelBind creates a channel for the\n             * peerAddress only. So if there is a chance that ChannelBind will\n             * be used, have a Channel instance per peerAddress and\n             * CreatePermission more often than really necessary (as a side\n             * effect).\n             */\n            if (channelDataSocket != null)\n                return this.peerAddress.equals(peerAddress);\n            else\n            {\n                return\n                    this.peerAddress.getAddress().equals(\n                            peerAddress.getAddress());\n            }\n        }", "signature": "public boolean peerAddressEquals(TransportAddress peerAddress)"}, {"syntax_pass": true, "original_string": "        public void send(DatagramPacket p, TransportAddress peerAddress)\n            throws StunException\n        {\n            byte[] pData = p.getData();\n            int pOffset = p.getOffset();\n            int pLength = p.getLength();\n            byte[] data;\n\n            if ((pOffset == 0) && (pLength == pData.length))\n                data = pData;\n            else\n            {\n                data = new byte[pLength];\n                System.arraycopy(pData, pOffset, data, 0, pLength);\n            }\n\n            if (channelDataIsPreferred\n                    && (channelNumber != CHANNEL_NUMBER_NOT_SPECIFIED)\n                    && channelNumberIsConfirmed)\n            {\n                char length = (char) data.length;\n                int channelDataLength\n                    = CHANNELDATA_CHANNELNUMBER_LENGTH\n                        + CHANNELDATA_LENGTH_LENGTH\n                        + length;\n\n                if ((channelData == null)\n                        || (channelData.length < channelDataLength))\n                {\n                    channelData = new byte[channelDataLength];\n                    if (channelDataPacket != null)\n                        channelDataPacket.setData(channelData);\n                }\n\n                // Channel Number\n                channelData[0] = (byte) (channelNumber >> 8);\n                channelData[1] = (byte) (channelNumber & 0xFF);\n                // Length\n                channelData[2] = (byte) (length >> 8);\n                channelData[3] = (byte) (length & 0xFF);\n                // Application Data\n                System.arraycopy(\n                        data,\n                        0,\n                        channelData,\n                        CHANNELDATA_CHANNELNUMBER_LENGTH\n                            + CHANNELDATA_LENGTH_LENGTH,\n                        length);\n\n                try\n                {\n                    if (channelDataPacket == null)\n                    {\n                        channelDataPacket\n                            = new DatagramPacket(\n                                    channelData, 0, channelDataLength,\n                                    turnCandidateHarvest.harvester.stunServer);\n                    }\n                    else\n                        channelDataPacket.setData(channelData, 0,\n                                channelDataLength);\n\n                    channelDataSocket.send(channelDataPacket);\n                }\n                catch (IOException ioex)\n                {\n                    throw\n                        new StunException(\n                                StunException.NETWORK_ERROR,\n                                \"Failed to send TURN ChannelData message\",\n                                ioex);\n                }\n            }\n            else\n            {\n                byte[] transactionID\n                    = TransactionID.createNewTransactionID().getBytes();\n                Indication sendIndication\n                    = MessageFactory.createSendIndication(\n                            peerAddress,\n                            data,\n                            transactionID);\n\n                sendIndication.setTransactionID(transactionID);\n                turnCandidateHarvest.harvester.getStunStack().sendIndication(\n                        sendIndication,\n                        turnCandidateHarvest.harvester.stunServer,\n                        turnCandidateHarvest\n                            .hostCandidate.getTransportAddress());\n            }\n        }", "docstring": "\nSends a specific <tt>DatagramPacket</tt> through this\n<tt>Channel</tt> to a specific peer <tt>TransportAddress</tt>.\n\n@param p the <tt>DatagramPacket</tt> to be sent\n@param peerAddress the <tt>TransportAddress</tt> of the peer to which\nthe <tt>DatagramPacket</tt> is to be sent\n@throws StunException if anything goes wrong while sending the\nspecified <tt>DatagramPacket</tt> to the specified peer\n<tt>TransportAddress</tt>\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "send", "params": [{"name": "p", "type": "DatagramPacket"}, {"name": "peerAddress", "type": "TransportAddress"}], "body": "        {\n            byte[] pData = p.getData();\n            int pOffset = p.getOffset();\n            int pLength = p.getLength();\n            byte[] data;\n\n            if ((pOffset == 0) && (pLength == pData.length))\n                data = pData;\n            else\n            {\n                data = new byte[pLength];\n                System.arraycopy(pData, pOffset, data, 0, pLength);\n            }\n\n            if (channelDataIsPreferred\n                    && (channelNumber != CHANNEL_NUMBER_NOT_SPECIFIED)\n                    && channelNumberIsConfirmed)\n            {\n                char length = (char) data.length;\n                int channelDataLength\n                    = CHANNELDATA_CHANNELNUMBER_LENGTH\n                        + CHANNELDATA_LENGTH_LENGTH\n                        + length;\n\n                if ((channelData == null)\n                        || (channelData.length < channelDataLength))\n                {\n                    channelData = new byte[channelDataLength];\n                    if (channelDataPacket != null)\n                        channelDataPacket.setData(channelData);\n                }\n\n                // Channel Number\n                channelData[0] = (byte) (channelNumber >> 8);\n                channelData[1] = (byte) (channelNumber & 0xFF);\n                // Length\n                channelData[2] = (byte) (length >> 8);\n                channelData[3] = (byte) (length & 0xFF);\n                // Application Data\n                System.arraycopy(\n                        data,\n                        0,\n                        channelData,\n                        CHANNELDATA_CHANNELNUMBER_LENGTH\n                            + CHANNELDATA_LENGTH_LENGTH,\n                        length);\n\n                try\n                {\n                    if (channelDataPacket == null)\n                    {\n                        channelDataPacket\n                            = new DatagramPacket(\n                                    channelData, 0, channelDataLength,\n                                    turnCandidateHarvest.harvester.stunServer);\n                    }\n                    else\n                        channelDataPacket.setData(channelData, 0,\n                                channelDataLength);\n\n                    channelDataSocket.send(channelDataPacket);\n                }\n                catch (IOException ioex)\n                {\n                    throw\n                        new StunException(\n                                StunException.NETWORK_ERROR,\n                                \"Failed to send TURN ChannelData message\",\n                                ioex);\n                }\n            }\n            else\n            {\n                byte[] transactionID\n                    = TransactionID.createNewTransactionID().getBytes();\n                Indication sendIndication\n                    = MessageFactory.createSendIndication(\n                            peerAddress,\n                            data,\n                            transactionID);\n\n                sendIndication.setTransactionID(transactionID);\n                turnCandidateHarvest.harvester.getStunStack().sendIndication(\n                        sendIndication,\n                        turnCandidateHarvest.harvester.stunServer,\n                        turnCandidateHarvest\n                            .hostCandidate.getTransportAddress());\n            }\n        }", "signature": "public void send(DatagramPacket p, TransportAddress peerAddress)"}, {"syntax_pass": true, "original_string": "        public void setBound(boolean bound, byte[] boundTransactionID)\n        {\n            if (bindingTransactionID != null)\n            {\n                bindingTransactionID = null;\n                this.bound = bound;\n            }\n        }", "docstring": "\nSets the indicator which determines whether this <tt>Channel</tt> is\nbound/installed.\n\n@param bound <tt>true</tt> if this <tt>Channel</tt> is to be marked\nas bound/installed; otherwise, <tt>false</tt>\n@param boundTransactionID an array of <tt>byte</tt>s which represents\nthe ID of the transaction with which the confirmation about the\nbinding/installing has arrived\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setBound", "params": [{"name": "bound", "type": "boolean"}, {"name": "boundTransactionID", "type": "byte[]"}], "body": "        {\n            if (bindingTransactionID != null)\n            {\n                bindingTransactionID = null;\n                this.bound = bound;\n            }\n        }", "signature": "public void setBound(boolean bound, byte[] boundTransactionID)"}, {"syntax_pass": true, "original_string": "        public void setChannelDataIsPreferred(boolean channelDataIsPreferred)\n        {\n            this.channelDataIsPreferred = channelDataIsPreferred;\n        }", "docstring": "\nSets the indicator which determines whether this <tt>Channel</tt> is\nset to prefer sending <tt>DatagramPacket</tt>s using TURN ChannelData\nmessages instead of Send indications.\n\n@param channelDataIsPreferred <tt>true</tt> if this <tt>Channel</tt>\nis to be set to prefer sending <tt>DatagramPacket</tt>s using TURN\nChannelData messages instead of Send indications\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setChannelDataIsPreferred", "params": [{"name": "channelDataIsPreferred", "type": "boolean"}], "body": "        {\n            this.channelDataIsPreferred = channelDataIsPreferred;\n        }", "signature": "public void setChannelDataIsPreferred(boolean channelDataIsPreferred)"}, {"syntax_pass": true, "original_string": "        public void setChannelNumberIsConfirmed(\n                boolean channelNumberIsConfirmed,\n                byte[] channelNumberIsConfirmedTransactionID)\n        {\n            this.channelNumberIsConfirmed = channelNumberIsConfirmed;\n        }", "docstring": "\nSets the indicator which determines whether the associated TURN\nserver has confirmed the allocation of the <tt>channelNumber</tt> of\nthis <tt>Channel</tt> by us receiving a success <tt>Response</tt> to\nour ChannelBind <tt>Request</tt>.\n\n@param channelNumberIsConfirmed <tt>true</tt> if allocation of the\nchannel number has been confirmed by a success <tt>Response</tt> to\nour ChannelBind <tt>Request</tt>\n@param channelNumberIsConfirmedTransactionID an array of\n<tt>byte</tt>s which represents the ID of the transaction with which\nthe confirmation about the allocation of the channel number has\narrived\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setChannelNumberIsConfirmed", "params": [{"name": "channelNumberIsConfirmed", "type": "boolean"}, {"name": "channelNumberIsConfirmedTransactionID", "type": "byte[]"}], "body": "        {\n            this.channelNumberIsConfirmed = channelNumberIsConfirmed;\n        }", "signature": "public void setChannelNumberIsConfirmed(\n                boolean channelNumberIsConfirmed,\n                byte[] channelNumberIsConfirmedTransactionID)"}]}], "class_docstring": "\nRepresents an application-purposed (as opposed to an ICE-specific)\n<tt>DatagramSocket</tt> for a <tt>RelayedCandidate</tt> harvested by a\n<tt>TurnCandidateHarvest</tt> (and its associated\n<tt>TurnCandidateHarvester</tt>, of course).\n<tt>RelayedCandidateDatagramSocket</tt> is associated with a successful\nAllocation on a TURN server and implements sends and receives through it\nusing TURN messages to and from that TURN server.\n\n@author Lyubomir Marinov\n", "original_string": "public class RelayedCandidateDatagramSocket\n    extends DatagramSocket\n    implements MessageEventHandler\n{\n\n    /**\n     * The <tt>Logger</tt> used by the <tt>RelayedCandidateDatagramSocket</tt>\n     * class and its instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(RelayedCandidateDatagramSocket.class.getName());\n\n    /**\n     * The constant which represents a channel number value signaling that no\n     * channel number has been explicitly specified.\n     */\n    private static final char CHANNEL_NUMBER_NOT_SPECIFIED = 0;\n\n    /**\n     * The length in bytes of the Channel Number field of a TURN ChannelData\n     * message.\n     */\n    private static final int CHANNELDATA_CHANNELNUMBER_LENGTH = 2;\n\n    /**\n     * The length in bytes of the Length field of a TURN ChannelData message.\n     */\n    private static final int CHANNELDATA_LENGTH_LENGTH = 2;\n\n    /**\n     * The maximum channel number which is valid for TURN ChannelBind\n     * <tt>Request</tt>.\n     */\n    private static final char MAX_CHANNEL_NUMBER = 0x7FFF;\n\n    /**\n     * The minimum channel number which is valid for TURN ChannelBind\n     * <tt>Request</tt>s.\n     */\n    private static final char MIN_CHANNEL_NUMBER = 0x4000;\n\n    /**\n     * The lifetime in milliseconds of a TURN permission created using a\n     * CreatePermission request.\n     */\n    private static final long PERMISSION_LIFETIME = 300 /* seconds */ * 1000L;\n\n    /**\n     * The time in milliseconds before a TURN permission expires that a\n     * <tt>RelayedCandidateDatagramSocket</tt> is to try to reinstall it.\n     */\n    private static final long PERMISSION_LIFETIME_LEEWAY\n        = 60 /* seconds */ * 1000L;\n\n    /**\n     * The <tt>DatagramSocket</tt> through which this\n     * <tt>RelayedCandidateDatagramSocket</tt> actually sends and receives the\n     * data it has been asked to {@link #send(DatagramPacket)} and\n     * {@link #receive(DatagramPacket)}. Since data can be exchanged with a TURN\n     * server using STUN messages (i.e. Send and Data indications),\n     * <tt>RelayedCandidateDatagramSocket</tt> may send and receive data using\n     * the associated <tt>StunStack</tt> and not <tt>channelDataSocket</tt>.\n     * However, using <tt>channelDataSocket</tt> is supposed to be more\n     * efficient than using <tt>StunStack</tt>.\n     */\n    private final DatagramSocket channelDataSocket;\n\n    /**\n     * The list of per-peer <tt>Channel</tt>s through which this\n     * <tt>RelayedCandidateDatagramSocket</tt>s relays data send to it to\n     * peer <tt>TransportAddress</tt>es.\n     */\n    private final List<Channel> channels = new LinkedList<>();\n\n    /**\n     * The indicator which determines whether this instance has started\n     * executing or has executed its {@link #close()} method.\n     */\n    private boolean closed = false;\n\n    /**\n     * The <tt>DatagramPacketFilter</tt> which is able to determine whether a\n     * specific <tt>DatagramPacket</tt> sent through a\n     * <tt>RelayedCandidateDatagramSocket</tt> is part of the ICE connectivity\n     * checks. The recognizing is necessary because RFC 5245 says that \"it is\n     * RECOMMENDED that the agent defer creation of a TURN channel until ICE\n     * completes.\"\n     */\n    private static final DatagramPacketFilter connectivityCheckRecognizer\n        = new StunDatagramPacketFilter();\n\n    /**\n     * The next free channel number to be returned by\n     * {@link #getNextChannelNumber()} and marked as non-free.\n     */\n    private char nextChannelNumber = MIN_CHANNEL_NUMBER;\n\n    /**\n     * The <tt>DatagramPacket</tt>s which are to be received through this\n     * <tt>DatagramSocket</tt> upon calls to its\n     * {@link #receive(DatagramPacket)} method. They have been received from the\n     * TURN server in the form of Data indications.\n     */\n    private final List<DatagramPacket> packetsToReceive = new LinkedList<>();\n\n    /**\n     * The <tt>DatagramSocket</tt>s which have been sent through this\n     * <tt>DatagramSocket</tt> using its {@link #send(DatagramPacket)} method\n     * and which are to be relayed through its associated TURN server in the\n     * form of Send indications.\n     */\n    private final List<DatagramPacket> packetsToSend = new LinkedList<>();\n\n    /**\n     * The <tt>Thread</tt> which receives <tt>DatagramPacket</tt>s from\n     * {@link #channelDataSocket} and queues them in {@link #packetsToReceive}.\n     */\n    private Thread receiveChannelDataThread;\n\n    /**\n     * The <tt>RelayedCandidate</tt> which uses this instance as the value of\n     * its <tt>socket</tt> property.\n     */\n    private final RelayedCandidate relayedCandidate;\n\n    /**\n     * The <tt>Thread</tt> which is to send the {@link #packetsToSend} to the\n     * associated TURN server.\n     */\n    private Thread sendThread;\n\n    /**\n     * The <tt>TurnCandidateHarvest</tt> which has harvested\n     * {@link #relayedCandidate}.\n     */\n    private final TurnCandidateHarvest turnCandidateHarvest;\n\n    /**\n     * Initializes a new <tt>RelayedCandidateDatagramSocket</tt> instance which\n     * is to be the <tt>socket</tt> of a specific <tt>RelayedCandidate</tt>\n     * harvested by a specific <tt>TurnCandidateHarvest</tt>.\n     *\n     * @param relayedCandidate the <tt>RelayedCandidate</tt> which is to use the\n     * new instance as the value of its <tt>socket</tt> property\n     * @param turnCandidateHarvest the <tt>TurnCandidateHarvest</tt> which has\n     * harvested <tt>relayedCandidate</tt>\n     * @throws SocketException if anything goes wrong while initializing the new\n     * <tt>RelayedCandidateDatagramSocket</tt> instance\n     */\n    public RelayedCandidateDatagramSocket(\n            RelayedCandidate relayedCandidate,\n            TurnCandidateHarvest turnCandidateHarvest)\n        throws SocketException\n    {\n        super(/* bindaddr */ (SocketAddress) null);\n\n        this.relayedCandidate = relayedCandidate;\n        this.turnCandidateHarvest = turnCandidateHarvest;\n\n        this.turnCandidateHarvest\n                .harvester\n                    .getStunStack()\n                        .addIndicationListener(\n                                this.turnCandidateHarvest.hostCandidate\n                                        .getTransportAddress(),\n                                this);\n\n        DatagramSocket hostSocket\n            = this.turnCandidateHarvest.hostCandidate\n                    .getCandidateIceSocketWrapper().getUDPSocket();\n\n        if (hostSocket instanceof MultiplexingDatagramSocket)\n        {\n            channelDataSocket\n                = ((MultiplexingDatagramSocket) hostSocket).getSocket(\n                        new TurnDatagramPacketFilter(\n                                this.turnCandidateHarvest.harvester.stunServer)\n                        {\n                            @Override\n                            public boolean accept(DatagramPacket p)\n                            {\n                                return channelDataSocketAccept(p);\n                            }\n\n                            @Override\n                            protected boolean acceptMethod(char method)\n                            {\n                                return channelDataSocketAcceptMethod(method);\n                            }\n                        });\n        }\n        else\n            channelDataSocket = null;\n    }\n\n    /**\n     * Determines whether a specific <tt>DatagramPacket</tt> is accepted by\n     * {@link #channelDataSocket} (i.e. whether <tt>channelDataSocket</tt>\n     * understands <tt>p</tt> and <tt>p</tt> is meant to be received by\n     * <tt>channelDataSocket</tt>).\n     *\n     * @param p the <tt>DatagramPacket</tt> which is to be checked whether it is\n     * accepted by <tt>channelDataSocket</tt>\n     * @return <tt>true</tt> if <tt>channelDataSocket</tt> accepts <tt>p</tt>\n     * (i.e. <tt>channelDataSocket</tt> understands <tt>p</tt> and <tt>p</tt> is\n     * meant to be received by <tt>channelDataSocket</tt>); otherwise,\n     * <tt>false</tt>\n     */\n    private boolean channelDataSocketAccept(DatagramPacket p)\n    {\n        // Is it from our TURN server?\n        if (turnCandidateHarvest.harvester.stunServer.equals(\n                p.getSocketAddress()))\n        {\n            int pLength = p.getLength();\n\n            if (pLength\n                    >= (CHANNELDATA_CHANNELNUMBER_LENGTH\n                            + CHANNELDATA_LENGTH_LENGTH))\n            {\n                byte[] pData = p.getData();\n                int pOffset = p.getOffset();\n\n                /*\n                 * The first two bits should be 0b01 because of the current\n                 * channel number range 0x4000 - 0x7FFE. But 0b10 and 0b11 which\n                 * are currently reserved and may be used in the future to\n                 * extend the range of channel numbers.\n                 */\n                if ((pData[pOffset] & 0xC0) != 0)\n                {\n                    /*\n                     * Technically, we cannot create a DatagramPacket from a\n                     * ChannelData message with a Channel Number we do not know\n                     * about. But determining that we know the value of the\n                     * Channel Number field may be too much of an unnecessary\n                     * performance penalty and it may be unnecessary because the\n                     * message comes from our TURN server and it looks like a\n                     * ChannelData message already.\n                     */\n                    pOffset += CHANNELDATA_CHANNELNUMBER_LENGTH;\n                    pLength -= CHANNELDATA_CHANNELNUMBER_LENGTH;\n\n                    int length\n                        = ((pData[pOffset++] << 8)\n                              | (pData[pOffset++] & 0xFF));\n\n                    int padding = ((length % 4) > 0) ? 4 - (length % 4) : 0;\n\n                    /*\n                     * The Length field specifies the length in bytes of the\n                     * Application Data field. The Length field does not include\n                     * the padding that is sometimes present in the data of the\n                     * DatagramPacket.\n                     */\n                    return length == pLength - padding - CHANNELDATA_LENGTH_LENGTH \n                        || length == pLength - CHANNELDATA_LENGTH_LENGTH;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Determines whether {@link #channelDataSocket} accepts\n     * <tt>DatagramPacket</tt>s which represent STUN messages with a specific\n     * method.\n     *\n     * @param method the method of the STUN messages represented in\n     * <tt>DatagramPacket</tt>s which is accepted by <tt>channelDataSocket</tt>\n     * @return <tt>true</tt> if <tt>channelDataSocket</tt> accepts\n     * <tt>DatagramPacket</tt>s which represent STUN messages with the specified\n     * <tt>method</tt>; otherwise, <tt>false</tt>\n     */\n    private boolean channelDataSocketAcceptMethod(char method)\n    {\n        /*\n         * Accept only ChannelData messages for now. ChannelData messages are\n         * not STUN messages so they do not have a method associated with them.\n         */\n        return false;\n    }\n\n    /**\n     * Closes this datagram socket.\n     *\n     * @see DatagramSocket#close()\n     */\n    @Override\n    public void close()\n    {\n        synchronized (this)\n        {\n            if (this.closed)\n                return;\n            else\n                this.closed = true;\n        }\n        synchronized (packetsToReceive)\n        {\n            packetsToReceive.notifyAll();\n        }\n        synchronized (packetsToSend)\n        {\n            packetsToSend.notifyAll();\n        }\n        turnCandidateHarvest.harvester.getStunStack().removeIndicationListener(\n                turnCandidateHarvest.hostCandidate.getTransportAddress(),\n                this);\n        turnCandidateHarvest.close(this);\n\n        super.close();\n    }\n\n    /**\n     * Creates {@link #receiveChannelDataThread} which is to receive\n     * <tt>DatagramPacket</tt>s from {@link #channelDataSocket} and queue them\n     * in {@link #packetsToReceive}.\n     */\n    private void createReceiveChannelDataThread()\n    {\n        receiveChannelDataThread\n            = new Thread()\n            {\n                @Override\n                public void run()\n                {\n                    boolean done = false;\n\n                    try\n                    {\n                        runInReceiveChannelDataThread();\n                        done = true;\n                    }\n                    catch (SocketException sex)\n                    {\n                        done = true;\n                    }\n                    finally\n                    {\n                        /*\n                         * If receiveChannelDataThread is dying and this\n                         * RelayedCandidateDatagramSocket is not closed, then\n                         * spawn a new receiveChannelDataThread.\n                         */\n                        synchronized (packetsToReceive)\n                        {\n                            if (receiveChannelDataThread\n                                    == Thread.currentThread())\n                                receiveChannelDataThread = null;\n                            if ((receiveChannelDataThread == null)\n                                    && !closed\n                                    && !done)\n                                createReceiveChannelDataThread();\n                        }\n                    }\n                }\n            };\n        receiveChannelDataThread.start();\n    }\n\n    /**\n     * Creates {@link #sendThread} which is to send {@link #packetsToSend} to\n     * the associated TURN server.\n     */\n    private void createSendThread()\n    {\n        sendThread\n            = new Thread()\n            {\n                @Override\n                public void run()\n                {\n                    try\n                    {\n                        runInSendThread();\n                    }\n                    finally\n                    {\n                        /*\n                         * If sendThread is dying and there are packetsToSend,\n                         * then spawn a new sendThread.\n                         */\n                        synchronized (packetsToSend)\n                        {\n                            if (sendThread == Thread.currentThread())\n                                sendThread = null;\n                            if ((sendThread == null)\n                                    && !closed\n                                    && !packetsToSend.isEmpty())\n                                createSendThread();\n                        }\n                    }\n                }\n            };\n        sendThread.start();\n    }\n\n    /**\n     * Gets the local address to which the socket is bound.\n     * <tt>RelayedCandidateDatagramSocket</tt> returns the <tt>address</tt> of\n     * its <tt>localSocketAddress</tt>.\n     * <p>\n     * If there is a security manager, its <tt>checkConnect</tt> method is first\n     * called with the host address and <tt>-1</tt> as its arguments to see if\n     * the operation is allowed.\n     * </p>\n     *\n     * @return the local address to which the socket is bound, or an\n     * <tt>InetAddress</tt> representing any local address if either the socket\n     * is not bound, or the security manager <tt>checkConnect</tt> method does\n     * not allow the operation\n     * @see #getLocalSocketAddress()\n     * @see DatagramSocket#getLocalAddress()\n     */\n    @Override\n    public InetAddress getLocalAddress()\n    {\n        return getLocalSocketAddress().getAddress();\n    }\n\n    /**\n     * Returns the port number on the local host to which this socket is bound.\n     * <tt>RelayedCandidateDatagramSocket</tt> returns the <tt>port</tt> of its\n     * <tt>localSocketAddress</tt>.\n     *\n     * @return the port number on the local host to which this socket is bound\n     * @see #getLocalSocketAddress()\n     * @see DatagramSocket#getLocalPort()\n     */\n    @Override\n    public int getLocalPort()\n    {\n        return getLocalSocketAddress().getPort();\n    }\n\n    /**\n     * Returns the address of the endpoint this socket is bound to, or\n     * <tt>null</tt> if it is not bound yet. Since\n     * <tt>RelayedCandidateDatagramSocket</tt> represents an\n     * application-purposed <tt>DatagramSocket</tt> relaying data to and from a\n     * TURN server, the <tt>localSocketAddress</tt> is the\n     * <tt>transportAddress</tt> of the respective <tt>RelayedCandidate</tt>.\n     *\n     * @return a <tt>SocketAddress</tt> representing the local endpoint of this\n     * socket, or <tt>null</tt> if it is not bound yet\n     * @see DatagramSocket#getLocalSocketAddress()\n     */\n    @Override\n    public InetSocketAddress getLocalSocketAddress()\n    {\n        return getRelayedCandidate().getTransportAddress();\n    }\n\n    /**\n     * Gets the next free channel number to be allocated to a <tt>Channel</tt>\n     * and marked as non-free.\n     *\n     * @return the next free channel number to be allocated to a\n     * <tt>Channel</tt> and marked as non-free.\n     */\n    private char getNextChannelNumber()\n    {\n        char nextChannelNumber;\n\n        if (this.nextChannelNumber > MAX_CHANNEL_NUMBER)\n            nextChannelNumber = CHANNEL_NUMBER_NOT_SPECIFIED;\n        else\n        {\n            nextChannelNumber = this.nextChannelNumber;\n            this.nextChannelNumber++;\n        }\n        return nextChannelNumber;\n    }\n\n    /**\n     * Gets the <tt>RelayedCandidate</tt> which uses this instance as the value\n     * of its <tt>socket</tt> property.\n     *\n     * @return the <tt>RelayedCandidate</tt> which uses this instance as the\n     * value of its <tt>socket</tt> property\n     */\n    public final RelayedCandidate getRelayedCandidate()\n    {\n        return relayedCandidate;\n    }\n\n    /**\n     * Notifies this <tt>MessageEventHandler</tt> that a specific STUN message\n     * has been received, parsed and is ready for delivery.\n     * <tt>RelayedCandidateDatagramSocket</tt> handles STUN indications sent\n     * from the associated TURN server and received at the associated local\n     * <tt>TransportAddress</tt>.\n     *\n     * @param e a <tt>StunMessageEvent</tt> which encapsulates the received STUN\n     * message\n     */\n    public void handleMessageEvent(StunMessageEvent e)\n    {\n        /*\n         * Is it meant for us? (It should be because\n         * RelayedCandidateDatagramSocket registers for STUN indications\n         * received at the associated local TransportAddress only.)\n         */\n        if (!turnCandidateHarvest.hostCandidate.getTransportAddress().equals(\n                e.getLocalAddress()))\n            return;\n        // Is it from our TURN server?\n        if (!turnCandidateHarvest.harvester.stunServer.equals(\n                e.getRemoteAddress()))\n            return;\n\n        Message message = e.getMessage();\n        char messageType = message.getMessageType();\n\n        if (messageType != Message.DATA_INDICATION)\n            return;\n\n        /*\n         * RFC 5766: When the client receives a Data indication, it checks that\n         * the Data indication contains both an XOR-PEER-ADDRESS and a DATA\n         * attribute, and discards the indication if it does not.\n         */\n        XorPeerAddressAttribute peerAddressAttribute\n            = (XorPeerAddressAttribute)\n                message.getAttribute(Attribute.XOR_PEER_ADDRESS);\n\n        if (peerAddressAttribute == null)\n            return;\n\n        DataAttribute dataAttribute\n            = (DataAttribute) message.getAttribute(Attribute.DATA);\n\n        if (dataAttribute == null)\n            return;\n\n        TransportAddress peerAddress\n            = peerAddressAttribute.getAddress(message.getTransactionID());\n\n        if (peerAddress == null)\n            return;\n\n        byte[] data = dataAttribute.getData();\n\n        if (data == null)\n            return;\n\n        DatagramPacket packetToReceive;\n\n        try\n        {\n            packetToReceive\n                = new DatagramPacket(data, 0, data.length, peerAddress);\n        }\n        catch (Throwable t)\n        {\n            /*\n             * The signature of the DatagramPacket constructor was changed\n             * in JDK 8 to not declare that it may throw a SocketException.\n             */\n            if (t instanceof SocketException)\n            {\n                packetToReceive = null;\n            }\n            else if (t instanceof Error)\n            {\n                throw (Error) t;\n            }\n            else if (t instanceof RuntimeException)\n            {\n                throw (RuntimeException) t;\n            }\n            else\n            {\n                /*\n                 * Unfortunately, we cannot re-throw it. Anyway, it was\n                 * unlikely to occur on JDK 7.\n                 */\n                if (t instanceof InterruptedException)\n                {\n                    Thread.currentThread().interrupt();\n                }\n                packetToReceive = null;\n            }\n        }\n        if (packetToReceive != null)\n        {\n            synchronized (packetsToReceive)\n            {\n                packetsToReceive.add(packetToReceive);\n                packetsToReceive.notifyAll();\n            }\n        }\n    }\n\n    /**\n     * Notifies this <tt>RelayedCandidateDatagramSocket</tt> that a specific\n     * <tt>Request</tt> it has sent has either failed or received a STUN error\n     * <tt>Response</tt>.\n     *\n     * @param response the <tt>Response</tt> which responds to <tt>request</tt>\n     * @param request the <tt>Request</tt> sent by this instance to which\n     * <tt>response</tt> responds\n     * @return <tt>true</tt> if the failure or error condition has been handled\n     * and the caller should assume this instance has recovered from it;\n     * otherwise, <tt>false</tt>\n     */\n    public boolean processErrorOrFailure(Response response, Request request)\n    {\n        switch (request.getMessageType())\n        {\n        case Message.CHANNELBIND_REQUEST:\n            setChannelNumberIsConfirmed(request, false);\n            break;\n        case Message.CREATEPERMISSION_REQUEST:\n            setChannelBound(request, false);\n            break;\n        default:\n            break;\n        }\n        return false;\n    }\n\n    /**\n     * Notifies this <tt>RelayedCandidateDatagramSocket</tt> that a specific\n     * <tt>Request</tt> it has sent has received a STUN success\n     * <tt>Response</tt>.\n     *\n     * @param response the <tt>Response</tt> which responds to <tt>request</tt>\n     * @param request the <tt>Request</tt> sent by this instance to which\n     * <tt>response</tt> responds\n     */\n    public void processSuccess(Response response, Request request)\n    {\n        switch (request.getMessageType())\n        {\n        case Message.CHANNELBIND_REQUEST:\n            setChannelNumberIsConfirmed(request, true);\n            break;\n        case Message.CREATEPERMISSION_REQUEST:\n            setChannelBound(request, true);\n            break;\n        default:\n            break;\n        }\n    }\n\n    /**\n     * Receives a datagram packet from this socket. When this method returns,\n     * the <tt>DatagramPacket</tt>'s buffer is filled with the data received.\n     * The datagram packet also contains the sender's IP address, and the port\n     * number on the sender's machine.\n     *\n     * @param p the <tt>DatagramPacket</tt> into which to place the incoming\n     * data\n     * @throws IOException if an I/O error occurs\n     * @see DatagramSocket#receive(DatagramPacket)\n     */\n    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        synchronized (packetsToReceive)\n        {\n            do\n            {\n                /*\n                 * According to the javadoc of DatagramSocket#close(), any\n                 * thread currently blocked in #receive(DatagramPacket) upon\n                 * this socket will throw a SocketException.\n                 */\n                if (closed)\n                {\n                    throw\n                        new SocketException(\n                                RelayedCandidateDatagramSocket.class\n                                        .getSimpleName()\n                                    + \" has been closed.\");\n                }\n                else if (packetsToReceive.isEmpty())\n                {\n                    try\n                    {\n                        packetsToReceive.wait();\n                    }\n                    catch (InterruptedException iex)\n                    {\n                    }\n                }\n                else\n                {\n                    DatagramPacket packetToReceive = packetsToReceive.remove(0);\n\n                    MultiplexingXXXSocketSupport.copy(packetToReceive, p);\n                    packetsToReceive.notifyAll();\n                    break;\n                }\n            }\n            while (true);\n        }\n    }\n\n    /**\n     * Runs in {@link #receiveChannelDataThread} to receive\n     * <tt>DatagramPacket</tt>s from {@link #channelDataSocket} and queue them\n     * in {@link #packetsToReceive}.\n     *\n     * @throws SocketException if anything goes wrong while receiving\n     * <tt>DatagramPacket</tt>s from {@link #channelDataSocket} and\n     * {@link #receiveChannelDataThread} is to no longer exist\n     */\n    private void runInReceiveChannelDataThread()\n        throws SocketException\n    {\n        DatagramPacket p = null;\n\n        while (!closed)\n        {\n            // read one datagram a time\n            int receiveBufferSize = 1500;\n\n            if (p == null)\n            {\n                p\n                    = new DatagramPacket(\n                            new byte[receiveBufferSize],\n                            receiveBufferSize);\n            }\n            else\n            {\n                byte[] pData = p.getData();\n\n                if ((pData == null) || (pData.length < receiveBufferSize))\n                    p.setData(new byte[receiveBufferSize]);\n                else\n                    p.setLength(receiveBufferSize);\n            }\n\n            try\n            {\n                channelDataSocket.receive(p);\n            }\n            catch (Throwable t)\n            {\n                if (t instanceof ThreadDeath)\n                {\n                    // Death is the end of life no matter what.\n                    throw (ThreadDeath) t;\n                }\n                else if (t instanceof SocketException)\n                {\n                    /*\n                     * If the channelDataSocket has gone unusable, put an end to\n                     * receiving from it.\n                     */\n                    throw (SocketException) t;\n                }\n                else\n                {\n                    if (logger.isLoggable(Level.WARNING))\n                    {\n                        logger.log(\n                                Level.WARNING,\n                                \"Ignoring error while receiving from\"\n                                    + \" ChannelData socket\",\n                                t);\n                    }\n                    continue;\n                }\n            }\n\n            /*\n             * We've been waiting in #receive so make sure we're still to\n             * continue just in case.\n             */\n            if (closed)\n                break;\n\n            int channelDataLength = p.getLength();\n\n            if (channelDataLength\n                    < (CHANNELDATA_CHANNELNUMBER_LENGTH\n                            + CHANNELDATA_LENGTH_LENGTH))\n                continue;\n\n            byte[] channelData = p.getData();\n            int channelDataOffset = p.getOffset();\n            char channelNumber\n                = (char)\n                    ((channelData[channelDataOffset++] << 8)\n                            | (channelData[channelDataOffset++] & 0xFF));\n\n            channelDataLength -= CHANNELDATA_CHANNELNUMBER_LENGTH;\n\n            char length\n                = (char)\n                    ((channelData[channelDataOffset++] << 8)\n                            | (channelData[channelDataOffset++] & 0xFF));\n\n            channelDataLength -= CHANNELDATA_LENGTH_LENGTH;\n            if (length > channelDataLength)\n                continue;\n\n            TransportAddress peerAddress = null;\n\n            synchronized (packetsToSend)\n            {\n                int channelCount = channels.size();\n\n                for (int channelIndex = 0;\n                        channelIndex < channelCount;\n                        channelIndex++)\n                {\n                    Channel channel = channels.get(channelIndex);\n\n                    if (channel.channelNumberEquals(channelNumber))\n                    {\n                        peerAddress = channel.peerAddress;\n                        break;\n                    }\n                }\n            }\n            if (peerAddress == null)\n                continue;\n\n            byte[] data = new byte[length];\n\n            System.arraycopy(channelData, channelDataOffset, data, 0, length);\n\n            DatagramPacket packetToReceive\n                = new DatagramPacket(data, 0, length, peerAddress);\n\n            synchronized (packetsToReceive)\n            {\n                packetsToReceive.add(packetToReceive);\n                packetsToReceive.notifyAll();\n            }\n        }\n    }\n\n    /**\n     * Runs in {@link #sendThread} to send {@link #packetsToSend} to the\n     * associated TURN server.\n     */\n    private void runInSendThread()\n    {\n        synchronized (packetsToSend)\n        {\n            while (!closed)\n            {\n                if (packetsToSend.isEmpty())\n                {\n                    try\n                    {\n                        packetsToSend.wait();\n                    }\n                    catch (InterruptedException iex)\n                    {\n                    }\n                    continue;\n                }\n\n                int packetToSendCount = packetsToSend.size();\n\n                for (int packetToSendIndex = 0;\n                        packetToSendIndex < packetToSendCount;\n                        packetToSendIndex++)\n                {\n                    DatagramPacket packetToSend\n                        = packetsToSend.get(packetToSendIndex);\n\n                    /*\n                     * Get a channel to the peer which is to receive the\n                     * packetToSend.\n                     */\n                    int channelCount = channels.size();\n                    TransportAddress peerAddress\n                        = new TransportAddress(\n                                packetToSend.getAddress(),\n                                packetToSend.getPort(),\n                                Transport.UDP);\n                    Channel channel = null;\n\n                    for (int channelIndex = 0;\n                            channelIndex < channelCount;\n                            channelIndex++)\n                    {\n                        Channel aChannel = channels.get(channelIndex);\n\n                        if (aChannel.peerAddressEquals(peerAddress))\n                        {\n                            channel = aChannel;\n                            break;\n                        }\n                    }\n                    if (channel == null)\n                    {\n                        channel = new Channel(peerAddress);\n                        channels.add(channel);\n                    }\n\n                    /*\n                     * RFC 5245 says that \"it is RECOMMENDED that the agent\n                     * defer creation of a TURN channel until ICE completes.\"\n                     * RelayedCandidateDatagramSocket is not explicitly told\n                     * from the outside that ICE has completed so it tries to\n                     * determine it by assuming that connectivity checks send\n                     * only STUN messages and ICE has completed by the time a\n                     * non-STUN message is to be sent.\n                     */\n                    boolean forceBind = false;\n\n                    if ((channelDataSocket != null)\n                            && !channel.getChannelDataIsPreferred()\n                            && !connectivityCheckRecognizer.accept(\n                                    packetToSend))\n                    {\n                        channel.setChannelDataIsPreferred(true);\n                        forceBind = true;\n                    }\n\n                    /*\n                     * Either bind the channel or send the packetToSend through\n                     * it.\n                     */\n                    if (!forceBind && channel.isBound())\n                    {\n                        packetsToSend.remove(packetToSendIndex);\n                        try\n                        {\n                            channel.send(packetToSend, peerAddress);\n                        }\n                        catch (StunException sex)\n                        {\n                            if (logger.isLoggable(Level.INFO))\n                            {\n                                logger.log(\n                                        Level.INFO,\n                                        \"Failed to send through \"\n                                            + RelayedCandidateDatagramSocket\n                                                    .class.getSimpleName()\n                                            + \" channel.\" ,\n                                        sex);\n                            }\n                        }\n                        break;\n                    }\n                    else if (forceBind || !channel.isBinding())\n                    {\n                        try\n                        {\n                            channel.bind();\n                        }\n                        catch (StunException sex)\n                        {\n                            if (logger.isLoggable(Level.INFO))\n                            {\n                                logger.log(\n                                        Level.INFO,\n                                        \"Failed to bind \"\n                                            + RelayedCandidateDatagramSocket\n                                                    .class.getSimpleName()\n                                            + \" channel.\" ,\n                                        sex);\n                            }\n                            /*\n                             * Well, it may not be the fault of the packetToSend\n                             * but it happened while we were trying to send it\n                             * and we don't have a way to report an error so\n                             * just drop packetToSend in order to change\n                             * something and not just go again trying the same\n                             * thing.\n                             */\n                            packetsToSend.remove(packetToSendIndex);\n                            break;\n                        }\n                        /*\n                         * If the Channel was bound but #bind() was forced on\n                         * it, we cannot continue with the next packetToSend\n                         * because it may be for the same Channel and then\n                         * #bind() will not be forced and the Channel will be\n                         * bound already so the send order of the packetsToSend\n                         * will be disrupted.\n                         */\n                        if (forceBind)\n                            break;\n                    }\n                }\n\n                /*\n                 * If no packetToSend has been sent by the current iteration,\n                 * then we must be waiting for some condition to change in order\n                 * to be able to send.\n                 */\n                if (packetsToSend.size() == packetToSendCount)\n                {\n                    try\n                    {\n                        packetsToSend.wait();\n                    }\n                    catch (InterruptedException iex)\n                    {\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Sends a datagram packet from this socket. The <tt>DatagramPacket</tt>\n     * includes information indicating the data to be sent, its length, the IP\n     * address of the remote host, and the port number on the remote host.\n     *\n     * @param p the <tt>DatagramPacket</tt> to be sent\n     * @throws IOException if an I/O error occurs\n     * @see DatagramSocket#send(DatagramPacket)\n     */\n    @Override\n    public void send(DatagramPacket p)\n        throws IOException\n    {\n        synchronized (packetsToSend)\n        {\n            if (closed)\n            {\n                throw\n                    new IOException(\n                            RelayedCandidateDatagramSocket.class.getSimpleName()\n                                + \" has been closed.\");\n            }\n            else\n            {\n                packetsToSend.add(MultiplexingXXXSocketSupport.clone(p));\n                if (sendThread == null)\n                    createSendThread();\n                else\n                    packetsToSend.notifyAll();\n            }\n        }\n    }\n\n    /**\n     * Sets the <tt>bound</tt> property of a <tt>Channel</tt> the installation\n     * of which has been attempted by sending a specific <tt>Request</tt>.\n     *\n     * @param request the <tt>Request</tt> which has been attempted in order to\n     * install a <tt>Channel</tt>\n     * @param bound <tt>true</tt> if the <tt>bound</tt> property of the\n     * <tt>Channel</tt> is to be set to <tt>true</tt>; otherwise, <tt>false</tt>\n     */\n    private void setChannelBound(Request request, boolean bound)\n    {\n        XorPeerAddressAttribute peerAddressAttribute\n            = (XorPeerAddressAttribute)\n                request.getAttribute(Attribute.XOR_PEER_ADDRESS);\n        byte[] transactionID = request.getTransactionID();\n        TransportAddress peerAddress\n            = peerAddressAttribute.getAddress(transactionID);\n\n        synchronized (packetsToSend)\n        {\n            int channelCount = channels.size();\n\n            for (int channelIndex = 0;\n                    channelIndex < channelCount;\n                    channelIndex++)\n            {\n                Channel channel = channels.get(channelIndex);\n\n                if (channel.peerAddressEquals(peerAddress))\n                {\n                    channel.setBound(bound, transactionID);\n                    packetsToSend.notifyAll();\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Sets the <tt>channelNumberIsConfirmed</tt> property of a <tt>Channel</tt>\n     * which has attempted to allocate a specific channel number by sending a\n     * specific ChannelBind <tt>Request</tt>.\n     *\n     * @param request the <tt>Request</tt> which has been sent to allocate a\n     * specific channel number for a <tt>Channel</tt>\n     * @param channelNumberIsConfirmed <tt>true</tt> if the channel number has\n     * been successfully allocated; otherwise, <tt>false</tt>\n     */\n    private void setChannelNumberIsConfirmed(\n            Request request,\n            boolean channelNumberIsConfirmed)\n    {\n        XorPeerAddressAttribute peerAddressAttribute\n            = (XorPeerAddressAttribute)\n                request.getAttribute(Attribute.XOR_PEER_ADDRESS);\n        byte[] transactionID = request.getTransactionID();\n        TransportAddress peerAddress\n            = peerAddressAttribute.getAddress(transactionID);\n\n        synchronized (packetsToSend)\n        {\n            int channelCount = channels.size();\n\n            for (int channelIndex = 0;\n                    channelIndex < channelCount;\n                    channelIndex++)\n            {\n                Channel channel = channels.get(channelIndex);\n\n                if (channel.peerAddressEquals(peerAddress))\n                {\n                    channel.setChannelNumberIsConfirmed(\n                            channelNumberIsConfirmed,\n                            transactionID);\n                    packetsToSend.notifyAll();\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * Represents a channel which relays data sent through this\n     * <tt>RelayedCandidateDatagramSocket</tt> to a specific\n     * <tt>TransportAddress</tt> via the TURN server associated with this\n     * <tt>RelayedCandidateDatagramSocket</tt>.\n     */\n    private class Channel\n    {\n        /**\n         * The time stamp in milliseconds at which {@link #bindingTransactionID}\n         * has been used to bind/install this <tt>Channel</tt>.\n         */\n        private long bindingTimeStamp = -1;\n\n        /**\n         * The ID of the transaction with which a CreatePermission\n         * <tt>Request</tt> has been sent to bind/install this <tt>Channel</tt>.\n         */\n        private byte[] bindingTransactionID;\n\n        /**\n         * The indication which determines whether a confirmation has been\n         * received that this <tt>Channel</tt> has been bound.\n         */\n        private boolean bound = false;\n\n        /**\n         * The value of the <tt>data</tt> property of\n         * {@link #channelDataPacket}.\n         */\n        private byte[] channelData;\n\n        /**\n         * The indicator which determines whether this <tt>Channel</tt> is set\n         * to prefer sending <tt>DatagramPacket</tt>s using TURN ChannelData\n         * messages instead of Send indications.\n         */\n        private boolean channelDataIsPreferred = false;\n\n        /**\n         * The <tt>DatagramPacket</tt> in which this <tt>Channel</tt> sends TURN\n         * ChannelData messages through\n         * {@link RelayedCandidateDatagramSocket#channelDataSocket}.\n         */\n        private DatagramPacket channelDataPacket;\n\n        /**\n         * The TURN channel number of this <tt>Channel</tt> which is to be or\n         * has been allocated using a ChannelBind <tt>Request</tt>.\n         */\n        private char channelNumber = CHANNEL_NUMBER_NOT_SPECIFIED;\n\n        /**\n         * The indicator which determines whether the associated TURN server has\n         * confirmed the allocation of {@link #channelNumber} by us receiving a\n         * success <tt>Response</tt> to our ChannelBind <tt>Request</tt>.\n         */\n        private boolean channelNumberIsConfirmed;\n\n        /**\n         * The <tt>TransportAddress</tt> of the peer to which this\n         * <tt>Channel</tt> provides a permission of this\n         * <tt>RelayedCandidateDatagramSocket</tt> to send data to.\n         */\n        public final TransportAddress peerAddress;\n\n        /**\n         * Initializes a new <tt>Channel</tt> instance which is to provide this\n         * <tt>RelayedCandidateDatagramSocket</tt> with a permission to send\n         * to a specific peer <tt>TransportAddress</tt>.\n         *\n         * @param peerAddress the <tt>TransportAddress</tt> of the peer to which\n         * the new instance is to provide a permission of this\n         * <tt>RelayedCandidateDatagramSocket</tt> to send data to\n         */\n        public Channel(TransportAddress peerAddress)\n        {\n            this.peerAddress = peerAddress;\n        }\n\n        /**\n         * Binds/installs this channel so that it provides this\n         * <tt>RelayedCandidateDatagramSocket</tt> with a permission to send\n         * data to the <tt>TransportAddress</tt> associated with this instance.\n         *\n         * @throws StunException if anything goes wrong while binding/installing\n         * this channel\n         */\n        public void bind()\n            throws StunException\n        {\n            byte[] createPermissionTransactionID\n                = TransactionID.createNewTransactionID().getBytes();\n            Request createPermissionRequest\n                = MessageFactory.createCreatePermissionRequest(\n                        peerAddress,\n                        createPermissionTransactionID);\n\n            createPermissionRequest.setTransactionID(\n                    createPermissionTransactionID);\n            turnCandidateHarvest.sendRequest(\n                    RelayedCandidateDatagramSocket.this,\n                    createPermissionRequest);\n\n            bindingTransactionID = createPermissionTransactionID;\n            bindingTimeStamp = System.currentTimeMillis();\n\n            if (channelDataIsPreferred)\n            {\n                if (channelNumber == CHANNEL_NUMBER_NOT_SPECIFIED)\n                {\n                    channelNumber = getNextChannelNumber();\n                    channelNumberIsConfirmed = false;\n                }\n                if (channelNumber != CHANNEL_NUMBER_NOT_SPECIFIED)\n                {\n                    byte[] channelBindTransactionID\n                        = TransactionID.createNewTransactionID().getBytes();\n                    Request channelBindRequest\n                        = MessageFactory.createChannelBindRequest(\n                                channelNumber,\n                                peerAddress,\n                                channelBindTransactionID);\n\n                    channelBindRequest.setTransactionID(\n                            channelBindTransactionID);\n\n                    /*\n                     * We have to be prepared to receive ChannelData messages\n                     * from the TURN server as soon as we've sent the\n                     * ChannelBind request and before we've received a success\n                     * response to it.\n                     */\n                    synchronized (packetsToReceive)\n                    {\n                        if (!closed && (receiveChannelDataThread == null))\n                            createReceiveChannelDataThread();\n                    }\n\n                    turnCandidateHarvest.sendRequest(\n                            RelayedCandidateDatagramSocket.this,\n                            channelBindRequest);\n                }\n            }\n        }\n\n        /**\n         * Determines whether the channel number of this <tt>Channel</tt> is\n         * value equal to a specific channel number.\n         *\n         * @param channelNumber the channel number to be compared to the channel\n         * number of this <tt>Channel</tt> for value equality\n         * @return <tt>true</tt> if the specified <tt>channelNumber</tt> is\n         * equal to the channel number of this <tt>Channel</tt>\n         */\n        public boolean channelNumberEquals(char channelNumber)\n        {\n            return (this.channelNumber == channelNumber);\n        }\n\n        /**\n         * Gets the indicator which determines whether this <tt>Channel</tt> is\n         * set to prefer sending <tt>DatagramPacket</tt>s using TURN ChannelData\n         * messages instead of Send indications.\n         *\n         * @return the indicator which determines whether this <tt>Channel</tt>\n         * is set to prefer sending <tt>DatagramPacket</tt>s using TURN\n         * ChannelData messages instead of Send indications\n         */\n        public boolean getChannelDataIsPreferred()\n        {\n            return channelDataIsPreferred;\n        }\n\n        /**\n         * Gets the indicator which determines whether this instance has started\n         * binding/installing itself and has not received a confirmation that it\n         * has succeeded in doing so yet.\n         *\n         * @return <tt>true</tt> if this instance has started binding/installing\n         * itself and has not received a confirmation that it has succeeded in\n         * doing so yet; otherwise, <tt>false</tt>\n         */\n        public boolean isBinding()\n        {\n            return (bindingTransactionID != null);\n        }\n\n        /**\n         * Gets the indication which determines whether this instance is\n         * currently considered bound/installed.\n         *\n         * @return <tt>true</tt> if this instance is currently considered\n         * bound/installed; otherwise, <tt>false</tt>\n         */\n        public boolean isBound()\n        {\n            if ((bindingTimeStamp == -1)\n                    || (bindingTimeStamp\n                                + PERMISSION_LIFETIME\n                                - PERMISSION_LIFETIME_LEEWAY)\n                            < System.currentTimeMillis())\n                return false;\n            return (bindingTransactionID == null) && bound;\n        }\n\n        /**\n         * Determines whether the <tt>peerAddress</tt> property of this instance\n         * is considered by this <tt>Channel</tt> to be equal to a specific\n         * <tt>TransportAddress</tt>.\n         *\n         * @param peerAddress the <tt>TransportAddress</tt> which is to be\n         * checked for equality (as defined by this <tt>Channel</tt> and not\n         * necessarily by the <tt>TransportAddress</tt> class)\n         * @return <tt>true</tt> if the specified <tt>TransportAddress</tt> is\n         * considered by this <tt>Channel</tt> to be equal to its\n         * <tt>peerAddress</tt> property; otherwise, <tt>false</tt>\n         */\n        public boolean peerAddressEquals(TransportAddress peerAddress)\n        {\n            /*\n             * CreatePermission installs a permission for the IP address and the\n             * port is ignored. But ChannelBind creates a channel for the\n             * peerAddress only. So if there is a chance that ChannelBind will\n             * be used, have a Channel instance per peerAddress and\n             * CreatePermission more often than really necessary (as a side\n             * effect).\n             */\n            if (channelDataSocket != null)\n                return this.peerAddress.equals(peerAddress);\n            else\n            {\n                return\n                    this.peerAddress.getAddress().equals(\n                            peerAddress.getAddress());\n            }\n        }\n\n        /**\n         * Sends a specific <tt>DatagramPacket</tt> through this\n         * <tt>Channel</tt> to a specific peer <tt>TransportAddress</tt>.\n         *\n         * @param p the <tt>DatagramPacket</tt> to be sent\n         * @param peerAddress the <tt>TransportAddress</tt> of the peer to which\n         * the <tt>DatagramPacket</tt> is to be sent\n         * @throws StunException if anything goes wrong while sending the\n         * specified <tt>DatagramPacket</tt> to the specified peer\n         * <tt>TransportAddress</tt>\n         */\n        public void send(DatagramPacket p, TransportAddress peerAddress)\n            throws StunException\n        {\n            byte[] pData = p.getData();\n            int pOffset = p.getOffset();\n            int pLength = p.getLength();\n            byte[] data;\n\n            if ((pOffset == 0) && (pLength == pData.length))\n                data = pData;\n            else\n            {\n                data = new byte[pLength];\n                System.arraycopy(pData, pOffset, data, 0, pLength);\n            }\n\n            if (channelDataIsPreferred\n                    && (channelNumber != CHANNEL_NUMBER_NOT_SPECIFIED)\n                    && channelNumberIsConfirmed)\n            {\n                char length = (char) data.length;\n                int channelDataLength\n                    = CHANNELDATA_CHANNELNUMBER_LENGTH\n                        + CHANNELDATA_LENGTH_LENGTH\n                        + length;\n\n                if ((channelData == null)\n                        || (channelData.length < channelDataLength))\n                {\n                    channelData = new byte[channelDataLength];\n                    if (channelDataPacket != null)\n                        channelDataPacket.setData(channelData);\n                }\n\n                // Channel Number\n                channelData[0] = (byte) (channelNumber >> 8);\n                channelData[1] = (byte) (channelNumber & 0xFF);\n                // Length\n                channelData[2] = (byte) (length >> 8);\n                channelData[3] = (byte) (length & 0xFF);\n                // Application Data\n                System.arraycopy(\n                        data,\n                        0,\n                        channelData,\n                        CHANNELDATA_CHANNELNUMBER_LENGTH\n                            + CHANNELDATA_LENGTH_LENGTH,\n                        length);\n\n                try\n                {\n                    if (channelDataPacket == null)\n                    {\n                        channelDataPacket\n                            = new DatagramPacket(\n                                    channelData, 0, channelDataLength,\n                                    turnCandidateHarvest.harvester.stunServer);\n                    }\n                    else\n                        channelDataPacket.setData(channelData, 0,\n                                channelDataLength);\n\n                    channelDataSocket.send(channelDataPacket);\n                }\n                catch (IOException ioex)\n                {\n                    throw\n                        new StunException(\n                                StunException.NETWORK_ERROR,\n                                \"Failed to send TURN ChannelData message\",\n                                ioex);\n                }\n            }\n            else\n            {\n                byte[] transactionID\n                    = TransactionID.createNewTransactionID().getBytes();\n                Indication sendIndication\n                    = MessageFactory.createSendIndication(\n                            peerAddress,\n                            data,\n                            transactionID);\n\n                sendIndication.setTransactionID(transactionID);\n                turnCandidateHarvest.harvester.getStunStack().sendIndication(\n                        sendIndication,\n                        turnCandidateHarvest.harvester.stunServer,\n                        turnCandidateHarvest\n                            .hostCandidate.getTransportAddress());\n            }\n        }\n\n        /**\n         * Sets the indicator which determines whether this <tt>Channel</tt> is\n         * bound/installed.\n         *\n         * @param bound <tt>true</tt> if this <tt>Channel</tt> is to be marked\n         * as bound/installed; otherwise, <tt>false</tt>\n         * @param boundTransactionID an array of <tt>byte</tt>s which represents\n         * the ID of the transaction with which the confirmation about the\n         * binding/installing has arrived\n         */\n        public void setBound(boolean bound, byte[] boundTransactionID)\n        {\n            if (bindingTransactionID != null)\n            {\n                bindingTransactionID = null;\n                this.bound = bound;\n            }\n        }\n\n        /**\n         * Sets the indicator which determines whether this <tt>Channel</tt> is\n         * set to prefer sending <tt>DatagramPacket</tt>s using TURN ChannelData\n         * messages instead of Send indications.\n         *\n         * @param channelDataIsPreferred <tt>true</tt> if this <tt>Channel</tt>\n         * is to be set to prefer sending <tt>DatagramPacket</tt>s using TURN\n         * ChannelData messages instead of Send indications\n         */\n        public void setChannelDataIsPreferred(boolean channelDataIsPreferred)\n        {\n            this.channelDataIsPreferred = channelDataIsPreferred;\n        }\n\n        /**\n         * Sets the indicator which determines whether the associated TURN\n         * server has confirmed the allocation of the <tt>channelNumber</tt> of\n         * this <tt>Channel</tt> by us receiving a success <tt>Response</tt> to\n         * our ChannelBind <tt>Request</tt>.\n         *\n         * @param channelNumberIsConfirmed <tt>true</tt> if allocation of the\n         * channel number has been confirmed by a success <tt>Response</tt> to\n         * our ChannelBind <tt>Request</tt>\n         * @param channelNumberIsConfirmedTransactionID an array of\n         * <tt>byte</tt>s which represents the ID of the transaction with which\n         * the confirmation about the allocation of the channel number has\n         * arrived\n         */\n        public void setChannelNumberIsConfirmed(\n                boolean channelNumberIsConfirmed,\n                byte[] channelNumberIsConfirmedTransactionID)\n        {\n            this.channelNumberIsConfirmed = channelNumberIsConfirmed;\n        }\n    }\n}", "super_interfaces": ["MessageEventHandler"], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(RelayedCandidateDatagramSocket.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>RelayedCandidateDatagramSocket</tt>\nclass and its instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(RelayedCandidateDatagramSocket.class.getName())", "syntax_pass": true}, {"attribute_expression": "private static final char CHANNEL_NUMBER_NOT_SPECIFIED = 0;", "docstring": "\nThe constant which represents a channel number value signaling that no\nchannel number has been explicitly specified.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "CHANNEL_NUMBER_NOT_SPECIFIED = 0", "syntax_pass": true}, {"attribute_expression": "private static final int CHANNELDATA_CHANNELNUMBER_LENGTH = 2;", "docstring": "\nThe length in bytes of the Channel Number field of a TURN ChannelData\nmessage.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "CHANNELDATA_CHANNELNUMBER_LENGTH = 2", "syntax_pass": true}, {"attribute_expression": "private static final int CHANNELDATA_LENGTH_LENGTH = 2;", "docstring": "\nThe length in bytes of the Length field of a TURN ChannelData message.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "CHANNELDATA_LENGTH_LENGTH = 2", "syntax_pass": true}, {"attribute_expression": "private static final char MAX_CHANNEL_NUMBER = 0x7FFF;", "docstring": "\nThe maximum channel number which is valid for TURN ChannelBind\n<tt>Request</tt>.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "MAX_CHANNEL_NUMBER = 0x7FFF", "syntax_pass": true}, {"attribute_expression": "private static final char MIN_CHANNEL_NUMBER = 0x4000;", "docstring": "\nThe minimum channel number which is valid for TURN ChannelBind\n<tt>Request</tt>s.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "MIN_CHANNEL_NUMBER = 0x4000", "syntax_pass": true}, {"attribute_expression": "private static final long PERMISSION_LIFETIME = 300 /* seconds */ * 1000L;", "docstring": "\nThe lifetime in milliseconds of a TURN permission created using a\nCreatePermission request.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "PERMISSION_LIFETIME = 300 /* seconds */ * 1000L", "syntax_pass": true}, {"attribute_expression": "private static final long PERMISSION_LIFETIME_LEEWAY\n        = 60 /* seconds */ * 1000L;", "docstring": "\nThe time in milliseconds before a TURN permission expires that a\n<tt>RelayedCandidateDatagramSocket</tt> is to try to reinstall it.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "PERMISSION_LIFETIME_LEEWAY\n        = 60 /* seconds */ * 1000L", "syntax_pass": true}, {"attribute_expression": "private final DatagramSocket channelDataSocket;", "docstring": "\nThe <tt>DatagramSocket</tt> through which this\n<tt>RelayedCandidateDatagramSocket</tt> actually sends and receives the\ndata it has been asked to {@link #send(DatagramPacket)} and\n{@link #receive(DatagramPacket)}. Since data can be exchanged with a TURN\nserver using STUN messages (i.e. Send and Data indications),\n<tt>RelayedCandidateDatagramSocket</tt> may send and receive data using\nthe associated <tt>StunStack</tt> and not <tt>channelDataSocket</tt>.\nHowever, using <tt>channelDataSocket</tt> is supposed to be more\nefficient than using <tt>StunStack</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DatagramSocket", "name": "channelDataSocket", "syntax_pass": true}, {"attribute_expression": "private final List<Channel> channels = new LinkedList<>();", "docstring": "\nThe list of per-peer <tt>Channel</tt>s through which this\n<tt>RelayedCandidateDatagramSocket</tt>s relays data send to it to\npeer <tt>TransportAddress</tt>es.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Channel>", "name": "channels = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private boolean closed = false;", "docstring": "\nThe indicator which determines whether this instance has started\nexecuting or has executed its {@link #close()} method.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "closed = false", "syntax_pass": true}, {"attribute_expression": "private static final DatagramPacketFilter connectivityCheckRecognizer\n        = new StunDatagramPacketFilter();", "docstring": "\nThe <tt>DatagramPacketFilter</tt> which is able to determine whether a\nspecific <tt>DatagramPacket</tt> sent through a\n<tt>RelayedCandidateDatagramSocket</tt> is part of the ICE connectivity\nchecks. The recognizing is necessary because RFC 5245 says that \"it is\nRECOMMENDED that the agent defer creation of a TURN channel until ICE\ncompletes.\"\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "DatagramPacketFilter", "name": "connectivityCheckRecognizer\n        = new StunDatagramPacketFilter()", "syntax_pass": true}, {"attribute_expression": "private char nextChannelNumber = MIN_CHANNEL_NUMBER;", "docstring": "\nThe next free channel number to be returned by\n{@link #getNextChannelNumber()} and marked as non-free.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "char", "name": "nextChannelNumber = MIN_CHANNEL_NUMBER", "syntax_pass": true}, {"attribute_expression": "private final List<DatagramPacket> packetsToReceive = new LinkedList<>();", "docstring": "\nThe <tt>DatagramPacket</tt>s which are to be received through this\n<tt>DatagramSocket</tt> upon calls to its\n{@link #receive(DatagramPacket)} method. They have been received from the\nTURN server in the form of Data indications.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<DatagramPacket>", "name": "packetsToReceive = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private final List<DatagramPacket> packetsToSend = new LinkedList<>();", "docstring": "\nThe <tt>DatagramSocket</tt>s which have been sent through this\n<tt>DatagramSocket</tt> using its {@link #send(DatagramPacket)} method\nand which are to be relayed through its associated TURN server in the\nform of Send indications.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<DatagramPacket>", "name": "packetsToSend = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private Thread receiveChannelDataThread;", "docstring": "\nThe <tt>Thread</tt> which receives <tt>DatagramPacket</tt>s from\n{@link #channelDataSocket} and queues them in {@link #packetsToReceive}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Thread", "name": "receiveChannelDataThread", "syntax_pass": true}, {"attribute_expression": "private final RelayedCandidate relayedCandidate;", "docstring": "\nThe <tt>RelayedCandidate</tt> which uses this instance as the value of\nits <tt>socket</tt> property.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RelayedCandidate", "name": "relayedCandidate", "syntax_pass": true}, {"attribute_expression": "private Thread sendThread;", "docstring": "\nThe <tt>Thread</tt> which is to send the {@link #packetsToSend} to the\nassociated TURN server.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Thread", "name": "sendThread", "syntax_pass": true}, {"attribute_expression": "private final TurnCandidateHarvest turnCandidateHarvest;", "docstring": "\nThe <tt>TurnCandidateHarvest</tt> which has harvested\n{@link #relayedCandidate}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TurnCandidateHarvest", "name": "turnCandidateHarvest", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket", "name": "DelegatingServerSocket", "file_path": "src/main/java/org/ice4j/socket/DelegatingServerSocket.java", "superclasses": "ServerSocket", "methods": ["[]DelegatingServerSocket(ServerSocket)", "[]DelegatingServerSocket(ServerSocket,ServerSocketChannel)", "[Socket]accept()", "[void]bind(SocketAddress)", "[void]bind(SocketAddress,int)", "[void]close()", "[ServerSocketChannel]getChannel()", "[InetAddress]getInetAddress()", "[int]getLocalPort()", "[SocketAddress]getLocalSocketAddress()", "[int]getReceiveBufferSize()", "[boolean]getReuseAddress()", "[int]getSoTimeout()", "[boolean]isBound()", "[boolean]isClosed()", "[void]setPerformancePreferences(int,int,int)", "[void]setReceiveBufferSize(int)", "[void]setReuseAddress(boolean)", "[void]setSoTimeout(int)", "[String]toString()"], "method_uris": ["src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[]DelegatingServerSocket(ServerSocket)", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[]DelegatingServerSocket(ServerSocket,ServerSocketChannel)", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[Socket]accept()", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[void]bind(SocketAddress)", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[void]bind(SocketAddress,int)", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[void]close()", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[ServerSocketChannel]getChannel()", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[InetAddress]getInetAddress()", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[int]getLocalPort()", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[SocketAddress]getLocalSocketAddress()", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[int]getReceiveBufferSize()", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[boolean]getReuseAddress()", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[int]getSoTimeout()", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[boolean]isBound()", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[boolean]isClosed()", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[void]setPerformancePreferences(int,int,int)", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[void]setReceiveBufferSize(int)", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[void]setReuseAddress(boolean)", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[void]setSoTimeout(int)", "src/main/java/org/ice4j/socket/DelegatingServerSocket.java.DelegatingServerSocket.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a {@code ServerSocket} which delegates (its method calls) to\nanother {@code ServerSocket}. In other words, the former wraps the latter.\n\n@author Lyubomir Marinov\n", "original_string": "public class DelegatingServerSocket\n    extends ServerSocket\n{\n    /**\n     * The {@link ServerSocketChannel} of this instance. If {@code null}, the\n     * one of the {@link #delegate} is used.\n     */\n    protected final ServerSocketChannel channel;\n\n    /**\n     * The {@link ServerSocket} this instance delegates (its method calls) to.\n     */\n    protected final ServerSocket delegate;\n\n    /**\n     * Initializes a new {@code DelegatingServerSocket} instance which is to\n     * delegate (its method calls) to a specific {@link ServerSocket}.\n     *\n     * @param delegate the {@code ServerSocket} the new instance is to delegate\n     * (it method calls) to\n     * @throws IOException never thrown\n     */\n    public DelegatingServerSocket(ServerSocket delegate)\n        throws IOException\n    {\n        this(delegate, delegate.getChannel());\n    }\n\n    /**\n     * Initializes a new {@code DelegatingServerSocket} instance which is to\n     * delegate (its method calls) to a specific {@link ServerSocket} and is to\n     * report a specific {@link ServerSocketChannel}.\n     *\n     * @param delegate the {@code ServerSocket} the new instance is to delegate\n     * (it method calls) to\n     * @param channel the {@code ServerSocketChannel} to be reported by the new\n     * instance or {@code null} to report the one of {@code delegate}\n     * @throws IOException never thrown\n     */\n    public DelegatingServerSocket(\n            ServerSocket delegate,\n            ServerSocketChannel channel)\n        throws IOException\n    {\n        this.delegate = delegate;\n        this.channel = channel;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public Socket accept()\n        throws IOException\n    {\n        return delegate.accept();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public void bind(SocketAddress endpoint)\n        throws IOException\n    {\n        delegate.bind(endpoint);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public void bind(SocketAddress endpoint, int backlog)\n        throws IOException\n    {\n        delegate.bind(endpoint, backlog);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public void close()\n        throws IOException\n    {\n        delegate.close();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * If {@link #channel} is not {@code null}, returns it. Otherwise, forwards\n     * to {@link #delegate}.\n     */\n    @Override\n    public ServerSocketChannel getChannel()\n    {\n        ServerSocketChannel channel = this.channel;\n\n        return (channel == null) ? delegate.getChannel() : channel;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public InetAddress getInetAddress()\n    {\n        return delegate.getInetAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public int getLocalPort()\n    {\n        return delegate.getLocalPort();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public SocketAddress getLocalSocketAddress()\n    {\n        return delegate.getLocalSocketAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public int getReceiveBufferSize()\n        throws SocketException\n    {\n        return delegate.getReceiveBufferSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public boolean getReuseAddress()\n        throws SocketException\n    {\n        return delegate.getReuseAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public int getSoTimeout()\n        throws IOException\n    {\n        return delegate.getSoTimeout();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public boolean isBound()\n    {\n        return delegate.isBound();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public boolean isClosed()\n    {\n        return delegate.isClosed();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public void setPerformancePreferences(int connectionTime,\n                                          int latency,\n                                          int bandwidth)\n    {\n        delegate.setPerformancePreferences(connectionTime, latency, bandwidth);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public void setReceiveBufferSize(int size)\n        throws SocketException\n    {\n        delegate.setReceiveBufferSize(size);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public void setReuseAddress(boolean on)\n        throws SocketException\n    {\n        delegate.setReuseAddress(on);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public void setSoTimeout(int timeout)\n        throws SocketException\n    {\n        delegate.setSoTimeout(timeout);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public String toString()\n    {\n        return delegate.toString();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected final ServerSocketChannel channel;", "docstring": "\nThe {@link ServerSocketChannel} of this instance. If {@code null}, the\none of the {@link #delegate} is used.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "ServerSocketChannel", "name": "channel", "syntax_pass": true}, {"attribute_expression": "protected final ServerSocket delegate;", "docstring": "\nThe {@link ServerSocket} this instance delegates (its method calls) to.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "ServerSocket", "name": "delegate", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket", "name": "MultiplexingDatagramSocket", "file_path": "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java", "superclasses": "SafeCloseDatagramSocket", "methods": ["[]MultiplexingDatagramSocket()", "[]MultiplexingDatagramSocket(boolean)", "[]MultiplexingDatagramSocket(DatagramSocket)", "[]MultiplexingDatagramSocket(DatagramSocket,boolean)", "[]MultiplexingDatagramSocket(int)", "[]MultiplexingDatagramSocket(int,boolean)", "[]MultiplexingDatagramSocket(int,InetAddress)", "[]MultiplexingDatagramSocket(int,InetAddress,boolean)", "[]MultiplexingDatagramSocket(SocketAddress)", "[]MultiplexingDatagramSocket(SocketAddress,boolean)", "[void]close(MultiplexedDatagramSocket)", "[MultiplexedDatagramSocket]getSocket(DatagramPacketFilter)", "[MultiplexedDatagramSocket]getSocket(DatagramPacketFilter,boolean)", "[int]getSoTimeout()", "[void]multiplexingXXXSocketSupportDoReceive(DatagramPacket)", "[void]multiplexingXXXSocketSupportDoSetReceiveBufferSize(int)", "[void]receive(DatagramPacket)", "[void]receive(MultiplexedDatagramSocket,DatagramPacket)", "[void]setReceiveBufferSize(int)", "[void]setSoTimeout(int)"], "method_uris": ["src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket()", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(boolean)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(DatagramSocket)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(DatagramSocket,boolean)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(int)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(int,boolean)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(int,InetAddress)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(int,InetAddress,boolean)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(SocketAddress)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[]MultiplexingDatagramSocket(SocketAddress,boolean)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[void]close(MultiplexedDatagramSocket)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[MultiplexedDatagramSocket]getSocket(DatagramPacketFilter)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[MultiplexedDatagramSocket]getSocket(DatagramPacketFilter,boolean)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[int]getSoTimeout()", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[void]multiplexingXXXSocketSupportDoReceive(DatagramPacket)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[void]multiplexingXXXSocketSupportDoSetReceiveBufferSize(int)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[void]receive(DatagramPacket)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[void]receive(MultiplexedDatagramSocket,DatagramPacket)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[void]setReceiveBufferSize(int)", "src/main/java/org/ice4j/socket/MultiplexingDatagramSocket.java.MultiplexingDatagramSocket.[void]setSoTimeout(int)"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents a <tt>DatagramSocket</tt> which allows filtering\n<tt>DatagramPacket</tt>s it reads from the network using\n<tt>DatagramPacketFilter</tt>s so that the <tt>DatagramPacket</tt>s do not\nget received through it but through associated\n<tt>MultiplexedDatagramSocket</tt>s.\n\n@author Lyubomir Marinov\n", "original_string": "public class MultiplexingDatagramSocket\n    extends SafeCloseDatagramSocket\n{\n    /**\n     * The {@code MultiplexingXXXSocketSupport} which implements functionality\n     * common to TCP and UDP sockets in order to facilitate implementers such as\n     * this instance.\n     */\n    private final MultiplexingXXXSocketSupport<MultiplexedDatagramSocket>\n        multiplexingXXXSocketSupport\n            = new MultiplexingXXXSocketSupport<MultiplexedDatagramSocket>()\n            {\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected MultiplexedDatagramSocket createSocket(\n                        DatagramPacketFilter filter)\n                    throws SocketException\n                {\n                    return\n                        new MultiplexedDatagramSocket(\n                                MultiplexingDatagramSocket.this,\n                                filter);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected void doReceive(DatagramPacket p)\n                    throws IOException\n                {\n                    multiplexingXXXSocketSupportDoReceive(p);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected void doSetReceiveBufferSize(int receiveBufferSize)\n                    throws SocketException\n                {\n                    multiplexingXXXSocketSupportDoSetReceiveBufferSize(\n                            receiveBufferSize);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected SocketReceiveBuffer getReceived()\n                {\n                    return received;\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected SocketReceiveBuffer getReceived(\n                        MultiplexedDatagramSocket socket)\n                {\n                    return socket.received;\n                }\n            };\n\n    /**\n     * The list of <tt>DatagramPacket</tt>s to be received through this\n     * <tt>DatagramSocket</tt> i.e. not accepted by the list of\n     * {@link MultiplexedDatagramSocket} of this instance at the time of the\n     * reading from the network.\n     */\n    private final SocketReceiveBuffer received\n        = new SocketReceiveBuffer(this::getReceiveBufferSize);\n\n    /**\n     * Buffer variable for storing the SO_TIMEOUT value set by the\n     * last <tt>setSoTimeout()</tt> call. Although not strictly needed,\n     * getting the locally stored value as opposed to retrieving it\n     * from a parent <tt>getSoTimeout()</tt> call seems to\n     * significantly improve efficiency, at least on some platforms.\n     */\n    private int soTimeout = 0;\n\n    /**\n     * Whether this socket should be kept open even when all of its\n     * {@link MultiplexedDatagramSocket} are closed (if the value is\n     * {@code true}), or it should be closed when the last of its\n     * {@link MultiplexedDatagramSocket} is closed (if the value is\n     * {@code false}).\n     */\n    private final boolean persistent;\n\n    /**\n     * Initializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\n     * to enable <tt>DatagramPacket</tt> filtering and binds it to any available\n     * port on the local host machine. The socket will be bound to the wildcard\n     * address, an IP address chosen by the kernel.\n     *\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     * @see DatagramSocket#DatagramSocket()\n     */\n    public MultiplexingDatagramSocket()\n        throws SocketException\n    {\n        this(false);\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\n     * to enable <tt>DatagramPacket</tt> filtering and binds it to any available\n     * port on the local host machine. The socket will be bound to the wildcard\n     * address, an IP address chosen by the kernel.\n     *\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     * @param persistent whether this socket should be kept open after all of\n     * its {@link MultiplexedDatagramSocket}s are closed.\n     * @see DatagramSocket#DatagramSocket()\n     */\n    public MultiplexingDatagramSocket(boolean persistent)\n        throws SocketException\n    {\n        this.persistent = persistent;\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\n     * to enable <tt>DatagramPacket</tt> filtering on a specific\n     * <tt>DatagramSocket</tt>.\n     *\n     * @param delegate the <tt>DatagramSocket</tt> on which\n     * <tt>DatagramPacket</tt> filtering is to be enabled by the new instance\n     * @throws SocketException if anything goes wrong while initializing the new\n     * instance\n     */\n    public MultiplexingDatagramSocket(DatagramSocket delegate)\n        throws SocketException\n    {\n        this(delegate, false);\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\n     * to enable <tt>DatagramPacket</tt> filtering on a specific\n     * <tt>DatagramSocket</tt>.\n     *\n     * @param delegate the <tt>DatagramSocket</tt> on which\n     * <tt>DatagramPacket</tt> filtering is to be enabled by the new instance\n     * @param persistent whether this socket should be kept open after all of\n     * its {@link MultiplexedDatagramSocket}s are closed.\n     * @throws SocketException if anything goes wrong while initializing the new\n     * instance\n     */\n    public MultiplexingDatagramSocket(\n            DatagramSocket delegate,\n            boolean persistent)\n        throws SocketException\n    {\n        super(delegate);\n\n        this.persistent = persistent;\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\n     * to enable <tt>DatagramPacket</tt> filtering and binds it to the specified\n     * port on the local host machine. The socket will be bound to the wildcard\n     * address, an IP address chosen by the kernel.\n     *\n     * @param port the port to bind the new socket to\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     * @see DatagramSocket#DatagramSocket(int)\n     */\n    public MultiplexingDatagramSocket(int port)\n        throws SocketException\n    {\n        this(port, false);\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\n     * to enable <tt>DatagramPacket</tt> filtering and binds it to the specified\n     * port on the local host machine. The socket will be bound to the wildcard\n     * address, an IP address chosen by the kernel.\n     *\n     * @param port the port to bind the new socket to\n     * @param persistent whether this socket should be kept open after all of\n     * its {@link MultiplexedDatagramSocket}s are closed.\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     * @see DatagramSocket#DatagramSocket(int)\n     */\n    public MultiplexingDatagramSocket(int port, boolean persistent)\n        throws SocketException\n    {\n        super(port);\n\n        this.persistent = persistent;\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\n     * to enable <tt>DatagramPacket</tt> filtering, bound to the specified local\n     * address. The local port must be between 0 and 65535 inclusive. If the IP\n     * address is 0.0.0.0, the socket will be bound to the wildcard address, an\n     * IP address chosen by the kernel.\n     *\n     * @param port the local port to bind the new socket to\n     * @param laddr the local address to bind the new socket to\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     * @see DatagramSocket#DatagramSocket(int, InetAddress)\n     */\n    public MultiplexingDatagramSocket(int port, InetAddress laddr)\n        throws SocketException\n    {\n        this(port, laddr, false);\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\n     * to enable <tt>DatagramPacket</tt> filtering, bound to the specified local\n     * address. The local port must be between 0 and 65535 inclusive. If the IP\n     * address is 0.0.0.0, the socket will be bound to the wildcard address, an\n     * IP address chosen by the kernel.\n     *\n     * @param port the local port to bind the new socket to\n     * @param laddr the local address to bind the new socket to\n     * @param persistent whether this socket should be kept open after all of\n     * its {@link MultiplexedDatagramSocket}s are closed.\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     * @see DatagramSocket#DatagramSocket(int, InetAddress)\n     */\n    public MultiplexingDatagramSocket(\n            int port,\n            InetAddress laddr,\n            boolean persistent)\n        throws SocketException\n    {\n        super(port, laddr);\n\n        this.persistent = persistent;\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\n     * to enable <tt>DatagramPacket</tt> filtering, bound to the specified local\n     * socket address.\n     * <p>\n     * If the specified local socket address is <tt>null</tt>, creates an\n     * unbound socket.\n     * </p>\n     *\n     * @param bindaddr local socket address to bind, or <tt>null</tt> for an\n     * unbound socket\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     * @see DatagramSocket#DatagramSocket(SocketAddress)\n     */\n    public MultiplexingDatagramSocket(SocketAddress bindaddr)\n        throws SocketException\n    {\n        this(bindaddr, false);\n    }\n\n    /**\n     * Initializes a new <tt>MultiplexingDatagramSocket</tt> instance which is\n     * to enable <tt>DatagramPacket</tt> filtering, bound to the specified local\n     * socket address.\n     * <p>\n     * If the specified local socket address is <tt>null</tt>, creates an\n     * unbound socket.\n     * </p>\n     *\n     * @param bindaddr local socket address to bind, or <tt>null</tt> for an\n     * unbound socket\n     * @param persistent whether this socket should be kept open after all of\n     * its {@link MultiplexedDatagramSocket}s are closed.\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     * @see DatagramSocket#DatagramSocket(SocketAddress)\n     */\n    public MultiplexingDatagramSocket(\n                SocketAddress bindaddr,\n                boolean persistent)\n        throws SocketException\n    {\n        super(bindaddr);\n\n        this.persistent = persistent;\n    }\n\n    /**\n     * Closes a specific <tt>MultiplexedDatagramSocket</tt> which filters\n     * <tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt>.\n     *\n     * @param multiplexed the <tt>MultiplexedDatagramSocket</tt> to close\n     */\n    void close(MultiplexedDatagramSocket multiplexed)\n    {\n        if (!multiplexingXXXSocketSupport.close(multiplexed)\n            && !persistent)\n        {\n            close();\n        }\n    }\n\n    /**\n     * Gets a <tt>MultiplexedDatagramSocket</tt> which filters\n     * <tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using a\n     * specific <tt>DatagramPacketFilter</tt>. If such a\n     * <tt>MultiplexedDatagramSocket</tt> does not exist in this instance, it is\n     * created.\n     *\n     * @param filter the <tt>DatagramPacketFilter</tt> to get a\n     * <tt>MultiplexedDatagramSocket</tt> for\n     * @return a <tt>MultiplexedDatagramSocket</tt> which filters\n     * <tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using the\n     * specified <tt>filter</tt>\n     * @throws SocketException if creating the\n     * <tt>MultiplexedDatagramSocket</tt> for the specified <tt>filter</tt>\n     * fails\n     */\n    public MultiplexedDatagramSocket getSocket(DatagramPacketFilter filter)\n        throws SocketException\n    {\n        return getSocket(filter, /* create */ true);\n    }\n\n    /**\n     * Gets a <tt>MultiplexedDatagramSocket</tt> which filters\n     * <tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using a\n     * specific <tt>DatagramPacketFilter</tt>. If <tt>create</tt> is true and\n     * such a <tt>MultiplexedDatagramSocket</tt> does not exist in this\n     * instance, it is created.\n     *\n     * @param filter the <tt>DatagramPacketFilter</tt> to get a\n     * <tt>MultiplexedDatagramSocket</tt> for\n     * @param create whether or not to create a\n     * <tt>MultiplexedDatagramSocket</tt> if this instance does not already have\n     * a socket for the given <tt>filter</tt>.\n     * @return a <tt>MultiplexedDatagramSocket</tt> which filters\n     * <tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using the\n     * specified <tt>filter</tt>\n     * @throws SocketException if creating the\n     * <tt>MultiplexedDatagramSocket</tt> for the specified <tt>filter</tt>\n     * fails.\n     */\n    public MultiplexedDatagramSocket getSocket(\n            DatagramPacketFilter filter,\n            boolean create)\n        throws SocketException\n    {\n        return multiplexingXXXSocketSupport.getSocket(filter, create);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getSoTimeout()\n    {\n        return soTimeout;\n    }\n\n    /**\n     * Implements {@link MultiplexingXXXSocketSupport#doReceive(DatagramPacket)}\n     * on behalf of {@link #multiplexingXXXSocketSupport}. Receives a\n     * {@code DatagramPacket} from this socket.\n     *\n     * @param p the {@code DatagramPacket} into which to place the incoming data\n     * @throws IOException if an I/O error occurs\n     */\n    private void multiplexingXXXSocketSupportDoReceive(DatagramPacket p)\n        throws IOException\n    {\n        super.receive(p);\n    }\n\n    /**\n     * Implements\n     * {@link MultiplexingXXXSocketSupport#doSetReceiveBufferSize(int)} on\n     * behalf of {@link #multiplexingXXXSocketSupport}. Sets the\n     * {@code SO_RCVBUF} option to the specified value for this\n     * {@code DatagramSocket}. The {@code SO_RCVBUF} option is used by the\n     * network implementation as a hint to size the underlying network I/O\n     * buffers. The {@code SO_RCVBUF} setting may also be used by the network\n     * implementation to determine the maximum size of the packet that can be\n     * received on this socket.\n     *\n     * @param receiveBufferSize the size to which to set the receive buffer size\n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as a UDP error\n     */\n    private void multiplexingXXXSocketSupportDoSetReceiveBufferSize(\n            int receiveBufferSize)\n        throws SocketException\n    {\n        super.setReceiveBufferSize(receiveBufferSize);\n    }\n\n    /**\n     * Receives a datagram packet from this socket. The <tt>DatagramPacket</tt>s\n     * returned by this method do not match any of the\n     * <tt>DatagramPacketFilter</tt>s of the <tt>MultiplexedDatagramSocket</tt>s\n     * associated with this instance at the time of their receipt. When this\n     * method returns, the <tt>DatagramPacket</tt>'s buffer is filled with the\n     * data received. The datagram packet also contains the sender's IP address,\n     * and the port number on the sender's machine.\n     * <p>\n     * This method blocks until a datagram is received. The <tt>length</tt>\n     * field of the datagram packet object contains the length of the received\n     * message. If the message is longer than the packet's length, the message\n     * is truncated.\n     * </p>\n     *\n     * @param p the <tt>DatagramPacket</tt> into which to place the incoming\n     * data\n     * @throws IOException if an I/O error occurs\n     * @throws SocketTimeoutException if <tt>setSoTimeout(int)</tt> was\n     * previously called and the timeout has expired\n     * @see DatagramSocket#receive(DatagramPacket)\n     */\n    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        multiplexingXXXSocketSupport.receive(received, p, soTimeout);\n    }\n\n    /**\n     * Receives a <tt>DatagramPacket</tt> from this <tt>DatagramSocket</tt> upon\n     * request from a specific <tt>MultiplexedDatagramSocket</tt>.\n     *\n     * @param multiplexed the <tt>MultiplexedDatagramSocket</tt> which requests\n     * the receipt of a <tt>DatagramPacket</tt> from the network\n     * @param p the <tt>DatagramPacket</tt> to receive the data from the network\n     * @throws IOException if an I/O error occurs\n     * @throws SocketTimeoutException if <tt>setSoTimeout(int)</tt> was\n     * previously called on <tt>multiplexed</tt> and the timeout has expired\n     */\n    void receive(MultiplexedDatagramSocket multiplexed, DatagramPacket p)\n        throws IOException\n    {\n        multiplexingXXXSocketSupport.receive(\n                multiplexed.received,\n                p,\n                multiplexed.getSoTimeout());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setReceiveBufferSize(int receiveBufferSize)\n        throws SocketException\n    {\n        multiplexingXXXSocketSupport.setReceiveBufferSize(receiveBufferSize);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setSoTimeout(int timeout)\n        throws SocketException\n    {\n        super.setSoTimeout(timeout);\n\n        soTimeout = timeout;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final MultiplexingXXXSocketSupport<MultiplexedDatagramSocket>\n        multiplexingXXXSocketSupport\n            = new MultiplexingXXXSocketSupport<MultiplexedDatagramSocket>()\n            {\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected MultiplexedDatagramSocket createSocket(\n                        DatagramPacketFilter filter)\n                    throws SocketException\n                {\n                    return\n                        new MultiplexedDatagramSocket(\n                                MultiplexingDatagramSocket.this,\n                                filter);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected void doReceive(DatagramPacket p)\n                    throws IOException\n                {\n                    multiplexingXXXSocketSupportDoReceive(p);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected void doSetReceiveBufferSize(int receiveBufferSize)\n                    throws SocketException\n                {\n                    multiplexingXXXSocketSupportDoSetReceiveBufferSize(\n                            receiveBufferSize);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected SocketReceiveBuffer getReceived()\n                {\n                    return received;\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected SocketReceiveBuffer getReceived(\n                        MultiplexedDatagramSocket socket)\n                {\n                    return socket.received;\n                }\n            };", "docstring": "\nThe {@code MultiplexingXXXSocketSupport} which implements functionality\ncommon to TCP and UDP sockets in order to facilitate implementers such as\nthis instance.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "MultiplexingXXXSocketSupport<MultiplexedDatagramSocket>", "name": "multiplexingXXXSocketSupport\n            = new MultiplexingXXXSocketSupport<MultiplexedDatagramSocket>()\n            {\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected MultiplexedDatagramSocket createSocket(\n                        DatagramPacketFilter filter)\n                    throws SocketException\n                {\n                    return\n                        new MultiplexedDatagramSocket(\n                                MultiplexingDatagramSocket.this,\n                                filter);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected void doReceive(DatagramPacket p)\n                    throws IOException\n                {\n                    multiplexingXXXSocketSupportDoReceive(p);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected void doSetReceiveBufferSize(int receiveBufferSize)\n                    throws SocketException\n                {\n                    multiplexingXXXSocketSupportDoSetReceiveBufferSize(\n                            receiveBufferSize);\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected SocketReceiveBuffer getReceived()\n                {\n                    return received;\n                }\n\n                /**\n                 * {@inheritDoc}\n                 */\n                @Override\n                protected SocketReceiveBuffer getReceived(\n                        MultiplexedDatagramSocket socket)\n                {\n                    return socket.received;\n                }\n            }", "syntax_pass": true}, {"attribute_expression": "private final SocketReceiveBuffer received\n        = new SocketReceiveBuffer(this::getReceiveBufferSize);", "docstring": "\nThe list of <tt>DatagramPacket</tt>s to be received through this\n<tt>DatagramSocket</tt> i.e. not accepted by the list of\n{@link MultiplexedDatagramSocket} of this instance at the time of the\nreading from the network.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "SocketReceiveBuffer", "name": "received\n        = new SocketReceiveBuffer(this::getReceiveBufferSize)", "syntax_pass": true}, {"attribute_expression": "private int soTimeout = 0;", "docstring": "\nBuffer variable for storing the SO_TIMEOUT value set by the\nlast <tt>setSoTimeout()</tt> call. Although not strictly needed,\ngetting the locally stored value as opposed to retrieving it\nfrom a parent <tt>getSoTimeout()</tt> call seems to\nsignificantly improve efficiency, at least on some platforms.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "soTimeout = 0", "syntax_pass": true}, {"attribute_expression": "private final boolean persistent;", "docstring": "\nWhether this socket should be kept open even when all of its\n{@link MultiplexedDatagramSocket} are closed (if the value is\n{@code true}), or it should be closed when the last of its\n{@link MultiplexedDatagramSocket} is closed (if the value is\n{@code false}).\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "persistent", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket", "name": "GoogleRelayedCandidateDatagramSocket", "file_path": "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java", "superclasses": "DatagramSocket", "methods": ["[]GoogleRelayedCandidateDatagramSocket(GoogleRelayedCandidate,GoogleTurnCandidateHarvest,String)", "[void]close()", "[InetAddress]getLocalAddress()", "[int]getLocalPort()", "[InetSocketAddress]getLocalSocketAddress()", "[GoogleRelayedCandidate]getRelayedCandidate()", "[void]processSuccess(Response,Request)", "[void]processResponse(StunResponseEvent)", "[void]receive(DatagramPacket)", "[void]send(DatagramPacket)"], "method_uris": ["src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[]GoogleRelayedCandidateDatagramSocket(GoogleRelayedCandidate,GoogleTurnCandidateHarvest,String)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[void]close()", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[InetAddress]getLocalAddress()", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[int]getLocalPort()", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[InetSocketAddress]getLocalSocketAddress()", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[GoogleRelayedCandidate]getRelayedCandidate()", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[void]processSuccess(Response,Request)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[void]processResponse(StunResponseEvent)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[void]receive(DatagramPacket)", "src/main/java/org/ice4j/socket/GoogleRelayedCandidateDatagramSocket.java.GoogleRelayedCandidateDatagramSocket.[void]send(DatagramPacket)"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents an application-purposed (as opposed to an ICE-specific)\n<tt>DatagramSocket</tt> for a <tt>RelayedCandidate</tt> harvested by a\n<tt>TurnCandidateHarvest</tt> (and its associated\n<tt>TurnCandidateHarvester</tt>, of course).\n<tt>GoogleRelayedCandidateDatagramSocket</tt> is associated with a successful\nAllocation on a TURN server and implements sends and receives through it\nusing TURN messages to and from that TURN server.\n\n@author Lyubomir Marinov\n@author Sebastien Vincent\n", "original_string": "public class GoogleRelayedCandidateDatagramSocket\n    extends DatagramSocket\n{\n    /**\n     * The <tt>Logger</tt> used by the\n     * <tt>GoogleRelayedCandidateDatagramSocket</tt> class and its instances for\n     * logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(\n                GoogleRelayedCandidateDatagramSocket.class.getName());\n\n    /**\n     * The indicator which determines whether this instance has started\n     * executing or has executed its {@link #close()} method.\n     */\n    private boolean closed = false;\n\n    /**\n     * The <tt>GoogleRelayedCandidate</tt> which uses this instance as the value\n     * of its <tt>socket</tt> property.\n     */\n    private final GoogleRelayedCandidate relayedCandidate;\n\n    /**\n     * The <tt>GoogleTurnCandidateHarvest</tt> which has harvested\n     * {@link #relayedCandidate}.\n     */\n    private final GoogleTurnCandidateHarvest turnCandidateHarvest;\n\n    /**\n     * The <tt>GoogleTurnCandidateDelegage</tt> which will handle send/receive\n     * operations.\n     */\n    private final GoogleRelayedCandidateDelegate socketDelegate;\n\n    /**\n     * Initializes a new <tt>GoogleRelayedCandidateDatagramSocket</tt> instance\n     * which is to be the <tt>socket</tt> of a specific\n     * <tt>RelayedCandidate</tt> harvested by a specific\n     * <tt>TurnCandidateHarvest</tt>.\n     *\n     * @param relayedCandidate the <tt>RelayedCandidate</tt> which is to use the\n     * new instance as the value of its <tt>socket</tt> property\n     * @param turnCandidateHarvest the <tt>TurnCandidateHarvest</tt> which has\n     * harvested <tt>relayedCandidate</tt>\n     * @param username username\n     * @throws SocketException if anything goes wrong while initializing the new\n     * <tt>GoogleRelayedCandidateDatagramSocket</tt> instance\n     */\n    public GoogleRelayedCandidateDatagramSocket(\n            GoogleRelayedCandidate relayedCandidate,\n            GoogleTurnCandidateHarvest turnCandidateHarvest,\n            String username)\n        throws SocketException\n    {\n        super(/* bindaddr */ (SocketAddress) null);\n\n        socketDelegate = new GoogleRelayedCandidateDelegate(\n            turnCandidateHarvest, username);\n        this.relayedCandidate = relayedCandidate;\n        this.turnCandidateHarvest = turnCandidateHarvest;\n\n        logger.finest(\"Create new GoogleRelayedCandidateDatagramSocket\");\n    }\n\n    /**\n     * Closes this datagram socket.\n     *\n     * @see DatagramSocket#close()\n     */\n    @Override\n    public void close()\n    {\n        synchronized (this)\n        {\n            if (this.closed)\n                return;\n            else\n                this.closed = true;\n        }\n\n        socketDelegate.close();\n        turnCandidateHarvest.close(this);\n    }\n\n    /**\n     * Gets the local address to which the socket is bound.\n     * <tt>GoogleRelayedCandidateDatagramSocket</tt> returns the\n     * <tt>address</tt> of its <tt>localSocketAddress</tt>.\n     * <p>\n     * If there is a security manager, its <tt>checkConnect</tt> method is first\n     * called with the host address and <tt>-1</tt> as its arguments to see if\n     * the operation is allowed.\n     * </p>\n     *\n     * @return the local address to which the socket is bound, or an\n     * <tt>InetAddress</tt> representing any local address if either the socket\n     * is not bound, or the security manager <tt>checkConnect</tt> method does\n     * not allow the operation\n     * @see #getLocalSocketAddress()\n     * @see DatagramSocket#getLocalAddress()\n     */\n    @Override\n    public InetAddress getLocalAddress()\n    {\n        return getLocalSocketAddress().getAddress();\n    }\n\n    /**\n     * Returns the port number on the local host to which this socket is bound.\n     * <tt>GoogleRelayedCandidateDatagramSocket</tt> returns the <tt>port</tt>\n     * of its <tt>localSocketAddress</tt>.\n     *\n     * @return the port number on the local host to which this socket is bound\n     * @see #getLocalSocketAddress()\n     * @see DatagramSocket#getLocalPort()\n     */\n    @Override\n    public int getLocalPort()\n    {\n        return getLocalSocketAddress().getPort();\n    }\n\n    /**\n     * Returns the address of the endpoint this socket is bound to, or\n     * <tt>null</tt> if it is not bound yet. Since\n     * <tt>GoogleRelayedCandidateDatagramSocket</tt> represents an\n     * application-purposed <tt>DatagramSocket</tt> relaying data to and from a\n     * TURN server, the <tt>localSocketAddress</tt> is the\n     * <tt>transportAddress</tt> of the respective <tt>RelayedCandidate</tt>.\n     *\n     * @return a <tt>SocketAddress</tt> representing the local endpoint of this\n     * socket, or <tt>null</tt> if it is not bound yet\n     * @see DatagramSocket#getLocalSocketAddress()\n     */\n    @Override\n    public InetSocketAddress getLocalSocketAddress()\n    {\n        return getRelayedCandidate().getTransportAddress();\n    }\n\n    /**\n     * Gets the <tt>RelayedCandidate</tt> which uses this instance as the value\n     * of its <tt>socket</tt> property.\n     *\n     * @return the <tt>RelayedCandidate</tt> which uses this instance as the\n     * value of its <tt>socket</tt> property\n     */\n    public final GoogleRelayedCandidate getRelayedCandidate()\n    {\n        return relayedCandidate;\n    }\n\n    /**\n     * Notifies this <tt>GoogleRelayedCandidateDatagramSocket</tt> that a\n     * specific <tt>Request</tt> it has sent has received a STUN success\n     * <tt>Response</tt>.\n     *\n     * @param response the <tt>Response</tt> which responds to <tt>request</tt>\n     * @param request the <tt>Request</tt> sent by this instance to which\n     * <tt>response</tt> responds\n     */\n    public void processSuccess(Response response, Request request)\n    {\n        socketDelegate.processSuccess(response, request);\n    }\n\n    /**\n     * Dispatch the specified response.\n     *\n     * @param response the response to dispatch.\n     */\n    public void processResponse(StunResponseEvent response)\n    {\n        socketDelegate.processResponse(response);\n    }\n\n    /**\n     * Receives a datagram packet from this socket. When this method returns,\n     * the <tt>DatagramPacket</tt>'s buffer is filled with the data received.\n     * The datagram packet also contains the sender's IP address, and the port\n     * number on the sender's machine.\n     *\n     * @param p the <tt>DatagramPacket</tt> into which to place the incoming\n     * data\n     * @throws IOException if an I/O error occurs\n     * @see DatagramSocket#receive(DatagramPacket)\n     */\n    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        socketDelegate.receive(p);\n    }\n\n    /**\n     * Sends a datagram packet from this socket. The <tt>DatagramPacket</tt>\n     * includes information indicating the data to be sent, its length, the IP\n     * address of the remote host, and the port number on the remote host.\n     *\n     * @param p the <tt>DatagramPacket</tt> to be sent\n     * @throws IOException if an I/O error occurs\n     * @see DatagramSocket#send(DatagramPacket)\n     */\n    @Override\n    public void send(DatagramPacket p)\n        throws IOException\n    {\n        socketDelegate.send(p);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(\n                GoogleRelayedCandidateDatagramSocket.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the\n<tt>GoogleRelayedCandidateDatagramSocket</tt> class and its instances for\nlogging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(\n                GoogleRelayedCandidateDatagramSocket.class.getName())", "syntax_pass": true}, {"attribute_expression": "private boolean closed = false;", "docstring": "\nThe indicator which determines whether this instance has started\nexecuting or has executed its {@link #close()} method.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "closed = false", "syntax_pass": true}, {"attribute_expression": "private final GoogleRelayedCandidate relayedCandidate;", "docstring": "\nThe <tt>GoogleRelayedCandidate</tt> which uses this instance as the value\nof its <tt>socket</tt> property.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "GoogleRelayedCandidate", "name": "relayedCandidate", "syntax_pass": true}, {"attribute_expression": "private final GoogleTurnCandidateHarvest turnCandidateHarvest;", "docstring": "\nThe <tt>GoogleTurnCandidateHarvest</tt> which has harvested\n{@link #relayedCandidate}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "GoogleTurnCandidateHarvest", "name": "turnCandidateHarvest", "syntax_pass": true}, {"attribute_expression": "private final GoogleRelayedCandidateDelegate socketDelegate;", "docstring": "\nThe <tt>GoogleTurnCandidateDelegage</tt> which will handle send/receive\noperations.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "GoogleRelayedCandidateDelegate", "name": "socketDelegate", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream", "name": "TCPInputStream", "file_path": "src/main/java/org/ice4j/socket/TCPInputStream.java", "superclasses": "InputStream", "methods": ["[]TCPInputStream(MultiplexingSocket)", "[void]close()", "[int]read()", "[int]read(byte[],int,int)", "[int]read0(byte[],int,int)", "[long]skip(long)", "[void]waitWhileInRead()"], "method_uris": ["src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream.[]TCPInputStream(MultiplexingSocket)", "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream.[void]close()", "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream.[int]read()", "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream.[int]read(byte[],int,int)", "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream.[int]read0(byte[],int,int)", "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream.[long]skip(long)", "src/main/java/org/ice4j/socket/TCPInputStream.java.TCPInputStream.[void]waitWhileInRead()"], "overrides": null, "attributes": [], "class_docstring": "\nTCP input stream for TCP socket. It is used to multiplex sockets and keep the\n<tt>InputStream</tt> interface to users.\n\n@author Sebastien Vincent\n@author Lyubomir Marinov\n", "original_string": "public class TCPInputStream\n    extends InputStream\n{\n    /**\n     * The default size of the receive buffer of <tt>TCPInputStream</tt> if the\n     * associated <tt>MultiplexingSocket</tt> does not specify a value.\n     */\n    private static final int DEFAULT_RECEIVE_BUFFER_SIZE = 65536;\n\n    /**\n     * The <tt>byte</tt> array with one element which is used by the\n     * implementation of {@link #read()} in order to delegate to the\n     * implementation of {@link #read(byte[], int, int)} for the purposes of\n     * simplicity.\n     */\n    private final byte[] b = new byte[1];\n\n    /**\n     * The indicator which determines whether this <tt>TCPInputStream</tt> is\n     * executing one of its <tt>read</tt> method implementations.\n     */\n    private boolean inRead;\n\n    /**\n     * Current packet being processed if any.\n     */\n    private DatagramPacket packet;\n\n    /**\n     * The <tt>data</tt> of {@link #packet}.\n     */\n    private byte[] packetData;\n\n    /**\n     * Current packet length.\n     */\n    private int packetLength;\n\n    /**\n     * Current offset.\n     */\n    private int packetOffset;\n\n    /**\n     * The <tt>Object</tt> which synchronizes the access to the read-related\n     * state of this instance.\n     */\n    private final Object readSyncRoot = new Object();\n\n    /**\n     * The <tt>MultiplexingSocket</tt> which has initialized this instance and\n     * is using it as its <tt>inputStream</tt>.\n     */\n    private final MultiplexingSocket socket;\n\n    /**\n     * Initializes a new <tt>TCPInputStream</tt>.\n     *\n     * @param socket The inputStream for this instance.\n     */\n    public TCPInputStream(MultiplexingSocket socket)\n    {\n        if (socket == null)\n            throw new NullPointerException(\"socket\");\n\n        this.socket = socket;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void close()\n        throws IOException\n    {\n        // TODO Auto-generated method stub\n        super.close();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int read()\n        throws IOException\n    {\n        synchronized (readSyncRoot)\n        {\n            waitWhileInRead();\n            inRead = true;\n        }\n        try\n        {\n            do\n            {\n                int read = read0(b, 0, 1);\n\n                if (read == -1)\n                    return read;\n                if (read == 1)\n                    return b[0];\n            }\n            while (true);\n        }\n        finally\n        {\n            synchronized (readSyncRoot)\n            {\n                inRead = false;\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int read(byte[] b, int off, int len)\n        throws IOException\n    {\n        int read;\n\n        // The javadoc on InputStream.read(byte[], int, int) says that, if len\n        // is zero, no bytes are read and zero is returned.\n        if (len == 0)\n        {\n            read = 0;\n        }\n        else\n        {\n            synchronized (readSyncRoot)\n            {\n                waitWhileInRead();\n                inRead = true;\n            }\n            try\n            {\n                read = read0(b, off, len);\n            }\n            finally\n            {\n                synchronized (readSyncRoot)\n                {\n                    inRead = false;\n                }\n            }\n        }\n        return read;\n    }\n\n    protected int read0(byte[] b, int off, int len)\n        throws IOException\n    {\n        int read;\n\n        do\n        {\n            if (packetLength > 0)\n            {\n                // Data has already been received from the network.\n                read = Math.min(packetLength, len);\n                System.arraycopy(packetData, packetOffset, b, off, read);\n                packetLength -= read;\n                packetOffset += read;\n                break;\n            }\n\n            // Receive from the network.\n\n            // Make sure that the receive buffer of this InputStream satisfies\n            // the requirements with respect to size of the socket.\n            int receiveBufferSize = socket.getReceiveBufferSize();\n\n            if (receiveBufferSize < 1)\n                receiveBufferSize = DEFAULT_RECEIVE_BUFFER_SIZE;\n            if ((packetData == null) || (packetData.length < receiveBufferSize))\n                packetData = new byte[receiveBufferSize];\n            if (packet == null)\n                packet = new DatagramPacket(packetData, 0, packetData.length);\n            else\n                packet.setData(packetData, 0, packetData.length);\n            packetLength = 0;\n            packetOffset = 0;\n\n            socket.receive(packet);\n\n            packetData = packet.getData();\n            packetLength = packet.getLength();\n            packetOffset = packet.getOffset();\n        }\n        while (true);\n\n        return read;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long skip(long n)\n        throws IOException\n    {\n        // Optimizing the implementation of InputStream.skip(long) sounds like a\n        // nice idea in general. However, we do not expect the method to be used\n        // a lot. Consequently, we would rather go for simplicity.\n        return super.skip(n);\n    }\n\n    /**\n     * Waits on {@link #readSyncRoot} while {@link #inRead} equals\n     * <tt>true</tt>.\n     */\n    private void waitWhileInRead()\n    {\n        boolean interrupted = false;\n\n        synchronized (readSyncRoot)\n        {\n            while (inRead)\n            {\n                try\n                {\n                    readSyncRoot.wait();\n                }\n                catch (InterruptedException ex)\n                {\n                    interrupted = true;\n                }\n            }\n        }\n        if (interrupted)\n            Thread.currentThread().interrupt();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final int DEFAULT_RECEIVE_BUFFER_SIZE = 65536;", "docstring": "\nThe default size of the receive buffer of <tt>TCPInputStream</tt> if the\nassociated <tt>MultiplexingSocket</tt> does not specify a value.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "DEFAULT_RECEIVE_BUFFER_SIZE = 65536", "syntax_pass": true}, {"attribute_expression": "private final byte[] b = new byte[1];", "docstring": "\nThe <tt>byte</tt> array with one element which is used by the\nimplementation of {@link #read()} in order to delegate to the\nimplementation of {@link #read(byte[], int, int)} for the purposes of\nsimplicity.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "byte[]", "name": "b = new byte[1]", "syntax_pass": true}, {"attribute_expression": "private boolean inRead;", "docstring": "\nThe indicator which determines whether this <tt>TCPInputStream</tt> is\nexecuting one of its <tt>read</tt> method implementations.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "inRead", "syntax_pass": true}, {"attribute_expression": "private DatagramPacket packet;", "docstring": "\nCurrent packet being processed if any.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DatagramPacket", "name": "packet", "syntax_pass": true}, {"attribute_expression": "private byte[] packetData;", "docstring": "\nThe <tt>data</tt> of {@link #packet}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "byte[]", "name": "packetData", "syntax_pass": true}, {"attribute_expression": "private int packetLength;", "docstring": "\nCurrent packet length.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "packetLength", "syntax_pass": true}, {"attribute_expression": "private int packetOffset;", "docstring": "\nCurrent offset.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "packetOffset", "syntax_pass": true}, {"attribute_expression": "private final Object readSyncRoot = new Object();", "docstring": "\nThe <tt>Object</tt> which synchronizes the access to the read-related\nstate of this instance.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "readSyncRoot = new Object()", "syntax_pass": true}, {"attribute_expression": "private final MultiplexingSocket socket;", "docstring": "\nThe <tt>MultiplexingSocket</tt> which has initialized this instance and\nis using it as its <tt>inputStream</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "MultiplexingSocket", "name": "socket", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/DTLSDatagramFilter.java.DTLSDatagramFilter", "name": "DTLSDatagramFilter", "file_path": "src/main/java/org/ice4j/socket/DTLSDatagramFilter.java", "superclasses": "", "methods": ["[boolean]isDTLS(DatagramPacket)", "[boolean]isDTLS(byte[],int,int)", "[boolean]accept(DatagramPacket)"], "method_uris": ["src/main/java/org/ice4j/socket/DTLSDatagramFilter.java.DTLSDatagramFilter.[boolean]isDTLS(DatagramPacket)", "src/main/java/org/ice4j/socket/DTLSDatagramFilter.java.DTLSDatagramFilter.[boolean]isDTLS(byte[],int,int)", "src/main/java/org/ice4j/socket/DTLSDatagramFilter.java.DTLSDatagramFilter.[boolean]accept(DatagramPacket)"], "overrides": null, "attributes": [], "class_docstring": "\nA {@code DatagramPacketFilter} which accepts DTLS packets only.\n\n@author Boris Grozev\n", "original_string": "public class DTLSDatagramFilter\n    implements DatagramPacketFilter\n{\n    /**\n     * Determines whether {@code p} looks like a DTLS packet.\n     *\n     * @param p the {@code DatagramPacket} to check.\n     * @return {@code true} if {@code p} looks like a DTLS packet; otherwise,\n     * {@code false}.\n     */\n    public static boolean isDTLS(DatagramPacket p)\n    {\n        return p != null && isDTLS(p.getData(), p.getOffset(), p.getLength());\n    }\n\n    /**\n     * Determines whether the buffer represented by {@code data}, {@code off}\n     * and {@code len} looks like a DTLS packet.\n     *\n     * @param data the array that contains the data.\n     * @param off the offset.\n     * @param len the length.\n     * @return {@code true} if the buffer looks like a DTLS packet; otherwise,\n     * {@code false}.\n     */\n    public static boolean isDTLS(byte[] data, int off, int len)\n    {\n        if (len > 0)\n        {\n            int fb = data[off] & 0xff;\n\n            return 19 < fb && fb < 64;\n        }\n\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean accept(DatagramPacket p)\n    {\n        return isDTLS(p);\n    }\n}", "super_interfaces": ["DatagramPacketFilter"], "fields": []}, {"uris": "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java.MultiplexedDatagramSocket", "name": "MultiplexedDatagramSocket", "file_path": "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java", "superclasses": "DelegatingDatagramSocket", "methods": ["[]MultiplexedDatagramSocket(MultiplexingDatagramSocket,DatagramPacketFilter)", "[void]close()", "[DatagramPacketFilter]getFilter()", "[void]receive(DatagramPacket)"], "method_uris": ["src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java.MultiplexedDatagramSocket.[]MultiplexedDatagramSocket(MultiplexingDatagramSocket,DatagramPacketFilter)", "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java.MultiplexedDatagramSocket.[void]close()", "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java.MultiplexedDatagramSocket.[DatagramPacketFilter]getFilter()", "src/main/java/org/ice4j/socket/MultiplexedDatagramSocket.java.MultiplexedDatagramSocket.[void]receive(DatagramPacket)"], "overrides": null, "attributes": [], "class_docstring": "\nRepresents a <tt>DatagramSocket</tt> which receives <tt>DatagramPacket</tt>s\nselected by a <tt>DatagramPacketFilter</tt> from a\n<tt>MultiplexingDatagramSocket</tt>. The associated\n<tt>MultiplexingDatagramSocket</tt> is the actual <tt>DatagramSocket</tt>\nwhich reads the <tt>DatagramPacket</tt>s from the network. The\n<tt>DatagramPacket</tt>s received through the\n<tt>MultiplexedDatagramSocket</tt> will not be received through the\nassociated <tt>MultiplexingDatagramSocket</tt>.\n\n@author Lyubomir Marinov\n", "original_string": "public class MultiplexedDatagramSocket\n    extends DelegatingDatagramSocket\n    implements MultiplexedXXXSocket\n{\n    /**\n     * The <tt>DatagramPacketFilter</tt> which determines which\n     * <tt>DatagramPacket</tt>s read from the network by {@link #multiplexing}\n     * are to be received through this instance.\n     */\n    private final DatagramPacketFilter filter;\n\n    /**\n     * The <tt>MultiplexingDatagramSocket</tt> which does the actual reading\n     * from the network and which forwards <tt>DatagramPacket</tt>s accepted by\n     * {@link #filter} for receipt to this instance.\n     */\n    private final MultiplexingDatagramSocket multiplexing;\n\n    /**\n     * The list of <tt>DatagramPacket</tt>s to be received through this\n     * <tt>DatagramSocket</tt> i.e. accepted by {@link #filter}.\n     */\n    final SocketReceiveBuffer received\n        = new SocketReceiveBuffer(this::getReceiveBufferSize);\n\n    /**\n     * Initializes a new <tt>MultiplexedDatagramSocket</tt> which is unbound and\n     * filters <tt>DatagramPacket</tt>s away from a specific\n     * <tt>MultiplexingDatagramSocket</tt> using a specific\n     * <tt>DatagramPacketFilter</tt>.\n     *\n     * @param multiplexing the <tt>MultiplexingDatagramSocket</tt> which does\n     * the actual reading from the network and which forwards\n     * <tt>DatagramPacket</tt>s accepted by the specified <tt>filter</tt> to the\n     * new instance\n     * @param filter the <tt>DatagramPacketFilter</tt> which determines which\n     * <tt>DatagramPacket</tt>s read from the network by the specified\n     * <tt>multiplexing</tt> are to be received through the new instance\n     * @throws SocketException if the socket could not be opened\n     */\n    MultiplexedDatagramSocket(\n            MultiplexingDatagramSocket multiplexing,\n            DatagramPacketFilter filter)\n        throws SocketException\n    {\n        /*\n         * Even if MultiplexingDatagramSocket allows MultiplexedDatagramSocket\n         * to perform bind, binding in the super will not execute correctly this\n         * early in the construction because the multiplexing field is not set\n         * yet. That is why MultiplexedDatagramSocket does not currently support\n         * bind at construction time.\n         */\n        super(multiplexing);\n\n        if (multiplexing == null)\n            throw new NullPointerException(\"multiplexing\");\n\n        this.multiplexing = multiplexing;\n        this.filter = filter;\n    }\n\n    /**\n     * Closes this datagram socket.\n     * <p>\n     * Any thread currently blocked in {@link #receive(DatagramPacket)} upon\n     * this socket will throw a {@link SocketException}.\n     * </p>\n     *\n     * @see DatagramSocket#close()\n     */\n    @Override\n    public void close()\n    {\n        multiplexing.close(this);\n\n        // We intentionally do not call super.close(), because it eventually\n        // delegates to #multiplexing. We don't want to close #multiplexing\n        // just yet, because it may have other filtered sockets attached to it\n        // (or it needs to be kept open for other reasons)\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public DatagramPacketFilter getFilter()\n    {\n        return filter;\n    }\n\n    /**\n     * Receives a datagram packet from this socket. When this method returns,\n     * the <tt>DatagramPacket</tt>'s buffer is filled with the data received.\n     * The datagram packet also contains the sender's IP address, and the port\n     * number on the sender's machine.\n     * <p>\n     * This method blocks until a datagram is received. The <tt>length</tt>\n     * field of the datagram packet object contains the length of the received\n     * message. If the message is longer than the packet's length, the message\n     * is truncated.\n     * </p>\n     * <p>\n     * If there is a security manager, a packet cannot be received if the\n     * security manager's <tt>checkAccept</tt> method does not allow it.\n     * </p>\n     *\n     * @param p the <tt>DatagramPacket</tt> into which to place the incoming\n     * data\n     * @throws IOException if an I/O error occurs\n     * @see DatagramSocket#receive(DatagramPacket)\n     */\n    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        multiplexing.receive(this, p);\n    }\n}", "super_interfaces": ["MultiplexedXXXSocket"], "fields": [{"attribute_expression": "private final DatagramPacketFilter filter;", "docstring": "\nThe <tt>DatagramPacketFilter</tt> which determines which\n<tt>DatagramPacket</tt>s read from the network by {@link #multiplexing}\nare to be received through this instance.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DatagramPacketFilter", "name": "filter", "syntax_pass": true}, {"attribute_expression": "private final MultiplexingDatagramSocket multiplexing;", "docstring": "\nThe <tt>MultiplexingDatagramSocket</tt> which does the actual reading\nfrom the network and which forwards <tt>DatagramPacket</tt>s accepted by\n{@link #filter} for receipt to this instance.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "MultiplexingDatagramSocket", "name": "multiplexing", "syntax_pass": true}, {"attribute_expression": "final SocketReceiveBuffer received\n        = new SocketReceiveBuffer(this::getReceiveBufferSize);", "docstring": "\nThe list of <tt>DatagramPacket</tt>s to be received through this\n<tt>DatagramSocket</tt> i.e. accepted by {@link #filter}.\n", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "SocketReceiveBuffer", "name": "received\n        = new SocketReceiveBuffer(this::getReceiveBufferSize)", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter", "name": "StunDatagramPacketFilter", "file_path": "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java", "superclasses": "", "methods": ["[]StunDatagramPacketFilter()", "[]StunDatagramPacketFilter(TransportAddress)", "[boolean]accept(DatagramPacket)", "[boolean]acceptMethod(char)", "[boolean]equals(Object)", "[int]hashCode()", "[boolean]isStunPacket(DatagramPacket)"], "method_uris": ["src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter.[]StunDatagramPacketFilter()", "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter.[]StunDatagramPacketFilter(TransportAddress)", "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter.[boolean]accept(DatagramPacket)", "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter.[boolean]acceptMethod(char)", "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter.[boolean]equals(Object)", "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter.[int]hashCode()", "src/main/java/org/ice4j/socket/StunDatagramPacketFilter.java.StunDatagramPacketFilter.[boolean]isStunPacket(DatagramPacket)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a <tt>DatagramPacketFilter</tt> which only accepts\n<tt>DatagramPacket</tt>s which represent STUN messages defined in RFC 5389\n\"Session Traversal Utilities for NAT (STUN)\" i.e. with method Binding or the\nreserved method 0x000 and 0x002/SharedSecret.\n\n@author Lyubomir Marinov\n", "original_string": "public class StunDatagramPacketFilter\n    implements DatagramPacketFilter\n{\n\n    /**\n     * The <tt>TransportAddress</tt> of the STUN server <tt>DatagramPacket</tt>s\n     * representing STUN messages from and to which are accepted by this\n     * instance.\n     */\n    protected final TransportAddress stunServer;\n\n    /**\n     * Initializes a new <tt>StunDatagramPacketFilter</tt> which will accept\n     * <tt>DatagramPacket</tt>s which represent STUN messages received from\n     * any destination.\n     */\n    public StunDatagramPacketFilter()\n    {\n        this(null);\n    }\n\n    /**\n     * Initializes a new <tt>StunDatagramPacketFilter</tt> which will accept\n     * <tt>DatagramPacket</tt>s which represent STUN messages and which are part\n     * of the communication with a specific STUN server (or any server if\n     * <tt>stunServer</tt> is <tt>null</tt>).\n     *\n     * @param stunServer the <tt>TransportAddress</tt> of the STUN server\n     * <tt>DatagramPacket</tt>s representing STUN messages from and to which\n     * will be accepted by the new instance or <tt>null</tt> if we would like\n     * to accept stun messages from any destination.\n     */\n    public StunDatagramPacketFilter(TransportAddress stunServer)\n    {\n        this.stunServer = stunServer;\n    }\n\n    /**\n     * Determines whether a specific <tt>DatagramPacket</tt> represents a STUN\n     * message and whether it is part of the communication with the STUN server\n     * if one was associated with this instance.\n     *\n     * @param p the <tt>DatagramPacket</tt> which is to be checked whether it is\n     * a STUN message which is part of the communicator with the STUN server\n     * associated with this instance\n     * @return <tt>true</tt> if the specified <tt>DatagramPacket</tt> represents\n     * a STUN message which is part of the communication with the STUN server\n     * associated with this instance; otherwise, <tt>false</tt>\n     */\n    public boolean accept(DatagramPacket p)\n    {\n        /*\n         * If we were instantiated for a specific STUN server, and the packet\n         * did not originate there, we reject it.\n         */\n        if ((stunServer != null) && !stunServer.equals(p.getSocketAddress()))\n            return false;\n\n        // If this is a STUN packet.\n        if (StunDatagramPacketFilter.isStunPacket(p))\n        {\n            byte[] data = p.getData();\n            int offset = p.getOffset();\n\n            byte b0 = data[offset];\n            byte b1 = data[offset + 1];\n            char method = (char) ((b0 & 0xFE) | (b1 & 0xEF));\n\n            return acceptMethod(method);\n        }\n        return false;\n    }\n\n    /**\n     * Determines whether this <tt>DatagramPacketFilter</tt> accepts a\n     * <tt>DatagramPacket</tt> which represents a STUN message with a specific\n     * STUN method. <tt>StunDatagramPacketFilter</tt> only accepts the method\n     * Binding and the reserved methods 0x000 and 0x002/SharedSecret.\n     *\n     * @param method the STUN method of a STUN message represented by a\n     * <tt>DatagramPacket</tt> to be checked whether it is accepted by this\n     * <tt>DatagramPacketFilter</tt>\n     * @return <tt>true</tt> if this <tt>DatagramPacketFilter</tt> accepts the\n     * <tt>DatagramPacket</tt> which represents a STUN message with the\n     * specified STUN method; otherwise, <tt>false</tt>\n     */\n    protected boolean acceptMethod(char method)\n    {\n        switch (method)\n        {\n        case Message.STUN_METHOD_BINDING:\n        case 0x0000:\n        case 0x0002:\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    /**\n     * Indicates whether some other object is \"equal to\" this one.\n     *\n     * @param obj the reference object with which to compare.\n     * @return <tt>true</tt> if this <tt>StunDatagramPacketFilter</tt> is equal\n     * to the <tt>obj</tt> argument; <tt>false</tt>, otherwise.\n     */\n    @Override\n    public boolean equals(Object obj)\n    {\n        if (null == obj)\n            return false;\n        else if (this == obj)\n            return true;\n        else\n            return getClass().equals(obj.getClass());\n    }\n\n    /**\n     * Returns a hash code value for this object for the benefit of hashtables\n     * such as those provided by <tt>Hashtable</tt>.\n     *\n     * @return a hash code value for this object\n     */\n    @Override\n    public int hashCode()\n    {\n        /*\n         * Overrides the super implementation in order to maintain the general\n         * contract of the hashCode method which states that equal objects must\n         * have equal hash codes.\n         */\n        return getClass().hashCode();\n    }\n\n    /**\n     * Determines whether a specific <tt>DatagramPacket</tt> represents a STUN\n     * (or TURN) packet.\n     *\n     * @param p the <tt>DatagramPacket</tt> which is to be checked whether it is\n     * a STUN message which is part of the communicator with the STUN server\n     * associated with this instance\n     *\n     * @return True if the <tt>DatagramPacket</tt> represents a STUN\n     * (or TURN) packet. False, otherwise.\n     */\n    public static boolean isStunPacket(DatagramPacket p)\n    {\n        byte[] data = p.getData();\n        int offset = p.getOffset();\n        int length = p.getLength();\n\n        // All STUN messages MUST start with a 20-byte header followed by zero or more Attributes.\n        if (length < 20)\n        {\n            return false;\n        }\n\n        // The most significant 2 bits of every STUN message MUST be zeroes. This can be used to differentiate STUN\n        // packets from other protocols when STUN is multiplexed with other protocols on the same port.\n        if ((data[offset] & 0xC0) != 0)\n        {\n            return false;\n        }\n\n        // If the MAGIC COOKIE is present this is a STUN packet (RFC5389 compliant).\n        if (data[offset + 4] == Message.MAGIC_COOKIE[0]\n            && data[offset + 5] == Message.MAGIC_COOKIE[1]\n            && data[offset + 6] == Message.MAGIC_COOKIE[2]\n            && data[offset + 7] == Message.MAGIC_COOKIE[3])\n        {\n            return true;\n        }\n        // Else, this packet may be a STUN packet (RFC3489 compliant). To determine this, we must continue the checks.\n        else\n        {\n            // Checks if the length of the data correspond to the length field of the STUN header. The message length\n            // field of the STUN header does not include the 20-byte of the STUN header.\n            int total_header_length\n                = ((((int)data[2]) & 0xff) << 8)\n                + (((int) data[3]) & 0xff)\n                + 20;\n            return (length == total_header_length);\n        }\n    }\n}", "super_interfaces": ["DatagramPacketFilter"], "fields": [{"attribute_expression": "protected final TransportAddress stunServer;", "docstring": "\nThe <tt>TransportAddress</tt> of the STUN server <tt>DatagramPacket</tt>s\nrepresenting STUN messages from and to which are accepted by this\ninstance.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "TransportAddress", "name": "stunServer", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream", "name": "TCPOutputStream", "file_path": "src/main/java/org/ice4j/socket/TCPOutputStream.java", "superclasses": "OutputStream", "methods": ["[]TCPOutputStream(OutputStream)", "[void]close()", "[void]flush()", "[void]write(byte[],int,int)", "[void]write(int)"], "method_uris": ["src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream.[]TCPOutputStream(OutputStream)", "src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream.[void]close()", "src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream.[void]flush()", "src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream.[void]write(byte[],int,int)", "src/main/java/org/ice4j/socket/TCPOutputStream.java.TCPOutputStream.[void]write(int)"], "overrides": null, "attributes": [], "class_docstring": "\nTCP output stream for TCP socket. It is used to multiplex sockets and keep\nthe <tt>OutputStream</tt> interface to users.\n\n@author Sebastien Vincent\n", "original_string": "public class TCPOutputStream\n    extends OutputStream\n{\n    /**\n     * The indicator which determines whether this <tt>TCPOutputStream</tt> is\n     * to frame RTP and RTCP packets in accord with RFC 4571 &quot;Framing\n     * Real-time Transport Protocol (RTP) and RTP Control Protocol (RTCP)\n     * Packets over Connection-Oriented Transport&quot;.\n     */\n    private final boolean frame;\n\n    /**\n     * Original <tt>OutputStream</tt> that this class wraps.\n     */\n    private final OutputStream outputStream;\n\n    /**\n     * Initializes a new <tt>TCPOutputStream</tt>.\n     *\n     * @param outputStream original <tt>OutputStream</tt>\n     */\n    public TCPOutputStream(OutputStream outputStream)\n    {\n        this.outputStream = outputStream;\n\n        // GoogleRelayedCandidateSocket will encapsulate data in TURN message so\n        // do not frame.\n        frame\n            = !(outputStream\n                    instanceof GoogleRelayedCandidateSocket.TCPOutputStream);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void close()\n        throws IOException\n    {\n        outputStream.close();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void flush()\n        throws IOException\n    {\n        outputStream.flush();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write(byte[] b, int off, int len)\n        throws IOException\n    {\n        if (frame)\n        {\n            int newLen = len + 2;\n            byte newB[] = new byte[newLen];\n\n            newB[0] = (byte) ((len >> 8) & 0xFF);\n            newB[1] = (byte) (len & 0xFF);\n            System.arraycopy(b, off, newB, 2, len);\n            outputStream.write(newB, 0, newLen);\n        }\n        else\n        {\n            outputStream.write(b, off, len);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void write(int b)\n        throws IOException\n    {\n        // TODO Auto-generated method stub\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final boolean frame;", "docstring": "\nThe indicator which determines whether this <tt>TCPOutputStream</tt> is\nto frame RTP and RTCP packets in accord with RFC 4571 &quot;Framing\nReal-time Transport Protocol (RTP) and RTP Control Protocol (RTCP)\nPackets over Connection-Oriented Transport&quot;.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "frame", "syntax_pass": true}, {"attribute_expression": "private final OutputStream outputStream;", "docstring": "\nOriginal <tt>OutputStream</tt> that this class wraps.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OutputStream", "name": "outputStream", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket", "name": "MultiplexedSocket", "file_path": "src/main/java/org/ice4j/socket/MultiplexedSocket.java", "superclasses": "DelegatingSocket", "methods": ["[]MultiplexedSocket(MultiplexingSocket,DatagramPacketFilter)", "[void]close()", "[DatagramPacketFilter]getFilter()", "[InputStream]getInputStream()", "[void]receive(DatagramPacket)"], "method_uris": ["src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket.[]MultiplexedSocket(MultiplexingSocket,DatagramPacketFilter)", "src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket.[void]close()", "src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket.[DatagramPacketFilter]getFilter()", "src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket.[InputStream]getInputStream()", "src/main/java/org/ice4j/socket/MultiplexedSocket.java.MultiplexedSocket.[void]receive(DatagramPacket)"], "overrides": null, "attributes": [{"original_string": "    private class InputStreamImpl\n        extends InputStream\n    {\n        /**\n         * A buffer to receive data into.\n         */\n        private final byte[] buf = new byte[1500];\n\n        /**\n         * A <tt>DatagramPacket</tt> instance to receive data into.\n         */\n        private final DatagramPacket packet = new DatagramPacket(buf, 1500);\n\n        /**\n         * Initializes a new <tt>TCPInputStream</tt>.\n         */\n        public InputStreamImpl()\n        {\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int available()\n        {\n            return 0;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean markSupported()\n        {\n            return false;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int read()\n            throws IOException\n        {\n            // We don't support reading a single byte\n            return 0;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int read(byte[] b)\n            throws IOException\n        {\n            return read(b, 0, b.length);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int read(byte[] b, int off, int len)\n            throws IOException\n        {\n            if (off == 0) // optimization: avoid copy to b\n            {\n                packet.setData(b);\n                receive(packet);\n\n                int lengthRead = packet.getLength();\n\n                if (packet.getData() == b && lengthRead <= len)\n                {\n                    return lengthRead;\n                }\n                else\n                {\n                    logger.warning(\n                            \"Failed to read directly into the provided buffer,\"\n                                + \" len=\" + len + \" lengthRead=\" + lengthRead\n                                + \" (packet.getData() == b)=\"\n                                + (packet.getData() == b));\n                }\n            }\n\n            // either there's an offset to take into account, or receiving\n            // directly in 'b' failed.\n\n            packet.setData(buf);\n            receive(packet);\n\n            int packetLen = packet.getLength();\n            int lengthRead = Math.min(len, packetLen);\n\n            System.arraycopy(\n                    packet.getData(), packet.getOffset(),\n                    b, off,\n                    lengthRead);\n\n            return lengthRead;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void reset()\n            throws IOException\n        {\n            if (!markSupported())\n            {\n                throw new IOException(\n                        \"InputStreamImpl does not support reset()\");\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public long skip(long n)\n            throws IOException\n        {\n            throw new IOException(\"InputStreamImpl does not support skip.\");\n        }\n    }", "definition": "    private class InputStreamImpl\n        extends InputStream", "class_docstring": "\nImplements an <tt>InputStream</tt> for this <tt>MultiplexedSocket</tt>,\nreading data using {@link #receive(java.net.DatagramPacket)}.\n", "name": "InputStreamImpl", "super_interfaces": [], "superclasses": "InputStream", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [{"attribute_expression": "private final byte[] buf = new byte[1500];", "docstring": "\nA buffer to receive data into.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "byte[]", "name": "buf = new byte[1500]", "syntax_pass": true}, {"attribute_expression": "private final DatagramPacket packet = new DatagramPacket(buf, 1500);", "docstring": "\nA <tt>DatagramPacket</tt> instance to receive data into.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DatagramPacket", "name": "packet = new DatagramPacket(buf, 1500)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public InputStreamImpl()\n        {\n        }", "docstring": "\nInitializes a new <tt>TCPInputStream</tt>.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "InputStreamImpl", "params": [], "body": "        {\n        }", "signature": "public InputStreamImpl()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int available()\n        {\n            return 0;\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "available", "params": [], "body": "        {\n            return 0;\n        }", "signature": "@Override\n        public int available()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean markSupported()\n        {\n            return false;\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "markSupported", "params": [], "body": "        {\n            return false;\n        }", "signature": "@Override\n        public boolean markSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int read()\n            throws IOException\n        {\n            // We don't support reading a single byte\n            return 0;\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "read", "params": [], "body": "        {\n            // We don't support reading a single byte\n            return 0;\n        }", "signature": "@Override\n        public int read()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int read(byte[] b)\n            throws IOException\n        {\n            return read(b, 0, b.length);\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "read", "params": [{"name": "b", "type": "byte[]"}], "body": "        {\n            return read(b, 0, b.length);\n        }", "signature": "@Override\n        public int read(byte[] b)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int read(byte[] b, int off, int len)\n            throws IOException\n        {\n            if (off == 0) // optimization: avoid copy to b\n            {\n                packet.setData(b);\n                receive(packet);\n\n                int lengthRead = packet.getLength();\n\n                if (packet.getData() == b && lengthRead <= len)\n                {\n                    return lengthRead;\n                }\n                else\n                {\n                    logger.warning(\n                            \"Failed to read directly into the provided buffer,\"\n                                + \" len=\" + len + \" lengthRead=\" + lengthRead\n                                + \" (packet.getData() == b)=\"\n                                + (packet.getData() == b));\n                }\n            }\n\n            // either there's an offset to take into account, or receiving\n            // directly in 'b' failed.\n\n            packet.setData(buf);\n            receive(packet);\n\n            int packetLen = packet.getLength();\n            int lengthRead = Math.min(len, packetLen);\n\n            System.arraycopy(\n                    packet.getData(), packet.getOffset(),\n                    b, off,\n                    lengthRead);\n\n            return lengthRead;\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "read", "params": [{"name": "b", "type": "byte[]"}, {"name": "off", "type": "int"}, {"name": "len", "type": "int"}], "body": "        {\n            if (off == 0) // optimization: avoid copy to b\n            {\n                packet.setData(b);\n                receive(packet);\n\n                int lengthRead = packet.getLength();\n\n                if (packet.getData() == b && lengthRead <= len)\n                {\n                    return lengthRead;\n                }\n                else\n                {\n                    logger.warning(\n                            \"Failed to read directly into the provided buffer,\"\n                                + \" len=\" + len + \" lengthRead=\" + lengthRead\n                                + \" (packet.getData() == b)=\"\n                                + (packet.getData() == b));\n                }\n            }\n\n            // either there's an offset to take into account, or receiving\n            // directly in 'b' failed.\n\n            packet.setData(buf);\n            receive(packet);\n\n            int packetLen = packet.getLength();\n            int lengthRead = Math.min(len, packetLen);\n\n            System.arraycopy(\n                    packet.getData(), packet.getOffset(),\n                    b, off,\n                    lengthRead);\n\n            return lengthRead;\n        }", "signature": "@Override\n        public int read(byte[] b, int off, int len)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void reset()\n            throws IOException\n        {\n            if (!markSupported())\n            {\n                throw new IOException(\n                        \"InputStreamImpl does not support reset()\");\n            }\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "reset", "params": [], "body": "        {\n            if (!markSupported())\n            {\n                throw new IOException(\n                        \"InputStreamImpl does not support reset()\");\n            }\n        }", "signature": "@Override\n        public void reset()"}, {"syntax_pass": true, "original_string": "        @Override\n        public long skip(long n)\n            throws IOException\n        {\n            throw new IOException(\"InputStreamImpl does not support skip.\");\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "long", "classes": []}, "name": "skip", "params": [{"name": "n", "type": "long"}], "body": "        {\n            throw new IOException(\"InputStreamImpl does not support skip.\");\n        }", "signature": "@Override\n        public long skip(long n)"}]}], "class_docstring": "\nRepresents a <tt>Socket</tt> which receives <tt>DatagramPacket</tt>s\nselected by a <tt>DatagramPacketFilter</tt> from a\n<tt>MultiplexingSocket</tt>. The associated <tt>MultiplexingSocket</tt> is\nthe actual <tt>Socket</tt> which reads the <tt>DatagramPacket</tt>s from the\nnetwork. The <tt>DatagramPacket</tt>s received through the\n<tt>MultiplexedSocket</tt> will not be received through the\nassociated <tt>MultiplexingSocket</tt>.\n\n@author Sebastien Vincent\n", "original_string": "public class MultiplexedSocket\n    extends DelegatingSocket\n    implements MultiplexedXXXSocket\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>MultiplexedSocket</tt> class and its\n     * instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(MultiplexedSocket.class.getName());\n\n    /**\n     * The <tt>DatagramPacketFilter</tt> which determines which\n     * <tt>DatagramPacket</tt>s read from the network by {@link #multiplexing}\n     * are to be received through this instance.\n     */\n    private final DatagramPacketFilter filter;\n\n    /**\n     * The custom <tt>InputStream</tt> for this <tt>MultiplexedSocket</tt>.\n     */\n    private final InputStream inputStream = new InputStreamImpl();\n\n    /**\n     * The <tt>MultiplexingSocket</tt> which does the actual reading from the\n     * network and which forwards <tt>DatagramPacket</tt>s accepted by\n     * {@link #filter} for receipt to this instance.\n     */\n    private final MultiplexingSocket multiplexing;\n\n    /**\n     * The list of <tt>DatagramPacket</tt>s to be received through this\n     * <tt>Socket</tt> i.e. accepted by {@link #filter}.\n     */\n    final SocketReceiveBuffer received\n        = new SocketReceiveBuffer(this::getReceiveBufferSize);\n\n    /**\n     * Initializes a new <tt>MultiplexedSocket</tt> which is unbound and filters\n     * <tt>DatagramPacket</tt>s away from a specific <tt>MultiplexingSocket</tt>\n     * using a specific <tt>DatagramPacketFilter</tt>.\n     *\n     * @param multiplexing the <tt>MultiplexingSocket</tt> which does the actual\n     * reading from the network and which forwards <tt>DatagramPacket</tt>s\n     * accepted by the specified <tt>filter</tt> to the new instance\n     * @param filter the <tt>DatagramPacketFilter</tt> which determines which\n     * <tt>DatagramPacket</tt>s read from the network by the specified\n     * <tt>multiplexing</tt> are to be received through the new instance\n     * @throws SocketException if the socket could not be opened\n     */\n    MultiplexedSocket(\n            MultiplexingSocket multiplexing,\n            DatagramPacketFilter filter)\n        throws SocketException\n    {\n        /*\n         * Even if MultiplexingSocket allows MultiplexedSocket to perform bind,\n         * binding in the super will not execute correctly this early in the\n         * construction because the multiplexing field is not set yet. That is\n         * why MultiplexedSocket does not currently support bind at construction\n         * time.\n         */\n        super(multiplexing);\n\n        if (multiplexing == null)\n            throw new NullPointerException(\"multiplexing\");\n\n        this.multiplexing = multiplexing;\n        this.filter = filter;\n    }\n\n    /**\n     * Closes this datagram socket.\n     * <p>\n     * Any thread currently blocked in {@link #receive(DatagramPacket)} upon\n     * this socket will throw a {@link SocketException}.\n     * </p>\n     *\n     * @see Socket#close()\n     */\n    @Override\n    public void close()\n    {\n        multiplexing.close(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public DatagramPacketFilter getFilter()\n    {\n        return filter;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InputStream getInputStream()\n    {\n        return inputStream;\n    }\n\n    /**\n     * Receives a datagram packet from this socket. When this method returns,\n     * the <tt>DatagramPacket</tt>'s buffer is filled with the data received.\n     * The datagram packet also contains the sender's IP address, and the port\n     * number on the sender's machine.\n     * <p>\n     * This method blocks until a datagram is received. The <tt>length</tt>\n     * field of the datagram packet object contains the length of the received\n     * message. If the message is longer than the packet's length, the message\n     * is truncated.\n     * </p>\n     *\n     * @param p the <tt>DatagramPacket</tt> into which to place the incoming\n     * data\n     * @throws IOException if an I/O error occurs\n     * @see MultiplexingSocket#receive(DatagramPacket)\n     */\n    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        multiplexing.receive(this, p);\n    }\n\n    /**\n     * Implements an <tt>InputStream</tt> for this <tt>MultiplexedSocket</tt>,\n     * reading data using {@link #receive(java.net.DatagramPacket)}.\n     */\n    private class InputStreamImpl\n        extends InputStream\n    {\n        /**\n         * A buffer to receive data into.\n         */\n        private final byte[] buf = new byte[1500];\n\n        /**\n         * A <tt>DatagramPacket</tt> instance to receive data into.\n         */\n        private final DatagramPacket packet = new DatagramPacket(buf, 1500);\n\n        /**\n         * Initializes a new <tt>TCPInputStream</tt>.\n         */\n        public InputStreamImpl()\n        {\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int available()\n        {\n            return 0;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean markSupported()\n        {\n            return false;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int read()\n            throws IOException\n        {\n            // We don't support reading a single byte\n            return 0;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int read(byte[] b)\n            throws IOException\n        {\n            return read(b, 0, b.length);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int read(byte[] b, int off, int len)\n            throws IOException\n        {\n            if (off == 0) // optimization: avoid copy to b\n            {\n                packet.setData(b);\n                receive(packet);\n\n                int lengthRead = packet.getLength();\n\n                if (packet.getData() == b && lengthRead <= len)\n                {\n                    return lengthRead;\n                }\n                else\n                {\n                    logger.warning(\n                            \"Failed to read directly into the provided buffer,\"\n                                + \" len=\" + len + \" lengthRead=\" + lengthRead\n                                + \" (packet.getData() == b)=\"\n                                + (packet.getData() == b));\n                }\n            }\n\n            // either there's an offset to take into account, or receiving\n            // directly in 'b' failed.\n\n            packet.setData(buf);\n            receive(packet);\n\n            int packetLen = packet.getLength();\n            int lengthRead = Math.min(len, packetLen);\n\n            System.arraycopy(\n                    packet.getData(), packet.getOffset(),\n                    b, off,\n                    lengthRead);\n\n            return lengthRead;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void reset()\n            throws IOException\n        {\n            if (!markSupported())\n            {\n                throw new IOException(\n                        \"InputStreamImpl does not support reset()\");\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public long skip(long n)\n            throws IOException\n        {\n            throw new IOException(\"InputStreamImpl does not support skip.\");\n        }\n    }\n}", "super_interfaces": ["MultiplexedXXXSocket"], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(MultiplexedSocket.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>MultiplexedSocket</tt> class and its\ninstances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(MultiplexedSocket.class.getName())", "syntax_pass": true}, {"attribute_expression": "private final DatagramPacketFilter filter;", "docstring": "\nThe <tt>DatagramPacketFilter</tt> which determines which\n<tt>DatagramPacket</tt>s read from the network by {@link #multiplexing}\nare to be received through this instance.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DatagramPacketFilter", "name": "filter", "syntax_pass": true}, {"attribute_expression": "private final InputStream inputStream = new InputStreamImpl();", "docstring": "\nThe custom <tt>InputStream</tt> for this <tt>MultiplexedSocket</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "InputStream", "name": "inputStream = new InputStreamImpl()", "syntax_pass": true}, {"attribute_expression": "private final MultiplexingSocket multiplexing;", "docstring": "\nThe <tt>MultiplexingSocket</tt> which does the actual reading from the\nnetwork and which forwards <tt>DatagramPacket</tt>s accepted by\n{@link #filter} for receipt to this instance.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "MultiplexingSocket", "name": "multiplexing", "syntax_pass": true}, {"attribute_expression": "final SocketReceiveBuffer received\n        = new SocketReceiveBuffer(this::getReceiveBufferSize);", "docstring": "\nThe list of <tt>DatagramPacket</tt>s to be received through this\n<tt>Socket</tt> i.e. accepted by {@link #filter}.\n", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "SocketReceiveBuffer", "name": "received\n        = new SocketReceiveBuffer(this::getReceiveBufferSize)", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket", "name": "MergingDatagramSocket", "file_path": "src/main/java/org/ice4j/socket/MergingDatagramSocket.java", "superclasses": "DatagramSocket", "methods": ["[]MergingDatagramSocket()", "[]MergingDatagramSocket(Logger)", "[boolean]isClosed()", "[void]close()", "[void]setSoTimeout(int)", "[int]getSoTimeout()", "[void]send(DatagramPacket)", "[void]add(DelegatingSocket)", "[void]add(IceSocketWrapper)", "[void]add(DatagramSocket)", "[void]doAdd(Object)", "[void]remove(DatagramSocket)", "[void]remove(DelegatingSocket)", "[void]doRemove(Object)", "[int]indexOf(SocketContainer[],Object)", "[SocketContainer]getActiveSocket()", "[InetAddress]getLocalAddress()", "[int]getLocalPort()", "[SocketAddress]getLocalSocketAddress()", "[boolean]accept(DatagramPacket)", "[void]receive(DatagramPacket)", "[void]initializeActive(IceSocketWrapper,TransportAddress)"], "method_uris": ["src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[]MergingDatagramSocket()", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[]MergingDatagramSocket(Logger)", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[boolean]isClosed()", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]close()", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]setSoTimeout(int)", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[int]getSoTimeout()", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]send(DatagramPacket)", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]add(DelegatingSocket)", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]add(IceSocketWrapper)", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]add(DatagramSocket)", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]doAdd(Object)", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]remove(DatagramSocket)", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]remove(DelegatingSocket)", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]doRemove(Object)", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[int]indexOf(SocketContainer[],Object)", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[SocketContainer]getActiveSocket()", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[InetAddress]getLocalAddress()", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[int]getLocalPort()", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[SocketAddress]getLocalSocketAddress()", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[boolean]accept(DatagramPacket)", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]receive(DatagramPacket)", "src/main/java/org/ice4j/socket/MergingDatagramSocket.java.MergingDatagramSocket.[void]initializeActive(IceSocketWrapper,TransportAddress)"], "overrides": null, "attributes": [{"original_string": "    private class SocketContainer\n    {\n        /**\n         * Either the socket represented by this instance, if it is a {@link\n         * DatagramSocket} instance, or {@code null} if it is not.\n         */\n        private final DatagramSocket datagramSocket;\n\n        /**\n         * Either the socket represented by this instance, if it is a {@link\n         * DelegatingSocket} instance, or {@code null}if it is not.\n         */\n        private final DelegatingSocket delegatingSocket;\n\n        /**\n         * The queue to which packets received from this instance's socket are\n         * added.\n         */\n        private final ArrayBlockingQueue<Buffer> queue\n            = new ArrayBlockingQueue<>(100);\n\n        /**\n         * A pool of unused {@link Buffer} instances.\n         */\n        private final ArrayBlockingQueue<Buffer> pool\n            = new ArrayBlockingQueue<>(10);\n\n        /**\n         * A flag used to signal to {@link #thread} to finish.\n         */\n        private boolean closed = false;\n\n        /**\n         * The remote address of the last received packet.\n         * Note that this is updated only when a packet is received from this\n         * {@link SocketContainer} via {@link #receive(DatagramPacket)}, and\n         * not when a packet is received from the underlying socket by its\n         * read thread. This is in order to prevent poisoning of the remote\n         * address, since the verification of the address is performed by\n         * the {@link MergingDatagramSocket} after it invokes\n         * {@link #receive(DatagramPacket)}.\n         */\n        private SocketAddress remoteAddress = null;\n\n        /**\n         * The thread which reads packets from this instance's socket and adds\n         * them to {@link #queue}. If the queue is filled up, it will stop\n         * receiving packets and will block waiting for the queue accept.\n         */\n        private Thread thread;\n\n        /**\n         * Initializes a {@link SocketContainer} instance using a {@link\n         * DatagramSocket} as its socket.\n         *\n         * @param socket the socket.\n         */\n        SocketContainer(DelegatingSocket socket)\n        {\n            this.datagramSocket = null;\n            this.delegatingSocket = Objects.requireNonNull(socket, \"socket\");\n            init();\n        }\n\n        /**\n         * Initializes a {@link SocketContainer} instance using a {@link\n         * DatagramSocket} as its socket.\n         *\n         * @param socket the socket.\n         */\n        SocketContainer(DatagramSocket socket)\n        {\n            this.datagramSocket = Objects.requireNonNull(socket, \"socket\");\n            this.delegatingSocket = null;\n            init();\n        }\n\n        /**\n         * Initializes and starts the thread of this instance.\n         */\n        private void init()\n        {\n            thread = new Thread()\n            {\n                @Override\n                public void run()\n                {\n                    runInReaderThread();\n                }\n            };\n            thread.setDaemon(true);\n            thread.setName(\"MergingDatagramSocket reader thread for: \"\n                               + getLocalSocketAddress() + \" -> \"\n                               + TransportAddress.redact(getRemoteSocketAddress()));\n\n            logger.debug(() -> \"Starting the thread for socket \"\n                            + getLocalSocketAddress() + \" -> \"\n                            + TransportAddress.redact(getRemoteSocketAddress()));\n            thread.start();\n        }\n\n        /**\n         * @return an unused {@link Buffer} instance.\n         */\n        private Buffer getFreeBuffer()\n        {\n            Buffer buffer = pool.poll();\n            if (buffer == null)\n                buffer = new Buffer();\n            buffer.reset();\n            return buffer;\n        }\n\n        /**\n         * Reads from the underlying socket and adds the read packets to {@link\n         * #queue}. Blocks if {@link #queue} is full.\n         */\n        private void runInReaderThread()\n        {\n            while (true)\n            {\n                if (closed || Thread.currentThread().isInterrupted())\n                    break;\n\n                // Read from the underlying socket\n                Buffer buffer = getFreeBuffer();\n                try\n                {\n                    if (!doReceive(buffer))\n                    {\n                        continue;\n                    }\n                }\n                catch (IOException ioe)\n                {\n                    logger.info(\"Failed to receive: \" + ioe);\n                    break;\n                }\n\n                if (closed || Thread.currentThread().isInterrupted())\n                    break;\n\n                try\n                {\n                    queue.put(buffer);\n                    synchronized (receiveLock)\n                    {\n                        receiveLock.notify();\n                    }\n                }\n                catch (InterruptedException ie)\n                {\n                    Thread.currentThread().interrupt();\n                }\n            }\n\n            // The receive thread is terminating, no reason to keep this\n            // container anymore.\n            close(true);\n\n            logger.debug(() -> \"Finished: \" + toString());\n        }\n\n        /**\n         * Tries to receive a packet from the underlying socket into {@code\n         * buffer}.\n         *\n         * @param buffer the buffer into which to receive.\n         * @return {@code true} if the method succeeded, or {@code false} if the\n         * thread was interrupted or this {@link SocketContainer} was closed.\n         * @throws IOException if receiving failed due to an I/O error from the\n         * underlying socket.\n         */\n        private boolean doReceive(Buffer buffer)\n            throws IOException\n        {\n            while (true)\n            {\n                if (closed || Thread.currentThread().isInterrupted())\n                    break;\n                try\n                {\n                    if (datagramSocket != null)\n                    {\n                        datagramSocket.receive(buffer.pkt);\n                    }\n                    else\n                    {\n                        delegatingSocket.receive(buffer.pkt);\n                    }\n\n                    buffer.receivedTime = System.currentTimeMillis();\n\n                    maybeUpdateActive();\n                    return true;\n                }\n                catch (SocketTimeoutException ste)\n                {\n                    // Ignore timeouts and loop.\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Makes this {@link SocketContainer} the active socket container for\n         * this {@link MergingDatagramSocket}, if it isn't already the active\n         * socket.\n         */\n        private void maybeUpdateActive()\n        {\n            SocketContainer active = MergingDatagramSocket.this.active;\n            // Avoid obtaining the lock on every packet from the active socket.\n            // There is no harm if the value is overwritten before we obtain\n            // the lock.\n            if (active != this)\n            {\n                synchronized (socketContainersSyncRoot)\n                {\n                    MergingDatagramSocket.this.active = this;\n                    logger.debug(() -> \"Switching to new active socket: \" + this);\n                }\n            }\n        }\n\n        /**\n         * Copies a packet from this {@link SocketContainer}'s queue into\n         * {@code p}. Does not block.\n         *\n         * @param p the {@link DatagramPacket} to receive into.\n         */\n        private void receive(DatagramPacket p)\n        {\n            Buffer buffer = queue.poll();\n            if (buffer == null)\n            {\n                throw new IllegalStateException(\"Queue empty.\");\n            }\n\n            byte[] dest = p.getData();\n            int destOffset = p.getOffset();\n            int len\n                = Math.min(\n                        dest.length - destOffset,\n                        buffer.pkt.getLength());\n\n            System.arraycopy(buffer.pkt.getData(), buffer.pkt.getOffset(),\n                             dest, destOffset,\n                             len);\n            p.setLength(len);\n            p.setSocketAddress(buffer.pkt.getSocketAddress());\n\n            pool.offer(buffer);\n        }\n\n        /**\n         * @return the time of reception of the first packet in the queue, or\n         * {@code -1} if the queue is empty.\n         */\n        private long getFirstReceivedTime()\n        {\n            Buffer nextBuffer = queue.peek();\n            if (nextBuffer != null)\n            {\n                return nextBuffer.receivedTime;\n            }\n            return -1;\n        }\n\n        /**\n         * {@inheritDoc}\n         * <p>\n         * Delegates to the underlying socket (either {@link #datagramSocket} or\n         * {@link #delegatingSocket}).\n         */\n        private InetAddress getLocalAddress()\n        {\n            return datagramSocket != null\n                ? datagramSocket.getLocalAddress()\n                : delegatingSocket.getLocalAddress();\n        }\n\n        /**\n         * {@inheritDoc}\n         * <p>\n         * Delegates to the underlying socket (either {@link #datagramSocket} or\n         * {@link #delegatingSocket}).\n         */\n        private int getLocalPort()\n        {\n            return datagramSocket != null\n                ? datagramSocket.getLocalPort()\n                : delegatingSocket.getLocalPort();\n        }\n\n        /**\n         * {@inheritDoc}\n         * <p>\n         * Delegates to the underlying socket (either {@link #datagramSocket} or\n         * {@link #delegatingSocket}).\n         */\n        public SocketAddress getLocalSocketAddress()\n        {\n            return datagramSocket != null\n                ? datagramSocket.getLocalSocketAddress()\n                : delegatingSocket.getLocalSocketAddress();\n        }\n\n        /**\n         * Returns a {@link String} representation of this {@link\n         * SocketContainer}.\n         */\n        public String toString()\n        {\n            if (datagramSocket != null)\n            {\n                return datagramSocket.getLocalSocketAddress()\n                    + \" -> \" + TransportAddress.redact(remoteAddress);\n            }\n            else\n            {\n                return delegatingSocket.getLocalSocketAddress()\n                    + \" -> \" + TransportAddress.redact(remoteAddress);\n            }\n        }\n\n        /**\n         * Sends a {@link DatagramPacket} through the underlying socket (either\n         * {@link #datagramSocket} or {@link #delegatingSocket}).\n         *\n         * @param pkt the packet to send.\n         */\n        private void send(DatagramPacket pkt)\n            throws IOException\n        {\n            // The application writing data doesn't necessarily know what\n            // remote address to use. Since this SocketContainer was selected\n            // to send the packet through, set the target accordingly.\n            setTarget(pkt);\n\n            if (datagramSocket != null)\n            {\n                datagramSocket.send(pkt);\n            }\n            else\n            {\n                delegatingSocket.send(pkt);\n            }\n        }\n\n        /**\n         * Sets the {@link SocketAddress} of {@code pkt} to the remote address\n         * that this {@link SocketContainer} should send packets to.\n         * @param pkt the packet for which to set the socket address.\n         */\n        private void setTarget(DatagramPacket pkt)\n        {\n            SocketAddress target;\n            // If the socket already has a remote address, use it. If this is\n            // the case, the DatagramPacket instance's remote address is likely\n            // to be ignored, anyway.\n            if (datagramSocket != null)\n            {\n                target = datagramSocket.getRemoteSocketAddress();\n            }\n            else\n            {\n                target = delegatingSocket.getRemoteSocketAddress();\n            }\n\n            // The socket doesn't always have a remote address (e.g. if it is\n            // an unconnected UDP socket from HostCandidateHarvester).\n            // In this case, we send to the source address of the last packet\n            // which was received and accepted, or to the address that was\n            // initialized via initializeActive (i.e. the address initially\n            // selected by ICE).\n            if (target == null)\n            {\n                target = this.remoteAddress;\n            }\n\n            pkt.setSocketAddress(target);\n        }\n\n        /**\n         * Notifies this {@link SocketContainer} that a particular\n         * {@link DatagramPacket} was received from it, and was accepted (as\n         * opposed to e.g. having been discarded due to its remote address not\n         * being authorized).\n         * @param pkt the accepted packet.\n         */\n        private void accepted(DatagramPacket pkt)\n        {\n            this.remoteAddress = pkt.getSocketAddress();\n        }\n\n        /**\n         * @return the underlying socket of this {@link SocketContainer}.\n         */\n        private Object getSocket()\n        {\n            return datagramSocket != null ? datagramSocket : delegatingSocket;\n        }\n\n        /**\n         * Closes this {@link SocketContainer}, stopping it's reading thread,\n         * and, if necessary removing it from the merging socket.\n         * @param remove whether to remove this container from the merging\n         * socket.\n         */\n        private void close(boolean remove)\n        {\n            if (closed)\n            {\n                return;\n            }\n            closed = true;\n\n            thread.interrupt();\n            if (remove)\n            {\n                MergingDatagramSocket.this.doRemove(getSocket());\n            }\n        }\n\n        /**\n         * Represents a {@link DatagramPacket} for the purposes of {@link\n         * SocketContainer}.\n         */\n        private class Buffer\n        {\n            /**\n             * The size of the buffer to allocate.\n             */\n            private static final int MAX_PACKET_SIZE = 1500;\n\n            /**\n             * The time at which this buffer was filled.\n             */\n            long receivedTime = -1;\n\n            /**\n             * The {@link DatagramPacket} wrapped by this {@link Buffer}.\n             */\n            DatagramPacket pkt\n                = new DatagramPacket(\n                new byte[MAX_PACKET_SIZE],\n                0,\n                MAX_PACKET_SIZE);\n\n            /**\n             * Prepares this {@link Buffer} for reuse.\n             */\n            private void reset()\n            {\n                receivedTime = -1;\n\n                // We are going to receive from a socket into this packet. If\n                // the length is insufficient it is going to truncate the data.\n                // So reset it to what we know is the underlying byte[]'s\n                // length.\n                pkt.setLength(MAX_PACKET_SIZE);\n            }\n        }\n    }", "definition": "    private class SocketContainer", "class_docstring": "\nContains one of the sockets which this {@link MergingDatagramSocket}\nmerges, and objects associated with the socket, including a thread\nwhich loops reading from it.\n\nThe socket is either a {@link DatagramSocket} or a\n{@link DelegatingSocket} instance, stored in {@link #datagramSocket} or\n{@link #delegatingSocket} respectively. Exactly one of these fields must\nbe null.\n", "name": "SocketContainer", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [{"attribute_expression": "private final DatagramSocket datagramSocket;", "docstring": "\nEither the socket represented by this instance, if it is a {@link\nDatagramSocket} instance, or {@code null} if it is not.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DatagramSocket", "name": "datagramSocket", "syntax_pass": true}, {"attribute_expression": "private final DelegatingSocket delegatingSocket;", "docstring": "\nEither the socket represented by this instance, if it is a {@link\nDelegatingSocket} instance, or {@code null}if it is not.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DelegatingSocket", "name": "delegatingSocket", "syntax_pass": true}, {"attribute_expression": "private final ArrayBlockingQueue<Buffer> queue\n            = new ArrayBlockingQueue<>(100);", "docstring": "\nThe queue to which packets received from this instance's socket are\nadded.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ArrayBlockingQueue<Buffer>", "name": "queue\n            = new ArrayBlockingQueue<>(100)", "syntax_pass": true}, {"attribute_expression": "private final ArrayBlockingQueue<Buffer> pool\n            = new ArrayBlockingQueue<>(10);", "docstring": "\nA pool of unused {@link Buffer} instances.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ArrayBlockingQueue<Buffer>", "name": "pool\n            = new ArrayBlockingQueue<>(10)", "syntax_pass": true}, {"attribute_expression": "private boolean closed = false;", "docstring": "\nA flag used to signal to {@link #thread} to finish.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "closed = false", "syntax_pass": true}, {"attribute_expression": "private SocketAddress remoteAddress = null;", "docstring": "\nThe remote address of the last received packet.\nNote that this is updated only when a packet is received from this\n{@link SocketContainer} via {@link #receive(DatagramPacket)}, and\nnot when a packet is received from the underlying socket by its\nread thread. This is in order to prevent poisoning of the remote\naddress, since the verification of the address is performed by\nthe {@link MergingDatagramSocket} after it invokes\n{@link #receive(DatagramPacket)}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SocketAddress", "name": "remoteAddress = null", "syntax_pass": true}, {"attribute_expression": "private Thread thread;", "docstring": "\nThe thread which reads packets from this instance's socket and adds\nthem to {@link #queue}. If the queue is filled up, it will stop\nreceiving packets and will block waiting for the queue accept.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Thread", "name": "thread", "syntax_pass": true}], "classes": [{"original_string": "        private class Buffer\n        {\n            /**\n             * The size of the buffer to allocate.\n             */\n            private static final int MAX_PACKET_SIZE = 1500;\n\n            /**\n             * The time at which this buffer was filled.\n             */\n            long receivedTime = -1;\n\n            /**\n             * The {@link DatagramPacket} wrapped by this {@link Buffer}.\n             */\n            DatagramPacket pkt\n                = new DatagramPacket(\n                new byte[MAX_PACKET_SIZE],\n                0,\n                MAX_PACKET_SIZE);\n\n            /**\n             * Prepares this {@link Buffer} for reuse.\n             */\n            private void reset()\n            {\n                receivedTime = -1;\n\n                // We are going to receive from a socket into this packet. If\n                // the length is insufficient it is going to truncate the data.\n                // So reset it to what we know is the underlying byte[]'s\n                // length.\n                pkt.setLength(MAX_PACKET_SIZE);\n            }\n        }", "definition": "        private class Buffer", "class_docstring": "\nRepresents a {@link DatagramPacket} for the purposes of {@link\nSocketContainer}.\n", "name": "Buffer", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [{"attribute_expression": "private static final int MAX_PACKET_SIZE = 1500;", "docstring": "\nThe size of the buffer to allocate.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "MAX_PACKET_SIZE = 1500", "syntax_pass": true}, {"attribute_expression": "long receivedTime = -1;", "docstring": "\nThe time at which this buffer was filled.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "receivedTime = -1", "syntax_pass": true}, {"attribute_expression": "DatagramPacket pkt\n                = new DatagramPacket(\n                new byte[MAX_PACKET_SIZE],\n                0,\n                MAX_PACKET_SIZE);", "docstring": "\nThe {@link DatagramPacket} wrapped by this {@link Buffer}.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "DatagramPacket", "name": "pkt\n                = new DatagramPacket(\n                new byte[MAX_PACKET_SIZE],\n                0,\n                MAX_PACKET_SIZE)", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "            private void reset()\n            {\n                receivedTime = -1;\n\n                // We are going to receive from a socket into this packet. If\n                // the length is insufficient it is going to truncate the data.\n                // So reset it to what we know is the underlying byte[]'s\n                // length.\n                pkt.setLength(MAX_PACKET_SIZE);\n            }", "docstring": "\nPrepares this {@link Buffer} for reuse.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "reset", "params": [], "body": "            {\n                receivedTime = -1;\n\n                // We are going to receive from a socket into this packet. If\n                // the length is insufficient it is going to truncate the data.\n                // So reset it to what we know is the underlying byte[]'s\n                // length.\n                pkt.setLength(MAX_PACKET_SIZE);\n            }", "signature": "private void reset()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        SocketContainer(DelegatingSocket socket)\n        {\n            this.datagramSocket = null;\n            this.delegatingSocket = Objects.requireNonNull(socket, \"socket\");\n            init();\n        }", "docstring": "\nInitializes a {@link SocketContainer} instance using a {@link\nDatagramSocket} as its socket.\n\n@param socket the socket.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SocketContainer", "params": [{"name": "socket", "type": "DelegatingSocket"}], "body": "        {\n            this.datagramSocket = null;\n            this.delegatingSocket = Objects.requireNonNull(socket, \"socket\");\n            init();\n        }", "signature": "SocketContainer(DelegatingSocket socket)"}, {"syntax_pass": true, "original_string": "        SocketContainer(DatagramSocket socket)\n        {\n            this.datagramSocket = Objects.requireNonNull(socket, \"socket\");\n            this.delegatingSocket = null;\n            init();\n        }", "docstring": "\nInitializes a {@link SocketContainer} instance using a {@link\nDatagramSocket} as its socket.\n\n@param socket the socket.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SocketContainer", "params": [{"name": "socket", "type": "DatagramSocket"}], "body": "        {\n            this.datagramSocket = Objects.requireNonNull(socket, \"socket\");\n            this.delegatingSocket = null;\n            init();\n        }", "signature": "SocketContainer(DatagramSocket socket)"}, {"syntax_pass": true, "original_string": "        private void init()\n        {\n            thread = new Thread()\n            {\n                @Override\n                public void run()\n                {\n                    runInReaderThread();\n                }\n            };\n            thread.setDaemon(true);\n            thread.setName(\"MergingDatagramSocket reader thread for: \"\n                               + getLocalSocketAddress() + \" -> \"\n                               + TransportAddress.redact(getRemoteSocketAddress()));\n\n            logger.debug(() -> \"Starting the thread for socket \"\n                            + getLocalSocketAddress() + \" -> \"\n                            + TransportAddress.redact(getRemoteSocketAddress()));\n            thread.start();\n        }", "docstring": "\nInitializes and starts the thread of this instance.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "init", "params": [], "body": "        {\n            thread = new Thread()\n            {\n                @Override\n                public void run()\n                {\n                    runInReaderThread();\n                }\n            };\n            thread.setDaemon(true);\n            thread.setName(\"MergingDatagramSocket reader thread for: \"\n                               + getLocalSocketAddress() + \" -> \"\n                               + TransportAddress.redact(getRemoteSocketAddress()));\n\n            logger.debug(() -> \"Starting the thread for socket \"\n                            + getLocalSocketAddress() + \" -> \"\n                            + TransportAddress.redact(getRemoteSocketAddress()));\n            thread.start();\n        }", "signature": "private void init()"}, {"syntax_pass": true, "original_string": "        private Buffer getFreeBuffer()\n        {\n            Buffer buffer = pool.poll();\n            if (buffer == null)\n                buffer = new Buffer();\n            buffer.reset();\n            return buffer;\n        }", "docstring": "\n@return an unused {@link Buffer} instance.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Buffer", "classes": []}, "name": "getFreeBuffer", "params": [], "body": "        {\n            Buffer buffer = pool.poll();\n            if (buffer == null)\n                buffer = new Buffer();\n            buffer.reset();\n            return buffer;\n        }", "signature": "private Buffer getFreeBuffer()"}, {"syntax_pass": true, "original_string": "        private void runInReaderThread()\n        {\n            while (true)\n            {\n                if (closed || Thread.currentThread().isInterrupted())\n                    break;\n\n                // Read from the underlying socket\n                Buffer buffer = getFreeBuffer();\n                try\n                {\n                    if (!doReceive(buffer))\n                    {\n                        continue;\n                    }\n                }\n                catch (IOException ioe)\n                {\n                    logger.info(\"Failed to receive: \" + ioe);\n                    break;\n                }\n\n                if (closed || Thread.currentThread().isInterrupted())\n                    break;\n\n                try\n                {\n                    queue.put(buffer);\n                    synchronized (receiveLock)\n                    {\n                        receiveLock.notify();\n                    }\n                }\n                catch (InterruptedException ie)\n                {\n                    Thread.currentThread().interrupt();\n                }\n            }\n\n            // The receive thread is terminating, no reason to keep this\n            // container anymore.\n            close(true);\n\n            logger.debug(() -> \"Finished: \" + toString());\n        }", "docstring": "\nReads from the underlying socket and adds the read packets to {@link\n#queue}. Blocks if {@link #queue} is full.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "runInReaderThread", "params": [], "body": "        {\n            while (true)\n            {\n                if (closed || Thread.currentThread().isInterrupted())\n                    break;\n\n                // Read from the underlying socket\n                Buffer buffer = getFreeBuffer();\n                try\n                {\n                    if (!doReceive(buffer))\n                    {\n                        continue;\n                    }\n                }\n                catch (IOException ioe)\n                {\n                    logger.info(\"Failed to receive: \" + ioe);\n                    break;\n                }\n\n                if (closed || Thread.currentThread().isInterrupted())\n                    break;\n\n                try\n                {\n                    queue.put(buffer);\n                    synchronized (receiveLock)\n                    {\n                        receiveLock.notify();\n                    }\n                }\n                catch (InterruptedException ie)\n                {\n                    Thread.currentThread().interrupt();\n                }\n            }\n\n            // The receive thread is terminating, no reason to keep this\n            // container anymore.\n            close(true);\n\n            logger.debug(() -> \"Finished: \" + toString());\n        }", "signature": "private void runInReaderThread()"}, {"syntax_pass": true, "original_string": "        private boolean doReceive(Buffer buffer)\n            throws IOException\n        {\n            while (true)\n            {\n                if (closed || Thread.currentThread().isInterrupted())\n                    break;\n                try\n                {\n                    if (datagramSocket != null)\n                    {\n                        datagramSocket.receive(buffer.pkt);\n                    }\n                    else\n                    {\n                        delegatingSocket.receive(buffer.pkt);\n                    }\n\n                    buffer.receivedTime = System.currentTimeMillis();\n\n                    maybeUpdateActive();\n                    return true;\n                }\n                catch (SocketTimeoutException ste)\n                {\n                    // Ignore timeouts and loop.\n                }\n            }\n\n            return false;\n        }", "docstring": "\nTries to receive a packet from the underlying socket into {@code\nbuffer}.\n\n@param buffer the buffer into which to receive.\n@return {@code true} if the method succeeded, or {@code false} if the\nthread was interrupted or this {@link SocketContainer} was closed.\n@throws IOException if receiving failed due to an I/O error from the\nunderlying socket.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "doReceive", "params": [{"name": "buffer", "type": "Buffer"}], "body": "        {\n            while (true)\n            {\n                if (closed || Thread.currentThread().isInterrupted())\n                    break;\n                try\n                {\n                    if (datagramSocket != null)\n                    {\n                        datagramSocket.receive(buffer.pkt);\n                    }\n                    else\n                    {\n                        delegatingSocket.receive(buffer.pkt);\n                    }\n\n                    buffer.receivedTime = System.currentTimeMillis();\n\n                    maybeUpdateActive();\n                    return true;\n                }\n                catch (SocketTimeoutException ste)\n                {\n                    // Ignore timeouts and loop.\n                }\n            }\n\n            return false;\n        }", "signature": "private boolean doReceive(Buffer buffer)"}, {"syntax_pass": true, "original_string": "        private void maybeUpdateActive()\n        {\n            SocketContainer active = MergingDatagramSocket.this.active;\n            // Avoid obtaining the lock on every packet from the active socket.\n            // There is no harm if the value is overwritten before we obtain\n            // the lock.\n            if (active != this)\n            {\n                synchronized (socketContainersSyncRoot)\n                {\n                    MergingDatagramSocket.this.active = this;\n                    logger.debug(() -> \"Switching to new active socket: \" + this);\n                }\n            }\n        }", "docstring": "\nMakes this {@link SocketContainer} the active socket container for\nthis {@link MergingDatagramSocket}, if it isn't already the active\nsocket.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "maybeUpdateActive", "params": [], "body": "        {\n            SocketContainer active = MergingDatagramSocket.this.active;\n            // Avoid obtaining the lock on every packet from the active socket.\n            // There is no harm if the value is overwritten before we obtain\n            // the lock.\n            if (active != this)\n            {\n                synchronized (socketContainersSyncRoot)\n                {\n                    MergingDatagramSocket.this.active = this;\n                    logger.debug(() -> \"Switching to new active socket: \" + this);\n                }\n            }\n        }", "signature": "private void maybeUpdateActive()"}, {"syntax_pass": true, "original_string": "        private void receive(DatagramPacket p)\n        {\n            Buffer buffer = queue.poll();\n            if (buffer == null)\n            {\n                throw new IllegalStateException(\"Queue empty.\");\n            }\n\n            byte[] dest = p.getData();\n            int destOffset = p.getOffset();\n            int len\n                = Math.min(\n                        dest.length - destOffset,\n                        buffer.pkt.getLength());\n\n            System.arraycopy(buffer.pkt.getData(), buffer.pkt.getOffset(),\n                             dest, destOffset,\n                             len);\n            p.setLength(len);\n            p.setSocketAddress(buffer.pkt.getSocketAddress());\n\n            pool.offer(buffer);\n        }", "docstring": "\nCopies a packet from this {@link SocketContainer}'s queue into\n{@code p}. Does not block.\n\n@param p the {@link DatagramPacket} to receive into.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "receive", "params": [{"name": "p", "type": "DatagramPacket"}], "body": "        {\n            Buffer buffer = queue.poll();\n            if (buffer == null)\n            {\n                throw new IllegalStateException(\"Queue empty.\");\n            }\n\n            byte[] dest = p.getData();\n            int destOffset = p.getOffset();\n            int len\n                = Math.min(\n                        dest.length - destOffset,\n                        buffer.pkt.getLength());\n\n            System.arraycopy(buffer.pkt.getData(), buffer.pkt.getOffset(),\n                             dest, destOffset,\n                             len);\n            p.setLength(len);\n            p.setSocketAddress(buffer.pkt.getSocketAddress());\n\n            pool.offer(buffer);\n        }", "signature": "private void receive(DatagramPacket p)"}, {"syntax_pass": true, "original_string": "        private long getFirstReceivedTime()\n        {\n            Buffer nextBuffer = queue.peek();\n            if (nextBuffer != null)\n            {\n                return nextBuffer.receivedTime;\n            }\n            return -1;\n        }", "docstring": "\n@return the time of reception of the first packet in the queue, or\n{@code -1} if the queue is empty.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "long", "classes": []}, "name": "getFirstReceivedTime", "params": [], "body": "        {\n            Buffer nextBuffer = queue.peek();\n            if (nextBuffer != null)\n            {\n                return nextBuffer.receivedTime;\n            }\n            return -1;\n        }", "signature": "private long getFirstReceivedTime()"}, {"syntax_pass": true, "original_string": "        private InetAddress getLocalAddress()\n        {\n            return datagramSocket != null\n                ? datagramSocket.getLocalAddress()\n                : delegatingSocket.getLocalAddress();\n        }", "docstring": "\n{@inheritDoc}\n<p>\nDelegates to the underlying socket (either {@link #datagramSocket} or\n{@link #delegatingSocket}).\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "InetAddress", "classes": []}, "name": "getLocalAddress", "params": [], "body": "        {\n            return datagramSocket != null\n                ? datagramSocket.getLocalAddress()\n                : delegatingSocket.getLocalAddress();\n        }", "signature": "private InetAddress getLocalAddress()"}, {"syntax_pass": true, "original_string": "        private int getLocalPort()\n        {\n            return datagramSocket != null\n                ? datagramSocket.getLocalPort()\n                : delegatingSocket.getLocalPort();\n        }", "docstring": "\n{@inheritDoc}\n<p>\nDelegates to the underlying socket (either {@link #datagramSocket} or\n{@link #delegatingSocket}).\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "name": "getLocalPort", "params": [], "body": "        {\n            return datagramSocket != null\n                ? datagramSocket.getLocalPort()\n                : delegatingSocket.getLocalPort();\n        }", "signature": "private int getLocalPort()"}, {"syntax_pass": true, "original_string": "        public SocketAddress getLocalSocketAddress()\n        {\n            return datagramSocket != null\n                ? datagramSocket.getLocalSocketAddress()\n                : delegatingSocket.getLocalSocketAddress();\n        }", "docstring": "\n{@inheritDoc}\n<p>\nDelegates to the underlying socket (either {@link #datagramSocket} or\n{@link #delegatingSocket}).\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "name": "getLocalSocketAddress", "params": [], "body": "        {\n            return datagramSocket != null\n                ? datagramSocket.getLocalSocketAddress()\n                : delegatingSocket.getLocalSocketAddress();\n        }", "signature": "public SocketAddress getLocalSocketAddress()"}, {"syntax_pass": true, "original_string": "        public String toString()\n        {\n            if (datagramSocket != null)\n            {\n                return datagramSocket.getLocalSocketAddress()\n                    + \" -> \" + TransportAddress.redact(remoteAddress);\n            }\n            else\n            {\n                return delegatingSocket.getLocalSocketAddress()\n                    + \" -> \" + TransportAddress.redact(remoteAddress);\n            }\n        }", "docstring": "\nReturns a {@link String} representation of this {@link\nSocketContainer}.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "        {\n            if (datagramSocket != null)\n            {\n                return datagramSocket.getLocalSocketAddress()\n                    + \" -> \" + TransportAddress.redact(remoteAddress);\n            }\n            else\n            {\n                return delegatingSocket.getLocalSocketAddress()\n                    + \" -> \" + TransportAddress.redact(remoteAddress);\n            }\n        }", "signature": "public String toString()"}, {"syntax_pass": true, "original_string": "        private void send(DatagramPacket pkt)\n            throws IOException\n        {\n            // The application writing data doesn't necessarily know what\n            // remote address to use. Since this SocketContainer was selected\n            // to send the packet through, set the target accordingly.\n            setTarget(pkt);\n\n            if (datagramSocket != null)\n            {\n                datagramSocket.send(pkt);\n            }\n            else\n            {\n                delegatingSocket.send(pkt);\n            }\n        }", "docstring": "\nSends a {@link DatagramPacket} through the underlying socket (either\n{@link #datagramSocket} or {@link #delegatingSocket}).\n\n@param pkt the packet to send.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "send", "params": [{"name": "pkt", "type": "DatagramPacket"}], "body": "        {\n            // The application writing data doesn't necessarily know what\n            // remote address to use. Since this SocketContainer was selected\n            // to send the packet through, set the target accordingly.\n            setTarget(pkt);\n\n            if (datagramSocket != null)\n            {\n                datagramSocket.send(pkt);\n            }\n            else\n            {\n                delegatingSocket.send(pkt);\n            }\n        }", "signature": "private void send(DatagramPacket pkt)"}, {"syntax_pass": true, "original_string": "        private void setTarget(DatagramPacket pkt)\n        {\n            SocketAddress target;\n            // If the socket already has a remote address, use it. If this is\n            // the case, the DatagramPacket instance's remote address is likely\n            // to be ignored, anyway.\n            if (datagramSocket != null)\n            {\n                target = datagramSocket.getRemoteSocketAddress();\n            }\n            else\n            {\n                target = delegatingSocket.getRemoteSocketAddress();\n            }\n\n            // The socket doesn't always have a remote address (e.g. if it is\n            // an unconnected UDP socket from HostCandidateHarvester).\n            // In this case, we send to the source address of the last packet\n            // which was received and accepted, or to the address that was\n            // initialized via initializeActive (i.e. the address initially\n            // selected by ICE).\n            if (target == null)\n            {\n                target = this.remoteAddress;\n            }\n\n            pkt.setSocketAddress(target);\n        }", "docstring": "\nSets the {@link SocketAddress} of {@code pkt} to the remote address\nthat this {@link SocketContainer} should send packets to.\n@param pkt the packet for which to set the socket address.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "setTarget", "params": [{"name": "pkt", "type": "DatagramPacket"}], "body": "        {\n            SocketAddress target;\n            // If the socket already has a remote address, use it. If this is\n            // the case, the DatagramPacket instance's remote address is likely\n            // to be ignored, anyway.\n            if (datagramSocket != null)\n            {\n                target = datagramSocket.getRemoteSocketAddress();\n            }\n            else\n            {\n                target = delegatingSocket.getRemoteSocketAddress();\n            }\n\n            // The socket doesn't always have a remote address (e.g. if it is\n            // an unconnected UDP socket from HostCandidateHarvester).\n            // In this case, we send to the source address of the last packet\n            // which was received and accepted, or to the address that was\n            // initialized via initializeActive (i.e. the address initially\n            // selected by ICE).\n            if (target == null)\n            {\n                target = this.remoteAddress;\n            }\n\n            pkt.setSocketAddress(target);\n        }", "signature": "private void setTarget(DatagramPacket pkt)"}, {"syntax_pass": true, "original_string": "        private void accepted(DatagramPacket pkt)\n        {\n            this.remoteAddress = pkt.getSocketAddress();\n        }", "docstring": "\nNotifies this {@link SocketContainer} that a particular\n{@link DatagramPacket} was received from it, and was accepted (as\nopposed to e.g. having been discarded due to its remote address not\nbeing authorized).\n@param pkt the accepted packet.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "accepted", "params": [{"name": "pkt", "type": "DatagramPacket"}], "body": "        {\n            this.remoteAddress = pkt.getSocketAddress();\n        }", "signature": "private void accepted(DatagramPacket pkt)"}, {"syntax_pass": true, "original_string": "        private Object getSocket()\n        {\n            return datagramSocket != null ? datagramSocket : delegatingSocket;\n        }", "docstring": "\n@return the underlying socket of this {@link SocketContainer}.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Object", "classes": []}, "name": "getSocket", "params": [], "body": "        {\n            return datagramSocket != null ? datagramSocket : delegatingSocket;\n        }", "signature": "private Object getSocket()"}, {"syntax_pass": true, "original_string": "        private void close(boolean remove)\n        {\n            if (closed)\n            {\n                return;\n            }\n            closed = true;\n\n            thread.interrupt();\n            if (remove)\n            {\n                MergingDatagramSocket.this.doRemove(getSocket());\n            }\n        }", "docstring": "\nCloses this {@link SocketContainer}, stopping it's reading thread,\nand, if necessary removing it from the merging socket.\n@param remove whether to remove this container from the merging\nsocket.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "close", "params": [{"name": "remove", "type": "boolean"}], "body": "        {\n            if (closed)\n            {\n                return;\n            }\n            closed = true;\n\n            thread.interrupt();\n            if (remove)\n            {\n                MergingDatagramSocket.this.doRemove(getSocket());\n            }\n        }", "signature": "private void close(boolean remove)"}]}], "class_docstring": "\nA {@link DatagramSocket} implementation which merges a set of sockets.\n\nIt maintains a thread reading from each of the underlying sockets. Thus\nreceived datagrams are provided via the {@link #receive(DatagramPacket)}\nAPI, in the order in which they were originally received (or close to it,\nsince the implementation is only based on timestamps).\n\nOne of the underlying sockets is used as a delegate, and handles sending\nvia {@link #send(DatagramPacket)} and calls to\n{@link #getLocalPort()}, {@link #getLocalAddress()} and\n{@link #getLocalSocketAddress()}.\n\n@author Boris Grozev\n", "original_string": "public class MergingDatagramSocket\n    extends DatagramSocket\n{\n    /**\n     * Used to control access to {@link #socketContainers}.\n     */\n    private final Object socketContainersSyncRoot = new Object();\n\n    /**\n     * Stores the underlying sockets. Copy on write.\n     */\n    private SocketContainer[] socketContainers = new SocketContainer[0];\n\n    /**\n     * Calls to {@link #receive(java.net.DatagramPacket)} will wait on this\n     * object in case no packet is available for reading.\n     */\n    private final Object receiveLock = new Object();\n\n    /**\n     * If non-zero, {@link #receive(java.net.DatagramPacket)} will attempt to\n     * return within this many milliseconds, and will throw a\n     * {@link SocketTimeoutException} if no packet has been read.\n     */\n    private int soTimeout = 0;\n\n    /**\n     * The {@link SocketContainer} considered active, i.e. the one which should\n     * be used for sending.\n     */\n    protected SocketContainer active = null;\n\n    /**\n     * The flag which indicates whether this socket is closed.\n     */\n    private boolean closed = false;\n\n    /**\n     * The number of packets which were read from an underlying socket, but were\n     * discarded because they were not accepted by\n     * {@link #accept(DatagramPacket)}.\n     * Access to this field should be protected by {@link #receiveLock}.\n     */\n    private int numDiscardedPackets = 0;\n\n    /**\n     * The {@link Logger} used by {@link MergingDatagramSocket} instances.\n     */\n    protected final Logger logger;\n\n    /**\n     * Initializes a new {@link MergingDatagramSocket} instance.\n     * @throws SocketException\n     */\n    public MergingDatagramSocket()\n            throws SocketException\n    {\n        this(null);\n    }\n\n    /**\n     * Initializes a new {@link MergingDatagramSocket} instance.\n     * @param parentLogger the {@link Logger} parent logger from which we'll\n     *                     derive this class' logger instance\n     * @throws SocketException\n     */\n    public MergingDatagramSocket(Logger parentLogger)\n            throws SocketException\n    {\n        logger = parentLogger.createChildLogger(this.getClass().getName());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isClosed()\n    {\n        return closed;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void close()\n    {\n        try\n        {\n            super.close();\n        }\n        finally\n        {\n\n            if (isClosed())\n            {\n                return;\n            }\n            closed = true;\n            logger.info(\"Closing.\");\n\n            // XXX do we want to risk obtaining the lock here, or should we just\n            // let any thread in receive() find out about the close after it's\n            // next timeout?\n            synchronized (receiveLock)\n            {\n                receiveLock.notifyAll();\n            }\n\n            synchronized (socketContainersSyncRoot)\n            {\n                active = null;\n                for (SocketContainer container : socketContainers)\n                {\n                    container.close(false);\n                }\n                socketContainers = new SocketContainer[0];\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setSoTimeout(int soTimeout)\n    {\n        this.soTimeout = soTimeout;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getSoTimeout()\n    {\n        return soTimeout;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p/>\n     * The current implementation delegates to the first container, but this is\n     * subject to change.\n     *\n     * @param pkt the datagram to send.\n     * @throws IOException\n     */\n    @Override\n    public void send(DatagramPacket pkt)\n        throws IOException\n    {\n        SocketContainer active = getActiveSocket();\n        if (active != null)\n        {\n            active.send(pkt);\n        }\n        else\n        {\n            throw new IOException(\"No active socket.\");\n        }\n    }\n\n    /**\n     * Adds a {@link DelegatingSocket} instance to this merging socket. Note\n     * that this will start a thread reading from the added socket.\n     * @param socket the socket to add.\n     */\n    public void add(DelegatingSocket socket)\n    {\n        Objects.requireNonNull(socket, \"socket\");\n        logger.debug(() -> \"Adding a DelegatingSocket instance: \"\n                        + socket.getLocalAddress());\n        doAdd(socket);\n    }\n\n    /**\n     * Adds the socket instance wrapped by {@code wrapper} to this merging\n     * socket. Note that this will start a thread reading from the added socket.\n     * @param wrapper the wrapper of the socket to add.\n     */\n    public void add(IceSocketWrapper wrapper)\n    {\n        Object socket = wrapper.getUDPSocket();\n        if (socket == null)\n        {\n            socket = wrapper.getTCPSocket();\n        }\n        doAdd(socket);\n    }\n\n    /**\n     * Adds a {@link DatagramSocket} instance to this merging socket. Note\n     * that this will start a thread reading from the added socket.\n     * @param socket the socket to add.\n     */\n    public void add(DatagramSocket socket)\n    {\n        Objects.requireNonNull(socket, \"socket\");\n        logger.debug(() -> \"Adding a DatagramSocket instance: \"\n                + socket.getLocalAddress());\n        doAdd(socket);\n    }\n\n    /**\n     * Adds a socket (either a {@link DatagramSocket} or a\n     * {@link DelegatingSocket}) to the list of underlying sockets merged by\n     * this {@link MergingDatagramSocket}.\n     * @param socket the socket to add.\n     */\n    private void doAdd(Object socket)\n    {\n        Objects.requireNonNull(socket, \"socket\");\n\n        if (!(socket instanceof DelegatingSocket) &&\n            !(socket instanceof DatagramSocket))\n        {\n            throw new IllegalStateException(\"Socket type not supported: \"\n                    + socket.getClass().getName());\n        }\n\n        synchronized (socketContainersSyncRoot)\n        {\n            if (indexOf(socketContainers, socket) != -1)\n            {\n                logger.warn(\"Socket already added.\");\n                return;\n            }\n\n            SocketContainer socketContainer;\n            if (socket instanceof DelegatingSocket)\n            {\n                socketContainer = new SocketContainer((DelegatingSocket) socket);\n            }\n            else\n            {\n                socketContainer = new SocketContainer((DatagramSocket) socket);\n            }\n\n            SocketContainer[] newSocketContainers\n                = new SocketContainer[socketContainers.length + 1];\n            System.arraycopy(socketContainers, 0,\n                             newSocketContainers, 0,\n                             socketContainers.length);\n            newSocketContainers[socketContainers.length] = socketContainer;\n\n            socketContainers = newSocketContainers;\n        }\n    }\n\n    /**\n     * Removes a specific {@link DatagramSocket} from the list of sockets\n     * merged by this {@link MergingDatagramSocket}.\n     * @param socket the {@link DatagramSocket} to remove.\n     */\n    public void remove(DatagramSocket socket)\n    {\n        doRemove(socket);\n    }\n\n    /**\n     * Removes a specific {@link DelegatingSocket} from the list of sockets\n     * merged by this {@link MergingDatagramSocket}.\n     * @param socket the {@link DelegatingSocket} to remove.\n     */\n    public void remove(DelegatingSocket socket)\n    {\n        doRemove(socket);\n    }\n\n    /**\n     * Removes a socket from the list of sockets merged by this\n     * {@link MergingDatagramSocket}.\n     * @param socket the socket to remove.\n     */\n    private void doRemove(Object socket)\n    {\n        SocketContainer socketContainer = null;\n\n        synchronized (socketContainersSyncRoot)\n        {\n            int i = indexOf(socketContainers, socket);\n            if (i >= 0)\n            {\n                socketContainer = socketContainers[i];\n\n                SocketContainer[] newSockets\n                    = new SocketContainer[socketContainers.length - 1];\n                if (i > 0)\n                {\n                    System.arraycopy(socketContainers, 0,\n                                     newSockets, 0,\n                                     i);\n                }\n                if (i < socketContainers.length - 1)\n                {\n                    System.arraycopy(socketContainers, i + 1,\n                                     newSockets, i,\n                                     socketContainers.length - i - 1);\n                }\n\n                socketContainers = newSockets;\n\n                if (socketContainer == active)\n                {\n                    // TODO: proper selection of a new active socket\n                    logger.warn(\n                        \"Removing the active socket. Won't be able to send \"\n                        + \"until a new one is elected.\");\n                    active = null;\n                }\n            }\n            else\n            {\n                logger.error(\"Cannot find socket to remove.\");\n            }\n        }\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Removed: \" + socketContainer);\n        }\n        if (socketContainer != null)\n        {\n            // We just removed it from the merging socket, so use remove=false\n            socketContainer.close(false);\n        }\n    }\n\n    /**\n     * Returns the index in {@link #socketContainers} of the\n     * {@link SocketContainer} with socket equal to {@code socket}, or -1 if\n     * such a {@link SocketContainer} doesn't exist.\n     *\n     * @param socket the {@link DatagramSocket} to get the index of.\n     * @return the index in {@link #socketContainers} of the\n     * {@link SocketContainer} with socket equal to {@code socket}, or -1 if\n     * such a {@link SocketContainer} doesn't exist.\n     */\n    private int indexOf(SocketContainer[] socketContainers, Object socket)\n    {\n        for (int i = 0; i < socketContainers.length; i++)\n        {\n            if (socketContainers[i].datagramSocket == socket ||\n                socketContainers[i].delegatingSocket == socket)\n            {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * TODO\n     */\n    protected SocketContainer getActiveSocket()\n    {\n        return this.active;\n    }\n\n    /**\n     * {@inheritDoc}\n     * </p>\n     * Delegates to the \"active\" socket, if one exists. Else returns\n     * {@code null}.\n     */\n    @Override\n    public InetAddress getLocalAddress()\n    {\n        SocketContainer activeSocket = getActiveSocket();\n        return activeSocket == null ? null : activeSocket.getLocalAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     * </p>\n     * Delegates to the \"active\" socket, if one exists. Else returns\n     * {@code 0}.\n     * TODO: should we return 0 (unbound) or -1 (closed) if there are no\n     * sockets?\n     */\n    @Override\n    public int getLocalPort()\n    {\n        SocketContainer activeSocket = getActiveSocket();\n        return activeSocket == null ? 0 : activeSocket.getLocalPort();\n    }\n\n    /**\n     * {@inheritDoc}\n     * </p>\n     * Delegates to the \"active\" socket, if one exists. Else returns\n     * {@code null}.\n     */\n    @Override\n    public SocketAddress getLocalSocketAddress()\n    {\n        SocketContainer activeSocket = getActiveSocket();\n        return\n            activeSocket == null ? null : activeSocket.getLocalSocketAddress();\n    }\n\n    /**\n     * Checks whether a particular {@link DatagramPacket}, received from one of\n     * the underlying sockets of thins merging socket, should be accepted and\n     * provided for reception from this {@link MergingDatagramSocket}.\n     * @param p the packet for which to decide whether to accept it or not.\n     * @return {@code true} iff {@code p} should be accepted.\n     */\n    protected boolean accept(DatagramPacket p)\n    {\n        // By default we accept all packets, and allow extending classes to\n        // override\n        return true;\n    }\n\n    /**\n     * {@inheritDoc}\n     * </p>\n     * Copies into {@code p} a packet already received from one of the\n     * underlying sockets. The socket is chosen on the base of the timestamp\n     * of the reception of the first packet in its queue (so that earlier\n     * packets are received first).\n     * @throws SocketTimeoutException if a socket timeout is set, and the\n     * call fails to receive a packet within the timeout.\n     * @throws SocketClosedException if the socket is closed while\n     */\n    @Override\n    public void receive(DatagramPacket p)\n            throws SocketTimeoutException,\n                   SocketClosedException\n    {\n        long start = System.currentTimeMillis();\n        int soTimeout = this.soTimeout;\n\n        // We need to hold the lock while checking for an available packet,\n        // otherwise we might end up wait()-ing if a packet becomes available\n        // after our check.\n        // We keep the loop inside the lock, because this prevents us from\n        // having to re-obtain the lock after wait() returns. All operations\n        // inside the block are non-blocking, except for wait(), so we run no\n        // risk of causing a deadlock by doing so.\n        synchronized (receiveLock)\n        {\n            do\n            {\n                if (isClosed())\n                {\n                    throw new SocketClosedException();\n                }\n\n                // Find the input socket with the oldest packet\n                SocketContainer[] socketContainers = this.socketContainers;\n                SocketContainer socketToReceiveFrom = null;\n                long firstTime = -1;\n                for (SocketContainer socketContainer : socketContainers)\n                {\n                    long f = socketContainer.getFirstReceivedTime();\n                    if (f > 0)\n                    {\n                        if (firstTime == -1 || firstTime > f)\n                        {\n                            firstTime = f;\n                            socketToReceiveFrom = socketContainer;\n                        }\n                    }\n                }\n\n                // If a packet is available, receive it\n                if (socketToReceiveFrom != null)\n                {\n                    socketToReceiveFrom.receive(p);\n\n                    if (accept(p))\n                    {\n                        socketToReceiveFrom.accepted(p);\n                        return;\n                    }\n                    else\n                    {\n                        numDiscardedPackets++;\n                        if (numDiscardedPackets % 100 == 1)\n                        {\n                            logger.info(\"Discarded \" + numDiscardedPackets\n                                    + \" packets. Last remote address:\"\n                                    + TransportAddress.redact(p.getSocketAddress()));\n                        }\n\n                        // Go on and receive the next packet in p.\n                        continue;\n                    }\n                }\n                // Otherwise wait on receiveLock.\n                else\n                {\n                    long waitTimeout = 500;\n                    if (soTimeout > 0)\n                    {\n                        long remaining\n                            = start + soTimeout\n                                    - System.currentTimeMillis();\n                        if (remaining <= 0)\n                            throw new SocketTimeoutException();\n\n                        waitTimeout = Math.min(waitTimeout, remaining);\n                    }\n                    try\n                    {\n                        receiveLock.wait(waitTimeout);\n                    }\n                    catch (InterruptedException ie)\n                    {\n                        Thread.currentThread().interrupt();\n                        // We haven't received a packet, but what else can we\n                        // do?\n                        return;\n                    }\n                }\n            }\n            while (true);\n        }\n    }\n\n    /**\n     * Initializes the active socket of this {@link MergingDatagramSocket}.\n     * @param socketWrapper the {@link IceSocketWrapper} instance wrapping the\n     * actual socket that should be used. Used to find the correct\n     * {@link SocketContainer}\n     * @param remoteAddress the remote address which was selected by ICE and\n     * and which should be used as the target.\n     */\n    protected void initializeActive(IceSocketWrapper socketWrapper,\n                                    TransportAddress remoteAddress)\n    {\n        Object socket = socketWrapper.getTCPSocket();\n        if (socket == null)\n        {\n            socket = socketWrapper.getUDPSocket();\n        }\n\n        if (logger.isDebugEnabled())\n        {\n            logger.debug(\"Initializing the active container, socket=\" + socket\n                    + \"; remote address=\" + TransportAddress.redact(remoteAddress));\n        }\n\n        synchronized (socketContainersSyncRoot)\n        {\n            if (active != null)\n            {\n                // This means that we've received data before ICE completed.\n                // That is, the remote side sent application data, and our\n                // application invoked receive(). Though maybe unusual, this\n                // is not necessarily incorrect.\n                // Still, go on and replace the active socket with whatever\n                // ICE selected.\n                logger.warn(\"Active socket already initialized.\");\n            }\n\n            SocketContainer newActive = null;\n            for (SocketContainer container : socketContainers)\n            {\n                if (socket == container.datagramSocket\n                    || socket == container.delegatingSocket)\n                {\n                    newActive = container;\n                    break;\n                }\n            }\n\n            if (newActive == null)\n            {\n                logger.error(\"No SocketContainer found!\");\n                return;\n            }\n\n            newActive.remoteAddress = remoteAddress;\n            active = newActive;\n\n        }\n    }\n\n    /**\n     * Contains one of the sockets which this {@link MergingDatagramSocket}\n     * merges, and objects associated with the socket, including a thread\n     * which loops reading from it.\n     *\n     * The socket is either a {@link DatagramSocket} or a\n     * {@link DelegatingSocket} instance, stored in {@link #datagramSocket} or\n     * {@link #delegatingSocket} respectively. Exactly one of these fields must\n     * be null.\n     */\n    private class SocketContainer\n    {\n        /**\n         * Either the socket represented by this instance, if it is a {@link\n         * DatagramSocket} instance, or {@code null} if it is not.\n         */\n        private final DatagramSocket datagramSocket;\n\n        /**\n         * Either the socket represented by this instance, if it is a {@link\n         * DelegatingSocket} instance, or {@code null}if it is not.\n         */\n        private final DelegatingSocket delegatingSocket;\n\n        /**\n         * The queue to which packets received from this instance's socket are\n         * added.\n         */\n        private final ArrayBlockingQueue<Buffer> queue\n            = new ArrayBlockingQueue<>(100);\n\n        /**\n         * A pool of unused {@link Buffer} instances.\n         */\n        private final ArrayBlockingQueue<Buffer> pool\n            = new ArrayBlockingQueue<>(10);\n\n        /**\n         * A flag used to signal to {@link #thread} to finish.\n         */\n        private boolean closed = false;\n\n        /**\n         * The remote address of the last received packet.\n         * Note that this is updated only when a packet is received from this\n         * {@link SocketContainer} via {@link #receive(DatagramPacket)}, and\n         * not when a packet is received from the underlying socket by its\n         * read thread. This is in order to prevent poisoning of the remote\n         * address, since the verification of the address is performed by\n         * the {@link MergingDatagramSocket} after it invokes\n         * {@link #receive(DatagramPacket)}.\n         */\n        private SocketAddress remoteAddress = null;\n\n        /**\n         * The thread which reads packets from this instance's socket and adds\n         * them to {@link #queue}. If the queue is filled up, it will stop\n         * receiving packets and will block waiting for the queue accept.\n         */\n        private Thread thread;\n\n        /**\n         * Initializes a {@link SocketContainer} instance using a {@link\n         * DatagramSocket} as its socket.\n         *\n         * @param socket the socket.\n         */\n        SocketContainer(DelegatingSocket socket)\n        {\n            this.datagramSocket = null;\n            this.delegatingSocket = Objects.requireNonNull(socket, \"socket\");\n            init();\n        }\n\n        /**\n         * Initializes a {@link SocketContainer} instance using a {@link\n         * DatagramSocket} as its socket.\n         *\n         * @param socket the socket.\n         */\n        SocketContainer(DatagramSocket socket)\n        {\n            this.datagramSocket = Objects.requireNonNull(socket, \"socket\");\n            this.delegatingSocket = null;\n            init();\n        }\n\n        /**\n         * Initializes and starts the thread of this instance.\n         */\n        private void init()\n        {\n            thread = new Thread()\n            {\n                @Override\n                public void run()\n                {\n                    runInReaderThread();\n                }\n            };\n            thread.setDaemon(true);\n            thread.setName(\"MergingDatagramSocket reader thread for: \"\n                               + getLocalSocketAddress() + \" -> \"\n                               + TransportAddress.redact(getRemoteSocketAddress()));\n\n            logger.debug(() -> \"Starting the thread for socket \"\n                            + getLocalSocketAddress() + \" -> \"\n                            + TransportAddress.redact(getRemoteSocketAddress()));\n            thread.start();\n        }\n\n        /**\n         * @return an unused {@link Buffer} instance.\n         */\n        private Buffer getFreeBuffer()\n        {\n            Buffer buffer = pool.poll();\n            if (buffer == null)\n                buffer = new Buffer();\n            buffer.reset();\n            return buffer;\n        }\n\n        /**\n         * Reads from the underlying socket and adds the read packets to {@link\n         * #queue}. Blocks if {@link #queue} is full.\n         */\n        private void runInReaderThread()\n        {\n            while (true)\n            {\n                if (closed || Thread.currentThread().isInterrupted())\n                    break;\n\n                // Read from the underlying socket\n                Buffer buffer = getFreeBuffer();\n                try\n                {\n                    if (!doReceive(buffer))\n                    {\n                        continue;\n                    }\n                }\n                catch (IOException ioe)\n                {\n                    logger.info(\"Failed to receive: \" + ioe);\n                    break;\n                }\n\n                if (closed || Thread.currentThread().isInterrupted())\n                    break;\n\n                try\n                {\n                    queue.put(buffer);\n                    synchronized (receiveLock)\n                    {\n                        receiveLock.notify();\n                    }\n                }\n                catch (InterruptedException ie)\n                {\n                    Thread.currentThread().interrupt();\n                }\n            }\n\n            // The receive thread is terminating, no reason to keep this\n            // container anymore.\n            close(true);\n\n            logger.debug(() -> \"Finished: \" + toString());\n        }\n\n        /**\n         * Tries to receive a packet from the underlying socket into {@code\n         * buffer}.\n         *\n         * @param buffer the buffer into which to receive.\n         * @return {@code true} if the method succeeded, or {@code false} if the\n         * thread was interrupted or this {@link SocketContainer} was closed.\n         * @throws IOException if receiving failed due to an I/O error from the\n         * underlying socket.\n         */\n        private boolean doReceive(Buffer buffer)\n            throws IOException\n        {\n            while (true)\n            {\n                if (closed || Thread.currentThread().isInterrupted())\n                    break;\n                try\n                {\n                    if (datagramSocket != null)\n                    {\n                        datagramSocket.receive(buffer.pkt);\n                    }\n                    else\n                    {\n                        delegatingSocket.receive(buffer.pkt);\n                    }\n\n                    buffer.receivedTime = System.currentTimeMillis();\n\n                    maybeUpdateActive();\n                    return true;\n                }\n                catch (SocketTimeoutException ste)\n                {\n                    // Ignore timeouts and loop.\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Makes this {@link SocketContainer} the active socket container for\n         * this {@link MergingDatagramSocket}, if it isn't already the active\n         * socket.\n         */\n        private void maybeUpdateActive()\n        {\n            SocketContainer active = MergingDatagramSocket.this.active;\n            // Avoid obtaining the lock on every packet from the active socket.\n            // There is no harm if the value is overwritten before we obtain\n            // the lock.\n            if (active != this)\n            {\n                synchronized (socketContainersSyncRoot)\n                {\n                    MergingDatagramSocket.this.active = this;\n                    logger.debug(() -> \"Switching to new active socket: \" + this);\n                }\n            }\n        }\n\n        /**\n         * Copies a packet from this {@link SocketContainer}'s queue into\n         * {@code p}. Does not block.\n         *\n         * @param p the {@link DatagramPacket} to receive into.\n         */\n        private void receive(DatagramPacket p)\n        {\n            Buffer buffer = queue.poll();\n            if (buffer == null)\n            {\n                throw new IllegalStateException(\"Queue empty.\");\n            }\n\n            byte[] dest = p.getData();\n            int destOffset = p.getOffset();\n            int len\n                = Math.min(\n                        dest.length - destOffset,\n                        buffer.pkt.getLength());\n\n            System.arraycopy(buffer.pkt.getData(), buffer.pkt.getOffset(),\n                             dest, destOffset,\n                             len);\n            p.setLength(len);\n            p.setSocketAddress(buffer.pkt.getSocketAddress());\n\n            pool.offer(buffer);\n        }\n\n        /**\n         * @return the time of reception of the first packet in the queue, or\n         * {@code -1} if the queue is empty.\n         */\n        private long getFirstReceivedTime()\n        {\n            Buffer nextBuffer = queue.peek();\n            if (nextBuffer != null)\n            {\n                return nextBuffer.receivedTime;\n            }\n            return -1;\n        }\n\n        /**\n         * {@inheritDoc}\n         * <p>\n         * Delegates to the underlying socket (either {@link #datagramSocket} or\n         * {@link #delegatingSocket}).\n         */\n        private InetAddress getLocalAddress()\n        {\n            return datagramSocket != null\n                ? datagramSocket.getLocalAddress()\n                : delegatingSocket.getLocalAddress();\n        }\n\n        /**\n         * {@inheritDoc}\n         * <p>\n         * Delegates to the underlying socket (either {@link #datagramSocket} or\n         * {@link #delegatingSocket}).\n         */\n        private int getLocalPort()\n        {\n            return datagramSocket != null\n                ? datagramSocket.getLocalPort()\n                : delegatingSocket.getLocalPort();\n        }\n\n        /**\n         * {@inheritDoc}\n         * <p>\n         * Delegates to the underlying socket (either {@link #datagramSocket} or\n         * {@link #delegatingSocket}).\n         */\n        public SocketAddress getLocalSocketAddress()\n        {\n            return datagramSocket != null\n                ? datagramSocket.getLocalSocketAddress()\n                : delegatingSocket.getLocalSocketAddress();\n        }\n\n        /**\n         * Returns a {@link String} representation of this {@link\n         * SocketContainer}.\n         */\n        public String toString()\n        {\n            if (datagramSocket != null)\n            {\n                return datagramSocket.getLocalSocketAddress()\n                    + \" -> \" + TransportAddress.redact(remoteAddress);\n            }\n            else\n            {\n                return delegatingSocket.getLocalSocketAddress()\n                    + \" -> \" + TransportAddress.redact(remoteAddress);\n            }\n        }\n\n        /**\n         * Sends a {@link DatagramPacket} through the underlying socket (either\n         * {@link #datagramSocket} or {@link #delegatingSocket}).\n         *\n         * @param pkt the packet to send.\n         */\n        private void send(DatagramPacket pkt)\n            throws IOException\n        {\n            // The application writing data doesn't necessarily know what\n            // remote address to use. Since this SocketContainer was selected\n            // to send the packet through, set the target accordingly.\n            setTarget(pkt);\n\n            if (datagramSocket != null)\n            {\n                datagramSocket.send(pkt);\n            }\n            else\n            {\n                delegatingSocket.send(pkt);\n            }\n        }\n\n        /**\n         * Sets the {@link SocketAddress} of {@code pkt} to the remote address\n         * that this {@link SocketContainer} should send packets to.\n         * @param pkt the packet for which to set the socket address.\n         */\n        private void setTarget(DatagramPacket pkt)\n        {\n            SocketAddress target;\n            // If the socket already has a remote address, use it. If this is\n            // the case, the DatagramPacket instance's remote address is likely\n            // to be ignored, anyway.\n            if (datagramSocket != null)\n            {\n                target = datagramSocket.getRemoteSocketAddress();\n            }\n            else\n            {\n                target = delegatingSocket.getRemoteSocketAddress();\n            }\n\n            // The socket doesn't always have a remote address (e.g. if it is\n            // an unconnected UDP socket from HostCandidateHarvester).\n            // In this case, we send to the source address of the last packet\n            // which was received and accepted, or to the address that was\n            // initialized via initializeActive (i.e. the address initially\n            // selected by ICE).\n            if (target == null)\n            {\n                target = this.remoteAddress;\n            }\n\n            pkt.setSocketAddress(target);\n        }\n\n        /**\n         * Notifies this {@link SocketContainer} that a particular\n         * {@link DatagramPacket} was received from it, and was accepted (as\n         * opposed to e.g. having been discarded due to its remote address not\n         * being authorized).\n         * @param pkt the accepted packet.\n         */\n        private void accepted(DatagramPacket pkt)\n        {\n            this.remoteAddress = pkt.getSocketAddress();\n        }\n\n        /**\n         * @return the underlying socket of this {@link SocketContainer}.\n         */\n        private Object getSocket()\n        {\n            return datagramSocket != null ? datagramSocket : delegatingSocket;\n        }\n\n        /**\n         * Closes this {@link SocketContainer}, stopping it's reading thread,\n         * and, if necessary removing it from the merging socket.\n         * @param remove whether to remove this container from the merging\n         * socket.\n         */\n        private void close(boolean remove)\n        {\n            if (closed)\n            {\n                return;\n            }\n            closed = true;\n\n            thread.interrupt();\n            if (remove)\n            {\n                MergingDatagramSocket.this.doRemove(getSocket());\n            }\n        }\n\n        /**\n         * Represents a {@link DatagramPacket} for the purposes of {@link\n         * SocketContainer}.\n         */\n        private class Buffer\n        {\n            /**\n             * The size of the buffer to allocate.\n             */\n            private static final int MAX_PACKET_SIZE = 1500;\n\n            /**\n             * The time at which this buffer was filled.\n             */\n            long receivedTime = -1;\n\n            /**\n             * The {@link DatagramPacket} wrapped by this {@link Buffer}.\n             */\n            DatagramPacket pkt\n                = new DatagramPacket(\n                new byte[MAX_PACKET_SIZE],\n                0,\n                MAX_PACKET_SIZE);\n\n            /**\n             * Prepares this {@link Buffer} for reuse.\n             */\n            private void reset()\n            {\n                receivedTime = -1;\n\n                // We are going to receive from a socket into this packet. If\n                // the length is insufficient it is going to truncate the data.\n                // So reset it to what we know is the underlying byte[]'s\n                // length.\n                pkt.setLength(MAX_PACKET_SIZE);\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Object socketContainersSyncRoot = new Object();", "docstring": "\nUsed to control access to {@link #socketContainers}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "socketContainersSyncRoot = new Object()", "syntax_pass": true}, {"attribute_expression": "private SocketContainer[] socketContainers = new SocketContainer[0];", "docstring": "\nStores the underlying sockets. Copy on write.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "SocketContainer[]", "name": "socketContainers = new SocketContainer[0]", "syntax_pass": true}, {"attribute_expression": "private final Object receiveLock = new Object();", "docstring": "\nCalls to {@link #receive(java.net.DatagramPacket)} will wait on this\nobject in case no packet is available for reading.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "receiveLock = new Object()", "syntax_pass": true}, {"attribute_expression": "private int soTimeout = 0;", "docstring": "\nIf non-zero, {@link #receive(java.net.DatagramPacket)} will attempt to\nreturn within this many milliseconds, and will throw a\n{@link SocketTimeoutException} if no packet has been read.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "soTimeout = 0", "syntax_pass": true}, {"attribute_expression": "protected SocketContainer active = null;", "docstring": "\nThe {@link SocketContainer} considered active, i.e. the one which should\nbe used for sending.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "SocketContainer", "name": "active = null", "syntax_pass": true}, {"attribute_expression": "private boolean closed = false;", "docstring": "\nThe flag which indicates whether this socket is closed.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "closed = false", "syntax_pass": true}, {"attribute_expression": "private int numDiscardedPackets = 0;", "docstring": "\nThe number of packets which were read from an underlying socket, but were\ndiscarded because they were not accepted by\n{@link #accept(DatagramPacket)}.\nAccess to this field should be protected by {@link #receiveLock}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "numDiscardedPackets = 0", "syntax_pass": true}, {"attribute_expression": "protected final Logger logger;", "docstring": "\nThe {@link Logger} used by {@link MergingDatagramSocket} instances.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Logger", "name": "logger", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket", "name": "DelegatingDatagramSocket", "file_path": "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java", "superclasses": "DatagramSocket", "methods": ["[void]setDefaultDelegateFactory(DatagramSocketFactory)", "[void]setDefaultReceiveBufferSize(int)", "[boolean]logNonStun(long)", "[]DelegatingDatagramSocket()", "[]DelegatingDatagramSocket(DatagramSocket)", "[]DelegatingDatagramSocket(int)", "[]DelegatingDatagramSocket(int,InetAddress)", "[]DelegatingDatagramSocket(SocketAddress)", "[]DelegatingDatagramSocket(DatagramSocket,SocketAddress)", "[void]bind(SocketAddress)", "[void]close()", "[void]connect(InetAddress,int)", "[void]connect(SocketAddress)", "[void]disconnect()", "[boolean]getBroadcast()", "[DatagramChannel]getChannel()", "[InetAddress]getInetAddress()", "[InetAddress]getLocalAddress()", "[int]getLocalPort()", "[SocketAddress]getLocalSocketAddress()", "[int]getPort()", "[int]getReceiveBufferSize()", "[SocketAddress]getRemoteSocketAddress()", "[boolean]getReuseAddress()", "[int]getSendBufferSize()", "[int]getSoTimeout()", "[int]getTrafficClass()", "[boolean]isBound()", "[boolean]isClosed()", "[boolean]isConnected()", "[void]receive(DatagramPacket)", "[void]send(DatagramPacket)", "[void]setBroadcast(boolean)", "[void]setReceiveBufferSize(int)", "[void]setReuseAddress(boolean)", "[void]setSendBufferSize(int)", "[void]setSoTimeout(int)", "[void]setTrafficClass(int)", "[void]initReceiveBufferSize()"], "method_uris": ["src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setDefaultDelegateFactory(DatagramSocketFactory)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setDefaultReceiveBufferSize(int)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[boolean]logNonStun(long)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[]DelegatingDatagramSocket()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[]DelegatingDatagramSocket(DatagramSocket)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[]DelegatingDatagramSocket(int)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[]DelegatingDatagramSocket(int,InetAddress)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[]DelegatingDatagramSocket(SocketAddress)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[]DelegatingDatagramSocket(DatagramSocket,SocketAddress)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]bind(SocketAddress)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]close()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]connect(InetAddress,int)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]connect(SocketAddress)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]disconnect()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[boolean]getBroadcast()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[DatagramChannel]getChannel()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[InetAddress]getInetAddress()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[InetAddress]getLocalAddress()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[int]getLocalPort()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[SocketAddress]getLocalSocketAddress()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[int]getPort()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[int]getReceiveBufferSize()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[SocketAddress]getRemoteSocketAddress()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[boolean]getReuseAddress()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[int]getSendBufferSize()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[int]getSoTimeout()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[int]getTrafficClass()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[boolean]isBound()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[boolean]isClosed()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[boolean]isConnected()", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]receive(DatagramPacket)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]send(DatagramPacket)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setBroadcast(boolean)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setReceiveBufferSize(int)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setReuseAddress(boolean)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setSendBufferSize(int)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setSoTimeout(int)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]setTrafficClass(int)", "src/main/java/org/ice4j/socket/DelegatingDatagramSocket.java.DelegatingDatagramSocket.[void]initReceiveBufferSize()"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a <tt>DatagramSocket</tt> which delegates its calls to a specific\n<tt>DatagramSocket</tt>.\n\n@author Lyubomir Marinov\n", "original_string": "public class DelegatingDatagramSocket\n    extends DatagramSocket\n{\n    /**\n     * Assigns a factory to generate custom DatagramSocket to replace classical\n     * \"java\" DatagramSocket. This way external applications can define the\n     * type of DatagramSocket to use.\n     * If \"null\", then the classical \"java\" DatagramSocket is used. Otherwise\n     * the factory generates custom DatagramSockets.\n     */\n    private static DatagramSocketFactory delegateFactory = null;\n\n    /**\n     * The size to which to set the receive buffer size. This value must set by\n     * using the DelegatingDatagramSocket.setDefaultReceiveBufferSize(int)\n     * function before calling the DelegatingDatagramSocket constructor and must\n     * be greater than 0 to be effective.\n     */\n    private static int defaultReceiveBufferSize = -1;\n\n    /**\n     * If a factory is provided, then any new instances of\n     * DelegatingDatagramSocket will automatically use a socket from  the\n     * factory instead of the super class.\n     *\n     * If this method is used, the factory class needs to ensure the socket\n     * objects are properly constructed and initialized - in particular, any\n     * default receive buffer size specified through\n     * DelegatingDatagramSocket#setDefaultReceiveBufferSize() won't\n     * automatically be applied to sockets obtain from the factory.\n     *\n     * @param factory The factory assigned to generates the new DatagramSocket\n     * for each new DelegatingDatagramSocket which do not use a delegate socket.\n     */\n    public static void setDefaultDelegateFactory(DatagramSocketFactory factory)\n    {\n        delegateFactory = factory;\n    }\n\n    /**\n     * Specifies a default receive buffer size for the underlying sockets.\n     * This function must be called before using the DelegatingDatagramSocket\n     * constructor. The size must be greater than 0 to be effective.\n     *\n     * @see DatagramSocket#setReceiveBufferSize(int) for a discussion of the\n     * effect of changing this setting.\n     *\n     * @param size the size to which to set the receive buffer size. This value\n     * must be greater than 0.\n     */\n    public static void setDefaultReceiveBufferSize(int size)\n    {\n        defaultReceiveBufferSize = size;\n    }\n\n    /**\n     * Determines whether a packet should be logged, given the number of sent\n     * or received packets.\n     *\n     * @param numOfPacket the number of packets sent or received.\n     */\n    static boolean logNonStun(long numOfPacket)\n    {\n        return (numOfPacket == 1)\n                || (numOfPacket == 300)\n                || (numOfPacket == 500)\n                || (numOfPacket == 1000)\n                || ((numOfPacket % 5000) == 0);\n    }\n\n    /**\n     * The <tt>DatagramSocket</tt> to which this\n     * <tt>DelegatingDatagramSocket</tt> delegates its calls.\n     */\n    protected final DatagramSocket delegate;\n\n    /**\n     * The number of non-STUN packets received on this socket.\n     */\n    private long nbReceivedPackets = 0;\n\n    /**\n     * The number of non-STUN packets sent through this socket.\n     */\n    private long nbSentPackets = 0;\n\n    /**\n     * Whether this socket has been closed.\n     */\n    private boolean closed = false;\n\n    /**\n     * Initializes a new <tt>DelegatingDatagramSocket</tt> instance and binds it\n     * to any available port on the local host machine.  The socket will be\n     * bound to the wildcard address, an IP address chosen by the kernel.\n     *\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     * @see DatagramSocket#DatagramSocket()\n     */\n    public DelegatingDatagramSocket()\n        throws SocketException\n    {\n        this(null, new InetSocketAddress(0));\n    }\n\n    /**\n     * Initializes a new <tt>DelegatingDatagramSocket</tt> instance which to\n     * implement the <tt>DatagramSocket</tt> functionality by delegating to a\n     * specific <tt>DatagramSocket</tt>.\n     *\n     * @param delegate the <tt>DatagramSocket</tt> to which the new instance is\n     * to delegate\n     * @throws SocketException if anything goes wrong while initializing the new\n     * <tt>DelegatingDatagramSocket</tt> instance\n     */\n    public DelegatingDatagramSocket(DatagramSocket delegate)\n        throws SocketException\n    {\n        this(delegate, null);\n    }\n\n    /**\n     * Initializes a new <tt>DelegatingDatagramSocket</tt> instance  and binds\n     * it to the specified port on the local host machine.  The socket will be\n     * bound to the wildcard address, an IP address chosen by the kernel.\n     *\n     * @param port the port to bind the new socket to\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     * @see DatagramSocket#DatagramSocket(int)\n     */\n    public DelegatingDatagramSocket(int port)\n        throws SocketException\n    {\n        this(null, new InetSocketAddress(port));\n    }\n\n    /**\n     * Initializes a new <tt>DelegatingDatagramSocket</tt> instance bound to the\n     * specified local address.  The local port must be between 0 and 65535\n     * inclusive. If the IP address is 0.0.0.0, the socket will be bound to the\n     * wildcard address, an IP address chosen by the kernel.\n     *\n     * @param port the local port to bind the new socket to\n     * @param laddr the local address to bind the new socket to\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     * @see DatagramSocket#DatagramSocket(int, InetAddress)\n     */\n    public DelegatingDatagramSocket(int port, InetAddress laddr)\n        throws SocketException\n    {\n        this(null, new InetSocketAddress(laddr, port));\n    }\n\n    /**\n     * Creates a datagram socket, bound to the specified local socket address.\n     * <p>\n     * If, if the address is <tt>null</tt>, creates an unbound socket.\n     * </p>\n     *\n     * @param bindaddr local socket address to bind, or <tt>null</tt> for an\n     * unbound socket\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port\n     */\n    public DelegatingDatagramSocket(SocketAddress bindaddr)\n        throws SocketException\n    {\n        this(null, bindaddr);\n    }\n\n    /**\n     * Initializes a new <tt>DelegatingDatagramSocket</tt> instance which\n     * implements the <tt>DatagramSocket</tt> functionality. If delegate is not\n     * null, then the DatagramSocket functionality is delegated to a specific\n     * <tt>DatagramSocket</tt>.\n     *\n     * @param delegate the <tt>DatagramSocket</tt> to which the new instance is\n     * to delegate.\n     * @param address The local socket address to bind, or <tt>null</tt> for an\n     * unbound socket.\n     *\n     * @throws SocketException if the socket could not be opened, or the socket\n     * could not bind to the specified local port.\n     */\n    public DelegatingDatagramSocket(\n            DatagramSocket delegate,\n            SocketAddress address)\n        throws SocketException\n    {\n        super((SocketAddress) null);\n\n        // Delegates the DatagramSocket functionality to the DatagramSocket\n        // given in parameter.\n        if (delegate != null)\n        {\n            this.delegate = delegate;\n        }\n        else\n        {\n            // Creates a custom DatagramSocket to replace classical \"java\"\n            // DatagramSocket and set it as a delegate Socket\n            if (delegateFactory != null)\n            {\n                this.delegate = delegateFactory.createUnboundDatagramSocket();\n            }\n            // Creates a socket directly connected to the network stack.\n            else\n            {\n                this.delegate = null;\n                initReceiveBufferSize();\n            }\n            // If not null, binds the delegate socket to the given address.\n            // Otherwise bind the \"super\" socket to this address.\n            bind(address);\n        }\n    }\n\n    /**\n     * Binds this <tt>DatagramSocket</tt> to a specific address and port.\n     * <p>\n     * If the address is <tt>null</tt>, then the system will pick up an\n     * ephemeral port and a valid local address to bind the socket.\n     *</p>\n     *\n     * @param addr the address and port to bind to\n     * @throws SocketException if any error happens during the bind, or if the\n     * socket is already bound\n     * @throws SecurityException if a security manager exists and its\n     * <tt>checkListen</tt> method doesn't allow the operation\n     * @throws IllegalArgumentException if <tt>addr</tt> is a\n     * <tt>SocketAddress</tt> subclass not supported by this socket\n     * @see DatagramSocket#bind(SocketAddress)\n     */\n    @Override\n    public void bind(SocketAddress addr)\n            throws SocketException\n    {\n        if (delegate == null)\n            super.bind(addr);\n        else\n            delegate.bind(addr);\n    }\n\n    /**\n     * Closes this datagram socket.\n     * <p>\n     * Any thread currently blocked in {@link #receive(DatagramPacket)} upon\n     * this socket will throw a {@link SocketException}.\n     * </p>\n     *\n     * @see DatagramSocket#close()\n     */\n    @Override\n    public void close()\n    {\n        // We want both #delegate and super to actually get closed (and release\n        // the FDs which they hold). But super will not close unless isClosed()\n        // returns false. So we update the #closed flag last.\n        if (delegate != null)\n            delegate.close();\n\n        super.close();\n        closed = true;\n    }\n\n    /**\n     * Connects the socket to a remote address for this socket. When a socket is\n     * connected to a remote address, packets may only be sent to or received\n     * from that address. By default a datagram socket is not connected.\n     * <p>\n     * If the remote destination to which the socket is connected does not\n     * exist, or is otherwise unreachable, and if an ICMP destination\n     * unreachable packet has been received for that address, then a subsequent\n     * call to {@link #send(DatagramPacket)} or {@link #receive(DatagramPacket)}\n     * may throw a <tt>PortUnreachableException</tt>. Note, there is no\n     * guarantee that the exception will be thrown.\n     * </p>\n     *\n     * @param address the remote address for the socket\n     * @param port the remote port for the socket\n     * @throws IllegalArgumentException if the address is <tt>null</tt>, or the\n     * port is out of range\n     * @throws SecurityException if the caller is not allowed to send datagrams\n     * to and receive datagrams from the address and port\n     * @see DatagramSocket#connect(InetAddress, int)\n     */\n    @Override\n    public void connect(InetAddress address, int port)\n    {\n        if (delegate == null)\n            super.connect(address, port);\n        else\n            delegate.connect(address, port);\n    }\n\n    /**\n     * Connects this socket to a remote socket address.\n     *\n     * @param addr the remote address\n     * @throws SocketException if the connect fails\n     * @throws IllegalArgumentException if <tt>addr</tt> is <tt>null</tt> or a\n     * <tt>SocketAddress</tt> subclass not supported by this socket\n     * @see DatagramSocket#connect(SocketAddress)\n     */\n    @Override\n    public void connect(SocketAddress addr)\n        throws SocketException\n    {\n        if (delegate == null)\n            super.connect(addr);\n        else\n            delegate.connect(addr);\n    }\n\n    /**\n     * Disconnects the socket. This does nothing if the socket is not connected.\n     *\n     * @see DatagramSocket#disconnect()\n     */\n    @Override\n    public void disconnect()\n    {\n        if (delegate == null)\n            super.disconnect();\n        else\n            delegate.disconnect();\n    }\n\n    /**\n     * Tests if <tt>SO_BROADCAST</tt> is enabled.\n     *\n     * @return a <tt>boolean</tt> indicating whether or not\n     * <tt>SO_BROADCAST</tt> is enabled\n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as an UDP error\n     * @see DatagramSocket#getBroadcast()\n     */\n    @Override\n    public boolean getBroadcast()\n        throws SocketException\n    {\n        return\n            (delegate == null) ? super.getBroadcast() : delegate.getBroadcast();\n    }\n\n    /**\n     * Returns the unique {@link DatagramChannel} object associated with this\n     * datagram socket, if any.\n     * <p>\n     * A datagram socket will have a channel if, and only if, the channel itself\n     * was created via the {@link DatagramChannel#open()} method\n     * </p>\n     *\n     * @return the datagram channel associated with this datagram socket, or\n     * <tt>null</tt> if this socket was not created for a channel\n     * @see DatagramSocket#getChannel()\n     */\n    @Override\n    public DatagramChannel getChannel()\n    {\n        return (delegate == null) ? super.getChannel() : delegate.getChannel();\n    }\n\n    /**\n     * Returns the address to which this socket is connected. Returns\n     * <tt>null</tt> if the socket is not connected.\n     *\n     * @return the address to which this socket is connected\n     * @see DatagramSocket#getInetAddress()\n     */\n    @Override\n    public InetAddress getInetAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getInetAddress()\n                : delegate.getInetAddress();\n    }\n\n    /**\n     * Gets the local address to which the socket is bound.\n     * <p>\n     * If there is a security manager, its <tt>checkConnect</tt> method is first\n     * called with the host address and <tt>-1</tt> as its arguments to see if\n     * the operation is allowed.\n     *\n     * @return the local address to which the socket is bound, or an\n     * <tt>InetAddress</tt> representing any local address if either the socket\n     * is not bound, or the security manager <tt>checkConnect</tt> method does\n     * not allow the operation\n     * @see DatagramSocket#getLocalAddress()\n     */\n    @Override\n    public InetAddress getLocalAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getLocalAddress()\n                : delegate.getLocalAddress();\n    }\n\n    /**\n     * Returns the port number on the local host to which this socket is bound.\n     *\n     * @return the port number on the local host to which this socket is bound\n     * @see DatagramSocket#getLocalPort()\n     */\n    @Override\n    public int getLocalPort()\n    {\n        return\n            (delegate == null) ? super.getLocalPort() : delegate.getLocalPort();\n    }\n\n    /**\n     * Returns the address of the endpoint this socket is bound to, or\n     * <tt>null</tt> if it is not bound yet.\n     *\n     * @return a <tt>SocketAddress</tt> representing the local endpoint of this\n     * socket, or <tt>null</tt> if it is not bound yet\n     * @see DatagramSocket#getLocalSocketAddress()\n     */\n    @Override\n    public SocketAddress getLocalSocketAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getLocalSocketAddress()\n                : delegate.getLocalSocketAddress();\n    }\n\n    /**\n     * Returns the port for this socket. Returns <tt>-1</tt> if the socket is\n     * not connected.\n     *\n     * @return the port to which this socket is connected\n     * @see DatagramSocket#getPort()\n     */\n    @Override\n    public int getPort()\n    {\n        return (delegate == null) ? super.getPort() : delegate.getPort();\n    }\n\n    /**\n     * Gets the value of the <tt>SO_RCVBUF</tt> option for this\n     * <tt>DatagramSocket</tt>, that is the buffer size used by the platform for\n     * input on this <tt>DatagramSocket</tt>.\n     *\n     * @return the value of the <tt>SO_RCVBUF</tt> option for this\n     * <tt>DatagramSocket</tt>\n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as an UDP error\n     * @see DatagramSocket#getReceiveBufferSize()\n     */\n    @Override\n    public int getReceiveBufferSize()\n        throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getReceiveBufferSize()\n                : delegate.getReceiveBufferSize();\n    }\n\n    /**\n     * Returns the address of the endpoint this socket is connected to, or\n     * <tt>null</tt> if it is unconnected.\n     *\n     * @return a <tt>SocketAddress</tt> representing the remote endpoint of this\n     * socket, or <tt>null</tt> if it is not connected yet\n     * @see DatagramSocket#getRemoteSocketAddress()\n     */\n    @Override\n    public SocketAddress getRemoteSocketAddress()\n    {\n        return\n            (delegate == null)\n                ? super.getRemoteSocketAddress()\n                : delegate.getRemoteSocketAddress();\n    }\n\n    /**\n     * Tests if <tt>SO_REUSEADDR</tt> is enabled.\n     *\n     * @return a <tt>boolean</tt> indicating whether or not\n     * <tt>SO_REUSEADDR</tt> is enabled\n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as an UDP error\n     * @see DatagramSocket#getReuseAddress()\n     */\n    @Override\n    public boolean getReuseAddress()\n        throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getReuseAddress()\n                : delegate.getReuseAddress();\n    }\n\n    /**\n     * Gets the value of the <tt>SO_SNDBUF</tt> option for this\n     * <tt>DatagramSocket</tt>, that is the buffer size used by the platform for\n     * output on this <tt>DatagramSocket</tt>.\n     *\n     * @return the value of the <tt>SO_SNDBUF</tt> option for this\n     * <tt>DatagramSocket</tt>\n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as an UDP error\n     * @see DatagramSocket#getSendBufferSize()\n     */\n    @Override\n    public int getSendBufferSize()\n        throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getSendBufferSize()\n                : delegate.getSendBufferSize();\n    }\n\n    /**\n     * Retrieves setting for <tt>SO_TIMEOUT</tt>.  Zero returned implies that\n     * the option is disabled (i.e., timeout of infinity).\n     *\n     * @return the setting for <tt>SO_TIMEOUT</tt>\n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as an UDP error\n     * @see DatagramSocket#getSoTimeout()\n     */\n    @Override\n    public int getSoTimeout()\n        throws SocketException\n    {\n        return\n            (delegate == null) ? super.getSoTimeout() : delegate.getSoTimeout();\n    }\n\n    /**\n     * Gets the traffic class or type-of-service in the IP datagram header for\n     * packets sent from this <tt>DatagramSocket</tt>.\n     * <p>\n     * As the underlying network implementation may ignore the traffic class or\n     * type-of-service set using {@link #setTrafficClass(int)} this method may\n     * return a different value than was previously set using the\n     * {@link #setTrafficClass(int)} method on this <tt>DatagramSocket</tt>.\n     * </p>\n     *\n     * @return the traffic class or type-of-service already set\n     * @throws SocketException if there is an error obtaining the traffic class\n     * or type-of-service value\n     * @see DatagramSocket#getTrafficClass()\n     */\n    @Override\n    public int getTrafficClass()\n        throws SocketException\n    {\n        return\n            (delegate == null)\n                ? super.getTrafficClass()\n                : delegate.getTrafficClass();\n    }\n\n    /**\n     * Returns the binding state of the socket.\n     *\n     * @return <tt>true</tt> if the socket successfully bound to an address;\n     * otherwise, <tt>false</tt>\n     * @see DatagramSocket#isBound()\n     */\n    @Override\n    public boolean isBound()\n    {\n        return (delegate == null) ? super.isBound() : delegate.isBound();\n    }\n\n    /**\n     * Returns whether the socket is closed or not.\n     *\n     * @return <tt>true</tt> if the socket has been closed; otherwise,\n     * <tt>false</tt>\n     * @see DatagramSocket#isClosed()\n     */\n    @Override\n    public boolean isClosed()\n    {\n        return closed;\n    }\n\n    /**\n     * Returns the connection state of the socket.\n     *\n     * @return <tt>true</tt> if the socket successfully connected to a server;\n     * otherwise, <tt>false</tt>\n     * @see DatagramSocket#isConnected()\n     */\n    @Override\n    public boolean isConnected()\n    {\n        return (delegate == null) ? super.isConnected() :\n            delegate.isConnected();\n    }\n\n    /**\n     * Receives a datagram packet from this socket. When this method returns,\n     * the <tt>DatagramPacket</tt>'s buffer is filled with the data received.\n     * The datagram packet also contains the sender's IP address, and the port\n     * number on the sender's machine.\n     * <p>\n     * This method blocks until a datagram is received. The <tt>length</tt>\n     * field of the datagram packet object contains the length of the received\n     * message. If the message is longer than the packet's length, the message\n     * is truncated.\n     * </p>\n     * <p>\n     * If there is a security manager, a packet cannot be received if the\n     * security manager's <tt>checkAccept</tt> method does not allow it.\n     * </p>\n     *\n     * @param p the <tt>DatagramPacket</tt> into which to place the incoming\n     * data\n     * @throws IOException if an I/O error occurs\n     * @see DatagramSocket#receive(DatagramPacket)\n     */\n    @Override\n    public void receive(DatagramPacket p)\n        throws IOException\n    {\n        if (delegate == null)\n        {\n            // If the packet length is too small, then the\n            // DatagramSocket.receive function will truncate the received\n            // datagram. This problem appears when reusing the same\n            // DatagramPacket i.e. if the first time we use the DatagramPacket\n            // to receive a small packet and the second time a bigger one, then\n            // after the first packet is received, the length is set to the size\n            // of the first packet and the second packet is truncated.\n            // http://docs.oracle.com/javase/6/docs/api/java/net/DatagramSocket.html\n            //\n            // XXX(boris): I think the above is wrong. I don't interpret the\n            // API description this way, and testing on a couple of different\n            // environments shows that  DatagramSocket.receive() grows the\n            // packet's length to as much as much as the array (and offset)\n            // would allow. I am leaving the code because it seems harmless.\n            byte[] data = p.getData();\n\n            p.setLength((data == null) ? 0 : (data.length - p.getOffset()));\n\n            super.receive(p);\n\n            if (StunDatagramPacketFilter.isStunPacket(p)\n                    || logNonStun(++nbReceivedPackets))\n            {\n                StunStack.logPacketToPcap(\n                        p,\n                        false,\n                        getLocalAddress(),\n                        getLocalPort());\n            }\n        }\n        else\n        {\n            delegate.receive(p);\n        }\n    }\n\n    /**\n     * Sends a datagram packet from this socket. The <tt>DatagramPacket</tt>\n     * includes information indicating the data to be sent, its length, the IP\n     * address of the remote host, and the port number on the remote host.\n     * <p>\n     * If there is a security manager, and the socket is not currently connected\n     * to a remote address, this method first performs some security checks.\n     * First, if <tt>p.getAddress().isMulticastAddress()</tt> is true, this\n     * method calls the security manager's <tt>checkMulticast</tt> method with\n     * <tt>p.getAddress()</tt> as its argument. If the evaluation of that\n     * expression is <tt>false</tt>, this method instead calls the security\n     * manager's <tt>checkConnect</tt> method with arguments\n     * <tt>p.getAddress().getHostAddress()</tt> and <tt>p.getPort()</tt>. Each\n     * call to a security manager method could result in a\n     * <tt>SecurityException</tt> if the operation is not allowed.\n     * </p>\n     *\n     * @param p the <tt>DatagramPacket</tt> to be sent\n     * @throws IOException if an I/O error occurs\n     * @see DatagramSocket#send(DatagramPacket)\n     */\n    @Override\n    public void send(DatagramPacket p)\n        throws IOException\n    {\n        // Sends the packet to the final DatagramSocket\n        if (delegate == null)\n        {\n            try\n            {\n                super.send(p);\n            }\n            // DIRTY, DIRTY, DIRTY!!!\n            // Here we correct a java under MAC OSX bug when dealing with\n            // ipv6 local interface: the destination address (as well as the\n            // source address) under java / MAC OSX must have a scope ID,\n            // i.e.  \"fe80::1%en1\".  This correction (the whole \"catch\") is to\n            // be removed as soon as java under MAC OSX implements a real ipv6\n            // network stack.\n            catch(Exception ex)\n            {\n                InetAddress tmpAddr = p.getAddress();\n                if (((ex instanceof NoRouteToHostException)\n                            || (ex.getMessage() != null\n                                && ex.getMessage().equals(\"No route to host\")))\n                        && (tmpAddr instanceof Inet6Address)\n                        && (tmpAddr.isLinkLocalAddress()))\n                {\n                    Inet6Address newAddr = Inet6Address.getByAddress(\n                            \"\",\n                            tmpAddr.getAddress(),\n                            ((Inet6Address) super.getLocalAddress())\n                            .getScopeId());\n                    p.setAddress(newAddr);\n\n                    super.send(p);\n                }\n                else if (ex instanceof IOException)\n                {\n                    throw((IOException)ex);\n                }\n           }\n\n            if (logNonStun(++nbSentPackets))\n            {\n                StunStack.logPacketToPcap(\n                        p,\n                        true,\n                        getLocalAddress(),\n                        getLocalPort());\n            }\n        }\n        // Else, the delegate socket will encapsulate the packet.\n        else\n        {\n            delegate.send(p);\n        }\n    }\n\n    /**\n     * Enables/disables <tt>SO_BROADCAST</tt>.\n     *\n     * @param on whether or not to have broadcast turned on\n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as an UDP error\n     * @see DatagramSocket#setBroadcast(boolean)\n     */\n    @Override\n    public void setBroadcast(boolean on)\n        throws SocketException\n    {\n        if (delegate == null)\n            super.setBroadcast(on);\n        else\n            delegate.setBroadcast(on);\n    }\n\n    /**\n     * Sets the <tt>SO_RCVBUF</tt> option to the specified value for this\n     * <tt>DatagramSocket</tt>. The <tt>SO_RCVBUF</tt> option is used by the\n     * network implementation as a hint to size the underlying network I/O\n     * buffers. The <tt>SO_RCVBUF</tt> setting may also be used by the network\n     * implementation to determine the maximum size of the packet that can be\n     * received on this socket.\n     * <p>\n     * Because <tt>SO_RCVBUF</tt> is a hint, applications that want to verify\n     * what size the buffers were set to should call\n     * {@link #getReceiveBufferSize()}.\n     * </p>\n     *\n     * @param size the size to which to set the receive buffer size. The value\n     * must be greater than zero\n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as an UDP error\n     * @throws IllegalArgumentException if the value is zero or is negative\n     * @see DatagramSocket#setReceiveBufferSize(int)\n     */\n    @Override\n    public void setReceiveBufferSize(int size)\n        throws SocketException\n    {\n        if (delegate == null)\n            super.setReceiveBufferSize(size);\n        else\n            delegate.setReceiveBufferSize(size);\n    }\n\n    /**\n     * Enables/disables the <tt>SO_REUSEADDR</tt> socket option.\n     *\n     * @param on whether to enable or disable the <tt>SO_REUSEADDR</tt> socket\n     * option\n     * @throws SocketException if an error occurs enabling or disabling the\n     * <tt>SO_RESUEADDR</tt> socket option, or the socket is closed\n     * @see DatagramSocket#setReuseAddress(boolean)\n     */\n    @Override\n    public void setReuseAddress(boolean on)\n        throws SocketException\n    {\n        if (delegate == null)\n            super.setReuseAddress(on);\n        else\n            delegate.setReuseAddress(on);\n    }\n\n    /**\n     * Sets the <tt>SO_SNDBUF</tt> option to the specified value for this\n     * <tt>DatagramSocket</tt>. The <tt>SO_SNDBUF</tt> option is used by the\n     * network implementation as a hint to size the underlying network I/O\n     * buffers. The <tt>SO_SNDBUF</tt> setting may also be used by the network\n     * implementation to determine the maximum size of the packet that can be\n     * sent on this socket.\n     * <p>\n     * As <tt>SO_SNDBUF</tt> is a hint, applications that want to verify what\n     * size the buffer is should call {@link #getSendBufferSize()}.\n     * </p>\n     * <p>\n     * Increasing the buffer size may allow multiple outgoing packets to be\n     * queued by the network implementation when the send rate is high.\n     * </p>\n     *\n     * @param size the size to which to set the send buffer size. The value must\n     * be greater than zero\n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as an UDP error\n     * @throws IllegalArgumentException if the value is zero or is negative\n     * @see DatagramSocket#setSendBufferSize(int)\n     */\n    @Override\n    public void setSendBufferSize(int size)\n        throws SocketException\n    {\n        if (delegate == null)\n            super.setSendBufferSize(size);\n        else\n            delegate.setSendBufferSize(size);\n    }\n\n    /**\n     * Enables/disables <tt>SO_TIMEOUT</tt> with the specified timeout, in\n     * milliseconds. With this option set to a non-zero timeout, a call to\n     * {@link #receive(DatagramPacket)} for this <tt>DatagramSocket</tt> will\n     * block for only this amount of time.  If the timeout expires, a\n     * <tt>SocketTimeoutException</tt> is raised, though the\n     * <tt>DatagramSocket</tt> is still valid.  The option must be enabled prior\n     * to entering the blocking operation to have effect.  The timeout must be\n     * greater than zero. A timeout of zero is interpreted as an infinite\n     * timeout.\n     *\n     * @param timeout the specified timeout in milliseconds\n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as an UDP error\n     * @see DatagramSocket#setSoTimeout(int)\n     */\n    @Override\n    public void setSoTimeout(int timeout)\n        throws SocketException\n    {\n        if (delegate == null)\n            super.setSoTimeout(timeout);\n        else\n            delegate.setSoTimeout(timeout);\n    }\n\n    /**\n     * Sets traffic class or type-of-service octet in the IP datagram header for\n     * datagrams sent from this <tt>DatagramSocket</tt>. As the underlying\n     * network implementation may ignore this value applications should consider\n     * it a hint.\n     *\n     * @param tc an <tt>int</tt> value for the bitset\n     * @throws SocketException if there is an error setting the traffic class or\n     * type-of-service\n     * @see DatagramSocket#setTrafficClass(int)\n     */\n    @Override\n    public void setTrafficClass(int tc)\n        throws SocketException\n    {\n        if (delegate == null)\n            super.setTrafficClass(tc);\n        else\n            delegate.setTrafficClass(tc);\n    }\n\n\n    /**\n     * A utility method used by the constructors to ensure the receive buffer\n     * size is set to the preferred default.\n     * \n     * This implementation only has an impact of there is no delegate, in other\n     * words, if we really are using the superclass socket implementation as the\n     * raw socket.\n     * \n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as an UDP error.\n     */\n    private void initReceiveBufferSize()\n        throws SocketException\n    {\n        // Only change the buffer size on the real underlying DatagramSocket.\n        if (delegate == null && defaultReceiveBufferSize > 0)\n        {\n            super.setReceiveBufferSize(defaultReceiveBufferSize);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static DatagramSocketFactory delegateFactory = null;", "docstring": "\nAssigns a factory to generate custom DatagramSocket to replace classical\n\"java\" DatagramSocket. This way external applications can define the\ntype of DatagramSocket to use.\nIf \"null\", then the classical \"java\" DatagramSocket is used. Otherwise\nthe factory generates custom DatagramSockets.\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "DatagramSocketFactory", "name": "delegateFactory = null", "syntax_pass": true}, {"attribute_expression": "private static int defaultReceiveBufferSize = -1;", "docstring": "\nThe size to which to set the receive buffer size. This value must set by\nusing the DelegatingDatagramSocket.setDefaultReceiveBufferSize(int)\nfunction before calling the DelegatingDatagramSocket constructor and must\nbe greater than 0 to be effective.\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "int", "name": "defaultReceiveBufferSize = -1", "syntax_pass": true}, {"attribute_expression": "protected final DatagramSocket delegate;", "docstring": "\nThe <tt>DatagramSocket</tt> to which this\n<tt>DelegatingDatagramSocket</tt> delegates its calls.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "DatagramSocket", "name": "delegate", "syntax_pass": true}, {"attribute_expression": "private long nbReceivedPackets = 0;", "docstring": "\nThe number of non-STUN packets received on this socket.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "nbReceivedPackets = 0", "syntax_pass": true}, {"attribute_expression": "private long nbSentPackets = 0;", "docstring": "\nThe number of non-STUN packets sent through this socket.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "long", "name": "nbSentPackets = 0", "syntax_pass": true}, {"attribute_expression": "private boolean closed = false;", "docstring": "\nWhether this socket has been closed.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "closed = false", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper", "name": "IceTcpServerSocketWrapper", "file_path": "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java", "superclasses": "IceSocketWrapper", "methods": ["[]IceTcpServerSocketWrapper(ServerSocket,Component)", "[void]send(DatagramPacket)", "[void]receive(DatagramPacket)", "[void]close()", "[InetAddress]getLocalAddress()", "[int]getLocalPort()", "[SocketAddress]getLocalSocketAddress()", "[Socket]getTCPSocket()", "[DatagramSocket]getUDPSocket()"], "method_uris": ["src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[]IceTcpServerSocketWrapper(ServerSocket,Component)", "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[void]send(DatagramPacket)", "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[void]receive(DatagramPacket)", "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[void]close()", "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[InetAddress]getLocalAddress()", "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[int]getLocalPort()", "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[SocketAddress]getLocalSocketAddress()", "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[Socket]getTCPSocket()", "src/main/java/org/ice4j/socket/IceTcpServerSocketWrapper.java.IceTcpServerSocketWrapper.[DatagramSocket]getUDPSocket()"], "overrides": null, "attributes": [{"original_string": "    private class ThreadAccept extends Thread\n    {\n        /**\n         * Thread entry point.\n         */\n        @Override\n        public void run()\n        {\n            isRun = true;\n\n            while (isRun)\n            {\n                try\n                {\n                    Socket tcpSocket = serverSocket.accept();\n\n                    if (tcpSocket != null)\n                    {\n                        MultiplexingSocket multiplexingSocket =\n                            new MultiplexingSocket(tcpSocket);\n                        component.getParentStream().getParentAgent().\n                            getStunStack().addSocket(\n                                new IceTcpSocketWrapper(multiplexingSocket));\n                        ComponentSocket componentSocket\n                            = component.getComponentSocket();\n                        if (componentSocket != null)\n                        {\n                            componentSocket.add(multiplexingSocket);\n                        }\n\n                        sockets.add(multiplexingSocket);\n                    }\n                }\n                catch(IOException e)\n                {\n                    logger.info(\"Failed to accept TCP socket \" + e);\n                }\n            }\n        }\n    }", "definition": "    private class ThreadAccept extends Thread", "class_docstring": "\nThread that will wait for new TCP connections.\n\n@author Sebastien Vincent\n", "name": "ThreadAccept", "super_interfaces": [], "superclasses": "Thread", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public void run()\n        {\n            isRun = true;\n\n            while (isRun)\n            {\n                try\n                {\n                    Socket tcpSocket = serverSocket.accept();\n\n                    if (tcpSocket != null)\n                    {\n                        MultiplexingSocket multiplexingSocket =\n                            new MultiplexingSocket(tcpSocket);\n                        component.getParentStream().getParentAgent().\n                            getStunStack().addSocket(\n                                new IceTcpSocketWrapper(multiplexingSocket));\n                        ComponentSocket componentSocket\n                            = component.getComponentSocket();\n                        if (componentSocket != null)\n                        {\n                            componentSocket.add(multiplexingSocket);\n                        }\n\n                        sockets.add(multiplexingSocket);\n                    }\n                }\n                catch(IOException e)\n                {\n                    logger.info(\"Failed to accept TCP socket \" + e);\n                }\n            }\n        }", "docstring": "\nThread entry point.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "run", "params": [], "body": "        {\n            isRun = true;\n\n            while (isRun)\n            {\n                try\n                {\n                    Socket tcpSocket = serverSocket.accept();\n\n                    if (tcpSocket != null)\n                    {\n                        MultiplexingSocket multiplexingSocket =\n                            new MultiplexingSocket(tcpSocket);\n                        component.getParentStream().getParentAgent().\n                            getStunStack().addSocket(\n                                new IceTcpSocketWrapper(multiplexingSocket));\n                        ComponentSocket componentSocket\n                            = component.getComponentSocket();\n                        if (componentSocket != null)\n                        {\n                            componentSocket.add(multiplexingSocket);\n                        }\n\n                        sockets.add(multiplexingSocket);\n                    }\n                }\n                catch(IOException e)\n                {\n                    logger.info(\"Failed to accept TCP socket \" + e);\n                }\n            }\n        }", "signature": "@Override\n        public void run()"}]}], "class_docstring": "\nTCP Server Socket wrapper.\n\n@author Sebastien Vincent\n", "original_string": "public class IceTcpServerSocketWrapper\n    extends IceSocketWrapper\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>LocalCandidate</tt> class and its\n     * instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(IceTcpServerSocketWrapper.class.getName());\n\n    /**\n     * Thread that will wait new connections.\n     */\n    private Thread acceptThread = null;\n\n    /**\n     * The wrapped TCP ServerSocket.\n     */\n    private final ServerSocket serverSocket;\n\n    /**\n     * If the socket is still listening.\n     */\n    private boolean isRun = false;\n\n    /**\n     * STUN stack.\n     */\n    private final Component component;\n\n    /**\n     * List of TCP client sockets.\n     */\n    private final List<Socket> sockets = new ArrayList<>();\n\n    /**\n     * Initializes a new <tt>IceTcpServerSocketWrapper</tt>.\n     *\n     * @param serverSocket TCP <tt>ServerSocket</tt>\n     * @param component related <tt>Component</tt>\n     */\n    public IceTcpServerSocketWrapper(ServerSocket serverSocket,\n        Component component)\n    {\n        this.serverSocket = serverSocket;\n        this.component = component;\n        acceptThread = new ThreadAccept();\n        acceptThread.start();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void send(DatagramPacket p) throws IOException\n    {\n        /* Do nothing for the moment */\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void receive(DatagramPacket p) throws IOException\n    {\n        /* Do nothing for the moment */\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void close()\n    {\n        try\n        {\n            isRun = false;\n            serverSocket.close();\n            for (Socket s : sockets)\n            {\n                s.close();\n            }\n        }\n        catch(IOException e)\n        {\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public InetAddress getLocalAddress()\n    {\n        return serverSocket.getInetAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getLocalPort()\n    {\n        return serverSocket.getLocalPort();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SocketAddress getLocalSocketAddress()\n    {\n        return serverSocket.getLocalSocketAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Socket getTCPSocket()\n    {\n        if (sockets.size() > 0)\n        {\n            return sockets.get(0);\n        }\n\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public DatagramSocket getUDPSocket()\n    {\n        return null;\n    }\n\n    /**\n     * Thread that will wait for new TCP connections.\n     *\n     * @author Sebastien Vincent\n     */\n    private class ThreadAccept extends Thread\n    {\n        /**\n         * Thread entry point.\n         */\n        @Override\n        public void run()\n        {\n            isRun = true;\n\n            while (isRun)\n            {\n                try\n                {\n                    Socket tcpSocket = serverSocket.accept();\n\n                    if (tcpSocket != null)\n                    {\n                        MultiplexingSocket multiplexingSocket =\n                            new MultiplexingSocket(tcpSocket);\n                        component.getParentStream().getParentAgent().\n                            getStunStack().addSocket(\n                                new IceTcpSocketWrapper(multiplexingSocket));\n                        ComponentSocket componentSocket\n                            = component.getComponentSocket();\n                        if (componentSocket != null)\n                        {\n                            componentSocket.add(multiplexingSocket);\n                        }\n\n                        sockets.add(multiplexingSocket);\n                    }\n                }\n                catch(IOException e)\n                {\n                    logger.info(\"Failed to accept TCP socket \" + e);\n                }\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(IceTcpServerSocketWrapper.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>LocalCandidate</tt> class and its\ninstances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(IceTcpServerSocketWrapper.class.getName())", "syntax_pass": true}, {"attribute_expression": "private Thread acceptThread = null;", "docstring": "\nThread that will wait new connections.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Thread", "name": "acceptThread = null", "syntax_pass": true}, {"attribute_expression": "private final ServerSocket serverSocket;", "docstring": "\nThe wrapped TCP ServerSocket.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ServerSocket", "name": "serverSocket", "syntax_pass": true}, {"attribute_expression": "private boolean isRun = false;", "docstring": "\nIf the socket is still listening.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "isRun = false", "syntax_pass": true}, {"attribute_expression": "private final Component component;", "docstring": "\nSTUN stack.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Component", "name": "component", "syntax_pass": true}, {"attribute_expression": "private final List<Socket> sockets = new ArrayList<>();", "docstring": "\nList of TCP client sockets.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Socket>", "name": "sockets = new ArrayList<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/MuxServerSocketChannelFactory.java.MuxServerSocketChannelFactory", "name": "MuxServerSocketChannelFactory", "file_path": "src/main/java/org/ice4j/socket/MuxServerSocketChannelFactory.java", "superclasses": "", "methods": ["[ServerSocketChannel]openAndBindServerSocketChannel(Map<String, Object>,SocketAddress,int)"], "method_uris": ["src/main/java/org/ice4j/socket/MuxServerSocketChannelFactory.java.MuxServerSocketChannelFactory.[ServerSocketChannel]openAndBindServerSocketChannel(Map<String, Object>,SocketAddress,int)"], "overrides": null, "attributes": [], "class_docstring": "\nIf supported by the runtime, initializes {@link ServerSocketChannel}s which\nare capable of sharing their listening endpoints with multiple others like\nthem.\n\n@author Lyubomir Marinov\n", "original_string": "public class MuxServerSocketChannelFactory\n{\n    /**\n     * The maximum number of milliseconds to wait for an accepted\n     * {@code SocketChannel} to provide incoming/readable data before it is\n     * considered abandoned by the client.\n     */\n    public static final int SOCKET_CHANNEL_READ_TIMEOUT = 15 * 1000;\n\n    /**\n     * The name of the {@code boolean} property of the {@code socket} property\n     * of the {@code ServerSocketChannel} returned by\n     * {@link #openAndBindServerSocketChannel(Map, SocketAddress, int)} which\n     * specifies the value of the {@code SO_REUSEADDR} socket option.\n     */\n    public static final String SOCKET_REUSE_ADDRESS_PROPERTY_NAME\n        = \"socket.reuseAddress\";\n\n    /**\n     * Opens and binds a new {@code ServerSocketChannel} instance.\n     *\n     * @param properties a {@code Map} of the values to be assigned to\n     * properties of the underlying {@link ServerSocketChannel} which is to\n     * actually listen on the specified {@code endpoint}. If the new instance is\n     * not the first to open and bind the specified {@code endpoint}, the\n     * {@code properties} and their respective values may not be used.\n     * @param endpoint the IP and port the new instance is to bind to\n     * @param backlog the requested maximum number of pending incoming\n     * connections to be queued. If the new instance is not the first to open\n     * and bind the specified {@code endpoint}, the value may not be used.\n     * @return a new {@code ServerSocketChannel} instance open and bound on the\n     * specified listening {@code endpoint}\n     * @throws IOException if an I/O error occurs\n     */\n    public static ServerSocketChannel openAndBindServerSocketChannel(\n            Map<String, Object> properties,\n            SocketAddress endpoint,\n            int backlog)\n        throws IOException\n    {\n        ServerSocketChannel channel = ServerSocketChannel.open();\n        // Apply the specified properties.\n        ServerSocket socket = channel.socket();\n\n        if (properties != null && !properties.isEmpty())\n        {\n            for (Map.Entry<String, Object> property\n                    : properties.entrySet())\n            {\n                String name = property.getKey();\n\n                if (SOCKET_REUSE_ADDRESS_PROPERTY_NAME.equals(name))\n                {\n                    Object value = property.getValue();\n                    boolean on;\n\n                    if (value == null)\n                        on = false;\n                    else if (value instanceof Boolean)\n                        on = (Boolean) value;\n                    else\n                        on = Boolean.parseBoolean(value.toString());\n\n                    socket.setReuseAddress(on);\n                }\n            }\n        }\n\n        socket.bind(endpoint, backlog);\n\n        return channel;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final int SOCKET_CHANNEL_READ_TIMEOUT = 15 * 1000;", "docstring": "\nThe maximum number of milliseconds to wait for an accepted\n{@code SocketChannel} to provide incoming/readable data before it is\nconsidered abandoned by the client.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "SOCKET_CHANNEL_READ_TIMEOUT = 15 * 1000", "syntax_pass": true}, {"attribute_expression": "public static final String SOCKET_REUSE_ADDRESS_PROPERTY_NAME\n        = \"socket.reuseAddress\";", "docstring": "\nThe name of the {@code boolean} property of the {@code socket} property\nof the {@code ServerSocketChannel} returned by\n{@link #openAndBindServerSocketChannel(Map, SocketAddress, int)} which\nspecifies the value of the {@code SO_REUSEADDR} socket option.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "SOCKET_REUSE_ADDRESS_PROPERTY_NAME\n        = \"socket.reuseAddress\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel", "name": "BaseDelegatingSocketChannel", "file_path": "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java", "superclasses": "SocketChannel", "methods": ["[]BaseDelegatingSocketChannel(T)", "[SocketChannel]bind(SocketAddress)", "[boolean]connect(SocketAddress)", "[boolean]finishConnect()", "[SocketAddress]getLocalAddress()", "[U]getOption(SocketOption<U>)", "[SocketAddress]getRemoteAddress()", "[void]implCloseSelectableChannel()", "[void]implConfigureBlocking(boolean)", "[Socket]implSocket(Socket)", "[boolean]isConnected()", "[boolean]isConnectionPending()", "[int]read(ByteBuffer)", "[long]read(ByteBuffer[],int,int)", "[SocketChannel]setOption(SocketOption<U>,U)", "[SocketChannel]shutdownInput()", "[SocketChannel]shutdownOutput()", "[Socket]socket()", "[Set<SocketOption<?>>]supportedOptions()", "[int]write(ByteBuffer)", "[long]write(ByteBuffer[],int,int)"], "method_uris": ["src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[]BaseDelegatingSocketChannel(T)", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[SocketChannel]bind(SocketAddress)", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[boolean]connect(SocketAddress)", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[boolean]finishConnect()", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[SocketAddress]getLocalAddress()", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[U]getOption(SocketOption<U>)", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[SocketAddress]getRemoteAddress()", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[void]implCloseSelectableChannel()", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[void]implConfigureBlocking(boolean)", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[Socket]implSocket(Socket)", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[boolean]isConnected()", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[boolean]isConnectionPending()", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[int]read(ByteBuffer)", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[long]read(ByteBuffer[],int,int)", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[SocketChannel]setOption(SocketOption<U>,U)", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[SocketChannel]shutdownInput()", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[SocketChannel]shutdownOutput()", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[Socket]socket()", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[Set<SocketOption<?>>]supportedOptions()", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[int]write(ByteBuffer)", "src/main/java/org/ice4j/socket/BaseDelegatingSocketChannel.java.BaseDelegatingSocketChannel.[long]write(ByteBuffer[],int,int)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements a {@code SocketChannel} which delegates (its method calls) to\nanother {@code SocketChannel}. In other words, the former wraps the latter.\n\n@author Lyubomir Marinov\n", "original_string": "public class BaseDelegatingSocketChannel<T extends SocketChannel>\n    extends SocketChannel\n{\n    /**\n     * The {@link SocketChannel} this instance delegates (its method calls) to.\n     */\n    protected final T delegate;\n\n    /**\n     * The {@code Socket} to be reported by this instance.\n     */\n    private Socket socket;\n\n    /**\n     * The <tt>Object</tt> which synchronizes the access to {@link #socket}.\n     */\n    private final Object socketSyncRoot = new Object();\n\n    /**\n     * Initializes a new {@code BaseDelegatingSocketChannel} instance which is\n     * to delegate (its method calls) to a specific {@code SocketChannel}.\n     *\n     * @param delegate the {@code SocketChannel} the new instance is to delegate\n     * (its method calls) to\n     */\n    public BaseDelegatingSocketChannel(T delegate)\n    {\n        super(delegate.provider());\n\n        this.delegate = delegate;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate} and returns {@code this}.\n     */\n    @Override\n    public SocketChannel bind(SocketAddress local)\n        throws IOException\n    {\n        delegate.bind(local);\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public boolean connect(SocketAddress remote)\n        throws IOException\n    {\n        return delegate.connect(remote);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public boolean finishConnect()\n        throws IOException\n    {\n        return delegate.finishConnect();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public SocketAddress getLocalAddress()\n        throws IOException\n    {\n        return delegate.getLocalAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public <U> U getOption(SocketOption<U> name)\n        throws IOException\n    {\n        return delegate.getOption(name);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public SocketAddress getRemoteAddress()\n        throws IOException\n    {\n        return delegate.getRemoteAddress();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    protected void implCloseSelectableChannel()\n        throws IOException\n    {\n        delegate.close();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    protected void implConfigureBlocking(boolean block)\n        throws IOException\n    {\n        delegate.configureBlocking(block);\n    }\n\n    /**\n     * Allows extenders to optionally configure (e.g. wrap) the {@code Socket}\n     * of {@link #delegate} and before it is returned by {@link #socket()}.\n     *\n     * @param socket the {@code Socket} of {@code delegate}\n     * @return the {@code Socket} to be returned by {@link #socket()} (in place\n     * of {@code socket})\n     * @throws IOException if an I/O error occurs\n     */\n    protected Socket implSocket(Socket socket)\n        throws IOException\n    {\n        return new DelegatingSocket(socket, this);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public boolean isConnected()\n    {\n        return delegate.isConnected();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public boolean isConnectionPending()\n    {\n        return delegate.isConnectionPending();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public int read(ByteBuffer dst)\n        throws IOException\n    {\n        return delegate.read(dst);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public long read(ByteBuffer[] dsts, int offset, int length)\n        throws IOException\n    {\n        return delegate.read(dsts, offset, length);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate} and returns {@code this}.\n     */\n    @Override\n    public <U> SocketChannel setOption(SocketOption<U> name, U value)\n        throws IOException\n    {\n        delegate.setOption(name, value);\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate} and returns {@code this}.\n     */\n    @Override\n    public SocketChannel shutdownInput()\n        throws IOException\n    {\n        delegate.shutdownInput();\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate} and returns {@code this}.\n     */\n    @Override\n    public SocketChannel shutdownOutput()\n        throws IOException\n    {\n        delegate.shutdownOutput();\n        return this;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Allows wrapping the {@code socket} of {@link #delegate}.\n     */\n    @Override\n    public Socket socket()\n    {\n        Socket socket = delegate.socket();\n\n        synchronized (socketSyncRoot)\n        {\n            if (this.socket == null)\n            {\n                if (socket != null)\n                {\n                    try\n                    {\n                        this.socket = implSocket(socket);\n                    }\n                    catch (IOException ioe)\n                    {\n                        throw new RuntimeException(ioe);\n                    }\n                }\n            }\n            else if (socket == null)\n            {\n                this.socket = null;\n            }\n            else\n            {\n                // TODO For the sake of completeness, maybe check that the\n                // value of this.socket still delegates to the latest value of\n                // socket. However, the value of socket is very likely final so\n                // do not bother with it at the time of this writing.\n            }\n            return this.socket;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public Set<SocketOption<?>> supportedOptions()\n    {\n        return delegate.supportedOptions();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public int write(ByteBuffer src)\n        throws IOException\n    {\n        return delegate.write(src);\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * Forwards to {@link #delegate}.\n     */\n    @Override\n    public long write(ByteBuffer[] srcs, int offset, int length)\n        throws IOException\n    {\n        return delegate.write(srcs, offset, length);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected final T delegate;", "docstring": "\nThe {@link SocketChannel} this instance delegates (its method calls) to.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "T", "name": "delegate", "syntax_pass": true}, {"attribute_expression": "private Socket socket;", "docstring": "\nThe {@code Socket} to be reported by this instance.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Socket", "name": "socket", "syntax_pass": true}, {"attribute_expression": "private final Object socketSyncRoot = new Object();", "docstring": "\nThe <tt>Object</tt> which synchronizes the access to {@link #socket}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "socketSyncRoot = new Object()", "syntax_pass": true}]}]