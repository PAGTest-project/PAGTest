[{"strategy": "retry", "code": "\npackage org.ice4j.stunclient;\n\nimport org.ice4j.TransportAddress;\nimport org.ice4j.message.Request;\nimport org.ice4j.message.StunMessageEvent;\nimport org.ice4j.stack.StunStack;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mockito;\n\nimport java.io.IOException;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\npublic class BlockingRequestSender_processResponseTest {\n\n    private BlockingRequestSender sender;\n    private StunStack stunStack;\n    private TransportAddress localAddress;\n    private TransportAddress serverAddress;\n    private Request request;\n\n    @BeforeEach\n    public void setUp() {\n        stunStack = mock(StunStack.class);\n        localAddress = mock(TransportAddress.class);\n        serverAddress = mock(TransportAddress.class);\n        request = mock(Request.class);\n        sender = new BlockingRequestSender(stunStack, localAddress);\n    }\n\n    @Test\n    public void testProcessResponse() throws IOException, InterruptedException {\n        // Given\n        StunMessageEvent responseEvent = mock(StunMessageEvent.class);\n        when(stunStack.sendRequest(request, serverAddress, localAddress, sender)).thenReturn(responseEvent);\n\n        // When\n        Thread senderThread = new Thread(() -> {\n            try {\n                sender.sendRequestAndWaitForResponse(request, serverAddress);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        });\n        senderThread.start();\n\n        // Simulate response processing\n        sender.processResponse(responseEvent);\n\n        // Then\n        assertTrue(sender.ended);\n    }\n}\n"}]