[{"uris": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase", "name": "PseudoTcpTestBase", "file_path": "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java", "superclasses": "MultiThreadSupportTest", "methods": ["[]PseudoTcpTestBase()", "[byte[]]createDummyData(int)", "[void]setLocalMtu(int)", "[void]setRemoteMtu(int)", "[void]setDelay(int)", "[void]setLoss(int)", "[void]setOptNagling(boolean)", "[void]setOptAckDelay(int)", "[void]setOptSndBuf(int)", "[void]setRemoteOptRcvBuf(int)", "[void]setLocalOptRcvBuf(int)", "[void]disableRemoteWindowScale()", "[void]disableLocalWindowScale()", "[void]connect()", "[void]close()", "[void]onTcpOpen(PseudoTCPBase)", "[void]onTcpClosed(PseudoTCPBase,IOException)", "[int]randomInt()", "[int]localSend(byte[],int)", "[int]localRecv(byte[],int)", "[int]remoteRecv(byte[],int)", "[int]remoteSend(byte[],int)", "[void]localPacket(byte[],int)", "[void]remotePacket(byte[],int)", "[TimerTask]getWriteRemotePacketTask(byte[],int)", "[TimerTask]getWriteLocalPacketTask(byte[],int)", "[WriteResult]tcpWritePacket(PseudoTCPBase,byte[],int)", "[void]updateLocalClock()", "[void]updateRemoteClock()", "[void]updateNextClock(PseudoTCPBase,Object)", "[void]startClocks()", "[void]stopClocks()", "[boolean]assert_Connected_wait(int)", "[boolean]assert_Disconnected_wait(long)", "[PseudoTCPBase]getRemoteTcp()", "[PseudoTCPBase]getLocalTcp()", "[long]maxTransferTime(long,long)"], "method_uris": ["src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[]PseudoTcpTestBase()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[byte[]]createDummyData(int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setLocalMtu(int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setRemoteMtu(int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setDelay(int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setLoss(int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setOptNagling(boolean)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setOptAckDelay(int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setOptSndBuf(int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setRemoteOptRcvBuf(int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]setLocalOptRcvBuf(int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]disableRemoteWindowScale()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]disableLocalWindowScale()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]connect()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]close()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]onTcpOpen(PseudoTCPBase)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]onTcpClosed(PseudoTCPBase,IOException)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[int]randomInt()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[int]localSend(byte[],int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[int]localRecv(byte[],int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[int]remoteRecv(byte[],int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[int]remoteSend(byte[],int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]localPacket(byte[],int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]remotePacket(byte[],int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[TimerTask]getWriteRemotePacketTask(byte[],int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[TimerTask]getWriteLocalPacketTask(byte[],int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[WriteResult]tcpWritePacket(PseudoTCPBase,byte[],int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]updateLocalClock()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]updateRemoteClock()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]updateNextClock(PseudoTCPBase,Object)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]startClocks()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[void]stopClocks()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[boolean]assert_Connected_wait(int)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[boolean]assert_Disconnected_wait(long)", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[PseudoTCPBase]getRemoteTcp()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[PseudoTCPBase]getLocalTcp()", "src/test/java/org/ice4j/pseudotcp/PseudoTcpTestBase.java.PseudoTcpTestBase.[long]maxTransferTime(long,long)"], "overrides": null, "attributes": [], "class_docstring": "\nBase class for other pseduoTCP logic tests. Runs all threads required for the\nprotocol to work. There are two instances of pseudoTCP logic being run. Data\npackets between them are passes directly with some loss and/or delay\nintroduced optionally.\n\n@author Pawel Domas\n", "original_string": "public abstract class PseudoTcpTestBase\n    extends MultiThreadSupportTest\n    implements PseudoTcpNotify\n{\n    /**\n     * The logger.\n     */\n    private static final Logger logger =\n        Logger.getLogger(PseudoTCPBase.class.getName());\n    /**\n     * Remote peer TCP logic instance\n     */\n    private final PseudoTCPBase remoteTcp;\n    /**\n     * Local peer TCP logic instance\n     */\n    private final PseudoTCPBase localTcp;\n    private int local_mtu_;\n    private int remote_mtu_;\n    /**\n     * Delay in ms introduced to packets delivery\n     */\n    private int delay_;\n    /**\n     * Simulated packets loss in %\n     */\n    private int loss_;\n    /**\n     * Stores info about connection state for use by child classes\n     */\n    protected boolean have_connected_;\n    protected boolean have_disconnected_;\n    /**\n     * Timer used to delay packets delivery\n     */\n    private Timer timer = new Timer(\"Delay timer\");\n    /**\n     * Timeout for connect operation in ms\n     */\n    static final int kConnectTimeoutMs = 5000;  // ~3 * default RTO of 3000ms\n    //static final int kMinTransferRate = 1050000;\n    /**\n     * Transfer rate used to calculate timeout for transfer operations. This\n     * timeout counts before the transfer tests will fail.\n     */\n    static final int kMinTransferRate = 1000;\n    /**\n     * Transfer blocks size\n     */\n    static final int kBlockSize = 4096;\n\n    public PseudoTcpTestBase()\n    {\n        this.remoteTcp = new PseudoTCPBase(this, 1);\n        //Debug names are usefull to identify peers in log messages\n        remoteTcp.debugName = \"REM\";\n        this.localTcp = new PseudoTCPBase(this, 1);\n        localTcp.debugName = \"LOC\";\n        setLocalMtu(65535);\n        setRemoteMtu(65535);\n    }\n\n    /**\n     * Creates some random data array\n     *\n     * @param size\n     * @return\n     */\n    static public byte[] createDummyData(int size)\n    {\n        byte[] dummy = new byte[size];\n        Random r = new Random();\n        r.nextBytes(dummy);\n        return dummy;\n    }\n\n    /**\n     * Sets the <tt>mtu</tt> for local peer\n     *\n     * @param mtu\n     */\n    void setLocalMtu(int mtu)\n    {\n        localTcp.notifyMTU(mtu);\n        local_mtu_ = mtu;\n    }\n\n    /**\n     * Sets the <tt>mtu</tt> for remote peer\n     *\n     * @param mtu\n     */\n    void setRemoteMtu(int mtu)\n    {\n        remoteTcp.notifyMTU(mtu);\n        remote_mtu_ = mtu;\n    }\n\n    /**\n     * Sets the delay introduced to packets delivery between peers\n     *\n     * @param delay\n     */\n    void setDelay(int delay)\n    {\n        delay_ = delay;\n    }\n\n    /**\n     * Sets loss % of packets transferred between local and remote peers\n     *\n     * @param percent\n     */\n    void setLoss(int percent)\n    {\n        loss_ = percent;\n    }\n\n    /**\n     * Sets OptNagling for both local and remote peers\n     *\n     * @param enable_nagles\n     */\n    void setOptNagling(boolean enable_nagles)\n    {\n        localTcp.setOption(Option.OPT_NODELAY, enable_nagles ? 0 : 1);\n        remoteTcp.setOption(Option.OPT_NODELAY, enable_nagles ? 0 : 1);\n\n    }\n\n    /**\n     * Sets ack delay option for local and remote peers\n     *\n     * @param ack_delay\n     */\n    void setOptAckDelay(int ack_delay)\n    {\n        localTcp.setOption(Option.OPT_ACKDELAY, ack_delay);\n        remoteTcp.setOption(Option.OPT_ACKDELAY, ack_delay);\n    }\n\n    /**\n     * Sets send buffer option for local and remote peers\n     *\n     * @param size\n     */\n    void setOptSndBuf(int size)\n    {\n        localTcp.setOption(Option.OPT_SNDBUF, size);\n        remoteTcp.setOption(Option.OPT_SNDBUF, size);\n    }\n\n    /**\n     * Sets receive buffer size option for remote peer\n     *\n     * @param size\n     */\n    void setRemoteOptRcvBuf(int size)\n    {\n        remoteTcp.setOption(Option.OPT_RCVBUF, size);\n    }\n\n    /**\n     * Sets receive buffer size option for local peer\n     *\n     * @param size\n     */\n    void setLocalOptRcvBuf(int size)\n    {\n        localTcp.setOption(Option.OPT_RCVBUF, size);\n    }\n\n    /**\n     * Disable window scaling for remote peer\n     */\n    void disableRemoteWindowScale()\n    {\n        remoteTcp.disableWindowScale();\n    }\n\n    /**\n     * Disable window scaling for local peer\n     */\n    void disableLocalWindowScale()\n    {\n        localTcp.disableWindowScale();\n    }\n\n    /**\n     * Starts the connection from local to remote peer\n     *\n     * @throws IOException\n     */\n    void connect() throws IOException\n    {\n        localTcp.connect();\n        updateLocalClock();\n    }\n\n    /**\n     * Closes the connection\n     */\n    void close()\n    {\n        localTcp.close(false);\n        updateLocalClock();\n    }\n\n    /**\n     * Catches the event OnTcpOpen on the local peer and marks have_connected\n     * flag\n     *\n     * @param tcp\n     */\n    @Override\n    public void onTcpOpen(PseudoTCPBase tcp)\n    {\n        if (tcp == localTcp)\n        {\n            have_connected_ = true;\n            onTcpWriteable(tcp);\n        }\n    }\n\n    /**\n     * Catches OnTcpClosed event on remote peer and marks have_disconnected flag\n     *\n     * @param tcp\n     * @param exc\n     */\n    @Override\n    public void onTcpClosed(PseudoTCPBase tcp, IOException exc)\n    {\n        assert exc == null;\n        if (tcp == remoteTcp)\n        {\n            have_disconnected_ = true;\n        }\n    }\n    /**\n     * Randomizer instance used to decide about packet loss\n     */\n    private Random random = new Random();\n\n    int randomInt()\n    {\n        return random.nextInt(100);\n    }\n\n    /**\n     * Send the <tt>data</tt> from local to remote peer\n     *\n     * @param data\n     * @param len\n     * @return\n     * @throws IOException\n     */\n    int localSend(byte[] data, int len) throws IOException\n    {\n        return localTcp.send(data, len);\n    }\n\n    /**\n     * Receive data as local peer\n     *\n     * @param buffer\n     * @param len\n     * @return\n     * @throws IOException\n     */\n    int localRecv(byte[] buffer, int len) throws IOException\n    {\n        return localTcp.recv(buffer, len);\n    }\n\n    /**\n     * Receive data as remote peer\n     *\n     * @param buffer\n     * @param len\n     * @return\n     * @throws IOException\n     */\n    int remoteRecv(byte[] buffer, int len) throws IOException\n    {\n\n        return remoteTcp.recv(buffer, len);\n    }\n\n    /**\n     * Sends the <tt>data</tt> from remote to local peer\n     *\n     * @param data\n     * @param len\n     * @return\n     * @throws IOException\n     */\n    int remoteSend(byte[] data, int len)\n        throws IOException\n    {\n        return remoteTcp.send(data, len);\n    }\n\n    /**\n     * Simulates packet received by local peer\n     *\n     * @param data\n     * @param len\n     * @throws IOException\n     */\n    private void localPacket(byte[] data, int len)\n        throws IOException\n    {\n        localTcp.notifyPacket(data, len);\n        updateLocalClock();\n    }\n\n    /**\n     * Simulates packet received by remote peer\n     *\n     * @param data\n     * @param len\n     * @throws IOException\n     */\n    private void remotePacket(byte[] data, int len)\n        throws IOException\n    {\n        remoteTcp.notifyPacket(data, len);\n        updateRemoteClock();\n    }\n\n    /**\n     * Creates <tt>TimerTask</tt> with @link(RemotePacket) action\n     *\n     * @param data\n     * @param len\n     * @return\n     */\n    private TimerTask getWriteRemotePacketTask(final byte[] data, final int len)\n    {\n        return new TimerTask()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    remotePacket(data, len);\n                }\n                catch (IOException ex)\n                {\n                    throw new RuntimeException(ex);\n                }\n            }\n        };\n    }\n\n    /**\n     * Creates <tt>TimerTask</tt> with @link(LocalPacket) action\n     *\n     * @param data\n     * @param len\n     * @return\n     */\n    private TimerTask getWriteLocalPacketTask(final byte[] data, final int len)\n    {\n        return new TimerTask()\n        {\n            @Override\n            public void run()\n            {\n                try\n                {\n                    localPacket(data, len);\n                }\n                catch (IOException ex)\n                {\n                    throw new RuntimeException(ex);\n                }\n            }\n        };\n    }\n\n    /**\n     * Handles passing packets between local and remote peers. Here are taken\n     * decisions about packets loss and delay.\n     *\n     * @param tcp\n     * @param buffer\n     * @param len\n     * @return\n     */\n    @Override\n    public WriteResult tcpWritePacket(PseudoTCPBase tcp, byte[] buffer, int len)\n    {\n        // Randomly drop the desired percentage of packets.\n        // Also drop packets that are larger than the configured MTU.\n        if (randomInt() < loss_)\n        {\n            if (logger.isLoggable(Level.FINE))\n            {\n                logger.log(Level.FINE, \"Randomly dropping packet, size=\" + len);\n            }\n        }\n        else\n        {\n            if (len > Math.min(local_mtu_, remote_mtu_))\n            {\n                if (logger.isLoggable(Level.FINE))\n                {\n                    logger.log(Level.FINE,\n                               \"Dropping packet that exceeds path MTU, size=\"\n                        + len);\n                }\n            }\n            else\n            {\n                if (tcp == localTcp)\n                {\n                    timer.schedule(getWriteRemotePacketTask(buffer, len), delay_);\n                }\n                else\n                {\n                    timer.schedule(getWriteLocalPacketTask(buffer, len), delay_);\n                }\n            }\n        }\n        return WriteResult.WR_SUCCESS;\n    }\n\n    /**\n     * Wakes up local clock thread from wait method causing forced time update\n     */\n    protected void updateLocalClock()\n    {\n        if (localClockThread != null)\n        {\n            synchronized (localClockLock)\n            {\n                localClockLock.notifyAll();\n            }\n        }\n    }\n\n    /**\n     * Wakes up remote clock thread from wait method causing forced time update\n     */\n    protected void updateRemoteClock()\n    {\n        if (remoteClockThread != null)\n        {\n            synchronized (remoteClockLock)\n            {\n                remoteClockLock.notifyAll();\n            }\n        }\n    }\n\n    /**\n     * Method handles time update for pseudoTCP logic class\n     *\n     * @param tcp\n     * @param lock\n     */\n    private void updateNextClock(final PseudoTCPBase tcp, final Object lock)\n    {\n        try\n        {\n\n            long now = PseudoTCPBase.now();\n            //System.out.println(tcp.debugName + \" NOTIFY CLOCK: \" + now);\n            synchronized (tcp)\n            {\n                tcp.notifyClock(now);\n            }\n            //UpdateClock(tcp);\n            long interval;  // NOLINT\n            synchronized (tcp)\n            {\n                interval = tcp.getNextClock(PseudoTCPBase.now());\n            }\n            //interval = Math.max(interval, 0L);  // sometimes interval is < 0 \n            if (logger.isLoggable(Level.FINEST))\n            {\n                logger.log(Level.FINEST,\n                           tcp.debugName + \" CLOCK sleep for \" + interval);\n            }\n            if (interval < 0)\n            {\n                if (interval == -1)\n                {\n                    interval = 1000;\n                }\n                else\n                {\n                    return;\n                }\n            }\n            synchronized (lock)\n            {\n                lock.wait(interval);\n            }\n        }\n        catch (InterruptedException ex)\n        {\n            //Logger.getLogger(PseudoTcpTestBase.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n    /**\n     * Local peer clock thread\n     */\n    private Thread localClockThread;\n    private final Object localClockLock = new Object();\n    /**\n     * Remote peer clock thread\n     */\n    private Thread remoteClockThread;\n    private final Object remoteClockLock = new Object();\n    /**\n     * The \"run flag\" for clock threads\n     */\n    private boolean runClocks = false;\n\n    /**\n     * Start clock threads\n     */\n    protected void startClocks()\n    {\n        if (localClockThread == null && remoteClockThread == null)\n        {\n            runClocks = true;\n            localClockThread = new Thread(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    while (runClocks)\n                    {\n                        //localTcp.NotifyClock(PseudoTCPBase.Now());\n                        updateNextClock(localTcp, localClockLock);\n\n                    }\n\n                }\n            }, \"LocalClockThread\");\n            remoteClockThread = new Thread(new Runnable()\n            {\n                @Override\n                public void run()\n                {\n                    while (runClocks)\n                    {\n                        //remoteTcp.NotifyClock(PseudoTCPBase.Now());\n                        updateNextClock(remoteTcp, remoteClockLock);\n                    }\n\n                }\n            }, \"RemoteClockThread\");\n            localClockThread.start();\n            remoteClockThread.start();\n        }\n        else\n        {\n            throw new IllegalStateException();\n        }\n    }\n\n    /**\n     * Stops clock threads\n     */\n    protected void stopClocks()\n    {\n        if (localClockThread != null && remoteClockThread != null)\n        {\n            try\n            {\n                runClocks = false;\n                localClockThread.interrupt();\n                remoteClockThread.interrupt();\n                localClockThread.join(5000);\n                localClockThread = null;\n                remoteClockThread.join(5000);\n                remoteClockThread = null;\n            }\n            catch (InterruptedException ex)\n            {\n                ex.printStackTrace();\n            }\n        }\n        else\n        {\n            throw new IllegalStateException();\n        }\n    }\n\n    /**\n     * This method waits <tt>kConnectTimeoutMs</tt> miliseconds or until the\n     * connection has been established between local and remote peers\n     *\n     * @param kConnectTimeoutMs\n     * @return <tt>isDone</tt> result\n     */\n    protected boolean assert_Connected_wait(int kConnectTimeoutMs)\n    {\n        return assert_wait_until(\n            () -> PseudoTcpTestBase.this.have_connected_,\n            kConnectTimeoutMs);\n    }\n\n    /**\n     * This method waits <tt>kTransferTimeoutMs</tt> miliseconds or until the\n     * connection has been closed, which means that the data was transferred\n     *\n     * @param kTransferTimeoutMs\n     * @return <tt>isDone</tt> result\n     */\n    protected boolean assert_Disconnected_wait(long kTransferTimeoutMs)\n    {\n        return assert_wait_until(\n            () -> PseudoTcpTestBase.this.have_disconnected_,\n            kTransferTimeoutMs);\n    }\n\n    /**\n     * @return the remoteTcp\n     */\n    PseudoTCPBase getRemoteTcp()\n    {\n        return remoteTcp;\n    }\n\n    /**\n     * @return the localTcp\n     */\n    PseudoTCPBase getLocalTcp()\n    {\n        return localTcp;\n    }\n\n    /**\n     * Calculates maximum transfer time of <tt>size</tt> bytes for specified\n     * transfer rate\n     *\n     * @param size\n     * @param kBps\n     * @return timeout for transfer in ms(minimum 3000 ms)\n     */\n    public long maxTransferTime(long size, long kBps)\n    {\n        long transferTout = ((size) / kBps) * 8 * 1000;\n        return transferTout > 3000 ? transferTout : 3000;\n    }\n}", "super_interfaces": ["PseudoTcpNotify"], "fields": [{"attribute_expression": "private static final Logger logger =\n        Logger.getLogger(PseudoTCPBase.class.getName());", "docstring": "\nThe logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger =\n        Logger.getLogger(PseudoTCPBase.class.getName())", "syntax_pass": true}, {"attribute_expression": "private final PseudoTCPBase remoteTcp;", "docstring": "\nRemote peer TCP logic instance\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PseudoTCPBase", "name": "remoteTcp", "syntax_pass": true}, {"attribute_expression": "private final PseudoTCPBase localTcp;", "docstring": "\nLocal peer TCP logic instance\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PseudoTCPBase", "name": "localTcp", "syntax_pass": true}, {"attribute_expression": "private int local_mtu_;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "local_mtu_", "syntax_pass": true}, {"attribute_expression": "private int remote_mtu_;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "remote_mtu_", "syntax_pass": true}, {"attribute_expression": "private int delay_;", "docstring": "\nDelay in ms introduced to packets delivery\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "delay_", "syntax_pass": true}, {"attribute_expression": "private int loss_;", "docstring": "\nSimulated packets loss in %\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "loss_", "syntax_pass": true}, {"attribute_expression": "protected boolean have_connected_;", "docstring": "\nStores info about connection state for use by child classes\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "have_connected_", "syntax_pass": true}, {"attribute_expression": "protected boolean have_disconnected_;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "have_disconnected_", "syntax_pass": true}, {"attribute_expression": "private Timer timer = new Timer(\"Delay timer\");", "docstring": "\nTimer used to delay packets delivery\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Timer", "name": "timer = new Timer(\"Delay timer\")", "syntax_pass": true}, {"attribute_expression": "static final int kConnectTimeoutMs = 5000;", "docstring": "\nTimeout for connect operation in ms\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "kConnectTimeoutMs = 5000", "syntax_pass": true}, {"attribute_expression": "static final int kMinTransferRate = 1000;", "docstring": "\nTransfer rate used to calculate timeout for transfer operations. This\ntimeout counts before the transfer tests will fail.\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "kMinTransferRate = 1000", "syntax_pass": true}, {"attribute_expression": "static final int kBlockSize = 4096;", "docstring": "\nTransfer blocks size\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "kBlockSize = 4096", "syntax_pass": true}, {"attribute_expression": "private Random random = new Random();", "docstring": "\nRandomizer instance used to decide about packet loss\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Random", "name": "random = new Random()", "syntax_pass": true}, {"attribute_expression": "private Thread localClockThread;", "docstring": "\nLocal peer clock thread\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Thread", "name": "localClockThread", "syntax_pass": true}, {"attribute_expression": "private final Object localClockLock = new Object();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "localClockLock = new Object()", "syntax_pass": true}, {"attribute_expression": "private Thread remoteClockThread;", "docstring": "\nRemote peer clock thread\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Thread", "name": "remoteClockThread", "syntax_pass": true}, {"attribute_expression": "private final Object remoteClockLock = new Object();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "remoteClockLock = new Object()", "syntax_pass": true}, {"attribute_expression": "private boolean runClocks = false;", "docstring": "\nThe \"run flag\" for clock threads\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "runClocks = false", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/AbstractResponseCollector.java.AbstractResponseCollector", "name": "AbstractResponseCollector", "file_path": "src/main/java/org/ice4j/AbstractResponseCollector.java", "superclasses": "", "methods": ["[void]processFailure(BaseStunMessageEvent)", "[void]processTimeout(StunTimeoutEvent)", "[void]processUnreachable(StunFailureEvent)"], "method_uris": ["src/main/java/org/ice4j/AbstractResponseCollector.java.AbstractResponseCollector.[void]processFailure(BaseStunMessageEvent)", "src/main/java/org/ice4j/AbstractResponseCollector.java.AbstractResponseCollector.[void]processTimeout(StunTimeoutEvent)", "src/main/java/org/ice4j/AbstractResponseCollector.java.AbstractResponseCollector.[void]processUnreachable(StunFailureEvent)"], "overrides": null, "attributes": [], "class_docstring": "\n@author Lubomir Marinov\n", "original_string": "public abstract class AbstractResponseCollector\n    implements ResponseCollector\n{\n\n    /**\n     * Notifies this <tt>ResponseCollector</tt> that a transaction described by\n     * the specified <tt>BaseStunMessageEvent</tt> has failed. The possible\n     * reasons for the failure include timeouts, unreachable destination, etc.\n     *\n     * @param event the <tt>BaseStunMessageEvent</tt> which describes the failed\n     * transaction and the runtime type of which specifies the failure reason\n     */\n    protected abstract void processFailure(BaseStunMessageEvent event);\n\n    /**\n     * Notifies this collector that no response had been received after repeated\n     * retransmissions of the original request (as described by rfc3489) and\n     * that the request should be considered unanswered.\n     *\n     * @param event the <tt>StunTimeoutEvent</tt> containing a reference to the\n     * transaction that has just failed.\n     */\n    public void processTimeout(StunTimeoutEvent event)\n    {\n        processFailure(event);\n    }\n\n    /**\n     * Notifies this collector that the destination of the request has been\n     * determined to be unreachable and that the request should be considered\n     * unanswered.\n     *\n     * @param event the <tt>StunFailureEvent</tt> containing the\n     * <tt>PortUnreachableException</tt> that has just occurred.\n     */\n    public void processUnreachable(StunFailureEvent event)\n    {\n        processFailure(event);\n    }\n}", "super_interfaces": ["ResponseCollector"], "fields": []}, {"uris": "src/main/java/org/ice4j/message/Message.java.Message", "name": "Message", "file_path": "src/main/java/org/ice4j/message/Message.java", "superclasses": "", "methods": ["[]Message()", "[char]getDataLength()", "[char]getDataLengthWithoutPadding()", "[void]putAttribute(Attribute)", "[boolean]containsAttribute(char)", "[Attribute]getAttribute(char)", "[List<Attribute>]getAttributes()", "[Attribute]removeAttribute(char)", "[int]getAttributeCount()", "[void]setMessageType(char)", "[char]getMessageType()", "[void]setTransactionID(byte[])", "[byte[]]getTransactionID()", "[byte]getAttributePresentity(char)", "[String]getName()", "[boolean]equals(Object)", "[byte[]]encode(StunStack)", "[void]prepareForEncoding()", "[Message]decode(byte[],int,int)", "[void]performAttributeSpecificActions(Attribute,byte[],int,int)", "[boolean]validateFingerprint(FingerprintAttribute,byte[],int,int)", "[void]validateAttributePresentity()", "[boolean]isErrorResponseType(char)", "[boolean]isSuccessResponseType(char)", "[boolean]isResponseType(char)", "[boolean]isIndicationType(char)", "[boolean]isRequestType(char)", "[String]toString()"], "method_uris": ["src/main/java/org/ice4j/message/Message.java.Message.[]Message()", "src/main/java/org/ice4j/message/Message.java.Message.[char]getDataLength()", "src/main/java/org/ice4j/message/Message.java.Message.[char]getDataLengthWithoutPadding()", "src/main/java/org/ice4j/message/Message.java.Message.[void]putAttribute(Attribute)", "src/main/java/org/ice4j/message/Message.java.Message.[boolean]containsAttribute(char)", "src/main/java/org/ice4j/message/Message.java.Message.[Attribute]getAttribute(char)", "src/main/java/org/ice4j/message/Message.java.Message.[List<Attribute>]getAttributes()", "src/main/java/org/ice4j/message/Message.java.Message.[Attribute]removeAttribute(char)", "src/main/java/org/ice4j/message/Message.java.Message.[int]getAttributeCount()", "src/main/java/org/ice4j/message/Message.java.Message.[void]setMessageType(char)", "src/main/java/org/ice4j/message/Message.java.Message.[char]getMessageType()", "src/main/java/org/ice4j/message/Message.java.Message.[void]setTransactionID(byte[])", "src/main/java/org/ice4j/message/Message.java.Message.[byte[]]getTransactionID()", "src/main/java/org/ice4j/message/Message.java.Message.[byte]getAttributePresentity(char)", "src/main/java/org/ice4j/message/Message.java.Message.[String]getName()", "src/main/java/org/ice4j/message/Message.java.Message.[boolean]equals(Object)", "src/main/java/org/ice4j/message/Message.java.Message.[byte[]]encode(StunStack)", "src/main/java/org/ice4j/message/Message.java.Message.[void]prepareForEncoding()", "src/main/java/org/ice4j/message/Message.java.Message.[Message]decode(byte[],int,int)", "src/main/java/org/ice4j/message/Message.java.Message.[void]performAttributeSpecificActions(Attribute,byte[],int,int)", "src/main/java/org/ice4j/message/Message.java.Message.[boolean]validateFingerprint(FingerprintAttribute,byte[],int,int)", "src/main/java/org/ice4j/message/Message.java.Message.[void]validateAttributePresentity()", "src/main/java/org/ice4j/message/Message.java.Message.[boolean]isErrorResponseType(char)", "src/main/java/org/ice4j/message/Message.java.Message.[boolean]isSuccessResponseType(char)", "src/main/java/org/ice4j/message/Message.java.Message.[boolean]isResponseType(char)", "src/main/java/org/ice4j/message/Message.java.Message.[boolean]isIndicationType(char)", "src/main/java/org/ice4j/message/Message.java.Message.[boolean]isRequestType(char)", "src/main/java/org/ice4j/message/Message.java.Message.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nThis class represents a STUN message. Messages are TLV (type-length-value)\nencoded using big endian (network ordered) binary.  All STUN messages start\nwith a STUN header, followed by a STUN payload.  The payload is a series of\nSTUN attributes, the set of which depends on the message type.  The STUN\nheader contains a STUN message type, transaction ID, and length.\n\n@author Emil Ivov\n@author Sebastien Vincent\n@author Lyubomir Marinov\n@author Aakash Garg\n", "original_string": "public abstract class Message\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>Message</tt> class and its instances\n     * for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(Message.class.getName());\n\n    /**\n     * The mask of the two bits from the message type structure, which indicate\n     * the message class.\n     */\n    private static final char MESSAGE_CLASS_MASK = 0x0110;\n\n    /**\n     * STUN request code.\n     */\n    public static final char STUN_REQUEST = 0x0000;\n\n    /**\n     * STUN indication code.\n     */\n    public static final char STUN_INDICATION = 0x0010;\n\n    /**\n     * STUN success response code.\n     */\n    public static final char STUN_SUCCESS_RESP = 0x0100;\n\n    /**\n     * STUN error response code.\n     */\n    public static final char STUN_ERROR_RESP = 0x0110;\n\n    /* STUN methods */\n    /**\n     * STUN binding method.\n     */\n    public static final char STUN_METHOD_BINDING = 0x0001;\n\n    /**\n     * STUN binding request code.\n     */\n    public static final char BINDING_REQUEST\n        = (STUN_METHOD_BINDING | STUN_REQUEST);\n\n    /**\n     * STUN binding success response code.\n     */\n    public static final char BINDING_SUCCESS_RESPONSE\n        = (STUN_METHOD_BINDING | STUN_SUCCESS_RESP);\n\n    /**\n     * STUN binding error response code.\n     */\n    public static final char BINDING_ERROR_RESPONSE\n        = (STUN_METHOD_BINDING | STUN_ERROR_RESP);\n\n    /**\n     * STUN binding request code.\n     */\n    public static final char BINDING_INDICATION\n        = (STUN_METHOD_BINDING | STUN_INDICATION);\n\n    /**\n     * STUN shared secret request.\n     */\n    public static final char SHARED_SECRET_REQUEST = 0x0002;\n\n    /**\n     * STUN shared secret response.\n     */\n    public static final char SHARED_SECRET_RESPONSE = 0x0102;\n\n    /**\n     * STUN shared secret error response.\n     */\n    public static final char SHARED_SECRET_ERROR_RESPONSE = 0x0112;\n\n    /* TURN methods */\n    /**\n     * TURN allocate method code.\n     */\n    public static final char TURN_METHOD_ALLOCATE = 0x0003;\n\n    /**\n     * TURN refresh method code.\n     */\n    public static final char TURN_METHOD_REFRESH = 0x0004;\n\n    /**\n     * TURN send method code.\n     */\n    public static final char TURN_METHOD_SEND = 0x0006;\n\n    /**\n     * TURN data method code.\n     */\n    public static final char TURN_METHOD_DATA = 0x0007;\n\n    /**\n     * TURN CreatePermission method code.\n     */\n    public static final char TURN_METHOD_CREATEPERMISSION = 0x0008;\n\n    /**\n     * TURN ChannelBind method code.\n     */\n    public static final char TURN_METHOD_CHANNELBIND = 0x0009;\n    \n    /**\n     * TURN Connect method code.\n     */\n    public static final char TURN_METHOD_CONNECT = 0X000a;\n    \n    /**\n     * TURN ConnectionBind method code.\n     */\n    public static final char TURN_METHOD_CONNECTION_BIND = 0X000b;\n    \n    /**\n     * TURN ConnectionAttempt method code.\n     */\n    public static final char TURN_METHOD_CONNECTION_ATTEMPT = 0X000c;\n    \n    /**\n     * TURN allocate request code.\n     */\n    public static final char ALLOCATE_REQUEST\n        = (TURN_METHOD_ALLOCATE | STUN_REQUEST);\n\n    /**\n     * TURN allocate response code.\n     */\n    public static final char ALLOCATE_RESPONSE\n        = (TURN_METHOD_ALLOCATE | STUN_SUCCESS_RESP);\n\n    /**\n     * TURN allocate error response code.\n     */\n    public static final char ALLOCATE_ERROR_RESPONSE\n        = (TURN_METHOD_ALLOCATE | STUN_ERROR_RESP);\n\n    /**\n     * TURN refresh request code.\n     */\n    public static final char REFRESH_REQUEST\n        = (TURN_METHOD_REFRESH | STUN_REQUEST);\n    \n    /**\n     * TURN allocate refresh request code.\n     */\n    public static final char ALLOCATE_REFRESH_REQUEST\n        = (TURN_METHOD_ALLOCATE | REFRESH_REQUEST);\n    \n    /**\n     * TURN refresh response code.\n     */\n    public static final char REFRESH_RESPONSE\n        = (TURN_METHOD_REFRESH | STUN_SUCCESS_RESP);\n\n    /**\n     * TURN refresh error response code.\n     */\n    public static final char REFRESH_ERROR_RESPONSE\n        = (TURN_METHOD_REFRESH | STUN_ERROR_RESP);\n\n    /**\n     * TURN ChannelBind request code.\n     */\n    public static final char CHANNELBIND_REQUEST\n        = (TURN_METHOD_CHANNELBIND | STUN_REQUEST);\n\n    /**\n     * TURN ChannelBind response code.\n     */\n    public static final char CHANNELBIND_RESPONSE\n        = (TURN_METHOD_CHANNELBIND | STUN_SUCCESS_RESP);\n\n    /**\n     * TURN ChannelBind error response code.\n     */\n    public static final char CHANNELBIND_ERROR_RESPONSE\n        = (TURN_METHOD_CHANNELBIND | STUN_ERROR_RESP);\n\n    /**\n     * TURN CreatePermission request code.\n     */\n    public static final char CREATEPERMISSION_REQUEST\n        = (TURN_METHOD_CREATEPERMISSION | STUN_REQUEST);\n\n    /**\n     * TURN CreatePermission response code.\n     */\n    public static final char CREATEPERMISSION_RESPONSE\n        = (TURN_METHOD_CREATEPERMISSION | STUN_SUCCESS_RESP);\n\n    /**\n     * TURN CreatePermission error response code.\n     */\n    public static final char CREATEPERMISSION_ERROR_RESPONSE\n        = (TURN_METHOD_CREATEPERMISSION | STUN_ERROR_RESP);\n\n    /**\n     * TURN send indication code.\n     */\n    public static final char SEND_INDICATION\n        = (TURN_METHOD_SEND | STUN_INDICATION);\n\n    /**\n     * TURN data indication code.\n     */\n    public static final char DATA_INDICATION\n        = (TURN_METHOD_DATA | STUN_INDICATION);\n\n    /**\n     * TURN Connect Request code.\n     */\n    public static final char CONNECT_REQUEST\n        = (TURN_METHOD_CONNECT | STUN_REQUEST);\n\n    /**\n     * TURN Connect Success Response code.\n     */\n    public static final char CONNECT_RESPONSE\n        = (TURN_METHOD_CONNECT | STUN_SUCCESS_RESP);\n\n    /**\n     * TURN Connect Error Response code.\n     */\n    public static final char CONNECT_ERROR_RESPONSE\n        = (TURN_METHOD_CONNECT | STUN_ERROR_RESP);\n\n    /**\n     * TURN Connection Bind Request code.\n     */\n    public static final char CONNECTION_BIND_REQUEST\n        = (TURN_METHOD_CONNECTION_BIND | STUN_REQUEST);\n\n    /**\n     * TURN Connection Bind Success Response code.\n     */\n    public static final char CONNECTION_BIND_SUCCESS_RESPONSE\n        = (TURN_METHOD_CONNECTION_BIND | STUN_SUCCESS_RESP);\n\n    /**\n     * TURN Connection Bind error code. \n     */\n    public static final char CONNECTION_BIND_ERROR_RESPONSE\n        = (TURN_METHOD_CONNECTION_BIND | STUN_ERROR_RESP);\n\n    /**\n     * TURN Connection Attempt Indication code.\n     */\n    public static final char CONNECTION_ATTEMPT_INDICATION\n        = (TURN_METHOD_CONNECTION_ATTEMPT | STUN_INDICATION);\n\n    /* Old TURN method */\n    /**\n     * TURN Send request.\n     */\n    public static final char SEND_REQUEST = 0x0004;\n\n    /**\n     * TURN Send request.\n     */\n    public static final char OLD_DATA_INDICATION = 0x0115;\n\n    //Message fields\n    /**\n     * The length of Stun Message Headers in bytes\n     * = len(Type) + len(DataLength) + len(Transaction ID).\n     */\n    public static final byte HEADER_LENGTH = 20;\n\n    /**\n     * Indicates the type of the message. The message type can be Binding Request,\n     * Binding Response, Binding Error Response, Shared Secret Request, Shared\n     * Secret Response, or Shared Secret Error Response.\n     */\n    protected char messageType = 0x0000;\n\n    /**\n     * The transaction ID is used to correlate requests and responses.\n     */\n    protected byte[] transactionID = null;\n\n    /**\n     * The magic cookie (0x2112A442).\n     */\n    public static final byte[] MAGIC_COOKIE = { 0x21, 0x12, (byte)0xA4, 0x42 };\n\n    /**\n     * The length of the transaction id (in bytes).\n     */\n    public static final byte TRANSACTION_ID_LENGTH = 12;\n\n    /**\n     * The length of the RFC3489 transaction id (in bytes).\n     */\n    public static final byte RFC3489_TRANSACTION_ID_LENGTH = 16;\n\n    /**\n     * The list of attributes contained by the message. We are using a Map\n     * rather than a uni-dimensional list, in order to facilitate attribute\n     * search (even though it introduces some redundancies). Order is important\n     * so we'll be using a <tt>LinkedHashMap</tt>\n     */\n    //not sure this is the best solution but I'm trying to keep entry order\n    protected final LinkedHashMap<Character, Attribute> attributes\n        = new LinkedHashMap<>();\n\n    /**\n     * Attribute presentity is a thing of RFC 3489 and no longer exists in\n     * 5389. we are not using it any longer and if at some point we decide we\n     * need it in certain situations, then make extend use of the following\n     * field.\n     */\n    private static boolean rfc3489CompatibilityMode = false;\n\n    /**\n     * Describes which attributes are present in which messages.  An\n     * M indicates that inclusion of the attribute in the message is\n     * mandatory, O means its optional, C means it's conditional based on\n     * some other aspect of the message, and N/A means that the attribute is\n     * not applicable to that message type.\n     *\n     * For classic STUN :\n     *\n     * <pre>\n     *                                         Binding  Shared  Shared  Shared\n     *                       Binding  Binding  Error    Secret  Secret  Secret\n     *   Att.                Req.     Resp.    Resp.    Req.    Resp.   Error \n     *                                                                  Resp. \n     *   _____________________________________________________________________\n     *   MAPPED-ADDRESS      N/A      M        N/A      N/A     N/A     N/A   \n     *   RESPONSE-ADDRESS    O        N/A      N/A      N/A     N/A     N/A   \n     *   CHANGE-REQUEST      O        N/A      N/A      N/A     N/A     N/A   \n     *   SOURCE-ADDRESS      N/A      M        N/A      N/A     N/A     N/A   \n     *   CHANGED-ADDRESS     N/A      M        N/A      N/A     N/A     N/A   \n     *   USERNAME            O        N/A      N/A      N/A     M       N/A   \n     *   PASSWORD            N/A      N/A      N/A      N/A     M       N/A   \n     *   MESSAGE-INTEGRITY   O        O        N/A      N/A     N/A     N/A   \n     *   ERROR-CODE          N/A      N/A      M        N/A     N/A     M     \n     *   UNKNOWN-ATTRIBUTES  N/A      N/A      C        N/A     N/A     C     \n     *   REFLECTED-FROM      N/A      C        N/A      N/A     N/A     N/A   \n     *   XOR-MAPPED-ADDRESS  N/A      M        N/A      N/A     N/A     N/A   \n     *   XOR-ONLY            O        N/A      N/A      N/A     N/A     N/A   \n     *   SOFTWARE            N/A      O        O        N/A     O       O     \n     * </pre>\n     */\n    private static final byte N_A = 0;\n\n    /**\n     * C means it's conditional based on some other aspect of the message.\n     */\n    private static final byte C = 1;\n\n    /**\n     * O means the parameter is optional.\n     *\n     * @see Message#N_A\n     */\n    public static final byte O = 2;\n\n    /**\n     * M indicates that inclusion of the attribute in the message is\n     * mandatory.\n     *\n     * @see Message#N_A\n     */\n    public static final byte M = 3;\n\n    //Message indices\n    protected static final byte BINDING_REQUEST_PRESENTITY_INDEX           = 0;\n    protected static final byte BINDING_RESPONSE_PRESENTITY_INDEX          = 1;\n    protected static final byte BINDING_ERROR_RESPONSE_PRESENTITY_INDEX    = 2;\n    protected static final byte SHARED_SECRET_REQUEST_PRESENTITY_INDEX     = 3;\n    protected static final byte SHARED_SECRET_RESPONSE_PRESENTITY_INDEX    = 4;\n    protected static final byte SHARED_SECRET_ERROR_RESPONSE_PRESENTITY_INDEX =\n        5;\n    protected static final byte ALLOCATE_REQUEST_PRESENTITY_INDEX          = 6;\n    protected static final byte ALLOCATE_RESPONSE_PRESENTITY_INDEX         = 7;\n    protected static final byte REFRESH_REQUEST_PRESENTITY_INDEX           = 8;\n    protected static final byte REFRESH_RESPONSE_PRESENTITY_INDEX          = 9;\n    protected static final byte CHANNELBIND_REQUEST_PRESENTITY_INDEX       = 10;\n    protected static final byte CHANNELBIND_RESPONSE_PRESENTITY_INDEX      = 11;\n    protected static final byte SEND_INDICATION_PRESENTITY_INDEX           = 12;\n    protected static final byte DATA_INDICATION_PRESENTITY_INDEX           = 13;\n\n    //Attribute indices\n    protected static final byte MAPPED_ADDRESS_PRESENTITY_INDEX            =  0;\n    protected static final byte RESPONSE_ADDRESS_PRESENTITY_INDEX          =  1;\n    protected static final byte CHANGE_REQUEST_PRESENTITY_INDEX            =  2;\n    protected static final byte SOURCE_ADDRESS_PRESENTITY_INDEX            =  3;\n    protected static final byte CHANGED_ADDRESS_PRESENTITY_INDEX           =  4;\n    protected static final byte USERNAME_PRESENTITY_INDEX                  =  5;\n    protected static final byte PASSWORD_PRESENTITY_INDEX                  =  6;\n    protected static final byte MESSAGE_INTEGRITY_PRESENTITY_INDEX         =  7;\n    protected static final byte ERROR_CODE_PRESENTITY_INDEX                =  8;\n    protected static final byte UNKNOWN_ATTRIBUTES_PRESENTITY_INDEX        =  9;\n    protected static final byte REFLECTED_FROM_PRESENTITY_INDEX            = 10;\n    protected static final byte XOR_MAPPED_ADDRESS_PRESENTITY_INDEX        = 11;\n    protected static final byte XOR_ONLY_PRESENTITY_INDEX                  = 12;\n    protected static final byte SOFTWARE_PRESENTITY_INDEX                  = 13;\n    protected static final byte UNKNOWN_OPTIONAL_ATTRIBUTES_PRESENTITY_INDEX  =\n        14;\n    protected static final byte ALTERNATE_SERVER_PRESENTITY_INDEX          = 15;\n    protected static final byte REALM_PRESENTITY_INDEX                     = 16;\n    protected static final byte NONCE_PRESENTITY_INDEX                     = 17;\n    protected static final byte FINGERPRINT_PRESENTITY_INDEX               = 18;\n\n    /* TURN attributes */\n    protected static final byte CHANNEL_NUMBER_PRESENTITY_INDEX            = 19;\n    protected static final byte LIFETIME_PRESENTITY_INDEX                  = 20;\n    protected static final byte XOR_PEER_ADDRESS_PRESENTITY_INDEX          = 21;\n    protected static final byte DATA_PRESENTITY_INDEX                      = 22;\n    protected static final byte XOR_RELAYED_ADDRESS_PRESENTITY_INDEX       = 23;\n    protected static final byte EVEN_PORT_PRESENTITY_INDEX                 = 24;\n    protected static final byte REQUESTED_TRANSPORT_PRESENTITY_INDEX       = 25;\n    protected static final byte DONT_FRAGMENT_PRESENTITY_INDEX             = 26;\n    protected static final byte RESERVATION_TOKEN_PRESENTITY_INDEX         = 27;\n\n    /* ICE attributes */\n    protected static final byte PRIORITY_PRESENTITY_INDEX                  = 28;\n    protected static final byte ICE_CONTROLLING_PRESENTITY_INDEX           = 29;\n    protected static final byte ICE_CONTROLLED_PRESENTITY_INDEX            = 30;\n    protected static final byte USE_CANDIDATE_PRESENTITY_INDEX             = 31;\n\n    /* Old TURN attributes */\n    protected static final byte DESTINATION_ADDRESS_PRESENTITY_INDEX       = 29;\n\n    // CHECKSTYLE:OFF\n    protected final static byte attributePresentities[][] = new byte[][]{\n    //                                            Binding   Shared   Shared   Shared  Alloc   Alloc   Rfrsh   Rfrsh   ChnlBnd  ChnlBnd Send    Data\n    //                        Binding   Binding   Error     Secret   Secret   Secret  Req.    Resp.   Req.    Resp.   Req.     Resp.   Indic.  Indic.\n    //  Att.                  Req.      Resp.     Resp.     Req.     Resp.    Error\n    //                                                                        Resp.\n    //  ____________________________________________________________________________________________________________________________________________\n      /*MAPPED-ADDRESS*/    { N_A,      M,        N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*RESPONSE-ADDRESS*/  { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*CHANGE-REQUEST*/    { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*SOURCE-ADDRESS*/    { N_A,      M,        N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   M},\n      /*CHANGED-ADDRESS*/   { N_A,      M,        N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*USERNAME*/          { O,        N_A,      N_A,      N_A,     M,       N_A,    O,      N_A,    O,      N_A,    O,       N_A,    N_A,   N_A},\n      /*PASSWORD*/          { N_A,      N_A,      N_A,      N_A,     M,       N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*MESSAGE-INTEGRITY*/ { O,        O,        N_A,      N_A,     N_A,     N_A,    O,      O,      O,      O,      O,       O,      N_A,   N_A},\n      /*ERROR-CODE*/        { N_A,      N_A,      M,        N_A,     N_A,     M,      N_A,    M,      N_A,    M,      N_A,     M,      N_A,   N_A},\n      /*UNKNOWN-ATTRIBUTES*/{ N_A,      N_A,      C,        N_A,     N_A,     C,      N_A,    C,      N_A,    C,      N_A,     C,      N_A,   N_A},\n      /*REFLECTED-FROM*/    { N_A,      C,        N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*XOR-MAPPED-ADDRESS*/{ N_A,      C,        N_A,      N_A,     N_A,     N_A,    N_A,    M,      N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*XOR-ONLY*/          { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*SOFTWARE*/          { N_A,      O,        O,        N_A,     O,       O,      O,      O,      O,      O,      O,       O,      O,     N_A},\n      /*UNKNOWN_OPTIONAL*/  { O,        O,        O,        O,       O,       O,      O,      O,      O,      O,      O,       O,      N_A,   N_A},\n      /*ALTERNATE_SERVER*/  { O,        O,        O,        O,       O,       O,      N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*REALM*/             { O,        N_A,      N_A,      N_A,     M,       N_A,    O,      O,      O,      O,      O,       O,      N_A,   N_A},\n      /*NONCE*/             { O,        N_A,      N_A,      N_A,     M,       N_A,    O,      O,      O,      O,      O,       O,      N_A,   N_A},\n      /*FINGERPRINT*/       { O,        O,        O,        O,       O,       O,      O,      O,      O,      O,      O,       O,      N_A,   N_A},\n      /*CHANNEL-NUMBER*/    { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    M,       N_A,    N_A,   N_A},\n      /*LIFETIME*/          { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    O,      N_A,    O,      N_A,    N_A,     N_A,    N_A,   N_A},\n      /*XOR-PEER-ADDRESS*/  { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    M,       N_A,    M,     M},\n      /*DATA*/              { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    O,      N_A,    N_A,     N_A,    O,     M},\n      /*XOR-RELAYED-ADDRESS*/{N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    M,      N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*EVEN-PORT*/         { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    O,      N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*REQUESTED-TRANSPORT*/{N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    M,      N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*DONT-FRAGMENT*/     { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    O,      N_A,    N_A,    N_A,    N_A,     N_A,    O,     N_A},\n      /*RESERVATION-TOKEN*/ { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    O,      O,      N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*PRIORITY*/          { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*ICE-CONTROLLING*/   { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*ICE-CONTROLLED*/    { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*USE-CANDIDATE*/     { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*DESTINATION-ADDRESS*/{N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    O,      N_A,    N_A,     N_A,    M,     N_A},\n    };\n    // CHECKSTYLE:ON\n\n    /**\n     * Creates an empty STUN Message.\n     */\n    protected Message()\n    {\n    }\n\n    /**\n     * Returns the length of this message's body.\n     * @return the length of the data in this message.\n     */\n    public char getDataLength()\n    {\n        char length = 0;\n\n        List<Attribute> attrs = getAttributes();\n        for (Attribute att : attrs)\n        {\n            int attLen = att.getDataLength() + Attribute.HEADER_LENGTH;\n\n            //take attribute padding into account:\n            attLen += (4 - (attLen % 4)) % 4;\n\n            length += attLen;\n        }\n        return length;\n    }\n\n    /**\n     * Returns the length of this message's body without padding.\n     * Some STUN/ICE dialect does not take into account padding (GTalk).\n     *\n     * @return the length of the data in this message.\n     */\n    public char getDataLengthWithoutPadding()\n    {\n        char length = 0;\n\n        List<Attribute> attrs = getAttributes();\n\n        for (Attribute att : attrs)\n        {\n            int attLen = att.getDataLength() + Attribute.HEADER_LENGTH;\n            length += attLen;\n        }\n        return length;\n    }\n\n    /**\n     * Puts the specified attribute into this message. If an attribute with that\n     * name was already added, it would be replaced.\n     *\n     * @param attribute the attribute to put into this message.\n     *\n     * @throws IllegalArgumentException if the message cannot contain\n     * such an attribute.\n     */\n    public void putAttribute(Attribute attribute)\n        throws IllegalArgumentException\n    {\n        if (getAttributePresentity(attribute.getAttributeType()) == N_A)\n        {\n            throw new IllegalArgumentException(\n                                    \"The attribute \"\n                                    + attribute.getName()\n                                    + \" is not allowed in a \"\n                                    + getName());\n        }\n\n        synchronized(attributes)\n        {\n            attributes.put(attribute.getAttributeType(), attribute);\n        }\n    }\n\n    /**\n     * Returns <tt>true</tt> if the this <tt>Message</tt> contains an attribute\n     * with the specified type or <tt>false</tt> otherwise.\n     *\n     * @param attributeType the type whose presence we need to determine.\n     *\n     * @return <tt>true</tt> if the this <tt>Message</tt> contains an attribute\n     * with the specified type or <tt>false</tt> otherwise.\n     */\n    public boolean containsAttribute(char attributeType)\n    {\n        return attributes.containsKey(attributeType);\n    }\n\n    /**\n     * Returns the attribute with the specified type or null if no such\n     * attribute exists.\n     *\n     * @param attributeType the type of the attribute\n     * @return the attribute with the specified type or null if no such\n     * attribute exists\n     */\n    public Attribute getAttribute(char attributeType)\n    {\n        synchronized(attributes)\n        {\n            return attributes.get(attributeType);\n        }\n    }\n\n    /**\n     * Returns a copy of all {@link Attribute}s in this {@link Message}.\n     *\n     * @return a copy of all {@link Attribute}s in this {@link Message}.\n     */\n    public List<Attribute> getAttributes()\n    {\n        synchronized(attributes)\n        {\n            return new LinkedList<>(attributes.values());\n        }\n    }\n\n    /**\n     * Removes the specified attribute.\n     *\n     * @param attributeType the attribute to remove.\n     *\n     * @return the <tt>Attribute</tt> we've just removed.\n     */\n    public Attribute removeAttribute(char attributeType)\n    {\n        synchronized(attributes)\n        {\n            return attributes.remove(attributeType);\n        }\n    }\n\n    /**\n     * Returns the number of attributes, currently contained by the message.\n     *\n     * @return the number of attributes, currently contained by the message.\n     */\n    public int getAttributeCount()\n    {\n        return  attributes.size();\n    }\n\n    /**\n     * Sets this message's type to be messageType. Method is package access\n     * as it should not permit changing the type of message once it has been\n     * initialized (could provoke attribute discrepancies). Called by\n     * messageFactory.\n     *\n     * @param messageType the message type.\n     */\n    protected void setMessageType(char messageType)\n    {\n        this.messageType = messageType;\n    }\n\n    /**\n     * The message type of this message.\n     *\n     * @return the message type of the message.\n     */\n    public char getMessageType()\n    {\n        return messageType;\n    }\n\n    /**\n     * Copies the specified tranID and sets it as this message's transactionID.\n     *\n     * @param tranID the transaction id to set in this message.\n     *\n     * @throws StunException ILLEGAL_ARGUMENT if the transaction id is not\n     * valid.\n     */\n    public void setTransactionID(byte[] tranID)\n        throws StunException\n    {\n        if (tranID == null\n           || (tranID.length != TRANSACTION_ID_LENGTH &&\n                   tranID.length != RFC3489_TRANSACTION_ID_LENGTH))\n            throw new StunException(StunException.ILLEGAL_ARGUMENT,\n                                    \"Invalid transaction id length\");\n\n        int tranIDLength = tranID.length;\n\n        this.transactionID = new byte[tranIDLength];\n        System.arraycopy(tranID, 0,\n                         this.transactionID, 0, tranIDLength);\n    }\n\n    /**\n     * Returns a reference to this message's transaction id.\n     *\n     * @return a reference to this message's transaction id.\n     */\n    public byte[] getTransactionID()\n    {\n        return this.transactionID;\n    }\n\n    /**\n     * Returns whether an attribute could be present in this message.\n     *\n     * @param attributeType the id of the attribute to check .\n     *\n     * @return Message.N_A - for not applicable <br>\n     *         Message.C   - for case depending <br>\n     *         Message.N_A - for not applicable <br>\n     */\n    protected byte getAttributePresentity(char attributeType)\n    {\n        if (!rfc3489CompatibilityMode)\n            return O;\n\n        byte msgIndex = -1;\n        byte attributeIndex = -1;\n\n        switch (messageType)\n        {\n            case BINDING_REQUEST:\n                msgIndex = BINDING_REQUEST_PRESENTITY_INDEX; break;\n            case BINDING_SUCCESS_RESPONSE:\n                msgIndex = BINDING_RESPONSE_PRESENTITY_INDEX; break;\n            case BINDING_ERROR_RESPONSE:\n                msgIndex = BINDING_ERROR_RESPONSE_PRESENTITY_INDEX; break;\n            case SHARED_SECRET_REQUEST:\n                msgIndex = SHARED_SECRET_REQUEST_PRESENTITY_INDEX; break;\n            case SHARED_SECRET_RESPONSE:\n                msgIndex = SHARED_SECRET_RESPONSE_PRESENTITY_INDEX; break;\n            case SHARED_SECRET_ERROR_RESPONSE:\n                msgIndex = SHARED_SECRET_ERROR_RESPONSE_PRESENTITY_INDEX; break;\n            case ALLOCATE_REQUEST:\n                msgIndex = ALLOCATE_REQUEST_PRESENTITY_INDEX; break;\n            case REFRESH_REQUEST:\n                msgIndex = REFRESH_REQUEST_PRESENTITY_INDEX; break;\n            case CHANNELBIND_REQUEST:\n                msgIndex = CHANNELBIND_REQUEST_PRESENTITY_INDEX; break;\n            case SEND_INDICATION:\n                msgIndex = SEND_INDICATION_PRESENTITY_INDEX; break;\n            case DATA_INDICATION:\n                msgIndex = DATA_INDICATION_PRESENTITY_INDEX; break;\n            default:\n                if (logger.isLoggable(Level.FINE))\n                {\n                    logger.log(\n                            Level.FINE,\n                            \"Attribute presentity not defined for STUN \" +\n                            \"message type: \" + ((int) messageType)\n                                + \". Will assume optional.\");\n                }\n                return O;\n        }\n\n        switch (attributeType)\n        {\n            case Attribute.MAPPED_ADDRESS:\n                attributeIndex = MAPPED_ADDRESS_PRESENTITY_INDEX; break;\n            case Attribute.RESPONSE_ADDRESS:\n                attributeIndex = RESPONSE_ADDRESS_PRESENTITY_INDEX; break;\n            case Attribute.CHANGE_REQUEST:\n                attributeIndex = CHANGE_REQUEST_PRESENTITY_INDEX; break;\n            case Attribute.SOURCE_ADDRESS:\n                attributeIndex = SOURCE_ADDRESS_PRESENTITY_INDEX; break;\n            case Attribute.CHANGED_ADDRESS:\n                attributeIndex = CHANGED_ADDRESS_PRESENTITY_INDEX; break;\n            case Attribute.USERNAME:\n                attributeIndex = USERNAME_PRESENTITY_INDEX; break;\n            case Attribute.PASSWORD:\n                attributeIndex = PASSWORD_PRESENTITY_INDEX; break;\n            case Attribute.MESSAGE_INTEGRITY:\n                attributeIndex = MESSAGE_INTEGRITY_PRESENTITY_INDEX; break;\n            case Attribute.ERROR_CODE:\n                attributeIndex = ERROR_CODE_PRESENTITY_INDEX; break;\n            case Attribute.UNKNOWN_ATTRIBUTES:\n                attributeIndex = UNKNOWN_ATTRIBUTES_PRESENTITY_INDEX; break;\n            case Attribute.REFLECTED_FROM:\n                attributeIndex = REFLECTED_FROM_PRESENTITY_INDEX; break;\n            case Attribute.XOR_MAPPED_ADDRESS:\n                attributeIndex = XOR_MAPPED_ADDRESS_PRESENTITY_INDEX; break;\n            case Attribute.XOR_ONLY:\n                attributeIndex = XOR_ONLY_PRESENTITY_INDEX; break;\n            case Attribute.SOFTWARE:\n                attributeIndex = SOFTWARE_PRESENTITY_INDEX; break;\n            case Attribute.ALTERNATE_SERVER:\n                attributeIndex = ALTERNATE_SERVER_PRESENTITY_INDEX; break;\n            case Attribute.REALM:\n                attributeIndex = REALM_PRESENTITY_INDEX; break;\n            case Attribute.NONCE:\n                attributeIndex = NONCE_PRESENTITY_INDEX; break;\n            case Attribute.FINGERPRINT:\n                attributeIndex = FINGERPRINT_PRESENTITY_INDEX; break;\n            case Attribute.CHANNEL_NUMBER:\n                attributeIndex = CHANNEL_NUMBER_PRESENTITY_INDEX; break;\n            case Attribute.LIFETIME:\n                attributeIndex = LIFETIME_PRESENTITY_INDEX; break;\n            case Attribute.XOR_PEER_ADDRESS:\n                attributeIndex = XOR_PEER_ADDRESS_PRESENTITY_INDEX; break;\n            case Attribute.DATA:\n                attributeIndex = DATA_PRESENTITY_INDEX; break;\n            case Attribute.XOR_RELAYED_ADDRESS:\n                attributeIndex = XOR_RELAYED_ADDRESS_PRESENTITY_INDEX; break;\n            case Attribute.EVEN_PORT:\n                attributeIndex = EVEN_PORT_PRESENTITY_INDEX; break;\n            case Attribute.REQUESTED_TRANSPORT:\n                attributeIndex = REQUESTED_TRANSPORT_PRESENTITY_INDEX; break;\n            case Attribute.DONT_FRAGMENT:\n                attributeIndex = DONT_FRAGMENT_PRESENTITY_INDEX; break;\n            case Attribute.RESERVATION_TOKEN:\n                attributeIndex = RESERVATION_TOKEN_PRESENTITY_INDEX; break;\n            default:\n                attributeIndex = UNKNOWN_OPTIONAL_ATTRIBUTES_PRESENTITY_INDEX;\n                break;\n        }\n\n        return attributePresentities[ attributeIndex ][ msgIndex ];\n    }\n\n    /**\n     * Returns the human readable name of this message. Message names do\n     * not really matter from the protocol point of view. They are only used\n     * for debugging and readability.\n     *\n     * @return this message's name.\n     */\n    public String getName()\n    {\n        switch (messageType)\n        {\n        case ALLOCATE_REQUEST:             return \"ALLOCATE-REQUEST\";\n        case ALLOCATE_RESPONSE:            return \"ALLOCATE-RESPONSE\";\n        case ALLOCATE_ERROR_RESPONSE:      return \"ALLOCATE-ERROR-RESPONSE\";\n        case BINDING_REQUEST:              return \"BINDING-REQUEST\";\n        case BINDING_SUCCESS_RESPONSE:     return \"BINDING-RESPONSE\";\n        case BINDING_ERROR_RESPONSE:       return \"BINDING-ERROR-RESPONSE\";\n        case CREATEPERMISSION_REQUEST:     return \"CREATE-PERMISSION-REQUEST\";\n        case CREATEPERMISSION_RESPONSE:    return \"CREATE-PERMISSION-RESPONSE\";\n        case CREATEPERMISSION_ERROR_RESPONSE:\n            return \"CREATE-PERMISSION-ERROR-RESPONSE\";\n        case DATA_INDICATION:              return \"DATA-INDICATION\";\n        case REFRESH_REQUEST:              return \"REFRESH-REQUEST\";\n        case REFRESH_RESPONSE:             return \"REFRESH-RESPONSE\";\n        case REFRESH_ERROR_RESPONSE:       return \"REFRESH-ERROR-RESPONSE\";\n        case SEND_INDICATION:              return \"SEND-INDICATION\";\n        case SHARED_SECRET_REQUEST:        return \"SHARED-SECRET-REQUEST\";\n        case SHARED_SECRET_RESPONSE:       return \"SHARED-SECRET-RESPONSE\";\n        case SHARED_SECRET_ERROR_RESPONSE:\n            return \"SHARED-SECRET-ERROR-RESPONSE\";\n        default:                           return \"UNKNOWN-MESSAGE\";\n        }\n    }\n\n    /**\n     * Compares two STUN Messages. Messages are considered equal when their\n     * type, length, and all their attributes are equal.\n     *\n     * @param obj the object to compare this message with.\n     *\n     * @return true if the messages are equal and false otherwise.\n     */\n    @Override\n    public boolean equals(Object obj)\n    {\n        if (!(obj instanceof Message))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        Message msg = (Message) obj;\n        if ( msg.getMessageType()   != getMessageType())\n            return false;\n        if (msg.getDataLength() != getDataLength())\n            return false;\n\n        //compare attributes\n        for (Attribute localAtt : attributes.values())\n        {\n            if (!localAtt.equals(msg.getAttribute(localAtt.getAttributeType())))\n                return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns a binary representation of this message.\n     *\n     * @param stunStack the <tt>StunStack</tt> in the context of which the\n     * request to encode this <tt>Message</tt> is being made\n     * @return a binary representation of this message.\n     *\n     * @throws IllegalStateException if the message does not have all\n     * required attributes.\n     */\n    public byte[] encode(StunStack stunStack)\n        throws IllegalStateException\n    {\n        prepareForEncoding();\n\n        //make sure we have everything necessary to encode a proper message\n        validateAttributePresentity();\n\n        final char dataLength;\n\n        dataLength = getDataLength();\n\n        byte binMsg[] = new byte[HEADER_LENGTH + dataLength];\n        int offset    = 0;\n\n        // STUN Message Type\n        binMsg[offset++] = (byte)(getMessageType() >> 8);\n        binMsg[offset++] = (byte)(getMessageType() & 0xFF);\n\n        // Message Length\n        final int messageLengthOffset = offset;\n\n        offset += 2;\n\n        byte tranID[] = getTransactionID();\n\n        if (tranID.length == 12)\n        {\n            System.arraycopy(MAGIC_COOKIE, 0, binMsg, offset, 4);\n            offset += 4;\n            System.arraycopy(tranID, 0, binMsg, offset, TRANSACTION_ID_LENGTH);\n            offset += TRANSACTION_ID_LENGTH;\n        }\n        else\n        {\n            /* RFC3489 behavior */\n            System.arraycopy(tranID, 0, binMsg, offset,\n                RFC3489_TRANSACTION_ID_LENGTH);\n            offset += RFC3489_TRANSACTION_ID_LENGTH;\n        }\n\n        Vector<Map.Entry<Character, Attribute>> v = new Vector<>();\n        Iterator<Map.Entry<Character, Attribute>> iter = null;\n        char dataLengthForContentDependentAttribute = 0;\n\n        synchronized (attributes)\n        {\n            v.addAll(attributes.entrySet());\n        }\n\n        iter = v.iterator();\n\n        while (iter.hasNext())\n        {\n            Attribute attribute = iter.next().getValue();\n            int attributeLength\n                = attribute.getDataLength() + Attribute.HEADER_LENGTH;\n\n            //take attribute padding into account:\n            attributeLength += (4 - attributeLength % 4) % 4;\n            dataLengthForContentDependentAttribute += attributeLength;\n\n            //special handling for message integrity and fingerprint values\n            byte[] binAtt;\n\n            if (attribute instanceof ContentDependentAttribute)\n            {\n                /*\n                 * The \"Message Length\" seen by a ContentDependentAttribute is\n                 * up to and including the very Attribute but without any other\n                 * Attribute instances after it.\n                 */\n                binMsg[messageLengthOffset]\n                    = (byte)(dataLengthForContentDependentAttribute >> 8);\n                binMsg[messageLengthOffset + 1]\n                    = (byte)(dataLengthForContentDependentAttribute & 0xFF);\n                binAtt\n                    = ((ContentDependentAttribute)attribute)\n                            .encode(stunStack, binMsg, 0, offset);\n            }\n            else\n            {\n                binAtt = attribute.encode();\n            }\n\n            System.arraycopy(binAtt, 0, binMsg, offset, binAtt.length);\n            /*\n             * Offset by attributeLength and not by binAtt.length because\n             * attributeLength takes the attribute padding into account and\n             * binAtt.length does not.\n             */\n            offset += attributeLength;\n        }\n\n        // Message Length\n        binMsg[messageLengthOffset]     = (byte)(dataLength >> 8);\n        binMsg[messageLengthOffset + 1] = (byte)(dataLength & 0xFF);\n\n        return binMsg;\n    }\n\n    /**\n     * Adds attributes that have been requested vis configuration properties.\n     * Asserts attribute order where necessary.\n     */\n    private void prepareForEncoding()\n    {\n        //remove MESSAGE-INTEGRITY and FINGERPRINT attributes so that we can\n        //make sure they are added at the end.\n        Attribute msgIntAttr = removeAttribute(Attribute.MESSAGE_INTEGRITY);\n        Attribute fingerprint = removeAttribute(Attribute.FINGERPRINT);\n\n        //add a SOFTWARE attribute if the user said so, and unless they did it\n        //themselves.\n        String software = AgentConfig.config.getSoftware();\n\n        if (getAttribute(Attribute.SOFTWARE) == null\n            && software != null && software.length() > 0)\n        {\n            putAttribute(AttributeFactory\n                            .createSoftwareAttribute(software.getBytes()));\n        }\n\n        //re-add MESSAGE-INTEGRITY if there was one.\n        if (msgIntAttr != null)\n        {\n            putAttribute(msgIntAttr);\n        }\n\n        //add FINGERPRINT if there was one or if user told us to add it\n        //everywhere.\n        if (fingerprint == null\n            && Boolean.getBoolean(StackProperties.ALWAYS_SIGN))\n        {\n            fingerprint = AttributeFactory.createFingerprintAttribute();\n        }\n\n        if (fingerprint != null)\n        {\n            putAttribute(fingerprint);\n        }\n    }\n\n    /**\n     * Constructs a message from its binary representation.\n     * @param binMessage the binary array that contains the encoded message\n     * @param offset the index where the message starts.\n     * @param arrayLen the length of the message\n     * @return a Message object constructed from the binMessage array\n     *\n     * @throws StunException <tt>ILLEGAL_ARGUMENT</tt> if one or more of the\n     * arguments have invalid values.\n     */\n    public static Message decode(byte[] binMessage, int offset, int arrayLen)\n        throws StunException\n    {\n        int originalOffset = offset;\n        arrayLen = Math.min(binMessage.length, arrayLen);\n\n        if (arrayLen - offset < Message.HEADER_LENGTH)\n        {\n            throw new StunException( StunException.ILLEGAL_ARGUMENT,\n                         \"The given binary array is not a valid StunMessage\");\n        }\n\n        char messageType = (char)((binMessage[offset++] << 8)\n                               | (binMessage[offset++] & 0xFF));\n\n        Message message;\n        /* 0x0115 is a old TURN DATA indication message type */\n        if (Message.isResponseType(messageType) &&\n                messageType != OLD_DATA_INDICATION)\n            message = new Response();\n        else if (Message.isRequestType(messageType))\n            message = new Request();\n        else /* indication */\n            message = new Indication();\n\n        message.setMessageType(messageType);\n\n        int length = (char)((binMessage[offset++] << 8)\n                          | (binMessage[offset++]  & 0xFF));\n\n        /* copy the cookie */\n        byte[] cookie = new byte[4];\n        System.arraycopy(binMessage, offset, cookie, 0, 4);\n        offset += 4;\n\n        boolean rfc3489Compat = false;\n\n        if (!Arrays.equals(MAGIC_COOKIE, cookie))\n        {\n            rfc3489Compat = true;\n        }\n\n        if (arrayLen - offset - TRANSACTION_ID_LENGTH < length)\n        {\n            throw\n                new StunException(\n                        StunException.ILLEGAL_ARGUMENT,\n                        \"The given binary array does not seem to contain\"\n                            + \" a whole StunMessage: given \"\n                            + arrayLen\n                            + \" bytes of \"\n                            + message.getName()\n                            + \" but expecting \"\n                            + (offset + TRANSACTION_ID_LENGTH + length));\n        }\n\n        byte[] tranID = new byte[TRANSACTION_ID_LENGTH];\n        System.arraycopy(binMessage, offset, tranID, 0, TRANSACTION_ID_LENGTH);\n        try\n        {\n            if (rfc3489Compat)\n            {\n                byte[] rfc3489TranID = new byte[TRANSACTION_ID_LENGTH + 4];\n                System.arraycopy(cookie, 0, rfc3489TranID, 0, 4);\n                System.arraycopy(tranID, 0, rfc3489TranID, 4,\n                        TRANSACTION_ID_LENGTH);\n                message.setTransactionID(rfc3489TranID);\n            }\n            else\n            {\n                message.setTransactionID(tranID);\n            }\n        }\n        catch (StunException exc)\n        {\n            throw new StunException( StunException.ILLEGAL_ARGUMENT,\n                            \"The given binary array does not seem to \"\n                            + \"contain a whole StunMessage\", exc);\n        }\n\n        offset += TRANSACTION_ID_LENGTH;\n\n        while (offset - Message.HEADER_LENGTH < length)\n        {\n            Attribute att = AttributeDecoder.decode(\n                binMessage, offset, (char)(length - offset));\n\n            performAttributeSpecificActions(att, binMessage,\n                originalOffset, offset);\n\n            message.putAttribute(att);\n            offset += att.getDataLength() + Attribute.HEADER_LENGTH;\n\n            //now also skip any potential padding that might have come with\n            //this attribute.\n            if ((att.getDataLength() % 4) > 0)\n            {\n                offset += (4 - (att.getDataLength() % 4));\n            }\n        }\n\n        return message;\n    }\n\n    /**\n     * Executes actions related specific attributes like asserting proper\n     * fingerprint checksum.\n     *\n     * @param attribute the <tt>Attribute</tt> we'd like to process.\n     * @param binMessage the byte array that the message arrived with.\n     * @param offset the index where data starts in <tt>binMessage</tt>.\n     * @param msgLen the number of message bytes in <tt>binMessage</tt>.\n     *\n     * @throws StunException if there's something in the <tt>attribute</tt> that\n     * caused us to discard the whole message (e.g. an invalid checksum or\n     * username)\n     */\n    private static void performAttributeSpecificActions(Attribute attribute,\n                                                        byte[]    binMessage,\n                                                        int       offset,\n                                                        int       msgLen)\n        throws StunException\n    {\n        //check finger print CRC\n        if (attribute instanceof FingerprintAttribute)\n        {\n            if (!validateFingerprint((FingerprintAttribute)attribute,\n                            binMessage, offset, msgLen))\n            {\n                //RFC 5389 says that we should ignore bad CRCs rather than\n                //reply with an error response.\n                throw new StunException(\"Wrong value in FINGERPRINT\");\n            }\n        }\n    }\n\n    /**\n     * Recalculates the FINGERPRINT CRC32 checksum of the <tt>message</tt>\n     * array so that we could compare it with the value brought by the\n     * {@link FingerprintAttribute}.\n     *\n     * @param fingerprint the attribute that we need to validate.\n     * @param message the message whose CRC32 checksum we'd need to recalculate.\n     * @param offset the index in <tt>message</tt> where data starts.\n     * @param length the number of bytes in <tt>message</tt> that the CRC32\n     * would need to be calculated over.\n     *\n     * @return <tt>true</tt> if <tt>FINGERPRINT</tt> contains a valid CRC32\n     * value and <tt>false</tt> otherwise.\n     */\n    private static boolean validateFingerprint(FingerprintAttribute fingerprint,\n                                               byte[]               message,\n                                               int                  offset,\n                                               int                  length)\n    {\n\n        byte[] incomingCrcBytes = fingerprint.getChecksum();\n\n        //now check whether the CRC really is what it's supposed to be.\n        //re calculate the check sum\n        byte[] realCrcBytes = FingerprintAttribute.calculateXorCRC32(\n                        message, offset, length);\n\n        //CRC validation.\n        if ( ! Arrays.equals(incomingCrcBytes, realCrcBytes))\n        {\n            if (logger.isLoggable(Level.FINE))\n            {\n                logger.fine(\n                        \"An incoming message arrived with a wrong FINGERPRINT \"\n                        +\"attribute value. \"\n                        +\"CRC Was:\"  + Arrays.toString(incomingCrcBytes)\n                        + \". Should have been:\" + Arrays.toString(realCrcBytes)\n                        +\". Will ignore.\");\n            }\n\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Verify that the message has all obligatory attributes and throw an\n     * exception if this is not the case.\n     *\n     * @throws IllegalStateException if the message does not have all\n     * required attributes.\n     */\n    protected void validateAttributePresentity()\n        throws IllegalStateException\n    {\n        if (! rfc3489CompatibilityMode )\n            return;\n\n        for (char i = Attribute.MAPPED_ADDRESS; i < Attribute.REFLECTED_FROM; i++)\n            if (getAttributePresentity(i) == M && getAttribute(i) == null)\n                throw new IllegalStateException(\n                    \"A mandatory attribute (type=\" + (int)i + \") is missing!\");\n    }\n\n    /**\n     * Determines if the message type is a Error Response.\n     * @param type type to test\n     * @return true if the type is Error Response, false otherwise\n     */\n    public static boolean isErrorResponseType(char type)\n    {\n      return ((type & MESSAGE_CLASS_MASK) == STUN_ERROR_RESP);\n    }\n\n    /**\n     * Determines if the message type is a Success Response.\n     * @param type type to test\n     * @return true if the type is Success Response, false otherwise\n     */\n    public static boolean isSuccessResponseType(char type)\n    {\n        return ((type & MESSAGE_CLASS_MASK) == STUN_SUCCESS_RESP);\n    }\n\n    /**\n     * Determines whether type could be the type of a STUN Response (as opposed\n     * to STUN Request).\n     * @param type the type to test.\n     * @return true if type is a valid response type.\n     */\n    public static boolean isResponseType(char type)\n    {\n        /* return (((type >> 8) & 1) != 0); */\n        return (isSuccessResponseType(type) || isErrorResponseType(type));\n    }\n\n    /**\n     * Determines if the message type is Indication.\n     * @param type type to test\n     * @return true if the type is Indication, false otherwise\n     */\n    public static boolean isIndicationType(char type)\n    {\n      return ((type & MESSAGE_CLASS_MASK) == STUN_INDICATION);\n    }\n\n    /**\n     * Determines whether type could be the type of a STUN Request (as opposed\n     * to STUN Response).\n     * @param type the type to test.\n     * @return true if type is a valid request type.\n     */\n    public static boolean isRequestType(char type)\n    {\n        /* return !isResponseType(type); */\n        return ((type & MESSAGE_CLASS_MASK) == STUN_REQUEST);\n    }\n\n    /**\n     * Returns a <tt>String</tt> representation of this message.\n     *\n     * @return  a <tt>String</tt> representation of this message.\n     */\n    @Override\n    public String toString()\n    {\n        StringBuilder stringBuilder = new StringBuilder();\n\n        stringBuilder.append(getName());\n        stringBuilder.append(\"(0x\");\n        stringBuilder.append(Integer.toHexString(getMessageType()));\n        stringBuilder.append(\")[attrib.count=\");\n        stringBuilder.append(getAttributeCount());\n        stringBuilder.append(\" len=\");\n        stringBuilder.append((int) this.getDataLength());\n\n        byte[] transactionID = getTransactionID();\n\n        if (transactionID != null)\n        {\n            stringBuilder.append(\" tranID=\");\n            stringBuilder.append(TransactionID.toString(transactionID));\n        }\n        stringBuilder.append(\"]\");\n        return stringBuilder.toString();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(Message.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>Message</tt> class and its instances\nfor logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(Message.class.getName())", "syntax_pass": true}, {"attribute_expression": "private static final char MESSAGE_CLASS_MASK = 0x0110;", "docstring": "\nThe mask of the two bits from the message type structure, which indicate\nthe message class.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "MESSAGE_CLASS_MASK = 0x0110", "syntax_pass": true}, {"attribute_expression": "public static final char STUN_REQUEST = 0x0000;", "docstring": "\nSTUN request code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "STUN_REQUEST = 0x0000", "syntax_pass": true}, {"attribute_expression": "public static final char STUN_INDICATION = 0x0010;", "docstring": "\nSTUN indication code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "STUN_INDICATION = 0x0010", "syntax_pass": true}, {"attribute_expression": "public static final char STUN_SUCCESS_RESP = 0x0100;", "docstring": "\nSTUN success response code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "STUN_SUCCESS_RESP = 0x0100", "syntax_pass": true}, {"attribute_expression": "public static final char STUN_ERROR_RESP = 0x0110;", "docstring": "\nSTUN error response code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "STUN_ERROR_RESP = 0x0110", "syntax_pass": true}, {"attribute_expression": "public static final char STUN_METHOD_BINDING = 0x0001;", "docstring": "\nSTUN binding method.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "STUN_METHOD_BINDING = 0x0001", "syntax_pass": true}, {"attribute_expression": "public static final char BINDING_REQUEST\n        = (STUN_METHOD_BINDING | STUN_REQUEST);", "docstring": "\nSTUN binding request code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "BINDING_REQUEST\n        = (STUN_METHOD_BINDING | STUN_REQUEST)", "syntax_pass": true}, {"attribute_expression": "public static final char BINDING_SUCCESS_RESPONSE\n        = (STUN_METHOD_BINDING | STUN_SUCCESS_RESP);", "docstring": "\nSTUN binding success response code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "BINDING_SUCCESS_RESPONSE\n        = (STUN_METHOD_BINDING | STUN_SUCCESS_RESP)", "syntax_pass": true}, {"attribute_expression": "public static final char BINDING_ERROR_RESPONSE\n        = (STUN_METHOD_BINDING | STUN_ERROR_RESP);", "docstring": "\nSTUN binding error response code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "BINDING_ERROR_RESPONSE\n        = (STUN_METHOD_BINDING | STUN_ERROR_RESP)", "syntax_pass": true}, {"attribute_expression": "public static final char BINDING_INDICATION\n        = (STUN_METHOD_BINDING | STUN_INDICATION);", "docstring": "\nSTUN binding request code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "BINDING_INDICATION\n        = (STUN_METHOD_BINDING | STUN_INDICATION)", "syntax_pass": true}, {"attribute_expression": "public static final char SHARED_SECRET_REQUEST = 0x0002;", "docstring": "\nSTUN shared secret request.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "SHARED_SECRET_REQUEST = 0x0002", "syntax_pass": true}, {"attribute_expression": "public static final char SHARED_SECRET_RESPONSE = 0x0102;", "docstring": "\nSTUN shared secret response.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "SHARED_SECRET_RESPONSE = 0x0102", "syntax_pass": true}, {"attribute_expression": "public static final char SHARED_SECRET_ERROR_RESPONSE = 0x0112;", "docstring": "\nSTUN shared secret error response.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "SHARED_SECRET_ERROR_RESPONSE = 0x0112", "syntax_pass": true}, {"attribute_expression": "public static final char TURN_METHOD_ALLOCATE = 0x0003;", "docstring": "\nTURN allocate method code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "TURN_METHOD_ALLOCATE = 0x0003", "syntax_pass": true}, {"attribute_expression": "public static final char TURN_METHOD_REFRESH = 0x0004;", "docstring": "\nTURN refresh method code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "TURN_METHOD_REFRESH = 0x0004", "syntax_pass": true}, {"attribute_expression": "public static final char TURN_METHOD_SEND = 0x0006;", "docstring": "\nTURN send method code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "TURN_METHOD_SEND = 0x0006", "syntax_pass": true}, {"attribute_expression": "public static final char TURN_METHOD_DATA = 0x0007;", "docstring": "\nTURN data method code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "TURN_METHOD_DATA = 0x0007", "syntax_pass": true}, {"attribute_expression": "public static final char TURN_METHOD_CREATEPERMISSION = 0x0008;", "docstring": "\nTURN CreatePermission method code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "TURN_METHOD_CREATEPERMISSION = 0x0008", "syntax_pass": true}, {"attribute_expression": "public static final char TURN_METHOD_CHANNELBIND = 0x0009;", "docstring": "\nTURN ChannelBind method code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "TURN_METHOD_CHANNELBIND = 0x0009", "syntax_pass": true}, {"attribute_expression": "public static final char TURN_METHOD_CONNECT = 0X000a;", "docstring": "\nTURN Connect method code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "TURN_METHOD_CONNECT = 0X000a", "syntax_pass": true}, {"attribute_expression": "public static final char TURN_METHOD_CONNECTION_BIND = 0X000b;", "docstring": "\nTURN ConnectionBind method code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "TURN_METHOD_CONNECTION_BIND = 0X000b", "syntax_pass": true}, {"attribute_expression": "public static final char TURN_METHOD_CONNECTION_ATTEMPT = 0X000c;", "docstring": "\nTURN ConnectionAttempt method code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "TURN_METHOD_CONNECTION_ATTEMPT = 0X000c", "syntax_pass": true}, {"attribute_expression": "public static final char ALLOCATE_REQUEST\n        = (TURN_METHOD_ALLOCATE | STUN_REQUEST);", "docstring": "\nTURN allocate request code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ALLOCATE_REQUEST\n        = (TURN_METHOD_ALLOCATE | STUN_REQUEST)", "syntax_pass": true}, {"attribute_expression": "public static final char ALLOCATE_RESPONSE\n        = (TURN_METHOD_ALLOCATE | STUN_SUCCESS_RESP);", "docstring": "\nTURN allocate response code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ALLOCATE_RESPONSE\n        = (TURN_METHOD_ALLOCATE | STUN_SUCCESS_RESP)", "syntax_pass": true}, {"attribute_expression": "public static final char ALLOCATE_ERROR_RESPONSE\n        = (TURN_METHOD_ALLOCATE | STUN_ERROR_RESP);", "docstring": "\nTURN allocate error response code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ALLOCATE_ERROR_RESPONSE\n        = (TURN_METHOD_ALLOCATE | STUN_ERROR_RESP)", "syntax_pass": true}, {"attribute_expression": "public static final char REFRESH_REQUEST\n        = (TURN_METHOD_REFRESH | STUN_REQUEST);", "docstring": "\nTURN refresh request code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "REFRESH_REQUEST\n        = (TURN_METHOD_REFRESH | STUN_REQUEST)", "syntax_pass": true}, {"attribute_expression": "public static final char ALLOCATE_REFRESH_REQUEST\n        = (TURN_METHOD_ALLOCATE | REFRESH_REQUEST);", "docstring": "\nTURN allocate refresh request code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ALLOCATE_REFRESH_REQUEST\n        = (TURN_METHOD_ALLOCATE | REFRESH_REQUEST)", "syntax_pass": true}, {"attribute_expression": "public static final char REFRESH_RESPONSE\n        = (TURN_METHOD_REFRESH | STUN_SUCCESS_RESP);", "docstring": "\nTURN refresh response code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "REFRESH_RESPONSE\n        = (TURN_METHOD_REFRESH | STUN_SUCCESS_RESP)", "syntax_pass": true}, {"attribute_expression": "public static final char REFRESH_ERROR_RESPONSE\n        = (TURN_METHOD_REFRESH | STUN_ERROR_RESP);", "docstring": "\nTURN refresh error response code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "REFRESH_ERROR_RESPONSE\n        = (TURN_METHOD_REFRESH | STUN_ERROR_RESP)", "syntax_pass": true}, {"attribute_expression": "public static final char CHANNELBIND_REQUEST\n        = (TURN_METHOD_CHANNELBIND | STUN_REQUEST);", "docstring": "\nTURN ChannelBind request code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CHANNELBIND_REQUEST\n        = (TURN_METHOD_CHANNELBIND | STUN_REQUEST)", "syntax_pass": true}, {"attribute_expression": "public static final char CHANNELBIND_RESPONSE\n        = (TURN_METHOD_CHANNELBIND | STUN_SUCCESS_RESP);", "docstring": "\nTURN ChannelBind response code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CHANNELBIND_RESPONSE\n        = (TURN_METHOD_CHANNELBIND | STUN_SUCCESS_RESP)", "syntax_pass": true}, {"attribute_expression": "public static final char CHANNELBIND_ERROR_RESPONSE\n        = (TURN_METHOD_CHANNELBIND | STUN_ERROR_RESP);", "docstring": "\nTURN ChannelBind error response code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CHANNELBIND_ERROR_RESPONSE\n        = (TURN_METHOD_CHANNELBIND | STUN_ERROR_RESP)", "syntax_pass": true}, {"attribute_expression": "public static final char CREATEPERMISSION_REQUEST\n        = (TURN_METHOD_CREATEPERMISSION | STUN_REQUEST);", "docstring": "\nTURN CreatePermission request code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CREATEPERMISSION_REQUEST\n        = (TURN_METHOD_CREATEPERMISSION | STUN_REQUEST)", "syntax_pass": true}, {"attribute_expression": "public static final char CREATEPERMISSION_RESPONSE\n        = (TURN_METHOD_CREATEPERMISSION | STUN_SUCCESS_RESP);", "docstring": "\nTURN CreatePermission response code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CREATEPERMISSION_RESPONSE\n        = (TURN_METHOD_CREATEPERMISSION | STUN_SUCCESS_RESP)", "syntax_pass": true}, {"attribute_expression": "public static final char CREATEPERMISSION_ERROR_RESPONSE\n        = (TURN_METHOD_CREATEPERMISSION | STUN_ERROR_RESP);", "docstring": "\nTURN CreatePermission error response code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CREATEPERMISSION_ERROR_RESPONSE\n        = (TURN_METHOD_CREATEPERMISSION | STUN_ERROR_RESP)", "syntax_pass": true}, {"attribute_expression": "public static final char SEND_INDICATION\n        = (TURN_METHOD_SEND | STUN_INDICATION);", "docstring": "\nTURN send indication code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "SEND_INDICATION\n        = (TURN_METHOD_SEND | STUN_INDICATION)", "syntax_pass": true}, {"attribute_expression": "public static final char DATA_INDICATION\n        = (TURN_METHOD_DATA | STUN_INDICATION);", "docstring": "\nTURN data indication code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "DATA_INDICATION\n        = (TURN_METHOD_DATA | STUN_INDICATION)", "syntax_pass": true}, {"attribute_expression": "public static final char CONNECT_REQUEST\n        = (TURN_METHOD_CONNECT | STUN_REQUEST);", "docstring": "\nTURN Connect Request code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CONNECT_REQUEST\n        = (TURN_METHOD_CONNECT | STUN_REQUEST)", "syntax_pass": true}, {"attribute_expression": "public static final char CONNECT_RESPONSE\n        = (TURN_METHOD_CONNECT | STUN_SUCCESS_RESP);", "docstring": "\nTURN Connect Success Response code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CONNECT_RESPONSE\n        = (TURN_METHOD_CONNECT | STUN_SUCCESS_RESP)", "syntax_pass": true}, {"attribute_expression": "public static final char CONNECT_ERROR_RESPONSE\n        = (TURN_METHOD_CONNECT | STUN_ERROR_RESP);", "docstring": "\nTURN Connect Error Response code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CONNECT_ERROR_RESPONSE\n        = (TURN_METHOD_CONNECT | STUN_ERROR_RESP)", "syntax_pass": true}, {"attribute_expression": "public static final char CONNECTION_BIND_REQUEST\n        = (TURN_METHOD_CONNECTION_BIND | STUN_REQUEST);", "docstring": "\nTURN Connection Bind Request code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CONNECTION_BIND_REQUEST\n        = (TURN_METHOD_CONNECTION_BIND | STUN_REQUEST)", "syntax_pass": true}, {"attribute_expression": "public static final char CONNECTION_BIND_SUCCESS_RESPONSE\n        = (TURN_METHOD_CONNECTION_BIND | STUN_SUCCESS_RESP);", "docstring": "\nTURN Connection Bind Success Response code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CONNECTION_BIND_SUCCESS_RESPONSE\n        = (TURN_METHOD_CONNECTION_BIND | STUN_SUCCESS_RESP)", "syntax_pass": true}, {"attribute_expression": "public static final char CONNECTION_BIND_ERROR_RESPONSE\n        = (TURN_METHOD_CONNECTION_BIND | STUN_ERROR_RESP);", "docstring": "\nTURN Connection Bind error code. \n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CONNECTION_BIND_ERROR_RESPONSE\n        = (TURN_METHOD_CONNECTION_BIND | STUN_ERROR_RESP)", "syntax_pass": true}, {"attribute_expression": "public static final char CONNECTION_ATTEMPT_INDICATION\n        = (TURN_METHOD_CONNECTION_ATTEMPT | STUN_INDICATION);", "docstring": "\nTURN Connection Attempt Indication code.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CONNECTION_ATTEMPT_INDICATION\n        = (TURN_METHOD_CONNECTION_ATTEMPT | STUN_INDICATION)", "syntax_pass": true}, {"attribute_expression": "public static final char SEND_REQUEST = 0x0004;", "docstring": "\nTURN Send request.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "SEND_REQUEST = 0x0004", "syntax_pass": true}, {"attribute_expression": "public static final char OLD_DATA_INDICATION = 0x0115;", "docstring": "\nTURN Send request.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "OLD_DATA_INDICATION = 0x0115", "syntax_pass": true}, {"attribute_expression": "public static final byte HEADER_LENGTH = 20;", "docstring": "\nThe length of Stun Message Headers in bytes\n= len(Type) + len(DataLength) + len(Transaction ID).\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "HEADER_LENGTH = 20", "syntax_pass": true}, {"attribute_expression": "protected char messageType = 0x0000;", "docstring": "\nIndicates the type of the message. The message type can be Binding Request,\nBinding Response, Binding Error Response, Shared Secret Request, Shared\nSecret Response, or Shared Secret Error Response.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "char", "name": "messageType = 0x0000", "syntax_pass": true}, {"attribute_expression": "protected byte[] transactionID = null;", "docstring": "\nThe transaction ID is used to correlate requests and responses.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "byte[]", "name": "transactionID = null", "syntax_pass": true}, {"attribute_expression": "public static final byte[] MAGIC_COOKIE = { 0x21, 0x12, (byte)0xA4, 0x42 };", "docstring": "\nThe magic cookie (0x2112A442).\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte[]", "name": "MAGIC_COOKIE = { 0x21, 0x12, (byte)0xA4, 0x42 }", "syntax_pass": true}, {"attribute_expression": "public static final byte TRANSACTION_ID_LENGTH = 12;", "docstring": "\nThe length of the transaction id (in bytes).\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "TRANSACTION_ID_LENGTH = 12", "syntax_pass": true}, {"attribute_expression": "public static final byte RFC3489_TRANSACTION_ID_LENGTH = 16;", "docstring": "\nThe length of the RFC3489 transaction id (in bytes).\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "RFC3489_TRANSACTION_ID_LENGTH = 16", "syntax_pass": true}, {"attribute_expression": "protected final LinkedHashMap<Character, Attribute> attributes\n        = new LinkedHashMap<>();", "docstring": "not sure this is the best solution but I'm trying to keep entry order", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "LinkedHashMap<Character, Attribute>", "name": "attributes\n        = new LinkedHashMap<>()", "syntax_pass": true}, {"attribute_expression": "private static boolean rfc3489CompatibilityMode = false;", "docstring": "\nAttribute presentity is a thing of RFC 3489 and no longer exists in\n5389. we are not using it any longer and if at some point we decide we\nneed it in certain situations, then make extend use of the following\nfield.\n", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "boolean", "name": "rfc3489CompatibilityMode = false", "syntax_pass": true}, {"attribute_expression": "private static final byte N_A = 0;", "docstring": "\nDescribes which attributes are present in which messages.  An\nM indicates that inclusion of the attribute in the message is\nmandatory, O means its optional, C means it's conditional based on\nsome other aspect of the message, and N/A means that the attribute is\nnot applicable to that message type.\n\nFor classic STUN :\n\n<pre>\n                                        Binding  Shared  Shared  Shared\n                      Binding  Binding  Error    Secret  Secret  Secret\n  Att.                Req.     Resp.    Resp.    Req.    Resp.   Error \n                                                                 Resp. \n  _____________________________________________________________________\n  MAPPED-ADDRESS      N/A      M        N/A      N/A     N/A     N/A   \n  RESPONSE-ADDRESS    O        N/A      N/A      N/A     N/A     N/A   \n  CHANGE-REQUEST      O        N/A      N/A      N/A     N/A     N/A   \n  SOURCE-ADDRESS      N/A      M        N/A      N/A     N/A     N/A   \n  CHANGED-ADDRESS     N/A      M        N/A      N/A     N/A     N/A   \n  USERNAME            O        N/A      N/A      N/A     M       N/A   \n  PASSWORD            N/A      N/A      N/A      N/A     M       N/A   \n  MESSAGE-INTEGRITY   O        O        N/A      N/A     N/A     N/A   \n  ERROR-CODE          N/A      N/A      M        N/A     N/A     M     \n  UNKNOWN-ATTRIBUTES  N/A      N/A      C        N/A     N/A     C     \n  REFLECTED-FROM      N/A      C        N/A      N/A     N/A     N/A   \n  XOR-MAPPED-ADDRESS  N/A      M        N/A      N/A     N/A     N/A   \n  XOR-ONLY            O        N/A      N/A      N/A     N/A     N/A   \n  SOFTWARE            N/A      O        O        N/A     O       O     \n</pre>\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "byte", "name": "N_A = 0", "syntax_pass": true}, {"attribute_expression": "private static final byte C = 1;", "docstring": "\nC means it's conditional based on some other aspect of the message.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "byte", "name": "C = 1", "syntax_pass": true}, {"attribute_expression": "public static final byte O = 2;", "docstring": "\nO means the parameter is optional.\n\n@see Message#N_A\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "O = 2", "syntax_pass": true}, {"attribute_expression": "public static final byte M = 3;", "docstring": "\nM indicates that inclusion of the attribute in the message is\nmandatory.\n\n@see Message#N_A\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "byte", "name": "M = 3", "syntax_pass": true}, {"attribute_expression": "protected static final byte BINDING_REQUEST_PRESENTITY_INDEX           = 0;", "docstring": "Message indices", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "BINDING_REQUEST_PRESENTITY_INDEX           = 0", "syntax_pass": true}, {"attribute_expression": "protected static final byte BINDING_RESPONSE_PRESENTITY_INDEX          = 1;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "BINDING_RESPONSE_PRESENTITY_INDEX          = 1", "syntax_pass": true}, {"attribute_expression": "protected static final byte BINDING_ERROR_RESPONSE_PRESENTITY_INDEX    = 2;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "BINDING_ERROR_RESPONSE_PRESENTITY_INDEX    = 2", "syntax_pass": true}, {"attribute_expression": "protected static final byte SHARED_SECRET_REQUEST_PRESENTITY_INDEX     = 3;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "SHARED_SECRET_REQUEST_PRESENTITY_INDEX     = 3", "syntax_pass": true}, {"attribute_expression": "protected static final byte SHARED_SECRET_RESPONSE_PRESENTITY_INDEX    = 4;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "SHARED_SECRET_RESPONSE_PRESENTITY_INDEX    = 4", "syntax_pass": true}, {"attribute_expression": "protected static final byte SHARED_SECRET_ERROR_RESPONSE_PRESENTITY_INDEX =\n        5;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "SHARED_SECRET_ERROR_RESPONSE_PRESENTITY_INDEX =\n        5", "syntax_pass": true}, {"attribute_expression": "protected static final byte ALLOCATE_REQUEST_PRESENTITY_INDEX          = 6;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "ALLOCATE_REQUEST_PRESENTITY_INDEX          = 6", "syntax_pass": true}, {"attribute_expression": "protected static final byte ALLOCATE_RESPONSE_PRESENTITY_INDEX         = 7;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "ALLOCATE_RESPONSE_PRESENTITY_INDEX         = 7", "syntax_pass": true}, {"attribute_expression": "protected static final byte REFRESH_REQUEST_PRESENTITY_INDEX           = 8;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "REFRESH_REQUEST_PRESENTITY_INDEX           = 8", "syntax_pass": true}, {"attribute_expression": "protected static final byte REFRESH_RESPONSE_PRESENTITY_INDEX          = 9;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "REFRESH_RESPONSE_PRESENTITY_INDEX          = 9", "syntax_pass": true}, {"attribute_expression": "protected static final byte CHANNELBIND_REQUEST_PRESENTITY_INDEX       = 10;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "CHANNELBIND_REQUEST_PRESENTITY_INDEX       = 10", "syntax_pass": true}, {"attribute_expression": "protected static final byte CHANNELBIND_RESPONSE_PRESENTITY_INDEX      = 11;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "CHANNELBIND_RESPONSE_PRESENTITY_INDEX      = 11", "syntax_pass": true}, {"attribute_expression": "protected static final byte SEND_INDICATION_PRESENTITY_INDEX           = 12;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "SEND_INDICATION_PRESENTITY_INDEX           = 12", "syntax_pass": true}, {"attribute_expression": "protected static final byte DATA_INDICATION_PRESENTITY_INDEX           = 13;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "DATA_INDICATION_PRESENTITY_INDEX           = 13", "syntax_pass": true}, {"attribute_expression": "protected static final byte MAPPED_ADDRESS_PRESENTITY_INDEX            =  0;", "docstring": "Attribute indices", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "MAPPED_ADDRESS_PRESENTITY_INDEX            =  0", "syntax_pass": true}, {"attribute_expression": "protected static final byte RESPONSE_ADDRESS_PRESENTITY_INDEX          =  1;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "RESPONSE_ADDRESS_PRESENTITY_INDEX          =  1", "syntax_pass": true}, {"attribute_expression": "protected static final byte CHANGE_REQUEST_PRESENTITY_INDEX            =  2;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "CHANGE_REQUEST_PRESENTITY_INDEX            =  2", "syntax_pass": true}, {"attribute_expression": "protected static final byte SOURCE_ADDRESS_PRESENTITY_INDEX            =  3;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "SOURCE_ADDRESS_PRESENTITY_INDEX            =  3", "syntax_pass": true}, {"attribute_expression": "protected static final byte CHANGED_ADDRESS_PRESENTITY_INDEX           =  4;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "CHANGED_ADDRESS_PRESENTITY_INDEX           =  4", "syntax_pass": true}, {"attribute_expression": "protected static final byte USERNAME_PRESENTITY_INDEX                  =  5;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "USERNAME_PRESENTITY_INDEX                  =  5", "syntax_pass": true}, {"attribute_expression": "protected static final byte PASSWORD_PRESENTITY_INDEX                  =  6;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "PASSWORD_PRESENTITY_INDEX                  =  6", "syntax_pass": true}, {"attribute_expression": "protected static final byte MESSAGE_INTEGRITY_PRESENTITY_INDEX         =  7;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "MESSAGE_INTEGRITY_PRESENTITY_INDEX         =  7", "syntax_pass": true}, {"attribute_expression": "protected static final byte ERROR_CODE_PRESENTITY_INDEX                =  8;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "ERROR_CODE_PRESENTITY_INDEX                =  8", "syntax_pass": true}, {"attribute_expression": "protected static final byte UNKNOWN_ATTRIBUTES_PRESENTITY_INDEX        =  9;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "UNKNOWN_ATTRIBUTES_PRESENTITY_INDEX        =  9", "syntax_pass": true}, {"attribute_expression": "protected static final byte REFLECTED_FROM_PRESENTITY_INDEX            = 10;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "REFLECTED_FROM_PRESENTITY_INDEX            = 10", "syntax_pass": true}, {"attribute_expression": "protected static final byte XOR_MAPPED_ADDRESS_PRESENTITY_INDEX        = 11;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "XOR_MAPPED_ADDRESS_PRESENTITY_INDEX        = 11", "syntax_pass": true}, {"attribute_expression": "protected static final byte XOR_ONLY_PRESENTITY_INDEX                  = 12;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "XOR_ONLY_PRESENTITY_INDEX                  = 12", "syntax_pass": true}, {"attribute_expression": "protected static final byte SOFTWARE_PRESENTITY_INDEX                  = 13;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "SOFTWARE_PRESENTITY_INDEX                  = 13", "syntax_pass": true}, {"attribute_expression": "protected static final byte UNKNOWN_OPTIONAL_ATTRIBUTES_PRESENTITY_INDEX  =\n        14;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "UNKNOWN_OPTIONAL_ATTRIBUTES_PRESENTITY_INDEX  =\n        14", "syntax_pass": true}, {"attribute_expression": "protected static final byte ALTERNATE_SERVER_PRESENTITY_INDEX          = 15;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "ALTERNATE_SERVER_PRESENTITY_INDEX          = 15", "syntax_pass": true}, {"attribute_expression": "protected static final byte REALM_PRESENTITY_INDEX                     = 16;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "REALM_PRESENTITY_INDEX                     = 16", "syntax_pass": true}, {"attribute_expression": "protected static final byte NONCE_PRESENTITY_INDEX                     = 17;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "NONCE_PRESENTITY_INDEX                     = 17", "syntax_pass": true}, {"attribute_expression": "protected static final byte FINGERPRINT_PRESENTITY_INDEX               = 18;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "FINGERPRINT_PRESENTITY_INDEX               = 18", "syntax_pass": true}, {"attribute_expression": "protected static final byte CHANNEL_NUMBER_PRESENTITY_INDEX            = 19;", "docstring": " TURN attributes", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "CHANNEL_NUMBER_PRESENTITY_INDEX            = 19", "syntax_pass": true}, {"attribute_expression": "protected static final byte LIFETIME_PRESENTITY_INDEX                  = 20;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "LIFETIME_PRESENTITY_INDEX                  = 20", "syntax_pass": true}, {"attribute_expression": "protected static final byte XOR_PEER_ADDRESS_PRESENTITY_INDEX          = 21;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "XOR_PEER_ADDRESS_PRESENTITY_INDEX          = 21", "syntax_pass": true}, {"attribute_expression": "protected static final byte DATA_PRESENTITY_INDEX                      = 22;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "DATA_PRESENTITY_INDEX                      = 22", "syntax_pass": true}, {"attribute_expression": "protected static final byte XOR_RELAYED_ADDRESS_PRESENTITY_INDEX       = 23;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "XOR_RELAYED_ADDRESS_PRESENTITY_INDEX       = 23", "syntax_pass": true}, {"attribute_expression": "protected static final byte EVEN_PORT_PRESENTITY_INDEX                 = 24;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "EVEN_PORT_PRESENTITY_INDEX                 = 24", "syntax_pass": true}, {"attribute_expression": "protected static final byte REQUESTED_TRANSPORT_PRESENTITY_INDEX       = 25;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "REQUESTED_TRANSPORT_PRESENTITY_INDEX       = 25", "syntax_pass": true}, {"attribute_expression": "protected static final byte DONT_FRAGMENT_PRESENTITY_INDEX             = 26;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "DONT_FRAGMENT_PRESENTITY_INDEX             = 26", "syntax_pass": true}, {"attribute_expression": "protected static final byte RESERVATION_TOKEN_PRESENTITY_INDEX         = 27;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "RESERVATION_TOKEN_PRESENTITY_INDEX         = 27", "syntax_pass": true}, {"attribute_expression": "protected static final byte PRIORITY_PRESENTITY_INDEX                  = 28;", "docstring": " ICE attributes", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "PRIORITY_PRESENTITY_INDEX                  = 28", "syntax_pass": true}, {"attribute_expression": "protected static final byte ICE_CONTROLLING_PRESENTITY_INDEX           = 29;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "ICE_CONTROLLING_PRESENTITY_INDEX           = 29", "syntax_pass": true}, {"attribute_expression": "protected static final byte ICE_CONTROLLED_PRESENTITY_INDEX            = 30;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "ICE_CONTROLLED_PRESENTITY_INDEX            = 30", "syntax_pass": true}, {"attribute_expression": "protected static final byte USE_CANDIDATE_PRESENTITY_INDEX             = 31;", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "USE_CANDIDATE_PRESENTITY_INDEX             = 31", "syntax_pass": true}, {"attribute_expression": "protected static final byte DESTINATION_ADDRESS_PRESENTITY_INDEX       = 29;", "docstring": " Old TURN attributes", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "byte", "name": "DESTINATION_ADDRESS_PRESENTITY_INDEX       = 29", "syntax_pass": true}, {"attribute_expression": "protected final static byte attributePresentities[][] = new byte[][]{\n    //                                            Binding   Shared   Shared   Shared  Alloc   Alloc   Rfrsh   Rfrsh   ChnlBnd  ChnlBnd Send    Data\n    //                        Binding   Binding   Error     Secret   Secret   Secret  Req.    Resp.   Req.    Resp.   Req.     Resp.   Indic.  Indic.\n    //  Att.                  Req.      Resp.     Resp.     Req.     Resp.    Error\n    //                                                                        Resp.\n    //  ____________________________________________________________________________________________________________________________________________\n      /*MAPPED-ADDRESS*/    { N_A,      M,        N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*RESPONSE-ADDRESS*/  { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*CHANGE-REQUEST*/    { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*SOURCE-ADDRESS*/    { N_A,      M,        N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   M},\n      /*CHANGED-ADDRESS*/   { N_A,      M,        N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*USERNAME*/          { O,        N_A,      N_A,      N_A,     M,       N_A,    O,      N_A,    O,      N_A,    O,       N_A,    N_A,   N_A},\n      /*PASSWORD*/          { N_A,      N_A,      N_A,      N_A,     M,       N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*MESSAGE-INTEGRITY*/ { O,        O,        N_A,      N_A,     N_A,     N_A,    O,      O,      O,      O,      O,       O,      N_A,   N_A},\n      /*ERROR-CODE*/        { N_A,      N_A,      M,        N_A,     N_A,     M,      N_A,    M,      N_A,    M,      N_A,     M,      N_A,   N_A},\n      /*UNKNOWN-ATTRIBUTES*/{ N_A,      N_A,      C,        N_A,     N_A,     C,      N_A,    C,      N_A,    C,      N_A,     C,      N_A,   N_A},\n      /*REFLECTED-FROM*/    { N_A,      C,        N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*XOR-MAPPED-ADDRESS*/{ N_A,      C,        N_A,      N_A,     N_A,     N_A,    N_A,    M,      N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*XOR-ONLY*/          { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*SOFTWARE*/          { N_A,      O,        O,        N_A,     O,       O,      O,      O,      O,      O,      O,       O,      O,     N_A},\n      /*UNKNOWN_OPTIONAL*/  { O,        O,        O,        O,       O,       O,      O,      O,      O,      O,      O,       O,      N_A,   N_A},\n      /*ALTERNATE_SERVER*/  { O,        O,        O,        O,       O,       O,      N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*REALM*/             { O,        N_A,      N_A,      N_A,     M,       N_A,    O,      O,      O,      O,      O,       O,      N_A,   N_A},\n      /*NONCE*/             { O,        N_A,      N_A,      N_A,     M,       N_A,    O,      O,      O,      O,      O,       O,      N_A,   N_A},\n      /*FINGERPRINT*/       { O,        O,        O,        O,       O,       O,      O,      O,      O,      O,      O,       O,      N_A,   N_A},\n      /*CHANNEL-NUMBER*/    { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    M,       N_A,    N_A,   N_A},\n      /*LIFETIME*/          { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    O,      N_A,    O,      N_A,    N_A,     N_A,    N_A,   N_A},\n      /*XOR-PEER-ADDRESS*/  { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    M,       N_A,    M,     M},\n      /*DATA*/              { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    O,      N_A,    N_A,     N_A,    O,     M},\n      /*XOR-RELAYED-ADDRESS*/{N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    M,      N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*EVEN-PORT*/         { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    O,      N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*REQUESTED-TRANSPORT*/{N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    M,      N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*DONT-FRAGMENT*/     { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    O,      N_A,    N_A,    N_A,    N_A,     N_A,    O,     N_A},\n      /*RESERVATION-TOKEN*/ { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    O,      O,      N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*PRIORITY*/          { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*ICE-CONTROLLING*/   { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*ICE-CONTROLLED*/    { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*USE-CANDIDATE*/     { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*DESTINATION-ADDRESS*/{N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    O,      N_A,    N_A,     N_A,    M,     N_A},\n    };", "docstring": " CHECKSTYLE:OFF", "modifiers": "protected final static", "marker_annotations": [], "non_marker_annotations": ["protected", "final", "static"], "comments": [], "type": "byte", "name": "attributePresentities[][] = new byte[][]{\n    //                                            Binding   Shared   Shared   Shared  Alloc   Alloc   Rfrsh   Rfrsh   ChnlBnd  ChnlBnd Send    Data\n    //                        Binding   Binding   Error     Secret   Secret   Secret  Req.    Resp.   Req.    Resp.   Req.     Resp.   Indic.  Indic.\n    //  Att.                  Req.      Resp.     Resp.     Req.     Resp.    Error\n    //                                                                        Resp.\n    //  ____________________________________________________________________________________________________________________________________________\n      /*MAPPED-ADDRESS*/    { N_A,      M,        N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*RESPONSE-ADDRESS*/  { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*CHANGE-REQUEST*/    { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*SOURCE-ADDRESS*/    { N_A,      M,        N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   M},\n      /*CHANGED-ADDRESS*/   { N_A,      M,        N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*USERNAME*/          { O,        N_A,      N_A,      N_A,     M,       N_A,    O,      N_A,    O,      N_A,    O,       N_A,    N_A,   N_A},\n      /*PASSWORD*/          { N_A,      N_A,      N_A,      N_A,     M,       N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*MESSAGE-INTEGRITY*/ { O,        O,        N_A,      N_A,     N_A,     N_A,    O,      O,      O,      O,      O,       O,      N_A,   N_A},\n      /*ERROR-CODE*/        { N_A,      N_A,      M,        N_A,     N_A,     M,      N_A,    M,      N_A,    M,      N_A,     M,      N_A,   N_A},\n      /*UNKNOWN-ATTRIBUTES*/{ N_A,      N_A,      C,        N_A,     N_A,     C,      N_A,    C,      N_A,    C,      N_A,     C,      N_A,   N_A},\n      /*REFLECTED-FROM*/    { N_A,      C,        N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*XOR-MAPPED-ADDRESS*/{ N_A,      C,        N_A,      N_A,     N_A,     N_A,    N_A,    M,      N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*XOR-ONLY*/          { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*SOFTWARE*/          { N_A,      O,        O,        N_A,     O,       O,      O,      O,      O,      O,      O,       O,      O,     N_A},\n      /*UNKNOWN_OPTIONAL*/  { O,        O,        O,        O,       O,       O,      O,      O,      O,      O,      O,       O,      N_A,   N_A},\n      /*ALTERNATE_SERVER*/  { O,        O,        O,        O,       O,       O,      N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*REALM*/             { O,        N_A,      N_A,      N_A,     M,       N_A,    O,      O,      O,      O,      O,       O,      N_A,   N_A},\n      /*NONCE*/             { O,        N_A,      N_A,      N_A,     M,       N_A,    O,      O,      O,      O,      O,       O,      N_A,   N_A},\n      /*FINGERPRINT*/       { O,        O,        O,        O,       O,       O,      O,      O,      O,      O,      O,       O,      N_A,   N_A},\n      /*CHANNEL-NUMBER*/    { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    M,       N_A,    N_A,   N_A},\n      /*LIFETIME*/          { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    O,      N_A,    O,      N_A,    N_A,     N_A,    N_A,   N_A},\n      /*XOR-PEER-ADDRESS*/  { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    M,       N_A,    M,     M},\n      /*DATA*/              { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    O,      N_A,    N_A,     N_A,    O,     M},\n      /*XOR-RELAYED-ADDRESS*/{N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    M,      N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*EVEN-PORT*/         { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    O,      N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*REQUESTED-TRANSPORT*/{N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    M,      N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*DONT-FRAGMENT*/     { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    O,      N_A,    N_A,    N_A,    N_A,     N_A,    O,     N_A},\n      /*RESERVATION-TOKEN*/ { N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    O,      O,      N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*PRIORITY*/          { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*ICE-CONTROLLING*/   { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*ICE-CONTROLLED*/    { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*USE-CANDIDATE*/     { O,        N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    N_A,    N_A,    N_A,     N_A,    N_A,   N_A},\n      /*DESTINATION-ADDRESS*/{N_A,      N_A,      N_A,      N_A,     N_A,     N_A,    N_A,    N_A,    O,      N_A,    N_A,     N_A,    M,     N_A},\n    }", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute", "name": "AddressAttribute", "file_path": "src/main/java/org/ice4j/attribute/AddressAttribute.java", "superclasses": "Attribute", "methods": ["[]AddressAttribute(char)", "[boolean]isTypeValid(char)", "[void]setAttributeType(char)", "[String]getName()", "[boolean]equals(Object)", "[char]getDataLength()", "[byte[]]encode()", "[void]setAddress(TransportAddress)", "[TransportAddress]getAddress()", "[byte[]]getAddressBytes()", "[byte]getFamily()", "[int]getPort()", "[void]decodeAttributeBody(byte[],char,char)"], "method_uris": ["src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[]AddressAttribute(char)", "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[boolean]isTypeValid(char)", "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[void]setAttributeType(char)", "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[void]setAddress(TransportAddress)", "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[TransportAddress]getAddress()", "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[byte[]]getAddressBytes()", "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[byte]getFamily()", "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[int]getPort()", "src/main/java/org/ice4j/attribute/AddressAttribute.java.AddressAttribute.[void]decodeAttributeBody(byte[],char,char)"], "overrides": null, "attributes": [], "class_docstring": "\nThis class is used to represent Stun attributes that contain an address. Such\nattributes are:\n<ul>\n<li>MAPPED-ADDRESS\n<li>RESPONSE-ADDRESS\n<li>SOURCE-ADDRESS\n<li>CHANGED-ADDRESS\n<li>REFLECTED-FROM\n<li>ALTERNATE-SERVER\n<li>XOR-PEER-ADDRESS\n<li>XOR-RELAYED-ADDRESS\n</ul>\n<p>\nThe different attributes are distinguished by the attributeType of\n{@link Attribute}.\n<p>\nAddress attributes indicate the mapped IP address and\nport.  They consist of an eight bit address family, and a sixteen bit\nport, followed by a fixed length value representing the IP address.\n<pre>\n 0                   1                   2                   3   \n 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 \n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|x x x x x x x x|    Family     |           Port                |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n|                             Address                           |\n+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n</pre>\n<p>\nThe port is a network byte ordered representation of the mapped port.\nThe address family is always 0x01, corresponding to IPv4.  The first\n8 bits of the MAPPED-ADDRESS are ignored, for the purposes of\naligning parameters on natural boundaries.  The IPv4 address is 32\nbits.\n</p>\n@author Emil Ivov\n", "original_string": "abstract class AddressAttribute extends Attribute\n{\n    /**\n     * Indicates that this attribute is transporting an IPv4 address\n     */\n    static final byte ADDRESS_FAMILY_IPV4 = 0x01;\n\n    /**\n     * Indicates that this attribute is transporting an IPv6 address\n     */\n    static final byte ADDRESS_FAMILY_IPV6 = 0x02;\n\n     /**\n      * The address represented by this message;\n      */\n     protected TransportAddress address = null;\n\n     /**\n      * The length of the data contained by this attribute in the case of an\n      * IPv6 address.\n      */\n     private static final char DATA_LENGTH_FOR_IPV6 = 20;\n\n     /**\n      * The length of the data contained by this attribute in the case of an\n      * IPv4 address.\n      */\n     private static final char DATA_LENGTH_FOR_IPV4 = 8;\n\n    /**\n     * Constructs an address attribute with the specified type.\n     *\n     * @param attributeType the type of the address attribute.\n     */\n    AddressAttribute(char attributeType)\n    {\n        super(attributeType);\n    }\n    /**\n     * Verifies that type is a valid address attribute type.\n     * @param type the type to test\n     * @return true if the type is a valid address attribute type and false\n     * otherwise\n     */\n    private boolean isTypeValid(char type)\n    {\n        return (type == MAPPED_ADDRESS || type == RESPONSE_ADDRESS\n                || type == SOURCE_ADDRESS || type == CHANGED_ADDRESS\n                || type == REFLECTED_FROM || type == XOR_MAPPED_ADDRESS\n                || type == ALTERNATE_SERVER || type == XOR_PEER_ADDRESS\n                || type == XOR_RELAYED_ADDRESS || type == DESTINATION_ADDRESS);\n    }\n\n    /**\n     * Sets it as this attribute's type.\n     *\n     * @param type the new type of the attribute.\n     */\n    protected void setAttributeType(char  type)\n    {\n        if (!isTypeValid(type))\n            throw new IllegalArgumentException(((int)type)\n                                + \"is not a valid address attribute!\");\n\n        super.setAttributeType(type);\n    }\n\n    /**\n     * Returns the human readable name of this attribute. Attribute names do\n     * not really matter from the protocol point of view. They are only used\n     * for debugging and readability.\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        switch(getAttributeType())\n        {\n            case MAPPED_ADDRESS:     return MappedAddressAttribute.NAME;\n            case RESPONSE_ADDRESS:   return ResponseAddressAttribute.NAME;\n            case SOURCE_ADDRESS:     return SourceAddressAttribute.NAME;\n            case CHANGED_ADDRESS:    return ChangedAddressAttribute.NAME;\n            case REFLECTED_FROM:     return ReflectedFromAttribute.NAME;\n            case XOR_MAPPED_ADDRESS: return XorMappedAddressAttribute.NAME;\n            case ALTERNATE_SERVER:   return AlternateServerAttribute.NAME;\n            case XOR_PEER_ADDRESS:   return XorPeerAddressAttribute.NAME;\n            case XOR_RELAYED_ADDRESS:return XorRelayedAddressAttribute.NAME;\n        }\n\n        return \"UNKNOWN ATTRIBUTE\";\n    }\n\n   /**\n    * Compares two STUN Attributes. Attributes are considered equal when their\n    * type, length, and all data are the same.\n    *\n    * @param obj the object to compare this attribute with.\n    * @return true if the attributes are equal and false otherwise.\n    */\n    public boolean equals(Object obj)\n    {\n        if (! (obj instanceof AddressAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        AddressAttribute att = (AddressAttribute) obj;\n        if (att.getAttributeType() != getAttributeType()\n            || att.getDataLength() != getDataLength()\n            //compare data\n            || att.getFamily()     != getFamily()\n            || (att.getAddress()   != null\n                && !address.equals(att.getAddress()))\n            )\n            return false;\n\n        //addresses\n        if ( att.getAddress() == null && getAddress() == null)\n            return true;\n\n        return true;\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     * @return the length of this attribute's value (8 bytes).\n     */\n    public char getDataLength()\n    {\n        if (getFamily() == ADDRESS_FAMILY_IPV6)\n            return DATA_LENGTH_FOR_IPV6;\n        else\n            return DATA_LENGTH_FOR_IPV4;\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        char type = getAttributeType();\n        if (!isTypeValid(type))\n            throw new IllegalStateException(((int)type)\n                            + \"is not a valid address attribute!\");\n        byte binValue[] = new byte[HEADER_LENGTH + getDataLength()];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n        //Not used\n        binValue[4] = 0x00;\n        //Family\n        binValue[5] = getFamily();\n        //port\n        binValue[6] = (byte)(getPort() >> 8);\n        binValue[7] = (byte)(getPort() & 0x00FF);\n\n        //address\n        if (getFamily() == ADDRESS_FAMILY_IPV6)\n        {\n            System.arraycopy(getAddressBytes(), 0, binValue, 8, 16);\n        }\n        else\n        {\n            System.arraycopy(getAddressBytes(), 0, binValue, 8, 4);\n        }\n\n        return binValue;\n    }\n\n    /**\n     * Sets address to be the address transported by this attribute.\n     * @param address that this attribute should encapsulate.\n     */\n    public void setAddress(TransportAddress address)\n    {\n        this.address = address;\n    }\n\n    /**\n     * Returns the address encapsulated by this attribute.\n     *\n     * @return the address encapsulated by this attribute.\n     */\n    public TransportAddress getAddress()\n    {\n        return address;\n    }\n\n    /**\n     * Returns the bytes of the address.\n     *\n     * @return the <tt>byte[]</tt> array containing the address.\n     */\n    public byte[] getAddressBytes()\n    {\n        return address.getAddressBytes();\n    }\n\n    /**\n     * Returns the family that the this.address belongs to.\n     * @return the family that the this.address belongs to.\n     */\n    public byte getFamily()\n    {\n        if ( address.getAddress() instanceof Inet6Address )\n            return ADDRESS_FAMILY_IPV6;\n        else\n            return ADDRESS_FAMILY_IPV4;\n    }\n\n    /**\n     * Returns the port associated with the address contained by the attribute.\n     * @return the port associated with the address contained by the attribute.\n     */\n    public int getPort()\n    {\n        return address.getPort();\n    }\n\n    /**\n      * Sets this attribute's fields according to attributeValue array.\n      *\n      * @param attributeValue a binary array containing this attribute's field\n      *                       values and NOT containing the attribute header.\n      * @param offset the position where attribute values begin (most often\n      *                  offset is equal to the index of the first byte after\n      *                  length)\n      * @param length the length of the binary array.\n      * @throws StunException if attrubteValue contains invalid data.\n      */\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n        throws StunException\n    {\n        //skip through padding\n        offset ++;\n\n        //get family\n        byte family = attributeValue[offset++];\n\n        //port\n        char port = ((char)((attributeValue[offset++] << 8 )\n                        | (attributeValue[offset++] & 0xFF) ));\n\n        //address\n        byte address[] = null;\n        if (family == ADDRESS_FAMILY_IPV6)\n        {\n            address = new byte[16];\n        }\n        else\n        {\n            //ipv4\n            address = new byte[4];\n        }\n\n        System.arraycopy(attributeValue, offset, address, 0, address.length);\n        try\n        {\n            setAddress(new TransportAddress(address, port, Transport.UDP));\n        }\n        catch (UnknownHostException e)\n        {\n            throw new StunException(e);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final byte ADDRESS_FAMILY_IPV4 = 0x01;", "docstring": "\nIndicates that this attribute is transporting an IPv4 address\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "byte", "name": "ADDRESS_FAMILY_IPV4 = 0x01", "syntax_pass": true}, {"attribute_expression": "static final byte ADDRESS_FAMILY_IPV6 = 0x02;", "docstring": "\nIndicates that this attribute is transporting an IPv6 address\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "byte", "name": "ADDRESS_FAMILY_IPV6 = 0x02", "syntax_pass": true}, {"attribute_expression": "protected TransportAddress address = null;", "docstring": "\nThe address represented by this message;\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "TransportAddress", "name": "address = null", "syntax_pass": true}, {"attribute_expression": "private static final char DATA_LENGTH_FOR_IPV6 = 20;", "docstring": "\nThe length of the data contained by this attribute in the case of an\nIPv6 address.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "DATA_LENGTH_FOR_IPV6 = 20", "syntax_pass": true}, {"attribute_expression": "private static final char DATA_LENGTH_FOR_IPV4 = 8;", "docstring": "\nThe length of the data contained by this attribute in the case of an\nIPv4 address.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "DATA_LENGTH_FOR_IPV4 = 8", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute", "name": "IceControlAttribute", "file_path": "src/main/java/org/ice4j/attribute/IceControlAttribute.java", "superclasses": "Attribute", "methods": ["[]IceControlAttribute(boolean)", "[void]decodeAttributeBody(byte[],char,char)", "[byte[]]encode()", "[boolean]equals(Object)", "[char]getDataLength()", "[String]getName()", "[void]setTieBreaker(long)", "[long]getTieBreaker()"], "method_uris": ["src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[]IceControlAttribute(boolean)", "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[void]decodeAttributeBody(byte[],char,char)", "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[String]getName()", "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[void]setTieBreaker(long)", "src/main/java/org/ice4j/attribute/IceControlAttribute.java.IceControlAttribute.[long]getTieBreaker()"], "overrides": null, "attributes": [], "class_docstring": "\n\n@author Emil Ivov\n", "original_string": "public abstract class IceControlAttribute\n    extends Attribute\n{\n    /**\n     * The length of the data contained in this attribute\n     */\n    static final char DATA_LENGTH_ICE_CONTROL = 8;\n\n    /**\n     * The tie-breaker value stored in this attribute\n     */\n    long tieBreaker;\n\n    /**\n     * Indicates whether this is an <tt>ICE-CONTROLLING</tt> or an\n     * <tt>ICE-CONTROLLED</tt> attribute.\n     */\n    boolean isControlling;\n\n    /**\n     * Constructs an ICE-CONTROLLING or an ICE-CONTROLLED attribute depending\n     * on the value of <tt>isControlling</tt>.\n     *\n     * @param isControlling indicates the kind of attribute we are trying to\n     * create\n     */\n    IceControlAttribute(boolean isControlling)\n    {\n        super(isControlling ? ICE_CONTROLLING : ICE_CONTROLLED);\n        this.isControlling = isControlling;\n    }\n\n    /**\n     * Sets this attribute's fields according to attributeValue array.\n     *\n     * @param attributeValue a binary array containing this attribute's field\n     *                       values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     *                  offset is equal to the index of the first byte after\n     *                  length)\n     * @param length the length of the attribute data.\n     *\n     * @throws StunException if attrubteValue contains invalid data.\n     */\n    void decodeAttributeBody(byte[] attributeValue, char offset, char length)\n            throws StunException\n    {\n        // array used to hold the intermediate long values reconstructed from\n        // the attributeValue array\n\n        // Reading in the network byte order (Big-Endian)\n        tieBreaker = ((attributeValue[offset++] & 0xffL) << 56)\n                  | ((attributeValue[offset++] & 0xffL) << 48)\n                  | ((attributeValue[offset++] & 0xffL) << 40)\n                  | ((attributeValue[offset++] & 0xffL) << 32)\n                  | ((attributeValue[offset++] & 0xffL) << 24)\n                  | ((attributeValue[offset++] & 0xffL) << 16)\n                  | ((attributeValue[offset++] & 0xffL) <<  8)\n                  | (attributeValue[offset]  & 0xffL);\n    }\n\n    /**\n     * Returns a binary representation of this attribute.\n     *\n     * @return a binary representation of this attribute.\n     */\n    public byte[] encode()\n    {\n        char type = getAttributeType();\n        byte[] binValue = new byte[HEADER_LENGTH + getDataLength()];\n\n        //Type\n        binValue[0] = (byte)(type >> 8);\n        binValue[1] = (byte)(type & 0x00FF);\n\n        //Length\n        binValue[2] = (byte)(getDataLength() >> 8);\n        binValue[3] = (byte)(getDataLength() & 0x00FF);\n\n        //Tie-Breaker\n        binValue[4]  = (byte)((tieBreaker & 0xFF00000000000000L) >> 56);\n        binValue[5]  = (byte)((tieBreaker & 0x00FF000000000000L) >> 48);\n        binValue[6]  = (byte)((tieBreaker & 0x0000FF0000000000L) >> 40);\n        binValue[7]  = (byte)((tieBreaker & 0x000000FF00000000L) >> 32);\n        binValue[8]  = (byte)((tieBreaker & 0x00000000FF000000L) >> 24);\n        binValue[9]  = (byte)((tieBreaker & 0x0000000000FF0000L) >> 16);\n        binValue[10] = (byte)((tieBreaker & 0x000000000000FF00L) >> 8);\n        binValue[11] = (byte)( tieBreaker & 0x00000000000000FFL);\n\n        return binValue;\n    }\n\n    /**\n     * Compares two STUN Attributes. Attributes are considered equal when their\n     * type, length, and all data are the same.\n     *\n     * @param obj the object to compare this attribute with.\n     *\n     * @return true if the attributes are equal and false otherwise.\n     */\n    public boolean equals(Object obj)\n    {\n        if (!(obj instanceof IceControlAttribute))\n            return false;\n\n        if (obj == this)\n            return true;\n\n        IceControlAttribute iceControlAtt = (IceControlAttribute)obj;\n        if (iceControlAtt.getAttributeType() != getAttributeType()\n            || iceControlAtt.isControlling != isControlling\n            || iceControlAtt.getDataLength() != DATA_LENGTH_ICE_CONTROL\n            || getTieBreaker() != iceControlAtt.getTieBreaker())\n        {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the data length of this attribute\n     *\n     * @return    the data length of this attribute\n     */\n    public char getDataLength()\n    {\n        return DATA_LENGTH_ICE_CONTROL;\n    }\n\n    /**\n     * Returns the human readable name of this attribute.\n     *\n     * @return this attribute's name.\n     */\n    public String getName()\n    {\n        return isControlling ? \"ICE-CONTROLLING\" : \"ICE-CONTROLLED\";\n    }\n\n    /**\n     * Sets the tie-breaker value.\n     *\n     * @param tieBreaker the the tie-breaker value\n     */\n    public void setTieBreaker(long tieBreaker)\n    {\n        this.tieBreaker = tieBreaker;\n    }\n\n    /**\n     * Returns the value of the tie-breaker.\n     *\n     * @return the value of the tie-breaker.\n     */\n    public long getTieBreaker()\n    {\n        return tieBreaker;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final char DATA_LENGTH_ICE_CONTROL = 8;", "docstring": "\nThe length of the data contained in this attribute\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "char", "name": "DATA_LENGTH_ICE_CONTROL = 8", "syntax_pass": true}, {"attribute_expression": "long tieBreaker;", "docstring": "\nThe tie-breaker value stored in this attribute\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "long", "name": "tieBreaker", "syntax_pass": true}, {"attribute_expression": "boolean isControlling;", "docstring": "\nIndicates whether this is an <tt>ICE-CONTROLLING</tt> or an\n<tt>ICE-CONTROLLED</tt> attribute.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "isControlling", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/attribute/Attribute.java.Attribute", "name": "Attribute", "file_path": "src/main/java/org/ice4j/attribute/Attribute.java", "superclasses": "", "methods": ["[]Attribute(char)", "[char]getDataLength()", "[String]getName()", "[char]getAttributeType()", "[void]setAttributeType(char)", "[boolean]equals(Object)", "[byte[]]encode()", "[void]setLocationInMessage(int)", "[int]getLocationInMessage()", "[void]decodeAttributeBody(byte[],char,char)"], "method_uris": ["src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[]Attribute(char)", "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[char]getDataLength()", "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[String]getName()", "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[char]getAttributeType()", "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[void]setAttributeType(char)", "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[boolean]equals(Object)", "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[byte[]]encode()", "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[void]setLocationInMessage(int)", "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[int]getLocationInMessage()", "src/main/java/org/ice4j/attribute/Attribute.java.Attribute.[void]decodeAttributeBody(byte[],char,char)"], "overrides": null, "attributes": [], "class_docstring": "\nAfter the header are 0 or more attributes.  Each attribute is TLV\nencoded, with a 16 bit type, 16 bit length, and variable value:\n<pre>\n    0                   1                   2                   3   \n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |         Type                  |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                             Value                             ....\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n   The following types are defined:\n\nSTUN attributes:\n   0x0001: MAPPED-ADDRESS\n   0x0002: RESPONSE-ADDRESS\n   0x0003: CHANGE-REQUEST\n   0x0004: SOURCE-ADDRESS\n   0x0005: CHANGED-ADDRESS\n   0x0006: USERNAME\n   0x0007: PASSWORD\n   0x0008: MESSAGE-INTEGRITY\n   0x0009: ERROR-CODE\n   0x000a: UNKNOWN-ATTRIBUTES\n   0x000b: REFLECTED-FROM\n   0x0014: REALM\n   0x0015: NONCE\n   0x0020: XOR-MAPPED-ADDRESS\n   0x8022: SOFTWARE\n   0x8023: ALTERNATE-SERVER\n   0x8028: FINGERPRINT\n\nTURN attributes:\n   0x000C: CHANNEL-NUMBER\n   0x000D: LIFETIME\n   0x0012: XOR-PEER-ADDRESS\n   0x0013: DATA\n   0x0016: XOR-RELAYED-ADDRESS\n   0x0018: EVEN-PORT\n   0x0019: REQUESTED-TRANSPORT\n   0x001A: DONT-FRAGMENT\n   0x0022: RESERVATION-TOKEN\n\nICE attributes:\n   0x0024: PRIORITY\n   0x0025: USE-CANDIDATE\n   0x8029: ICE-CONTROLLED\n   0x802A: ICE-CONTROLLING\n</pre>\n\n@author Emil Ivov\n@author Sebastien Vincent\n@author Namal Senarathne\n@author Aakash Garg\n", "original_string": "public abstract class Attribute\n{\n    /* STUN attributes */\n    /**\n     * Mapped address attribute.\n     */\n    public static final char MAPPED_ADDRESS = 0x0001;\n\n    /**\n     * Response address attribute.\n     */\n    public static final char RESPONSE_ADDRESS = 0x0002;\n\n    /**\n     * Change request attribute.\n     */\n    public static final char CHANGE_REQUEST = 0x0003;\n\n    /**\n     * Source address attribute.\n     */\n    public static final char SOURCE_ADDRESS = 0x0004;\n\n    /**\n     * Changed address attribute.\n     */\n    public static final char CHANGED_ADDRESS = 0x0005;\n\n    /**\n     * Username attribute.\n     */\n    public static final char USERNAME = 0x0006;\n\n    /**\n     * Password attribute.\n     */\n    public static final char PASSWORD = 0x0007;\n\n    /**\n     * Message integrity attribute.\n     */\n    public static final char MESSAGE_INTEGRITY = 0x0008;\n\n    /**\n     * Error code attribute.\n     */\n    public static final char ERROR_CODE = 0x0009;\n\n    /**\n     * Unknown attributes attribute.\n     */\n    public static final char UNKNOWN_ATTRIBUTES = 0x000a;\n\n    /**\n     * Reflected from attribute.\n     */\n    public static final char REFLECTED_FROM = 0x000b;\n\n    /**\n     * Realm attribute.\n     */\n    public static final char REALM = 0x0014;\n\n    /**\n     * Nonce attribute.\n     */\n    public static final char NONCE = 0x0015;\n\n    /**\n     * XOR Mapped address attribute.\n     */\n    public static final char XOR_MAPPED_ADDRESS = 0x0020;\n\n    /**\n     * XOR only attribute.\n     */\n    public static final char XOR_ONLY = 0x0021;\n\n    /**\n     * Software attribute.\n     */\n    public static final char SOFTWARE = 0x8022;\n\n    /**\n     * Alternate server attribute.\n     */\n    public static final char ALTERNATE_SERVER = 0x8023;\n    \n    /**\n     * Fingerprint attribute.\n     */\n    public static final char FINGERPRINT = 0x8028;\n\n    /**\n     * Unknown optional attribute.\n     */\n    public static final char UNKNOWN_OPTIONAL_ATTRIBUTE = 0x8000;\n\n    /* TURN attributes */\n    /**\n     * Channel number attribute.\n     */\n    public static final char CHANNEL_NUMBER = 0x000c;\n\n    /**\n     * Lifetime attribute.\n     */\n    public static final char LIFETIME = 0x000d;\n\n    /**\n     * XOR peer address attribute.\n     */\n    public static final char XOR_PEER_ADDRESS = 0x0012;\n\n    /**\n     * Data attribute.\n     */\n    public static final char DATA = 0x0013;\n\n    /**\n     * XOR relayed address attribute.\n     */\n    public static final char XOR_RELAYED_ADDRESS = 0x0016;\n    \n    /**\n     * Requested Address Family attribute.\n     */\n    public static final char REQUESTED_ADDRESS_FAMILY = 0X0017;\n\n    /**\n     * Even port attribute.\n     */\n    public static final char EVEN_PORT = 0x0018;\n\n    /**\n     * Requested transport attribute.\n     */\n    public static final char REQUESTED_TRANSPORT = 0x0019;\n\n    /**\n     * Don't fragment attribute.\n     */\n    public static final char DONT_FRAGMENT = 0x001a;\n\n    /**\n     * Reservation token attribute.\n     */\n    public static final char RESERVATION_TOKEN = 0x0022;\n   \n    /**\n     * Connection Id attribute.\n     * TURN TCP support attribute\n     */\n    public static final char CONNECTION_ID = 0x002a;\n\n    /* Old TURN attributes */\n    /**\n     * Magic cookie attribute.\n     */\n    public static final char MAGIC_COOKIE = 0x000f;\n\n    /**\n     * Destination address attribute.\n     */\n    public static final char DESTINATION_ADDRESS = 0x0011;\n\n    /**\n     * Destination address attribute.\n     */\n    public static final char REMOTE_ADDRESS = 0x0012;\n\n    /* ICE attributes */\n    /**\n     * Priority attribute.\n     */\n    public static final char PRIORITY = 0x0024;\n\n    /**\n     * Use candidate attribute.\n     */\n    public static final char USE_CANDIDATE = 0x0025;\n\n    /**\n     * ICE controlled attribute.\n     */\n    public static final char ICE_CONTROLLED = 0x8029;\n\n    /**\n     * ICE controlling attribute.\n     */\n    public static final char ICE_CONTROLLING = 0x802a;\n\n    /**\n     * The type of the attribute.\n     */\n    protected char attributeType = 0;\n\n    /**\n     * The size of an attribute header in bytes = len(TYPE) + len(LENGTH) = 4\n     */\n    public static final char HEADER_LENGTH = 4;\n\n    /**\n     * For attributes that have arriving in incoming messages, this fiels\n     * contains their original location in the binary array so that we could\n     * later more easily verify attributes like MESSAGE-INTEGRITY.\n     */\n    private int locationInMessage = -1;\n\n    /**\n     * Creates an empty STUN message attribute.\n     *\n     * @param attributeType the type of the attribute.\n     */\n    protected Attribute(char attributeType)\n    {\n        setAttributeType(attributeType);\n    }\n\n    /**\n     * Returns the length of this attribute's body.\n     *\n     * @return the length of this attribute's value.\n     */\n    public abstract char getDataLength();\n\n    /**\n     * Returns the human readable name of this attribute. Attribute names do\n     * not really matter from the protocol point of view. They are only used\n     * for debugging and readability.\n     *\n     * @return this attribute's name.\n     */\n    public abstract String getName();\n\n    /**\n     * Returns the attribute's type.\n     *\n     * @return the type of this attribute.\n     */\n    public char getAttributeType()\n    {\n        return attributeType;\n    }\n\n    /**\n     * Sets the attribute's type.\n     *\n     * @param type the new type of this attribute\n     */\n    protected void setAttributeType(char type)\n    {\n        this.attributeType = type;\n    }\n\n   /**\n    * Compares two STUN Attributes. Two attributes are considered equal when\n    * they have the same type length and value.\n    *\n    * @param obj the object to compare this attribute with.\n    *\n    * @return true if the attributes are equal and false otherwise.\n    */\n\n    @Override\n    public abstract boolean equals(Object obj);\n\n    /**\n     * Returns a binary representation of this attribute.\n     *\n     * @return a binary representation of this attribute.\n     */\n    public abstract byte[] encode();\n\n    /**\n     * For attributes that have arriving in incoming messages, this method\n     * stores their original location in the binary array so that we could\n     * later more easily verify attributes like MESSAGE-INTEGRITY.\n     *\n     * @param index the original location of this attribute in the datagram\n     * we got off the wire\n     */\n    public void setLocationInMessage(int index)\n    {\n        this.locationInMessage = index;\n    }\n\n    /**\n     * For attributes that have arriving in incoming messages, this method\n     * returns their original location in the binary array so that we could\n     * later more easily verify attributes like MESSAGE-INTEGRITY.\n     *\n     * @return the original location of this attribute in the datagram\n     * we got off the wire or -1 if this is not an incoming {@link Attribute}\n     */\n    public int getLocationInMessage()\n    {\n        return this.locationInMessage;\n    }\n\n    /**\n     * Sets this attribute's fields according to attributeValue array.\n     *\n     * @param attributeValue a binary array containing this attribute's field\n     * values and NOT containing the attribute header.\n     * @param offset the position where attribute values begin (most often\n     * offset is equal to the index of the first byte after length)\n     * @param length the length of the binary array.\n     *\n     * @throws StunException if attrubteValue contains invalid data.\n     */\n    abstract void decodeAttributeBody( byte[] attributeValue,\n                                       char   offset,\n                                       char   length)\n        throws StunException;\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final char MAPPED_ADDRESS = 0x0001;", "docstring": "\nMapped address attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "MAPPED_ADDRESS = 0x0001", "syntax_pass": true}, {"attribute_expression": "public static final char RESPONSE_ADDRESS = 0x0002;", "docstring": "\nResponse address attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "RESPONSE_ADDRESS = 0x0002", "syntax_pass": true}, {"attribute_expression": "public static final char CHANGE_REQUEST = 0x0003;", "docstring": "\nChange request attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CHANGE_REQUEST = 0x0003", "syntax_pass": true}, {"attribute_expression": "public static final char SOURCE_ADDRESS = 0x0004;", "docstring": "\nSource address attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "SOURCE_ADDRESS = 0x0004", "syntax_pass": true}, {"attribute_expression": "public static final char CHANGED_ADDRESS = 0x0005;", "docstring": "\nChanged address attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CHANGED_ADDRESS = 0x0005", "syntax_pass": true}, {"attribute_expression": "public static final char USERNAME = 0x0006;", "docstring": "\nUsername attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "USERNAME = 0x0006", "syntax_pass": true}, {"attribute_expression": "public static final char PASSWORD = 0x0007;", "docstring": "\nPassword attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "PASSWORD = 0x0007", "syntax_pass": true}, {"attribute_expression": "public static final char MESSAGE_INTEGRITY = 0x0008;", "docstring": "\nMessage integrity attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "MESSAGE_INTEGRITY = 0x0008", "syntax_pass": true}, {"attribute_expression": "public static final char ERROR_CODE = 0x0009;", "docstring": "\nError code attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ERROR_CODE = 0x0009", "syntax_pass": true}, {"attribute_expression": "public static final char UNKNOWN_ATTRIBUTES = 0x000a;", "docstring": "\nUnknown attributes attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "UNKNOWN_ATTRIBUTES = 0x000a", "syntax_pass": true}, {"attribute_expression": "public static final char REFLECTED_FROM = 0x000b;", "docstring": "\nReflected from attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "REFLECTED_FROM = 0x000b", "syntax_pass": true}, {"attribute_expression": "public static final char REALM = 0x0014;", "docstring": "\nRealm attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "REALM = 0x0014", "syntax_pass": true}, {"attribute_expression": "public static final char NONCE = 0x0015;", "docstring": "\nNonce attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "NONCE = 0x0015", "syntax_pass": true}, {"attribute_expression": "public static final char XOR_MAPPED_ADDRESS = 0x0020;", "docstring": "\nXOR Mapped address attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "XOR_MAPPED_ADDRESS = 0x0020", "syntax_pass": true}, {"attribute_expression": "public static final char XOR_ONLY = 0x0021;", "docstring": "\nXOR only attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "XOR_ONLY = 0x0021", "syntax_pass": true}, {"attribute_expression": "public static final char SOFTWARE = 0x8022;", "docstring": "\nSoftware attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "SOFTWARE = 0x8022", "syntax_pass": true}, {"attribute_expression": "public static final char ALTERNATE_SERVER = 0x8023;", "docstring": "\nAlternate server attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ALTERNATE_SERVER = 0x8023", "syntax_pass": true}, {"attribute_expression": "public static final char FINGERPRINT = 0x8028;", "docstring": "\nFingerprint attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "FINGERPRINT = 0x8028", "syntax_pass": true}, {"attribute_expression": "public static final char UNKNOWN_OPTIONAL_ATTRIBUTE = 0x8000;", "docstring": "\nUnknown optional attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "UNKNOWN_OPTIONAL_ATTRIBUTE = 0x8000", "syntax_pass": true}, {"attribute_expression": "public static final char CHANNEL_NUMBER = 0x000c;", "docstring": "\nChannel number attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CHANNEL_NUMBER = 0x000c", "syntax_pass": true}, {"attribute_expression": "public static final char LIFETIME = 0x000d;", "docstring": "\nLifetime attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "LIFETIME = 0x000d", "syntax_pass": true}, {"attribute_expression": "public static final char XOR_PEER_ADDRESS = 0x0012;", "docstring": "\nXOR peer address attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "XOR_PEER_ADDRESS = 0x0012", "syntax_pass": true}, {"attribute_expression": "public static final char DATA = 0x0013;", "docstring": "\nData attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "DATA = 0x0013", "syntax_pass": true}, {"attribute_expression": "public static final char XOR_RELAYED_ADDRESS = 0x0016;", "docstring": "\nXOR relayed address attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "XOR_RELAYED_ADDRESS = 0x0016", "syntax_pass": true}, {"attribute_expression": "public static final char REQUESTED_ADDRESS_FAMILY = 0X0017;", "docstring": "\nRequested Address Family attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "REQUESTED_ADDRESS_FAMILY = 0X0017", "syntax_pass": true}, {"attribute_expression": "public static final char EVEN_PORT = 0x0018;", "docstring": "\nEven port attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "EVEN_PORT = 0x0018", "syntax_pass": true}, {"attribute_expression": "public static final char REQUESTED_TRANSPORT = 0x0019;", "docstring": "\nRequested transport attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "REQUESTED_TRANSPORT = 0x0019", "syntax_pass": true}, {"attribute_expression": "public static final char DONT_FRAGMENT = 0x001a;", "docstring": "\nDon't fragment attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "DONT_FRAGMENT = 0x001a", "syntax_pass": true}, {"attribute_expression": "public static final char RESERVATION_TOKEN = 0x0022;", "docstring": "\nReservation token attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "RESERVATION_TOKEN = 0x0022", "syntax_pass": true}, {"attribute_expression": "public static final char CONNECTION_ID = 0x002a;", "docstring": "\nConnection Id attribute.\nTURN TCP support attribute\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "CONNECTION_ID = 0x002a", "syntax_pass": true}, {"attribute_expression": "public static final char MAGIC_COOKIE = 0x000f;", "docstring": "\nMagic cookie attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "MAGIC_COOKIE = 0x000f", "syntax_pass": true}, {"attribute_expression": "public static final char DESTINATION_ADDRESS = 0x0011;", "docstring": "\nDestination address attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "DESTINATION_ADDRESS = 0x0011", "syntax_pass": true}, {"attribute_expression": "public static final char REMOTE_ADDRESS = 0x0012;", "docstring": "\nDestination address attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "REMOTE_ADDRESS = 0x0012", "syntax_pass": true}, {"attribute_expression": "public static final char PRIORITY = 0x0024;", "docstring": "\nPriority attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "PRIORITY = 0x0024", "syntax_pass": true}, {"attribute_expression": "public static final char USE_CANDIDATE = 0x0025;", "docstring": "\nUse candidate attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "USE_CANDIDATE = 0x0025", "syntax_pass": true}, {"attribute_expression": "public static final char ICE_CONTROLLED = 0x8029;", "docstring": "\nICE controlled attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ICE_CONTROLLED = 0x8029", "syntax_pass": true}, {"attribute_expression": "public static final char ICE_CONTROLLING = 0x802a;", "docstring": "\nICE controlling attribute.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "ICE_CONTROLLING = 0x802a", "syntax_pass": true}, {"attribute_expression": "protected char attributeType = 0;", "docstring": "\nThe type of the attribute.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "char", "name": "attributeType = 0", "syntax_pass": true}, {"attribute_expression": "public static final char HEADER_LENGTH = 4;", "docstring": "\nThe size of an attribute header in bytes = len(TYPE) + len(LENGTH) = 4\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "char", "name": "HEADER_LENGTH = 4", "syntax_pass": true}, {"attribute_expression": "private int locationInMessage = -1;", "docstring": "\nFor attributes that have arriving in incoming messages, this fiels\ncontains their original location in the binary array so that we could\nlater more easily verify attributes like MESSAGE-INTEGRITY.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "locationInMessage = -1", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable", "name": "PeriodicRunnable", "file_path": "src/main/java/org/ice4j/util/PeriodicRunnable.java", "superclasses": "", "methods": ["[]PeriodicRunnable(ScheduledExecutorService,ExecutorService)", "[Duration]getDelayUntilNextRun()", "[void]run()", "[void]schedule()", "[void]cancel()", "[void]scheduleNextRun(Duration)", "[void]submitExecuteRun()", "[void]executeRun()", "[PeriodicRunnable]create(ScheduledExecutorService,ExecutorService,Duration,Runnable)"], "method_uris": ["src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[]PeriodicRunnable(ScheduledExecutorService,ExecutorService)", "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[Duration]getDelayUntilNextRun()", "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[void]run()", "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[void]schedule()", "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[void]cancel()", "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[void]scheduleNextRun(Duration)", "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[void]submitExecuteRun()", "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[void]executeRun()", "src/main/java/org/ice4j/util/PeriodicRunnable.java.PeriodicRunnable.[PeriodicRunnable]create(ScheduledExecutorService,ExecutorService,Duration,Runnable)"], "overrides": null, "attributes": [], "class_docstring": "\nA base class for runnables which should be periodically executed on\nspecified executor service.\n\n@author Yura Yaroshevich\n", "original_string": "public abstract class PeriodicRunnable\n{\n    /**\n     * The {@link Logger} used by the {@link PeriodicRunnable} class for logging output.\n     */\n    private final static Logger logger = new LoggerImpl(PeriodicRunnable.class.getName());\n\n    /**\n     * A timer to perform periodic scheduling of {@link #run()} execution\n     * on {@link #executor}'s thread.\n     */\n    private final ScheduledExecutorService timer;\n\n    /**\n     * An executor service to perform actual execution of {@link #run()}.\n     */\n    private final ExecutorService executor;\n\n    /**\n     * A synchronization object to synchronize scheduling, execution and\n     * cancellation of {@link #run()}.\n     */\n    private final Object syncRoot = new Object();\n\n    /**\n     * Indicates if execution of {@link #run()} scheduled and should\n     * be further continued.\n     */\n    private volatile boolean running = false;\n\n    /**\n     * Store a reference to last runnable submitted to {@link #timer}\n     */\n    private ScheduledFuture<?> scheduledSubmit;\n\n    /**\n     * Store a reference to last runnable submitted to {@link #executor}\n     */\n    private Future<?> submittedExecute;\n\n    /**\n     * Create instance of {@link PeriodicRunnable} with specified timer and\n     * executor.\n     * @param timer an {@link ScheduledExecutorService} which is used to\n     *              periodic triggering of {@link #run()} execution.\n     * @param executor an {@link ExecutorService} to perform actual execution\n     *                 of {@link #run()}.\n     */\n    protected PeriodicRunnable(\n        ScheduledExecutorService timer,\n        ExecutorService executor)\n    {\n        if (timer == null)\n        {\n            throw new IllegalArgumentException(\"timer is null\");\n        }\n        if (executor == null)\n        {\n            throw new IllegalArgumentException(\"executor is null\");\n        }\n        this.timer = timer;\n        this.executor = executor;\n    }\n\n    /**\n     * Get delay before next execution of {@link #run()}.\n     * @return non-negative value if execution of {@link #run()} should be\n     * performed with specified delay, negative value if execution should not\n     * be done.\n     */\n    protected abstract Duration getDelayUntilNextRun();\n\n    /**\n     * Periodically executed method on {@link #executor}'s thread.\n     */\n    protected abstract void run();\n\n    /**\n     * Schedules periodic execution of {@link #run()} on {@link #executor}'s\n     * thread.\n     */\n    public void schedule()\n    {\n        if (running)\n        {\n            return;\n        }\n\n        final Duration delay =\n            getDelayUntilNextRun();\n\n        scheduleNextRun(delay);\n    }\n\n    /**\n     * Cancels periodic execution of {@link #run()} on {@link #executor}'s\n     * thread.\n     */\n    public void cancel()\n    {\n        if (!running)\n        {\n            return;\n        }\n\n        synchronized (syncRoot)\n        {\n            if (running)\n            {\n                running = false;\n\n                if (scheduledSubmit != null)\n                {\n                    scheduledSubmit.cancel(true);\n                    scheduledSubmit = null;\n                }\n\n                if (submittedExecute != null)\n                {\n                    submittedExecute.cancel(true);\n                    submittedExecute = null;\n                }\n            }\n        }\n    }\n\n    /**\n     * Perform either cancellation or actual scheduling based on delay until\n     * next run.\n     * @param delay delay before next execution of {@link #run()}.\n     */\n    private void scheduleNextRun(Duration delay)\n    {\n        synchronized (syncRoot)\n        {\n            final boolean isRecurrentRun = submittedExecute != null;\n            if (isRecurrentRun && !running)\n            {\n                // was cancelled\n                return;\n            }\n\n            if (delay.isNegative())\n            {\n                running = false;\n                scheduledSubmit = null;\n                submittedExecute = null;\n                return;\n            }\n\n            running = true;\n\n            if (delay.isZero())\n            {\n                submitExecuteRun();\n            }\n            else\n            {\n                scheduledSubmit = timer.schedule(\n                    this::submitExecuteRun,\n                    delay.toNanos(),\n                    TimeUnit.NANOSECONDS);\n            }\n        }\n    }\n\n    /**\n     * Submit execution of {@link #run()} into {@link #executor}'s thread\n     * if not cancelled.\n     */\n    private void submitExecuteRun()\n    {\n        if (!running)\n        {\n            return;\n        }\n        synchronized (syncRoot)\n        {\n            if (!running)\n            {\n                return;\n            }\n            submittedExecute = this.executor.submit(this::executeRun);\n        }\n    }\n\n    /**\n     * Perform execution of {@link #run()} with further re-schedule of\n     * execution if not cancelled\n     */\n    private void executeRun()\n    {\n        if (!running)\n        {\n            return;\n        }\n\n        try\n        {\n            this.run();\n        }\n        catch (Exception e)\n        {\n            logger.warn(\"Exception in run(), will retry.\", e);\n        }\n        finally\n        {\n            if (running)\n            {\n                final Duration delayMillis =\n                    getDelayUntilNextRun();\n\n                scheduleNextRun(delayMillis);\n            }\n        }\n    }\n\n    /**\n     * Constructs {@link PeriodicRunnable} for {@link Runnable} with provided\n     * timer, executor and fixed delay.\n     * fixed delay.\n     * @param timer {@link ScheduledExecutorService} to be used as timer\n     * @param executor {@link ExecutorService} to execute provided runnable\n     * @param period delay between subsequent execution of runnable\n     * @param r {@link Runnable} to for periodic execution.\n     * @return {@link PeriodicRunnable} instance constructed with provided\n     * arguments\n     */\n    static PeriodicRunnable create(\n        ScheduledExecutorService timer,\n        ExecutorService executor,\n        Duration period,\n        Runnable r)\n    {\n        return new PeriodicRunnable(timer, executor)\n        {\n            @Override\n            protected Duration getDelayUntilNextRun()\n            {\n                return period;\n            }\n\n            @Override\n            protected void run()\n            {\n                r.run();\n            }\n        };\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final static Logger logger = new LoggerImpl(PeriodicRunnable.class.getName());", "docstring": "\nThe {@link Logger} used by the {@link PeriodicRunnable} class for logging output.\n", "modifiers": "private final static", "marker_annotations": [], "non_marker_annotations": ["private", "final", "static"], "comments": [], "type": "Logger", "name": "logger = new LoggerImpl(PeriodicRunnable.class.getName())", "syntax_pass": true}, {"attribute_expression": "private final ScheduledExecutorService timer;", "docstring": "\nA timer to perform periodic scheduling of {@link #run()} execution\non {@link #executor}'s thread.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ScheduledExecutorService", "name": "timer", "syntax_pass": true}, {"attribute_expression": "private final ExecutorService executor;", "docstring": "\nAn executor service to perform actual execution of {@link #run()}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ExecutorService", "name": "executor", "syntax_pass": true}, {"attribute_expression": "private final Object syncRoot = new Object();", "docstring": "\nA synchronization object to synchronize scheduling, execution and\ncancellation of {@link #run()}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "syncRoot = new Object()", "syntax_pass": true}, {"attribute_expression": "private volatile boolean running = false;", "docstring": "\nIndicates if execution of {@link #run()} scheduled and should\nbe further continued.\n", "modifiers": "private volatile", "marker_annotations": [], "non_marker_annotations": ["private", "volatile"], "comments": [], "type": "boolean", "name": "running = false", "syntax_pass": true}, {"attribute_expression": "private ScheduledFuture<?> scheduledSubmit;", "docstring": "\nStore a reference to last runnable submitted to {@link #timer}\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ScheduledFuture<?>", "name": "scheduledSubmit", "syntax_pass": true}, {"attribute_expression": "private Future<?> submittedExecute;", "docstring": "\nStore a reference to last runnable submitted to {@link #executor}\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Future<?>", "name": "submittedExecute", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate", "name": "LocalCandidate", "file_path": "src/main/java/org/ice4j/ice/LocalCandidate.java", "superclasses": "", "methods": ["[]LocalCandidate(TransportAddress,Component,CandidateType,CandidateExtendedType,LocalCandidate)", "[DatagramSocket]getDatagramSocket()", "[Socket]getSocket()", "[IceSocketWrapper]getIceSocketWrapper()", "[IceSocketWrapper]getCandidateIceSocketWrapper()", "[IceSocketWrapper]getCandidateIceSocketWrapper(SocketAddress)", "[IceSocketWrapper]getStunSocket(TransportAddress)", "[StunStack]getStunStack()", "[StunDatagramPacketFilter]createStunDatagramPacketFilter(TransportAddress)", "[void]free()", "[boolean]isDefault()", "[void]setUfrag(String)", "[String]getUfrag()", "[CandidateExtendedType]getExtendedType()", "[void]setExtendedType(CandidateExtendedType)", "[LocalCandidate]findRelatedCandidate(TransportAddress)", "[boolean]isSSL()", "[void]setSSL(boolean)"], "method_uris": ["src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[]LocalCandidate(TransportAddress,Component,CandidateType,CandidateExtendedType,LocalCandidate)", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[DatagramSocket]getDatagramSocket()", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[Socket]getSocket()", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[IceSocketWrapper]getIceSocketWrapper()", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper()", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[IceSocketWrapper]getCandidateIceSocketWrapper(SocketAddress)", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[IceSocketWrapper]getStunSocket(TransportAddress)", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[StunStack]getStunStack()", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[StunDatagramPacketFilter]createStunDatagramPacketFilter(TransportAddress)", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[void]free()", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[boolean]isDefault()", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[void]setUfrag(String)", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[String]getUfrag()", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[CandidateExtendedType]getExtendedType()", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[void]setExtendedType(CandidateExtendedType)", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[LocalCandidate]findRelatedCandidate(TransportAddress)", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[boolean]isSSL()", "src/main/java/org/ice4j/ice/LocalCandidate.java.LocalCandidate.[void]setSSL(boolean)"], "overrides": null, "attributes": [], "class_docstring": "\n<tt>LocalCandidate</tt>s are obtained by an agent for every stream component\nand are then included in outgoing offers or answers.\n\n@author Emil Ivov\n@author Lyubomir Marinov\n", "original_string": "public abstract class LocalCandidate\n    extends Candidate<LocalCandidate>\n{\n    /**\n     * The <tt>Logger</tt> used by the <tt>LocalCandidate</tt> class for logging\n     * output.\n     * Note that this shouldn't be used directly by instances of\n     * {@link DefaultNominator}, because it doesn't take into account the\n     * per-instance log level. Instances should use {@link #logger} instead.\n     */\n    private static final java.util.logging.Logger classLogger\n        = java.util.logging.Logger.getLogger(HostCandidate.class.getName());\n\n    /**\n     * The type of method used to discover this candidate (\"host\", \"upnp\", \"stun\n     * peer reflexive\", \"stun server reflexive\", \"turn relayed\", \"google turn\n     * relayed\", \"google tcp turn relayed\" or \"jingle node\").\n     */\n    private CandidateExtendedType extendedType = null;\n\n    /**\n     * Ufrag for the local candidate.\n     */\n    private String ufrag = null;\n\n    /**\n     * Whether this <tt>LocalCandidate</tt> uses SSL.\n     */\n    private boolean isSSL = false;\n\n    /**\n     * The {@link Logger} used by {@link LocalCandidate} instances.\n     */\n    private final Logger logger;\n\n    /**\n     * Creates a <tt>LocalCandidate</tt> instance for the specified transport\n     * address and properties.\n     *\n     * @param transportAddress  the transport address that this candidate is\n     * encapsulating.\n     * @param parentComponent the <tt>Component</tt> that this candidate\n     * belongs to.\n     * @param type the <tt>CandidateType</tt> for this <tt>Candidate</tt>.\n     * @param extendedType The type of method used to discover this candidate\n     * (\"host\", \"upnp\", \"stun peer reflexive\", \"stun server reflexive\", \"turn\n     * relayed\", \"google turn relayed\", \"google tcp turn relayed\" or \"jingle\n     * node\").\n     * @param relatedCandidate the relatedCandidate: null for a host candidate,\n     * the base address (host candidate) for a reflexive candidate, the mapped\n     * address (the mapped address of the TURN allocate response) for a relayed\n     * candidate.\n     */\n    public LocalCandidate(TransportAddress transportAddress,\n                          Component        parentComponent,\n                          CandidateType    type,\n                          CandidateExtendedType extendedType,\n                          LocalCandidate  relatedCandidate)\n\n    {\n        super(transportAddress, parentComponent, type, relatedCandidate);\n        logger = parentComponent.getLogger().createChildLogger(this.getClass().getName());\n        this.extendedType = extendedType;\n    }\n\n    /**\n     * Gets the <tt>DatagramSocket</tt> associated with this\n     * <tt>Candidate</tt>.\n     *\n     * @return the <tt>DatagramSocket</tt> associated with this\n     * <tt>Candidate</tt>\n     *\n     * @deprecated This should be used by the library only. Users of ice4j\n     * should use {@link org.ice4j.ice.Component#getSocket()} instead.\n     */\n    @Deprecated\n    public DatagramSocket getDatagramSocket()\n    {\n        IceSocketWrapper wrapper = getIceSocketWrapper();\n        return wrapper == null ? null : wrapper.getUDPSocket();\n    }\n\n    /**\n     * Gets the <tt>Socket</tt> associated with this\n     * <tt>Candidate</tt>.\n     *\n     * @return the <tt>Socket</tt> associated with this\n     * <tt>Candidate</tt>\n     *\n     * @deprecated This should be used by the library only. Users of ice4j\n     * should use {@link org.ice4j.ice.Component#getSocket()} instead.\n     */\n    @Deprecated\n    public Socket getSocket()\n    {\n        return null;\n    }\n\n    /**\n     * @return the {@link IceSocketWrapper} instance of the {@link Component}\n     * which owns this {@link LocalCandidate}. Note that this IS NOT an\n     * instance specific to this {@link LocalCandidate}. See\n     * {@link #getCandidateIceSocketWrapper()}.\n     */\n    protected IceSocketWrapper getIceSocketWrapper()\n    {\n        return getParentComponent().getSocketWrapper();\n    }\n\n    /**\n     * @return the {@link IceSocketWrapper} instance, if any, associated with\n     * this candidate. Note that this IS NOT the instance which should be used\n     * for reading and writing by the application, and SHOULD NOT be used from\n     * outside ice4j (even if a subclass exposes it as public). Also see\n     * {@link #getIceSocketWrapper()}.\n     */\n    protected abstract IceSocketWrapper getCandidateIceSocketWrapper();\n\n    /**\n     * @return the {@link IceSocketWrapper} instance for this candidate,\n     * associated with a particular remote address.\n     * @param remoteAddress the remote address for which to return an\n     * associated socket.\n     */\n    protected IceSocketWrapper getCandidateIceSocketWrapper(\n        SocketAddress remoteAddress)\n    {\n        // The default implementation just refers to the method which doesn't\n        // involve a remove address. Extenders which support multiple instances\n        // mapped by remote address should override.\n        return getCandidateIceSocketWrapper();\n    }\n\n    /**\n     * Creates if necessary and returns a <tt>DatagramSocket</tt> that would\n     * capture all STUN packets arriving on this candidate's socket. If the\n     * <tt>serverAddress</tt> parameter is not <tt>null</tt> this socket would\n     * only intercept packets originating at this address.\n     *\n     * @param serverAddress the address of the source we'd like to receive\n     * packets from or <tt>null</tt> if we'd like to intercept all STUN packets.\n     *\n     * @return the <tt>DatagramSocket</tt> that this candidate uses when sending\n     * and receiving STUN packets, while harvesting STUN candidates or\n     * performing connectivity checks.\n     */\n    public IceSocketWrapper getStunSocket(TransportAddress serverAddress)\n    {\n        IceSocketWrapper hostSocket = getCandidateIceSocketWrapper();\n\n        if (hostSocket != null\n              && hostSocket.getTCPSocket() != null)\n        {\n            Socket tcpSocket = hostSocket.getTCPSocket();\n            Socket tcpStunSocket = null;\n\n            if (tcpSocket instanceof MultiplexingSocket)\n            {\n                DatagramPacketFilter stunDatagramPacketFilter\n                    = createStunDatagramPacketFilter(serverAddress);\n                Throwable exception = null;\n\n                try\n                {\n                    tcpStunSocket\n                        = ((MultiplexingSocket) tcpSocket)\n                            .getSocket(stunDatagramPacketFilter);\n                }\n                catch (SocketException sex) //don't u just luv da name? ;)\n                {\n                    logger.error(\"Failed to acquire Socket\"\n                                   + \" specific to STUN communication.\",\n                               sex);\n                    exception = sex;\n                }\n                if (tcpStunSocket == null)\n                {\n                    throw\n                        new IllegalStateException(\n                                \"Failed to acquire Socket\"\n                                    + \" specific to STUN communication\",\n                                exception);\n                }\n            }\n            else\n            {\n                throw\n                    new IllegalStateException(\n                            \"The socket of \"\n                                + getClass().getSimpleName()\n                                + \" must be a MultiplexingSocket \" +\n                                        \"instance\");\n            }\n\n            IceTcpSocketWrapper stunSocket = null;\n            try\n            {\n                stunSocket = new IceTcpSocketWrapper(tcpStunSocket);\n            }\n            catch(IOException e)\n            {\n                logger.info(\"Failed to create IceTcpSocketWrapper \" + e);\n            }\n\n            return stunSocket;\n        }\n        else if (hostSocket != null\n                   && hostSocket.getUDPSocket() != null)\n        {\n            DatagramSocket udpSocket = hostSocket.getUDPSocket();\n            DatagramSocket udpStunSocket = null;\n\n            if (udpSocket instanceof MultiplexingDatagramSocket)\n            {\n                DatagramPacketFilter stunDatagramPacketFilter\n                    = createStunDatagramPacketFilter(serverAddress);\n                Throwable exception = null;\n\n                try\n                {\n                    udpStunSocket\n                        = ((MultiplexingDatagramSocket) udpSocket)\n                            .getSocket(stunDatagramPacketFilter);\n                }\n                catch (SocketException sex) //don't u just luv da name? ;)\n                {\n                    logger.error(\"Failed to acquire DatagramSocket\"\n                                   + \" specific to STUN communication.\",\n                               sex);\n                    exception = sex;\n                }\n                if (udpStunSocket == null)\n                {\n                    throw\n                        new IllegalStateException(\n                                \"Failed to acquire DatagramSocket\"\n                                    + \" specific to STUN communication\",\n                                exception);\n                }\n            }\n            else\n            {\n                throw\n                    new IllegalStateException(\n                            \"The socket of \"\n                                + getClass().getSimpleName()\n                                + \" must be a MultiplexingDatagramSocket \" +\n                                        \"instance\");\n            }\n            return new IceUdpSocketWrapper(udpStunSocket);\n        }\n\n        return null;\n    }\n\n    /**\n     * Gets the <tt>StunStack</tt> associated with this <tt>Candidate</tt>.\n     *\n     * @return the <tt>StunStack</tt> associated with this <tt>Candidate</tt>\n     */\n    public StunStack getStunStack()\n    {\n        return\n            getParentComponent()\n                .getParentStream()\n                    .getParentAgent()\n                        .getStunStack();\n    }\n\n    /**\n     * Creates a new <tt>StunDatagramPacketFilter</tt> which is to capture STUN\n     * messages and make them available to the <tt>DatagramSocket</tt> returned\n     * by {@link #getStunSocket(TransportAddress)}.\n     *\n     * @param serverAddress the address of the source we'd like to receive\n     * packets from or <tt>null</tt> if we'd like to intercept all STUN packets\n     * @return the <tt>StunDatagramPacketFilter</tt> which is to capture STUN\n     * messages and make them available to the <tt>DatagramSocket</tt> returned\n     * by {@link #getStunSocket(TransportAddress)}\n     */\n    protected StunDatagramPacketFilter createStunDatagramPacketFilter(\n            TransportAddress serverAddress)\n    {\n        return new StunDatagramPacketFilter(serverAddress);\n    }\n\n    /**\n     * Frees resources allocated by this candidate such as its\n     * <tt>DatagramSocket</tt>, for example. The <tt>socket</tt> of this\n     * <tt>LocalCandidate</tt> is closed only if it is not the <tt>socket</tt>\n     * of the <tt>base</tt> of this <tt>LocalCandidate</tt>.\n     */\n    protected void free()\n    {\n        // Close the socket associated with this LocalCandidate.\n        IceSocketWrapper socket = getCandidateIceSocketWrapper();\n\n        if (socket != null)\n        {\n            LocalCandidate base = getBase();\n\n            if ((base == null)\n                    || (base == this)\n                    || (base.getCandidateIceSocketWrapper() != socket))\n            {\n                //remove our socket from the stack.\n                getStunStack().removeSocket(getTransportAddress());\n\n                /*\n                 * Allow this LocalCandidate implementation to not create a\n                 * socket if it still hasn't created one.\n                 */\n                socket.close();\n            }\n        }\n    }\n\n    /**\n     * Determines whether this <tt>Candidate</tt> is the default one for its\n     * parent component.\n     *\n     * @return <tt>true</tt> if this <tt>Candidate</tt> is the default for its\n     * parent component and <tt>false</tt> if it isn't or if it has no parent\n     * Component yet.\n     */\n    @Override\n    public boolean isDefault()\n    {\n        Component parentCmp = getParentComponent();\n\n        return (parentCmp != null) && equals(parentCmp.getDefaultCandidate());\n    }\n\n    /**\n     * Set the local ufrag.\n     *\n     * @param ufrag local ufrag\n     */\n    public void setUfrag(String ufrag)\n    {\n        this.ufrag = ufrag;\n    }\n\n    /**\n     * Get the local ufrag.\n     *\n     * @return local ufrag\n     */\n    @Override\n    public String getUfrag()\n    {\n        return ufrag;\n    }\n\n    /**\n     * Returns the type of method used to discover this candidate (\"host\",\n     * \"upnp\", \"stun peer reflexive\", \"stun server reflexive\", \"turn relayed\",\n     * \"google turn relayed\", \"google tcp turn relayed\" or \"jingle node\").\n     *\n     * @return The type of method used to discover this candidate (\"host\",\n     * \"upnp\", \"stun peer reflexive\", \"stun server reflexive\", \"turn relayed\",\n     * \"google turn relayed\", \"google tcp turn relayed\" or \"jingle node\").\n     */\n    public CandidateExtendedType getExtendedType()\n    {\n        return this.extendedType;\n    }\n\n    /**\n     * Sets the type of method used to discover this candidate (\"host\", \"upnp\",\n     * \"stun peer reflexive\", \"stun server reflexive\", \"turn relayed\", \"google\n     * turn relayed\", \"google tcp turn relayed\" or \"jingle node\").\n     *\n     * @param extendedType The type of method used to discover this candidate\n     * (\"host\", \"upnp\", \"stun peer reflexive\", \"stun server reflexive\", \"turn\n     * relayed\", \"google turn relayed\", \"google tcp turn relayed\" or \"jingle\n     * node\").\n     */\n    public void setExtendedType(CandidateExtendedType extendedType)\n    {\n        this.extendedType = extendedType;\n    }\n\n    /**\n     * Find the candidate corresponding to the address given in parameter.\n     *\n     * @param relatedAddress The related address:\n     * - null for a host candidate,\n     * - the base address (host candidate) for a reflexive candidate,\n     * - the mapped address (the mapped address of the TURN allocate response)\n     * for a relayed candidate.\n     * - null for a peer reflexive candidate : there is no way to know the\n     * related address.\n     *\n     * @return The related candidate corresponding to the address given in\n     * parameter:\n     * - null for a host candidate,\n     * - the base address (host candidate) for a reflexive candidate,\n     * - the mapped address (the mapped address of the TURN allocate response)\n     * for a relayed candidate.\n     * - null for a peer reflexive candidate : there is no way to know the\n     * related address.\n     */\n    @Override\n    protected LocalCandidate findRelatedCandidate(\n            TransportAddress relatedAddress)\n    {\n        return getParentComponent().findLocalCandidate(relatedAddress);\n    }\n\n    /**\n     * Gets the value of the 'ssl' flag.\n     * @return the value of the 'ssl' flag.\n     */\n    public boolean isSSL()\n    {\n        return isSSL;\n    }\n\n    /**\n     * Sets the value of the 'ssl' flag.\n     * @param isSSL the value to set.\n     */\n    public void setSSL(boolean isSSL)\n    {\n        this.isSSL = isSSL;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final java.util.logging.Logger classLogger\n        = java.util.logging.Logger.getLogger(HostCandidate.class.getName());", "docstring": "\nThe <tt>Logger</tt> used by the <tt>LocalCandidate</tt> class for logging\noutput.\nNote that this shouldn't be used directly by instances of\n{@link DefaultNominator}, because it doesn't take into account the\nper-instance log level. Instances should use {@link #logger} instead.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "java.util.logging.Logger", "name": "classLogger\n        = java.util.logging.Logger.getLogger(HostCandidate.class.getName())", "syntax_pass": true}, {"attribute_expression": "private CandidateExtendedType extendedType = null;", "docstring": "\nThe type of method used to discover this candidate (\"host\", \"upnp\", \"stun\npeer reflexive\", \"stun server reflexive\", \"turn relayed\", \"google turn\nrelayed\", \"google tcp turn relayed\" or \"jingle node\").\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CandidateExtendedType", "name": "extendedType = null", "syntax_pass": true}, {"attribute_expression": "private String ufrag = null;", "docstring": "\nUfrag for the local candidate.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "ufrag = null", "syntax_pass": true}, {"attribute_expression": "private boolean isSSL = false;", "docstring": "\nWhether this <tt>LocalCandidate</tt> uses SSL.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "isSSL = false", "syntax_pass": true}, {"attribute_expression": "private final Logger logger;", "docstring": "\nThe {@link Logger} used by {@link LocalCandidate} instances.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Logger", "name": "logger", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/Candidate.java.Candidate", "name": "Candidate", "file_path": "src/main/java/org/ice4j/ice/Candidate.java", "superclasses": "", "methods": ["[]Candidate(TransportAddress,Component,CandidateType,T)", "[CandidateType]getType()", "[void]setCandidateType(CandidateType)", "[String]getFoundation()", "[void]setFoundation(String)", "[T]getBase()", "[void]setBase(T)", "[long]getPriority()", "[TransportAddress]getTransportAddress()", "[boolean]equals(Object)", "[int]hashCode()", "[Component]getParentComponent()", "[long]computePriority()", "[long]computeGTalkPriority()", "[long]computePriorityForType(CandidateType)", "[long]computeGTalkPriorityForType(CandidateType)", "[int]getTypePreference(CandidateType)", "[int]getLocalPreference()", "[boolean]isVirtual()", "[void]setVirtual(boolean)", "[TransportAddress]getStunServerAddress()", "[void]setStunServerAddress(TransportAddress)", "[TransportAddress]getRelayServerAddress()", "[void]setRelayServerAddress(TransportAddress)", "[TransportAddress]getMappedAddress()", "[void]setMappedAddress(TransportAddress)", "[Transport]getTransport()", "[TransportAddress]getRelatedAddress()", "[T]findRelatedCandidate(TransportAddress)", "[String]toString()", "[String]toRedactedString()", "[String]toString(boolean)", "[String]toShortString()", "[String]toRedactedShortString()", "[int]getDefaultPreference()", "[boolean]canReach(Candidate<?>)", "[boolean]isDefault()", "[String]getUfrag()", "[TransportAddress]getHostAddress()", "[TransportAddress]getReflexiveAddress()", "[TransportAddress]getRelayedAddress()", "[T]getRelatedCandidate()", "[int]compareTo(T)", "[CandidateTcpType]getTcpType()", "[void]setTcpType(CandidateTcpType)"], "method_uris": ["src/main/java/org/ice4j/ice/Candidate.java.Candidate.[]Candidate(TransportAddress,Component,CandidateType,T)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[CandidateType]getType()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setCandidateType(CandidateType)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[String]getFoundation()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setFoundation(String)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[T]getBase()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setBase(T)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[long]getPriority()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getTransportAddress()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[boolean]equals(Object)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[int]hashCode()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[Component]getParentComponent()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[long]computePriority()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[long]computeGTalkPriority()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[long]computePriorityForType(CandidateType)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[long]computeGTalkPriorityForType(CandidateType)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[int]getTypePreference(CandidateType)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[int]getLocalPreference()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[boolean]isVirtual()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setVirtual(boolean)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getStunServerAddress()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setStunServerAddress(TransportAddress)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getRelayServerAddress()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setRelayServerAddress(TransportAddress)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getMappedAddress()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setMappedAddress(TransportAddress)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[Transport]getTransport()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getRelatedAddress()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[T]findRelatedCandidate(TransportAddress)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[String]toString()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[String]toRedactedString()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[String]toString(boolean)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[String]toShortString()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[String]toRedactedShortString()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[int]getDefaultPreference()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[boolean]canReach(Candidate<?>)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[boolean]isDefault()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[String]getUfrag()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getHostAddress()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getReflexiveAddress()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[TransportAddress]getRelayedAddress()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[T]getRelatedCandidate()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[int]compareTo(T)", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[CandidateTcpType]getTcpType()", "src/main/java/org/ice4j/ice/Candidate.java.Candidate.[void]setTcpType(CandidateTcpType)"], "overrides": null, "attributes": [], "class_docstring": "\nA candidate represents a transport address that is a potential point of\ncontact for receipt of media. Candidates also have properties - their\ntype (server reflexive, relayed or host), priority, foundation,\nand base.\n<p>\nAt this point this class only supports UDP candidates. Implementation of\nsupport for other transport protocols should mean that this class should\nbecome abstract and some transport specific components like to socket for\nexample should be brought down the inheritance chain.\n</p>\n\n@author Emil Ivov\n@author Lyubomir Marinov\n", "original_string": "public abstract class Candidate<T extends Candidate<?>>\n    implements Comparable<T>\n{\n    /**\n     * The maximum value for a candidate's type preference.\n     */\n    public static final int MAX_TYPE_PREFERENCE = 126;\n\n    /**\n     * The minimum value for a candidate's type preference.\n     */\n    public static final int MIN_TYPE_PREFERENCE = 0;\n\n    /**\n     * The maximum value for a candidate's local preference.\n     */\n    public static final int MAX_LOCAL_PREFERENCE = 65535;\n\n    /**\n     * The minimum value for a candidate's local preference.\n     */\n    public static final int MIN_LOCAL_PREFERENCE = 0;\n\n    /**\n     * The transport address represented by this candidate.\n     */\n    private final TransportAddress transportAddress;\n\n    /**\n     * The type of this candidate. At this point the ICE specification (and\n     * hence this implementation) only defines for candidate types: host,\n     * server reflexive, peer reflexive and relayed candidates. Others may be\n     * added in the future.\n     */\n    private CandidateType candidateType;\n\n    /**\n     * An arbitrary string that is the same for two candidates\n     * that have the same type, base IP address, protocol (UDP, TCP,\n     * etc.) and STUN or TURN server. If any of these are different then\n     * the foundation will be different. Two candidate pairs with the\n     * same foundation pairs are likely to have similar network\n     * characteristics. Foundations are used in the frozen algorithm.\n     */\n    private String foundation = null;\n\n    /**\n     * The base of a server reflexive candidate is the host candidate\n     * from which it was derived. A host candidate is also said to have\n     * a base, equal to that candidate itself. Similarly, the base of a\n     * relayed candidate is that candidate itself.\n     */\n    private T base = null;\n\n    /**\n     * A unique priority number that MUST be a positive integer between 1 and\n     * (2**32 - 1). This priority will be set and used by ICE algorithms to\n     * determine the order of the connectivity checks and the relative\n     * preference for candidates.\n     */\n    protected long priority = 0;\n\n    /**\n     * Specifies whether the address associated with this candidate belongs to\n     * a VPN interface. In many cases (e.g. when running on a 1.5 JVM) we won't\n     * be able to determine whether an interface is virtual or not. If we are\n     * however (that is when running a more recent JVM) we will reflect it in\n     * this property.\n     */\n    private boolean virtual = false;\n\n    /**\n     * The component that this candidate was created for. Every candidate is\n     * always associated with a specific component for which it is a candidate.\n     */\n    private final Component parentComponent;\n\n    /**\n     * The address of the STUN server that was used to obtain this\n     * <tt>Candidate</tt>. Will be <tt>null</tt> if this is not a server\n     * reflexive candidate.\n     */\n    private TransportAddress stunServerAddress = null;\n\n    /**\n     * The address of the relay server (i.e. TURN, Jingle Nodes, ...) that was\n     * used to obtain this <tt>Candidate</tt>. Will be <tt>null</tt> if this is\n     * not a relayed candidate.\n     */\n    private TransportAddress relayServerAddress = null;\n\n    /**\n     * The address that our TURN/STUN server returned as mapped if this is a\n     * relayed or a reflexive <tt>Candidate</tt>. Will remain <tt>null</tt> if\n     * this is a host candidate.\n     */\n    private TransportAddress mappedAddress = null;\n\n    /**\n     * The related candidate:\n     * - null for a host candidate,\n     * - the base address (host candidate) for a reflexive candidate,\n     * - the mapped address (the mapped address of the TURN allocate response)\n     * for a relayed candidate.\n     * - null for a peer reflexive candidate : there is no way to know the\n     * related address.\n     */\n    private T relatedCandidate = null;\n\n    /**\n     * The <tt>CandidateTcpType</tt> for this <tt>Candidate</tt>.\n     */\n    private CandidateTcpType tcpType = null;\n\n    /**\n     * Creates a candidate for the specified transport address and properties.\n     *\n     * @param transportAddress  the transport address that this candidate is\n     * encapsulating.\n     * @param parentComponent the <tt>Component</tt> that this candidate\n     * belongs to.\n     * @param type the <tt>CandidateType</tt> for this <tt>Candidate</tt>.\n     * @param relatedCandidate The related candidate:\n     * - null for a host candidate,\n     * - the base address (host candidate) for a reflexive candidate,\n     * - the mapped address (the mapped address of the TURN allocate response)\n     * for a relayed candidate.\n     * - null for a peer reflexive candidate : there is no way to know the\n     * related address.\n     */\n    public Candidate(TransportAddress transportAddress,\n                     Component        parentComponent,\n                     CandidateType    type,\n                     T relatedCandidate)\n    {\n        this.transportAddress = transportAddress;\n        this.parentComponent = parentComponent;\n        this.candidateType = type;\n        this.relatedCandidate = relatedCandidate;\n    }\n\n    /**\n     * Returns the type of this candidate which should be an instance of the\n     * {@link CandidateType} enumeration.\n     *\n     * @return a <tt>CandidateType</tt> indicating the type of this\n     * <tt>Candidate</tt>.\n     */\n    public CandidateType getType()\n    {\n        return candidateType;\n    }\n\n    /**\n     * Sets the type of this candidate which should be an instance of the\n     * {@link CandidateType} enumeration.\n     *\n     * @param candidateType a <tt>CandidateType</tt> instance indicating the\n     * type of this <tt>Candidate</tt>.\n     */\n    public void setCandidateType(CandidateType candidateType)\n    {\n        this.candidateType = candidateType;\n    }\n\n    /**\n     * Returns a <tt>String</tt> containing the foundation of this\n     * <tt>Candidate</tt>. A foundation is an arbitrary <tt>String</tt> that is\n     * the same for candidates that have the same type, base IP address,\n     * transport protocol (UDP, TCP, etc.) and STUN or TURN server. If any of\n     * these are different then the foundation will be different. Two candidate\n     * pairs with the same foundation pairs are likely to have similar network\n     * characteristics. Typically, candidates for RTP and RTCP streams will\n     * share the same foundation. Foundations are used in the frozen algorithm.\n     *\n     * @return the foundation of this <tt>Candidate</tt>.\n     */\n    public String getFoundation()\n    {\n        return foundation;\n    }\n\n    /**\n     * Sets this <tt>Candidate</tt>'s foundation. A foundation is an arbitrary\n     * string that is always the same for candidates that have the same type,\n     * base IP address, protocol (UDP, TCP, etc.) and STUN or TURN server. If\n     * any of these are different then the foundation will be different. Two\n     * candidate pairs with the same foundation pairs are likely to have similar\n     * network characteristics. Foundations are used in the frozen algorithm.\n     *\n     * @param foundation the foundation of this <tt>Candidate</tt>.\n     */\n    public void setFoundation(String foundation)\n    {\n        this.foundation = foundation;\n    }\n\n    /**\n     * Returns this <tt>Candidate</tt>'s base. The base of a server\n     * reflexive candidate is the host candidate from which it was derived.\n     * A host candidate is also said to have a base, equal to that candidate\n     * itself. Similarly, the base of a relayed candidate is that candidate\n     * itself.\n     *\n     * @return the base <tt>Candidate</tt> for this <tt>Candidate</tt>.\n     */\n    public T getBase()\n    {\n        return base;\n    }\n\n    /**\n     * Sets this <tt>Candidate</tt>'s base. The base of a server\n     * reflexive candidate is the host candidate from which it was derived.\n     * A host candidate is also said to have a base, equal to that candidate\n     * itself. Similarly, the base of a relayed candidate is that candidate\n     * itself.\n     *\n     * @param base the base <tt>Candidate</tt> of this <tt>Candidate</tt>.\n     */\n    public void setBase(T base)\n    {\n        this.base = base;\n    }\n\n    /**\n     * Returns the priority of this candidate. Priority is a unique priority\n     * number that MUST be a positive integer between 1 and (2**32 - 1). This\n     * priority will be set and used by ICE algorithms to  determine the order\n     * of the connectivity checks and the relative preference for candidates.\n     *\n     * @return a number between 1 and (2**32 - 1) indicating the priority of\n     * this candidate.\n     */\n    public long getPriority()\n    {\n        return priority;\n    }\n\n    /**\n     * Returns the transport address that this candidate is representing.\n     *\n     * @return the TransportAddress encapsulated by this Candidate.\n     */\n    public TransportAddress getTransportAddress()\n    {\n        return transportAddress;\n    }\n\n    /**\n     * Indicates whether some other Candidate is \"equal to\" this one. We\n     * consider candidates equal when they are redundant, i.e.\n     * <p>\n     * @param obj the reference object with which to compare.\n     * <p>\n     * @return <code>true</code> if this <tt>Candidate</tt> is equal to the\n     * obj argument; <code>false</code> otherwise.\n     *\n     * @throws java.lang.NullPointerException if <tt>obj</tt> is null;\n     */\n    @Override\n    public boolean equals(Object obj)\n        throws NullPointerException\n    {\n        if (obj == this)\n            return true;\n\n        if (! (obj instanceof Candidate))\n            return false;\n\n        Candidate<?> candidate = (Candidate<?>) obj;\n\n        //compare candidate addresses\n        if (! candidate.getTransportAddress().equals(getTransportAddress()))\n            return false;\n\n        //compare bases\n        Candidate<?> base = getBase();\n        Candidate<?> candidateBase = candidate.getBase();\n        boolean baseEqualsCandidateBase;\n\n        if (base == null)\n        {\n            if (candidateBase != null)\n                return false;\n            else\n                baseEqualsCandidateBase = true;\n        }\n        else\n        {\n            // If this and candidate are bases of themselves, their bases are\n            // considered equal.\n            baseEqualsCandidateBase\n                = (base == this && candidateBase == candidate)\n                    || base.equals(candidateBase);\n        }\n\n        //compare other properties\n        return\n            baseEqualsCandidateBase\n                && getPriority() == candidate.getPriority()\n                && getType() == candidate.getType()\n                && getFoundation().equals(candidate.getFoundation());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int hashCode()\n    {\n        // Even if the following hashCode algorithm has drawbacks because of it\n        // simplicity, it is better than nothing because at least it allows\n        // Candidate and, respectively, CandidatePair to be used as HashMap\n        // keys.\n        return\n            getParentComponent().hashCode() + getTransportAddress().hashCode();\n    }\n\n    /**\n     * Returns a reference to the <tt>Component</tt> that this candidate belongs\n     * to.\n     *\n     * @return a reference to the <tt>Component</tt> that this candidate belongs\n     * to.\n     */\n    public Component getParentComponent()\n    {\n        return parentComponent;\n    }\n\n    /**\n     * Computes the priority for this <tt>Candidate</tt> based on the procedures\n     * defined in the ICE specification..\n     *\n     * @return the priority for this <tt>Candidate</tt> as per the procedures\n     * defined in the ICE specification..\n     */\n    public long computePriority()\n    {\n        this.priority = computePriorityForType(getType());\n\n        return this.priority;\n    }\n\n    /**\n     * Computes the priority for this <tt>Candidate</tt> based on the procedures\n     * defined in the Google Talk specification.\n     *\n     * @return the priority for this <tt>Candidate</tt> as per the procedures\n     * defined in the ICE specification..\n     */\n    public long computeGTalkPriority()\n    {\n        this.priority = computeGTalkPriorityForType(getType());\n\n        return this.priority;\n    }\n\n    /**\n     * Computes the priority this <tt>Candidate</tt> would have if it were of\n     * the specified <tt>candidateType</tt> and based on the procedures\n     * defined in the ICE specification. The reason we need this method in\n     * addition to the {@link #computePriority()} one is the need to be able\n     * to compute the priority of a peer reflexive <tt>candidate</tt> that we\n     * might learn during connectivity checks through this <tt>Candidate</tt>.\n     *\n     * @param candidateType the hypothetical type that we'd like to use when\n     * computing the priority for this <tt>Candidate</tt>.\n     *\n     * @return the priority this <tt>Candidate</tt> would have had if it were\n     * of the specified <tt>candidateType</tt>.\n     */\n    public long computePriorityForType(CandidateType candidateType)\n    {\n        //According to the ICE spec we compute priority this way:\n        //priority = (2^24)*(type preference) +\n        //           (2^8)*(local preference) +\n        //           (2^0)*(256 - component ID)\n\n        return (long) (getTypePreference(candidateType)  << 24) +\n               (long) (getLocalPreference()              << 8 ) +\n               (long) (256 - getParentComponent().getComponentID());\n    }\n\n    /**\n     * Computes the priority this <tt>Candidate</tt> would have if it were of\n     * the specified <tt>candidateType</tt> and based on the procedures\n     * defined in the Google Talk specification.\n     *\n     * @param candidateType the hypothetical type that we'd like to use when\n     * computing the priority for this <tt>Candidate</tt>.\n     * @return the priority this <tt>Candidate</tt> would have had if it were\n     * of the specified <tt>candidateType</tt>.\n     */\n    public long computeGTalkPriorityForType(CandidateType candidateType)\n    {\n        long priority = 0;\n\n        /* Google Talk priority is in range 0 - 1, we multiply this by 1000\n         * to have a long rather than float\n         */\n        if (candidateType == CandidateType.HOST_CANDIDATE)\n        {\n           priority += 0.95 * 1000 -\n               (this.getBase().getTransport() == Transport.TCP ? 200 : 0);\n        }\n        else if (candidateType == CandidateType.PEER_REFLEXIVE_CANDIDATE)\n        {\n            priority += (long)(0.9 * 1000) -\n                (this.getBase().getTransport() == Transport.TCP ? 200 : 0);\n        }\n        else if (candidateType == CandidateType.SERVER_REFLEXIVE_CANDIDATE)\n        {\n            priority += (long)(0.9 * 1000);\n        }\n        else //relayed candidates\n        {\n            priority += (long)(0.5 * 1000);\n        }\n\n        priority -= getParentComponent().getComponentID() - 1;\n\n        InetAddress addr = getTransportAddress().getAddress();\n\n        // IPv6 has better priority than IPv4\n        if (addr instanceof Inet6Address)\n        {\n            if (addr.isLinkLocalAddress())\n            {\n                priority += 40;\n            }\n            else\n                priority += 50;\n        }\n\n        return priority;\n    }\n\n    /**\n     * Returns the type preference that should be used when computing priority\n     * for <tt>Candidate</tt>s of the specified <tt>candidateType</tt>.\n     * The type preference MUST be an integer from <tt>0</tt> to <tt>126</tt>\n     * inclusive, and represents the preference for the type of the candidate\n     * (where the types are local, server reflexive, peer reflexive and\n     * relayed). A <tt>126</tt> is the highest preference, and a <tt>0</tt> is\n     * the lowest. Setting the value to a <tt>0</tt> means that candidates of\n     * this type will only be used as a last resort.  The type preference MUST\n     * be identical for all candidates of the same type and MUST be different\n     * for candidates of different types.  The type preference for peer\n     * reflexive candidates MUST be higher than that of server reflexive\n     * candidates.\n     *\n     * @param candidateType the <tt>CandidateType</tt> that we'd like to obtain\n     * a preference for.\n     *\n     * @return the type preference for this <tt>Candidate</tt> as per the\n     * procedures in the ICE specification.\n     */\n    private static int getTypePreference(CandidateType candidateType)\n    {\n        int typePreference;\n\n        if (candidateType == CandidateType.HOST_CANDIDATE)\n        {\n            typePreference = MAX_TYPE_PREFERENCE; // 126\n        }\n        else if (candidateType == CandidateType.PEER_REFLEXIVE_CANDIDATE)\n        {\n            typePreference = 110;\n        }\n        else if (candidateType == CandidateType.SERVER_REFLEXIVE_CANDIDATE)\n        {\n            typePreference = 100;\n        }\n        else //relayed candidates\n        {\n            typePreference =  MIN_TYPE_PREFERENCE; // 0\n        }\n\n        return typePreference;\n    }\n\n    /**\n     * Calculates and returns the local preference for this <tt>Candidate</tt>\n     * <p>\n     * The local preference MUST be an integer from <tt>0</tt> to <tt>65535</tt>\n     * inclusive. It represents a preference for the particular IP address from\n     * which the candidate was obtained, in cases where an agent is multihomed.\n     * <tt>65535</tt> represents the highest preference, and a zero, the lowest.\n     * When there is only a single IP address, this value SHOULD be set to\n     * <tt>65535</tt>. More generally, if there are multiple candidates for a\n     * particular component for a particular media stream which have the same\n     * type, the local preference MUST be unique for each one. In this\n     * specification, this only happens for multihomed hosts.  If a host is\n     * multihomed because it is dual stacked, the local preference SHOULD be\n     * set equal to the precedence value for IP addresses described in RFC 3484.\n     * </p>\n     * @return the local preference for this <tt>Candidate</tt>.\n     */\n    private int getLocalPreference()\n    {\n        //The ICE spec says: When there is only a single IP address, this value\n        //SHOULD be set to.\n        if (getParentComponent().countLocalHostCandidates() < 2)\n            return MAX_LOCAL_PREFERENCE;\n\n        //The ICE spec also says: Furthermore, if an agent is multi-homed and\n        //has multiple IP addresses, the local preference for host candidates\n        //from a VPN interface SHOULD have a priority of 0.\n        if (isVirtual())\n            return MIN_LOCAL_PREFERENCE;\n\n        InetAddress addr = getTransportAddress().getAddress();\n\n        //the following tries to reuse precedence from RFC 3484 but that's a\n        //bit tricky since it is not meant to be used exactly the way that\n        //Johnnie seems to think.\n\n        //prefer IPv6 to IPv4\n        if (addr instanceof Inet6Address)\n        {\n            //prefer link local addresses to global ones\n            if (addr.isLinkLocalAddress())\n                return 30;\n            else\n                return 40;\n        }\n        else\n        {\n            //IPv4\n            return 10;\n        }\n    }\n\n    /**\n     * Determines whether the address associated with this candidate belongs to\n     * a VPN interface. In many cases (e.g. when running on a 1.5 JVM) we won't\n     * be able to determine whether an interface is virtual or not. If we are\n     * however (that is when running a more recent JVM) we will reflect it in\n     * this property. Note that the <tt>isVirtual</tt> property is not really\n     * an ICE concept. The ICE specs only mention it and give basic guidelines\n     * as to how it should be handled so other implementations maybe dealing\n     * with it differently.\n     *\n     * @return <tt>true</tt> if we were able to determine that the address\n     * associated with this <tt>Candidate</tt> comes from a virtual interface\n     * and <tt>false</tt> if otherwise.\n     */\n    public boolean isVirtual()\n    {\n        return virtual;\n    }\n\n    /**\n     * Specifies whether the address associated with this candidate belongs to\n     * a VPN interface. In many cases (e.g. when running on a 1.5 JVM) we won't\n     * be able to determine whether an interface is virtual or not. If we are\n     * however (that is when running a more recent JVM) we will reflect it in\n     * this property. Note that the <tt>isVirtual</tt> property is not really\n     * an ICE concept. The ICE specs only mention it and give basic guidelines\n     * as to how it should be handled so other implementations maybe dealing\n     * with it differently.\n     *\n     * @param virtual <tt>true</tt> if we were able to determine that the\n     * address associated with this <tt>Candidate</tt> comes from a virtual\n     * interface and <tt>false</tt> if otherwise.\n     */\n    public void setVirtual(boolean virtual)\n    {\n        this.virtual = virtual;\n    }\n\n    /**\n     * Returns the address of the STUN server that was used to obtain this\n     * <tt>Candidate</tt> or <tt>null</tt> if this is not a server reflexive\n     * candidate.\n     *\n     * @return the address of the STUN server that was used to obtain this\n     * <tt>Candidate</tt> or <tt>null</tt> if this is not a server reflexive\n     * candidate.\n     */\n    public TransportAddress getStunServerAddress()\n    {\n        return stunServerAddress;\n    }\n\n    /**\n     * Sets the address of the STUN server that was used to obtain this\n     * <tt>Candidate</tt>. Only makes sense if this is a relayed candidate.\n     *\n     * @param address the address of the STUN server that was used to obtain\n     * this <tt>Candidate</tt> or <tt>null</tt> if this is not a server\n     * reflexive candidate.\n     */\n    protected void setStunServerAddress(TransportAddress address)\n    {\n        this.stunServerAddress = address;\n    }\n\n    /**\n     * Returns the address of the relay server (i.e. TURN, Jingle Nodes, ...)\n     * that was used to obtain this <tt>Candidate</tt> or <tt>null</tt> if this\n     * is not a relayed candidate.\n     *\n     * @return the address of the relay server that was used to obtain this\n     * <tt>Candidate</tt> or <tt>null</tt> if this is not a relayed candidate.\n     */\n    public TransportAddress getRelayServerAddress()\n    {\n        return relayServerAddress;\n    }\n\n    /**\n     * Sets the address of the relay server (i.e. TURN, Jingle Nodes, ...) that\n     * was used to obtain this <tt>Candidate</tt>. Only makes sense if this is a\n     *  relayed candidate.\n     *\n     * @param address the address of the relay server that was used to obtain\n     * this <tt>Candidate</tt> or <tt>null</tt> if this is not a relayed\n     * candidate.\n     */\n    protected void setRelayServerAddress(TransportAddress address)\n    {\n        this.relayServerAddress = address;\n    }\n\n    /**\n     * Returns the address that was returned to us a \"mapped address\" from a\n     * TURN or a STUN server in case this <tt>Candidate</tt> is relayed or\n     * reflexive and <tt>null</tt> otherwise. Note that the address returned by\n     * this method would be equal to the transport address for reflexive\n     * <tt>Candidate</tt>s but not for relayed ones.\n     *\n     * @return the address that our TURN/STUN server returned as mapped if this\n     * is a relayed or a reflexive <tt>Candidate</tt> or <tt>null</tt> if this\n     * is a host candidate.\n     */\n    public TransportAddress getMappedAddress()\n    {\n        return mappedAddress;\n    }\n\n    /**\n     * Sets the address that was returned to us a \"mapped address\" from a\n     * TURN or a STUN server in case this <tt>Candidate</tt> is relayed.\n     *\n     * @param address the address that our TURN/STUN server returned as mapped\n     * if this is a relayed or a reflexive <tt>Candidate</tt>.\n     */\n    protected void setMappedAddress(TransportAddress address)\n    {\n        this.mappedAddress = address;\n    }\n\n    /**\n     * Returns the <tt>Transport</tt> for this <tt>Candidate</tt>. This is a\n     * convenience method only and it is equivalent to retrieving the transport\n     * of this <tt>Candidate</tt>'s transport address.\n     *\n     * @return the <tt>Transport</tt> that this <tt>Candidate</tt> was obtained\n     * for/with.\n     */\n    public Transport getTransport()\n    {\n        return getTransportAddress().getTransport();\n    }\n\n    /**\n     * Returns a <tt>TransportAddress</tt> related to this <tt>Candidate</tt>.\n     * Related addresses are present for server reflexive, peer reflexive and\n     * relayed candidates. If a candidate is server or peer reflexive,\n     * the related address is equal to the base of this <tt>Candidate</tt>.\n     * If the candidate is relayed, the returned address is equal to the mapped\n     * address. If the candidate is a host candidate then the method returns\n     * <tt>null</tt>.\n     *\n     * @return the <tt>TransportAddress</tt> of the base if this is a reflexive\n     * candidate, the mapped address in the case of a relayed candidate, and\n     * <tt>null</tt> if this is a host or a remote candidate.\n     */\n    public TransportAddress getRelatedAddress()\n    {\n        if (getRelatedCandidate() != null)\n        {\n            return getRelatedCandidate().getTransportAddress();\n        }\n        return null;\n    }\n\n    /**\n     * Find the candidate corresponding to the address given in parameter.\n     *\n     * @param relatedAddress The related address:\n     * - null for a host candidate,\n     * - the base address (host candidate) for a reflexive candidate,\n     * - the mapped address (the mapped address of the TURN allocate response)\n     * for a relayed candidate.\n     * - null for a peer reflexive candidate : there is no way to know the\n     * related address.\n     *\n     * @return The related candidate corresponding to the address given in\n     * parameter:\n     * - null for a host candidate,\n     * - the base address (host candidate) for a reflexive candidate,\n     * - the mapped address (the mapped address of the TURN allocate response)\n     * for a relayed candidate.\n     * - null for a peer reflexive candidate : there is no way to know the\n     * related address.\n     */\n    protected abstract T findRelatedCandidate(TransportAddress relatedAddress);\n\n    /**\n     * Returns a <tt>String</tt> representation of this <tt>Candidate</tt>\n     * containing its <tt>TransportAddress</tt>, base, foundation, priority and\n     * whatever other properties may be relevant.\n     *\n     * @return a <tt>String</tt> representation of this <tt>Candidate</tt>.\n     */\n    @Override\n    public String toString() {\n        return toString(false);\n    }\n\n    /**\n     * Returns a <tt>String</tt> representation of this <tt>Candidate</tt>\n     * containing its <tt>TransportAddress</tt>, base, foundation, priority and\n     * whatever other properties may be relevant, but with its IP address redacted if\n     * redaction is enabled.\n     *\n     * @return a redacted <tt>String</tt> representation of this <tt>Candidate</tt>.\n     */\n    public String toRedactedString() {\n        return toString(true);\n    }\n\n    private String toString(boolean redacted)\n    {\n        StringBuilder buff = new StringBuilder(\"candidate:\");\n\n        buff.append(getFoundation());\n        buff.append(\" \").append(getParentComponent().getComponentID());\n        buff.append(\" \").append(getTransport());\n        buff.append(\" \").append(getPriority());\n        if (redacted && getType() != CandidateType.RELAYED_CANDIDATE)\n        {\n            buff.append(\" \").append(getTransportAddress().getRedactedAddress());\n        }\n        else\n        {\n            buff.append(\" \").append(getTransportAddress().getHostAddress());\n        }\n        buff.append(\" \").append(getTransportAddress().getPort());\n        buff.append(\" typ \").append(getType());\n\n        TransportAddress relAddr = getRelatedAddress();\n\n        if (relAddr != null)\n        {\n            buff.append(\" raddr \");\n            if (redacted)\n            {\n                buff.append(relAddr.getRedactedAddress());\n            }\n            else\n            {\n                buff.append(relAddr.getHostAddress());\n            }\n            buff.append(\" rport \").append(relAddr.getPort());\n        }\n\n        return buff.toString();\n    }\n\n    /**\n     * Returns short <tt>String</tt> representation of this <tt>Candidate</tt>.\n     * @return short <tt>String</tt> representation of this <tt>Candidate</tt>.\n     */\n    public String toShortString()\n    {\n        return getTransportAddress() + \"/\" + getType();\n    }\n\n    public String toRedactedShortString()\n    {\n        if (getType() == CandidateType.RELAYED_CANDIDATE)\n        {\n            return toShortString();\n        }\n        return getTransportAddress().toRedactedString() + \"/\" + getType();\n    }\n\n    /**\n     * Returns an integer indicating the preference that this <tt>Candidate</tt>\n     * should be considered with for becoming a default candidate.\n     *\n     * @return an integer indicating the preference that this <tt>Candidate</tt>\n     * should be considered with for becoming a default candidate.\n     */\n    protected int getDefaultPreference()\n    {\n        // https://tools.ietf.org/html/rfc5245#section-4.1.4\n        //\n        // It is RECOMMENDED that default candidates be chosen based on the\n        // likelihood of those candidates to work with the peer that is being\n        // contacted.  It is RECOMMENDED that the default candidates are the\n        // relayed candidates (if relayed candidates are available), server\n        // reflexive candidates (if server reflexive candidates are available),\n        // and finally host candidates.\n\n        switch (getType())\n        {\n        case RELAYED_CANDIDATE:\n            return 30;\n\n        case SERVER_REFLEXIVE_CANDIDATE:\n            return 20;\n\n        case HOST_CANDIDATE:\n            // Prefer IPv4 as default since many servers would still freak out\n            // when seeing IPv6 address.\n            return getTransportAddress().isIPv6() ? 10 : 15;\n\n        default:\n            // WTF?\n            return 5;\n        }\n    }\n\n    /**\n     * Determines whether this <tt>Candidate</tt>'s<tt>TransportAddress</tt> is\n     * theoretically usable for communication with that of <tt>dst</tt>. Same\n     * as calling:\n     * <p>\n     *  <tt>getTransportAddress().canReach(dst.getTransportAddress())</tt>\n     * </p>\n     *\n     * @param dst the <tt>Candidate</tt> that we'd like to check for\n     * reachability from this one.\n     *\n     * @return <tt>true</tt> if this {@link Candidate} shares the same\n     * <tt>Transport</tt> and family as <tt>dst</tt> or <tt>false</tt>\n     * otherwise.\n     *\n     */\n    public boolean canReach(Candidate<?> dst)\n    {\n        return getTransportAddress().canReach(dst.getTransportAddress());\n    }\n\n    /**\n     * Determines whether this <tt>Candidate</tt> is the default one for its\n     * parent component.\n     *\n     * @return <tt>true</tt> if this <tt>Candidate</tt> is the default for its\n     * parent component and <tt>false</tt> if it isn't or if it has no parent\n     * Component yet.\n     */\n    public abstract boolean isDefault();\n\n    /**\n     * Get the local ufrag.\n     *\n     * @return local ufrag\n     */\n    public abstract String getUfrag();\n\n    /**\n     * Returns this candidate host address.\n     *\n     * @return This candidate host address.\n     */\n    public TransportAddress getHostAddress()\n    {\n        switch (getType())\n        {\n            case SERVER_REFLEXIVE_CANDIDATE:\n                if (getBase() != null)\n                {\n                    return getBase().getHostAddress();\n                }\n                break;\n            case PEER_REFLEXIVE_CANDIDATE:\n                if (getBase() != null)\n                {\n                    return getBase().getHostAddress();\n                }\n                break;\n            case RELAYED_CANDIDATE:\n                if (getRelatedCandidate() != null)\n                {\n                    return getRelatedCandidate().getHostAddress();\n                }\n                break;\n            default: //host candidate\n                return getTransportAddress();\n        }\n        return null;\n    }\n\n    /**\n     * Returns this candidate reflexive address.\n     *\n     * @return This candidate reflexive address. Null if this candidate\n     * does not use a peer/server reflexive address.\n     */\n    public TransportAddress getReflexiveAddress()\n    {\n        switch (getType())\n        {\n            case SERVER_REFLEXIVE_CANDIDATE:\n                return getTransportAddress();\n            case PEER_REFLEXIVE_CANDIDATE:\n                return getTransportAddress();\n            case RELAYED_CANDIDATE:\n                // Corresponding to getMappedAddress();\n                if (getRelatedCandidate() != null)\n                {\n                    return getRelatedCandidate().getReflexiveAddress();\n                }\n                break;\n            default: //host candidate\n                return null;\n        }\n        return null;\n    }\n\n    /**\n     * Returns this candidate relayed address.\n     *\n     * @return This candidate relayed address. Null if this candidate\n     * does not use a relay.\n     */\n    public TransportAddress getRelayedAddress()\n    {\n        switch (getType())\n        {\n            case SERVER_REFLEXIVE_CANDIDATE:\n                return null;\n            case PEER_REFLEXIVE_CANDIDATE:\n                return null;\n            case RELAYED_CANDIDATE:\n                return getTransportAddress();\n            default: //host candidate\n                return null;\n        }\n    }\n\n    /**\n     * Returns the related candidate corresponding to the address given in\n     * parameter:\n     * - null for a host candidate,\n     * - the base address (host candidate) for a reflexive candidate,\n     * - the mapped address (the mapped address of the TURN allocate response)\n     * for a relayed candidate.\n     * - null for a peer reflexive candidate : there is no way to know the\n     * related address.\n     *\n     * @return The related candidate corresponding to the address given in\n     * parameter:\n     * - null for a host candidate,\n     * - the base address (host candidate) for a reflexive candidate,\n     * - the mapped address (the mapped address of the TURN allocate response)\n     * for a relayed candidate.\n     * - null for a peer reflexive candidate : there is no way to know the\n     * related address.\n     */\n    public T getRelatedCandidate()\n    {\n        if (this.relatedCandidate == null)\n        {\n            TransportAddress relatedAddress = null;\n            switch (getType())\n            {\n            case SERVER_REFLEXIVE_CANDIDATE:\n                if (getBase() != null)\n                {\n                    relatedAddress = getBase().getTransportAddress();\n                }\n                break;\n            case PEER_REFLEXIVE_CANDIDATE:\n                if (getBase() != null)\n                {\n                    relatedAddress = getBase().getTransportAddress();\n                }\n                break;\n            case RELAYED_CANDIDATE:\n                relatedAddress = getMappedAddress();\n                break;\n            default:\n                //host candidate\n                return null;\n            }\n            // Update the related candidate conforming to the related address.\n            this.relatedCandidate = findRelatedCandidate(relatedAddress);\n        }\n\n        return this.relatedCandidate;\n    }\n\n    /**\n     * Compares this <tt>Candidate</tt> with the specified one based on their\n     * priority and returns a negative integer, zero, or a positive integer if\n     * this <tt>Candidate</tt> has a lower, equal, or greater priority than the\n     * second.\n     *\n     * @param candidate the second <tt>Candidate</tt> to compare.\n     *\n     * @return a negative integer, zero, or a positive integer as the first\n     * <tt>Candidate</tt> has a lower, equal, or greater priority than the\n     * second.\n     */\n    public int compareTo(T candidate)\n    {\n        return CandidatePrioritizer.compareCandidates(this, candidate);\n    }\n\n    /**\n     * Gets the <tt>CandidateTcpType</tt> for this <tt>Candidate</tt>.\n     * @return the <tt>CandidateTcpType</tt> for this <tt>Candidate</tt>.\n     */\n    public CandidateTcpType getTcpType()\n    {\n        return tcpType;\n    }\n\n    /**\n     * Sets the <tt>CandidateTcpType</tt> for this <tt>Candidate</tt>.\n     * @param tcpType the <tt>CandidateTcpType</tt> to set.\n     */\n    public void setTcpType(CandidateTcpType tcpType)\n    {\n        this.tcpType = tcpType;\n    }\n}", "super_interfaces": ["Comparable<T>"], "fields": [{"attribute_expression": "public static final int MAX_TYPE_PREFERENCE = 126;", "docstring": "\nThe maximum value for a candidate's type preference.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "MAX_TYPE_PREFERENCE = 126", "syntax_pass": true}, {"attribute_expression": "public static final int MIN_TYPE_PREFERENCE = 0;", "docstring": "\nThe minimum value for a candidate's type preference.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "MIN_TYPE_PREFERENCE = 0", "syntax_pass": true}, {"attribute_expression": "public static final int MAX_LOCAL_PREFERENCE = 65535;", "docstring": "\nThe maximum value for a candidate's local preference.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "MAX_LOCAL_PREFERENCE = 65535", "syntax_pass": true}, {"attribute_expression": "public static final int MIN_LOCAL_PREFERENCE = 0;", "docstring": "\nThe minimum value for a candidate's local preference.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "MIN_LOCAL_PREFERENCE = 0", "syntax_pass": true}, {"attribute_expression": "private final TransportAddress transportAddress;", "docstring": "\nThe transport address represented by this candidate.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TransportAddress", "name": "transportAddress", "syntax_pass": true}, {"attribute_expression": "private CandidateType candidateType;", "docstring": "\nThe type of this candidate. At this point the ICE specification (and\nhence this implementation) only defines for candidate types: host,\nserver reflexive, peer reflexive and relayed candidates. Others may be\nadded in the future.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CandidateType", "name": "candidateType", "syntax_pass": true}, {"attribute_expression": "private String foundation = null;", "docstring": "\nAn arbitrary string that is the same for two candidates\nthat have the same type, base IP address, protocol (UDP, TCP,\netc.) and STUN or TURN server. If any of these are different then\nthe foundation will be different. Two candidate pairs with the\nsame foundation pairs are likely to have similar network\ncharacteristics. Foundations are used in the frozen algorithm.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "foundation = null", "syntax_pass": true}, {"attribute_expression": "private T base = null;", "docstring": "\nThe base of a server reflexive candidate is the host candidate\nfrom which it was derived. A host candidate is also said to have\na base, equal to that candidate itself. Similarly, the base of a\nrelayed candidate is that candidate itself.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "T", "name": "base = null", "syntax_pass": true}, {"attribute_expression": "protected long priority = 0;", "docstring": "\nA unique priority number that MUST be a positive integer between 1 and\n(2**32 - 1). This priority will be set and used by ICE algorithms to\ndetermine the order of the connectivity checks and the relative\npreference for candidates.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "long", "name": "priority = 0", "syntax_pass": true}, {"attribute_expression": "private boolean virtual = false;", "docstring": "\nSpecifies whether the address associated with this candidate belongs to\na VPN interface. In many cases (e.g. when running on a 1.5 JVM) we won't\nbe able to determine whether an interface is virtual or not. If we are\nhowever (that is when running a more recent JVM) we will reflect it in\nthis property.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "virtual = false", "syntax_pass": true}, {"attribute_expression": "private final Component parentComponent;", "docstring": "\nThe component that this candidate was created for. Every candidate is\nalways associated with a specific component for which it is a candidate.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Component", "name": "parentComponent", "syntax_pass": true}, {"attribute_expression": "private TransportAddress stunServerAddress = null;", "docstring": "\nThe address of the STUN server that was used to obtain this\n<tt>Candidate</tt>. Will be <tt>null</tt> if this is not a server\nreflexive candidate.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransportAddress", "name": "stunServerAddress = null", "syntax_pass": true}, {"attribute_expression": "private TransportAddress relayServerAddress = null;", "docstring": "\nThe address of the relay server (i.e. TURN, Jingle Nodes, ...) that was\nused to obtain this <tt>Candidate</tt>. Will be <tt>null</tt> if this is\nnot a relayed candidate.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransportAddress", "name": "relayServerAddress = null", "syntax_pass": true}, {"attribute_expression": "private TransportAddress mappedAddress = null;", "docstring": "\nThe address that our TURN/STUN server returned as mapped if this is a\nrelayed or a reflexive <tt>Candidate</tt>. Will remain <tt>null</tt> if\nthis is a host candidate.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TransportAddress", "name": "mappedAddress = null", "syntax_pass": true}, {"attribute_expression": "private T relatedCandidate = null;", "docstring": "\nThe related candidate:\n- null for a host candidate,\n- the base address (host candidate) for a reflexive candidate,\n- the mapped address (the mapped address of the TURN allocate response)\nfor a relayed candidate.\n- null for a peer reflexive candidate : there is no way to know the\nrelated address.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "T", "name": "relatedCandidate = null", "syntax_pass": true}, {"attribute_expression": "private CandidateTcpType tcpType = null;", "docstring": "\nThe <tt>CandidateTcpType</tt> for this <tt>Candidate</tt>.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CandidateTcpType", "name": "tcpType = null", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractCandidateHarvester.java.AbstractCandidateHarvester", "name": "AbstractCandidateHarvester", "file_path": "src/main/java/org/ice4j/ice/harvest/AbstractCandidateHarvester.java", "superclasses": "", "methods": ["[HarvestStatistics]getHarvestStatistics()", "[boolean]isHostHarvester()"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/AbstractCandidateHarvester.java.AbstractCandidateHarvester.[HarvestStatistics]getHarvestStatistics()", "src/main/java/org/ice4j/ice/harvest/AbstractCandidateHarvester.java.AbstractCandidateHarvester.[boolean]isHostHarvester()"], "overrides": null, "attributes": [], "class_docstring": "\nAn abstract partial implementation of {@link CandidateHarvester}.\n\n@author Emil Ivov\n@author Lyubomir Marinov\n@author Boris Grozev\n", "original_string": "public abstract class AbstractCandidateHarvester\n    implements CandidateHarvester\n{\n    /**\n     * Manages statistics about harvesting time.\n     */\n    private HarvestStatistics harvestStatistics = new HarvestStatistics();\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public HarvestStatistics getHarvestStatistics()\n    {\n        return harvestStatistics;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isHostHarvester()\n    {\n        return false;\n    }\n}", "super_interfaces": ["CandidateHarvester"], "fields": [{"attribute_expression": "private HarvestStatistics harvestStatistics = new HarvestStatistics();", "docstring": "\nManages statistics about harvesting time.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "HarvestStatistics", "name": "harvestStatistics = new HarvestStatistics()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener", "name": "AbstractUdpListener", "file_path": "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java", "superclasses": "", "methods": ["[List<TransportAddress>]getAllowedAddresses(int)", "[String]getUfrag(byte[],int,int)", "[]AbstractUdpListener(TransportAddress)", "[TransportAddress]getLocalAddress()", "[void]close()", "[void]runInHarvesterThread()", "[void]runInHarvesterThreadPush()", "[Buffer]bufferFromPacket(DatagramPacket,Instant)", "[MySocket]maybeAcceptNewSession(Buffer,InetSocketAddress,String)", "[Buffer]getFreeBuffer()", "[MySocket]addSocket(InetSocketAddress,String,BufferHandler)"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[List<TransportAddress>]getAllowedAddresses(int)", "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[String]getUfrag(byte[],int,int)", "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[]AbstractUdpListener(TransportAddress)", "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[TransportAddress]getLocalAddress()", "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[void]close()", "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[void]runInHarvesterThread()", "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[void]runInHarvesterThreadPush()", "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[Buffer]bufferFromPacket(DatagramPacket,Instant)", "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[MySocket]maybeAcceptNewSession(Buffer,InetSocketAddress,String)", "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[Buffer]getFreeBuffer()", "src/main/java/org/ice4j/ice/harvest/AbstractUdpListener.java.AbstractUdpListener.[MySocket]addSocket(InetSocketAddress,String,BufferHandler)"], "overrides": null, "attributes": [{"original_string": "    protected class MySocket\n            extends DatagramSocket\n    {\n        /**\n         * The size of {@link #queue}.\n         */\n        private static final int QUEUE_SIZE = 128;\n\n        /**\n         * The FIFO which acts as a buffer for this socket.\n         */\n        private final ArrayBlockingQueue<Buffer> queue = new ArrayBlockingQueue<>(QUEUE_SIZE);\n\n        /**\n         * The {@link QueueStatistics} instance optionally used to collect and\n         * print detailed statistics about {@link #queue}.\n         */\n        private final QueueStatistics queueStatistics;\n\n        /**\n         * The remote address that is associated with this socket.\n         */\n        private InetSocketAddress remoteAddress;\n\n        /**\n         * The flag which indicates that this <tt>DatagramSocket</tt> has been\n         * closed.\n         */\n        private boolean closed = false;\n\n        private final String ufrag;\n\n        @NotNull\n        private final BufferHandler bufferHandler;\n\n        /**\n         * Initializes a new <tt>MySocket</tt> instance with the given\n         * remote address.\n         * @param remoteAddress the remote address to be associated with the\n         * new instance.\n         * @throws SocketException\n         */\n        MySocket(InetSocketAddress remoteAddress, String ufrag, @NotNull BufferHandler bufferHandler)\n            throws SocketException\n        {\n            // unbound\n            super((SocketAddress)null);\n\n            this.ufrag = ufrag;\n            this.bufferHandler = bufferHandler;\n            this.remoteAddress = remoteAddress;\n            if (logger.isLoggable(Level.FINEST))\n            {\n                queueStatistics = new QueueStatistics(QUEUE_SIZE, Clock.systemUTC());\n            }\n            else\n            {\n                queueStatistics = null;\n            }\n        }\n\n        /**\n         * Adds pkt to this socket. If the queue is full, drops a packet. Does\n         * not block.\n         */\n        public void addBuffer(Buffer buf)\n        {\n            synchronized (queue)\n            {\n                // Drop the first rather than the current packet, so that\n                // receivers can notice the loss earlier.\n                if (queue.size() == QUEUE_SIZE)\n                {\n                    logger.info(\n                            \"Dropping a packet because the queue is full. Remote address = \"\n                                    + remoteAddress + \" ufrag=\" + ufrag);\n                    if (queueStatistics != null)\n                    {\n                        queueStatistics.dropped();\n                    }\n                    queue.poll();\n                }\n\n                queue.offer(buf);\n                if (queueStatistics != null)\n                {\n                    queueStatistics.added();\n                }\n\n                queue.notify();\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * Delegates to the actual socket of the harvester.\n         */\n        @Override\n        public InetAddress getLocalAddress()\n        {\n            return localAddress.getAddress();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * Delegates to the actual socket of the harvester.\n         */\n        @Override\n        public int getLocalPort()\n        {\n            return localAddress.getPort();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * Delegates to the actual socket of the harvester.\n         */\n        @Override\n        public SocketAddress getLocalSocketAddress()\n        {\n            return localAddress;\n        }\n\n        /**\n         * {@inheritDoc}\n         * </p>\n         * This {@link DatagramSocket} will only allow packets from the\n         * remote address that it has, so we consider it connected to this\n         * address.\n         */\n        @Override\n        public SocketAddress getRemoteSocketAddress()\n        {\n            return remoteAddress;\n        }\n\n        /**\n         * {@inheritDoc}\n         * </p>\n         * This {@link DatagramSocket} will only allow packets from the\n         * remote address that it has, so we consider it connected to this\n         * address.\n         */\n        @Override\n        public InetAddress getInetAddress()\n        {\n            return remoteAddress.getAddress();\n        }\n\n        /**\n         * {@inheritDoc}\n         * </p>\n         * This {@link DatagramSocket} will only allow packets from the\n         * remote address that it has, so we consider it connected to this\n         * address.\n         */\n        @Override\n        public int getPort()\n        {\n            return remoteAddress.getPort();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * Removes the association of the remote address with this socket from\n         * the harvester's map.\n         */\n        @Override\n        public void close()\n        {\n            synchronized (queue)\n            {\n                closed = true;\n\n                // Wake up any threads still in receive()\n                queue.notifyAll();\n            }\n\n            // We could be called by the super-class constructor, in which\n            // case this.removeAddress is not initialized yet.\n            if (remoteAddress != null)\n            {\n                AbstractUdpListener.this.sockets.remove(remoteAddress);\n            }\n\n            super.close();\n        }\n\n        /**\n         * Reads the data from the first element of {@link #queue} into\n         * <tt>p</tt>. Blocks until {@link #queue} has an element.\n         * @param p\n         * @throws IOException\n         */\n        @Override\n        public void receive(DatagramPacket p)\n           throws IOException\n        {\n            Buffer buf = null;\n\n            while (buf == null)\n            {\n                synchronized (queue)\n                {\n                    if (closed)\n                    {\n                        throw new SocketException(\"Socket closed\");\n                    }\n\n                    if (queue.isEmpty())\n                    {\n                        try\n                        {\n                            queue.wait();\n                        }\n                        catch (InterruptedException ie)\n                        {}\n                    }\n\n                    buf = queue.poll();\n                    if (buf != null && queueStatistics != null)\n                    {\n                        queueStatistics.removed(queue.size(), null);\n                    }\n                }\n            }\n\n            byte[] pData = p.getData();\n\n            if (pData == null || pData.length < buf.getLength())\n            {\n                throw new IOException(\"packet buffer not available\");\n            }\n\n            System.arraycopy(buf.getBuffer(), buf.getOffset(), pData, 0, buf.getLength());\n            p.setLength(buf.getLength());\n            p.setSocketAddress(remoteAddress);\n\n            // We use a different memory model with the push API.\n            if (USE_PUSH_API)\n            {\n                BufferPool.returnBuffer.invoke(buf);\n            }\n            else\n            {\n                pool.offer(buf);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * Delegates to the actual socket of the harvester.\n         */\n        @Override\n        public void send(DatagramPacket p)\n            throws IOException\n        {\n            p.setSocketAddress(remoteAddress);\n            socket.send(p);\n        }\n    }", "definition": "    protected class MySocket\n            extends DatagramSocket", "class_docstring": "\nImplements a <tt>DatagramSocket</tt> for the purposes of a specific\n<tt>MyCandidate</tt>.\n\nIt is not bound to a specific port, but shares the same local address\nas the bound socket held by the harvester.\n", "name": "MySocket", "super_interfaces": [], "superclasses": "DatagramSocket", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "fields": [{"attribute_expression": "private static final int QUEUE_SIZE = 128;", "docstring": "\nThe size of {@link #queue}.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "QUEUE_SIZE = 128", "syntax_pass": true}, {"attribute_expression": "private final ArrayBlockingQueue<Buffer> queue = new ArrayBlockingQueue<>(QUEUE_SIZE);", "docstring": "\nThe FIFO which acts as a buffer for this socket.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ArrayBlockingQueue<Buffer>", "name": "queue = new ArrayBlockingQueue<>(QUEUE_SIZE)", "syntax_pass": true}, {"attribute_expression": "private final QueueStatistics queueStatistics;", "docstring": "\nThe {@link QueueStatistics} instance optionally used to collect and\nprint detailed statistics about {@link #queue}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "QueueStatistics", "name": "queueStatistics", "syntax_pass": true}, {"attribute_expression": "private InetSocketAddress remoteAddress;", "docstring": "\nThe remote address that is associated with this socket.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "InetSocketAddress", "name": "remoteAddress", "syntax_pass": true}, {"attribute_expression": "private boolean closed = false;", "docstring": "\nThe flag which indicates that this <tt>DatagramSocket</tt> has been\nclosed.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "closed = false", "syntax_pass": true}, {"attribute_expression": "private final String ufrag;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "ufrag", "syntax_pass": true}, {"attribute_expression": "@NotNull\n        private final BufferHandler bufferHandler;", "docstring": "", "modifiers": "@NotNull\n        private final", "marker_annotations": ["@NotNull"], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BufferHandler", "name": "bufferHandler", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        MySocket(InetSocketAddress remoteAddress, String ufrag, @NotNull BufferHandler bufferHandler)\n            throws SocketException\n        {\n            // unbound\n            super((SocketAddress)null);\n\n            this.ufrag = ufrag;\n            this.bufferHandler = bufferHandler;\n            this.remoteAddress = remoteAddress;\n            if (logger.isLoggable(Level.FINEST))\n            {\n                queueStatistics = new QueueStatistics(QUEUE_SIZE, Clock.systemUTC());\n            }\n            else\n            {\n                queueStatistics = null;\n            }\n        }", "docstring": "\nInitializes a new <tt>MySocket</tt> instance with the given\nremote address.\n@param remoteAddress the remote address to be associated with the\nnew instance.\n@throws SocketException\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MySocket", "params": [{"name": "remoteAddress", "type": "InetSocketAddress"}, {"name": "ufrag", "type": "String"}, {"name": "bufferHandler", "type": "BufferHandler"}], "body": "        {\n            // unbound\n            super((SocketAddress)null);\n\n            this.ufrag = ufrag;\n            this.bufferHandler = bufferHandler;\n            this.remoteAddress = remoteAddress;\n            if (logger.isLoggable(Level.FINEST))\n            {\n                queueStatistics = new QueueStatistics(QUEUE_SIZE, Clock.systemUTC());\n            }\n            else\n            {\n                queueStatistics = null;\n            }\n        }", "signature": "MySocket(InetSocketAddress remoteAddress, String ufrag, @NotNull BufferHandler bufferHandler)"}, {"syntax_pass": true, "original_string": "        public void addBuffer(Buffer buf)\n        {\n            synchronized (queue)\n            {\n                // Drop the first rather than the current packet, so that\n                // receivers can notice the loss earlier.\n                if (queue.size() == QUEUE_SIZE)\n                {\n                    logger.info(\n                            \"Dropping a packet because the queue is full. Remote address = \"\n                                    + remoteAddress + \" ufrag=\" + ufrag);\n                    if (queueStatistics != null)\n                    {\n                        queueStatistics.dropped();\n                    }\n                    queue.poll();\n                }\n\n                queue.offer(buf);\n                if (queueStatistics != null)\n                {\n                    queueStatistics.added();\n                }\n\n                queue.notify();\n            }\n        }", "docstring": "\nAdds pkt to this socket. If the queue is full, drops a packet. Does\nnot block.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "addBuffer", "params": [{"name": "buf", "type": "Buffer"}], "body": "        {\n            synchronized (queue)\n            {\n                // Drop the first rather than the current packet, so that\n                // receivers can notice the loss earlier.\n                if (queue.size() == QUEUE_SIZE)\n                {\n                    logger.info(\n                            \"Dropping a packet because the queue is full. Remote address = \"\n                                    + remoteAddress + \" ufrag=\" + ufrag);\n                    if (queueStatistics != null)\n                    {\n                        queueStatistics.dropped();\n                    }\n                    queue.poll();\n                }\n\n                queue.offer(buf);\n                if (queueStatistics != null)\n                {\n                    queueStatistics.added();\n                }\n\n                queue.notify();\n            }\n        }", "signature": "public void addBuffer(Buffer buf)"}, {"syntax_pass": true, "original_string": "        @Override\n        public InetAddress getLocalAddress()\n        {\n            return localAddress.getAddress();\n        }", "docstring": "\n{@inheritDoc}\n\nDelegates to the actual socket of the harvester.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetAddress", "classes": []}, "name": "getLocalAddress", "params": [], "body": "        {\n            return localAddress.getAddress();\n        }", "signature": "@Override\n        public InetAddress getLocalAddress()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int getLocalPort()\n        {\n            return localAddress.getPort();\n        }", "docstring": "\n{@inheritDoc}\n\nDelegates to the actual socket of the harvester.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getLocalPort", "params": [], "body": "        {\n            return localAddress.getPort();\n        }", "signature": "@Override\n        public int getLocalPort()"}, {"syntax_pass": true, "original_string": "        @Override\n        public SocketAddress getLocalSocketAddress()\n        {\n            return localAddress;\n        }", "docstring": "\n{@inheritDoc}\n\nDelegates to the actual socket of the harvester.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "name": "getLocalSocketAddress", "params": [], "body": "        {\n            return localAddress;\n        }", "signature": "@Override\n        public SocketAddress getLocalSocketAddress()"}, {"syntax_pass": true, "original_string": "        @Override\n        public SocketAddress getRemoteSocketAddress()\n        {\n            return remoteAddress;\n        }", "docstring": "\n{@inheritDoc}\n</p>\nThis {@link DatagramSocket} will only allow packets from the\nremote address that it has, so we consider it connected to this\naddress.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "name": "getRemoteSocketAddress", "params": [], "body": "        {\n            return remoteAddress;\n        }", "signature": "@Override\n        public SocketAddress getRemoteSocketAddress()"}, {"syntax_pass": true, "original_string": "        @Override\n        public InetAddress getInetAddress()\n        {\n            return remoteAddress.getAddress();\n        }", "docstring": "\n{@inheritDoc}\n</p>\nThis {@link DatagramSocket} will only allow packets from the\nremote address that it has, so we consider it connected to this\naddress.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetAddress", "classes": []}, "name": "getInetAddress", "params": [], "body": "        {\n            return remoteAddress.getAddress();\n        }", "signature": "@Override\n        public InetAddress getInetAddress()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int getPort()\n        {\n            return remoteAddress.getPort();\n        }", "docstring": "\n{@inheritDoc}\n</p>\nThis {@link DatagramSocket} will only allow packets from the\nremote address that it has, so we consider it connected to this\naddress.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getPort", "params": [], "body": "        {\n            return remoteAddress.getPort();\n        }", "signature": "@Override\n        public int getPort()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void close()\n        {\n            synchronized (queue)\n            {\n                closed = true;\n\n                // Wake up any threads still in receive()\n                queue.notifyAll();\n            }\n\n            // We could be called by the super-class constructor, in which\n            // case this.removeAddress is not initialized yet.\n            if (remoteAddress != null)\n            {\n                AbstractUdpListener.this.sockets.remove(remoteAddress);\n            }\n\n            super.close();\n        }", "docstring": "\n{@inheritDoc}\n\nRemoves the association of the remote address with this socket from\nthe harvester's map.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "close", "params": [], "body": "        {\n            synchronized (queue)\n            {\n                closed = true;\n\n                // Wake up any threads still in receive()\n                queue.notifyAll();\n            }\n\n            // We could be called by the super-class constructor, in which\n            // case this.removeAddress is not initialized yet.\n            if (remoteAddress != null)\n            {\n                AbstractUdpListener.this.sockets.remove(remoteAddress);\n            }\n\n            super.close();\n        }", "signature": "@Override\n        public void close()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void receive(DatagramPacket p)\n           throws IOException\n        {\n            Buffer buf = null;\n\n            while (buf == null)\n            {\n                synchronized (queue)\n                {\n                    if (closed)\n                    {\n                        throw new SocketException(\"Socket closed\");\n                    }\n\n                    if (queue.isEmpty())\n                    {\n                        try\n                        {\n                            queue.wait();\n                        }\n                        catch (InterruptedException ie)\n                        {}\n                    }\n\n                    buf = queue.poll();\n                    if (buf != null && queueStatistics != null)\n                    {\n                        queueStatistics.removed(queue.size(), null);\n                    }\n                }\n            }\n\n            byte[] pData = p.getData();\n\n            if (pData == null || pData.length < buf.getLength())\n            {\n                throw new IOException(\"packet buffer not available\");\n            }\n\n            System.arraycopy(buf.getBuffer(), buf.getOffset(), pData, 0, buf.getLength());\n            p.setLength(buf.getLength());\n            p.setSocketAddress(remoteAddress);\n\n            // We use a different memory model with the push API.\n            if (USE_PUSH_API)\n            {\n                BufferPool.returnBuffer.invoke(buf);\n            }\n            else\n            {\n                pool.offer(buf);\n            }\n        }", "docstring": "\nReads the data from the first element of {@link #queue} into\n<tt>p</tt>. Blocks until {@link #queue} has an element.\n@param p\n@throws IOException\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "receive", "params": [{"name": "p", "type": "DatagramPacket"}], "body": "        {\n            Buffer buf = null;\n\n            while (buf == null)\n            {\n                synchronized (queue)\n                {\n                    if (closed)\n                    {\n                        throw new SocketException(\"Socket closed\");\n                    }\n\n                    if (queue.isEmpty())\n                    {\n                        try\n                        {\n                            queue.wait();\n                        }\n                        catch (InterruptedException ie)\n                        {}\n                    }\n\n                    buf = queue.poll();\n                    if (buf != null && queueStatistics != null)\n                    {\n                        queueStatistics.removed(queue.size(), null);\n                    }\n                }\n            }\n\n            byte[] pData = p.getData();\n\n            if (pData == null || pData.length < buf.getLength())\n            {\n                throw new IOException(\"packet buffer not available\");\n            }\n\n            System.arraycopy(buf.getBuffer(), buf.getOffset(), pData, 0, buf.getLength());\n            p.setLength(buf.getLength());\n            p.setSocketAddress(remoteAddress);\n\n            // We use a different memory model with the push API.\n            if (USE_PUSH_API)\n            {\n                BufferPool.returnBuffer.invoke(buf);\n            }\n            else\n            {\n                pool.offer(buf);\n            }\n        }", "signature": "@Override\n        public void receive(DatagramPacket p)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void send(DatagramPacket p)\n            throws IOException\n        {\n            p.setSocketAddress(remoteAddress);\n            socket.send(p);\n        }", "docstring": "\n{@inheritDoc}\n\nDelegates to the actual socket of the harvester.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "send", "params": [{"name": "p", "type": "DatagramPacket"}], "body": "        {\n            p.setSocketAddress(remoteAddress);\n            socket.send(p);\n        }", "signature": "@Override\n        public void send(DatagramPacket p)"}]}], "class_docstring": "\nA class which holds a {@link DatagramSocket} and runs a thread\n({@link #thread}) which perpetually reads from it.\n\nWhen a datagram from an unknown source is received, it is parsed as a STUN\nBinding Request, and if it has a USERNAME attribute, its ufrag is extracted.\nAt this point, an implementing class may choose to create a mapping for\nthe remote address of the datagram, which will be used for further packets\nfrom this address.\n\n@author Boris Grozev\n", "original_string": "public abstract class AbstractUdpListener\n{\n    /**\n     * Our class logger.\n     */\n    private static final Logger logger\n            = Logger.getLogger(AbstractUdpListener.class.getName());\n\n    /**\n     * The size for newly allocated <tt>Buffer</tt> instances. This limits the\n     * maximum size of datagrams we can receive.\n     *\n     * XXX should we increase this in case of other MTUs, or set it dynamically\n     * according to the available network interfaces?\n     */\n    private static final int BUFFER_SIZE\n        = /* assumed MTU */ 1500 - /* IPv4 header */ 20 - /* UDP header */ 8;\n\n    /**\n     * The number of <tt>Buffer</tt> instances to keep in {@link #pool}.\n     */\n    private static final int POOL_SIZE = 256;\n\n    /**\n     * Number of extra bytes to leave at the start of a buffer (only when the push API is used).\n     */\n    public static int BYTES_TO_LEAVE_AT_START_OF_PACKET = 0;\n\n    /**\n     * Number of extra bytes to leave at the end of a buffer (only when the push API is used).\n     */\n    public static int BYTES_TO_LEAVE_AT_END_OF_PACKET = 0;\n\n    /**\n     * Whether to enable the push API. With the push API packets carrying payload are pushed to the application\n     * instead of being made available through a DatagramSocket API. See push-api.md.\n     */\n\n    public static boolean USE_PUSH_API = false;\n\n    /**\n     * Returns the list of {@link TransportAddress}es, one for each allowed IP\n     * address found on each allowed network interface, with the given port.\n     *\n     * @param port the UDP port number.\n     * @return the list of allowed transport addresses.\n     */\n    public static List<TransportAddress> getAllowedAddresses(int port)\n    {\n        List<TransportAddress> addresses = new LinkedList<>();\n        for (InetAddress address : HostCandidateHarvester.getAllAllowedAddresses())\n        {\n            addresses.add(new TransportAddress(address, port, Transport.UDP));\n        }\n\n        return addresses;\n    }\n\n    /**\n     * Tries to parse the bytes in <tt>buf</tt> at offset <tt>off</tt> (and\n     * length <tt>len</tt>) as a STUN Binding Request message. If successful,\n     * looks for a USERNAME attribute and returns the local username fragment\n     * part (see RFC5245 Section 7.1.2.3).\n     * In case of any failure returns <tt>null</tt>.\n     *\n     * @param buf the bytes.\n     * @param off the offset.\n     * @param len the length.\n     * @return the local ufrag from the USERNAME attribute of the STUN message\n     * contained in <tt>buf</tt>, or <tt>null</tt>.\n     */\n    static String getUfrag(byte[] buf, int off, int len)\n    {\n        // RFC5389, Section 6:\n        // All STUN messages MUST start with a 20-byte header followed by zero\n        // or more Attributes.\n        if (buf == null || buf.length < off + len || len < 20)\n        {\n            return null;\n        }\n\n        // RFC5389, Section 6:\n        // The magic cookie field MUST contain the fixed value 0x2112A442 in\n        // network byte order.\n        if ( !( (buf[off + 4] & 0xFF) == 0x21 &&\n            (buf[off + 5] & 0xFF) == 0x12 &&\n            (buf[off + 6] & 0xFF) == 0xA4 &&\n            (buf[off + 7] & 0xFF) == 0x42))\n        {\n            if (logger.isLoggable(Level.FINE))\n            {\n                logger.fine(\"Not a STUN packet, magic cookie not found.\");\n            }\n            return null;\n        }\n\n        try\n        {\n            Message stunMessage = Message.decode(buf, off, len);\n\n            if (stunMessage.getMessageType()\n                != Message.BINDING_REQUEST)\n            {\n                return null;\n            }\n\n            UsernameAttribute usernameAttribute\n                = (UsernameAttribute)\n                stunMessage.getAttribute(Attribute.USERNAME);\n            if (usernameAttribute == null)\n                return null;\n\n            String usernameString\n                = new String(usernameAttribute.getUsername());\n            return usernameString.split(\":\")[0];\n        }\n        catch (Exception e)\n        {\n            // Catch everything. We are going to log, and then drop the packet\n            // anyway.\n            if (logger.isLoggable(Level.FINE))\n            {\n                logger.fine(\"Failed to extract local ufrag: \" + e);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * The map which keeps the known remote addresses and their associated\n     * candidateSockets.\n     * {@link #thread} is the only thread which adds new entries, while\n     * other threads remove entries when candidates are freed.\n     */\n    private final Map<SocketAddress, MySocket> sockets = new ConcurrentHashMap<>();\n\n    /**\n     * A pool of <tt>Buffer</tt> instances used to avoid creating of new java\n     * objects.\n     */\n    private final ArrayBlockingQueue<Buffer> pool = new ArrayBlockingQueue<>(POOL_SIZE);\n\n    /**\n     * The local address that this harvester is bound to.\n     */\n    protected final TransportAddress localAddress;\n\n    /**\n     * The \"main\" socket that this harvester reads from.\n     */\n    private final DatagramSocket socket;\n\n    /**\n     * The thread reading from {@link #socket}.\n     */\n    private final Thread thread;\n\n    /**\n     * Triggers the termination of the threads of this instance.\n     */\n    private boolean close = false;\n\n    /**\n     * Initializes a new <tt>SinglePortUdpHarvester</tt> instance which is to\n     * bind on the specified local address.\n     * @param localAddress the address to bind to. If the port is 0 an ephemeral port will be chosen by the OS and the\n     *                     AbstractUdpListener.localAddress will reflect the allocated port.\n     * @throws IOException if initialization fails.\n     */\n    protected AbstractUdpListener(TransportAddress localAddress)\n        throws IOException\n    {\n        TransportAddress tempAddress = localAddress;\n\n        boolean bindWildcard = StackProperties.getBoolean(\n                StackProperties.BIND_WILDCARD,\n                false);\n\n        if (bindWildcard)\n        {\n            tempAddress = new TransportAddress(\n                                        (InetAddress) null,\n                                        localAddress.getPort(),\n                                        localAddress.getTransport()\n                                );\n        }\n\n        socket = new DatagramSocket( tempAddress );\n\n        Integer receiveBufferSize = config.udpReceiveBufferSize();\n        if (receiveBufferSize != null)\n        {\n            socket.setReceiveBufferSize(receiveBufferSize);\n        }\n\n        /* Update the port number if needed. */\n        if (localAddress.getPort() == 0)\n        {\n            tempAddress = new TransportAddress(\n                    tempAddress.getAddress(),\n                    socket.getLocalPort(),\n                    tempAddress.getTransport()\n            );\n        }\n        this.localAddress = tempAddress;\n\n        String logMessage\n            = \"Initialized AbstractUdpListener with address \" + this.localAddress;\n        logMessage += \". Receive buffer size \" + socket.getReceiveBufferSize();\n        if (receiveBufferSize != null)\n        {\n            logMessage += \" (asked for \" + receiveBufferSize + \")\";\n        }\n        logger.info(logMessage);\n\n        thread = new Thread(() ->\n        {\n            if (USE_PUSH_API)\n            {\n                AbstractUdpListener.this.runInHarvesterThreadPush();\n            }\n            else\n            {\n                AbstractUdpListener.this.runInHarvesterThread();\n            }\n        });\n\n        thread.setName(AbstractUdpListener.class.getName() + \" thread for \" + this.localAddress);\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    public TransportAddress getLocalAddress()\n    {\n        return localAddress;\n    }\n\n    /**\n     * Triggers the termination of the threads of this instance.\n     */\n    public void close()\n    {\n        close = true;\n        socket.close(); // causes socket#receive to stop blocking.\n    }\n\n    /**\n     * Perpetually reads datagrams from {@link #socket} and handles them\n     * accordingly.\n     *\n     * It is important that this blocks are little as possible (except on\n     * socket.receive(), of course),  because it could potentially delay the\n     * reception of both ICE and media packets for the whole application.\n     */\n    private void runInHarvesterThread()\n    {\n        Buffer buf;\n        DatagramPacket pkt = null;\n        MySocket destinationSocket;\n        InetSocketAddress remoteAddress;\n\n        do\n        {\n            if (close)\n            {\n                break;\n            }\n\n            buf = getFreeBuffer();\n\n            if (pkt == null)\n                pkt = new DatagramPacket(buf.getBuffer(), 0, buf.getBuffer().length);\n            else\n                pkt.setData(buf.getBuffer(), 0, buf.getBuffer().length);\n\n            try\n            {\n                socket.receive(pkt);\n            }\n            catch (IOException ioe)\n            {\n                if (!close)\n                {\n                    logger.severe(\"Failed to receive from socket: \" + ioe);\n                }\n                break;\n            }\n            buf.setOffset(pkt.getOffset());\n            buf.setLength(pkt.getLength());\n\n\n            remoteAddress = (InetSocketAddress) pkt.getSocketAddress();\n            destinationSocket = sockets.get(remoteAddress);\n            if (destinationSocket != null)\n            {\n                //make 'pkt' available for reading through destinationSocket\n                destinationSocket.addBuffer(buf);\n            }\n            else\n            {\n                // Packet from an unknown source. Is it a STUN Binding Request?\n                String ufrag = getUfrag(buf.getBuffer(), buf.getOffset(), buf.getLength());\n                if (ufrag == null)\n                {\n                    // Not a STUN Binding Request or doesn't have a valid\n                    // USERNAME attribute. Drop it.\n                    continue;\n                }\n\n                MySocket newSocket = maybeAcceptNewSession(buf, remoteAddress, ufrag);\n                if (newSocket == null)\n                {\n                    pool.offer(buf);\n                }\n                else\n                {\n                    newSocket.addBuffer(buf);\n                }\n            }\n        }\n        while (true);\n\n        // now clean up and exit\n        for (MySocket candidateSocket : new ArrayList<>(sockets.values()))\n        {\n            candidateSocket.close();\n        }\n        socket.close();\n    }\n\n    /**\n     * Read packets from the socket and forward them via the push API. Note that the memory model here is different\n     * than the other case. Specifically, we:\n     * 1. Receive from {@link #socket} into a fixed buffer\n     * 2. Obtain a buffer of the required size using {@link BufferPool#getBuffer}\n     * 3. Copy the data into the buffer and either\n     * 3.1 Call the associated {@link BufferHandler} if the packet is payload\n     * 3.2 Make the packet available to the STUN socket if it's STUN\n     *\n     * The only difference in the STUN case is that we take responsibility to return the buffer using\n     * {@link BufferPool#returnBuffer} afterwards.\n     */\n    private void runInHarvesterThreadPush()\n    {\n        DatagramPacket pkt = new DatagramPacket(new byte[1500], 0, 1500);\n        MySocket destinationSocket;\n        InetSocketAddress remoteAddress;\n        Clock clock = Clock.systemUTC();\n        Instant receivedTime;\n\n        do\n        {\n            if (close)\n            {\n                break;\n            }\n\n            pkt.setData(pkt.getData(), 0, pkt.getData().length);\n\n            try\n            {\n                socket.receive(pkt);\n                receivedTime = clock.instant();\n            }\n            catch (IOException ioe)\n            {\n                if (!close)\n                {\n                    logger.severe(\"Failed to receive from socket: \" + ioe);\n                }\n                break;\n            }\n\n            remoteAddress = (InetSocketAddress) pkt.getSocketAddress();\n            destinationSocket = sockets.get(remoteAddress);\n            if (destinationSocket == null)\n            {\n                // Packet from an unknown source. Is it a STUN Binding Request?\n                String ufrag = getUfrag(pkt.getData(), pkt.getOffset(), pkt.getLength());\n                if (ufrag == null)\n                {\n                    // Not a STUN Binding Request or doesn't have a valid USERNAME attribute. Drop it.\n                    continue;\n                }\n\n                Buffer buffer = bufferFromPacket(pkt, receivedTime);\n                MySocket newSocket = maybeAcceptNewSession(buffer, remoteAddress, ufrag);\n                if (newSocket == null)\n                {\n                    BufferPool.returnBuffer.invoke(buffer);\n                }\n                else\n                {\n                    newSocket.addBuffer(buffer);\n                }\n            }\n            else\n            {\n                Buffer buf = bufferFromPacket(pkt, receivedTime);\n                if (StunDatagramPacketFilter.isStunPacket(pkt))\n                {\n                    // STUN packets are made available to the DatagramSocket-based API used by ice4j internally.\n                    destinationSocket.addBuffer(buf);\n                }\n                else\n                {\n                    // Payload goes through the push API.\n                    destinationSocket.bufferHandler.handleBuffer(buf);\n                }\n            }\n        }\n        while (true);\n\n        // now clean up and exit\n        for (MySocket candidateSocket : new ArrayList<>(sockets.values()))\n        {\n            candidateSocket.close();\n        }\n        socket.close();\n    }\n\n    private Buffer bufferFromPacket(DatagramPacket p, Instant receivedTime)\n    {\n        int off = BYTES_TO_LEAVE_AT_START_OF_PACKET;\n        Buffer buffer = BufferPool.getBuffer.invoke(off + p.getLength() + BYTES_TO_LEAVE_AT_END_OF_PACKET);\n\n        System.arraycopy(p.getData(), p.getOffset(), buffer.getBuffer(), off, p.getLength());\n        buffer.setOffset(off);\n        buffer.setLength(p.getLength());\n        buffer.setLocalAddress(socket.getLocalSocketAddress());\n        buffer.setRemoteAddress(p.getSocketAddress());\n        buffer.setReceivedTime(receivedTime);\n\n        return buffer;\n    }\n\n    /**\n     * Handles the reception of a STUN Binding Request with a valid USERNAME\n     * attribute, from a \"new\" remote address (one which is not in\n     * {@link #sockets}).\n     * Implementations may choose to e.g. create a socket and pass it to their\n     * ICE stack.\n     *\n     * Note that this is meant to only be executed by\n     * {@link AbstractUdpListener}'s read thread, and should not be called from\n     * implementing classes.\n     *\n     * @param buf the UDP payload of the first datagram received on the newly\n     * accepted socket.\n     * @param remoteAddress the remote address from which the datagram was\n     * received.\n     * @param ufrag the local ICE username fragment of the received STUN Binding\n     * Request.\n     */\n    protected abstract MySocket maybeAcceptNewSession(\n            Buffer buf,\n            InetSocketAddress remoteAddress,\n            String ufrag);\n\n    /**\n     * Gets an unused <tt>Buffer</tt> instance, creating it if necessary.\n     * @return  an unused <tt>Buffer</tt> instance, creating it if necessary.\n     */\n    private Buffer getFreeBuffer()\n    {\n        Buffer buf = pool.poll();\n        if (buf == null)\n        {\n            buf = new Buffer(new byte[BUFFER_SIZE], 0, 0);\n        }\n\n        return buf;\n    }\n\n    /**\n     * Creates a new {@link MySocket} instance and associates it with the given\n     * remote address. Returns the created instance.\n     *\n     * Note that this is meant to only execute in {@link AbstractUdpListener}'s\n     * read thread.\n     *\n     * @param remoteAddress the remote address with which to associate the new\n     * socket instance.\n     * @param ufrag The username fragment associated with the socket.\n     * @param bufferHandler The handler to call when the push API is used.\n     * @return the created socket instance.\n     */\n    protected MySocket addSocket(InetSocketAddress remoteAddress, String ufrag, @NotNull BufferHandler bufferHandler)\n        throws SocketException\n    {\n        MySocket newSocket = new MySocket(remoteAddress, ufrag, bufferHandler);\n        sockets.put(remoteAddress, newSocket);\n        return newSocket;\n    }\n\n\n    /**\n     * Implements a <tt>DatagramSocket</tt> for the purposes of a specific\n     * <tt>MyCandidate</tt>.\n     *\n     * It is not bound to a specific port, but shares the same local address\n     * as the bound socket held by the harvester.\n     */\n    protected class MySocket\n            extends DatagramSocket\n    {\n        /**\n         * The size of {@link #queue}.\n         */\n        private static final int QUEUE_SIZE = 128;\n\n        /**\n         * The FIFO which acts as a buffer for this socket.\n         */\n        private final ArrayBlockingQueue<Buffer> queue = new ArrayBlockingQueue<>(QUEUE_SIZE);\n\n        /**\n         * The {@link QueueStatistics} instance optionally used to collect and\n         * print detailed statistics about {@link #queue}.\n         */\n        private final QueueStatistics queueStatistics;\n\n        /**\n         * The remote address that is associated with this socket.\n         */\n        private InetSocketAddress remoteAddress;\n\n        /**\n         * The flag which indicates that this <tt>DatagramSocket</tt> has been\n         * closed.\n         */\n        private boolean closed = false;\n\n        private final String ufrag;\n\n        @NotNull\n        private final BufferHandler bufferHandler;\n\n        /**\n         * Initializes a new <tt>MySocket</tt> instance with the given\n         * remote address.\n         * @param remoteAddress the remote address to be associated with the\n         * new instance.\n         * @throws SocketException\n         */\n        MySocket(InetSocketAddress remoteAddress, String ufrag, @NotNull BufferHandler bufferHandler)\n            throws SocketException\n        {\n            // unbound\n            super((SocketAddress)null);\n\n            this.ufrag = ufrag;\n            this.bufferHandler = bufferHandler;\n            this.remoteAddress = remoteAddress;\n            if (logger.isLoggable(Level.FINEST))\n            {\n                queueStatistics = new QueueStatistics(QUEUE_SIZE, Clock.systemUTC());\n            }\n            else\n            {\n                queueStatistics = null;\n            }\n        }\n\n        /**\n         * Adds pkt to this socket. If the queue is full, drops a packet. Does\n         * not block.\n         */\n        public void addBuffer(Buffer buf)\n        {\n            synchronized (queue)\n            {\n                // Drop the first rather than the current packet, so that\n                // receivers can notice the loss earlier.\n                if (queue.size() == QUEUE_SIZE)\n                {\n                    logger.info(\n                            \"Dropping a packet because the queue is full. Remote address = \"\n                                    + remoteAddress + \" ufrag=\" + ufrag);\n                    if (queueStatistics != null)\n                    {\n                        queueStatistics.dropped();\n                    }\n                    queue.poll();\n                }\n\n                queue.offer(buf);\n                if (queueStatistics != null)\n                {\n                    queueStatistics.added();\n                }\n\n                queue.notify();\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * Delegates to the actual socket of the harvester.\n         */\n        @Override\n        public InetAddress getLocalAddress()\n        {\n            return localAddress.getAddress();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * Delegates to the actual socket of the harvester.\n         */\n        @Override\n        public int getLocalPort()\n        {\n            return localAddress.getPort();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * Delegates to the actual socket of the harvester.\n         */\n        @Override\n        public SocketAddress getLocalSocketAddress()\n        {\n            return localAddress;\n        }\n\n        /**\n         * {@inheritDoc}\n         * </p>\n         * This {@link DatagramSocket} will only allow packets from the\n         * remote address that it has, so we consider it connected to this\n         * address.\n         */\n        @Override\n        public SocketAddress getRemoteSocketAddress()\n        {\n            return remoteAddress;\n        }\n\n        /**\n         * {@inheritDoc}\n         * </p>\n         * This {@link DatagramSocket} will only allow packets from the\n         * remote address that it has, so we consider it connected to this\n         * address.\n         */\n        @Override\n        public InetAddress getInetAddress()\n        {\n            return remoteAddress.getAddress();\n        }\n\n        /**\n         * {@inheritDoc}\n         * </p>\n         * This {@link DatagramSocket} will only allow packets from the\n         * remote address that it has, so we consider it connected to this\n         * address.\n         */\n        @Override\n        public int getPort()\n        {\n            return remoteAddress.getPort();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * Removes the association of the remote address with this socket from\n         * the harvester's map.\n         */\n        @Override\n        public void close()\n        {\n            synchronized (queue)\n            {\n                closed = true;\n\n                // Wake up any threads still in receive()\n                queue.notifyAll();\n            }\n\n            // We could be called by the super-class constructor, in which\n            // case this.removeAddress is not initialized yet.\n            if (remoteAddress != null)\n            {\n                AbstractUdpListener.this.sockets.remove(remoteAddress);\n            }\n\n            super.close();\n        }\n\n        /**\n         * Reads the data from the first element of {@link #queue} into\n         * <tt>p</tt>. Blocks until {@link #queue} has an element.\n         * @param p\n         * @throws IOException\n         */\n        @Override\n        public void receive(DatagramPacket p)\n           throws IOException\n        {\n            Buffer buf = null;\n\n            while (buf == null)\n            {\n                synchronized (queue)\n                {\n                    if (closed)\n                    {\n                        throw new SocketException(\"Socket closed\");\n                    }\n\n                    if (queue.isEmpty())\n                    {\n                        try\n                        {\n                            queue.wait();\n                        }\n                        catch (InterruptedException ie)\n                        {}\n                    }\n\n                    buf = queue.poll();\n                    if (buf != null && queueStatistics != null)\n                    {\n                        queueStatistics.removed(queue.size(), null);\n                    }\n                }\n            }\n\n            byte[] pData = p.getData();\n\n            if (pData == null || pData.length < buf.getLength())\n            {\n                throw new IOException(\"packet buffer not available\");\n            }\n\n            System.arraycopy(buf.getBuffer(), buf.getOffset(), pData, 0, buf.getLength());\n            p.setLength(buf.getLength());\n            p.setSocketAddress(remoteAddress);\n\n            // We use a different memory model with the push API.\n            if (USE_PUSH_API)\n            {\n                BufferPool.returnBuffer.invoke(buf);\n            }\n            else\n            {\n                pool.offer(buf);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * Delegates to the actual socket of the harvester.\n         */\n        @Override\n        public void send(DatagramPacket p)\n            throws IOException\n        {\n            p.setSocketAddress(remoteAddress);\n            socket.send(p);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n            = Logger.getLogger(AbstractUdpListener.class.getName());", "docstring": "\nOur class logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n            = Logger.getLogger(AbstractUdpListener.class.getName())", "syntax_pass": true}, {"attribute_expression": "private static final int BUFFER_SIZE\n        = /* assumed MTU */ 1500 - /* IPv4 header */ 20 - /* UDP header */ 8;", "docstring": "\nThe size for newly allocated <tt>Buffer</tt> instances. This limits the\nmaximum size of datagrams we can receive.\n\nXXX should we increase this in case of other MTUs, or set it dynamically\naccording to the available network interfaces?\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "BUFFER_SIZE\n        = /* assumed MTU */ 1500 - /* IPv4 header */ 20 - /* UDP header */ 8", "syntax_pass": true}, {"attribute_expression": "private static final int POOL_SIZE = 256;", "docstring": "\nThe number of <tt>Buffer</tt> instances to keep in {@link #pool}.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "POOL_SIZE = 256", "syntax_pass": true}, {"attribute_expression": "public static int BYTES_TO_LEAVE_AT_START_OF_PACKET = 0;", "docstring": "\nNumber of extra bytes to leave at the start of a buffer (only when the push API is used).\n", "modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "type": "int", "name": "BYTES_TO_LEAVE_AT_START_OF_PACKET = 0", "syntax_pass": true}, {"attribute_expression": "public static int BYTES_TO_LEAVE_AT_END_OF_PACKET = 0;", "docstring": "\nNumber of extra bytes to leave at the end of a buffer (only when the push API is used).\n", "modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "type": "int", "name": "BYTES_TO_LEAVE_AT_END_OF_PACKET = 0", "syntax_pass": true}, {"attribute_expression": "public static boolean USE_PUSH_API = false;", "docstring": "\nWhether to enable the push API. With the push API packets carrying payload are pushed to the application\ninstead of being made available through a DatagramSocket API. See push-api.md.\n", "modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "type": "boolean", "name": "USE_PUSH_API = false", "syntax_pass": true}, {"attribute_expression": "private final Map<SocketAddress, MySocket> sockets = new ConcurrentHashMap<>();", "docstring": "\nThe map which keeps the known remote addresses and their associated\ncandidateSockets.\n{@link #thread} is the only thread which adds new entries, while\nother threads remove entries when candidates are freed.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<SocketAddress, MySocket>", "name": "sockets = new ConcurrentHashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final ArrayBlockingQueue<Buffer> pool = new ArrayBlockingQueue<>(POOL_SIZE);", "docstring": "\nA pool of <tt>Buffer</tt> instances used to avoid creating of new java\nobjects.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ArrayBlockingQueue<Buffer>", "name": "pool = new ArrayBlockingQueue<>(POOL_SIZE)", "syntax_pass": true}, {"attribute_expression": "protected final TransportAddress localAddress;", "docstring": "\nThe local address that this harvester is bound to.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "TransportAddress", "name": "localAddress", "syntax_pass": true}, {"attribute_expression": "private final DatagramSocket socket;", "docstring": "\nThe \"main\" socket that this harvester reads from.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DatagramSocket", "name": "socket", "syntax_pass": true}, {"attribute_expression": "private final Thread thread;", "docstring": "\nThe thread reading from {@link #socket}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Thread", "name": "thread", "syntax_pass": true}, {"attribute_expression": "private boolean close = false;", "docstring": "\nTriggers the termination of the threads of this instance.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "close = false", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener", "name": "AbstractTcpListener", "file_path": "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java", "superclasses": "", "methods": ["[void]closeNoExceptions(Channel)", "[List<TransportAddress>]getLocalAddresses(int,List<NetworkInterface>)", "[]AbstractTcpListener(int)", "[]AbstractTcpListener(int,List<NetworkInterface>)", "[]AbstractTcpListener(List<TransportAddress>)", "[void]addLocalAddresses(List<TransportAddress>)", "[void]close()", "[void]init()", "[void]addSocketChannel(InetSocketAddress)", "[void]acceptSession(Socket,String,DatagramPacket)"], "method_uris": ["src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[void]closeNoExceptions(Channel)", "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[List<TransportAddress>]getLocalAddresses(int,List<NetworkInterface>)", "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[]AbstractTcpListener(int)", "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[]AbstractTcpListener(int,List<NetworkInterface>)", "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[]AbstractTcpListener(List<TransportAddress>)", "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[void]addLocalAddresses(List<TransportAddress>)", "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[void]close()", "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[void]init()", "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[void]addSocketChannel(InetSocketAddress)", "src/main/java/org/ice4j/ice/harvest/AbstractTcpListener.java.AbstractTcpListener.[void]acceptSession(Socket,String,DatagramPacket)"], "overrides": null, "attributes": [{"original_string": "    private class AcceptThread\n        extends Thread\n    {\n        /**\n         * The <tt>Selector</tt> used to select a specific\n         * <tt>ServerSocketChannel</tt> which is ready to <tt>accept</tt>.\n         */\n        private final Selector selector;\n\n        /**\n         * Initializes a new <tt>AcceptThread</tt>.\n         */\n        public AcceptThread()\n            throws IOException\n        {\n            setName(\"TcpHarvester AcceptThread\");\n            setDaemon(true);\n\n            selector = Selector.open();\n            for (ServerSocketChannel channel : serverSocketChannels)\n            {\n                channel.configureBlocking(false);\n                channel.register(selector, SelectionKey.OP_ACCEPT);\n            }\n        }\n\n        /**\n         * Notifies {@link #readThread} that new channels have been added.\n         */\n        private void notifyReadThread()\n        {\n            readSelector.wakeup();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void run()\n        {\n            do\n            {\n                if (close)\n                {\n                    break;\n                }\n\n                IOException exception = null;\n                List<SocketChannel> channelsToAdd = new LinkedList<>();\n                // Allow to go on, so we can quit if closed.\n                long selectTimeout = 3000;\n\n                for (SelectionKey key : selector.keys())\n                {\n                    if (key.isValid())\n                    {\n                        SocketChannel channel;\n                        boolean acceptable = key.isAcceptable();\n\n                        try\n                        {\n                            channel\n                                = ((ServerSocketChannel) key.channel())\n                                    .accept();\n                        }\n                        catch (IOException ioe)\n                        {\n                            exception = ioe;\n                            break;\n                        }\n\n                        // Add the accepted channel to newChannels to allow the\n                        // 'read' thread to it up.\n                        if (channel != null)\n                        {\n                            channelsToAdd.add(channel);\n                        }\n                        else if (acceptable)\n                        {\n                            // The SelectionKey reported the channel as\n                            // acceptable but channel#accept() did not accept a\n                            // non-null SocketChannel. Give the channel a little\n                            // time to get its act together.\n                            selectTimeout = 100;\n                        }\n                    }\n                }\n                // We accepted from all serverSocketChannels.\n                selector.selectedKeys().clear();\n\n                if (!channelsToAdd.isEmpty())\n                {\n                    synchronized (newChannels)\n                    {\n                        newChannels.addAll(channelsToAdd);\n                    }\n                    notifyReadThread();\n                }\n\n                if (exception != null)\n                {\n                    logger.info(\n                            \"Failed to accept a socket, which should have been\"\n                                + \" ready to accept: \" + exception);\n                    break;\n                }\n\n                try\n                {\n                    // Allow to go on, so we can quit if closed.\n                    selector.select(selectTimeout);\n                }\n                catch (IOException ioe)\n                {\n                    logger.info(\n                            \"Failed to select an accept-ready socket: \" + ioe);\n                    break;\n                }\n            }\n            while (true);\n\n            //now clean up and exit\n            for (ServerSocketChannel serverSocketChannel : serverSocketChannels)\n                closeNoExceptions(serverSocketChannel);\n\n            try\n            {\n                selector.close();\n            }\n            catch (IOException ioe)\n            {\n                // ignore\n            }\n        }\n    }", "definition": "    private class AcceptThread\n        extends Thread", "class_docstring": "\nA <tt>Thread</tt> which will accept new <tt>SocketChannel</tt>s from all\n<tt>ServerSocketChannel</tt>s in {@link #serverSocketChannels}.\n", "name": "AcceptThread", "super_interfaces": [], "superclasses": "Thread", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [{"attribute_expression": "private final Selector selector;", "docstring": "\nThe <tt>Selector</tt> used to select a specific\n<tt>ServerSocketChannel</tt> which is ready to <tt>accept</tt>.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Selector", "name": "selector", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public AcceptThread()\n            throws IOException\n        {\n            setName(\"TcpHarvester AcceptThread\");\n            setDaemon(true);\n\n            selector = Selector.open();\n            for (ServerSocketChannel channel : serverSocketChannels)\n            {\n                channel.configureBlocking(false);\n                channel.register(selector, SelectionKey.OP_ACCEPT);\n            }\n        }", "docstring": "\nInitializes a new <tt>AcceptThread</tt>.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "AcceptThread", "params": [], "body": "        {\n            setName(\"TcpHarvester AcceptThread\");\n            setDaemon(true);\n\n            selector = Selector.open();\n            for (ServerSocketChannel channel : serverSocketChannels)\n            {\n                channel.configureBlocking(false);\n                channel.register(selector, SelectionKey.OP_ACCEPT);\n            }\n        }", "signature": "public AcceptThread()"}, {"syntax_pass": true, "original_string": "        private void notifyReadThread()\n        {\n            readSelector.wakeup();\n        }", "docstring": "\nNotifies {@link #readThread} that new channels have been added.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "notifyReadThread", "params": [], "body": "        {\n            readSelector.wakeup();\n        }", "signature": "private void notifyReadThread()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void run()\n        {\n            do\n            {\n                if (close)\n                {\n                    break;\n                }\n\n                IOException exception = null;\n                List<SocketChannel> channelsToAdd = new LinkedList<>();\n                // Allow to go on, so we can quit if closed.\n                long selectTimeout = 3000;\n\n                for (SelectionKey key : selector.keys())\n                {\n                    if (key.isValid())\n                    {\n                        SocketChannel channel;\n                        boolean acceptable = key.isAcceptable();\n\n                        try\n                        {\n                            channel\n                                = ((ServerSocketChannel) key.channel())\n                                    .accept();\n                        }\n                        catch (IOException ioe)\n                        {\n                            exception = ioe;\n                            break;\n                        }\n\n                        // Add the accepted channel to newChannels to allow the\n                        // 'read' thread to it up.\n                        if (channel != null)\n                        {\n                            channelsToAdd.add(channel);\n                        }\n                        else if (acceptable)\n                        {\n                            // The SelectionKey reported the channel as\n                            // acceptable but channel#accept() did not accept a\n                            // non-null SocketChannel. Give the channel a little\n                            // time to get its act together.\n                            selectTimeout = 100;\n                        }\n                    }\n                }\n                // We accepted from all serverSocketChannels.\n                selector.selectedKeys().clear();\n\n                if (!channelsToAdd.isEmpty())\n                {\n                    synchronized (newChannels)\n                    {\n                        newChannels.addAll(channelsToAdd);\n                    }\n                    notifyReadThread();\n                }\n\n                if (exception != null)\n                {\n                    logger.info(\n                            \"Failed to accept a socket, which should have been\"\n                                + \" ready to accept: \" + exception);\n                    break;\n                }\n\n                try\n                {\n                    // Allow to go on, so we can quit if closed.\n                    selector.select(selectTimeout);\n                }\n                catch (IOException ioe)\n                {\n                    logger.info(\n                            \"Failed to select an accept-ready socket: \" + ioe);\n                    break;\n                }\n            }\n            while (true);\n\n            //now clean up and exit\n            for (ServerSocketChannel serverSocketChannel : serverSocketChannels)\n                closeNoExceptions(serverSocketChannel);\n\n            try\n            {\n                selector.close();\n            }\n            catch (IOException ioe)\n            {\n                // ignore\n            }\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "run", "params": [], "body": "        {\n            do\n            {\n                if (close)\n                {\n                    break;\n                }\n\n                IOException exception = null;\n                List<SocketChannel> channelsToAdd = new LinkedList<>();\n                // Allow to go on, so we can quit if closed.\n                long selectTimeout = 3000;\n\n                for (SelectionKey key : selector.keys())\n                {\n                    if (key.isValid())\n                    {\n                        SocketChannel channel;\n                        boolean acceptable = key.isAcceptable();\n\n                        try\n                        {\n                            channel\n                                = ((ServerSocketChannel) key.channel())\n                                    .accept();\n                        }\n                        catch (IOException ioe)\n                        {\n                            exception = ioe;\n                            break;\n                        }\n\n                        // Add the accepted channel to newChannels to allow the\n                        // 'read' thread to it up.\n                        if (channel != null)\n                        {\n                            channelsToAdd.add(channel);\n                        }\n                        else if (acceptable)\n                        {\n                            // The SelectionKey reported the channel as\n                            // acceptable but channel#accept() did not accept a\n                            // non-null SocketChannel. Give the channel a little\n                            // time to get its act together.\n                            selectTimeout = 100;\n                        }\n                    }\n                }\n                // We accepted from all serverSocketChannels.\n                selector.selectedKeys().clear();\n\n                if (!channelsToAdd.isEmpty())\n                {\n                    synchronized (newChannels)\n                    {\n                        newChannels.addAll(channelsToAdd);\n                    }\n                    notifyReadThread();\n                }\n\n                if (exception != null)\n                {\n                    logger.info(\n                            \"Failed to accept a socket, which should have been\"\n                                + \" ready to accept: \" + exception);\n                    break;\n                }\n\n                try\n                {\n                    // Allow to go on, so we can quit if closed.\n                    selector.select(selectTimeout);\n                }\n                catch (IOException ioe)\n                {\n                    logger.info(\n                            \"Failed to select an accept-ready socket: \" + ioe);\n                    break;\n                }\n            }\n            while (true);\n\n            //now clean up and exit\n            for (ServerSocketChannel serverSocketChannel : serverSocketChannels)\n                closeNoExceptions(serverSocketChannel);\n\n            try\n            {\n                selector.close();\n            }\n            catch (IOException ioe)\n            {\n                // ignore\n            }\n        }", "signature": "@Override\n        public void run()"}]}, {"original_string": "    private static class ChannelDesc\n    {\n        /**\n         * The actual <tt>SocketChannel</tt>.\n         */\n        public final SocketChannel channel;\n\n        /**\n         * The buffer which stores the data so far read from the channel.\n         */\n        ByteBuffer buffer = null;\n\n        /**\n         * Whether we had checked for initial \"pseudo\" SSL handshake.\n         */\n        boolean checkedForSSLHandshake = false;\n\n        /**\n         * Buffer to use if we had read some data in advance and want to process\n         * it after next read, used when we are checking for \"pseudo\" SSL and\n         * we haven't found some, but had read data to check for it.\n         */\n        byte[] preBuffered = null;\n\n        /**\n         * The value of the RFC4571 \"length\" field read from the channel, or\n         * -1 if it hasn't been read (yet).\n         */\n        int length = -1;\n\n        /**\n         * Initializes a new <tt>ChannelDesc</tt> with the given channel.\n         * @param channel the channel.\n         */\n        public ChannelDesc(SocketChannel channel)\n        {\n            this.channel = channel;\n        }\n    }", "definition": "    private static class ChannelDesc", "class_docstring": "\nContains a <tt>SocketChannel</tt> that <tt>ReadThread</tt> is reading\nfrom.\n", "name": "ChannelDesc", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "public final SocketChannel channel;", "docstring": "\nThe actual <tt>SocketChannel</tt>.\n", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "SocketChannel", "name": "channel", "syntax_pass": true}, {"attribute_expression": "ByteBuffer buffer = null;", "docstring": "\nThe buffer which stores the data so far read from the channel.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ByteBuffer", "name": "buffer = null", "syntax_pass": true}, {"attribute_expression": "boolean checkedForSSLHandshake = false;", "docstring": "\nWhether we had checked for initial \"pseudo\" SSL handshake.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "boolean", "name": "checkedForSSLHandshake = false", "syntax_pass": true}, {"attribute_expression": "byte[] preBuffered = null;", "docstring": "\nBuffer to use if we had read some data in advance and want to process\nit after next read, used when we are checking for \"pseudo\" SSL and\nwe haven't found some, but had read data to check for it.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "byte[]", "name": "preBuffered = null", "syntax_pass": true}, {"attribute_expression": "int length = -1;", "docstring": "\nThe value of the RFC4571 \"length\" field read from the channel, or\n-1 if it hasn't been read (yet).\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "length = -1", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ChannelDesc(SocketChannel channel)\n        {\n            this.channel = channel;\n        }", "docstring": "\nInitializes a new <tt>ChannelDesc</tt> with the given channel.\n@param channel the channel.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ChannelDesc", "params": [{"name": "channel", "type": "SocketChannel"}], "body": "        {\n            this.channel = channel;\n        }", "signature": "public ChannelDesc(SocketChannel channel)"}]}, {"original_string": "    protected static class PushBackIceSocketWrapper\n        extends IceSocketWrapper\n    {\n        /**\n         * The <tt>DatagramPacket</tt> which will be used on the first call to\n         * {@link #receive(DatagramPacket)}.\n         */\n        private DatagramPacket datagramPacket;\n\n        /**\n         * The <tt>IceSocketWrapper</tt> that this instance wraps around.\n         */\n        private final IceSocketWrapper wrapped;\n\n        /**\n         * Initializes a new <tt>PushBackIceSocketWrapper</tt> instance that\n         * wraps around <tt>wrappedWrapper</tt> and reads from\n         * <tt>datagramSocket</tt> on the first call to\n         * {@link #receive(DatagramPacket)}\n         *\n         * @param wrappedWrapper the <tt>IceSocketWrapper</tt> instance that we\n         * wrap around.\n         * @param datagramPacket the <tt>DatagramPacket</tt> which will be used\n         * on the first call to {@link #receive(DatagramPacket)}\n         */\n        public PushBackIceSocketWrapper(IceSocketWrapper wrappedWrapper,\n                                        DatagramPacket datagramPacket)\n        {\n            this.wrapped = wrappedWrapper;\n            this.datagramPacket = datagramPacket;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void close()\n        {\n            wrapped.close();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public InetAddress getLocalAddress()\n        {\n            return wrapped.getLocalAddress();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getLocalPort()\n        {\n            return wrapped.getLocalPort();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public SocketAddress getLocalSocketAddress()\n        {\n            return wrapped.getLocalSocketAddress();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Socket getTCPSocket()\n        {\n            return wrapped.getTCPSocket();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public DatagramSocket getUDPSocket()\n        {\n            return wrapped.getUDPSocket();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * On the first call to this instance reads from\n         * {@link #datagramPacket}, on subsequent calls delegates to\n         * {@link #wrapped}.\n         */\n        @Override\n        public void receive(DatagramPacket p) throws IOException\n        {\n            if (datagramPacket != null)\n            {\n                int len = Math.min(p.getLength(), datagramPacket.getLength());\n                System.arraycopy(datagramPacket.getData(), 0,\n                                 p.getData(), 0,\n                                 len);\n                p.setAddress(datagramPacket.getAddress());\n                p.setPort(datagramPacket.getPort());\n                datagramPacket = null;\n            }\n            else\n            {\n                wrapped.receive(p);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void send(DatagramPacket p) throws IOException\n        {\n            wrapped.send(p);\n        }\n    }", "definition": "    protected static class PushBackIceSocketWrapper\n        extends IceSocketWrapper", "class_docstring": "\nAn <tt>IceSocketWrapper</tt> implementation which allows a\n<tt>DatagramPacket</tt> to be pushed back and received on the first call\nto {@link #receive(DatagramPacket)}.\n", "name": "PushBackIceSocketWrapper", "super_interfaces": [], "superclasses": "IceSocketWrapper", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "private DatagramPacket datagramPacket;", "docstring": "\nThe <tt>DatagramPacket</tt> which will be used on the first call to\n{@link #receive(DatagramPacket)}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DatagramPacket", "name": "datagramPacket", "syntax_pass": true}, {"attribute_expression": "private final IceSocketWrapper wrapped;", "docstring": "\nThe <tt>IceSocketWrapper</tt> that this instance wraps around.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "IceSocketWrapper", "name": "wrapped", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public PushBackIceSocketWrapper(IceSocketWrapper wrappedWrapper,\n                                        DatagramPacket datagramPacket)\n        {\n            this.wrapped = wrappedWrapper;\n            this.datagramPacket = datagramPacket;\n        }", "docstring": "\nInitializes a new <tt>PushBackIceSocketWrapper</tt> instance that\nwraps around <tt>wrappedWrapper</tt> and reads from\n<tt>datagramSocket</tt> on the first call to\n{@link #receive(DatagramPacket)}\n\n@param wrappedWrapper the <tt>IceSocketWrapper</tt> instance that we\nwrap around.\n@param datagramPacket the <tt>DatagramPacket</tt> which will be used\non the first call to {@link #receive(DatagramPacket)}\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "PushBackIceSocketWrapper", "params": [{"name": "wrappedWrapper", "type": "IceSocketWrapper"}, {"name": "datagramPacket", "type": "DatagramPacket"}], "body": "        {\n            this.wrapped = wrappedWrapper;\n            this.datagramPacket = datagramPacket;\n        }", "signature": "public PushBackIceSocketWrapper(IceSocketWrapper wrappedWrapper,\n                                        DatagramPacket datagramPacket)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void close()\n        {\n            wrapped.close();\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "close", "params": [], "body": "        {\n            wrapped.close();\n        }", "signature": "@Override\n        public void close()"}, {"syntax_pass": true, "original_string": "        @Override\n        public InetAddress getLocalAddress()\n        {\n            return wrapped.getLocalAddress();\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "InetAddress", "classes": []}, "name": "getLocalAddress", "params": [], "body": "        {\n            return wrapped.getLocalAddress();\n        }", "signature": "@Override\n        public InetAddress getLocalAddress()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int getLocalPort()\n        {\n            return wrapped.getLocalPort();\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getLocalPort", "params": [], "body": "        {\n            return wrapped.getLocalPort();\n        }", "signature": "@Override\n        public int getLocalPort()"}, {"syntax_pass": true, "original_string": "        @Override\n        public SocketAddress getLocalSocketAddress()\n        {\n            return wrapped.getLocalSocketAddress();\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SocketAddress", "classes": []}, "name": "getLocalSocketAddress", "params": [], "body": "        {\n            return wrapped.getLocalSocketAddress();\n        }", "signature": "@Override\n        public SocketAddress getLocalSocketAddress()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Socket getTCPSocket()\n        {\n            return wrapped.getTCPSocket();\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Socket", "classes": []}, "name": "getTCPSocket", "params": [], "body": "        {\n            return wrapped.getTCPSocket();\n        }", "signature": "@Override\n        public Socket getTCPSocket()"}, {"syntax_pass": true, "original_string": "        @Override\n        public DatagramSocket getUDPSocket()\n        {\n            return wrapped.getUDPSocket();\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "DatagramSocket", "classes": []}, "name": "getUDPSocket", "params": [], "body": "        {\n            return wrapped.getUDPSocket();\n        }", "signature": "@Override\n        public DatagramSocket getUDPSocket()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void receive(DatagramPacket p) throws IOException\n        {\n            if (datagramPacket != null)\n            {\n                int len = Math.min(p.getLength(), datagramPacket.getLength());\n                System.arraycopy(datagramPacket.getData(), 0,\n                                 p.getData(), 0,\n                                 len);\n                p.setAddress(datagramPacket.getAddress());\n                p.setPort(datagramPacket.getPort());\n                datagramPacket = null;\n            }\n            else\n            {\n                wrapped.receive(p);\n            }\n        }", "docstring": "\n{@inheritDoc}\n\nOn the first call to this instance reads from\n{@link #datagramPacket}, on subsequent calls delegates to\n{@link #wrapped}.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "receive", "params": [{"name": "p", "type": "DatagramPacket"}], "body": "        {\n            if (datagramPacket != null)\n            {\n                int len = Math.min(p.getLength(), datagramPacket.getLength());\n                System.arraycopy(datagramPacket.getData(), 0,\n                                 p.getData(), 0,\n                                 len);\n                p.setAddress(datagramPacket.getAddress());\n                p.setPort(datagramPacket.getPort());\n                datagramPacket = null;\n            }\n            else\n            {\n                wrapped.receive(p);\n            }\n        }", "signature": "@Override\n        public void receive(DatagramPacket p)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void send(DatagramPacket p) throws IOException\n        {\n            wrapped.send(p);\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "send", "params": [{"name": "p", "type": "DatagramPacket"}], "body": "        {\n            wrapped.send(p);\n        }", "signature": "@Override\n        public void send(DatagramPacket p)"}]}, {"original_string": "    private class ReadThread\n        extends Thread\n    {\n        /**\n         * Initializes a new <tt>ReadThread</tt>.\n         */\n        public ReadThread()\n        {\n            setName(\"TcpHarvester ReadThread\");\n            setDaemon(true);\n        }\n\n        /**\n         * Registers the channels from {@link #newChannels} in\n         * {@link #readSelector}.\n         */\n        private void checkForNewChannels()\n        {\n            synchronized (newChannels)\n            {\n                for (SocketChannel channel : newChannels)\n                {\n                    try\n                    {\n                        channel.configureBlocking(false);\n                        channel.register(\n                                readSelector,\n                                SelectionKey.OP_READ,\n                                new ChannelDesc(channel));\n                    }\n                    catch (IOException ioe)\n                    {\n                        logger.info(\"Failed to register channel: \" + ioe);\n                        closeNoExceptions(channel);\n                    }\n                }\n                newChannels.clear();\n            }\n        }\n\n        /**\n         * Tries to read, without blocking, from <tt>channel</tt> to its\n         * buffer. If after reading the buffer is filled, handles the data in\n         * the buffer.\n         *\n         * This works in three stages:\n         * 1 (optional): Read a fixed-size message. If it matches the\n         * hard-coded pseudo SSL ClientHello, sends the hard-coded ServerHello.\n         * 2: Read two bytes as an unsigned int and interpret it as the length\n         * to read in the next stage.\n         * 3: Read number of bytes indicated in stage2 and try to interpret\n         * them as a STUN message.\n         *\n         * If a datagram is successfully read it is passed on to\n         * {@link #processFirstDatagram(byte[], ChannelDesc, SelectionKey)}\n         *\n         * @param channel the <tt>SocketChannel</tt> to read from.\n         * @param key the <tt>SelectionKey</tt> associated with\n         * <tt>channel</tt>, which is to be canceled in case no further\n         * reading is required from the channel.\n         */\n        private void readFromChannel(ChannelDesc channel, SelectionKey key)\n        {\n            if (channel.buffer == null)\n            {\n                // Set up a buffer with a pre-determined size\n\n                if (!channel.checkedForSSLHandshake && channel.length == -1)\n                {\n                    channel.buffer\n                        = ByteBuffer.allocate(\n                                GoogleTurnSSLCandidateHarvester\n                                    .SSL_CLIENT_HANDSHAKE.length);\n                }\n                else if (channel.length == -1)\n                {\n                    channel.buffer = ByteBuffer.allocate(2);\n                }\n                else\n                {\n                    channel.buffer = ByteBuffer.allocate(channel.length);\n                }\n            }\n\n            try\n            {\n                int read = channel.channel.read(channel.buffer);\n\n                if (read == -1)\n                    throw new IOException(\"End of stream!\");\n\n                if (!channel.buffer.hasRemaining())\n                {\n                    // We've filled in the buffer.\n                    if (!channel.checkedForSSLHandshake)\n                    {\n                        byte[] bytesRead\n                            = new byte[GoogleTurnSSLCandidateHarvester\n                                .SSL_CLIENT_HANDSHAKE.length];\n\n                        channel.buffer.flip();\n                        channel.buffer.get(bytesRead);\n\n                        // Set to null, so that we re-allocate it for the next\n                        // stage\n                        channel.buffer = null;\n                        channel.checkedForSSLHandshake = true;\n\n                        if (Arrays.equals(bytesRead,\n                                          GoogleTurnSSLCandidateHarvester\n                                                  .SSL_CLIENT_HANDSHAKE))\n                        {\n                            ByteBuffer byteBuffer = ByteBuffer.wrap(\n                                    GoogleTurnSSLCandidateHarvester\n                                            .SSL_SERVER_HANDSHAKE);\n                            channel.channel.write(byteBuffer);\n                        }\n                        else\n                        {\n                            int fb = bytesRead[0];\n                            int sb = bytesRead[1];\n\n                            channel.length = (((fb & 0xff) << 8) | (sb & 0xff));\n\n                            byte[] preBuffered\n                                = Arrays.copyOfRange(\n                                    bytesRead, 2, bytesRead.length);\n\n                            // if we had read enough data\n                            if (channel.length <= bytesRead.length - 2)\n                            {\n                                processFirstDatagram(\n                                    preBuffered, channel, key);\n                            }\n                            else\n                            {\n                                // not enough data, store what was read\n                                // and continue\n                                channel.preBuffered = preBuffered;\n\n                                channel.length -= channel.preBuffered.length;\n                            }\n                        }\n                    }\n                    else if (channel.length == -1)\n                    {\n                        channel.buffer.flip();\n\n                        int fb = channel.buffer.get();\n                        int sb = channel.buffer.get();\n\n                        channel.length = (((fb & 0xff) << 8) | (sb & 0xff));\n\n                        // Set to null, so that we re-allocate it for the next\n                        // stage\n                        channel.buffer = null;\n                    }\n                    else\n                    {\n                        byte[] bytesRead = new byte[channel.length];\n\n                        channel.buffer.flip();\n                        channel.buffer.get(bytesRead);\n\n                        if (channel.preBuffered != null)\n                        {\n                            // will store preBuffered and currently read data\n                            byte[] newBytesRead = new byte[\n                                channel.preBuffered.length + bytesRead.length];\n\n                            // copy old data\n                            System.arraycopy(\n                                channel.preBuffered, 0,\n                                newBytesRead, 0,\n                                channel.preBuffered.length);\n                            // and new data\n                            System.arraycopy(\n                                bytesRead, 0,\n                                newBytesRead, channel.preBuffered.length,\n                                bytesRead.length);\n\n                            // use that data for processing\n                            bytesRead = newBytesRead;\n\n                            channel.preBuffered = null;\n                        }\n\n                        processFirstDatagram(bytesRead, channel, key);\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                // The ReadThread should continue running no matter what\n                // exceptions occur in the code above (we've observed exceptions\n                // due to failures to allocate resources) because otherwise\n                // the #newChannels list is never pruned leading to a leak of\n                // sockets.\n                logger.info(\n                        \"Failed to handle TCP socket \"\n                            + channel.channel.socket() + \": \" + e.getMessage());\n                key.cancel();\n                closeNoExceptions(channel.channel);\n            }\n        }\n\n        /**\n         * Process the first RFC4571-framed datagram read from a socket.\n         *\n         * If the datagram contains a STUN Binding Request, and it has a\n         * USERNAME attribute, the local &quot;ufrag&quot; is extracted from the\n         * attribute value, and the socket is passed to\n         * {@link #acceptSession(Socket, String, DatagramPacket)}.\n         *\n         * @param bytesRead bytes to be processed\n         * @param channel the <tt>SocketChannel</tt> to read from.\n         * @param key the <tt>SelectionKey</tt> associated with\n         * <tt>channel</tt>, which is to be canceled in case no further\n         * reading is required from the channel.\n         * @throws IOException if the datagram does not contain s STUN Binding\n         * Request with a USERNAME attribute.\n         * @throws IllegalStateException if the session for the extracted\n         * username fragment cannot be accepted for implementation reasons\n         * (e.g. no ICE Agent with the given local ufrag is found).\n         */\n        private void processFirstDatagram(\n            byte[] bytesRead,\n            ChannelDesc channel, SelectionKey key)\n            throws IOException, IllegalStateException\n        {\n            // Does this look like a STUN binding request?\n            // What's the username?\n            String ufrag\n                = AbstractUdpListener.getUfrag(bytesRead,\n                                               (char) 0,\n                                               (char) bytesRead.length);\n\n            if (ufrag == null)\n            {\n                throw new IOException(\"Cannot extract ufrag\");\n            }\n\n            // The rest of the stack will read from the socket's\n            // InputStream. We cannot change the blocking mode\n            // before the channel is removed from the selector (by\n            // cancelling the key)\n            key.cancel();\n            channel.channel.configureBlocking(true);\n\n            // Construct a DatagramPacket from the just-read packet\n            // which is to be pushed back\n            DatagramPacket p\n                = new DatagramPacket(bytesRead, bytesRead.length);\n            Socket socket = channel.channel.socket();\n\n            p.setAddress(socket.getInetAddress());\n            p.setPort(socket.getPort());\n\n            acceptSession(socket, ufrag, p);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void run()\n        {\n            do\n            {\n                synchronized (AbstractTcpListener.this)\n                {\n                    if (close)\n                        break;\n                }\n\n                checkForNewChannels();\n\n                for (SelectionKey key : readSelector.keys())\n                {\n                    if (key.isValid())\n                    {\n                        ChannelDesc channelDesc\n                            = (ChannelDesc) key.attachment();\n\n                        readFromChannel(channelDesc, key);\n                    }\n                }\n                // We read from all SocketChannels.\n                readSelector.selectedKeys().clear();\n\n                try\n                {\n                    readSelector.select(\n                            MuxServerSocketChannelFactory\n                                    .SOCKET_CHANNEL_READ_TIMEOUT\n                                / 2);\n                }\n                catch (IOException ioe)\n                {\n                    logger.info(\"Failed to select a read-ready channel.\");\n                }\n            }\n            while (true);\n\n            //we are all done, clean up.\n            synchronized (newChannels)\n            {\n                for (SocketChannel channel : newChannels)\n                {\n                    closeNoExceptions(channel);\n                }\n                newChannels.clear();\n            }\n\n            for (SelectionKey key : readSelector.keys())\n            {\n                // An invalid key specifies that either the channel was closed\n                // (in which case we do not have to do anything else to it) or\n                // that we no longer control the channel (i.e. we do not want to\n                // do anything else to it).\n                if (key.isValid())\n                {\n                    Channel channel = key.channel();\n\n                    if (channel.isOpen())\n                        closeNoExceptions(channel);\n                }\n            }\n\n            try\n            {\n                readSelector.close();\n            }\n            catch (IOException ioe)\n            {\n                // ignore\n            }\n        }\n    }", "definition": "    private class ReadThread\n        extends Thread", "class_docstring": "", "name": "ReadThread", "super_interfaces": [], "superclasses": "Thread", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ReadThread()\n        {\n            setName(\"TcpHarvester ReadThread\");\n            setDaemon(true);\n        }", "docstring": "\nInitializes a new <tt>ReadThread</tt>.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ReadThread", "params": [], "body": "        {\n            setName(\"TcpHarvester ReadThread\");\n            setDaemon(true);\n        }", "signature": "public ReadThread()"}, {"syntax_pass": true, "original_string": "        private void checkForNewChannels()\n        {\n            synchronized (newChannels)\n            {\n                for (SocketChannel channel : newChannels)\n                {\n                    try\n                    {\n                        channel.configureBlocking(false);\n                        channel.register(\n                                readSelector,\n                                SelectionKey.OP_READ,\n                                new ChannelDesc(channel));\n                    }\n                    catch (IOException ioe)\n                    {\n                        logger.info(\"Failed to register channel: \" + ioe);\n                        closeNoExceptions(channel);\n                    }\n                }\n                newChannels.clear();\n            }\n        }", "docstring": "\nRegisters the channels from {@link #newChannels} in\n{@link #readSelector}.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "checkForNewChannels", "params": [], "body": "        {\n            synchronized (newChannels)\n            {\n                for (SocketChannel channel : newChannels)\n                {\n                    try\n                    {\n                        channel.configureBlocking(false);\n                        channel.register(\n                                readSelector,\n                                SelectionKey.OP_READ,\n                                new ChannelDesc(channel));\n                    }\n                    catch (IOException ioe)\n                    {\n                        logger.info(\"Failed to register channel: \" + ioe);\n                        closeNoExceptions(channel);\n                    }\n                }\n                newChannels.clear();\n            }\n        }", "signature": "private void checkForNewChannels()"}, {"syntax_pass": true, "original_string": "        private void readFromChannel(ChannelDesc channel, SelectionKey key)\n        {\n            if (channel.buffer == null)\n            {\n                // Set up a buffer with a pre-determined size\n\n                if (!channel.checkedForSSLHandshake && channel.length == -1)\n                {\n                    channel.buffer\n                        = ByteBuffer.allocate(\n                                GoogleTurnSSLCandidateHarvester\n                                    .SSL_CLIENT_HANDSHAKE.length);\n                }\n                else if (channel.length == -1)\n                {\n                    channel.buffer = ByteBuffer.allocate(2);\n                }\n                else\n                {\n                    channel.buffer = ByteBuffer.allocate(channel.length);\n                }\n            }\n\n            try\n            {\n                int read = channel.channel.read(channel.buffer);\n\n                if (read == -1)\n                    throw new IOException(\"End of stream!\");\n\n                if (!channel.buffer.hasRemaining())\n                {\n                    // We've filled in the buffer.\n                    if (!channel.checkedForSSLHandshake)\n                    {\n                        byte[] bytesRead\n                            = new byte[GoogleTurnSSLCandidateHarvester\n                                .SSL_CLIENT_HANDSHAKE.length];\n\n                        channel.buffer.flip();\n                        channel.buffer.get(bytesRead);\n\n                        // Set to null, so that we re-allocate it for the next\n                        // stage\n                        channel.buffer = null;\n                        channel.checkedForSSLHandshake = true;\n\n                        if (Arrays.equals(bytesRead,\n                                          GoogleTurnSSLCandidateHarvester\n                                                  .SSL_CLIENT_HANDSHAKE))\n                        {\n                            ByteBuffer byteBuffer = ByteBuffer.wrap(\n                                    GoogleTurnSSLCandidateHarvester\n                                            .SSL_SERVER_HANDSHAKE);\n                            channel.channel.write(byteBuffer);\n                        }\n                        else\n                        {\n                            int fb = bytesRead[0];\n                            int sb = bytesRead[1];\n\n                            channel.length = (((fb & 0xff) << 8) | (sb & 0xff));\n\n                            byte[] preBuffered\n                                = Arrays.copyOfRange(\n                                    bytesRead, 2, bytesRead.length);\n\n                            // if we had read enough data\n                            if (channel.length <= bytesRead.length - 2)\n                            {\n                                processFirstDatagram(\n                                    preBuffered, channel, key);\n                            }\n                            else\n                            {\n                                // not enough data, store what was read\n                                // and continue\n                                channel.preBuffered = preBuffered;\n\n                                channel.length -= channel.preBuffered.length;\n                            }\n                        }\n                    }\n                    else if (channel.length == -1)\n                    {\n                        channel.buffer.flip();\n\n                        int fb = channel.buffer.get();\n                        int sb = channel.buffer.get();\n\n                        channel.length = (((fb & 0xff) << 8) | (sb & 0xff));\n\n                        // Set to null, so that we re-allocate it for the next\n                        // stage\n                        channel.buffer = null;\n                    }\n                    else\n                    {\n                        byte[] bytesRead = new byte[channel.length];\n\n                        channel.buffer.flip();\n                        channel.buffer.get(bytesRead);\n\n                        if (channel.preBuffered != null)\n                        {\n                            // will store preBuffered and currently read data\n                            byte[] newBytesRead = new byte[\n                                channel.preBuffered.length + bytesRead.length];\n\n                            // copy old data\n                            System.arraycopy(\n                                channel.preBuffered, 0,\n                                newBytesRead, 0,\n                                channel.preBuffered.length);\n                            // and new data\n                            System.arraycopy(\n                                bytesRead, 0,\n                                newBytesRead, channel.preBuffered.length,\n                                bytesRead.length);\n\n                            // use that data for processing\n                            bytesRead = newBytesRead;\n\n                            channel.preBuffered = null;\n                        }\n\n                        processFirstDatagram(bytesRead, channel, key);\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                // The ReadThread should continue running no matter what\n                // exceptions occur in the code above (we've observed exceptions\n                // due to failures to allocate resources) because otherwise\n                // the #newChannels list is never pruned leading to a leak of\n                // sockets.\n                logger.info(\n                        \"Failed to handle TCP socket \"\n                            + channel.channel.socket() + \": \" + e.getMessage());\n                key.cancel();\n                closeNoExceptions(channel.channel);\n            }\n        }", "docstring": "\nTries to read, without blocking, from <tt>channel</tt> to its\nbuffer. If after reading the buffer is filled, handles the data in\nthe buffer.\n\nThis works in three stages:\n1 (optional): Read a fixed-size message. If it matches the\nhard-coded pseudo SSL ClientHello, sends the hard-coded ServerHello.\n2: Read two bytes as an unsigned int and interpret it as the length\nto read in the next stage.\n3: Read number of bytes indicated in stage2 and try to interpret\nthem as a STUN message.\n\nIf a datagram is successfully read it is passed on to\n{@link #processFirstDatagram(byte[], ChannelDesc, SelectionKey)}\n\n@param channel the <tt>SocketChannel</tt> to read from.\n@param key the <tt>SelectionKey</tt> associated with\n<tt>channel</tt>, which is to be canceled in case no further\nreading is required from the channel.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "readFromChannel", "params": [{"name": "channel", "type": "ChannelDesc"}, {"name": "key", "type": "SelectionKey"}], "body": "        {\n            if (channel.buffer == null)\n            {\n                // Set up a buffer with a pre-determined size\n\n                if (!channel.checkedForSSLHandshake && channel.length == -1)\n                {\n                    channel.buffer\n                        = ByteBuffer.allocate(\n                                GoogleTurnSSLCandidateHarvester\n                                    .SSL_CLIENT_HANDSHAKE.length);\n                }\n                else if (channel.length == -1)\n                {\n                    channel.buffer = ByteBuffer.allocate(2);\n                }\n                else\n                {\n                    channel.buffer = ByteBuffer.allocate(channel.length);\n                }\n            }\n\n            try\n            {\n                int read = channel.channel.read(channel.buffer);\n\n                if (read == -1)\n                    throw new IOException(\"End of stream!\");\n\n                if (!channel.buffer.hasRemaining())\n                {\n                    // We've filled in the buffer.\n                    if (!channel.checkedForSSLHandshake)\n                    {\n                        byte[] bytesRead\n                            = new byte[GoogleTurnSSLCandidateHarvester\n                                .SSL_CLIENT_HANDSHAKE.length];\n\n                        channel.buffer.flip();\n                        channel.buffer.get(bytesRead);\n\n                        // Set to null, so that we re-allocate it for the next\n                        // stage\n                        channel.buffer = null;\n                        channel.checkedForSSLHandshake = true;\n\n                        if (Arrays.equals(bytesRead,\n                                          GoogleTurnSSLCandidateHarvester\n                                                  .SSL_CLIENT_HANDSHAKE))\n                        {\n                            ByteBuffer byteBuffer = ByteBuffer.wrap(\n                                    GoogleTurnSSLCandidateHarvester\n                                            .SSL_SERVER_HANDSHAKE);\n                            channel.channel.write(byteBuffer);\n                        }\n                        else\n                        {\n                            int fb = bytesRead[0];\n                            int sb = bytesRead[1];\n\n                            channel.length = (((fb & 0xff) << 8) | (sb & 0xff));\n\n                            byte[] preBuffered\n                                = Arrays.copyOfRange(\n                                    bytesRead, 2, bytesRead.length);\n\n                            // if we had read enough data\n                            if (channel.length <= bytesRead.length - 2)\n                            {\n                                processFirstDatagram(\n                                    preBuffered, channel, key);\n                            }\n                            else\n                            {\n                                // not enough data, store what was read\n                                // and continue\n                                channel.preBuffered = preBuffered;\n\n                                channel.length -= channel.preBuffered.length;\n                            }\n                        }\n                    }\n                    else if (channel.length == -1)\n                    {\n                        channel.buffer.flip();\n\n                        int fb = channel.buffer.get();\n                        int sb = channel.buffer.get();\n\n                        channel.length = (((fb & 0xff) << 8) | (sb & 0xff));\n\n                        // Set to null, so that we re-allocate it for the next\n                        // stage\n                        channel.buffer = null;\n                    }\n                    else\n                    {\n                        byte[] bytesRead = new byte[channel.length];\n\n                        channel.buffer.flip();\n                        channel.buffer.get(bytesRead);\n\n                        if (channel.preBuffered != null)\n                        {\n                            // will store preBuffered and currently read data\n                            byte[] newBytesRead = new byte[\n                                channel.preBuffered.length + bytesRead.length];\n\n                            // copy old data\n                            System.arraycopy(\n                                channel.preBuffered, 0,\n                                newBytesRead, 0,\n                                channel.preBuffered.length);\n                            // and new data\n                            System.arraycopy(\n                                bytesRead, 0,\n                                newBytesRead, channel.preBuffered.length,\n                                bytesRead.length);\n\n                            // use that data for processing\n                            bytesRead = newBytesRead;\n\n                            channel.preBuffered = null;\n                        }\n\n                        processFirstDatagram(bytesRead, channel, key);\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                // The ReadThread should continue running no matter what\n                // exceptions occur in the code above (we've observed exceptions\n                // due to failures to allocate resources) because otherwise\n                // the #newChannels list is never pruned leading to a leak of\n                // sockets.\n                logger.info(\n                        \"Failed to handle TCP socket \"\n                            + channel.channel.socket() + \": \" + e.getMessage());\n                key.cancel();\n                closeNoExceptions(channel.channel);\n            }\n        }", "signature": "private void readFromChannel(ChannelDesc channel, SelectionKey key)"}, {"syntax_pass": true, "original_string": "        private void processFirstDatagram(\n            byte[] bytesRead,\n            ChannelDesc channel, SelectionKey key)\n            throws IOException, IllegalStateException\n        {\n            // Does this look like a STUN binding request?\n            // What's the username?\n            String ufrag\n                = AbstractUdpListener.getUfrag(bytesRead,\n                                               (char) 0,\n                                               (char) bytesRead.length);\n\n            if (ufrag == null)\n            {\n                throw new IOException(\"Cannot extract ufrag\");\n            }\n\n            // The rest of the stack will read from the socket's\n            // InputStream. We cannot change the blocking mode\n            // before the channel is removed from the selector (by\n            // cancelling the key)\n            key.cancel();\n            channel.channel.configureBlocking(true);\n\n            // Construct a DatagramPacket from the just-read packet\n            // which is to be pushed back\n            DatagramPacket p\n                = new DatagramPacket(bytesRead, bytesRead.length);\n            Socket socket = channel.channel.socket();\n\n            p.setAddress(socket.getInetAddress());\n            p.setPort(socket.getPort());\n\n            acceptSession(socket, ufrag, p);\n        }", "docstring": "\nProcess the first RFC4571-framed datagram read from a socket.\n\nIf the datagram contains a STUN Binding Request, and it has a\nUSERNAME attribute, the local &quot;ufrag&quot; is extracted from the\nattribute value, and the socket is passed to\n{@link #acceptSession(Socket, String, DatagramPacket)}.\n\n@param bytesRead bytes to be processed\n@param channel the <tt>SocketChannel</tt> to read from.\n@param key the <tt>SelectionKey</tt> associated with\n<tt>channel</tt>, which is to be canceled in case no further\nreading is required from the channel.\n@throws IOException if the datagram does not contain s STUN Binding\nRequest with a USERNAME attribute.\n@throws IllegalStateException if the session for the extracted\nusername fragment cannot be accepted for implementation reasons\n(e.g. no ICE Agent with the given local ufrag is found).\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "processFirstDatagram", "params": [{"name": "bytesRead", "type": "byte[]"}, {"name": "channel", "type": "ChannelDesc"}, {"name": "key", "type": "SelectionKey"}], "body": "        {\n            // Does this look like a STUN binding request?\n            // What's the username?\n            String ufrag\n                = AbstractUdpListener.getUfrag(bytesRead,\n                                               (char) 0,\n                                               (char) bytesRead.length);\n\n            if (ufrag == null)\n            {\n                throw new IOException(\"Cannot extract ufrag\");\n            }\n\n            // The rest of the stack will read from the socket's\n            // InputStream. We cannot change the blocking mode\n            // before the channel is removed from the selector (by\n            // cancelling the key)\n            key.cancel();\n            channel.channel.configureBlocking(true);\n\n            // Construct a DatagramPacket from the just-read packet\n            // which is to be pushed back\n            DatagramPacket p\n                = new DatagramPacket(bytesRead, bytesRead.length);\n            Socket socket = channel.channel.socket();\n\n            p.setAddress(socket.getInetAddress());\n            p.setPort(socket.getPort());\n\n            acceptSession(socket, ufrag, p);\n        }", "signature": "private void processFirstDatagram(\n            byte[] bytesRead,\n            ChannelDesc channel, SelectionKey key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void run()\n        {\n            do\n            {\n                synchronized (AbstractTcpListener.this)\n                {\n                    if (close)\n                        break;\n                }\n\n                checkForNewChannels();\n\n                for (SelectionKey key : readSelector.keys())\n                {\n                    if (key.isValid())\n                    {\n                        ChannelDesc channelDesc\n                            = (ChannelDesc) key.attachment();\n\n                        readFromChannel(channelDesc, key);\n                    }\n                }\n                // We read from all SocketChannels.\n                readSelector.selectedKeys().clear();\n\n                try\n                {\n                    readSelector.select(\n                            MuxServerSocketChannelFactory\n                                    .SOCKET_CHANNEL_READ_TIMEOUT\n                                / 2);\n                }\n                catch (IOException ioe)\n                {\n                    logger.info(\"Failed to select a read-ready channel.\");\n                }\n            }\n            while (true);\n\n            //we are all done, clean up.\n            synchronized (newChannels)\n            {\n                for (SocketChannel channel : newChannels)\n                {\n                    closeNoExceptions(channel);\n                }\n                newChannels.clear();\n            }\n\n            for (SelectionKey key : readSelector.keys())\n            {\n                // An invalid key specifies that either the channel was closed\n                // (in which case we do not have to do anything else to it) or\n                // that we no longer control the channel (i.e. we do not want to\n                // do anything else to it).\n                if (key.isValid())\n                {\n                    Channel channel = key.channel();\n\n                    if (channel.isOpen())\n                        closeNoExceptions(channel);\n                }\n            }\n\n            try\n            {\n                readSelector.close();\n            }\n            catch (IOException ioe)\n            {\n                // ignore\n            }\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "run", "params": [], "body": "        {\n            do\n            {\n                synchronized (AbstractTcpListener.this)\n                {\n                    if (close)\n                        break;\n                }\n\n                checkForNewChannels();\n\n                for (SelectionKey key : readSelector.keys())\n                {\n                    if (key.isValid())\n                    {\n                        ChannelDesc channelDesc\n                            = (ChannelDesc) key.attachment();\n\n                        readFromChannel(channelDesc, key);\n                    }\n                }\n                // We read from all SocketChannels.\n                readSelector.selectedKeys().clear();\n\n                try\n                {\n                    readSelector.select(\n                            MuxServerSocketChannelFactory\n                                    .SOCKET_CHANNEL_READ_TIMEOUT\n                                / 2);\n                }\n                catch (IOException ioe)\n                {\n                    logger.info(\"Failed to select a read-ready channel.\");\n                }\n            }\n            while (true);\n\n            //we are all done, clean up.\n            synchronized (newChannels)\n            {\n                for (SocketChannel channel : newChannels)\n                {\n                    closeNoExceptions(channel);\n                }\n                newChannels.clear();\n            }\n\n            for (SelectionKey key : readSelector.keys())\n            {\n                // An invalid key specifies that either the channel was closed\n                // (in which case we do not have to do anything else to it) or\n                // that we no longer control the channel (i.e. we do not want to\n                // do anything else to it).\n                if (key.isValid())\n                {\n                    Channel channel = key.channel();\n\n                    if (channel.isOpen())\n                        closeNoExceptions(channel);\n                }\n            }\n\n            try\n            {\n                readSelector.close();\n            }\n            catch (IOException ioe)\n            {\n                // ignore\n            }\n        }", "signature": "@Override\n        public void run()"}]}], "class_docstring": "\nAn abstract class that binds on a set of sockets and accepts sessions that\nstart with a STUN Binding Request (preceded by an optional fake SSL\nhandshake). The handling of the accepted sessions (e.g. handling in ICE) is\nleft to the implementations.\n\nThis instance runs two threads: {@link #acceptThread} and\n{@link #readThread}. The 'accept' thread just accepts new <tt>Socket</tt>s\nand passes them over to the 'read' thread. The 'read' thread reads a STUN\nmessage from an accepted socket and, based on the STUN username, passes it\nto the appropriate session.\n\n@author Boris Grozev\n@author Lyubomir Marinov\n", "original_string": "public abstract class AbstractTcpListener\n{\n    /**\n     * Our class logger.\n     */\n    private static final Logger logger\n        = Logger.getLogger(AbstractTcpListener.class.getName());\n\n    /**\n     * Closes a {@code Channel} and swallows any {@link IOException}.\n     *\n     * @param channel the {@code Channel} to close\n     */\n    static void closeNoExceptions(Channel channel)\n    {\n        try\n        {\n            channel.close();\n        }\n        catch (IOException ioe)\n        {\n            // The whole idea of the method is to close a specific Channel\n            // without caring about any possible IOException.\n        }\n    }\n\n    /**\n     * Returns a list of all addresses on the interfaces in <tt>interfaces</tt>\n     * which are found suitable for candidate allocations (are not loopback, are\n     * up, and are allowed by the configuration).\n     *\n     * @param port the port to use.\n     * @param interfaces the list of interfaces to use.\n     */\n    private static List<TransportAddress> getLocalAddresses(\n            int port,\n            List<NetworkInterface> interfaces)\n    {\n        List<TransportAddress> addresses = new LinkedList<>();\n\n        for (NetworkInterface iface : interfaces)\n        {\n            if (!HostCandidateHarvester.isInterfaceAllowed(iface))\n            {\n                continue;\n            }\n\n            Enumeration<InetAddress> ifaceAddresses = iface.getInetAddresses();\n\n            while (ifaceAddresses.hasMoreElements())\n            {\n                InetAddress addr = ifaceAddresses.nextElement();\n\n                addresses.add(new TransportAddress(addr, port, Transport.TCP));\n            }\n        }\n        return addresses;\n    }\n\n    /**\n     * The thread which <tt>accept</tt>s TCP connections from the sockets in\n     * {@link #serverSocketChannels}.\n     */\n    private AcceptThread acceptThread;\n\n    /**\n     * Triggers the termination of the threads of this instance.\n     */\n    private boolean close = false;\n\n    /**\n     * The list of transport addresses which we have found to be listening on,\n     * and which may be, for example, advertises as ICE candidates.\n     */\n    protected final List<TransportAddress> localAddresses = new LinkedList<>();\n\n    /**\n     * Channels pending to be added to the list that {@link #readThread} reads\n     * from.\n     */\n    private final List<SocketChannel> newChannels = new LinkedList<>();\n\n    /**\n     * The <tt>Selector</tt> used by {@link #readThread}.\n     */\n    private final Selector readSelector = Selector.open();\n\n    /**\n     * The thread which reads from the already <tt>accept</tt>ed sockets.\n     */\n    private ReadThread readThread;\n\n    /**\n     * The list of <tt>ServerSocketChannel</tt>s that we will <tt>accept</tt>\n     * on.\n     */\n    private final List<ServerSocketChannel> serverSocketChannels\n        = new LinkedList<>();\n\n    /**\n     * Initializes a new <tt>TcpHarvester</tt>, which is to\n     * listen on port number <tt>port</tt> on all IP addresses on all available\n     * interfaces.\n     *\n     * @param port the port to listen on.\n     * @throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n     * {@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\n     * if an I/O error occurs.\n     */\n    public AbstractTcpListener(int port)\n            throws IOException\n    {\n        this(port, Collections.list(NetworkInterface.getNetworkInterfaces()));\n    }\n\n    /**\n     * Initializes a new <tt>TcpHarvester</tt>, which is to listen on port\n     * number <tt>port</tt> on all the IP addresses on the specified\n     * <tt>NetworkInterface</tt>s.\n     *\n     * @param port the port to listen on.\n     * @param interfaces the interfaces to listen on.\n     * @throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n     * {@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\n     * if an I/O error occurs.\n     */\n    public AbstractTcpListener(int port, List<NetworkInterface> interfaces)\n        throws IOException\n    {\n        this(getLocalAddresses(port, interfaces));\n    }\n\n    /**\n     * Initializes a new <tt>TcpHarvester</tt>, which is to listen on the\n     * specified list of <tt>TransportAddress</tt>es.\n     *\n     * @param transportAddresses the transport addresses to listen on.\n     * @throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n     * {@link HarvestConfig#getBlockedAddresses()} contains invalid values, or\n     * if an I/O error occurs.\n     */\n    public AbstractTcpListener(List<TransportAddress> transportAddresses)\n        throws IOException\n    {\n        addLocalAddresses(transportAddresses);\n        init();\n    }\n\n    /**\n     * Adds to {@link #localAddresses} those addresses from\n     * <tt>transportAddresses</tt> which are found suitable for candidate\n     * allocation.\n     *\n     * @param transportAddresses the list of addresses to add.\n     * @throws IOException when {@link HarvestConfig#getAllowedAddresses()} or\n     * {@link HarvestConfig#getBlockedAddresses()} contains invalid values.\n     */\n    protected void addLocalAddresses(List<TransportAddress> transportAddresses)\n        throws IOException\n    {\n        for (TransportAddress transportAddress : transportAddresses)\n        {\n            if (HostCandidateHarvester.isAddressAllowed(transportAddress.getAddress()))\n            {\n                localAddresses.add(transportAddress);\n            }\n        }\n    }\n\n    /**\n     * Triggers the termination of the threads of this\n     * <tt>MultiplexingTcpHarvester</tt>.\n     */\n    public void close()\n    {\n        close = true;\n    }\n\n    /**\n     * Initializes {@link #serverSocketChannels}, creates and starts the threads\n     * used by this instance.\n     * @throws IOException if an I/O error occurs\n     */\n    protected void init()\n        throws IOException\n    {\n        boolean bindWildcard = StackProperties.getBoolean(\n                StackProperties.BIND_WILDCARD,\n                false);\n\n        // Use a set to filter out any duplicates.\n        Set<InetSocketAddress> addressesToBind = new HashSet<>();\n\n        for (TransportAddress transportAddress : localAddresses)\n        {\n            addressesToBind.add( new InetSocketAddress(\n                bindWildcard ? null : transportAddress.getAddress(),\n                transportAddress.getPort()\n            ) );\n        }\n\n        for (InetSocketAddress addressToBind : addressesToBind )\n        {\n            addSocketChannel( addressToBind );\n        }\n\n        acceptThread = new AcceptThread();\n        acceptThread.start();\n\n        readThread = new ReadThread();\n        readThread.start();\n    }\n\n    /**\n     * Initializes one of the channels in {@link #serverSocketChannels},\n     * @throws IOException if an I/O error occurs\n     */\n    private void addSocketChannel(InetSocketAddress address)\n        throws IOException\n    {\n        ServerSocketChannel channel = MuxServerSocketChannelFactory\n            .openAndBindServerSocketChannel(null, address, 0);\n\n        serverSocketChannels.add(channel);\n    }\n\n    /**\n     * Accepts a session.\n     * @param socket the {@link Socket} for the session.\n     * @param ufrag the local username fragment for the session.\n     * @param pushback the first \"datagram\" (RFC4571-framed), already read from\n     * the socket's stream.\n     */\n    protected abstract void acceptSession(\n            Socket socket, String ufrag, DatagramPacket pushback)\n        throws IOException, IllegalStateException;\n\n    /**\n     * A <tt>Thread</tt> which will accept new <tt>SocketChannel</tt>s from all\n     * <tt>ServerSocketChannel</tt>s in {@link #serverSocketChannels}.\n     */\n    private class AcceptThread\n        extends Thread\n    {\n        /**\n         * The <tt>Selector</tt> used to select a specific\n         * <tt>ServerSocketChannel</tt> which is ready to <tt>accept</tt>.\n         */\n        private final Selector selector;\n\n        /**\n         * Initializes a new <tt>AcceptThread</tt>.\n         */\n        public AcceptThread()\n            throws IOException\n        {\n            setName(\"TcpHarvester AcceptThread\");\n            setDaemon(true);\n\n            selector = Selector.open();\n            for (ServerSocketChannel channel : serverSocketChannels)\n            {\n                channel.configureBlocking(false);\n                channel.register(selector, SelectionKey.OP_ACCEPT);\n            }\n        }\n\n        /**\n         * Notifies {@link #readThread} that new channels have been added.\n         */\n        private void notifyReadThread()\n        {\n            readSelector.wakeup();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void run()\n        {\n            do\n            {\n                if (close)\n                {\n                    break;\n                }\n\n                IOException exception = null;\n                List<SocketChannel> channelsToAdd = new LinkedList<>();\n                // Allow to go on, so we can quit if closed.\n                long selectTimeout = 3000;\n\n                for (SelectionKey key : selector.keys())\n                {\n                    if (key.isValid())\n                    {\n                        SocketChannel channel;\n                        boolean acceptable = key.isAcceptable();\n\n                        try\n                        {\n                            channel\n                                = ((ServerSocketChannel) key.channel())\n                                    .accept();\n                        }\n                        catch (IOException ioe)\n                        {\n                            exception = ioe;\n                            break;\n                        }\n\n                        // Add the accepted channel to newChannels to allow the\n                        // 'read' thread to it up.\n                        if (channel != null)\n                        {\n                            channelsToAdd.add(channel);\n                        }\n                        else if (acceptable)\n                        {\n                            // The SelectionKey reported the channel as\n                            // acceptable but channel#accept() did not accept a\n                            // non-null SocketChannel. Give the channel a little\n                            // time to get its act together.\n                            selectTimeout = 100;\n                        }\n                    }\n                }\n                // We accepted from all serverSocketChannels.\n                selector.selectedKeys().clear();\n\n                if (!channelsToAdd.isEmpty())\n                {\n                    synchronized (newChannels)\n                    {\n                        newChannels.addAll(channelsToAdd);\n                    }\n                    notifyReadThread();\n                }\n\n                if (exception != null)\n                {\n                    logger.info(\n                            \"Failed to accept a socket, which should have been\"\n                                + \" ready to accept: \" + exception);\n                    break;\n                }\n\n                try\n                {\n                    // Allow to go on, so we can quit if closed.\n                    selector.select(selectTimeout);\n                }\n                catch (IOException ioe)\n                {\n                    logger.info(\n                            \"Failed to select an accept-ready socket: \" + ioe);\n                    break;\n                }\n            }\n            while (true);\n\n            //now clean up and exit\n            for (ServerSocketChannel serverSocketChannel : serverSocketChannels)\n                closeNoExceptions(serverSocketChannel);\n\n            try\n            {\n                selector.close();\n            }\n            catch (IOException ioe)\n            {\n                // ignore\n            }\n        }\n    }\n\n    /**\n     * Contains a <tt>SocketChannel</tt> that <tt>ReadThread</tt> is reading\n     * from.\n     */\n    private static class ChannelDesc\n    {\n        /**\n         * The actual <tt>SocketChannel</tt>.\n         */\n        public final SocketChannel channel;\n\n        /**\n         * The buffer which stores the data so far read from the channel.\n         */\n        ByteBuffer buffer = null;\n\n        /**\n         * Whether we had checked for initial \"pseudo\" SSL handshake.\n         */\n        boolean checkedForSSLHandshake = false;\n\n        /**\n         * Buffer to use if we had read some data in advance and want to process\n         * it after next read, used when we are checking for \"pseudo\" SSL and\n         * we haven't found some, but had read data to check for it.\n         */\n        byte[] preBuffered = null;\n\n        /**\n         * The value of the RFC4571 \"length\" field read from the channel, or\n         * -1 if it hasn't been read (yet).\n         */\n        int length = -1;\n\n        /**\n         * Initializes a new <tt>ChannelDesc</tt> with the given channel.\n         * @param channel the channel.\n         */\n        public ChannelDesc(SocketChannel channel)\n        {\n            this.channel = channel;\n        }\n    }\n\n    /**\n     * An <tt>IceSocketWrapper</tt> implementation which allows a\n     * <tt>DatagramPacket</tt> to be pushed back and received on the first call\n     * to {@link #receive(DatagramPacket)}.\n     */\n    protected static class PushBackIceSocketWrapper\n        extends IceSocketWrapper\n    {\n        /**\n         * The <tt>DatagramPacket</tt> which will be used on the first call to\n         * {@link #receive(DatagramPacket)}.\n         */\n        private DatagramPacket datagramPacket;\n\n        /**\n         * The <tt>IceSocketWrapper</tt> that this instance wraps around.\n         */\n        private final IceSocketWrapper wrapped;\n\n        /**\n         * Initializes a new <tt>PushBackIceSocketWrapper</tt> instance that\n         * wraps around <tt>wrappedWrapper</tt> and reads from\n         * <tt>datagramSocket</tt> on the first call to\n         * {@link #receive(DatagramPacket)}\n         *\n         * @param wrappedWrapper the <tt>IceSocketWrapper</tt> instance that we\n         * wrap around.\n         * @param datagramPacket the <tt>DatagramPacket</tt> which will be used\n         * on the first call to {@link #receive(DatagramPacket)}\n         */\n        public PushBackIceSocketWrapper(IceSocketWrapper wrappedWrapper,\n                                        DatagramPacket datagramPacket)\n        {\n            this.wrapped = wrappedWrapper;\n            this.datagramPacket = datagramPacket;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void close()\n        {\n            wrapped.close();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public InetAddress getLocalAddress()\n        {\n            return wrapped.getLocalAddress();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int getLocalPort()\n        {\n            return wrapped.getLocalPort();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public SocketAddress getLocalSocketAddress()\n        {\n            return wrapped.getLocalSocketAddress();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Socket getTCPSocket()\n        {\n            return wrapped.getTCPSocket();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public DatagramSocket getUDPSocket()\n        {\n            return wrapped.getUDPSocket();\n        }\n\n        /**\n         * {@inheritDoc}\n         *\n         * On the first call to this instance reads from\n         * {@link #datagramPacket}, on subsequent calls delegates to\n         * {@link #wrapped}.\n         */\n        @Override\n        public void receive(DatagramPacket p) throws IOException\n        {\n            if (datagramPacket != null)\n            {\n                int len = Math.min(p.getLength(), datagramPacket.getLength());\n                System.arraycopy(datagramPacket.getData(), 0,\n                                 p.getData(), 0,\n                                 len);\n                p.setAddress(datagramPacket.getAddress());\n                p.setPort(datagramPacket.getPort());\n                datagramPacket = null;\n            }\n            else\n            {\n                wrapped.receive(p);\n            }\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void send(DatagramPacket p) throws IOException\n        {\n            wrapped.send(p);\n        }\n    }\n\n    private class ReadThread\n        extends Thread\n    {\n        /**\n         * Initializes a new <tt>ReadThread</tt>.\n         */\n        public ReadThread()\n        {\n            setName(\"TcpHarvester ReadThread\");\n            setDaemon(true);\n        }\n\n        /**\n         * Registers the channels from {@link #newChannels} in\n         * {@link #readSelector}.\n         */\n        private void checkForNewChannels()\n        {\n            synchronized (newChannels)\n            {\n                for (SocketChannel channel : newChannels)\n                {\n                    try\n                    {\n                        channel.configureBlocking(false);\n                        channel.register(\n                                readSelector,\n                                SelectionKey.OP_READ,\n                                new ChannelDesc(channel));\n                    }\n                    catch (IOException ioe)\n                    {\n                        logger.info(\"Failed to register channel: \" + ioe);\n                        closeNoExceptions(channel);\n                    }\n                }\n                newChannels.clear();\n            }\n        }\n\n        /**\n         * Tries to read, without blocking, from <tt>channel</tt> to its\n         * buffer. If after reading the buffer is filled, handles the data in\n         * the buffer.\n         *\n         * This works in three stages:\n         * 1 (optional): Read a fixed-size message. If it matches the\n         * hard-coded pseudo SSL ClientHello, sends the hard-coded ServerHello.\n         * 2: Read two bytes as an unsigned int and interpret it as the length\n         * to read in the next stage.\n         * 3: Read number of bytes indicated in stage2 and try to interpret\n         * them as a STUN message.\n         *\n         * If a datagram is successfully read it is passed on to\n         * {@link #processFirstDatagram(byte[], ChannelDesc, SelectionKey)}\n         *\n         * @param channel the <tt>SocketChannel</tt> to read from.\n         * @param key the <tt>SelectionKey</tt> associated with\n         * <tt>channel</tt>, which is to be canceled in case no further\n         * reading is required from the channel.\n         */\n        private void readFromChannel(ChannelDesc channel, SelectionKey key)\n        {\n            if (channel.buffer == null)\n            {\n                // Set up a buffer with a pre-determined size\n\n                if (!channel.checkedForSSLHandshake && channel.length == -1)\n                {\n                    channel.buffer\n                        = ByteBuffer.allocate(\n                                GoogleTurnSSLCandidateHarvester\n                                    .SSL_CLIENT_HANDSHAKE.length);\n                }\n                else if (channel.length == -1)\n                {\n                    channel.buffer = ByteBuffer.allocate(2);\n                }\n                else\n                {\n                    channel.buffer = ByteBuffer.allocate(channel.length);\n                }\n            }\n\n            try\n            {\n                int read = channel.channel.read(channel.buffer);\n\n                if (read == -1)\n                    throw new IOException(\"End of stream!\");\n\n                if (!channel.buffer.hasRemaining())\n                {\n                    // We've filled in the buffer.\n                    if (!channel.checkedForSSLHandshake)\n                    {\n                        byte[] bytesRead\n                            = new byte[GoogleTurnSSLCandidateHarvester\n                                .SSL_CLIENT_HANDSHAKE.length];\n\n                        channel.buffer.flip();\n                        channel.buffer.get(bytesRead);\n\n                        // Set to null, so that we re-allocate it for the next\n                        // stage\n                        channel.buffer = null;\n                        channel.checkedForSSLHandshake = true;\n\n                        if (Arrays.equals(bytesRead,\n                                          GoogleTurnSSLCandidateHarvester\n                                                  .SSL_CLIENT_HANDSHAKE))\n                        {\n                            ByteBuffer byteBuffer = ByteBuffer.wrap(\n                                    GoogleTurnSSLCandidateHarvester\n                                            .SSL_SERVER_HANDSHAKE);\n                            channel.channel.write(byteBuffer);\n                        }\n                        else\n                        {\n                            int fb = bytesRead[0];\n                            int sb = bytesRead[1];\n\n                            channel.length = (((fb & 0xff) << 8) | (sb & 0xff));\n\n                            byte[] preBuffered\n                                = Arrays.copyOfRange(\n                                    bytesRead, 2, bytesRead.length);\n\n                            // if we had read enough data\n                            if (channel.length <= bytesRead.length - 2)\n                            {\n                                processFirstDatagram(\n                                    preBuffered, channel, key);\n                            }\n                            else\n                            {\n                                // not enough data, store what was read\n                                // and continue\n                                channel.preBuffered = preBuffered;\n\n                                channel.length -= channel.preBuffered.length;\n                            }\n                        }\n                    }\n                    else if (channel.length == -1)\n                    {\n                        channel.buffer.flip();\n\n                        int fb = channel.buffer.get();\n                        int sb = channel.buffer.get();\n\n                        channel.length = (((fb & 0xff) << 8) | (sb & 0xff));\n\n                        // Set to null, so that we re-allocate it for the next\n                        // stage\n                        channel.buffer = null;\n                    }\n                    else\n                    {\n                        byte[] bytesRead = new byte[channel.length];\n\n                        channel.buffer.flip();\n                        channel.buffer.get(bytesRead);\n\n                        if (channel.preBuffered != null)\n                        {\n                            // will store preBuffered and currently read data\n                            byte[] newBytesRead = new byte[\n                                channel.preBuffered.length + bytesRead.length];\n\n                            // copy old data\n                            System.arraycopy(\n                                channel.preBuffered, 0,\n                                newBytesRead, 0,\n                                channel.preBuffered.length);\n                            // and new data\n                            System.arraycopy(\n                                bytesRead, 0,\n                                newBytesRead, channel.preBuffered.length,\n                                bytesRead.length);\n\n                            // use that data for processing\n                            bytesRead = newBytesRead;\n\n                            channel.preBuffered = null;\n                        }\n\n                        processFirstDatagram(bytesRead, channel, key);\n                    }\n                }\n            }\n            catch (Exception e)\n            {\n                // The ReadThread should continue running no matter what\n                // exceptions occur in the code above (we've observed exceptions\n                // due to failures to allocate resources) because otherwise\n                // the #newChannels list is never pruned leading to a leak of\n                // sockets.\n                logger.info(\n                        \"Failed to handle TCP socket \"\n                            + channel.channel.socket() + \": \" + e.getMessage());\n                key.cancel();\n                closeNoExceptions(channel.channel);\n            }\n        }\n\n        /**\n         * Process the first RFC4571-framed datagram read from a socket.\n         *\n         * If the datagram contains a STUN Binding Request, and it has a\n         * USERNAME attribute, the local &quot;ufrag&quot; is extracted from the\n         * attribute value, and the socket is passed to\n         * {@link #acceptSession(Socket, String, DatagramPacket)}.\n         *\n         * @param bytesRead bytes to be processed\n         * @param channel the <tt>SocketChannel</tt> to read from.\n         * @param key the <tt>SelectionKey</tt> associated with\n         * <tt>channel</tt>, which is to be canceled in case no further\n         * reading is required from the channel.\n         * @throws IOException if the datagram does not contain s STUN Binding\n         * Request with a USERNAME attribute.\n         * @throws IllegalStateException if the session for the extracted\n         * username fragment cannot be accepted for implementation reasons\n         * (e.g. no ICE Agent with the given local ufrag is found).\n         */\n        private void processFirstDatagram(\n            byte[] bytesRead,\n            ChannelDesc channel, SelectionKey key)\n            throws IOException, IllegalStateException\n        {\n            // Does this look like a STUN binding request?\n            // What's the username?\n            String ufrag\n                = AbstractUdpListener.getUfrag(bytesRead,\n                                               (char) 0,\n                                               (char) bytesRead.length);\n\n            if (ufrag == null)\n            {\n                throw new IOException(\"Cannot extract ufrag\");\n            }\n\n            // The rest of the stack will read from the socket's\n            // InputStream. We cannot change the blocking mode\n            // before the channel is removed from the selector (by\n            // cancelling the key)\n            key.cancel();\n            channel.channel.configureBlocking(true);\n\n            // Construct a DatagramPacket from the just-read packet\n            // which is to be pushed back\n            DatagramPacket p\n                = new DatagramPacket(bytesRead, bytesRead.length);\n            Socket socket = channel.channel.socket();\n\n            p.setAddress(socket.getInetAddress());\n            p.setPort(socket.getPort());\n\n            acceptSession(socket, ufrag, p);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void run()\n        {\n            do\n            {\n                synchronized (AbstractTcpListener.this)\n                {\n                    if (close)\n                        break;\n                }\n\n                checkForNewChannels();\n\n                for (SelectionKey key : readSelector.keys())\n                {\n                    if (key.isValid())\n                    {\n                        ChannelDesc channelDesc\n                            = (ChannelDesc) key.attachment();\n\n                        readFromChannel(channelDesc, key);\n                    }\n                }\n                // We read from all SocketChannels.\n                readSelector.selectedKeys().clear();\n\n                try\n                {\n                    readSelector.select(\n                            MuxServerSocketChannelFactory\n                                    .SOCKET_CHANNEL_READ_TIMEOUT\n                                / 2);\n                }\n                catch (IOException ioe)\n                {\n                    logger.info(\"Failed to select a read-ready channel.\");\n                }\n            }\n            while (true);\n\n            //we are all done, clean up.\n            synchronized (newChannels)\n            {\n                for (SocketChannel channel : newChannels)\n                {\n                    closeNoExceptions(channel);\n                }\n                newChannels.clear();\n            }\n\n            for (SelectionKey key : readSelector.keys())\n            {\n                // An invalid key specifies that either the channel was closed\n                // (in which case we do not have to do anything else to it) or\n                // that we no longer control the channel (i.e. we do not want to\n                // do anything else to it).\n                if (key.isValid())\n                {\n                    Channel channel = key.channel();\n\n                    if (channel.isOpen())\n                        closeNoExceptions(channel);\n                }\n            }\n\n            try\n            {\n                readSelector.close();\n            }\n            catch (IOException ioe)\n            {\n                // ignore\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(AbstractTcpListener.class.getName());", "docstring": "\nOur class logger.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(AbstractTcpListener.class.getName())", "syntax_pass": true}, {"attribute_expression": "private AcceptThread acceptThread;", "docstring": "\nThe thread which <tt>accept</tt>s TCP connections from the sockets in\n{@link #serverSocketChannels}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "AcceptThread", "name": "acceptThread", "syntax_pass": true}, {"attribute_expression": "private boolean close = false;", "docstring": "\nTriggers the termination of the threads of this instance.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "close = false", "syntax_pass": true}, {"attribute_expression": "protected final List<TransportAddress> localAddresses = new LinkedList<>();", "docstring": "\nThe list of transport addresses which we have found to be listening on,\nand which may be, for example, advertises as ICE candidates.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "List<TransportAddress>", "name": "localAddresses = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private final List<SocketChannel> newChannels = new LinkedList<>();", "docstring": "\nChannels pending to be added to the list that {@link #readThread} reads\nfrom.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<SocketChannel>", "name": "newChannels = new LinkedList<>()", "syntax_pass": true}, {"attribute_expression": "private final Selector readSelector = Selector.open();", "docstring": "\nThe <tt>Selector</tt> used by {@link #readThread}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Selector", "name": "readSelector = Selector.open()", "syntax_pass": true}, {"attribute_expression": "private ReadThread readThread;", "docstring": "\nThe thread which reads from the already <tt>accept</tt>ed sockets.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ReadThread", "name": "readThread", "syntax_pass": true}, {"attribute_expression": "private final List<ServerSocketChannel> serverSocketChannels\n        = new LinkedList<>();", "docstring": "\nThe list of <tt>ServerSocketChannel</tt>s that we will <tt>accept</tt>\non.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<ServerSocketChannel>", "name": "serverSocketChannels\n        = new LinkedList<>()", "syntax_pass": true}]}, {"uris": "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper", "name": "IceSocketWrapper", "file_path": "src/main/java/org/ice4j/socket/IceSocketWrapper.java", "superclasses": "", "methods": ["[void]send(DatagramPacket)", "[void]receive(DatagramPacket)", "[void]close()", "[InetAddress]getLocalAddress()", "[int]getLocalPort()", "[SocketAddress]getLocalSocketAddress()", "[Socket]getTCPSocket()", "[DatagramSocket]getUDPSocket()"], "method_uris": ["src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[void]send(DatagramPacket)", "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[void]receive(DatagramPacket)", "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[void]close()", "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[InetAddress]getLocalAddress()", "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[int]getLocalPort()", "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[SocketAddress]getLocalSocketAddress()", "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[Socket]getTCPSocket()", "src/main/java/org/ice4j/socket/IceSocketWrapper.java.IceSocketWrapper.[DatagramSocket]getUDPSocket()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract socket wrapper that define a socket that could be UDP, TCP...\n\n@author Sebastien Vincent\n", "original_string": "public abstract class IceSocketWrapper\n{\n    /**\n     * Sends a <tt>DatagramPacket</tt> from this socket\n     * It is a utility method to provide a common way to send for both\n     * UDP and TCP socket. If the underlying socket is a TCP one, it is still\n     * possible to get the <tt>OutputStream</tt> and do stuff with it.\n     *\n     *\n     * @param p <tt>DatagramPacket</tt> to send\n     * @throws IOException if something goes wrong\n     */\n    public abstract void send(DatagramPacket p)\n        throws IOException;\n\n    /**\n     * Receives a <tt>DatagramPacket</tt> from this socket.\n     * It is a utility method to provide a common way to receive for both\n     * UDP and TCP socket. If the underlying socket is a TCP one, it is still\n     * possible to get the <tt>InputStream</tt> and do stuff with it.\n     *\n     * @param p <tt>DatagramPacket</tt>\n     * @throws IOException if something goes wrong\n     */\n    public abstract void receive(DatagramPacket p)\n        throws IOException;\n\n    /**\n     * Closes this socket.\n     */\n    public abstract void close();\n\n    /**\n     * Get local address.\n     *\n     * @return local address\n     */\n    public abstract InetAddress getLocalAddress();\n\n    /**\n     * Get local port.\n     *\n     * @return local port\n     */\n    public abstract int getLocalPort();\n\n    /**\n     * Get socket address.\n     *\n     * @return socket address\n     */\n    public abstract SocketAddress getLocalSocketAddress();\n\n    /**\n     * Returns Socket object if the delegate socket is a TCP one, null\n     * otherwise.\n     *\n     * @return Socket object if the delegate socket is a TCP one, null\n     * otherwise.\n     */\n    public abstract Socket getTCPSocket();\n\n    /**\n     * Returns DatagramSocket object if the delegate socket is a UDP one, null\n     * otherwise.\n     *\n     * @return DatagramSocket object if the delegate socket is a UDP one, null\n     * otherwise.\n     */\n    public abstract DatagramSocket getUDPSocket();\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport", "name": "MultiplexingXXXSocketSupport", "file_path": "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java", "superclasses": "", "methods": ["[DatagramPacket]clone(DatagramPacket)", "[DatagramPacket]clone(DatagramPacket,boolean)", "[void]copy(DatagramPacket,DatagramPacket)", "[]MultiplexingXXXSocketSupport()", "[void]acceptBySocketsOrThis(DatagramPacket)", "[boolean]close(MultiplexedXXXSocketT)", "[MultiplexedXXXSocketT]createSocket(DatagramPacketFilter)", "[void]doReceive(DatagramPacket)", "[void]doSetReceiveBufferSize(int)", "[DatagramPacketFilter]getFilter(MultiplexedXXXSocketT)", "[SocketReceiveBuffer]getReceived()", "[SocketReceiveBuffer]getReceived(MultiplexedXXXSocketT)", "[MultiplexedXXXSocketT]getSocket(DatagramPacketFilter)", "[MultiplexedXXXSocketT]getSocket(DatagramPacketFilter,boolean)", "[void]moveReceivedFromThisToSocket(MultiplexedXXXSocketT)", "[void]receive(SocketReceiveBuffer,DatagramPacket,int)", "[void]setReceiveBufferSize(int)"], "method_uris": ["src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[DatagramPacket]clone(DatagramPacket)", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[DatagramPacket]clone(DatagramPacket,boolean)", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[void]copy(DatagramPacket,DatagramPacket)", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[]MultiplexingXXXSocketSupport()", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[void]acceptBySocketsOrThis(DatagramPacket)", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[boolean]close(MultiplexedXXXSocketT)", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[MultiplexedXXXSocketT]createSocket(DatagramPacketFilter)", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[void]doReceive(DatagramPacket)", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[void]doSetReceiveBufferSize(int)", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[DatagramPacketFilter]getFilter(MultiplexedXXXSocketT)", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[SocketReceiveBuffer]getReceived()", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[SocketReceiveBuffer]getReceived(MultiplexedXXXSocketT)", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[MultiplexedXXXSocketT]getSocket(DatagramPacketFilter)", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[MultiplexedXXXSocketT]getSocket(DatagramPacketFilter,boolean)", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[void]moveReceivedFromThisToSocket(MultiplexedXXXSocketT)", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[void]receive(SocketReceiveBuffer,DatagramPacket,int)", "src/main/java/org/ice4j/socket/MultiplexingXXXSocketSupport.java.MultiplexingXXXSocketSupport.[void]setReceiveBufferSize(int)"], "overrides": null, "attributes": [], "class_docstring": "\nImplements functionality common to TCP and UDP implementations of\n(de)multiplexing sockets i.e. sockets which provide\n{@code DatagramPacket}-based views of the packets they receive in the forms\nof pseudo sockets.\n\n@author Lyubomir Marinov\n", "original_string": "abstract class MultiplexingXXXSocketSupport\n        <MultiplexedXXXSocketT extends MultiplexedXXXSocket>\n{\n    /**\n     * The {@code Logger} used by the {@code MultiplexingXXXSocketSupport} class\n     * and its instances for logging output.\n     */\n    private static final Logger logger\n        = Logger.getLogger(MultiplexingXXXSocketSupport.class.getName());\n\n    /**\n     * Initializes a new <tt>DatagramPacket</tt> instance which is a clone of a\n     * specific <tt>DatagramPacket</tt> i.e. the properties of the clone\n     * <tt>DatagramPacket</tt> are clones of the specified\n     * <tt>DatagramPacket</tt>.\n     *\n     * @param p the <tt>DatagramPacket</tt> to clone\n     * @return a new <tt>DatagramPacket</tt> instance which is a clone of the\n     * specified <tt>DatagramPacket</tt>\n     */\n    public static DatagramPacket clone(DatagramPacket p)\n    {\n        return clone(p, /* arraycopy */ true);\n    }\n\n    /**\n     * Initializes a new <tt>DatagramPacket</tt> instance which is a clone of a\n     * specific <tt>DatagramPacket</tt> i.e. the properties of the clone\n     * <tt>DatagramPacket</tt> are clones of the specified\n     * <tt>DatagramPacket</tt>.\n     *\n     * @param p the <tt>DatagramPacket</tt> to clone\n     * @param arraycopy <tt>true</tt> if the actual bytes of the data of\n     * <tt>p</tt> are to be copied into the clone or <tt>false</tt> if only the\n     * capacity of the data of <tt>p</tt> is to be cloned without copying the\n     * actual bytes of the data of <tt>p</tt>\n     * @return a new <tt>DatagramPacket</tt> instance which is a clone of the\n     * specified <tt>DatagramPacket</tt>\n     */\n    private static DatagramPacket clone(DatagramPacket p, boolean arraycopy)\n    {\n        byte[] data;\n        int off;\n        int len;\n        InetAddress address;\n        int port;\n\n        synchronized (p)\n        {\n            data = p.getData();\n            off = p.getOffset();\n            len = p.getLength();\n\n            // Clone the data.\n            {\n                // The capacity of the specified p is preserved.\n                byte[] dataClone = new byte[data.length];\n\n                // However, only copy the range of data starting with off and\n                // spanning len number of bytes. Of course, preserve off and len\n                // in addition to the capacity.\n                if (arraycopy && (len > 0))\n                {\n                    int arraycopyOff, arraycopyLen;\n\n                    // If off and/or len are going to cause an exception though,\n                    // copy the whole data.\n                    if ((off >= 0)\n                            && (off < data.length)\n                            && (off + len <= data.length))\n                    {\n                        arraycopyOff = off;\n                        arraycopyLen = len;\n                    }\n                    else\n                    {\n                        arraycopyOff = 0;\n                        arraycopyLen = data.length;\n                    }\n                    System.arraycopy(\n                            data, arraycopyOff,\n                            dataClone, arraycopyOff,\n                            arraycopyLen);\n                }\n                data = dataClone;\n            }\n\n            address = p.getAddress();\n            port = p.getPort();\n        }\n\n        DatagramPacket c = new DatagramPacket(data, off, len);\n\n        if (address != null)\n            c.setAddress(address);\n        if (port >= 0)\n            c.setPort(port);\n\n        return c;\n    }\n\n    /**\n     * Copies the properties of a specific <tt>DatagramPacket</tt> to another\n     * <tt>DatagramPacket</tt>. The property values are not cloned.\n     *\n     * @param src the <tt>DatagramPacket</tt> which is to have its properties\n     * copied to <tt>dest</tt>\n     * @param dest the <tt>DatagramPacket</tt> which is to have its properties\n     * set to the value of the respective properties of <tt>src</tt>\n     */\n    public static void copy(DatagramPacket src, DatagramPacket dest)\n    {\n        synchronized (dest)\n        {\n            dest.setAddress(src.getAddress());\n            dest.setPort(src.getPort());\n\n            byte[] srcData = src.getData();\n\n            if (srcData == null)\n            {\n                dest.setLength(0);\n            }\n            else\n            {\n                byte[] destData = dest.getData();\n\n                if (destData == null)\n                {\n                    dest.setLength(0);\n                }\n                else\n                {\n                    int destOffset = dest.getOffset();\n                    int destLength = destData.length - destOffset;\n                    int srcLength = src.getLength();\n\n                    if (destLength >= srcLength)\n                    {\n                        destLength = srcLength;\n                    }\n                    else if (logger.isLoggable(Level.WARNING))\n                    {\n                        logger.log(\n                                Level.WARNING,\n                                \"Truncating received DatagramPacket data!\");\n                    }\n                    System.arraycopy(\n                            srcData, src.getOffset(),\n                            destData, destOffset,\n                            destLength);\n                    dest.setLength(destLength);\n                }\n            }\n        }\n    }\n\n    /**\n     * The max number of {@link DatagramPacket}'s stored in the receive pool.\n     */\n    private static final int RECEIVE_DATAGRAM_PACKETS_POOL_SIZE = 64;\n\n    /**\n     * The buffer size of pooled datagram packet used to read from\n     * underlying socket.\n     */\n    private static final int POOLED_DATAGRAM_PACKET_SIZE = 1500;\n\n    /**\n     * A pool of {@link DatagramPacket}s used to receive data from unrelying\n     * socket.\n     */\n    private final BlockingQueue<DatagramPacket> receiveDatagramPacketsPool\n        = new ArrayBlockingQueue<>(RECEIVE_DATAGRAM_PACKETS_POOL_SIZE);\n\n    /**\n     * The indicator which determines whether this <tt>DatagramSocket</tt> is\n     * currently reading from the network using\n     * {@link DatagramSocket#receive(DatagramPacket)}. When <tt>true</tt>,\n     * subsequent requests to read from the network will be blocked until the\n     * current read is finished.\n     */\n    private boolean inReceive = false;\n\n    /**\n     * The value with which {@link DatagramSocket#setReceiveBufferSize(int)} is\n     * to be invoked if {@link #setReceiveBufferSize} is <tt>true</tt>. \n     */\n    private int receiveBufferSize;\n\n    /**\n     * The <tt>Object</tt> which synchronizes the access to {@link #inReceive}.\n     */\n    private final Object receiveSyncRoot = new Object();\n\n    /**\n     * The indicator which determines whether\n     * {@link DatagramSocket#setReceiveBufferSize(int)} is to be invoked with\n     * the value of {@link #receiveBufferSize}.\n     */\n    private boolean setReceiveBufferSize = false;\n\n    /**\n     * The IP sockets filtering {@code DatagramPacket}s away from this IP\n     * socket.\n     */\n    private final List<MultiplexedXXXSocketT> sockets = new ArrayList<>();\n\n    /**\n     * Initializes a new {@code MultiplexingXXXSocketSupport} instance.\n     */\n    protected MultiplexingXXXSocketSupport()\n    {\n    }\n\n    /**\n     * Accepts a {@code DatagramPacket} received by this socket and queues it\n     * for receipt through either this multiplexing socket or its multiplexed\n     * sockets whose {@code DatagramPacketFilter}s accept {@code p}.\n     *\n     * @param p the {@code DatagramPacket} to be accepted by either this\n     * multiplexing socket or its multiplexed sockets whose\n     * {@code DatagramPacketFilter}s accept {@code p}\n     */\n    private void acceptBySocketsOrThis(DatagramPacket p)\n    {\n        synchronized (sockets)\n        {\n            boolean accepted = false;\n\n            for (MultiplexedXXXSocketT socket : sockets)\n            {\n                if (getFilter(socket).accept(p))\n                {\n                    SocketReceiveBuffer socketReceived = getReceived(socket);\n\n                    synchronized (socketReceived)\n                    {\n                        socketReceived.add(\n                                accepted ? clone(p, /* arraycopy */ true) : p);\n                        socketReceived.notifyAll();\n                    }\n                    accepted = true;\n\n                    // Emil Ivov: Don't break because we want all\n                    // filtering sockets to get the received packet.\n                }\n            }\n            if (!accepted)\n            {\n                SocketReceiveBuffer thisReceived = getReceived();\n\n                synchronized (thisReceived)\n                {\n                    thisReceived.add(p);\n                    thisReceived.notifyAll();\n                }\n            }\n        }\n    }\n\n    /**\n     * Closes a specific <tt>MultiplexedDatagramSocket</tt> which filters\n     * <tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt>.\n     *\n     * @param multiplexed the <tt>MultiplexedDatagramSocket</tt> to close\n     * @return {@code true} if there are remaining filtered sockets.\n     */\n    boolean close(MultiplexedXXXSocketT multiplexed)\n    {\n        synchronized (sockets)\n        {\n            sockets.remove(multiplexed);\n\n            return !sockets.isEmpty();\n        }\n    }\n\n    /**\n     * Initializes a new multiplexed socket instance which is to be associated\n     * with a specific {@code DatagramPacketFilter}.\n     *\n     * @param filter the {@code DatagramPacketFilter} to associate with the new\n     * instance\n     * @return a new multiplexed socket associated with the specified\n     * {@code filter}\n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as a TCP or UDP error\n     */\n    protected abstract MultiplexedXXXSocketT createSocket(\n            DatagramPacketFilter filter)\n        throws SocketException;\n\n    /**\n     * Receives a {@code DatagramPacket} from this socket.\n     *\n     * @param p the {@code DatagramPacket} into which to place the incoming data\n     * @throws IOException if an I/O error occurs\n     */\n    protected abstract void doReceive(DatagramPacket p)\n        throws IOException;\n\n    /**\n     * Sets the {@code SO_RCVBUF} option to the specified value for this\n     * {@code DatagramSocket}. The {@code SO_RCVBUF} option is used by the\n     * network implementation as a hint to size the underlying network I/O\n     * buffers. The {@code SO_RCVBUF} setting may also be used by the network\n     * implementation to determine the maximum size of the packet that can be\n     * received on this socket.\n     *\n     * @param receiveBufferSize the size to which to set the receive buffer size\n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as a UDP error\n     */\n    protected abstract void doSetReceiveBufferSize(int receiveBufferSize)\n        throws SocketException;\n\n    /**\n     * Gets the {@code DatagramPacketFilter} associated with a specific\n     * multiplexed socket.\n     *\n     * @param socket the multiplexed socket whose associated\n     * {@code DatagramPacketFilter} is to be retrieved\n     * @return the {@code DatagramPacketFilter} associated with {@code socket}\n     */\n    protected DatagramPacketFilter getFilter(MultiplexedXXXSocketT socket)\n    {\n        return socket.getFilter();\n    }\n\n    /**\n     * Gets the list of {@code DatagramPacket}s received by this socket and not\n     * accepted by any (existing) {@code DatagramPacketFilter} at the time of\n     * receipt.\n     *\n     * @return the list of {@code DatagramPacket}s received by this socket and\n     * not accepted by any (existing) {@code DatagramPacketFilter} at the time of\n     * receipt\n     */\n    protected abstract SocketReceiveBuffer getReceived();\n\n    /**\n     * Gets the list of {@code DatagramPacket}s received by this multiplexing\n     * socket and accepted by the {@code DatagramPacketFilter} of a specific\n     * multiplexed socket at the time of receipt.\n     *\n     * @param socket the multiplexed socket whose list of accepted received\n     * {@code DatagramPacket}s is to be returned\n     * @return the list of {@code DatagramPacket}s received by this multiplexing\n     * socket and accepted by the {@code DatagramPacketFilter} of the\n     * multiplexed {@code socket} at the time of receipt\n     */\n    protected abstract SocketReceiveBuffer getReceived(\n            MultiplexedXXXSocketT socket);\n\n    /**\n     * Gets a <tt>MultiplexedDatagramSocket</tt> which filters\n     * <tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using a\n     * specific <tt>DatagramPacketFilter</tt>. If such a\n     * <tt>MultiplexedDatagramSocket</tt> does not exist in this instance, it is\n     * created.\n     *\n     * @param filter the <tt>DatagramPacketFilter</tt> to get a\n     * <tt>MultiplexedDatagramSocket</tt> for\n     * @return a <tt>MultiplexedDatagramSocket</tt> which filters\n     * <tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using the\n     * specified <tt>filter</tt>\n     * @throws SocketException if creating the\n     * <tt>MultiplexedDatagramSocket</tt> for the specified <tt>filter</tt>\n     * fails\n     */\n    public MultiplexedXXXSocketT getSocket(DatagramPacketFilter filter)\n        throws SocketException\n    {\n        return getSocket(filter, /* create */ true);\n    }\n\n    /**\n     * Gets a <tt>MultiplexedDatagramSocket</tt> which filters\n     * <tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using a\n     * specific <tt>DatagramPacketFilter</tt>. If <tt>create</tt> is true and\n     * such a <tt>MultiplexedDatagramSocket</tt> does not exist in this\n     * instance, it is created.\n     *\n     * @param filter the <tt>DatagramPacketFilter</tt> to get a\n     * <tt>MultiplexedDatagramSocket</tt> for\n     * @param create whether or not to create a\n     * <tt>MultiplexedDatagramSocket</tt> if this instance does not already have\n     * a socket for the given <tt>filter</tt>.\n     * @return a <tt>MultiplexedDatagramSocket</tt> which filters\n     * <tt>DatagramPacket</tt>s away from this <tt>DatagramSocket</tt> using the\n     * specified <tt>filter</tt>\n     * @throws SocketException if creating the\n     * <tt>MultiplexedDatagramSocket</tt> for the specified <tt>filter</tt>\n     * fails.\n     */\n    public MultiplexedXXXSocketT getSocket(\n            DatagramPacketFilter filter,\n            boolean create)\n        throws SocketException\n    {\n        if (filter == null)\n            throw new NullPointerException(\"filter\");\n\n        synchronized (sockets)\n        {\n            // If a socket for the specified filter exists already, do not\n            // create a new one and return the existing.\n            for (MultiplexedXXXSocketT socket : sockets)\n            {\n                if (filter.equals(getFilter(socket)))\n                    return socket;\n            }\n\n            if (!create)\n                return null;\n\n            // Create a new socket for the specified filter.\n            MultiplexedXXXSocketT socket = createSocket(filter);\n\n            // Remember the new socket.\n            if (socket != null)\n            {\n                sockets.add(socket);\n\n                // A multiplexed socket may be created after packets matching\n                // its filter have been received. Pull them out of the\n                // multiplexing socket and into the newly-created multiplexed\n                // socket.\n\n                // XXX The fields received of both the multiplexed and the\n                // multiplexing sockets are used as synchronization roots (e.g.\n                // the method acceptBySocketsOrThis). In order to preserve the\n                // order of acquiring synchronization roots, perform the\n                // following procedure under the protection of the field\n                // socketsSyncRoot even though the field sockets will not be\n                // accessed.\n                moveReceivedFromThisToSocket(socket);\n            }\n\n            return socket;\n        }\n    }\n\n    /**\n     * Moves packets which have been received from this multiplexing socket to\n     * a specific multiplexed socket if they are accepted by the\n     * {@code DatagramPacketFilter} of the latter.\n     *\n     * @param socket the multiplexed socket into which received packets are to\n     * be moved from this multiplexing socket if they are accepted by the\n     * {@code DatagramPacketFilter} of the former\n     */\n    private void moveReceivedFromThisToSocket(MultiplexedXXXSocketT socket)\n    {\n        // Pull the packets which have been received already and are accepted by\n        // the specified multiplexed socket out of the multiplexing socket.\n        final SocketReceiveBuffer thisReceived = getReceived();\n        final DatagramPacketFilter socketFilter = getFilter(socket);\n        final List<DatagramPacket> toMove;\n\n        synchronized (thisReceived)\n        {\n            toMove = thisReceived.scan(socketFilter);\n        }\n\n        // Push the packets which have been accepted already and are accepted by\n        // the specified multiplexed socket into the multiplexed socket in\n        // question.\n        if (!toMove.isEmpty())\n        {\n            final SocketReceiveBuffer socketReceived = getReceived(socket);\n\n            synchronized (socketReceived)\n            {\n                for (DatagramPacket datagramPacket : toMove) {\n                    socketReceived.add(datagramPacket);\n                }\n                // The notifyAll will practically likely be unnecessary because\n                // the specified socket will likely be a newly-created one to\n                // which noone else has a reference. Anyway, dp the invocation\n                // for the purposes of consistency, clarity, and such.\n                socketReceived.notifyAll();\n            }\n        }\n    }\n\n    /**\n     * Receives a <tt>DatagramPacket</tt> from a specific list of\n     * <tt>DatagramPacket</tt>s if it is not empty or from the network if the\n     * specified list is empty. When this method returns, the\n     * <tt>DatagramPacket</tt>'s buffer is filled with the data received. The\n     * datagram packet also contains the sender's IP address, and the port\n     * number on the sender's machine.\n     *\n     * @param received the list of previously received <tt>DatagramPacket</tt>\n     * from which the first is to be removed and returned if available\n     * @param p the <tt>DatagramPacket</tt> into which to place the incoming\n     * data\n     * @param timeout the maximum time in milliseconds to wait for a\n     * packet. A timeout of zero is interpreted as an infinite\n     * timeout\n     * @throws IOException if an I/O error occurs\n     * @throws SocketTimeoutException if <tt>timeout</tt> is positive and has\n     * expired\n     */\n    void receive(SocketReceiveBuffer received, DatagramPacket p, int timeout)\n        throws IOException\n    {\n        long startTime = System.currentTimeMillis();\n        DatagramPacket receivedPacket;\n\n        do\n        {\n            long now = System.currentTimeMillis();\n\n            // If there is a packet which has been received from the network and\n            // is to merely be received from the list of received\n            // DatagramPackets, then let it be received and do not throw a\n            // SocketTimeoutException.\n            synchronized (received)\n            {\n                receivedPacket = received.poll();\n                if (receivedPacket != null)\n                    break;\n            }\n\n            // Throw a SocketTimeoutException if the timeout is over/up.\n            long remainingTimeout;\n\n            if (timeout > 0)\n            {\n                remainingTimeout = timeout - (now - startTime);\n                if (remainingTimeout <= 0L)\n                {\n                    throw new SocketTimeoutException(\n                            Long.toString(remainingTimeout));\n                }\n            }\n            else\n            {\n                remainingTimeout = 1000L;\n            }\n\n            // Determine whether the caller will receive from the network or\n            // will wait for a previous caller to receive from the network.\n            boolean wait;\n\n            synchronized (receiveSyncRoot)\n            {\n                if (inReceive)\n                {\n                    wait = true;\n                }\n                else\n                {\n                    wait = false;\n                    inReceive = true;\n                }\n            }\n            try\n            {\n                if (wait)\n                {\n                    // The caller will wait for a previous caller to receive\n                    // from the network.\n                    synchronized (received)\n                    {\n                        if (received.isEmpty())\n                        {\n                            try\n                            {\n                                received.wait(remainingTimeout);\n                            }\n                            catch (InterruptedException ie)\n                            {\n                            }\n                        }\n                        else\n                        {\n                            received.notifyAll();\n                        }\n                    }\n                    continue;\n                }\n\n                // The pooled datagram packet instance will be used to receive\n                // from the network.\n                DatagramPacket receivePacket\n                    = receiveDatagramPacketsPool.poll();\n                if (receivePacket == null)\n                {\n                    receivePacket = new DatagramPacket(\n                        new byte[POOLED_DATAGRAM_PACKET_SIZE],\n                        POOLED_DATAGRAM_PACKET_SIZE);\n                }\n\n                receivePacket.setLength(POOLED_DATAGRAM_PACKET_SIZE);\n\n                synchronized (receiveSyncRoot)\n                {\n                    if (setReceiveBufferSize)\n                    {\n                        setReceiveBufferSize = false;\n                        try\n                        {\n                            doSetReceiveBufferSize(receiveBufferSize);\n                        }\n                        catch (Throwable t)\n                        {\n                            if (t instanceof ThreadDeath)\n                                throw (ThreadDeath) t;\n                        }\n                    }\n                }\n                doReceive(receivePacket);\n\n                // The caller received from the network. Copy/add the packet to\n                // the receive list of the sockets which accept it.\n                acceptBySocketsOrThis(receivePacket);\n            }\n            finally\n            {\n                synchronized (receiveSyncRoot)\n                {\n                    if (!wait)\n                        inReceive = false;\n                }\n            }\n        }\n        while (true);\n\n        copy(receivedPacket, p);\n\n        // receivePacket is a datagram packet retrieved from SocketReceiveBuffer\n        // SocketReceiveBuffers only store datagrams borrowed from pool,\n        // so return datagram back to pool.\n        receiveDatagramPacketsPool.offer(receivedPacket);\n    }\n\n    /**\n     * Sets the {@code SO_RCVBUF} option to the specified value for this socket.\n     * The {@code SO_RCVBUF} option is used by the network implementation as a\n     * hint to size the underlying network I/O buffers. The {@code SO_RCVBUF}\n     * setting may also be used by the network implementation to determine the\n     * maximum size of the packet that can be received on this socket.\n     *\n     * @param receiveBufferSize the size to which to set the receive buffer size\n     * @throws SocketException if there is an error in the underlying protocol,\n     * such as a TCP or UDP error\n     */\n    public void setReceiveBufferSize(int receiveBufferSize)\n        throws SocketException\n    {\n        synchronized (receiveSyncRoot)\n        {\n            this.receiveBufferSize = receiveBufferSize;\n\n            if (inReceive)\n            {\n                setReceiveBufferSize = true;\n            }\n            else\n            {\n                doSetReceiveBufferSize(receiveBufferSize);\n                setReceiveBufferSize = false;\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger logger\n        = Logger.getLogger(MultiplexingXXXSocketSupport.class.getName());", "docstring": "\nThe {@code Logger} used by the {@code MultiplexingXXXSocketSupport} class\nand its instances for logging output.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "logger\n        = Logger.getLogger(MultiplexingXXXSocketSupport.class.getName())", "syntax_pass": true}, {"attribute_expression": "private static final int RECEIVE_DATAGRAM_PACKETS_POOL_SIZE = 64;", "docstring": "\nThe max number of {@link DatagramPacket}'s stored in the receive pool.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "RECEIVE_DATAGRAM_PACKETS_POOL_SIZE = 64", "syntax_pass": true}, {"attribute_expression": "private static final int POOLED_DATAGRAM_PACKET_SIZE = 1500;", "docstring": "\nThe buffer size of pooled datagram packet used to read from\nunderlying socket.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "POOLED_DATAGRAM_PACKET_SIZE = 1500", "syntax_pass": true}, {"attribute_expression": "private final BlockingQueue<DatagramPacket> receiveDatagramPacketsPool\n        = new ArrayBlockingQueue<>(RECEIVE_DATAGRAM_PACKETS_POOL_SIZE);", "docstring": "\nA pool of {@link DatagramPacket}s used to receive data from unrelying\nsocket.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BlockingQueue<DatagramPacket>", "name": "receiveDatagramPacketsPool\n        = new ArrayBlockingQueue<>(RECEIVE_DATAGRAM_PACKETS_POOL_SIZE)", "syntax_pass": true}, {"attribute_expression": "private boolean inReceive = false;", "docstring": "\nThe indicator which determines whether this <tt>DatagramSocket</tt> is\ncurrently reading from the network using\n{@link DatagramSocket#receive(DatagramPacket)}. When <tt>true</tt>,\nsubsequent requests to read from the network will be blocked until the\ncurrent read is finished.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "inReceive = false", "syntax_pass": true}, {"attribute_expression": "private int receiveBufferSize;", "docstring": "\nThe value with which {@link DatagramSocket#setReceiveBufferSize(int)} is\nto be invoked if {@link #setReceiveBufferSize} is <tt>true</tt>. \n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "receiveBufferSize", "syntax_pass": true}, {"attribute_expression": "private final Object receiveSyncRoot = new Object();", "docstring": "\nThe <tt>Object</tt> which synchronizes the access to {@link #inReceive}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "receiveSyncRoot = new Object()", "syntax_pass": true}, {"attribute_expression": "private boolean setReceiveBufferSize = false;", "docstring": "\nThe indicator which determines whether\n{@link DatagramSocket#setReceiveBufferSize(int)} is to be invoked with\nthe value of {@link #receiveBufferSize}.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "setReceiveBufferSize = false", "syntax_pass": true}, {"attribute_expression": "private final List<MultiplexedXXXSocketT> sockets = new ArrayList<>();", "docstring": "\nThe IP sockets filtering {@code DatagramPacket}s away from this IP\nsocket.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<MultiplexedXXXSocketT>", "name": "sockets = new ArrayList<>()", "syntax_pass": true}]}]