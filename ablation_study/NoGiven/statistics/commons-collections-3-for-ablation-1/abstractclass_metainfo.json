[{"uris": "src/test/java/org/apache/commons/collections4/AbstractLinkedListTest.java.AbstractLinkedListTest", "name": "AbstractLinkedListTest", "file_path": "src/test/java/org/apache/commons/collections4/AbstractLinkedListTest.java", "superclasses": "", "methods": ["[]AbstractLinkedListTest(String)", "[LinkedList<T>]getCollection()", "[LinkedList<T>]getConfirmedLinkedList()", "[Collection<T>]makeConfirmedCollection()", "[Collection<T>]makeConfirmedFullCollection()", "[LinkedList<T>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/AbstractLinkedListTest.java.AbstractLinkedListTest.[]AbstractLinkedListTest(String)", "src/test/java/org/apache/commons/collections4/AbstractLinkedListTest.java.AbstractLinkedListTest.[LinkedList<T>]getCollection()", "src/test/java/org/apache/commons/collections4/AbstractLinkedListTest.java.AbstractLinkedListTest.[LinkedList<T>]getConfirmedLinkedList()", "src/test/java/org/apache/commons/collections4/AbstractLinkedListTest.java.AbstractLinkedListTest.[Collection<T>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/AbstractLinkedListTest.java.AbstractLinkedListTest.[Collection<T>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/AbstractLinkedListTest.java.AbstractLinkedListTest.[LinkedList<T>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTests base {@link java.util.LinkedList} methods and contracts.\n<p>\nTo use, simply extend this class, and implement the {@link #makeObject()} method.\n<p>\nIf your {@link LinkedList} fails one of these tests by design, you may still use this base set of cases. Simply override the test case (method) your\n{@link List} fails.\n", "original_string": "public abstract class AbstractLinkedListTest<T> extends AbstractListTest<T> {\n\n    public AbstractLinkedListTest(final String testName) {\n        super(testName);\n    }\n\n    /**\n     * Returns the {@link #collection} field cast to a {@link LinkedList}.\n     *\n     * @return the collection field as a List\n     */\n    @Override\n    public LinkedList<T> getCollection() {\n        return (LinkedList<T>) super.getCollection();\n    }\n\n    /**\n     * Returns the {@link #confirmed} field cast to a {@link LinkedList}.\n     *\n     * @return the confirmed field as a List\n     */\n    protected LinkedList<T> getConfirmedLinkedList() {\n        return (LinkedList<T>) getConfirmed();\n    }\n\n    /**\n     * Returns an empty {@link LinkedList}.\n     */\n    @Override\n    public Collection<T> makeConfirmedCollection() {\n        return new LinkedList<>();\n    }\n\n    /**\n     * Returns a full {@link LinkedList}.\n     */\n    @Override\n    public Collection<T> makeConfirmedFullCollection() {\n        return new LinkedList<>(Arrays.asList(getFullElements()));\n    }\n\n    @Override\n    public abstract LinkedList<T> makeObject();\n\n    /**\n     * Tests {@link LinkedList#addFirst(Object)}.\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testLinkedListAddFirst() {\n        if (!isAddSupported()) {\n            return;\n        }\n        final T o = (T) \"hello\";\n\n        resetEmpty();\n        getCollection().addFirst(o);\n        getConfirmedLinkedList().addFirst(o);\n        verify();\n\n        resetFull();\n        getCollection().addFirst(o);\n        getConfirmedLinkedList().addFirst(o);\n        verify();\n    }\n\n    /**\n     * Tests {@link LinkedList#addLast(Object)}.\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testLinkedListAddLast() {\n        if (!isAddSupported()) {\n            return;\n        }\n        final T o = (T) \"hello\";\n\n        resetEmpty();\n        getCollection().addLast(o);\n        getConfirmedLinkedList().addLast(o);\n        verify();\n\n        resetFull();\n        getCollection().addLast(o);\n        getConfirmedLinkedList().addLast(o);\n        verify();\n    }\n\n    /**\n     * Tests {@link LinkedList#getFirst()}.\n     */\n    @Test\n    public void testLinkedListGetFirst() {\n        resetEmpty();\n        assertThrows(NoSuchElementException.class, () -> getCollection().getFirst(), \"getFirst() should throw a NoSuchElementException for an empty list.\");\n        verify();\n\n        resetFull();\n        final Object first = getCollection().getFirst();\n        final Object confirmedFirst = getConfirmedLinkedList().getFirst();\n        assertEquals(confirmedFirst, first, \"Result returned by getFirst() was wrong.\");\n        verify();\n    }\n\n    /**\n     * Tests {@link LinkedList#getLast()}.\n     */\n    @Test\n    public void testLinkedListGetLast() {\n        resetEmpty();\n        assertThrows(NoSuchElementException.class, () -> getCollection().getLast(), \"getLast() should throw a NoSuchElementException for an empty list.\");\n        verify();\n\n        resetFull();\n        final Object last = getCollection().getLast();\n        final Object confirmedLast = getConfirmedLinkedList().getLast();\n        assertEquals(confirmedLast, last, \"Result returned by getLast() was wrong.\");\n        verify();\n    }\n\n    /**\n     * Tests {@link LinkedList#removeFirst()}.\n     */\n    @Test\n    public void testLinkedListRemoveFirst() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        resetEmpty();\n        assertThrows(NoSuchElementException.class, () -> getCollection().removeFirst(),\n                \"removeFirst() should throw a NoSuchElementException for an empty list.\");\n        verify();\n\n        resetFull();\n        final Object first = getCollection().removeFirst();\n        final Object confirmedFirst = getConfirmedLinkedList().removeFirst();\n        assertEquals(confirmedFirst, first, \"Result returned by removeFirst() was wrong.\");\n        verify();\n    }\n\n    /**\n     * Tests {@link LinkedList#removeLast()}.\n     */\n    @Test\n    public void testLinkedListRemoveLast() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        resetEmpty();\n        assertThrows(NoSuchElementException.class, () -> getCollection().removeLast(), \"removeLast() should throw a NoSuchElementException for an empty list.\");\n        verify();\n\n        resetFull();\n        final Object last = getCollection().removeLast();\n        final Object confirmedLast = getConfirmedLinkedList().removeLast();\n        assertEquals(confirmedLast, last, \"Result returned by removeLast() was wrong.\");\n        verify();\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest", "name": "AbstractObjectTest", "file_path": "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java", "superclasses": "BulkTest", "methods": ["[]AbstractObjectTest(String)", "[String]getCanonicalEmptyCollectionName(Object)", "[String]getCanonicalFullCollectionName(Object)", "[String]getCompatibilityVersion()", "[boolean]isEqualsCheckable()", "[boolean]isTestSerialization()", "[Object]makeObject()", "[Object]readExternalFormFromBytes(byte[])", "[Object]readExternalFormFromDisk(String)", "[Object]readExternalFormFromStream(InputStream)", "[Object]serializeDeserialize(Object)", "[boolean]skipSerializedCanonicalTests()", "[boolean]supportsEmptyCollections()", "[boolean]supportsFullCollections()", "[byte[]]writeExternalFormToBytes(Serializable)", "[void]writeExternalFormToDisk(Serializable,String)", "[void]writeExternalFormToStream(Serializable,OutputStream)"], "method_uris": ["src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[]AbstractObjectTest(String)", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[String]getCanonicalEmptyCollectionName(Object)", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[String]getCanonicalFullCollectionName(Object)", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[boolean]isEqualsCheckable()", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[boolean]isTestSerialization()", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[Object]makeObject()", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[Object]readExternalFormFromBytes(byte[])", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[Object]readExternalFormFromDisk(String)", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[Object]readExternalFormFromStream(InputStream)", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[Object]serializeDeserialize(Object)", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[boolean]skipSerializedCanonicalTests()", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[boolean]supportsEmptyCollections()", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[boolean]supportsFullCollections()", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[byte[]]writeExternalFormToBytes(Serializable)", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[void]writeExternalFormToDisk(Serializable,String)", "src/test/java/org/apache/commons/collections4/AbstractObjectTest.java.AbstractObjectTest.[void]writeExternalFormToStream(Serializable,OutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract test class for {@link Object} methods and contracts.\n<p>\nTo use, simply extend this class, and implement\nthe {@link #makeObject()} method.\n<p>\nIf your {@link Object} fails one of these tests by design,\nyou may still use this base set of cases.  Simply override the\ntest case (method) your {@link Object} fails.\n", "original_string": "public abstract class AbstractObjectTest extends BulkTest {\n\n    /** Current major release for Collections */\n    public static final int COLLECTIONS_MAJOR_VERSION = 4;\n\n    /**\n     * JUnit constructor.\n     *\n     * @param testName  the test class name\n     */\n    public AbstractObjectTest(final String testName) {\n        super(testName);\n    }\n\n    protected String getCanonicalEmptyCollectionName(final Object object) {\n        final StringBuilder retval = new StringBuilder();\n        retval.append(TEST_DATA_PATH);\n        String colName = object.getClass().getName();\n        colName = colName.substring(colName.lastIndexOf(\".\") + 1);\n        retval.append(colName);\n        retval.append(\".emptyCollection.version\");\n        retval.append(getCompatibilityVersion());\n        retval.append(\".obj\");\n        return retval.toString();\n    }\n\n    protected String getCanonicalFullCollectionName(final Object object) {\n        final StringBuilder retval = new StringBuilder();\n        retval.append(TEST_DATA_PATH);\n        String colName = object.getClass().getName();\n        colName = colName.substring(colName.lastIndexOf(\".\") + 1);\n        retval.append(colName);\n        retval.append(\".fullCollection.version\");\n        retval.append(getCompatibilityVersion());\n        retval.append(\".obj\");\n        return retval.toString();\n    }\n\n    // protected implementation\n    /**\n     * Gets the version of Collections that this object tries to\n     * maintain serialization compatibility with. Defaults to 4, due to\n     * the package change to collections4 introduced in version 4.\n     *\n     * This constant makes it possible for TestMap (and other subclasses,\n     * if necessary) to automatically check SCM for a versionX copy of a\n     * Serialized object, so we can make sure that compatibility is maintained.\n     * See, for example, TestMap.getCanonicalFullMapName(Map map).\n     * Subclasses can override this variable, indicating compatibility\n     * with earlier Collections versions.\n     *\n     * @return The version, or {@code null} if this object shouldn't be\n     * tested for compatibility with previous versions.\n     */\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    /**\n     * Returns true to indicate that the collection supports equals() comparisons.\n     * This implementation returns true;\n     */\n    public boolean isEqualsCheckable() {\n        return true;\n    }\n\n    /**\n     * Is serialization testing supported.\n     * Default is true.\n     */\n    public boolean isTestSerialization() {\n        return true;\n    }\n\n    /**\n     * Implement this method to return the object to test.\n     *\n     * @return the object to test\n     */\n    public abstract Object makeObject();\n\n    /**\n     * Read a Serialized or Externalized Object from bytes.\n     * Useful for verifying serialization in memory.\n     *\n     * @param b byte array containing a serialized Object\n     * @return Object contained in the bytes\n     * @throws IOException\n     * @throws ClassNotFoundException\n     */\n    protected Object readExternalFormFromBytes(final byte[] b) throws IOException, ClassNotFoundException {\n        final ByteArrayInputStream stream = new ByteArrayInputStream(b);\n        return readExternalFormFromStream(stream);\n    }\n\n    /**\n     * Reads a Serialized or Externalized Object from disk.\n     * Useful for creating compatibility tests between\n     * different SCM versions of the same class\n     *\n     * @param path path to the serialized Object\n     * @return the Object at the given path\n     * @throws IOException\n     * @throws ClassNotFoundException\n     */\n    protected Object readExternalFormFromDisk(final String path) throws IOException, ClassNotFoundException {\n        try (FileInputStream stream = new FileInputStream(path)) {\n            return readExternalFormFromStream(stream);\n        }\n    }\n\n    // private implementation\n    private Object readExternalFormFromStream(final InputStream stream) throws IOException, ClassNotFoundException {\n        final ObjectInputStream oStream = new ObjectInputStream(stream);\n        return oStream.readObject();\n    }\n\n    protected Object serializeDeserialize(final Object obj) throws Exception {\n        final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        final ObjectOutputStream out = new ObjectOutputStream(buffer);\n        out.writeObject(obj);\n        out.close();\n\n        final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n        final Object dest = in.readObject();\n        in.close();\n\n        return dest;\n    }\n\n    protected boolean skipSerializedCanonicalTests() {\n        return Boolean.getBoolean(\"org.apache.commons.collections:with-clover\");\n    }\n\n    /**\n     * Override this method if a subclass is testing an object\n     * that cannot serialize an \"empty\" Collection.\n     * (e.g. Comparators have no contents)\n     *\n     * @return true\n     */\n    public boolean supportsEmptyCollections() {\n        return true;\n    }\n\n    /**\n     * Override this method if a subclass is testing an object\n     * that cannot serialize a \"full\" Collection.\n     * (e.g. Comparators have no contents)\n     *\n     * @return true\n     */\n    public boolean supportsFullCollections() {\n        return true;\n    }\n\n    /**\n     * Tests serialization by comparing against a previously stored version in SCM.\n     * If the test object is serializable, confirm that a canonical form exists.\n     */\n    @Test\n    public void testCanonicalEmptyCollectionExists() {\n        if (supportsEmptyCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {\n            final Object object = makeObject();\n            if (object instanceof Serializable) {\n                final String name = getCanonicalEmptyCollectionName(object);\n                assertTrue(\n                        new File(name).exists(),\n                        \"Canonical empty collection (\" + name + \") is not in SCM\");\n            }\n        }\n    }\n\n    /**\n     * Tests serialization by comparing against a previously stored version in SCM.\n     * If the test object is serializable, confirm that a canonical form exists.\n     */\n    @Test\n    public void testCanonicalFullCollectionExists() {\n        if (supportsFullCollections() && isTestSerialization() && !skipSerializedCanonicalTests()) {\n            final Object object = makeObject();\n            if (object instanceof Serializable) {\n                final String name = getCanonicalFullCollectionName(object);\n                assertTrue(\n                        new File(name).exists(),\n                        \"Canonical full collection (\" + name + \") is not in SCM\");\n            }\n        }\n    }\n\n    @Test\n    public void testEqualsNull() {\n        final Object obj = makeObject();\n        assertFalse(obj.equals(null)); // make sure this doesn't throw NPE either\n    }\n\n    @Test\n    public void testObjectEqualsSelf() {\n        final Object obj = makeObject();\n        assertEquals(obj, obj, \"A Object should equal itself\");\n    }\n\n    @Test\n    public void testObjectHashCodeEqualsContract() {\n        final Object obj1 = makeObject();\n        if (obj1.equals(obj1)) {\n            assertEquals(\n                    obj1.hashCode(), obj1.hashCode(),\n                    \"[1] When two objects are equal, their hashCodes should be also.\");\n        }\n        final Object obj2 = makeObject();\n        if (obj1.equals(obj2)) {\n            assertEquals(\n                    obj1.hashCode(), obj2.hashCode(),\n                    \"[2] When two objects are equal, their hashCodes should be also.\");\n            assertEquals(obj2, obj1, \"When obj1.equals(obj2) is true, then obj2.equals(obj1) should also be true\");\n        }\n    }\n\n    @Test\n    public void testObjectHashCodeEqualsSelfHashCode() {\n        final Object obj = makeObject();\n        assertEquals(obj.hashCode(), obj.hashCode(), \"hashCode should be repeatable\");\n    }\n\n    @Test\n    public void testSerializeDeserializeThenCompare() throws Exception {\n        final Object obj = makeObject();\n        if (obj instanceof Serializable && isTestSerialization()) {\n            final Object dest = serializeDeserialize(obj);\n            if (isEqualsCheckable()) {\n                assertEquals(obj, dest, \"obj != deserialize(serialize(obj))\");\n            }\n        }\n    }\n\n    /**\n     * Sanity check method, makes sure that any Serializable\n     * class can be serialized and de-serialized in memory,\n     * using the handy makeObject() method\n     *\n     * @throws IOException\n     * @throws ClassNotFoundException\n     */\n    @Test\n    public void testSimpleSerialization() throws Exception {\n        final Object o = makeObject();\n        if (o instanceof Serializable && isTestSerialization()) {\n            final byte[] object = writeExternalFormToBytes((Serializable) o);\n            readExternalFormFromBytes(object);\n        }\n    }\n\n    /**\n     * Converts a Serializable or Externalizable object to\n     * bytes.  Useful for in-memory tests of serialization\n     *\n     * @param o Object to convert to bytes\n     * @return serialized form of the Object\n     * @throws IOException\n     */\n    protected byte[] writeExternalFormToBytes(final Serializable o) throws IOException {\n        final ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n        writeExternalFormToStream(o, byteStream);\n        return byteStream.toByteArray();\n    }\n\n    /**\n     * Writes a Serializable or Externalizable object as\n     * a file at the given path.  NOT USEFUL as part\n     * of a unit test; this is just a utility method\n     * for creating disk-based objects in SCM that can become\n     * the basis for compatibility tests using\n     * readExternalFormFromDisk(String path)\n     *\n     * @param o Object to serialize\n     * @param path path to write the serialized Object\n     * @throws IOException\n     */\n    protected void writeExternalFormToDisk(final Serializable o, final String path) throws IOException {\n        try (FileOutputStream fileStream = new FileOutputStream(path)) {\n            writeExternalFormToStream(o, fileStream);\n        }\n    }\n\n    private void writeExternalFormToStream(final Serializable o, final OutputStream stream) throws IOException {\n        final ObjectOutputStream oStream = new ObjectOutputStream(stream);\n        oStream.writeObject(o);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final int COLLECTIONS_MAJOR_VERSION = 4;", "docstring": " Current major release for Collections", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "COLLECTIONS_MAJOR_VERSION = 4", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/AbstractTreeMapTest.java.AbstractTreeMapTest", "name": "AbstractTreeMapTest", "file_path": "src/test/java/org/apache/commons/collections4/AbstractTreeMapTest.java", "superclasses": "", "methods": ["[]AbstractTreeMapTest(String)", "[boolean]isAllowNullKey()", "[TreeMap<K, V>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/AbstractTreeMapTest.java.AbstractTreeMapTest.[]AbstractTreeMapTest(String)", "src/test/java/org/apache/commons/collections4/AbstractTreeMapTest.java.AbstractTreeMapTest.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/AbstractTreeMapTest.java.AbstractTreeMapTest.[TreeMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nTests TreeMap.\n", "original_string": "public abstract class AbstractTreeMapTest<K, V> extends AbstractMapTest<K, V> {\n\n    public AbstractTreeMapTest(final String testName) {\n        super(testName);\n    }\n\n    @Override\n    public boolean isAllowNullKey() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public abstract TreeMap<K, V> makeObject();\n\n    @Test\n    public void testNewMap() {\n        final TreeMap<K, V> map = makeObject();\n        assertTrue(map.isEmpty(), \"New map is empty\");\n        assertEquals(0, map.size(), \"New map has size zero\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSearch() {\n        final TreeMap<K, V> map = makeObject();\n        map.put((K) \"first\", (V) \"First Item\");\n        map.put((K) \"second\", (V) \"Second Item\");\n        assertEquals(\"First Item\", map.get(\"first\"),\n                \"Top item is 'Second Item'\");\n        assertEquals(\"Second Item\", map.get(\"second\"),\n                \"Next Item is 'First Item'\");\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/MockTestCase.java.MockTestCase", "name": "MockTestCase", "file_path": "src/test/java/org/apache/commons/collections4/MockTestCase.java", "superclasses": "", "methods": ["[T]createMock(Class<?>)", "[IExpectationSetters<T>]expect(T)", "[T]registerMock(T)", "[void]replay()", "[void]verify()"], "method_uris": ["src/test/java/org/apache/commons/collections4/MockTestCase.java.MockTestCase.[T]createMock(Class<?>)", "src/test/java/org/apache/commons/collections4/MockTestCase.java.MockTestCase.[IExpectationSetters<T>]expect(T)", "src/test/java/org/apache/commons/collections4/MockTestCase.java.MockTestCase.[T]registerMock(T)", "src/test/java/org/apache/commons/collections4/MockTestCase.java.MockTestCase.[void]replay()", "src/test/java/org/apache/commons/collections4/MockTestCase.java.MockTestCase.[void]verify()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides utilities for making mock-based tests.  Most notable is the generic \"type-safe\"\n{@link #createMock(Class)} method, and {@link #replay()} and {@link #verify()} methods\nthat call the respective methods on all created mock objects.\n", "original_string": "public abstract class MockTestCase {\n    private final List<Object> mockObjects = new ArrayList<>();\n\n    @SuppressWarnings(\"unchecked\")\n    protected <T> T createMock(final Class<?> name) {\n        final T mock = (T) EasyMock.createMock(name);\n        return registerMock(mock);\n    }\n\n    protected <T> IExpectationSetters<T> expect(final T t) {\n        return EasyMock.expect(t);\n    }\n\n    private <T> T registerMock(final T mock) {\n        mockObjects.add(mock);\n        return mock;\n    }\n\n    protected final void replay() {\n        for (final Object o : mockObjects) {\n            EasyMock.replay(o);\n        }\n    }\n\n    protected final void verify() {\n        for (final ListIterator<Object> i = mockObjects.listIterator(); i.hasNext();) {\n            try {\n                EasyMock.verify(i.next());\n            } catch (final AssertionError e) {\n                throw new AssertionError(i.previousIndex() + 1 + StringUtils.EMPTY\n                        + e.getMessage());\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final List<Object> mockObjects = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Object>", "name": "mockObjects = new ArrayList<>()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/AbstractArrayListTest.java.AbstractArrayListTest", "name": "AbstractArrayListTest", "file_path": "src/test/java/org/apache/commons/collections4/AbstractArrayListTest.java", "superclasses": "", "methods": ["[]AbstractArrayListTest(String)", "[ArrayList<E>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/AbstractArrayListTest.java.AbstractArrayListTest.[]AbstractArrayListTest(String)", "src/test/java/org/apache/commons/collections4/AbstractArrayListTest.java.AbstractArrayListTest.[ArrayList<E>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract test class for ArrayList.\n", "original_string": "public abstract class AbstractArrayListTest<E> extends AbstractListTest<E> {\n\n    public AbstractArrayListTest(final String testName) {\n        super(testName);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public abstract ArrayList<E> makeObject();\n\n    @Test\n    public void testNewArrayList() {\n        final ArrayList<E> list = makeObject();\n        assertTrue(list.isEmpty(), \"New list is empty\");\n        assertEquals(0, list.size(), \"New list has size zero\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.get(1));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSearch() {\n        final ArrayList<E> list = makeObject();\n        list.add((E) \"First Item\");\n        list.add((E) \"Last Item\");\n        assertEquals(\"First Item\", list.get(0), \"First item is 'First Item'\");\n        assertEquals(\"Last Item\", list.get(1), \"Last Item is 'Last Item'\");\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/queue/AbstractQueueTest.java.AbstractQueueTest", "name": "AbstractQueueTest", "file_path": "src/test/java/org/apache/commons/collections4/queue/AbstractQueueTest.java", "superclasses": "", "methods": ["[]AbstractQueueTest(String)", "[Queue<E>]getCollection()", "[boolean]isSetSupported()", "[Collection<E>]makeConfirmedCollection()", "[Collection<E>]makeConfirmedFullCollection()", "[Queue<E>]makeFullCollection()", "[Queue<E>]makeObject()", "[void]verify()"], "method_uris": ["src/test/java/org/apache/commons/collections4/queue/AbstractQueueTest.java.AbstractQueueTest.[]AbstractQueueTest(String)", "src/test/java/org/apache/commons/collections4/queue/AbstractQueueTest.java.AbstractQueueTest.[Queue<E>]getCollection()", "src/test/java/org/apache/commons/collections4/queue/AbstractQueueTest.java.AbstractQueueTest.[boolean]isSetSupported()", "src/test/java/org/apache/commons/collections4/queue/AbstractQueueTest.java.AbstractQueueTest.[Collection<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/queue/AbstractQueueTest.java.AbstractQueueTest.[Collection<E>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/queue/AbstractQueueTest.java.AbstractQueueTest.[Queue<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/queue/AbstractQueueTest.java.AbstractQueueTest.[Queue<E>]makeObject()", "src/test/java/org/apache/commons/collections4/queue/AbstractQueueTest.java.AbstractQueueTest.[void]verify()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract test class for {@link java.util.Queue} methods and contracts.\n<p>\nTo use, simply extend this class, and implement\nthe {@link #makeObject} method.\n<p>\nIf your {@link Queue} fails one of these tests by design,\nyou may still use this base set of cases.  Simply override the\ntest case (method) your {@link Queue} fails or override one of the\nprotected methods from AbstractCollectionTest.\n", "original_string": "public abstract class AbstractQueueTest<E> extends AbstractCollectionTest<E> {\n\n    /**\n     * JUnit constructor.\n     *\n     * @param testName  the test class name\n     */\n    public AbstractQueueTest(final String testName) {\n        super(testName);\n    }\n\n    /**\n     * Returns the {@link #collection} field cast to a {@link Queue}.\n     *\n     * @return the collection field as a Queue\n     */\n    @Override\n    public Queue<E> getCollection() {\n        return (Queue<E>) super.getCollection();\n    }\n\n    /**\n     *  Returns true if the collections produced by\n     *  {@link #makeObject()} and {@link #makeFullCollection()}\n     *  support the <code>set operation.<p>\n     *  Default implementation returns true.  Override if your collection\n     *  class does not support set.\n     */\n    public boolean isSetSupported() {\n        return true;\n    }\n\n    /**\n     * Returns an empty {@link ArrayList}.\n     */\n    @Override\n    public Collection<E> makeConfirmedCollection() {\n        return new ArrayList<>();\n    }\n\n    /**\n     * Returns a full {@link ArrayList}.\n     */\n    @Override\n    public Collection<E> makeConfirmedFullCollection() {\n        return new ArrayList<>(Arrays.asList(getFullElements()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Queue<E> makeFullCollection() {\n        // only works if queue supports optional \"addAll(Collection)\"\n        final Queue<E> queue = makeObject();\n        queue.addAll(Arrays.asList(getFullElements()));\n        return queue;\n    }\n\n    /**\n     * Returns {@link #makeObject()}.\n     *\n     * @return an empty queue to be used for testing\n     */\n    @Override\n    public abstract Queue<E> makeObject();\n\n    /**\n     * Compare the current serialized form of the Queue\n     * against the canonical version in SCM.\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEmptyQueueCompatibility() throws IOException, ClassNotFoundException {\n        /*\n         * Create canonical objects with this code\n        Queue queue = makeEmptyQueue();\n        if (!(queue instanceof Serializable)) return;\n\n        writeExternalFormToDisk((Serializable) queue, getCanonicalEmptyCollectionName(queue));\n        */\n\n        // test to make sure the canonical form has been preserved\n        final Queue<E> queue = makeObject();\n        if (queue instanceof Serializable && !skipSerializedCanonicalTests()\n                && isTestSerialization()) {\n            final Queue<E> queue2 = (Queue<E>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(queue));\n            assertEquals(0, queue2.size(), \"Queue is empty\");\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEmptyQueueSerialization() throws IOException, ClassNotFoundException {\n        final Queue<E> queue = makeObject();\n        if (!(queue instanceof Serializable && isTestSerialization())) {\n            return;\n        }\n\n        final byte[] object = writeExternalFormToBytes((Serializable) queue);\n        final Queue<E> queue2 = (Queue<E>) readExternalFormFromBytes(object);\n\n        assertEquals(0, queue.size(), \"Both queues are empty\");\n        assertEquals(0, queue2.size(), \"Both queues are empty\");\n    }\n\n    /**\n     * Compare the current serialized form of the Queue\n     * against the canonical version in SCM.\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testFullQueueCompatibility() throws IOException, ClassNotFoundException {\n        /*\n         * Create canonical objects with this code\n        Queue queue = makeFullQueue();\n        if (!(queue instanceof Serializable)) return;\n\n        writeExternalFormToDisk((Serializable) queue, getCanonicalFullCollectionName(queue));\n        */\n\n        // test to make sure the canonical form has been preserved\n        final Queue<E> queue = makeFullCollection();\n        if (queue instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n            final Queue<E> queue2 = (Queue<E>) readExternalFormFromDisk(getCanonicalFullCollectionName(queue));\n            assertEquals(queue.size(), queue2.size(), \"Queues are not the right size\");\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testFullQueueSerialization() throws IOException, ClassNotFoundException {\n        final Queue<E> queue = makeFullCollection();\n        final int size = getFullElements().length;\n        if (!(queue instanceof Serializable && isTestSerialization())) {\n            return;\n        }\n\n        final byte[] object = writeExternalFormToBytes((Serializable) queue);\n        final Queue<E> queue2 = (Queue<E>) readExternalFormFromBytes(object);\n\n        assertEquals(size, queue.size(), \"Both queues are same size\");\n        assertEquals(size, queue2.size(), \"Both queues are same size\");\n    }\n\n    /**\n     *  Tests {@link Queue#element()}.\n     */\n    @Test\n    public void testQueueElement() {\n        resetEmpty();\n\n        assertThrows(NoSuchElementException.class, () -> getCollection().element(),\n                \"Queue.element should throw NoSuchElementException\");\n\n        resetFull();\n\n        assertTrue(getConfirmed().contains(getCollection().element()));\n\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        final int max = getFullElements().length;\n        for (int i = 0; i < max; i++) {\n            final E element = getCollection().element();\n\n            if (!isNullSupported()) {\n                assertNotNull(element);\n            }\n\n            assertTrue(getConfirmed().contains(element));\n\n            getCollection().remove(element);\n            getConfirmed().remove(element);\n\n            verify();\n        }\n\n        assertThrows(NoSuchElementException.class, () -> getCollection().element(),\n                \"Queue.element should throw NoSuchElementException\");\n    }\n\n    /**\n     *  Tests {@link Queue#offer(Object)}.\n     */\n    @Test\n    public void testQueueOffer() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final E[] elements = getFullElements();\n        for (final E element : elements) {\n            resetEmpty();\n            final boolean r = getCollection().offer(element);\n            getConfirmed().add(element);\n            verify();\n            assertTrue(r, \"Empty queue changed after add\");\n            assertEquals(1, getCollection().size(), \"Queue size is 1 after first add\");\n        }\n\n        resetEmpty();\n        int size = 0;\n        for (final E element : elements) {\n            final boolean r = getCollection().offer(element);\n            getConfirmed().add(element);\n            verify();\n            if (r) {\n                size++;\n            }\n            assertEquals(size, getCollection().size(), \"Queue size should grow after add\");\n            assertTrue(getCollection().contains(element), \"Queue should contain added element\");\n        }\n    }\n\n    /**\n     *  Tests {@link Queue#peek()}.\n     */\n    @Test\n    public void testQueuePeek() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        resetEmpty();\n\n        E element = getCollection().peek();\n        assertNull(element);\n\n        resetFull();\n\n        final int max = getFullElements().length;\n        for (int i = 0; i < max; i++) {\n            element = getCollection().peek();\n\n            if (!isNullSupported()) {\n                assertNotNull(element);\n            }\n\n            assertTrue(getConfirmed().contains(element));\n\n            getCollection().remove(element);\n            getConfirmed().remove(element);\n\n            verify();\n        }\n\n        element = getCollection().peek();\n        assertNull(element);\n    }\n\n    /**\n     *  Tests {@link Queue#poll()}.\n     */\n    @Test\n    public void testQueuePoll() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        resetEmpty();\n\n        E element = getCollection().poll();\n        assertNull(element);\n\n        resetFull();\n\n        final int max = getFullElements().length;\n        for (int i = 0; i < max; i++) {\n            element = getCollection().poll();\n            final boolean success = getConfirmed().remove(element);\n            assertTrue(success, \"poll should return correct element\");\n            verify();\n        }\n\n        element = getCollection().poll();\n        assertNull(element);\n    }\n\n    /**\n     *  Tests {@link Queue#remove()}.\n     */\n    @Test\n    public void testQueueRemove() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        resetEmpty();\n\n        assertThrows(NoSuchElementException.class, () -> getCollection().remove(),\n                \"Queue.remove should throw NoSuchElementException\");\n\n        resetFull();\n\n        final int max = getFullElements().length;\n        for (int i = 0; i < max; i++) {\n            final E element = getCollection().remove();\n            final boolean success = getConfirmed().remove(element);\n            assertTrue(success, \"remove should return correct element\");\n            verify();\n        }\n\n        assertThrows(NoSuchElementException.class, () -> getCollection().element(),\n                \"Queue.remove should throw NoSuchElementException\");\n    }\n\n    /**\n     *  Verifies that the test queue implementation matches the confirmed queue\n     *  implementation.\n     */\n    @Override\n    public void verify() {\n        super.verify();\n        final Iterator<E> iterator1 = getCollection().iterator();\n        for (final E e : getConfirmed()) {\n            assertTrue(iterator1.hasNext());\n            final Object o1 = iterator1.next();\n            final Object o2 = e;\n            assertEquals(o1, o2);\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/AbstractBagTest.java.AbstractBagTest", "name": "AbstractBagTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/AbstractBagTest.java", "superclasses": "", "methods": ["[]AbstractBagTest(String)", "[BulkTest]bulkTestBagUniqueSet()", "[Bag<T>]getCollection()", "[Collection<T>]makeConfirmedCollection()", "[Collection<T>]makeConfirmedFullCollection()", "[Bag<T>]makeFullCollection()", "[Bag<T>]makeObject()", "[void]resetEmpty()", "[void]resetFull()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/AbstractBagTest.java.AbstractBagTest.[]AbstractBagTest(String)", "src/test/java/org/apache/commons/collections4/bag/AbstractBagTest.java.AbstractBagTest.[BulkTest]bulkTestBagUniqueSet()", "src/test/java/org/apache/commons/collections4/bag/AbstractBagTest.java.AbstractBagTest.[Bag<T>]getCollection()", "src/test/java/org/apache/commons/collections4/bag/AbstractBagTest.java.AbstractBagTest.[Collection<T>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/bag/AbstractBagTest.java.AbstractBagTest.[Collection<T>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/bag/AbstractBagTest.java.AbstractBagTest.[Bag<T>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/bag/AbstractBagTest.java.AbstractBagTest.[Bag<T>]makeObject()", "src/test/java/org/apache/commons/collections4/bag/AbstractBagTest.java.AbstractBagTest.[void]resetEmpty()", "src/test/java/org/apache/commons/collections4/bag/AbstractBagTest.java.AbstractBagTest.[void]resetFull()"], "overrides": null, "attributes": [{"original_string": "    public class TestBagUniqueSet extends AbstractSetTest<T> {\n\n        public TestBagUniqueSet() {\n            super(StringUtils.EMPTY);\n        }\n\n        @Override\n        public T[] getFullElements() {\n            return AbstractBagTest.this.getFullElements();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractBagTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public T[] getOtherElements() {\n            return AbstractBagTest.this.getOtherElements();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractBagTest.this.isNullSupported();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Set<T> makeFullCollection() {\n            return AbstractBagTest.this.makeFullCollection().uniqueSet();\n        }\n\n        @Override\n        public Set<T> makeObject() {\n            return AbstractBagTest.this.makeObject().uniqueSet();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractBagTest.this.resetEmpty();\n            TestBagUniqueSet.this.setCollection(AbstractBagTest.this.getCollection().uniqueSet());\n            TestBagUniqueSet.this.setConfirmed(new HashSet<>(AbstractBagTest.this.getConfirmed()));\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractBagTest.this.resetFull();\n            TestBagUniqueSet.this.setCollection(AbstractBagTest.this.getCollection().uniqueSet());\n            TestBagUniqueSet.this.setConfirmed(new HashSet<>(AbstractBagTest.this.getConfirmed()));\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n        }\n    }", "definition": "    public class TestBagUniqueSet extends AbstractSetTest<T>", "class_docstring": "", "name": "TestBagUniqueSet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestBagUniqueSet() {\n            super(StringUtils.EMPTY);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestBagUniqueSet", "params": [], "body": "                                  {\n            super(StringUtils.EMPTY);\n        }", "signature": "public TestBagUniqueSet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public T[] getFullElements() {\n            return AbstractBagTest.this.getFullElements();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                     {\n            return AbstractBagTest.this.getFullElements();\n        }", "signature": "@Override\n        public T[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected int getIterationBehaviour() {\n            return AbstractBagTest.this.getIterationBehaviour();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "getIterationBehaviour", "params": [], "body": "                                              {\n            return AbstractBagTest.this.getIterationBehaviour();\n        }", "signature": "@Override\n        protected int getIterationBehaviour()"}, {"syntax_pass": true, "original_string": "        @Override\n        public T[] getOtherElements() {\n            return AbstractBagTest.this.getOtherElements();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T[]", "classes": []}, "name": "getOtherElements", "params": [], "body": "                                      {\n            return AbstractBagTest.this.getOtherElements();\n        }", "signature": "@Override\n        public T[] getOtherElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            return false;\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isNullSupported() {\n            return AbstractBagTest.this.isNullSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNullSupported", "params": [], "body": "                                         {\n            return AbstractBagTest.this.isNullSupported();\n        }", "signature": "@Override\n        public boolean isNullSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return false;\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<T> makeFullCollection() {\n            return AbstractBagTest.this.makeFullCollection().uniqueSet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<T>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                           {\n            return AbstractBagTest.this.makeFullCollection().uniqueSet();\n        }", "signature": "@Override\n        public Set<T> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<T> makeObject() {\n            return AbstractBagTest.this.makeObject().uniqueSet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<T>", "classes": []}, "name": "makeObject", "params": [], "body": "                                   {\n            return AbstractBagTest.this.makeObject().uniqueSet();\n        }", "signature": "@Override\n        public Set<T> makeObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetEmpty() {\n            AbstractBagTest.this.resetEmpty();\n            TestBagUniqueSet.this.setCollection(AbstractBagTest.this.getCollection().uniqueSet());\n            TestBagUniqueSet.this.setConfirmed(new HashSet<>(AbstractBagTest.this.getConfirmed()));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetEmpty", "params": [], "body": "                                 {\n            AbstractBagTest.this.resetEmpty();\n            TestBagUniqueSet.this.setCollection(AbstractBagTest.this.getCollection().uniqueSet());\n            TestBagUniqueSet.this.setConfirmed(new HashSet<>(AbstractBagTest.this.getConfirmed()));\n        }", "signature": "@Override\n        public void resetEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetFull() {\n            AbstractBagTest.this.resetFull();\n            TestBagUniqueSet.this.setCollection(AbstractBagTest.this.getCollection().uniqueSet());\n            TestBagUniqueSet.this.setConfirmed(new HashSet<>(AbstractBagTest.this.getConfirmed()));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetFull", "params": [], "body": "                                {\n            AbstractBagTest.this.resetFull();\n            TestBagUniqueSet.this.setCollection(AbstractBagTest.this.getCollection().uniqueSet());\n            TestBagUniqueSet.this.setConfirmed(new HashSet<>(AbstractBagTest.this.getConfirmed()));\n        }", "signature": "@Override\n        public void resetFull()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void verify() {\n            super.verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "verify", "params": [], "body": "                             {\n            super.verify();\n        }", "signature": "@Override\n        public void verify()"}]}], "class_docstring": "\nAbstract test class for {@link org.apache.commons.collections4.Bag Bag} methods and contracts.\n<p>\nTo use, simply extend this class, and implement\nthe {@link #makeObject} method.\n<p>\nIf your bag fails one of these tests by design,\nyou may still use this base set of cases.  Simply override the\ntest case (method) your bag fails.\n<p>\n<b>Note:</b> The Bag interface does not conform to the Collection interface\nso the generic collection tests from AbstractCollectionTest would normally fail.\nAs a work-around since 4.0, a CollectionBag decorator can be used\nto make any Bag implementation comply to the Collection contract.\n<p>\nThis abstract test class does wrap the concrete bag implementation\nwith such a decorator, see the overridden {@link #resetEmpty()} and\n{@link #resetFull()} methods.\n<p>\nIn addition to the generic collection tests (prefix testCollection) inherited\nfrom AbstractCollectionTest, there are test methods that test the \"normal\" Bag\ninterface (prefix testBag). For Bag specific tests use the {@link #makeObject()} and\n{@link #makeFullCollection()} methods instead of {@link #resetEmpty()} and resetFull(),\notherwise the collection will be wrapped by a {@link CollectionBag} decorator.\n", "original_string": "public abstract class AbstractBagTest<T> extends AbstractCollectionTest<T> {\n\n    public class TestBagUniqueSet extends AbstractSetTest<T> {\n\n        public TestBagUniqueSet() {\n            super(StringUtils.EMPTY);\n        }\n\n        @Override\n        public T[] getFullElements() {\n            return AbstractBagTest.this.getFullElements();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractBagTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public T[] getOtherElements() {\n            return AbstractBagTest.this.getOtherElements();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractBagTest.this.isNullSupported();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Set<T> makeFullCollection() {\n            return AbstractBagTest.this.makeFullCollection().uniqueSet();\n        }\n\n        @Override\n        public Set<T> makeObject() {\n            return AbstractBagTest.this.makeObject().uniqueSet();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractBagTest.this.resetEmpty();\n            TestBagUniqueSet.this.setCollection(AbstractBagTest.this.getCollection().uniqueSet());\n            TestBagUniqueSet.this.setConfirmed(new HashSet<>(AbstractBagTest.this.getConfirmed()));\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractBagTest.this.resetFull();\n            TestBagUniqueSet.this.setCollection(AbstractBagTest.this.getCollection().uniqueSet());\n            TestBagUniqueSet.this.setConfirmed(new HashSet<>(AbstractBagTest.this.getConfirmed()));\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n        }\n    }\n\n    /**\n     * JUnit constructor.\n     *\n     * @param testName  the test class name\n     */\n    public AbstractBagTest(final String testName) {\n        super(testName);\n    }\n\n    /**\n     * Bulk test {@link Bag#uniqueSet()}.  This method runs through all of\n     * the tests in {@link AbstractSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the bag and the other collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing the bag's unique set\n     */\n    public BulkTest bulkTestBagUniqueSet() {\n        return new TestBagUniqueSet();\n    }\n\n    /**\n     * Returns the {@link #collection} field cast to a {@link Bag}.\n     *\n     * @return the collection field as a Bag\n     */\n    @Override\n    public Bag<T> getCollection() {\n        return (Bag<T>) super.getCollection();\n    }\n\n    /**\n     * Returns an empty {@link ArrayList}.\n     */\n    @Override\n    public Collection<T> makeConfirmedCollection() {\n        return new ArrayList<>();\n    }\n\n    /**\n     * Returns a full collection.\n     */\n    @Override\n    public Collection<T> makeConfirmedFullCollection() {\n        final Collection<T> coll = makeConfirmedCollection();\n        coll.addAll(Arrays.asList(getFullElements()));\n        return coll;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Bag<T> makeFullCollection() {\n        final Bag<T> bag = makeObject();\n        bag.addAll(Arrays.asList(getFullElements()));\n        return bag;\n    }\n\n    /**\n     * Return a new, empty bag to used for testing.\n     *\n     * @return the bag to be tested\n     */\n    @Override\n    public abstract Bag<T> makeObject();\n\n    @Override\n    public void resetEmpty() {\n        setCollection(CollectionBag.collectionBag(makeObject()));\n        setConfirmed(makeConfirmedCollection());\n    }\n\n    @Override\n    public void resetFull() {\n        setCollection(CollectionBag.collectionBag(makeFullCollection()));\n        setConfirmed(makeConfirmedFullCollection());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagAdd() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        bag.add((T) \"A\");\n        assertTrue(bag.contains(\"A\"), \"Should contain 'A'\");\n        assertEquals(1, bag.getCount(\"A\"), \"Should have count of 1\");\n        bag.add((T) \"A\");\n        assertTrue(bag.contains(\"A\"), \"Should contain 'A'\");\n        assertEquals(2, bag.getCount(\"A\"), \"Should have count of 2\");\n        bag.add((T) \"B\");\n        assertTrue(bag.contains(\"A\"));\n        assertTrue(bag.contains(\"B\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagContains() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n\n        assertFalse(bag.contains(\"A\"), \"Bag does not have at least 1 'A'\");\n        assertFalse(bag.contains(\"B\"), \"Bag does not have at least 1 'B'\");\n\n        bag.add((T) \"A\");  // bag 1A\n        assertTrue(bag.contains(\"A\"), \"Bag has at least 1 'A'\");\n        assertFalse(bag.contains(\"B\"), \"Bag does not have at least 1 'B'\");\n\n        bag.add((T) \"A\");  // bag 2A\n        assertTrue(bag.contains(\"A\"), \"Bag has at least 1 'A'\");\n        assertFalse(bag.contains(\"B\"), \"Bag does not have at least 1 'B'\");\n\n        bag.add((T) \"B\");  // bag 2A,1B\n        assertTrue(bag.contains(\"A\"), \"Bag has at least 1 'A'\");\n        assertTrue(bag.contains(\"B\"), \"Bag has at least 1 'B'\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagContainsAll() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        final List<String> known = new ArrayList<>();\n        final List<String> known1A = new ArrayList<>();\n        known1A.add(\"A\");\n        final List<String> known2A = new ArrayList<>();\n        known2A.add(\"A\");\n        known2A.add(\"A\");\n        final List<String> known1B = new ArrayList<>();\n        known1B.add(\"B\");\n        final List<String> known1A1B = new ArrayList<>();\n        known1A1B.add(\"A\");\n        known1A1B.add(\"B\");\n\n        assertTrue(bag.containsAll(known), \"Bag containsAll of empty\");\n        assertFalse(bag.containsAll(known1A), \"Bag does not containsAll of 1 'A'\");\n        assertFalse(bag.containsAll(known2A), \"Bag does not containsAll of 2 'A'\");\n        assertFalse(bag.containsAll(known1B), \"Bag does not containsAll of 1 'B'\");\n        assertFalse(bag.containsAll(known1A1B), \"Bag does not containsAll of 1 'A' 1 'B'\");\n\n        bag.add((T) \"A\");  // bag 1A\n        assertTrue(bag.containsAll(known), \"Bag containsAll of empty\");\n        assertTrue(bag.containsAll(known1A), \"Bag containsAll of 1 'A'\");\n        assertFalse(bag.containsAll(known2A), \"Bag does not containsAll of 2 'A'\");\n        assertFalse(bag.containsAll(known1B), \"Bag does not containsAll of 1 'B'\");\n        assertFalse(bag.containsAll(known1A1B), \"Bag does not containsAll of 1 'A' 1 'B'\");\n\n        bag.add((T) \"A\");  // bag 2A\n        assertTrue(bag.containsAll(known), \"Bag containsAll of empty\");\n        assertTrue(bag.containsAll(known1A), \"Bag containsAll of 1 'A'\");\n        assertTrue(bag.containsAll(known2A), \"Bag containsAll of 2 'A'\");\n        assertFalse(bag.containsAll(known1B), \"Bag does not containsAll of 1 'B'\");\n        assertFalse(bag.containsAll(known1A1B), \"Bag does not containsAll of 1 'A' 1 'B'\");\n\n        bag.add((T) \"A\");  // bag 3A\n        assertTrue(bag.containsAll(known), \"Bag containsAll of empty\");\n        assertTrue(bag.containsAll(known1A), \"Bag containsAll of 1 'A'\");\n        assertTrue(bag.containsAll(known2A), \"Bag containsAll of 2 'A'\");\n        assertFalse(bag.containsAll(known1B), \"Bag does not containsAll of 1 'B'\");\n        assertFalse(bag.containsAll(known1A1B), \"Bag does not containsAll of 1 'A' 1 'B'\");\n\n        bag.add((T) \"B\");  // bag 3A1B\n        assertTrue(bag.containsAll(known), \"Bag containsAll of empty\");\n        assertTrue(bag.containsAll(known1A), \"Bag containsAll of 1 'A'\");\n        assertTrue(bag.containsAll(known2A), \"Bag containsAll of 2 'A'\");\n        assertTrue(bag.containsAll(known1B), \"Bag containsAll of 1 'B'\");\n        assertTrue(bag.containsAll(known1A1B), \"Bag containsAll of 1 'A' 1 'B'\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagEquals() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        final Bag<T> bag2 = makeObject();\n        assertEquals(bag, bag2);\n        bag.add((T) \"A\");\n        assertNotEquals(bag, bag2);\n        bag2.add((T) \"A\");\n        assertEquals(bag, bag2);\n        bag.add((T) \"A\");\n        bag.add((T) \"B\");\n        bag.add((T) \"B\");\n        bag.add((T) \"C\");\n        bag2.add((T) \"A\");\n        bag2.add((T) \"B\");\n        bag2.add((T) \"B\");\n        bag2.add((T) \"C\");\n        assertEquals(bag, bag2);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagEqualsHashBag() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        final Bag<T> bag2 = new HashBag<>();\n        assertEquals(bag, bag2);\n        bag.add((T) \"A\");\n        assertNotEquals(bag, bag2);\n        bag2.add((T) \"A\");\n        assertEquals(bag, bag2);\n        bag.add((T) \"A\");\n        bag.add((T) \"B\");\n        bag.add((T) \"B\");\n        bag.add((T) \"C\");\n        bag2.add((T) \"A\");\n        bag2.add((T) \"B\");\n        bag2.add((T) \"B\");\n        bag2.add((T) \"C\");\n        assertEquals(bag, bag2);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagEqualsSelf() {\n        final Bag<T> bag = makeObject();\n        assertEquals(bag, bag);\n\n        if (!isAddSupported()) {\n            return;\n        }\n\n        bag.add((T) \"elt\");\n        assertEquals(bag, bag);\n        bag.add((T) \"elt\"); // again\n        assertEquals(bag, bag);\n        bag.add((T) \"elt2\");\n        assertEquals(bag, bag);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagHashCode() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        final Bag<T> bag2 = makeObject();\n        assertEquals(0, bag.hashCode());\n        assertEquals(0, bag2.hashCode());\n        assertEquals(bag.hashCode(), bag2.hashCode());\n        bag.add((T) \"A\");\n        bag.add((T) \"A\");\n        bag.add((T) \"B\");\n        bag.add((T) \"B\");\n        bag.add((T) \"C\");\n        bag2.add((T) \"A\");\n        bag2.add((T) \"A\");\n        bag2.add((T) \"B\");\n        bag2.add((T) \"B\");\n        bag2.add((T) \"C\");\n        assertEquals(bag.hashCode(), bag2.hashCode());\n\n        int total = 0;\n        total += \"A\".hashCode() ^ 2;\n        total += \"B\".hashCode() ^ 2;\n        total += \"C\".hashCode() ^ 1;\n        assertEquals(total, bag.hashCode());\n        assertEquals(total, bag2.hashCode());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagIterator() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        bag.add((T) \"A\");\n        bag.add((T) \"A\");\n        bag.add((T) \"B\");\n        assertEquals(3, bag.size(), \"Bag should have 3 items\");\n        final Iterator<T> i = bag.iterator();\n\n        boolean foundA = false;\n        while (i.hasNext()) {\n            final String element = (String) i.next();\n            // ignore the first A, remove the second via Iterator.remove()\n            if (element.equals(\"A\")) {\n                if (!foundA) {\n                    foundA = true;\n                } else {\n                    i.remove();\n                }\n            }\n        }\n\n        assertTrue(bag.contains(\"A\"), \"Bag should still contain 'A'\");\n        assertEquals(2, bag.size(), \"Bag should have 2 items\");\n        assertEquals(1, bag.getCount(\"A\"), \"Bag should have 1 'A'\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagIteratorFail() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        bag.add((T) \"A\");\n        bag.add((T) \"A\");\n        bag.add((T) \"B\");\n        final Iterator<T> it = bag.iterator();\n        it.next();\n        bag.remove(\"A\");\n\n        assertThrows(ConcurrentModificationException.class, () -> it.next());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagIteratorFailDoubleRemove() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        bag.add((T) \"A\");\n        bag.add((T) \"A\");\n        bag.add((T) \"B\");\n        final Iterator<T> it = bag.iterator();\n        it.next();\n        it.next();\n        assertEquals(3, bag.size());\n        it.remove();\n        assertEquals(2, bag.size());\n\n        assertThrows(IllegalStateException.class, () -> it.remove());\n\n        assertEquals(2, bag.size());\n        it.next();\n        it.remove();\n        assertEquals(1, bag.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagIteratorFailNoMore() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        bag.add((T) \"A\");\n        bag.add((T) \"A\");\n        bag.add((T) \"B\");\n        final Iterator<T> it = bag.iterator();\n        it.next();\n        it.next();\n        it.next();\n\n        assertThrows(NoSuchElementException.class, () -> it.next());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagIteratorRemoveProtectsInvariants() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        bag.add((T) \"A\");\n        bag.add((T) \"A\");\n        assertEquals(2, bag.size());\n        final Iterator<T> it = bag.iterator();\n        assertEquals(\"A\", it.next());\n        assertTrue(it.hasNext());\n        it.remove();\n        assertEquals(1, bag.size());\n        assertTrue(it.hasNext());\n        assertEquals(\"A\", it.next());\n        assertFalse(it.hasNext());\n        it.remove();\n        assertEquals(0, bag.size());\n        assertFalse(it.hasNext());\n\n        final Iterator<T> it2 = bag.iterator();\n        assertFalse(it2.hasNext());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagRemove() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        bag.add((T) \"A\");\n        assertEquals(1, bag.getCount(\"A\"), \"Should have count of 1\");\n        bag.remove(\"A\");\n        assertEquals(0, bag.getCount(\"A\"), \"Should have count of 0\");\n        bag.add((T) \"A\");\n        bag.add((T) \"A\");\n        bag.add((T) \"A\");\n        bag.add((T) \"A\");\n        assertEquals(4, bag.getCount(\"A\"), \"Should have count of 4\");\n        bag.remove(\"A\", 0);\n        assertEquals(4, bag.getCount(\"A\"), \"Should have count of 4\");\n        bag.remove(\"A\", 2);\n        assertEquals(2, bag.getCount(\"A\"), \"Should have count of 2\");\n        bag.remove(\"A\");\n        assertEquals(0, bag.getCount(\"A\"), \"Should have count of 0\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagRemoveAll() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        bag.add((T) \"A\", 2);\n        assertEquals(2, bag.getCount(\"A\"), \"Should have count of 2\");\n        bag.add((T) \"B\");\n        bag.add((T) \"C\");\n        assertEquals(4, bag.size(), \"Should have count of 4\");\n        final List<String> delete = new ArrayList<>();\n        delete.add(\"A\");\n        delete.add(\"B\");\n        bag.removeAll(delete);\n        assertEquals(1, bag.getCount(\"A\"), \"Should have count of 1\");\n        assertEquals(0, bag.getCount(\"B\"), \"Should have count of 0\");\n        assertEquals(1, bag.getCount(\"C\"), \"Should have count of 1\");\n        assertEquals(2, bag.size(), \"Should have count of 2\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagRetainAll() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        bag.add((T) \"A\");\n        bag.add((T) \"A\");\n        bag.add((T) \"A\");\n        bag.add((T) \"B\");\n        bag.add((T) \"B\");\n        bag.add((T) \"C\");\n        final List<String> retains = new ArrayList<>();\n        retains.add(\"B\");\n        retains.add(\"C\");\n        bag.retainAll(retains);\n        assertEquals(2, bag.size(), \"Should have 2 total items\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagSize() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        assertEquals(0, bag.size(), \"Should have 0 total items\");\n        bag.add((T) \"A\");\n        assertEquals(1, bag.size(), \"Should have 1 total items\");\n        bag.add((T) \"A\");\n        assertEquals(2, bag.size(), \"Should have 2 total items\");\n        bag.add((T) \"A\");\n        assertEquals(3, bag.size(), \"Should have 3 total items\");\n        bag.add((T) \"B\");\n        assertEquals(4, bag.size(), \"Should have 4 total items\");\n        bag.add((T) \"B\");\n        assertEquals(5, bag.size(), \"Should have 5 total items\");\n        bag.remove(\"A\", 2);\n        assertEquals(1, bag.getCount(\"A\"), \"Should have 1 'A'\");\n        assertEquals(3, bag.size(), \"Should have 3 total items\");\n        bag.remove(\"B\");\n        assertEquals(1, bag.size(), \"Should have 1 total item\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagToArray() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        bag.add((T) \"A\");\n        bag.add((T) \"A\");\n        bag.add((T) \"B\");\n        bag.add((T) \"B\");\n        bag.add((T) \"C\");\n        final Object[] array = bag.toArray();\n        int a = 0, b = 0, c = 0;\n        for (final Object element : array) {\n            a += element.equals(\"A\") ? 1 : 0;\n            b += element.equals(\"B\") ? 1 : 0;\n            c += element.equals(\"C\") ? 1 : 0;\n        }\n        assertEquals(2, a);\n        assertEquals(2, b);\n        assertEquals(1, c);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBagToArrayPopulate() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final Bag<T> bag = makeObject();\n        bag.add((T) \"A\");\n        bag.add((T) \"A\");\n        bag.add((T) \"B\");\n        bag.add((T) \"B\");\n        bag.add((T) \"C\");\n        final String[] array = bag.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n        int a = 0, b = 0, c = 0;\n        for (final String element : array) {\n            a += element.equals(\"A\") ? 1 : 0;\n            b += element.equals(\"B\") ? 1 : 0;\n            c += element.equals(\"C\") ? 1 : 0;\n        }\n        assertEquals(2, a);\n        assertEquals(2, b);\n        assertEquals(1, c);\n    }\n\n    /**\n     * Compare the current serialized form of the Bag\n     * against the canonical version in SCM.\n     */\n    @Test\n    public void testEmptyBagCompatibility() throws IOException, ClassNotFoundException {\n        // test to make sure the canonical form has been preserved\n        final Bag<T> bag = makeObject();\n        if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n            final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(bag));\n            assertTrue(bag2.isEmpty(), \"Bag is empty\");\n            assertEquals(bag, bag2);\n        }\n    }\n\n    /**\n     * Compare the current serialized form of the Bag\n     * against the canonical version in SCM.\n     */\n    @Test\n    public void testFullBagCompatibility() throws IOException, ClassNotFoundException {\n        // test to make sure the canonical form has been preserved\n        final Bag<T> bag = makeFullCollection();\n        if (bag instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n            final Bag<?> bag2 = (Bag<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(bag));\n            assertEquals(bag.size(), bag2.size(), \"Bag is the right size\");\n            assertEquals(bag, bag2);\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java.AbstractSortedBagTest", "name": "AbstractSortedBagTest", "file_path": "src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java", "superclasses": "", "methods": ["[]AbstractSortedBagTest(String)", "[SortedBag<T>]getCollection()", "[T[]]getFullNonNullElements()", "[T[]]getOtherNonNullElements()", "[boolean]isNullSupported()", "[SortedBag<T>]makeConfirmedCollection()", "[SortedBag<T>]makeFullCollection()", "[SortedBag<T>]makeObject()", "[void]resetEmpty()", "[void]resetFull()", "[void]verify()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java.AbstractSortedBagTest.[]AbstractSortedBagTest(String)", "src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java.AbstractSortedBagTest.[SortedBag<T>]getCollection()", "src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java.AbstractSortedBagTest.[T[]]getFullNonNullElements()", "src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java.AbstractSortedBagTest.[T[]]getOtherNonNullElements()", "src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java.AbstractSortedBagTest.[boolean]isNullSupported()", "src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java.AbstractSortedBagTest.[SortedBag<T>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java.AbstractSortedBagTest.[SortedBag<T>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java.AbstractSortedBagTest.[SortedBag<T>]makeObject()", "src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java.AbstractSortedBagTest.[void]resetEmpty()", "src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java.AbstractSortedBagTest.[void]resetFull()", "src/test/java/org/apache/commons/collections4/bag/AbstractSortedBagTest.java.AbstractSortedBagTest.[void]verify()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract test class for\n{@link org.apache.commons.collections4.SortedBag SortedBag}\nmethods and contracts.\n", "original_string": "public abstract class AbstractSortedBagTest<T> extends AbstractBagTest<T> {\n\n    public AbstractSortedBagTest(final String testName) {\n        super(testName);\n    }\n\n    /**\n     * Returns the {@link #collection} field cast to a {@link SortedBag}.\n     *\n     * @return the collection field as a SortedBag\n     */\n    @Override\n    public SortedBag<T> getCollection() {\n        return (SortedBag<T>) super.getCollection();\n    }\n\n    /**\n     * Override to return comparable objects.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public T[] getFullNonNullElements() {\n        final Object[] elements = new Object[30];\n\n        for (int i = 0; i < 30; i++) {\n            elements[i] = Integer.valueOf(i + i + 1);\n        }\n        return (T[]) elements;\n    }\n\n    /**\n     * Override to return comparable objects.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public T[] getOtherNonNullElements() {\n        final Object[] elements = new Object[30];\n        for (int i = 0; i < 30; i++) {\n            elements[i] = Integer.valueOf(i + i + 2);\n        }\n        return (T[]) elements;\n    }\n\n    /**\n     * Overridden because SortedBags don't allow null elements (normally).\n     * @return false\n     */\n    @Override\n    public boolean isNullSupported() {\n        return false;\n    }\n\n    /**\n     * Returns an empty {@link TreeBag} for use in modification testing.\n     *\n     * @return a confirmed empty collection\n     */\n    @Override\n    public SortedBag<T> makeConfirmedCollection() {\n        return new TreeBag<>();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SortedBag<T> makeFullCollection() {\n        return (SortedBag<T>) super.makeFullCollection();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public abstract SortedBag<T> makeObject();\n\n    @Override\n    public void resetEmpty() {\n        setCollection(CollectionSortedBag.collectionSortedBag(makeObject()));\n        setConfirmed(makeConfirmedCollection());\n    }\n\n    @Override\n    public void resetFull() {\n        setCollection(CollectionSortedBag.collectionSortedBag(makeFullCollection()));\n        setConfirmed(makeConfirmedFullCollection());\n    }\n\n    /**\n     * Verification extension, will check the order of elements,\n     * the sets should already be verified equal.\n     */\n    @Override\n    public void verify() {\n        super.verify();\n\n        // Check that iterator returns elements in order and first() and last()\n        // are consistent\n        final Iterator<T> collIter = getCollection().iterator();\n        final Iterator<T> confIter = getConfirmed().iterator();\n        T first = null;\n        T last = null;\n        while (collIter.hasNext()) {\n            if (first == null) {\n                first = collIter.next();\n                last = first;\n            } else {\n                last = collIter.next();\n            }\n            assertEquals(last, confIter.next(), \"Element appears to be out of order.\");\n        }\n        if (!getCollection().isEmpty()) {\n            assertEquals(first, getCollection().first(),\n                \"Incorrect element returned by first().\");\n            assertEquals(last, getCollection().last(),\n                \"Incorrect element returned by last().\");\n        }\n    }\n\n    // TODO: Add the SortedBag tests!\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest", "name": "AbstractCollectionTest", "file_path": "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java", "superclasses": "AbstractObjectTest", "methods": ["[void]assertNotCollectionContains(Collection<?>,Object)", "[void]assertNotCollectionContainsAll(Collection<?>,Collection<?>)", "[void]assertNotRemoveAllFromCollection(Collection<?>,Collection<?>)", "[void]assertNotRemoveFromCollection(Collection<?>,Object)", "[void]assertUnorderedArrayEquals(Object[],Object[],String)", "[]AbstractCollectionTest(String)", "[boolean]areEqualElementsDistinguishable()", "[Map.Entry<E, E>]cloneMapEntry(Map.Entry<E, E>)", "[Collection<E>]getCollection()", "[Collection<E>]getConfirmed()", "[E[]]getFullElements()", "[E[]]getFullNonNullElements()", "[Object[]]getFullNonNullStringElements()", "[int]getIterationBehaviour()", "[E[]]getOtherElements()", "[E[]]getOtherNonNullElements()", "[Object[]]getOtherNonNullStringElements()", "[boolean]isAddSupported()", "[boolean]isEqualsCheckable()", "[boolean]isFailFastSupported()", "[boolean]isNullSupported()", "[boolean]isRemoveSupported()", "[Collection<E>]makeConfirmedCollection()", "[Collection<E>]makeConfirmedFullCollection()", "[Collection<E>]makeFullCollection()", "[Collection<E>]makeObject()", "[void]resetEmpty()", "[void]resetFull()", "[void]setCollection(Collection<E>)", "[void]setConfirmed(Collection<E>)", "[void]verify()"], "method_uris": ["src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[void]assertNotCollectionContains(Collection<?>,Object)", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[void]assertNotCollectionContainsAll(Collection<?>,Collection<?>)", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[void]assertNotRemoveAllFromCollection(Collection<?>,Collection<?>)", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[void]assertNotRemoveFromCollection(Collection<?>,Object)", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[void]assertUnorderedArrayEquals(Object[],Object[],String)", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[]AbstractCollectionTest(String)", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[boolean]areEqualElementsDistinguishable()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[Map.Entry<E, E>]cloneMapEntry(Map.Entry<E, E>)", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[Collection<E>]getCollection()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[Collection<E>]getConfirmed()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[E[]]getFullElements()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[E[]]getFullNonNullElements()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[Object[]]getFullNonNullStringElements()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[E[]]getOtherElements()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[E[]]getOtherNonNullElements()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[Object[]]getOtherNonNullStringElements()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[boolean]isAddSupported()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[boolean]isEqualsCheckable()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[boolean]isFailFastSupported()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[boolean]isNullSupported()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[Collection<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[Collection<E>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[Collection<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[Collection<E>]makeObject()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[void]resetEmpty()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[void]resetFull()", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[void]setCollection(Collection<E>)", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[void]setConfirmed(Collection<E>)", "src/test/java/org/apache/commons/collections4/collection/AbstractCollectionTest.java.AbstractCollectionTest.[void]verify()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract test class for {@link java.util.Collection} methods and contracts.\n<p>\nYou should create a concrete subclass of this class to test any custom\n{@link Collection} implementation.  At minimum, you'll have to\nimplement the {@link #makeObject()}, {@link #makeConfirmedCollection()}\nand {@link #makeConfirmedFullCollection()} methods.\nYou might want to override some of the additional public methods as well:\n<p>\n<b>Element Population Methods</b>\n<p>\nOverride these if your collection restricts what kind of elements are\nallowed (for instance, if {@code null} is not permitted):\n<ul>\n<li>{@link #getFullElements()}\n<li>{@link #getOtherElements()}\n</ul>\n<p>\n<b>Supported Operation Methods</b>\n<p>\nOverride these if your collection doesn't support certain operations:\n<ul>\n<li>{@link #isAddSupported()}\n<li>{@link #isRemoveSupported()}\n<li>{@link #areEqualElementsDistinguishable()}\n<li>{@link #isNullSupported()}\n<li>{@link #isFailFastSupported()}\n</ul>\n<p>\n<b>Indicate Collection Behaviour</b>\n<p>\nOverride these if your collection makes specific behavior guarantees:\n<ul>\n<li>{@link #getIterationBehaviour()}</li>\n</ul>\n<p>\n<b>Fixture Methods</b>\n<p>\nFixtures are used to verify that the operation results in correct state\nfor the collection.  Basically, the operation is performed against your\ncollection implementation, and an identical operation is performed against a\n<em>confirmed</em> collection implementation.  A confirmed collection\nimplementation is something like {@link java.util.ArrayList}, which is\nknown to conform exactly to its collection interface's contract.  After the\noperation takes place on both your collection implementation and the\nconfirmed collection implementation, the two collections are compared to see\nif their state is identical.  The comparison is usually much more involved\nthan a simple {@code equals} test.  This verification is used to ensure\nproper modifications are made along with ensuring that the collection does\nnot change when read-only modifications are made.\n<p>\nThe {@link #collection} field holds an instance of your collection\nimplementation; the {@link #confirmed} field holds an instance of the\nconfirmed collection implementation.  The {@link #resetEmpty()} and\n{@link #resetFull()} methods set these fields to empty or full collections,\nso that tests can proceed from a known state.\n<p>\nAfter a modification operation to both {@link #collection} and\n{@link #confirmed}, the {@link #verify()} method is invoked to compare\nthe results.  You may want to override {@link #verify()} to perform\nadditional verifications.  For instance, when testing the collection\nviews of a map, {@link org.apache.commons.collections4.map.AbstractMapTest AbstractTestMap}\nwould override {@link #verify()} to make\nsure the map is changed after the collection view is changed.\n<p>\nIf you're extending this class directly, you will have to provide\nimplementations for the following:\n<ul>\n<li>{@link #makeConfirmedCollection()}\n<li>{@link #makeConfirmedFullCollection()}\n</ul>\n<p>\nThose methods should provide a confirmed collection implementation\nthat's compatible with your collection implementation.\n<p>\nIf you're extending {@link org.apache.commons.collections4.list.AbstractListTest AbstractListTest},\n{@link org.apache.commons.collections4.set.AbstractSetTest AbstractTestSet},\nor {@link org.apache.commons.collections4.bag.AbstractBagTest AbstractBagTest},\nyou probably don't have to worry about the\nabove methods, because those three classes already override the methods\nto provide standard JDK confirmed collections.<P>\n<p>\n<b>Other notes</b>\n<p>\nIf your {@link Collection} fails one of these tests by design,\nyou may still use this base set of cases.  Simply override the\ntest case (method) your {@link Collection} fails.\n", "original_string": "public abstract class AbstractCollectionTest<E> extends AbstractObjectTest {\n\n    //\n    // NOTE:\n    //\n    // Collection doesn't define any semantics for equals, and recommends you\n    // use reference-based default behavior of Object.equals.  (And a test for\n    // that already exists in AbstractTestObject).  Tests for equality of lists, sets\n    // and bags will have to be written in test subclasses.  Thus, there is no\n    // tests on Collection.equals nor any for Collection.hashCode.\n    //\n\n    /**\n     * Flag to indicate the collection makes no ordering guarantees for the iterator. If this is not used\n     * then the behavior is assumed to be ordered and the output order of the iterator is matched by\n     * the toArray method.\n     */\n    public static final int UNORDERED = 0x1;\n\n    // These fields are used by reset() and verify(), and any test\n    // method that tests a modification.\n\n    /**\n     * Handle the optional exceptions declared by {@link Collection#contains(Object)}\n     * @param coll\n     * @param element\n     */\n    protected static void assertNotCollectionContains(final Collection<?> coll, final Object element) {\n        try {\n            assertFalse(coll.contains(element));\n        } catch (final ClassCastException | NullPointerException e) {\n            //apparently not\n        }\n    }\n\n    /**\n     * Handle the optional exceptions declared by {@link Collection#containsAll(Collection)}\n     * @param coll\n     * @param sub\n     */\n    protected static void assertNotCollectionContainsAll(final Collection<?> coll, final Collection<?> sub) {\n        try {\n            assertFalse(coll.containsAll(sub));\n        } catch (final ClassCastException | NullPointerException e) {\n            //apparently not\n        }\n    }\n\n    /**\n     * Handle optional exceptions of {@link Collection#removeAll(Collection)}\n     * @param coll\n     * @param sub\n     */\n    protected static void assertNotRemoveAllFromCollection(final Collection<?> coll, final Collection<?> sub) {\n        try {\n            assertFalse(coll.removeAll(sub));\n        } catch (final ClassCastException | NullPointerException e) {\n            //apparently not\n        }\n    }\n\n    /**\n     * Handle optional exceptions of {@link Collection#remove(Object)}\n     * @param coll\n     * @param element\n     */\n    protected static void assertNotRemoveFromCollection(final Collection<?> coll, final Object element) {\n        try {\n            assertFalse(coll.remove(element));\n        } catch (final ClassCastException | NullPointerException e) {\n            //apparently not\n        }\n    }\n\n    /**\n     * Assert the arrays contain the same elements, ignoring the order.\n     *\n     * <p>Note this does not test the arrays are deeply equal. Array elements are compared\n     * using {@link Object#equals(Object)}.\n     *\n     * @param a1 First array\n     * @param a2 Second array\n     * @param msg Failure message prefix\n     */\n    private static void assertUnorderedArrayEquals(final Object[] a1, final Object[] a2, final String msg) {\n        assertEquals(a1.length, a2.length, () -> msg + \": length\");\n        final int size = a1.length;\n        // Track values that have been matched once (and only once)\n        final boolean[] matched = new boolean[size];\n        NEXT_OBJECT:\n        for (final Object o : a1) {\n            for (int i = 0; i < size; i++) {\n                if (matched[i]) {\n                    // skip values already matched\n                    continue;\n                }\n                if (Objects.equals(o, a2[i])) {\n                    // values matched\n                    matched[i] = true;\n                    // continue to the outer loop\n                    continue NEXT_OBJECT;\n                }\n            }\n            fail(msg + \": array 2 does not have object: \" + o);\n        }\n    }\n\n    /**\n     *  A collection instance that will be used for testing.\n     */\n    private Collection<E> collection;\n\n    /**\n     *  Confirmed collection.  This is an instance of a collection that is\n     *  confirmed to conform exactly to the java.util.Collection contract.\n     *  Modification operations are tested by performing a mod on your\n     *  collection, performing the exact same mod on an equivalent confirmed\n     *  collection, and then calling verify() to make sure your collection\n     *  still matches the confirmed collection.\n     */\n    private Collection<E> confirmed;\n\n    /**\n     * JUnit constructor.\n     *\n     * @param testName  the test class name\n     */\n    public AbstractCollectionTest(final String testName) {\n        super(testName);\n    }\n\n    /**\n     *  Specifies whether equal elements in the collection are, in fact,\n     *  distinguishable with information not readily available.  That is, if a\n     *  particular value is to be removed from the collection, then there is\n     *  one and only one value that can be removed, even if there are other\n     *  elements which are equal to it.\n     *\n     *  <P>In most collection cases, elements are not distinguishable (equal is\n     *  equal), thus this method defaults to return false.  In some cases,\n     *  however, they are.  For example, the collection returned from the map's\n     *  values() collection view are backed by the map, so while there may be\n     *  two values that are equal, their associated keys are not.  Since the\n     *  keys are distinguishable, the values are.\n     *\n     *  <P>This flag is used to skip some verifications for iterator.remove()\n     *  where it is impossible to perform an equivalent modification on the\n     *  confirmed collection because it is not possible to determine which\n     *  value in the confirmed collection to actually remove.  Tests that\n     *  override the default (i.e. where equal elements are distinguishable),\n     *  should provide additional tests on iterator.remove() to make sure the\n     *  proper elements are removed when remove() is called on the iterator.\n     **/\n    public boolean areEqualElementsDistinguishable() {\n        return false;\n    }\n\n    /**\n     * Creates a new Map Entry that is independent of the first and the map.\n     */\n    public Map.Entry<E, E> cloneMapEntry(final Map.Entry<E, E> entry) {\n        final HashMap<E, E> map = new HashMap<>();\n        map.put(entry.getKey(), entry.getValue());\n        return map.entrySet().iterator().next();\n    }\n\n    public Collection<E> getCollection() {\n        return collection;\n    }\n\n    public Collection<E> getConfirmed() {\n        return confirmed;\n    }\n\n    /**\n     *  Returns an array of objects that are contained in a collection\n     *  produced by {@link #makeFullCollection()}.  Every element in the\n     *  returned array <em>must</em> be an element in a full collection.<P>\n     *  The default implementation returns a heterogeneous array of\n     *  objects with some duplicates. null is added if allowed.\n     *  Override if you require specific testing elements.  Note that if you\n     *  override {@link #makeFullCollection()}, you <em>must</em> override\n     *  this method to reflect the contents of a full collection.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public E[] getFullElements() {\n        if (isNullSupported()) {\n            final ArrayList<E> list = new ArrayList<>(Arrays.asList(getFullNonNullElements()));\n            list.add(4, null);\n            return (E[]) list.toArray();\n        }\n        return getFullNonNullElements().clone();\n    }\n\n    /**\n     *  Returns a list of elements suitable for return by\n     *  {@link #getFullElements()}.  The array returned by this method\n     *  does not include null, but does include a variety of objects\n     *  of different types.  Override getFullElements to return\n     *  the results of this method if your collection does not support\n     *  the null element.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public E[] getFullNonNullElements() {\n        return (E[]) new Object[] {\n            StringUtils.EMPTY,\n            \"One\",\n            Integer.valueOf(2),\n            \"Three\",\n            Integer.valueOf(4),\n            \"One\",\n            Double.valueOf(5),\n            Float.valueOf(6),\n            \"Seven\",\n            \"Eight\",\n            \"Nine\",\n            Integer.valueOf(10),\n            Short.valueOf((short) 11),\n            Long.valueOf(12),\n            \"Thirteen\",\n            \"14\",\n            \"15\",\n            Byte.valueOf((byte) 16)\n        };\n    }\n\n    /**\n     *  Returns a list of string elements suitable for return by\n     *  {@link #getFullElements()}.  Override getFullElements to return\n     *  the results of this method if your collection does not support\n     *  heterogeneous elements or the null element.\n     */\n    public Object[] getFullNonNullStringElements() {\n        return new Object[] {\n            \"If\", \"the\", \"dull\", \"substance\", \"of\", \"my\", \"flesh\", \"were\",\n            \"thought\", \"Injurious\", \"distance\", \"could\", \"not\", \"stop\", \"my\", \"way\",\n        };\n    }\n\n    /**\n     * Return a flag specifying the iteration behavior of the collection.\n     * This is used to change the assertions used by specific tests.\n     * The default implementation returns 0 which indicates ordered iteration behavior.\n     *\n     * @return the iteration behavior\n     * @see #UNORDERED\n     */\n    protected int getIterationBehaviour() {\n        return 0;\n    }\n\n    /**\n     *  Returns an array of elements that are <em>not</em> contained in a\n     *  full collection.  Every element in the returned array must\n     *  not exist in a collection returned by {@link #makeFullCollection()}.\n     *  The default implementation returns a heterogeneous array of elements\n     *  without null.  Note that some of the tests add these elements\n     *  to an empty or full collection, so if your collection restricts\n     *  certain kinds of elements, you should override this method.\n     */\n    public E[] getOtherElements() {\n        return getOtherNonNullElements();\n    }\n\n    /**\n     *  Returns the default list of objects returned by\n     *  {@link #getOtherElements()}.  Includes many objects\n     *  of different types.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public E[] getOtherNonNullElements() {\n        return (E[]) new Object[] {\n            Integer.valueOf(0),\n            Float.valueOf(0),\n            Double.valueOf(0),\n            \"Zero\",\n            Short.valueOf((short) 0),\n            Byte.valueOf((byte) 0),\n            Long.valueOf(0),\n            Character.valueOf('\\u0000'),\n            \"0\"\n        };\n    }\n\n    /**\n     *  Returns a list of string elements suitable for return by\n     *  {@link #getOtherElements()}.  Override getOtherElements to return\n     *  the results of this method if your collection does not support\n     *  heterogeneous elements or the null element.\n     */\n    public Object[] getOtherNonNullStringElements() {\n        return new Object[] {\n            \"For\", \"then\", \"despite\", /* of */\"space\", \"I\", \"would\", \"be\",\n            \"brought\", \"From\", \"limits\", \"far\", \"remote\", \"where\", \"thou\", \"dost\", \"stay\"\n        };\n    }\n\n    /**\n     *  Returns true if the collections produced by\n     *  {@link #makeObject()} and {@link #makeFullCollection()}\n     *  support the {@code add} and {@code addAll}\n     *  operations.<P>\n     *  Default implementation returns true.  Override if your collection\n     *  class does not support add or addAll.\n     */\n    public boolean isAddSupported() {\n        return true;\n    }\n\n    /**\n     * Returns true to indicate that the collection supports equals() comparisons.\n     * This implementation returns false;\n     */\n    @Override\n    public boolean isEqualsCheckable() {\n        return false;\n    }\n\n    /**\n     * Returns true to indicate that the collection supports fail fast iterators.\n     * The default implementation returns true;\n     */\n    public boolean isFailFastSupported() {\n        return false;\n    }\n\n    /**\n     * Returns true to indicate that the collection supports holding null.\n     * The default implementation returns true;\n     */\n    public boolean isNullSupported() {\n        return true;\n    }\n\n    /**\n     *  Returns true if the collections produced by\n     *  {@link #makeObject()} and {@link #makeFullCollection()}\n     *  support the {@code remove}, {@code removeAll},\n     *  {@code retainAll}, {@code clear} and\n     *  {@code iterator().remove()} methods.\n     *  Default implementation returns true.  Override if your collection\n     *  class does not support removal operations.\n     */\n    public boolean isRemoveSupported() {\n        return true;\n    }\n\n    /**\n     *  Returns a confirmed empty collection.\n     *  For instance, an {@link java.util.ArrayList} for lists or a\n     *  {@link java.util.HashSet} for sets.\n     *\n     *  @return a confirmed empty collection\n     */\n    public abstract Collection<E> makeConfirmedCollection();\n\n    /**\n     *  Returns a confirmed full collection.\n     *  For instance, an {@link java.util.ArrayList} for lists or a\n     *  {@link java.util.HashSet} for sets.  The returned collection\n     *  should contain the elements returned by {@link #getFullElements()}.\n     *\n     *  @return a confirmed full collection\n     */\n    public abstract Collection<E> makeConfirmedFullCollection();\n\n    /**\n     *  Returns a full collection to be used for testing.  The collection\n     *  returned by this method should contain every element returned by\n     *  {@link #getFullElements()}.  The default implementation, in fact,\n     *  simply invokes {@code addAll} on an empty collection with\n     *  the results of {@link #getFullElements()}.  Override this default\n     *  if your collection doesn't support addAll.\n     */\n    public Collection<E> makeFullCollection() {\n        final Collection<E> c = makeObject();\n        c.addAll(Arrays.asList(getFullElements()));\n        return c;\n    }\n\n    /**\n     * Return a new, empty {@link Collection} to be used for testing.\n     */\n    @Override\n    public abstract Collection<E> makeObject();\n\n    /**\n     *  Resets the {@link #collection} and {@link #confirmed} fields to empty\n     *  collections.  Invoke this method before performing a modification\n     *  test.\n     */\n    public void resetEmpty() {\n        this.setCollection(makeObject());\n        this.setConfirmed(makeConfirmedCollection());\n    }\n\n    /**\n     *  Resets the {@link #collection} and {@link #confirmed} fields to full\n     *  collections.  Invoke this method before performing a modification\n     *  test.\n     */\n    public void resetFull() {\n        this.setCollection(makeFullCollection());\n        this.setConfirmed(makeConfirmedFullCollection());\n    }\n\n    /**\n     * Sets the collection.\n     * @param collection the Collection<E> to set\n     */\n    public void setCollection(final Collection<E> collection) {\n        this.collection = collection;\n    }\n\n    /**\n     * Sets the confirmed.\n     * @param confirmed the Collection<E> to set\n     */\n    public void setConfirmed(final Collection<E> confirmed) {\n        this.confirmed = confirmed;\n    }\n\n    // Tests\n    /**\n     *  Tests {@link Collection#add(Object)}.\n     */\n    @Test\n    public void testCollectionAdd() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final E[] elements = getFullElements();\n        for (final E element : elements) {\n            resetEmpty();\n            final boolean r = getCollection().add(element);\n            getConfirmed().add(element);\n            verify();\n            assertTrue(r, \"Empty collection changed after add\");\n            assertEquals(1, getCollection().size(), \"Collection size is 1 after first add\");\n        }\n\n        resetEmpty();\n        int size = 0;\n        for (final E element : elements) {\n            final boolean r = getCollection().add(element);\n            getConfirmed().add(element);\n            verify();\n            if (r) {\n                size++;\n            }\n            assertEquals(size, getCollection().size(), \"Collection size should grow after add\");\n            assertTrue(getCollection().contains(element), \"Collection should contain added element\");\n        }\n    }\n\n    /**\n     *  Tests {@link Collection#addAll(Collection)}.\n     */\n    @Test\n    public void testCollectionAddAll() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        resetEmpty();\n        E[] elements = getFullElements();\n        boolean r = getCollection().addAll(Arrays.asList(elements));\n        getConfirmed().addAll(Arrays.asList(elements));\n        verify();\n        assertTrue(r, \"Empty collection should change after addAll\");\n        for (final E element : elements) {\n            assertTrue(getCollection().contains(element), \"Collection should contain added element\");\n        }\n\n        resetFull();\n        int size = getCollection().size();\n        elements = getOtherElements();\n        r = getCollection().addAll(Arrays.asList(elements));\n        getConfirmed().addAll(Arrays.asList(elements));\n        verify();\n        assertTrue(r, \"Full collection should change after addAll\");\n        for (final E element : elements) {\n            assertTrue(getCollection().contains(element),\n                    \"Full collection should contain added element\");\n        }\n        assertEquals(size + elements.length, getCollection().size(), \"Size should increase after addAll\");\n\n        resetFull();\n        size = getCollection().size();\n        r = getCollection().addAll(Arrays.asList(getFullElements()));\n        getConfirmed().addAll(Arrays.asList(getFullElements()));\n        verify();\n        if (r) {\n            assertTrue(size < getCollection().size(), \"Size should increase if addAll returns true\");\n        } else {\n            assertEquals(size, getCollection().size(), \"Size should not change if addAll returns false\");\n        }\n    }\n\n    /**\n     *  Test {@link Collection#clear()}.\n     */\n    @Test\n    public void testCollectionClear() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        resetEmpty();\n        getCollection().clear(); // just to make sure it doesn't raise anything\n        verify();\n\n        resetFull();\n        getCollection().clear();\n        getConfirmed().clear();\n        verify();\n    }\n\n    /**\n     *  Tests {@link Collection#contains(Object)}.\n     */\n    @Test\n    public void testCollectionContains() {\n        Object[] elements;\n\n        resetEmpty();\n        elements = getFullElements();\n        for (int i = 0; i < elements.length; i++) {\n            assertFalse(getCollection().contains(elements[i]), \"Empty collection shouldn't contain element[\" + i + \"]\");\n        }\n        // make sure calls to \"contains\" don't change anything\n        verify();\n\n        elements = getOtherElements();\n        for (int i = 0; i < elements.length; i++) {\n            assertFalse(getCollection().contains(elements[i]), \"Empty collection shouldn't contain element[\" + i + \"]\");\n        }\n        // make sure calls to \"contains\" don't change anything\n        verify();\n\n        resetFull();\n        elements = getFullElements();\n        for (int i = 0; i < elements.length; i++) {\n            assertTrue(getCollection().contains(elements[i]),\n                    \"Full collection should contain element[\" + i + \"]\");\n        }\n        // make sure calls to \"contains\" don't change anything\n        verify();\n\n        resetFull();\n        elements = getOtherElements();\n        for (final Object element : elements) {\n            assertFalse(getCollection().contains(element), \"Full collection shouldn't contain element\");\n        }\n    }\n\n    /**\n     *  Tests {@link Collection#containsAll(Collection)}.\n     */\n    @Test\n    public void testCollectionContainsAll() {\n        resetEmpty();\n        Collection<E> col = new HashSet<>();\n        assertTrue(getCollection().containsAll(col),\n                \"Every Collection should contain all elements of an \" + \"empty Collection.\");\n        col.addAll(Arrays.asList(getOtherElements()));\n        assertFalse(getCollection().containsAll(col),\n                \"Empty Collection shouldn't contain all elements of \" + \"a non-empty Collection.\");\n        // make sure calls to \"containsAll\" don't change anything\n        verify();\n\n        resetFull();\n        assertFalse(getCollection().containsAll(col), \"Full collection shouldn't contain other elements\");\n\n        col.clear();\n        col.addAll(Arrays.asList(getFullElements()));\n        assertTrue(getCollection().containsAll(col),\n                \"Full collection should containAll full elements\");\n        // make sure calls to \"containsAll\" don't change anything\n        verify();\n\n        final int min = getFullElements().length < 4 ? 0 : 2;\n        final int max = getFullElements().length == 1 ? 1 :\n                getFullElements().length <= 5 ? getFullElements().length - 1 : 5;\n        col = Arrays.asList(getFullElements()).subList(min, max);\n        assertTrue(getCollection().containsAll(col),\n                \"Full collection should containAll partial full elements\");\n        assertTrue(getCollection().containsAll(getCollection()),\n                \"Full collection should containAll itself\");\n        // make sure calls to \"containsAll\" don't change anything\n        verify();\n\n        col = new ArrayList<>(Arrays.asList(getFullElements()));\n        col.addAll(Arrays.asList(getFullElements()));\n        assertTrue(getCollection().containsAll(col),\n                \"Full collection should containAll duplicate full elements\");\n\n        // make sure calls to \"containsAll\" don't change anything\n        verify();\n    }\n\n    /**\n     *  Tests {@link Collection#isEmpty()}.\n     */\n    @Test\n    public void testCollectionIsEmpty() {\n        resetEmpty();\n        assertTrue(getCollection().isEmpty(), \"New Collection should be empty.\");\n        // make sure calls to \"isEmpty() don't change anything\n        verify();\n\n        resetFull();\n        assertFalse(getCollection().isEmpty(), \"Full collection shouldn't be empty\");\n        // make sure calls to \"isEmpty() don't change anything\n        verify();\n    }\n\n    /**\n     *  Tests the read-only functionality of {@link Collection#iterator()}.\n     */\n    @Test\n    public void testCollectionIterator() {\n        resetEmpty();\n        Iterator<E> it1 = getCollection().iterator();\n        assertFalse(it1.hasNext(), \"Iterator for empty Collection shouldn't have next.\");\n        final Iterator<E> finalIt1 = it1;\n        assertThrows(NoSuchElementException.class, () -> finalIt1.next(),\n                \"Iterator at end of Collection should throw NoSuchElementException when next is called.\");\n        // make sure nothing has changed after non-modification\n        verify();\n\n        resetFull();\n        it1 = getCollection().iterator();\n        for (final E element : getCollection()) {\n            assertTrue(it1.hasNext(), \"Iterator for full collection should haveNext\");\n            it1.next();\n        }\n        assertFalse(it1.hasNext(), \"Iterator should be finished\");\n\n        final ArrayList<E> list = new ArrayList<>();\n        it1 = getCollection().iterator();\n        for (int i = 0; i < getCollection().size(); i++) {\n            final E next = it1.next();\n            assertTrue(getCollection().contains(next),\n                    \"Collection should contain element returned by its iterator\");\n            list.add(next);\n        }\n        final Iterator<E> finalIt2 = it1;\n        assertThrows(NoSuchElementException.class, () -> finalIt2.next(),\n                \"iterator.next() should raise NoSuchElementException after it finishes\");\n        // make sure nothing has changed after non-modification\n        verify();\n    }\n\n    /**\n     *  Tests that the collection's iterator is fail-fast.\n     */\n    @Test\n    public void testCollectionIteratorFailFast() {\n        if (!isFailFastSupported()) {\n            return;\n        }\n\n        if (isAddSupported()) {\n            resetFull();\n            final Iterator<E> iter0 = getCollection().iterator();\n            final E o = getOtherElements()[0];\n            getCollection().add(o);\n            getConfirmed().add(o);\n            assertThrows(ConcurrentModificationException.class, () -> iter0.next(),\n                    \"next after add should raise ConcurrentModification\");\n            verify();\n\n            resetFull();\n            final Iterator<E> iter = getCollection().iterator();\n            getCollection().addAll(Arrays.asList(getOtherElements()));\n            getConfirmed().addAll(Arrays.asList(getOtherElements()));\n            assertThrows(ConcurrentModificationException.class, () -> iter.next(),\n                    \"next after addAll should raise ConcurrentModification\");\n            verify();\n        }\n\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        resetFull();\n        try {\n            final Iterator<E> iter = getCollection().iterator();\n            getCollection().clear();\n            iter.next();\n            fail(\"next after clear should raise ConcurrentModification\");\n        } catch (final ConcurrentModificationException | NoSuchElementException e) {\n            // ConcurrentModificationException: expected\n            // NoSuchElementException: (also legal given spec)\n        }\n\n        resetFull();\n        final Iterator<E> iter0 = getCollection().iterator();\n        getCollection().remove(getFullElements()[0]);\n        assertThrows(ConcurrentModificationException.class, () -> iter0.next(),\n                \"next after remove should raise ConcurrentModification\");\n\n        resetFull();\n        final Iterator<E> iter1 = getCollection().iterator();\n        getCollection().removeIf(e -> false);\n        assertThrows(ConcurrentModificationException.class, () -> iter1.next(),\n                \"next after removeIf should raise ConcurrentModification\");\n\n        resetFull();\n        final Iterator<E> iter2 = getCollection().iterator();\n        final List<E> sublist = Arrays.asList(getFullElements()).subList(2, 5);\n        getCollection().removeAll(sublist);\n        assertThrows(ConcurrentModificationException.class, () -> iter2.next(),\n                \"next after removeAll should raise ConcurrentModification\");\n\n        resetFull();\n        final Iterator<E> iter3 = getCollection().iterator();\n        final List<E> sublist3 = Arrays.asList(getFullElements()).subList(2, 5);\n        getCollection().retainAll(sublist3);\n        assertThrows(ConcurrentModificationException.class, () -> iter3.next(),\n                \"next after retainAll should raise ConcurrentModification\");\n    }\n\n    /**\n     *  Tests removals from {@link Collection#iterator()}.\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testCollectionIteratorRemove() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        resetEmpty();\n        assertThrows(IllegalStateException.class, () -> getCollection().iterator().remove(),\n                \"New iterator.remove should raise IllegalState\");\n        verify();\n\n        final Iterator<E> iter0 = getCollection().iterator();\n        iter0.hasNext();\n        assertThrows(IllegalStateException.class, () -> iter0.remove(),\n                \"New iterator.remove should raise IllegalState even after hasNext\");\n        verify();\n\n        resetFull();\n        int size = getCollection().size();\n        Iterator<E> iter = getCollection().iterator();\n        while (iter.hasNext()) {\n            Object o = iter.next();\n            // TreeMap reuses the Map Entry, so the verify below fails\n            // Clone it here if necessary\n            if (o instanceof Map.Entry) {\n                o = cloneMapEntry((Map.Entry<E, E>) o);\n            }\n            iter.remove();\n\n            // if the elements aren't distinguishable, we can just remove a\n            // matching element from the confirmed collection and verify\n            // contents are still the same.  Otherwise, we don't have the\n            // ability to distinguish the elements and determine which to\n            // remove from the confirmed collection (in which case, we don't\n            // verify because we don't know how).\n            //\n            // see areEqualElementsDistinguishable()\n            if (!areEqualElementsDistinguishable()) {\n                getConfirmed().remove(o);\n                verify();\n            }\n\n            size--;\n            assertEquals(size, getCollection().size(),\n                    \"Collection should shrink by one after iterator.remove\");\n        }\n        assertTrue(getCollection().isEmpty(), \"Collection should be empty after iterator purge\");\n\n        resetFull();\n        iter = getCollection().iterator();\n        iter.next();\n        iter.remove();\n        final Iterator<E> finalIter = iter;\n        assertThrows(IllegalStateException.class, () -> finalIter.remove(),\n                \"Second iter.remove should raise IllegalState\");\n    }\n\n    /**\n     *  Tests {@link Collection#remove(Object)}.\n     */\n    @Test\n    public void testCollectionRemove() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        resetEmpty();\n        final E[] elements = getFullElements();\n        for (final E element : elements) {\n            assertFalse(getCollection().remove(element), \"Shouldn't remove nonexistent element\");\n            verify();\n        }\n\n        final E[] other = getOtherElements();\n\n        resetFull();\n        for (final E element : other) {\n            assertFalse(getCollection().remove(element), \"Shouldn't remove nonexistent other element\");\n            verify();\n        }\n\n        final int size = getCollection().size();\n        for (final E element : elements) {\n            resetFull();\n            assertTrue(getCollection().remove(element),\n                    \"Collection should remove extant element: \" + element);\n\n            // if the elements aren't distinguishable, we can just remove a\n            // matching element from the confirmed collection and verify\n            // contents are still the same.  Otherwise, we don't have the\n            // ability to distinguish the elements and determine which to\n            // remove from the confirmed collection (in which case, we don't\n            // verify because we don't know how).\n            //\n            // see areEqualElementsDistinguishable()\n            if (!areEqualElementsDistinguishable()) {\n                getConfirmed().remove(element);\n                verify();\n            }\n\n            assertEquals(size - 1, getCollection().size(), \"Collection should shrink after remove\");\n        }\n    }\n\n    /**\n     *  Tests {@link Collection#removeAll(Collection)}.\n     */\n    @Test\n    public void testCollectionRemoveAll() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        resetEmpty();\n        assertFalse(getCollection().removeAll(Collections.EMPTY_SET), \"Empty collection removeAll should return false for empty input\");\n        verify();\n\n        assertFalse(getCollection().removeAll(new ArrayList<>(getCollection())), \"Empty collection removeAll should return false for nonempty input\");\n        verify();\n\n        resetFull();\n        assertFalse(getCollection().removeAll(Collections.EMPTY_SET), \"Full collection removeAll should return false for empty input\");\n        verify();\n\n        assertFalse(getCollection().removeAll(Arrays.asList(getOtherElements())), \"Full collection removeAll should return false for other elements\");\n        verify();\n\n        assertTrue(getCollection().removeAll(new HashSet<>(getCollection())),\n                \"Full collection removeAll should return true for full elements\");\n        getConfirmed().removeAll(new HashSet<>(getConfirmed()));\n        verify();\n\n        resetFull();\n        final int size = getCollection().size();\n        final int min = getFullElements().length < 4 ? 0 : 2;\n        final int max = getFullElements().length == 1 ? 1 :\n                getFullElements().length <= 5 ? getFullElements().length - 1 : 5;\n        final Collection<E> all = Arrays.asList(getFullElements()).subList(min, max);\n        assertTrue(getCollection().removeAll(all), \"Full collection removeAll should work\");\n        getConfirmed().removeAll(all);\n        verify();\n\n        assertTrue(getCollection().size() < size, \"Collection should shrink after removeAll\");\n        for (final E element : all) {\n            assertFalse(getCollection().contains(element), \"Collection shouldn't contain removed element\");\n        }\n    }\n\n    /**\n     *  Tests {@link Collection#removeIf(Predicate)}.\n     */\n    @Test\n    public void testCollectionRemoveIf() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        resetEmpty();\n        assertFalse(getCollection().removeIf(e -> false), \"Empty collection removeIf should return false for a predicate that returns only false\");\n        verify();\n\n        assertFalse(getCollection().removeIf(e -> true), \"Empty collection removeIf should return false for a predicate that returns only true\");\n        verify();\n\n        resetFull();\n        assertFalse(getCollection().removeIf(e -> false), \"Full collection removeIf should return false for a predicate that returns only false\");\n        verify();\n\n        assertTrue(getCollection().removeIf(e -> true), \"Full collection removeIf should return true for a predicate that returns only true\");\n        getConfirmed().removeIf(e -> true);\n        verify();\n\n        resetFull();\n        final List<E> elements = Arrays.asList(getFullElements());\n\n        final int mid = getFullElements().length / 2;\n        final E target = elements.get(mid);\n\n        final int size = getCollection().size();\n        final int targetCount = Collections.frequency(elements, target);\n\n        final Predicate<E> filter = target::equals;\n\n        assertTrue(getCollection().removeIf(filter), \"Full collection removeIf should work\");\n        getConfirmed().removeIf(filter);\n        verify();\n\n        assertEquals(getCollection().size(), size - targetCount, \"Collection should shrink after removeIf\");\n        assertFalse(getCollection().contains(target), \"Collection shouldn't contain removed element\");\n    }\n\n    /**\n     *  Tests {@link Collection#retainAll(Collection)}.\n     */\n    @Test\n    public void testCollectionRetainAll() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        resetEmpty();\n        final List<E> elements = Arrays.asList(getFullElements());\n        final List<E> other = Arrays.asList(getOtherElements());\n\n        assertFalse(getCollection().retainAll(Collections.EMPTY_SET), \"Empty retainAll() should return false\");\n        verify();\n\n        assertFalse(getCollection().retainAll(elements), \"Empty retainAll() should return false\");\n        verify();\n\n        resetFull();\n        assertTrue(getCollection().retainAll(Collections.EMPTY_SET),\n                \"Collection should change from retainAll empty\");\n        getConfirmed().retainAll(Collections.EMPTY_SET);\n        verify();\n\n        resetFull();\n        assertTrue(getCollection().retainAll(other), \"Collection changed from retainAll other\");\n        getConfirmed().retainAll(other);\n        verify();\n\n        resetFull();\n        int size = getCollection().size();\n        assertFalse(getCollection().retainAll(elements), \"Collection shouldn't change from retainAll elements\");\n        verify();\n        assertEquals(size, getCollection().size(), \"Collection size shouldn't change\");\n\n        if (getFullElements().length > 1) {\n            resetFull();\n            size = getCollection().size();\n            final int min = getFullElements().length < 4 ? 0 : 2;\n            final int max = getFullElements().length <= 5 ? getFullElements().length - 1 : 5;\n            assertTrue(getCollection().retainAll(elements.subList(min, max)),\n                    \"Collection should changed by partial retainAll\");\n            getConfirmed().retainAll(elements.subList(min, max));\n            verify();\n\n            for (final E element : getCollection()) {\n                assertTrue(elements.subList(min, max).contains(element), \"Collection only contains retained element\");\n            }\n        }\n\n        resetFull();\n        final HashSet<E> set = new HashSet<>(elements);\n        size = getCollection().size();\n        assertFalse(getCollection().retainAll(set),\n                \"Collection shouldn't change from retainAll without \" + \"duplicate elements\");\n        verify();\n        assertEquals(size, getCollection().size(),\n                \"Collection size didn't change from nonduplicate \" + \"retainAll\");\n    }\n\n    /**\n     *  Tests {@link Collection#size()}.\n     */\n    @Test\n    public void testCollectionSize() {\n        resetEmpty();\n        assertEquals(0, getCollection().size(), \"Size of new Collection is 0.\");\n\n        resetFull();\n        assertFalse(getCollection().isEmpty(), \"Size of full collection should be greater than zero\");\n    }\n\n    /**\n     *  Tests {@link Collection#toArray()}.\n     */\n    @Test\n    public void testCollectionToArray() {\n        resetEmpty();\n        assertEquals(0, getCollection().toArray().length,\n                \"Empty Collection should return empty array for toArray\");\n\n        resetFull();\n        final Object[] array = getCollection().toArray();\n        assertEquals(array.length, getCollection().size(),\n                \"Full collection toArray should be same size as collection\");\n        final Object[] confirmedArray = getConfirmed().toArray();\n        assertEquals(confirmedArray.length, array.length, \"length of array from confirmed collection should \"\n                + \"match the length of the collection's array\");\n        final boolean[] matched = new boolean[array.length];\n\n        for (int i = 0; i < array.length; i++) {\n            assertTrue(getCollection().contains(array[i]),\n                    \"Collection should contain element in toArray\");\n\n            boolean match = false;\n            // find a match in the confirmed array\n            for (int j = 0; j < array.length; j++) {\n                // skip already matched\n                if (matched[j]) {\n                    continue;\n                }\n                if (Objects.equals(array[i], confirmedArray[j])) {\n                    matched[j] = true;\n                    match = true;\n                    break;\n                }\n            }\n            if (!match) {\n                fail(\"element \" + i + \" in returned array should be found \"\n                        + \"in the confirmed collection's array\");\n            }\n        }\n        for (final boolean element : matched) {\n            assertTrue(element, \"Collection should return all its elements in \" + \"toArray\");\n        }\n    }\n\n    /**\n     *  Tests {@link Collection#toArray(Object[])}.\n     */\n    @Test\n    public void testCollectionToArray2() {\n        resetEmpty();\n        Object[] a = { new Object(), null, null };\n        Object[] array = getCollection().toArray(a);\n        assertEquals(array, a, \"Given array shouldn't shrink\");\n        assertNull(a[0], \"Last element should be set to null\");\n        verify();\n\n        resetFull();\n        assertThrows(ArrayStoreException.class, () -> getCollection().toArray(new Void[0]),\n                \"toArray(new Void[0]) should raise ArrayStore\");\n        verify();\n\n        // Casting to Object[] allows compilation on Java 11.\n        assertThrows(NullPointerException.class, () -> getCollection().toArray((Object[]) null),\n                \"toArray(null) should raise NPE\");\n        verify();\n\n        array = getCollection().toArray(ArrayUtils.EMPTY_OBJECT_ARRAY);\n        a = getCollection().toArray();\n\n        if ((getIterationBehaviour() & UNORDERED) != 0) {\n            assertUnorderedArrayEquals(array, a, \"toArray(Object[]) and toArray()\");\n        } else {\n            assertEquals(Arrays.asList(array), Arrays.asList(a), \"toArrays should be equal\");\n        }\n        // Figure out if they're all the same class\n        // TODO: It'd be nicer to detect a common superclass\n        final HashSet<Class<?>> classes = new HashSet<>();\n        for (final Object element : array) {\n            classes.add(element == null ? null : element.getClass());\n        }\n        if (classes.size() > 1) {\n            return;\n        }\n\n        Class<?> cl = classes.iterator().next();\n        if (Map.Entry.class.isAssignableFrom(cl)) {  // check needed for protective cases like Predicated/Unmod map entrySet\n            cl = Map.Entry.class;\n        }\n        a = (Object[]) Array.newInstance(cl, 0);\n        array = getCollection().toArray(a);\n        assertEquals(a.getClass(), array.getClass(),\n                \"toArray(Object[]) should return correct array type\");\n\n        if ((getIterationBehaviour() & UNORDERED) != 0) {\n            assertUnorderedArrayEquals(array, getCollection().toArray(), \"type-specific toArray(T[]) and toArray()\");\n        } else {\n            assertEquals(Arrays.asList(array),\n                    Arrays.asList(getCollection().toArray()),\n                    \"type-specific toArrays should be equal\");\n        }\n        verify();\n    }\n\n    /**\n     *  Tests {@code toString} on a collection.\n     */\n    @Test\n    public void testCollectionToString() {\n        resetEmpty();\n        assertNotNull(getCollection().toString(), \"toString shouldn't return null\");\n\n        resetFull();\n        assertNotNull(getCollection().toString(), \"toString shouldn't return null\");\n    }\n\n    @Test\n    @Override\n    public void testSerializeDeserializeThenCompare() throws Exception {\n        Object obj = makeObject();\n        if (obj instanceof Serializable && isTestSerialization()) {\n            final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            final ObjectOutputStream out = new ObjectOutputStream(buffer);\n            out.writeObject(obj);\n            out.close();\n\n            final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n            final Object dest = in.readObject();\n            in.close();\n            if (isEqualsCheckable()) {\n                assertEquals(obj, dest, \"obj != deserialize(serialize(obj)) - EMPTY Collection\");\n            }\n        }\n        obj = makeFullCollection();\n        if (obj instanceof Serializable && isTestSerialization()) {\n            final ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            final ObjectOutputStream out = new ObjectOutputStream(buffer);\n            out.writeObject(obj);\n            out.close();\n\n            final ObjectInputStream in = new ObjectInputStream(new ByteArrayInputStream(buffer.toByteArray()));\n            final Object dest = in.readObject();\n            in.close();\n            if (isEqualsCheckable()) {\n                assertEquals(obj, dest, \"obj != deserialize(serialize(obj)) - FULL Collection\");\n            }\n        }\n    }\n\n    /**\n     *  If {@link #isAddSupported()} returns false, tests that add operations\n     *  raise <code>UnsupportedOperationException.\n     */\n    @Test\n    public void testUnsupportedAdd() {\n        if (isAddSupported()) {\n            return;\n        }\n\n        resetEmpty();\n        assertThrows(UnsupportedOperationException.class, () -> getCollection().add(getFullNonNullElements()[0]),\n                \"Empty collection should not support add.\");\n        // make sure things didn't change even if the expected exception was\n        // thrown.\n        verify();\n\n        assertThrows(UnsupportedOperationException.class, () -> getCollection().addAll(Arrays.asList(getFullElements())),\n                \"Empty collection should not support addAll.\");\n        // make sure things didn't change even if the expected exception was\n        // thrown.\n        verify();\n\n        resetFull();\n        assertThrows(UnsupportedOperationException.class, () -> getCollection().add(getFullNonNullElements()[0]),\n                \"Full collection should not support add.\");\n        // make sure things didn't change even if the expected exception was\n        // thrown.\n        verify();\n\n        assertThrows(UnsupportedOperationException.class, () -> getCollection().addAll(Arrays.asList(getOtherElements())),\n                \"Full collection should not support addAll.\");\n        // make sure things didn't change even if the expected exception was\n        // thrown.\n        verify();\n    }\n\n    /**\n     *  If isRemoveSupported() returns false, tests to see that remove\n     *  operations raise an UnsupportedOperationException.\n     */\n    @Test\n    public void testUnsupportedRemove() {\n        if (isRemoveSupported()) {\n            return;\n        }\n\n        resetEmpty();\n        assertThrows(UnsupportedOperationException.class, () -> getCollection().clear(),\n                \"clear should raise UnsupportedOperationException\");\n        verify();\n\n        assertThrows(UnsupportedOperationException.class, () -> getCollection().remove(null),\n                \"remove should raise UnsupportedOperationException\");\n        verify();\n\n        assertThrows(UnsupportedOperationException.class, () -> getCollection().removeIf(e -> true),\n                \"removeIf should raise UnsupportedOperationException\");\n        verify();\n\n        assertThrows(UnsupportedOperationException.class, () -> getCollection().removeAll(null),\n                \"removeAll should raise UnsupportedOperationException\");\n        verify();\n\n        assertThrows(UnsupportedOperationException.class, () -> getCollection().retainAll(null),\n                \"retainAll should raise UnsupportedOperationException\");\n        verify();\n\n        resetFull();\n        final Iterator<E> iterator = getCollection().iterator();\n        iterator.next();\n        assertThrows(UnsupportedOperationException.class, () -> iterator.remove(),\n                \"iterator.remove should raise UnsupportedOperationException\");\n        verify();\n\n    }\n\n    /**\n     *  Verifies that {@link #collection} and {@link #confirmed} have\n     *  identical state.\n     */\n    public void verify() {\n        final int confirmedSize = getConfirmed().size();\n        assertEquals(confirmedSize, getCollection().size(),\n                \"Collection size should match confirmed collection's\");\n        assertEquals(getConfirmed().isEmpty(), getCollection().isEmpty(),\n                \"Collection isEmpty() result should match confirmed collection's\");\n\n        // verify the collections are the same by attempting to match each\n        // object in the collection and confirmed collection.  To account for\n        // duplicates and differing orders, each confirmed element is copied\n        // into an array and a flag is maintained for each element to determine\n        // whether it has been matched once and only once.  If all elements in\n        // the confirmed collection are matched once and only once and there\n        // aren't any elements left to be matched in the collection,\n        // verification is a success.\n\n        // copy each collection value into an array\n        final Object[] confirmedValues = new Object[confirmedSize];\n\n        Iterator<E> iter;\n\n        iter = getConfirmed().iterator();\n        int pos = 0;\n        while (iter.hasNext()) {\n            confirmedValues[pos++] = iter.next();\n        }\n\n        // allocate an array of boolean flags for tracking values that have\n        // been matched once and only once.\n        final boolean[] matched = new boolean[confirmedSize];\n\n        // now iterate through the values of the collection and try to match\n        // the value with one in the confirmed array.\n        iter = getCollection().iterator();\n        while (iter.hasNext()) {\n            final Object o = iter.next();\n            boolean match = false;\n            for (int i = 0; i < confirmedSize; i++) {\n                if (matched[i]) {\n                    // skip values already matched\n                    continue;\n                }\n                if (Objects.equals(o, confirmedValues[i])) {\n                    // values matched\n                    matched[i] = true;\n                    match = true;\n                    break;\n                }\n            }\n            // no match found!\n            if (!match) {\n                fail(\"Collection should not contain a value that the \"\n                        + \"confirmed collection does not have: \" + o + \"\\nTest: \" + getCollection()\n                        + \"\\nReal: \" + getConfirmed());\n            }\n        }\n\n        // make sure there aren't any unmatched values\n        for (int i = 0; i < confirmedSize; i++) {\n            if (!matched[i]) {\n                // the collection didn't match all the confirmed values\n                fail(\"Collection should contain all values that are in the confirmed collection\"\n                        + \"\\nTest: \" + getCollection() + \"\\nReal: \" + getConfirmed());\n            }\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final int UNORDERED = 0x1;", "docstring": "\nFlag to indicate the collection makes no ordering guarantees for the iterator. If this is not used\nthen the behavior is assumed to be ordered and the output order of the iterator is matched by\nthe toArray method.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "UNORDERED = 0x1", "syntax_pass": true}, {"attribute_expression": "private Collection<E> collection;", "docstring": "\n A collection instance that will be used for testing.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<E>", "name": "collection", "syntax_pass": true}, {"attribute_expression": "private Collection<E> confirmed;", "docstring": "\n Confirmed collection.  This is an instance of a collection that is\n confirmed to conform exactly to the java.util.Collection contract.\n Modification operations are tested by performing a mod on your\n collection, performing the exact same mod on an equivalent confirmed\n collection, and then calling verify() to make sure your collection\n still matches the confirmed collection.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<E>", "name": "confirmed", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest", "name": "AbstractMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java", "superclasses": "AbstractObjectTest", "methods": ["[Map.Entry<K, V>]cloneMapEntry(Map.Entry<K, V>)", "[]AbstractMapTest(String)", "[void]addSampleMappings(Map<? super K, ? super V>)", "[boolean]areEqualElementsDistinguishable()", "[BulkTest]bulkTestMapEntrySet()", "[BulkTest]bulkTestMapKeySet()", "[BulkTest]bulkTestMapValues()", "[List<E>]getAsList(Object[])", "[String]getCompatibilityVersion()", "[Map<K, V>]getConfirmed()", "[int]getIterationBehaviour()", "[Map<K, V>]getMap()", "[V[]]getNewSampleValues()", "[K[]]getOtherKeys()", "[Object[]]getOtherNonNullStringElements()", "[V[]]getOtherValues()", "[K[]]getSampleKeys()", "[V[]]getSampleValues()", "[boolean]isAllowDuplicateValues()", "[boolean]isAllowNullKey()", "[boolean]isAllowNullValue()", "[boolean]isFailFastExpected()", "[boolean]isGetStructuralModify()", "[boolean]isPutAddSupported()", "[boolean]isPutChangeSupported()", "[boolean]isRemoveSupported()", "[boolean]isSetValueSupported()", "[boolean]isSubMapViewsSerializable()", "[Map<K, V>]makeConfirmedMap()", "[Map.Entry<K, V>[]]makeEntryArray(K[],V[])", "[Map<K, V>]makeFullMap()", "[Map<K, V>]makeObject()", "[void]resetEmpty()", "[void]resetFull()", "[void]tearDown()", "[void]verify()", "[void]verifyEntrySet()", "[void]verifyKeySet()", "[void]verifyMap()", "[void]verifyValues()", "[void]views()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[Map.Entry<K, V>]cloneMapEntry(Map.Entry<K, V>)", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[]AbstractMapTest(String)", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[void]addSampleMappings(Map<? super K, ? super V>)", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[boolean]areEqualElementsDistinguishable()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[BulkTest]bulkTestMapEntrySet()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[BulkTest]bulkTestMapKeySet()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[BulkTest]bulkTestMapValues()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[List<E>]getAsList(Object[])", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[Map<K, V>]getConfirmed()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[Map<K, V>]getMap()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[V[]]getNewSampleValues()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[K[]]getOtherKeys()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[Object[]]getOtherNonNullStringElements()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[V[]]getOtherValues()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[K[]]getSampleKeys()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[V[]]getSampleValues()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[boolean]isAllowDuplicateValues()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[boolean]isAllowNullValue()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[boolean]isFailFastExpected()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[boolean]isGetStructuralModify()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[boolean]isPutAddSupported()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[boolean]isPutChangeSupported()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[boolean]isSetValueSupported()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[boolean]isSubMapViewsSerializable()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[Map<K, V>]makeConfirmedMap()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[Map.Entry<K, V>[]]makeEntryArray(K[],V[])", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[Map<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[Map<K, V>]makeObject()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[void]resetEmpty()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[void]resetFull()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[void]tearDown()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[void]verify()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[void]verifyEntrySet()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[void]verifyKeySet()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[void]verifyMap()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[void]verifyValues()", "src/test/java/org/apache/commons/collections4/map/AbstractMapTest.java.AbstractMapTest.[void]views()"], "overrides": null, "attributes": [{"original_string": "    public class TestMapEntrySet extends AbstractSetTest<Map.Entry<K, V>> {\n        public TestMapEntrySet() {\n            super(\"MapEntrySet\");\n        }\n\n        @Override\n        public boolean areEqualElementsDistinguishable() {\n            return AbstractMapTest.this.areEqualElementsDistinguishable();\n        }\n\n        public Map.Entry<K, V> getEntry(final Iterator<Map.Entry<K, V>> itConfirmed, final K key) {\n            Map.Entry<K, V> entry = null;\n            while (itConfirmed.hasNext()) {\n                final Map.Entry<K, V> temp = itConfirmed.next();\n                if (temp.getKey() == null) {\n                    if (key == null) {\n                        entry = temp;\n                        break;\n                    }\n                } else if (temp.getKey().equals(key)) {\n                    entry = temp;\n                    break;\n                }\n            }\n            assertNotNull(entry, \"No matching entry in map for key '\" + key + \"'\");\n            return entry;\n        }\n\n        // Have to implement manually; entrySet doesn't support addAll\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Entry<K, V>[] getFullElements() {\n            return getFullNonNullElements();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Map.Entry<K, V>[] getFullNonNullElements() {\n            final K[] k = getSampleKeys();\n            final V[] v = getSampleValues();\n            return makeEntryArray(k, v);\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMapTest.this.getIterationBehaviour();\n        }\n\n        // Have to implement manually; entrySet doesn't support addAll\n        @Override\n        public Map.Entry<K, V>[] getOtherElements() {\n            final K[] k = getOtherKeys();\n            final V[] v = getOtherValues();\n            return makeEntryArray(k, v);\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            // Collection views don't support add operations.\n            return false;\n        }\n\n        public boolean isGetStructuralModify() {\n            return AbstractMapTest.this.isGetStructuralModify();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            // Entry set should only support remove if map does\n            return AbstractMapTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Set<Map.Entry<K, V>> makeFullCollection() {\n            return makeFullMap().entrySet();\n        }\n\n        @Override\n        public Set<Map.Entry<K, V>> makeObject() {\n            return AbstractMapTest.this.makeObject().entrySet();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractMapTest.this.resetEmpty();\n            setCollection(AbstractMapTest.this.getMap().entrySet());\n            TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractMapTest.this.resetFull();\n            setCollection(AbstractMapTest.this.getMap().entrySet());\n            TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());\n        }\n\n        @Test\n        public void testMapEntrySetIteratorEntry() {\n            resetFull();\n            int count = 0;\n            for (final Entry<K, V> entry : getCollection()) {\n                assertTrue(AbstractMapTest.this.getMap().containsKey(entry.getKey()));\n                assertTrue(AbstractMapTest.this.getMap().containsValue(entry.getValue()));\n                if (!isGetStructuralModify()) {\n                    assertEquals(AbstractMapTest.this.getMap().get(entry.getKey()), entry.getValue());\n                }\n                count++;\n            }\n            assertEquals(getCollection().size(), count);\n        }\n\n        @Test\n        public void testMapEntrySetIteratorEntrySetValue() {\n            final K key1 = getSampleKeys()[0];\n            final K key2 = getSampleKeys().length == 1 ? getSampleKeys()[0] : getSampleKeys()[1];\n            final V newValue1 = getNewSampleValues()[0];\n            final V newValue2 = getNewSampleValues().length == 1 ? getNewSampleValues()[0] : getNewSampleValues()[1];\n\n            resetFull();\n            // explicitly get entries as sample values/keys are connected for some maps\n            // such as BeanMap\n            Iterator<Map.Entry<K, V>> it = TestMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry1 = getEntry(it, key1);\n            it = TestMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry2 = getEntry(it, key2);\n            Iterator<Map.Entry<K, V>> itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n            itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n            verify();\n\n            if (!isSetValueSupported()) {\n                try {\n                    entry1.setValue(newValue1);\n                } catch (final UnsupportedOperationException ex) {\n                }\n                return;\n            }\n\n            entry1.setValue(newValue1);\n            entryConfirmed1.setValue(newValue1);\n            assertEquals(newValue1, entry1.getValue());\n            assertTrue(AbstractMapTest.this.getMap().containsKey(entry1.getKey()));\n            assertTrue(AbstractMapTest.this.getMap().containsValue(newValue1));\n            assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));\n            verify();\n\n            entry1.setValue(newValue1);\n            entryConfirmed1.setValue(newValue1);\n            assertEquals(newValue1, entry1.getValue());\n            assertTrue(AbstractMapTest.this.getMap().containsKey(entry1.getKey()));\n            assertTrue(AbstractMapTest.this.getMap().containsValue(newValue1));\n            assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));\n            verify();\n\n            entry2.setValue(newValue2);\n            entryConfirmed2.setValue(newValue2);\n            assertEquals(newValue2, entry2.getValue());\n            assertTrue(AbstractMapTest.this.getMap().containsKey(entry2.getKey()));\n            assertTrue(AbstractMapTest.this.getMap().containsValue(newValue2));\n            assertEquals(newValue2, AbstractMapTest.this.getMap().get(entry2.getKey()));\n            verify();\n        }\n\n        @Test\n        public void testMapEntrySetRemoveNonMapEntry() {\n            if (!isRemoveSupported()) {\n                return;\n            }\n            resetFull();\n            assertFalse(getCollection().remove(null));\n            assertFalse(getCollection().remove(new Object()));\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            AbstractMapTest.this.verify();\n        }\n    }", "definition": "    public class TestMapEntrySet extends AbstractSetTest<Map.Entry<K, V>>", "class_docstring": "", "name": "TestMapEntrySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestMapEntrySet() {\n            super(\"MapEntrySet\");\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestMapEntrySet", "params": [], "body": "                                 {\n            super(\"MapEntrySet\");\n        }", "signature": "public TestMapEntrySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean areEqualElementsDistinguishable() {\n            return AbstractMapTest.this.areEqualElementsDistinguishable();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "areEqualElementsDistinguishable", "params": [], "body": "                                                         {\n            return AbstractMapTest.this.areEqualElementsDistinguishable();\n        }", "signature": "@Override\n        public boolean areEqualElementsDistinguishable()"}, {"syntax_pass": true, "original_string": "        public Map.Entry<K, V> getEntry(final Iterator<Map.Entry<K, V>> itConfirmed, final K key) {\n            Map.Entry<K, V> entry = null;\n            while (itConfirmed.hasNext()) {\n                final Map.Entry<K, V> temp = itConfirmed.next();\n                if (temp.getKey() == null) {\n                    if (key == null) {\n                        entry = temp;\n                        break;\n                    }\n                } else if (temp.getKey().equals(key)) {\n                    entry = temp;\n                    break;\n                }\n            }\n            assertNotNull(entry, \"No matching entry in map for key '\" + key + \"'\");\n            return entry;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "getEntry", "params": [{"name": "itConfirmed", "type": "Iterator<Map.Entry<K, V>>"}, {"name": "key", "type": "K"}], "body": "                                                                                                  {\n            Map.Entry<K, V> entry = null;\n            while (itConfirmed.hasNext()) {\n                final Map.Entry<K, V> temp = itConfirmed.next();\n                if (temp.getKey() == null) {\n                    if (key == null) {\n                        entry = temp;\n                        break;\n                    }\n                } else if (temp.getKey().equals(key)) {\n                    entry = temp;\n                    break;\n                }\n            }\n            assertNotNull(entry, \"No matching entry in map for key '\" + key + \"'\");\n            return entry;\n        }", "signature": "public Map.Entry<K, V> getEntry(final Iterator<Map.Entry<K, V>> itConfirmed, final K key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Entry<K, V>[] getFullElements() {\n            return getFullNonNullElements();\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Entry<K, V>[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                               {\n            return getFullNonNullElements();\n        }", "signature": "@Override\n        public Entry<K, V>[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<K, V>[] getFullNonNullElements() {\n            final K[] k = getSampleKeys();\n            final V[] v = getSampleValues();\n            return makeEntryArray(k, v);\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>[]", "classes": []}, "name": "getFullNonNullElements", "params": [], "body": "                                                          {\n            final K[] k = getSampleKeys();\n            final V[] v = getSampleValues();\n            return makeEntryArray(k, v);\n        }", "signature": "@Override\n        public Map.Entry<K, V>[] getFullNonNullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMapTest.this.getIterationBehaviour();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "getIterationBehaviour", "params": [], "body": "                                              {\n            return AbstractMapTest.this.getIterationBehaviour();\n        }", "signature": "@Override\n        protected int getIterationBehaviour()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<K, V>[] getOtherElements() {\n            final K[] k = getOtherKeys();\n            final V[] v = getOtherValues();\n            return makeEntryArray(k, v);\n        }", "docstring": " Have to implement manually; entrySet doesn't support addAll", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>[]", "classes": []}, "name": "getOtherElements", "params": [], "body": "                                                    {\n            final K[] k = getOtherKeys();\n            final V[] v = getOtherValues();\n            return makeEntryArray(k, v);\n        }", "signature": "@Override\n        public Map.Entry<K, V>[] getOtherElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            // Collection views don't support add operations.\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            // Collection views don't support add operations.\n            return false;\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        public boolean isGetStructuralModify() {\n            return AbstractMapTest.this.isGetStructuralModify();\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isGetStructuralModify", "params": [], "body": "                                               {\n            return AbstractMapTest.this.isGetStructuralModify();\n        }", "signature": "public boolean isGetStructuralModify()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            // Entry set should only support remove if map does\n            return AbstractMapTest.this.isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            // Entry set should only support remove if map does\n            return AbstractMapTest.this.isRemoveSupported();\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<Map.Entry<K, V>> makeFullCollection() {\n            return makeFullMap().entrySet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<Map.Entry<K, V>>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                                         {\n            return makeFullMap().entrySet();\n        }", "signature": "@Override\n        public Set<Map.Entry<K, V>> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<Map.Entry<K, V>> makeObject() {\n            return AbstractMapTest.this.makeObject().entrySet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<Map.Entry<K, V>>", "classes": []}, "name": "makeObject", "params": [], "body": "                                                 {\n            return AbstractMapTest.this.makeObject().entrySet();\n        }", "signature": "@Override\n        public Set<Map.Entry<K, V>> makeObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetEmpty() {\n            AbstractMapTest.this.resetEmpty();\n            setCollection(AbstractMapTest.this.getMap().entrySet());\n            TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetEmpty", "params": [], "body": "                                 {\n            AbstractMapTest.this.resetEmpty();\n            setCollection(AbstractMapTest.this.getMap().entrySet());\n            TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());\n        }", "signature": "@Override\n        public void resetEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetFull() {\n            AbstractMapTest.this.resetFull();\n            setCollection(AbstractMapTest.this.getMap().entrySet());\n            TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetFull", "params": [], "body": "                                {\n            AbstractMapTest.this.resetFull();\n            setCollection(AbstractMapTest.this.getMap().entrySet());\n            TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());\n        }", "signature": "@Override\n        public void resetFull()"}, {"syntax_pass": true, "original_string": "        @Test\n        public void testMapEntrySetIteratorEntry() {\n            resetFull();\n            int count = 0;\n            for (final Entry<K, V> entry : getCollection()) {\n                assertTrue(AbstractMapTest.this.getMap().containsKey(entry.getKey()));\n                assertTrue(AbstractMapTest.this.getMap().containsValue(entry.getValue()));\n                if (!isGetStructuralModify()) {\n                    assertEquals(AbstractMapTest.this.getMap().get(entry.getKey()), entry.getValue());\n                }\n                count++;\n            }\n            assertEquals(getCollection().size(), count);\n        }", "docstring": "", "attributes": {"modifiers": "@Test\n        public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMapEntrySetIteratorEntry", "params": [], "body": "                                                   {\n            resetFull();\n            int count = 0;\n            for (final Entry<K, V> entry : getCollection()) {\n                assertTrue(AbstractMapTest.this.getMap().containsKey(entry.getKey()));\n                assertTrue(AbstractMapTest.this.getMap().containsValue(entry.getValue()));\n                if (!isGetStructuralModify()) {\n                    assertEquals(AbstractMapTest.this.getMap().get(entry.getKey()), entry.getValue());\n                }\n                count++;\n            }\n            assertEquals(getCollection().size(), count);\n        }", "signature": "@Test\n        public void testMapEntrySetIteratorEntry()"}, {"syntax_pass": true, "original_string": "        @Test\n        public void testMapEntrySetIteratorEntrySetValue() {\n            final K key1 = getSampleKeys()[0];\n            final K key2 = getSampleKeys().length == 1 ? getSampleKeys()[0] : getSampleKeys()[1];\n            final V newValue1 = getNewSampleValues()[0];\n            final V newValue2 = getNewSampleValues().length == 1 ? getNewSampleValues()[0] : getNewSampleValues()[1];\n\n            resetFull();\n            // explicitly get entries as sample values/keys are connected for some maps\n            // such as BeanMap\n            Iterator<Map.Entry<K, V>> it = TestMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry1 = getEntry(it, key1);\n            it = TestMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry2 = getEntry(it, key2);\n            Iterator<Map.Entry<K, V>> itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n            itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n            verify();\n\n            if (!isSetValueSupported()) {\n                try {\n                    entry1.setValue(newValue1);\n                } catch (final UnsupportedOperationException ex) {\n                }\n                return;\n            }\n\n            entry1.setValue(newValue1);\n            entryConfirmed1.setValue(newValue1);\n            assertEquals(newValue1, entry1.getValue());\n            assertTrue(AbstractMapTest.this.getMap().containsKey(entry1.getKey()));\n            assertTrue(AbstractMapTest.this.getMap().containsValue(newValue1));\n            assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));\n            verify();\n\n            entry1.setValue(newValue1);\n            entryConfirmed1.setValue(newValue1);\n            assertEquals(newValue1, entry1.getValue());\n            assertTrue(AbstractMapTest.this.getMap().containsKey(entry1.getKey()));\n            assertTrue(AbstractMapTest.this.getMap().containsValue(newValue1));\n            assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));\n            verify();\n\n            entry2.setValue(newValue2);\n            entryConfirmed2.setValue(newValue2);\n            assertEquals(newValue2, entry2.getValue());\n            assertTrue(AbstractMapTest.this.getMap().containsKey(entry2.getKey()));\n            assertTrue(AbstractMapTest.this.getMap().containsValue(newValue2));\n            assertEquals(newValue2, AbstractMapTest.this.getMap().get(entry2.getKey()));\n            verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Test\n        public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMapEntrySetIteratorEntrySetValue", "params": [], "body": "                                                           {\n            final K key1 = getSampleKeys()[0];\n            final K key2 = getSampleKeys().length == 1 ? getSampleKeys()[0] : getSampleKeys()[1];\n            final V newValue1 = getNewSampleValues()[0];\n            final V newValue2 = getNewSampleValues().length == 1 ? getNewSampleValues()[0] : getNewSampleValues()[1];\n\n            resetFull();\n            // explicitly get entries as sample values/keys are connected for some maps\n            // such as BeanMap\n            Iterator<Map.Entry<K, V>> it = TestMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry1 = getEntry(it, key1);\n            it = TestMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry2 = getEntry(it, key2);\n            Iterator<Map.Entry<K, V>> itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n            itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n            verify();\n\n            if (!isSetValueSupported()) {\n                try {\n                    entry1.setValue(newValue1);\n                } catch (final UnsupportedOperationException ex) {\n                }\n                return;\n            }\n\n            entry1.setValue(newValue1);\n            entryConfirmed1.setValue(newValue1);\n            assertEquals(newValue1, entry1.getValue());\n            assertTrue(AbstractMapTest.this.getMap().containsKey(entry1.getKey()));\n            assertTrue(AbstractMapTest.this.getMap().containsValue(newValue1));\n            assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));\n            verify();\n\n            entry1.setValue(newValue1);\n            entryConfirmed1.setValue(newValue1);\n            assertEquals(newValue1, entry1.getValue());\n            assertTrue(AbstractMapTest.this.getMap().containsKey(entry1.getKey()));\n            assertTrue(AbstractMapTest.this.getMap().containsValue(newValue1));\n            assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));\n            verify();\n\n            entry2.setValue(newValue2);\n            entryConfirmed2.setValue(newValue2);\n            assertEquals(newValue2, entry2.getValue());\n            assertTrue(AbstractMapTest.this.getMap().containsKey(entry2.getKey()));\n            assertTrue(AbstractMapTest.this.getMap().containsValue(newValue2));\n            assertEquals(newValue2, AbstractMapTest.this.getMap().get(entry2.getKey()));\n            verify();\n        }", "signature": "@Test\n        public void testMapEntrySetIteratorEntrySetValue()"}, {"syntax_pass": true, "original_string": "        @Test\n        public void testMapEntrySetRemoveNonMapEntry() {\n            if (!isRemoveSupported()) {\n                return;\n            }\n            resetFull();\n            assertFalse(getCollection().remove(null));\n            assertFalse(getCollection().remove(new Object()));\n        }", "docstring": "", "attributes": {"modifiers": "@Test\n        public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMapEntrySetRemoveNonMapEntry", "params": [], "body": "                                                       {\n            if (!isRemoveSupported()) {\n                return;\n            }\n            resetFull();\n            assertFalse(getCollection().remove(null));\n            assertFalse(getCollection().remove(new Object()));\n        }", "signature": "@Test\n        public void testMapEntrySetRemoveNonMapEntry()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void verify() {\n            super.verify();\n            AbstractMapTest.this.verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "verify", "params": [], "body": "                             {\n            super.verify();\n            AbstractMapTest.this.verify();\n        }", "signature": "@Override\n        public void verify()"}]}, {"original_string": "    public class TestMapKeySet extends AbstractSetTest<K> {\n        public TestMapKeySet() {\n            super(StringUtils.EMPTY);\n        }\n\n        @Override\n        public K[] getFullElements() {\n            return getSampleKeys();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMapTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public K[] getOtherElements() {\n            return getOtherKeys();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractMapTest.this.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMapTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Set<K> makeFullCollection() {\n            return AbstractMapTest.this.makeFullMap().keySet();\n        }\n\n        @Override\n        public Set<K> makeObject() {\n            return AbstractMapTest.this.makeObject().keySet();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractMapTest.this.resetEmpty();\n            setCollection(AbstractMapTest.this.getMap().keySet());\n            TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractMapTest.this.resetFull();\n            setCollection(AbstractMapTest.this.getMap().keySet());\n            TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            AbstractMapTest.this.verify();\n        }\n\n    }", "definition": "    public class TestMapKeySet extends AbstractSetTest<K>", "class_docstring": "", "name": "TestMapKeySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestMapKeySet() {\n            super(StringUtils.EMPTY);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestMapKeySet", "params": [], "body": "                               {\n            super(StringUtils.EMPTY);\n        }", "signature": "public TestMapKeySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K[] getFullElements() {\n            return getSampleKeys();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                     {\n            return getSampleKeys();\n        }", "signature": "@Override\n        public K[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMapTest.this.getIterationBehaviour();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "getIterationBehaviour", "params": [], "body": "                                              {\n            return AbstractMapTest.this.getIterationBehaviour();\n        }", "signature": "@Override\n        protected int getIterationBehaviour()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K[] getOtherElements() {\n            return getOtherKeys();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K[]", "classes": []}, "name": "getOtherElements", "params": [], "body": "                                      {\n            return getOtherKeys();\n        }", "signature": "@Override\n        public K[] getOtherElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            return false;\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isNullSupported() {\n            return AbstractMapTest.this.isAllowNullKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNullSupported", "params": [], "body": "                                         {\n            return AbstractMapTest.this.isAllowNullKey();\n        }", "signature": "@Override\n        public boolean isNullSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMapTest.this.isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return AbstractMapTest.this.isRemoveSupported();\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<K> makeFullCollection() {\n            return AbstractMapTest.this.makeFullMap().keySet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<K>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                           {\n            return AbstractMapTest.this.makeFullMap().keySet();\n        }", "signature": "@Override\n        public Set<K> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<K> makeObject() {\n            return AbstractMapTest.this.makeObject().keySet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<K>", "classes": []}, "name": "makeObject", "params": [], "body": "                                   {\n            return AbstractMapTest.this.makeObject().keySet();\n        }", "signature": "@Override\n        public Set<K> makeObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetEmpty() {\n            AbstractMapTest.this.resetEmpty();\n            setCollection(AbstractMapTest.this.getMap().keySet());\n            TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetEmpty", "params": [], "body": "                                 {\n            AbstractMapTest.this.resetEmpty();\n            setCollection(AbstractMapTest.this.getMap().keySet());\n            TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());\n        }", "signature": "@Override\n        public void resetEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetFull() {\n            AbstractMapTest.this.resetFull();\n            setCollection(AbstractMapTest.this.getMap().keySet());\n            TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetFull", "params": [], "body": "                                {\n            AbstractMapTest.this.resetFull();\n            setCollection(AbstractMapTest.this.getMap().keySet());\n            TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());\n        }", "signature": "@Override\n        public void resetFull()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void verify() {\n            super.verify();\n            AbstractMapTest.this.verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "verify", "params": [], "body": "                             {\n            super.verify();\n            AbstractMapTest.this.verify();\n        }", "signature": "@Override\n        public void verify()"}]}, {"original_string": "    public class TestMapValues extends AbstractCollectionTest<V> {\n        public TestMapValues() {\n            super(StringUtils.EMPTY);\n        }\n\n        @Override\n        public boolean areEqualElementsDistinguishable() {\n            // equal values are associated with different keys, so they are\n            // distinguishable.\n            return true;\n        }\n\n        @Override\n        public V[] getFullElements() {\n            return getSampleValues();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMapTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public V[] getOtherElements() {\n            return getOtherValues();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractMapTest.this.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMapTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Collection<V> makeConfirmedCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }\n\n        @Override\n        public Collection<V> makeConfirmedFullCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }\n\n        @Override\n        public Collection<V> makeFullCollection() {\n            return AbstractMapTest.this.makeFullMap().values();\n        }\n\n        @Override\n        public Collection<V> makeObject() {\n            return AbstractMapTest.this.makeObject().values();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractMapTest.this.resetEmpty();\n            setCollection(map.values());\n            TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractMapTest.this.resetFull();\n            setCollection(map.values());\n            TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            AbstractMapTest.this.verify();\n        }\n\n        // TODO: should test that a remove on the values collection view\n        // removes the proper mapping and not just any mapping that may have\n        // the value equal to the value returned from the values iterator.\n    }", "definition": "    public class TestMapValues extends AbstractCollectionTest<V>", "class_docstring": " are still equal to the confirmed's collection views.", "name": "TestMapValues", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestMapValues() {\n            super(StringUtils.EMPTY);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestMapValues", "params": [], "body": "                               {\n            super(StringUtils.EMPTY);\n        }", "signature": "public TestMapValues()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean areEqualElementsDistinguishable() {\n            // equal values are associated with different keys, so they are\n            // distinguishable.\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "areEqualElementsDistinguishable", "params": [], "body": "                                                         {\n            // equal values are associated with different keys, so they are\n            // distinguishable.\n            return true;\n        }", "signature": "@Override\n        public boolean areEqualElementsDistinguishable()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V[] getFullElements() {\n            return getSampleValues();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                     {\n            return getSampleValues();\n        }", "signature": "@Override\n        public V[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMapTest.this.getIterationBehaviour();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "getIterationBehaviour", "params": [], "body": "                                              {\n            return AbstractMapTest.this.getIterationBehaviour();\n        }", "signature": "@Override\n        protected int getIterationBehaviour()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V[] getOtherElements() {\n            return getOtherValues();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V[]", "classes": []}, "name": "getOtherElements", "params": [], "body": "                                      {\n            return getOtherValues();\n        }", "signature": "@Override\n        public V[] getOtherElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            return false;\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isNullSupported() {\n            return AbstractMapTest.this.isAllowNullKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNullSupported", "params": [], "body": "                                         {\n            return AbstractMapTest.this.isAllowNullKey();\n        }", "signature": "@Override\n        public boolean isNullSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMapTest.this.isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return AbstractMapTest.this.isRemoveSupported();\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<V> makeConfirmedCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<V>", "classes": []}, "name": "makeConfirmedCollection", "params": [], "body": "                                                       {\n            // never gets called, reset methods are overridden\n            return null;\n        }", "signature": "@Override\n        public Collection<V> makeConfirmedCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<V> makeConfirmedFullCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<V>", "classes": []}, "name": "makeConfirmedFullCollection", "params": [], "body": "                                                           {\n            // never gets called, reset methods are overridden\n            return null;\n        }", "signature": "@Override\n        public Collection<V> makeConfirmedFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<V> makeFullCollection() {\n            return AbstractMapTest.this.makeFullMap().values();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<V>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                                  {\n            return AbstractMapTest.this.makeFullMap().values();\n        }", "signature": "@Override\n        public Collection<V> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<V> makeObject() {\n            return AbstractMapTest.this.makeObject().values();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<V>", "classes": []}, "name": "makeObject", "params": [], "body": "                                          {\n            return AbstractMapTest.this.makeObject().values();\n        }", "signature": "@Override\n        public Collection<V> makeObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetEmpty() {\n            AbstractMapTest.this.resetEmpty();\n            setCollection(map.values());\n            TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetEmpty", "params": [], "body": "                                 {\n            AbstractMapTest.this.resetEmpty();\n            setCollection(map.values());\n            TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());\n        }", "signature": "@Override\n        public void resetEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetFull() {\n            AbstractMapTest.this.resetFull();\n            setCollection(map.values());\n            TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetFull", "params": [], "body": "                                {\n            AbstractMapTest.this.resetFull();\n            setCollection(map.values());\n            TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());\n        }", "signature": "@Override\n        public void resetFull()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void verify() {\n            super.verify();\n            AbstractMapTest.this.verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "verify", "params": [], "body": "                             {\n            super.verify();\n            AbstractMapTest.this.verify();\n        }", "signature": "@Override\n        public void verify()"}]}], "class_docstring": "\nAbstract test class for {@link java.util.Map} methods and contracts.\n<p>\nThe forces at work here are similar to those in {@link AbstractCollectionTest}. If your class implements the full Map interface, including optional\noperations, simply extend this class, and implement the {@link #makeObject()} method.\n<p>\nOn the other hand, if your map implementation is weird, you may have to override one or more of the other protected methods. They're described below.\n<p>\n<b>Entry Population Methods</b>\n<p>\nOverride these methods if your map requires special entries:\n\n<ul>\n<li>{@link #getSampleKeys()}\n<li>{@link #getSampleValues()}\n<li>{@link #getNewSampleValues()}\n<li>{@link #getOtherKeys()}\n<li>{@link #getOtherValues()}\n</ul>\n\n<b>Indicate Map Behaviour</b>\n<p>\nOverride these if your map makes specific behavior guarantees:\n<ul>\n<li>{@link #getIterationBehaviour()}</li>\n</ul>\n\n<b>Supported Operation Methods</b>\n<p>\nOverride these methods if your map doesn't support certain operations:\n\n<ul>\n<li>{@link #isPutAddSupported()}\n<li>{@link #isPutChangeSupported()}\n<li>{@link #isSetValueSupported()}\n<li>{@link #isRemoveSupported()}\n<li>{@link #isGetStructuralModify()}\n<li>{@link #isAllowDuplicateValues()}\n<li>{@link #isAllowNullKey()}\n<li>{@link #isAllowNullValue()}\n</ul>\n\n<b>Fixture Methods</b>\n<p>\nFor tests on modification operations (puts and removes), fixtures are used to verify that that operation results in correct state for the map and its\ncollection views. Basically, the modification is performed against your map implementation, and an identical modification is performed against a\n<em>confirmed</em> map implementation. A confirmed map implementation is something like <Code>java.util.HashMap</Code>, which is known to conform exactly to\nthe {@link Map} contract. After the modification takes place on both your map implementation and the confirmed map implementation, the two maps are compared\nto see if their state is identical. The comparison also compares the collection views to make sure they're still the same.\n<P>\n\nThe upshot of all that is that <em>any</em> test that modifies the map in <em>any</em> way will verify that <em>all</em> of the map's state is still correct,\nincluding the state of its collection views. So for instance if a key is removed by the map's key set's iterator, then the entry set is checked to make sure\nthe key/value pair no longer appears.\n<P>\n\nThe {@link #map} field holds an instance of your collection implementation. The {@link #entrySet}, {@link #keySet} and {@link #values} fields hold that map's\ncollection views. And the {@link #confirmed} field holds an instance of the confirmed collection implementation. The {@link #resetEmpty()} and\n{@link #resetFull()} methods set these fields to empty or full maps, so that tests can proceed from a known state.\n<P>\n\nAfter a modification operation to both {@link #map} and {@link #confirmed}, the {@link #verify()} method is invoked to compare the results. The\n{@link #verify} method calls separate methods to verify the map and its three collection views ({@link #verifyMap}, {@link #verifyEntrySet},\n{@link #verifyKeySet}, and {@link #verifyValues}). You may want to override one of the verification methods to perform additional verifications. For\ninstance, TestDoubleOrderedMap would want override its {@link #verifyValues()} method to verify that the values are unique and in ascending order.\n<P>\n\n<b>Other Notes</b>\n<p>\nIf your {@link Map} fails one of these tests by design, you may still use this base set of cases. Simply override the test case (method) your map fails\nand/or the methods that define the assumptions used by the test cases. For example, if your map does not allow duplicate values, override\n{@link #isAllowDuplicateValues()} and have it return {@code false}\n\n@param <K> the key type.\n@param <V> the value type.\n", "original_string": "public abstract class AbstractMapTest<K, V> extends AbstractObjectTest {\n\n    public class TestMapEntrySet extends AbstractSetTest<Map.Entry<K, V>> {\n        public TestMapEntrySet() {\n            super(\"MapEntrySet\");\n        }\n\n        @Override\n        public boolean areEqualElementsDistinguishable() {\n            return AbstractMapTest.this.areEqualElementsDistinguishable();\n        }\n\n        public Map.Entry<K, V> getEntry(final Iterator<Map.Entry<K, V>> itConfirmed, final K key) {\n            Map.Entry<K, V> entry = null;\n            while (itConfirmed.hasNext()) {\n                final Map.Entry<K, V> temp = itConfirmed.next();\n                if (temp.getKey() == null) {\n                    if (key == null) {\n                        entry = temp;\n                        break;\n                    }\n                } else if (temp.getKey().equals(key)) {\n                    entry = temp;\n                    break;\n                }\n            }\n            assertNotNull(entry, \"No matching entry in map for key '\" + key + \"'\");\n            return entry;\n        }\n\n        // Have to implement manually; entrySet doesn't support addAll\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Entry<K, V>[] getFullElements() {\n            return getFullNonNullElements();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public Map.Entry<K, V>[] getFullNonNullElements() {\n            final K[] k = getSampleKeys();\n            final V[] v = getSampleValues();\n            return makeEntryArray(k, v);\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMapTest.this.getIterationBehaviour();\n        }\n\n        // Have to implement manually; entrySet doesn't support addAll\n        @Override\n        public Map.Entry<K, V>[] getOtherElements() {\n            final K[] k = getOtherKeys();\n            final V[] v = getOtherValues();\n            return makeEntryArray(k, v);\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            // Collection views don't support add operations.\n            return false;\n        }\n\n        public boolean isGetStructuralModify() {\n            return AbstractMapTest.this.isGetStructuralModify();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            // Entry set should only support remove if map does\n            return AbstractMapTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Set<Map.Entry<K, V>> makeFullCollection() {\n            return makeFullMap().entrySet();\n        }\n\n        @Override\n        public Set<Map.Entry<K, V>> makeObject() {\n            return AbstractMapTest.this.makeObject().entrySet();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractMapTest.this.resetEmpty();\n            setCollection(AbstractMapTest.this.getMap().entrySet());\n            TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractMapTest.this.resetFull();\n            setCollection(AbstractMapTest.this.getMap().entrySet());\n            TestMapEntrySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().entrySet());\n        }\n\n        @Test\n        public void testMapEntrySetIteratorEntry() {\n            resetFull();\n            int count = 0;\n            for (final Entry<K, V> entry : getCollection()) {\n                assertTrue(AbstractMapTest.this.getMap().containsKey(entry.getKey()));\n                assertTrue(AbstractMapTest.this.getMap().containsValue(entry.getValue()));\n                if (!isGetStructuralModify()) {\n                    assertEquals(AbstractMapTest.this.getMap().get(entry.getKey()), entry.getValue());\n                }\n                count++;\n            }\n            assertEquals(getCollection().size(), count);\n        }\n\n        @Test\n        public void testMapEntrySetIteratorEntrySetValue() {\n            final K key1 = getSampleKeys()[0];\n            final K key2 = getSampleKeys().length == 1 ? getSampleKeys()[0] : getSampleKeys()[1];\n            final V newValue1 = getNewSampleValues()[0];\n            final V newValue2 = getNewSampleValues().length == 1 ? getNewSampleValues()[0] : getNewSampleValues()[1];\n\n            resetFull();\n            // explicitly get entries as sample values/keys are connected for some maps\n            // such as BeanMap\n            Iterator<Map.Entry<K, V>> it = TestMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry1 = getEntry(it, key1);\n            it = TestMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry2 = getEntry(it, key2);\n            Iterator<Map.Entry<K, V>> itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n            itConfirmed = TestMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n            verify();\n\n            if (!isSetValueSupported()) {\n                try {\n                    entry1.setValue(newValue1);\n                } catch (final UnsupportedOperationException ex) {\n                }\n                return;\n            }\n\n            entry1.setValue(newValue1);\n            entryConfirmed1.setValue(newValue1);\n            assertEquals(newValue1, entry1.getValue());\n            assertTrue(AbstractMapTest.this.getMap().containsKey(entry1.getKey()));\n            assertTrue(AbstractMapTest.this.getMap().containsValue(newValue1));\n            assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));\n            verify();\n\n            entry1.setValue(newValue1);\n            entryConfirmed1.setValue(newValue1);\n            assertEquals(newValue1, entry1.getValue());\n            assertTrue(AbstractMapTest.this.getMap().containsKey(entry1.getKey()));\n            assertTrue(AbstractMapTest.this.getMap().containsValue(newValue1));\n            assertEquals(newValue1, AbstractMapTest.this.getMap().get(entry1.getKey()));\n            verify();\n\n            entry2.setValue(newValue2);\n            entryConfirmed2.setValue(newValue2);\n            assertEquals(newValue2, entry2.getValue());\n            assertTrue(AbstractMapTest.this.getMap().containsKey(entry2.getKey()));\n            assertTrue(AbstractMapTest.this.getMap().containsValue(newValue2));\n            assertEquals(newValue2, AbstractMapTest.this.getMap().get(entry2.getKey()));\n            verify();\n        }\n\n        @Test\n        public void testMapEntrySetRemoveNonMapEntry() {\n            if (!isRemoveSupported()) {\n                return;\n            }\n            resetFull();\n            assertFalse(getCollection().remove(null));\n            assertFalse(getCollection().remove(new Object()));\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            AbstractMapTest.this.verify();\n        }\n    }\n\n    public class TestMapKeySet extends AbstractSetTest<K> {\n        public TestMapKeySet() {\n            super(StringUtils.EMPTY);\n        }\n\n        @Override\n        public K[] getFullElements() {\n            return getSampleKeys();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMapTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public K[] getOtherElements() {\n            return getOtherKeys();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractMapTest.this.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMapTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Set<K> makeFullCollection() {\n            return AbstractMapTest.this.makeFullMap().keySet();\n        }\n\n        @Override\n        public Set<K> makeObject() {\n            return AbstractMapTest.this.makeObject().keySet();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractMapTest.this.resetEmpty();\n            setCollection(AbstractMapTest.this.getMap().keySet());\n            TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractMapTest.this.resetFull();\n            setCollection(AbstractMapTest.this.getMap().keySet());\n            TestMapKeySet.this.setConfirmed(AbstractMapTest.this.getConfirmed().keySet());\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            AbstractMapTest.this.verify();\n        }\n\n    }\n\n    // These instance variables are initialized with the reset method.\n    // Tests for map methods that alter the map (put, putAll, remove)\n    // first call reset() to create the map and its views; then perform\n    // the modification on the map; perform the same modification on the\n    // confirmed; and then call verify() to ensure that the map is equal\n    // to the confirmed, that the already-constructed collection views\n    // are still equal to the confirmed's collection views.\n\n    public class TestMapValues extends AbstractCollectionTest<V> {\n        public TestMapValues() {\n            super(StringUtils.EMPTY);\n        }\n\n        @Override\n        public boolean areEqualElementsDistinguishable() {\n            // equal values are associated with different keys, so they are\n            // distinguishable.\n            return true;\n        }\n\n        @Override\n        public V[] getFullElements() {\n            return getSampleValues();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMapTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public V[] getOtherElements() {\n            return getOtherValues();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractMapTest.this.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMapTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Collection<V> makeConfirmedCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }\n\n        @Override\n        public Collection<V> makeConfirmedFullCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }\n\n        @Override\n        public Collection<V> makeFullCollection() {\n            return AbstractMapTest.this.makeFullMap().values();\n        }\n\n        @Override\n        public Collection<V> makeObject() {\n            return AbstractMapTest.this.makeObject().values();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractMapTest.this.resetEmpty();\n            setCollection(map.values());\n            TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractMapTest.this.resetFull();\n            setCollection(map.values());\n            TestMapValues.this.setConfirmed(AbstractMapTest.this.getConfirmed().values());\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            AbstractMapTest.this.verify();\n        }\n\n        // TODO: should test that a remove on the values collection view\n        // removes the proper mapping and not just any mapping that may have\n        // the value equal to the value returned from the values iterator.\n    }\n\n    /**\n     * Creates a new Map Entry that is independent of the first and the map.\n     *\n     * @param <K> the key type.\n     * @param <V> the value type.\n     */\n    public static <K, V> Map.Entry<K, V> cloneMapEntry(final Map.Entry<K, V> entry) {\n        final HashMap<K, V> map = new HashMap<>();\n        map.put(entry.getKey(), entry.getValue());\n        return map.entrySet().iterator().next();\n    }\n\n    /** Map created by reset(). */\n    protected Map<K, V> map;\n\n    /** Entry set of map created by reset(). */\n    protected Set<Map.Entry<K, V>> entrySet;\n\n    /** Key set of map created by reset(). */\n    protected Set<K> keySet;\n\n    /** Values collection of map created by reset(). */\n    protected Collection<V> values;\n\n    /** HashMap created by reset(). */\n    protected Map<K, V> confirmed;\n\n    /**\n     * JUnit constructor.\n     *\n     * @param testName the test name\n     */\n    public AbstractMapTest(final String testName) {\n        super(testName);\n    }\n\n    /**\n     * Helper method to add all the mappings described by {@link #getSampleKeys()} and {@link #getSampleValues()}.\n     */\n    public void addSampleMappings(final Map<? super K, ? super V> m) {\n\n        final K[] keys = getSampleKeys();\n        final V[] values = getSampleValues();\n\n        for (int i = 0; i < keys.length; i++) {\n            try {\n                m.put(keys[i], values[i]);\n            } catch (final NullPointerException exception) {\n                assertTrue(keys[i] == null || values[i] == null, \"NullPointerException only allowed to be thrown \" + \"if either the key or value is null.\");\n\n                assertTrue(keys[i] == null || !isAllowNullKey(),\n                        \"NullPointerException on null key, but \" + \"isAllowNullKey is not overridden to return false.\");\n\n                assertTrue(values[i] == null || !isAllowNullValue(),\n                        \"NullPointerException on null value, but \" + \"isAllowNullValue is not overridden to return false.\");\n\n                fail(\"Unknown reason for NullPointer.\");\n            }\n        }\n        assertEquals(keys.length, m.size(), \"size must reflect number of mappings added.\");\n    }\n\n    public boolean areEqualElementsDistinguishable() {\n        return false;\n    }\n\n    /**\n     * Bulk test {@link Map#entrySet()}. This method runs through all of the tests in {@link AbstractSetTest}. After modification operations, {@link #verify()}\n     * is invoked to ensure that the map and the other collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing the map's entry set\n     */\n    public BulkTest bulkTestMapEntrySet() {\n        return new TestMapEntrySet();\n    }\n\n    /**\n     * Bulk test {@link Map#keySet()}. This method runs through all of the tests in {@link AbstractSetTest}. After modification operations, {@link #verify()} is\n     * invoked to ensure that the map and the other collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing the map's key set\n     */\n    public BulkTest bulkTestMapKeySet() {\n        return new TestMapKeySet();\n    }\n\n    /**\n     * Bulk test {@link Map#values()}. This method runs through all of the tests in {@link AbstractCollectionTest}. After modification operations,\n     * {@link #verify()} is invoked to ensure that the map and the other collection views are still valid.\n     *\n     * @return a {@link AbstractCollectionTest} instance for testing the map's values collection\n     */\n    public BulkTest bulkTestMapValues() {\n        return new TestMapValues();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected <E> List<E> getAsList(final Object[] o) {\n        final ArrayList<E> result = new ArrayList<>();\n        for (final Object element : o) {\n            result.add((E) element);\n        }\n        return result;\n    }\n\n    /**\n     * Gets the compatibility version, needed for package access.\n     */\n    @Override\n    public String getCompatibilityVersion() {\n        return super.getCompatibilityVersion();\n    }\n\n    /**\n     * Gets the confirmed.\n     *\n     * @return Map<K, V>\n     */\n    public Map<K, V> getConfirmed() {\n        return confirmed;\n    }\n\n    /**\n     * Return a flag specifying the iteration behavior of the collection. This is used to change the assertions used by specific tests. The default\n     * implementation returns 0 which indicates ordered iteration behavior.\n     *\n     * @return the iteration behavior\n     * @see AbstractCollectionTest#UNORDERED\n     */\n    protected int getIterationBehaviour() {\n        return 0;\n    }\n\n    /**\n     * Gets the map.\n     *\n     * @return Map<K, V>\n     */\n    public Map<K, V> getMap() {\n        return map;\n    }\n\n    /**\n     * Returns a set of values that can be used to replace the values returned from {@link #getSampleValues()}. This method must return an array with the same\n     * length as {@link #getSampleValues()}. The values returned from this method should not be the same as those returned from {@link #getSampleValues()}. The\n     * default implementation constructs a set of String values and includes a single null value if {@link #isAllowNullValue()} returns {@code true}, and\n     * includes two values that are the same if {@link #isAllowDuplicateValues()} returns {@code true}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public V[] getNewSampleValues() {\n        final Object[] result = { isAllowNullValue() && isAllowDuplicateValues() ? null : \"newnonnullvalue\", \"newvalue\",\n            isAllowDuplicateValues() ? \"newvalue\" : \"newvalue2\", \"newblahv\", \"newfoov\", \"newbarv\", \"newbazv\", \"newtmpv\", \"newgoshv\", \"newgollyv\", \"newgeev\",\n            \"newhellov\", \"newgoodbyev\", \"newwe'llv\", \"newseev\", \"newyouv\", \"newallv\", \"newagainv\" };\n        return (V[]) result;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public K[] getOtherKeys() {\n        return (K[]) getOtherNonNullStringElements();\n    }\n\n    /**\n     * Returns a list of string elements suitable for return by {@link #getOtherKeys()} or {@link #getOtherValues}.\n     *\n     * <p>\n     * Override getOtherElements to return the results of this method if your collection does not support heterogeneous elements or the null element.\n     * </p>\n     */\n    public Object[] getOtherNonNullStringElements() {\n        return new Object[] { \"For\", \"then\", \"despite\", /* of */\"space\", \"I\", \"would\", \"be\", \"brought\", \"From\", \"limits\", \"far\", \"remote\", \"where\", \"thou\",\n            \"dost\", \"stay\" };\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public V[] getOtherValues() {\n        return (V[]) getOtherNonNullStringElements();\n    }\n\n    /**\n     * Returns the set of keys in the mappings used to test the map. This method must return an array with the same length as {@link #getSampleValues()} and all\n     * array elements must be different. The default implementation constructs a set of String keys, and includes a single null key if {@link #isAllowNullKey()}\n     * returns {@code true}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public K[] getSampleKeys() {\n        final Object[] result = { \"blah\", \"foo\", \"bar\", \"baz\", \"tmp\", \"gosh\", \"golly\", \"gee\", \"hello\", \"goodbye\", \"we'll\", \"see\", \"you\", \"all\", \"again\", \"key\",\n            \"key2\", isAllowNullKey() ? null : \"nonnullkey\" };\n        return (K[]) result;\n    }\n\n    /**\n     * Returns the set of values in the mappings used to test the map. This method must return an array with the same length as {@link #getSampleKeys()}. The\n     * default implementation constructs a set of String values and includes a single null value if {@link #isAllowNullValue()} returns {@code true}, and\n     * includes two values that are the same if {@link #isAllowDuplicateValues()} returns {@code true}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public V[] getSampleValues() {\n        final Object[] result = { \"blahv\", \"foov\", \"barv\", \"bazv\", \"tmpv\", \"goshv\", \"gollyv\", \"geev\", \"hellov\", \"goodbyev\", \"we'llv\", \"seev\", \"youv\", \"allv\",\n            \"againv\", isAllowNullValue() ? null : \"nonnullvalue\", \"value\", isAllowDuplicateValues() ? \"value\" : \"value2\", };\n        return (V[]) result;\n    }\n\n    /**\n     * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()} supports duplicate values.\n     * <p>\n     * Default implementation returns true. Override if your collection class does not support duplicate values.\n     */\n    public boolean isAllowDuplicateValues() {\n        return true;\n    }\n\n    /**\n     * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()} supports null keys.\n     * <p>\n     * Default implementation returns true. Override if your collection class does not support null keys.\n     */\n    public boolean isAllowNullKey() {\n        return true;\n    }\n\n    /**\n     * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()} supports null values.\n     * <p>\n     * Default implementation returns true. Override if your collection class does not support null values.\n     */\n    public boolean isAllowNullValue() {\n        return true;\n    }\n\n    /**\n     * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()} provide fail-fast behavior on their various iterators.\n     * <p>\n     * Default implementation returns true. Override if your collection class does not support fast failure.\n     */\n    public boolean isFailFastExpected() {\n        return true;\n    }\n\n    /**\n     * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()} can cause structural modification on a get(). The example is\n     * LRUMap.\n     * <p>\n     * Default implementation returns false. Override if your map class structurally modifies on get.\n     */\n    public boolean isGetStructuralModify() {\n        return false;\n    }\n\n    /**\n     * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()} support the {@code put} and {@code putAll} operations adding new\n     * mappings.\n     * <p>\n     * Default implementation returns true. Override if your collection class does not support put adding.\n     */\n    public boolean isPutAddSupported() {\n        return true;\n    }\n\n    // tests begin here. Each test adds a little bit of tested functionality.\n    // Many methods assume previous methods passed. That is, they do not\n    // exhaustively recheck things that have already been checked in a previous\n    // test methods.\n\n    /**\n     * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()} support the {@code put} and {@code putAll} operations changing\n     * existing mappings.\n     * <p>\n     * Default implementation returns true. Override if your collection class does not support put changing.\n     */\n    public boolean isPutChangeSupported() {\n        return true;\n    }\n\n    /**\n     * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()} support the {@code remove} and {@code clear} operations.\n     * <p>\n     * Default implementation returns true. Override if your collection class does not support removal operations.\n     */\n    public boolean isRemoveSupported() {\n        return true;\n    }\n\n    /**\n     * Returns true if the maps produced by {@link #makeObject()} and {@link #makeFullMap()} support the {@code setValue} operation on entrySet entries.\n     * <p>\n     * Default implementation returns isPutChangeSupported(). Override if your collection class does not support setValue but does support put changing.\n     */\n    public boolean isSetValueSupported() {\n        return isPutChangeSupported();\n    }\n\n    /**\n     * Returns whether the sub map views of SortedMap are serializable. If the class being tested is based around a TreeMap then you should override and return\n     * false as TreeMap has a bug in deserialization.\n     *\n     * @return false\n     */\n    public boolean isSubMapViewsSerializable() {\n        return true;\n    }\n\n    /**\n     * Override to return a map other than HashMap as the confirmed map.\n     *\n     * @return a map that is known to be valid\n     */\n    public Map<K, V> makeConfirmedMap() {\n        return new HashMap<>();\n    }\n\n    /**\n     * Utility methods to create an array of Map.Entry objects out of the given key and value arrays.\n     * <P>\n     *\n     * @param keys   the array of keys\n     * @param values the array of values\n     * @return an array of Map.Entry of those keys to those values\n     */\n    @SuppressWarnings(\"unchecked\")\n    private Map.Entry<K, V>[] makeEntryArray(final K[] keys, final V[] values) {\n        final Map.Entry<K, V>[] result = new Map.Entry[keys.length];\n        for (int i = 0; i < keys.length; i++) {\n            final Map<K, V> map = makeConfirmedMap();\n            map.put(keys[i], values[i]);\n            result[i] = map.entrySet().iterator().next();\n        }\n        return result;\n    }\n\n    /**\n     * Return a new, populated map. The mappings in the map should match the keys and values returned from {@link #getSampleKeys()} and\n     * {@link #getSampleValues()}. The default implementation uses makeEmptyMap() and calls {@link #addSampleMappings} to add all the mappings to the map.\n     *\n     * @return the map to be tested\n     */\n    public Map<K, V> makeFullMap() {\n        final Map<K, V> m = makeObject();\n        addSampleMappings(m);\n        return m;\n    }\n\n    /**\n     * Return a new, empty {@link Map} to be used for testing.\n     *\n     * @return the map to be tested\n     */\n    @Override\n    public abstract Map<K, V> makeObject();\n\n    /**\n     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet}, {@link #values} and {@link #confirmed} fields to empty.\n     */\n    public void resetEmpty() {\n        map = makeObject();\n        views();\n        confirmed = makeConfirmedMap();\n    }\n\n    /**\n     * Resets the {@link #map}, {@link #entrySet}, {@link #keySet}, {@link #values} and {@link #confirmed} fields to full.\n     */\n    public void resetFull() {\n        map = makeFullMap();\n        views();\n        confirmed = makeConfirmedMap();\n        final K[] k = getSampleKeys();\n        final V[] v = getSampleValues();\n        for (int i = 0; i < k.length; i++) {\n            confirmed.put(k[i], v[i]);\n        }\n    }\n\n    /**\n     * Erases any leftover instance variables by setting them to null.\n     */\n    @AfterEach\n    public void tearDown() throws Exception {\n        map = null;\n        keySet = null;\n        entrySet = null;\n        values = null;\n        confirmed = null;\n    }\n\n    /**\n     * Compare the current serialized form of the Map against the canonical version in SCM.\n     */\n    @Test\n    public void testEmptyMapCompatibility() throws Exception {\n        /*\n         * Create canonical objects with this code Map map = makeEmptyMap(); if (!(map instanceof Serializable)) return;\n         *\n         * writeExternalFormToDisk((Serializable) map, getCanonicalEmptyCollectionName(map));\n         */\n\n        // test to make sure the canonical form has been preserved\n        final Map<K, V> map = makeObject();\n        if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n            @SuppressWarnings(\"unchecked\")\n            final Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n            assertEquals(0, map2.size(), \"Map is empty\");\n        }\n    }\n\n    /**\n     * Tests that the {@link Map#entrySet()} collection is backed by the underlying map for clear().\n     */\n    @Test\n    public void testEntrySetClearChangesMap() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        // clear values, reflected in map\n        resetFull();\n        Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n        assertFalse(getMap().isEmpty());\n        assertFalse(entrySet.isEmpty());\n        entrySet.clear();\n        assertTrue(getMap().isEmpty());\n        assertTrue(entrySet.isEmpty());\n\n        // clear map, reflected in values\n        resetFull();\n        entrySet = getMap().entrySet();\n        assertFalse(getMap().isEmpty());\n        assertFalse(entrySet.isEmpty());\n        getMap().clear();\n        assertTrue(getMap().isEmpty());\n        assertTrue(entrySet.isEmpty());\n    }\n\n    @Test\n    public void testEntrySetContains1() {\n        resetFull();\n        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n        final Map.Entry<K, V> entry = entrySet.iterator().next();\n        assertTrue(entrySet.contains(entry));\n    }\n\n    @Test\n    public void testEntrySetContains2() {\n        resetFull();\n        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n        final Map.Entry<K, V> entry = entrySet.iterator().next();\n        final Map.Entry<K, V> test = cloneMapEntry(entry);\n        assertTrue(entrySet.contains(test));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEntrySetContains3() {\n        resetFull();\n        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n        final Map.Entry<K, V> entry = entrySet.iterator().next();\n        final HashMap<K, V> temp = new HashMap<>();\n        temp.put(entry.getKey(), (V) \"A VERY DIFFERENT VALUE\");\n        final Map.Entry<K, V> test = temp.entrySet().iterator().next();\n        assertFalse(entrySet.contains(test));\n    }\n\n    /**\n     * Verify that entrySet.iterator.remove changes the underlying map.\n     */\n    @Test\n    public void testEntrySetIteratorRemoveChangesMap() {\n        resetFull();\n        for (final Iterator<Map.Entry<K, V>> iter = getMap().entrySet().iterator(); iter.hasNext();) {\n            final K key = iter.next().getKey();\n            try {\n                iter.remove();\n            } catch (final UnsupportedOperationException e) {\n                return;\n            }\n            assertFalse(getMap().containsKey(key));\n        }\n    }\n\n    @Test\n    public void testEntrySetRemove1() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n        resetFull();\n        final int size = getMap().size();\n        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n        final Map.Entry<K, V> entry = entrySet.iterator().next();\n        final K key = entry.getKey();\n\n        assertTrue(entrySet.remove(entry));\n        assertFalse(getMap().containsKey(key));\n        assertEquals(size - 1, getMap().size());\n    }\n\n    @Test\n    public void testEntrySetRemove2() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n        resetFull();\n        final int size = getMap().size();\n        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n        final Map.Entry<K, V> entry = entrySet.iterator().next();\n        final K key = entry.getKey();\n        final Map.Entry<K, V> test = cloneMapEntry(entry);\n\n        assertTrue(entrySet.remove(test));\n        assertFalse(getMap().containsKey(key));\n        assertEquals(size - 1, getMap().size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEntrySetRemove3() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n        resetFull();\n        final int size = getMap().size();\n        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n        final Map.Entry<K, V> entry = entrySet.iterator().next();\n        final K key = entry.getKey();\n        final HashMap<K, V> temp = new HashMap<>();\n        temp.put(entry.getKey(), (V) \"A VERY DIFFERENT VALUE\");\n        final Map.Entry<K, V> test = temp.entrySet().iterator().next();\n\n        assertFalse(entrySet.remove(test));\n        assertTrue(getMap().containsKey(key));\n        assertEquals(size, getMap().size());\n    }\n\n    /**\n     * Test entrySet.removeAll.\n     */\n    @Test\n    public void testEntrySetRemoveAll() {\n        resetFull();\n        final K[] sampleKeys = getSampleKeys();\n        final V[] sampleValues = getSampleValues();\n        // verify map looks as expected:\n        for (int i = 0; i < sampleKeys.length; i++) {\n            if (!getMap().containsKey(sampleKeys[i])) {\n                return;\n            }\n            final V value = sampleValues[i];\n            final V test = getMap().get(sampleKeys[i]);\n            if (value == test || value != null && value.equals(test)) {\n                continue;\n            }\n            return;\n        }\n        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n        final HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<>(entrySet);\n        try {\n            assertFalse(entrySet.removeAll(Collections.<Map.Entry<K, V>>emptySet()));\n        } catch (final UnsupportedOperationException e) {\n            return;\n        }\n        assertEquals(sampleKeys.length, getMap().size());\n        try {\n            assertTrue(entrySet.removeAll(comparisonSet));\n        } catch (final UnsupportedOperationException e) {\n            return;\n        }\n        assertTrue(getMap().isEmpty());\n    }\n\n    /**\n     * Tests that the {@link Map#entrySet} set is backed by the underlying map by removing from the entrySet set and testing if the entry was removed from the\n     * map.\n     */\n    @Test\n    public void testEntrySetRemoveChangesMap() {\n        resetFull();\n        final K[] sampleKeys = getSampleKeys();\n        final V[] sampleValues = getSampleValues();\n        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n        for (int i = 0; i < sampleKeys.length; i++) {\n            try {\n                entrySet.remove(new DefaultMapEntry<>(sampleKeys[i], sampleValues[i]));\n            } catch (final UnsupportedOperationException e) {\n                // if entrySet removal is unsupported, just skip this test\n                return;\n            }\n            assertFalse(getMap().containsKey(sampleKeys[i]), \"Entry should have been removed from the underlying map.\");\n        }\n    }\n\n    /**\n     * Test entrySet.retainAll.\n     */\n    @Test\n    public void testEntrySetRetainAll() {\n        resetFull();\n        final K[] sampleKeys = getSampleKeys();\n        final V[] sampleValues = getSampleValues();\n        // verify map looks as expected:\n        for (int i = 0; i < sampleKeys.length; i++) {\n            if (!getMap().containsKey(sampleKeys[i])) {\n                return;\n            }\n            final V value = sampleValues[i];\n            final V test = getMap().get(sampleKeys[i]);\n            if (value == test || value != null && value.equals(test)) {\n                continue;\n            }\n            return;\n        }\n        final Set<Map.Entry<K, V>> entrySet = getMap().entrySet();\n        final HashSet<Map.Entry<K, V>> comparisonSet = new HashSet<>(entrySet);\n        try {\n            assertFalse(entrySet.retainAll(comparisonSet));\n        } catch (final UnsupportedOperationException e) {\n            return;\n        }\n        assertEquals(sampleKeys.length, getMap().size());\n        try {\n            assertTrue(entrySet.retainAll(Collections.<Map.Entry<K, V>>emptySet()));\n        } catch (final UnsupportedOperationException e) {\n            return;\n        }\n        assertTrue(getMap().isEmpty());\n    }\n\n    /**\n     * Compare the current serialized form of the Map against the canonical version in SCM.\n     */\n    @Test\n    public void testFullMapCompatibility() throws Exception {\n        /*\n         * Create canonical objects with this code Map map = makeFullMap(); if (!(map instanceof Serializable)) return;\n         *\n         * writeExternalFormToDisk((Serializable) map, getCanonicalFullCollectionName(map));\n         */\n\n        // test to make sure the canonical form has been preserved\n        final Map<K, V> map = makeFullMap();\n        if (map instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n            @SuppressWarnings(\"unchecked\")\n            final Map<K, V> map2 = (Map<K, V>) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n            assertEquals(getSampleKeys().length, map2.size(), \"Map is the right size\");\n        }\n    }\n\n    /**\n     * Tests that the {@link Map#keySet} collection is backed by the underlying map for clear().\n     */\n    @Test\n    public void testKeySetClearChangesMap() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        // clear values, reflected in map\n        resetFull();\n        Set<K> keySet = getMap().keySet();\n        assertFalse(getMap().isEmpty());\n        assertFalse(keySet.isEmpty());\n        keySet.clear();\n        assertTrue(getMap().isEmpty());\n        assertTrue(keySet.isEmpty());\n\n        // clear map, reflected in values\n        resetFull();\n        keySet = getMap().keySet();\n        assertFalse(getMap().isEmpty());\n        assertFalse(keySet.isEmpty());\n        getMap().clear();\n        assertTrue(getMap().isEmpty());\n        assertTrue(keySet.isEmpty());\n    }\n\n    /**\n     * Verify that keySet.iterator.remove changes the underlying map.\n     */\n    @Test\n    public void testKeySetIteratorRemoveChangesMap() {\n        resetFull();\n        for (final Iterator<K> iter = getMap().keySet().iterator(); iter.hasNext();) {\n            final K key = iter.next();\n            try {\n                iter.remove();\n            } catch (final UnsupportedOperationException e) {\n                return;\n            }\n            assertFalse(getMap().containsKey(key));\n        }\n    }\n\n    /**\n     * Test keySet.removeAll.\n     */\n    @Test\n    public void testKeySetRemoveAll() {\n        resetFull();\n        final Set<K> keys = getMap().keySet();\n        final List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());\n        if (!keys.equals(sampleKeysAsList)) {\n            return;\n        }\n        try {\n            assertFalse(keys.removeAll(Collections.<K>emptySet()));\n        } catch (final UnsupportedOperationException e) {\n            return;\n        }\n        assertEquals(sampleKeysAsList, keys);\n        try {\n            assertTrue(keys.removeAll(sampleKeysAsList));\n        } catch (final UnsupportedOperationException e) {\n            return;\n        }\n        assertTrue(getMap().isEmpty());\n    }\n\n    /**\n     * Tests that the {@link Map#keySet} set is backed by the underlying map by removing from the keySet set and testing if the key was removed from the map.\n     */\n    @Test\n    public void testKeySetRemoveChangesMap() {\n        resetFull();\n        final K[] sampleKeys = getSampleKeys();\n        final Set<K> keys = getMap().keySet();\n        for (final K sampleKey : sampleKeys) {\n            try {\n                keys.remove(sampleKey);\n            } catch (final UnsupportedOperationException e) {\n                // if key.remove is unsupported, just skip this test\n                return;\n            }\n            assertFalse(getMap().containsKey(sampleKey), \"Key should have been removed from the underlying map.\");\n        }\n    }\n\n    /**\n     * Test keySet.retainAll.\n     */\n    @Test\n    public void testKeySetRetainAll() {\n        resetFull();\n        final Set<K> keys = getMap().keySet();\n        final List<K> sampleKeysAsList = Arrays.asList(getSampleKeys());\n        if (!keys.equals(sampleKeysAsList)) {\n            return;\n        }\n        try {\n            assertFalse(keys.retainAll(sampleKeysAsList));\n        } catch (final UnsupportedOperationException e) {\n            return;\n        }\n        assertEquals(sampleKeysAsList, keys);\n        try {\n            assertTrue(keys.retainAll(Collections.<K>emptySet()));\n        } catch (final UnsupportedOperationException e) {\n            return;\n        }\n        assertTrue(getMap().isEmpty());\n    }\n\n    /**\n     * Test to ensure that makeEmptyMap and makeFull returns a new non-null map with each invocation.\n     */\n    @Test\n    public void testMakeMap() {\n        final Map<K, V> em = makeObject();\n        assertNotNull(em, \"failure in test: makeEmptyMap must return a non-null map.\");\n\n        final Map<K, V> em2 = makeObject();\n        assertNotNull(em, \"failure in test: makeEmptyMap must return a non-null map.\");\n\n        assertNotSame(em, em2, \"failure in test: makeEmptyMap must return a new map \" + \"with each invocation.\");\n\n        final Map<K, V> fm = makeFullMap();\n        assertNotNull(fm, \"failure in test: makeFullMap must return a non-null map.\");\n\n        final Map<K, V> fm2 = makeFullMap();\n        assertNotNull(fm2, \"failure in test: makeFullMap must return a non-null map.\");\n\n        assertNotSame(fm, fm2, \"failure in test: makeFullMap must return a new map \" + \"with each invocation.\");\n    }\n\n    /**\n     * Tests {@link Map#clear()}. If the map {@link #isRemoveSupported() can add and remove elements}, then {@link Map#size()} and {@link Map#isEmpty()} are\n     * used to ensure that map has no elements after a call to clear. If the map does not support adding and removing elements, this method checks to ensure\n     * clear throws an UnsupportedOperationException.\n     */\n    @Test\n    public void testMapClear() {\n        if (!isRemoveSupported()) {\n            resetFull();\n            assertThrows(UnsupportedOperationException.class, () -> getMap().clear(), \"Expected UnsupportedOperationException on clear\");\n            return;\n        }\n\n        resetEmpty();\n        getMap().clear();\n        getConfirmed().clear();\n        verify();\n\n        resetFull();\n        getMap().clear();\n        getConfirmed().clear();\n        verify();\n    }\n\n    /**\n     * Tests Map.containsKey(Object) by verifying it returns false for all sample keys on a map created using an empty map and returns true for all sample keys\n     * returned on a full map.\n     */\n    @Test\n    public void testMapContainsKey() {\n        final Object[] keys = getSampleKeys();\n\n        resetEmpty();\n        for (final Object key : keys) {\n            assertFalse(getMap().containsKey(key), \"Map must not contain key when map is empty\");\n        }\n        verify();\n\n        resetFull();\n        for (final Object key : keys) {\n            assertTrue(getMap().containsKey(key), \"Map must contain key for a mapping in the map. \" + \"Missing: \" + key);\n        }\n        verify();\n    }\n\n    /**\n     * Tests Map.containsValue(Object) by verifying it returns false for all sample values on an empty map and returns true for all sample values on a full map.\n     */\n    @Test\n    public void testMapContainsValue() {\n        final Object[] values = getSampleValues();\n\n        resetEmpty();\n        for (final Object value : values) {\n            assertFalse(getMap().containsValue(value), \"Empty map must not contain value\");\n        }\n        verify();\n\n        resetFull();\n        for (final Object value : values) {\n            assertTrue(getMap().containsValue(value), \"Map must contain value for a mapping in the map.\");\n        }\n        verify();\n    }\n\n    /**\n     * Tests Map.equals(Object)\n     */\n    @Test\n    public void testMapEquals() {\n        resetEmpty();\n        assertEquals(getMap(), confirmed, \"Empty maps unequal.\");\n        verify();\n\n        resetFull();\n        assertEquals(getMap(), confirmed, \"Full maps unequal.\");\n        verify();\n\n        resetFull();\n        // modify the HashMap created from the full map and make sure this\n        // change results in map.equals() to return false.\n        final Iterator<K> iter = confirmed.keySet().iterator();\n        iter.next();\n        iter.remove();\n        assertFalse(getMap().equals(confirmed), \"Different maps equal.\");\n\n        resetFull();\n        assertFalse(getMap().equals(null), \"equals(null) returned true.\");\n        assertFalse(getMap().equals(new Object()), \"equals(new Object()) returned true.\");\n        verify();\n    }\n\n    /**\n     * Tests Map.get(Object)\n     */\n    @Test\n    public void testMapGet() {\n        resetEmpty();\n\n        final Object[] keys = getSampleKeys();\n        final Object[] values = getSampleValues();\n\n        for (final Object key : keys) {\n            assertNull(getMap().get(key), \"Empty map.get() should return null.\");\n        }\n        verify();\n\n        resetFull();\n        for (int i = 0; i < keys.length; i++) {\n            assertEquals(values[i], getMap().get(keys[i]), \"Full map.get() should return value from mapping.\");\n        }\n    }\n\n    /**\n     * Tests Map.hashCode()\n     */\n    @Test\n    public void testMapHashCode() {\n        resetEmpty();\n        assertEquals(getMap().hashCode(), confirmed.hashCode(), \"Empty maps have different hashCodes.\");\n\n        resetFull();\n        assertEquals(getMap().hashCode(), confirmed.hashCode(), \"Equal maps have different hashCodes.\");\n    }\n\n    /**\n     * Tests Map.isEmpty()\n     */\n    @Test\n    public void testMapIsEmpty() {\n        resetEmpty();\n        assertTrue(getMap().isEmpty(), \"Map.isEmpty() should return true with an empty map\");\n        verify();\n\n        resetFull();\n        assertFalse(getMap().isEmpty(), \"Map.isEmpty() should return false with a non-empty map\");\n        verify();\n    }\n\n    /**\n     * Tests Map.put(Object, Object)\n     */\n    @Test\n    public void testMapPut() {\n        resetEmpty();\n        final K[] keys = getSampleKeys();\n        final V[] values = getSampleValues();\n        final V[] newValues = getNewSampleValues();\n\n        if (isPutAddSupported()) {\n            for (int i = 0; i < keys.length; i++) {\n                final Object o = getMap().put(keys[i], values[i]);\n                getConfirmed().put(keys[i], values[i]);\n                verify();\n                assertNull(o, \"First map.put should return null\");\n                assertTrue(getMap().containsKey(keys[i]), \"Map should contain key after put\");\n                assertTrue(getMap().containsValue(values[i]), \"Map should contain value after put\");\n            }\n            if (isPutChangeSupported()) {\n                for (int i = 0; i < keys.length; i++) {\n                    final Object o = getMap().put(keys[i], newValues[i]);\n                    getConfirmed().put(keys[i], newValues[i]);\n                    verify();\n                    assertEquals(values[i], o, \"Map.put should return previous value when changed\");\n                    assertTrue(getMap().containsKey(keys[i]), \"Map should still contain key after put when changed\");\n                    assertTrue(getMap().containsValue(newValues[i]), \"Map should contain new value after put when changed\");\n\n                    // if duplicates are allowed, we're not guaranteed that the value\n                    // no longer exists, so don't try checking that.\n                    if (!isAllowDuplicateValues()) {\n                        assertFalse(getMap().containsValue(values[i]), \"Map should not contain old value after put when changed\");\n                    }\n                }\n            } else {\n                try {\n                    // two possible exception here, either valid\n                    getMap().put(keys[0], newValues[0]);\n                    fail(\"Expected IllegalArgumentException or UnsupportedOperationException on put (change)\");\n                } catch (final IllegalArgumentException | UnsupportedOperationException ex) {\n                    // ignore\n                }\n            }\n\n        } else if (isPutChangeSupported()) {\n            resetEmpty();\n            try {\n                getMap().put(keys[0], values[0]);\n                fail(\"Expected UnsupportedOperationException or IllegalArgumentException on put (add) when fixed size\");\n            } catch (final IllegalArgumentException | UnsupportedOperationException ex) {\n                // ignore\n            }\n\n            resetFull();\n            int i = 0;\n            for (final Iterator<K> it = getMap().keySet().iterator(); it.hasNext() && i < newValues.length; i++) {\n                final K key = it.next();\n                final V o = getMap().put(key, newValues[i]);\n                final V value = getConfirmed().put(key, newValues[i]);\n                verify();\n                assertEquals(value, o, \"Map.put should return previous value when changed\");\n                assertTrue(getMap().containsKey(key), \"Map should still contain key after put when changed\");\n                assertTrue(getMap().containsValue(newValues[i]), \"Map should contain new value after put when changed\");\n\n                // if duplicates are allowed, we're not guaranteed that the value\n                // no longer exists, so don't try checking that.\n                if (!isAllowDuplicateValues()) {\n                    assertFalse(getMap().containsValue(values[i]), \"Map should not contain old value after put when changed\");\n                }\n            }\n        } else {\n            assertThrows(UnsupportedOperationException.class, () -> getMap().put(keys[0], values[0]), \"Expected UnsupportedOperationException on put (add)\");\n        }\n    }\n\n    /**\n     * Tests Map.putAll(map)\n     */\n    @Test\n    public void testMapPutAll() {\n        if (!isPutAddSupported()) {\n            if (!isPutChangeSupported()) {\n                final Map<K, V> temp = makeFullMap();\n                resetEmpty();\n                assertThrows(UnsupportedOperationException.class, () -> getMap().putAll(temp), \"Expected UnsupportedOperationException on putAll\");\n            }\n            return;\n        }\n\n        // check putAll OK adding empty map to empty map\n        resetEmpty();\n        assertEquals(0, getMap().size());\n        getMap().putAll(new HashMap<>());\n        assertEquals(0, getMap().size());\n\n        // check putAll OK adding empty map to non-empty map\n        resetFull();\n        final int size = getMap().size();\n        getMap().putAll(new HashMap<>());\n        assertEquals(size, getMap().size());\n\n        // check putAll OK adding non-empty map to empty map\n        resetEmpty();\n        Map<K, V> m2 = makeFullMap();\n        getMap().putAll(m2);\n        getConfirmed().putAll(m2);\n        verify();\n\n        // check putAll OK adding non-empty JDK map to empty map\n        resetEmpty();\n        m2 = makeConfirmedMap();\n        final K[] keys = getSampleKeys();\n        final V[] values = getSampleValues();\n        for (int i = 0; i < keys.length; i++) {\n            m2.put(keys[i], values[i]);\n        }\n        getMap().putAll(m2);\n        getConfirmed().putAll(m2);\n        verify();\n\n        // check putAll OK adding non-empty JDK map to non-empty map\n        resetEmpty();\n        m2 = makeConfirmedMap();\n        getMap().put(keys[0], values[0]);\n        getConfirmed().put(keys[0], values[0]);\n        verify();\n        for (int i = 1; i < keys.length; i++) {\n            m2.put(keys[i], values[i]);\n        }\n        getMap().putAll(m2);\n        getConfirmed().putAll(m2);\n        verify();\n    }\n\n    /**\n     * Tests Map.put(null, value)\n     */\n    @Test\n    public void testMapPutNullKey() {\n        resetFull();\n        final V[] values = getSampleValues();\n\n        if (isPutAddSupported()) {\n            if (isAllowNullKey()) {\n                getMap().put(null, values[0]);\n            } else {\n                try {\n                    getMap().put(null, values[0]);\n                    fail(\"put(null, value) should throw NPE/IAE\");\n                } catch (final NullPointerException | IllegalArgumentException ex) {\n                }\n            }\n        }\n    }\n\n    /**\n     * Tests Map.put(null, value)\n     */\n    @Test\n    public void testMapPutNullValue() {\n        resetFull();\n        final K[] keys = getSampleKeys();\n\n        if (isPutAddSupported()) {\n            if (isAllowNullValue()) {\n                getMap().put(keys[0], null);\n            } else {\n                try {\n                    getMap().put(keys[0], null);\n                    fail(\"put(key, null) should throw NPE/IAE\");\n                } catch (final NullPointerException | IllegalArgumentException ex) {\n                }\n            }\n        }\n    }\n\n    /**\n     * Tests Map.remove(Object)\n     */\n    @Test\n    public void testMapRemove() {\n        if (!isRemoveSupported()) {\n            resetFull();\n            assertThrows(UnsupportedOperationException.class, () -> getMap().remove(getMap().keySet().iterator().next()),\n                    \"Expected UnsupportedOperationException on remove\");\n            return;\n        }\n\n        resetEmpty();\n\n        final Object[] keys = getSampleKeys();\n        final Object[] values = getSampleValues();\n        for (final Object key : keys) {\n            final Object o = getMap().remove(key);\n            assertNull(o, \"First map.remove should return null\");\n        }\n        verify();\n\n        resetFull();\n\n        for (int i = 0; i < keys.length; i++) {\n            final Object o = getMap().remove(keys[i]);\n            getConfirmed().remove(keys[i]);\n            verify();\n\n            assertEquals(values[i], o, \"map.remove with valid key should return value\");\n        }\n\n        final Object[] other = getOtherKeys();\n\n        resetFull();\n        final int size = getMap().size();\n        for (final Object element : other) {\n            final Object o = getMap().remove(element);\n            assertNull(o, \"map.remove for nonexistent key should return null\");\n            assertEquals(size, getMap().size(), \"map.remove for nonexistent key should not \" + \"shrink map\");\n        }\n        verify();\n    }\n\n    /**\n     * Tests Map.size()\n     */\n    @Test\n    public void testMapSize() {\n        resetEmpty();\n        assertEquals(0, getMap().size(), \"Map.size() should be 0 with an empty map\");\n        verify();\n\n        resetFull();\n        assertEquals(getSampleKeys().length, getMap().size(), \"Map.size() should equal the number of entries \" + \"in the map\");\n        verify();\n    }\n\n    /**\n     * Tests Map.toString(). Since the format of the string returned by the toString() method is not defined in the Map interface, there is no common way to\n     * test the results of the toString() method. Therefore, it is encouraged that Map implementations override this test with one that checks the format\n     * matches any format defined in its API. This default implementation just verifies that the toString() method does not return null.\n     */\n    @Test\n    public void testMapToString() {\n        resetEmpty();\n        assertNotNull(getMap().toString(), \"Empty map toString() should not return null\");\n        verify();\n\n        resetFull();\n        assertNotNull(getMap().toString(), \"Empty map toString() should not return null\");\n        verify();\n    }\n\n    /**\n     * Test to ensure the test setup is working properly. This method checks to ensure that the getSampleKeys and getSampleValues methods are returning results\n     * that look appropriate. That is, they both return a non-null array of equal length. The keys array must not have any duplicate values, and may only\n     * contain a (single) null key if isNullKeySupported() returns true. The values array must only have a null value if useNullValue() is true and may only\n     * have duplicate values if isAllowDuplicateValues() returns true.\n     */\n    @Test\n    public void testSampleMappings() {\n        final Object[] keys = getSampleKeys();\n        final Object[] values = getSampleValues();\n        final Object[] newValues = getNewSampleValues();\n\n        assertNotNull(keys, \"failure in test: Must have keys returned from \" + \"getSampleKeys.\");\n\n        assertNotNull(values, \"failure in test: Must have values returned from \" + \"getSampleValues.\");\n\n        // verify keys and values have equivalent lengths (in case getSampleX are\n        // overridden)\n        assertEquals(keys.length, values.length, \"failure in test: not the same number of sample \" + \"keys and values.\");\n\n        assertEquals(values.length, newValues.length, \"failure in test: not the same number of values and new values.\");\n\n        // verify there aren't duplicate keys, and check values\n        for (int i = 0; i < keys.length - 1; i++) {\n            for (int j = i + 1; j < keys.length; j++) {\n                assertTrue(keys[i] != null || keys[j] != null, \"failure in test: duplicate null keys.\");\n                assertTrue(keys[i] == null || keys[j] == null || !keys[i].equals(keys[j]) && !keys[j].equals(keys[i]),\n                        \"failure in test: duplicate non-null key.\");\n            }\n            assertTrue(keys[i] != null || isAllowNullKey(), \"failure in test: found null key, but isNullKeySupported \" + \"is false.\");\n            assertTrue(values[i] != null || isAllowNullValue(), \"failure in test: found null value, but isNullValueSupported \" + \"is false.\");\n            assertTrue(newValues[i] != null || isAllowNullValue(), \"failure in test: found null new value, but isNullValueSupported \" + \"is false.\");\n            assertTrue(values[i] != newValues[i] && (values[i] == null || !values[i].equals(newValues[i])),\n                    \"failure in test: values should not be the same as new value\");\n        }\n    }\n\n    /**\n     * Tests that the {@link Map#bitMaps} collection is backed by the underlying map for clear().\n     */\n    @Test\n    public void testValuesClearChangesMap() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        // clear values, reflected in map\n        resetFull();\n        Collection<V> values = getMap().values();\n        assertFalse(getMap().isEmpty());\n        assertFalse(values.isEmpty());\n        values.clear();\n        assertTrue(getMap().isEmpty());\n        assertTrue(values.isEmpty());\n\n        // clear map, reflected in values\n        resetFull();\n        values = getMap().values();\n        assertFalse(getMap().isEmpty());\n        assertFalse(values.isEmpty());\n        getMap().clear();\n        assertTrue(getMap().isEmpty());\n        assertTrue(values.isEmpty());\n    }\n\n    /**\n     * Verifies that values.iterator.remove changes the underlying map.\n     */\n    @Test\n    @SuppressWarnings(\"boxing\") // OK in test code\n    public void testValuesIteratorRemoveChangesMap() {\n        resetFull();\n        final List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n        final Map<V, Integer> cardinality = CollectionUtils.getCardinalityMap(sampleValuesAsList);\n        final Collection<V> values = getMap().values();\n        for (final Iterator<V> iter = values.iterator(); iter.hasNext();) {\n            final V value = iter.next();\n            Integer count = cardinality.get(value);\n            if (count == null) {\n                return;\n            }\n            try {\n                iter.remove();\n                cardinality.put(value, --count);\n            } catch (final UnsupportedOperationException e) {\n                // if values.iterator.remove is unsupported, just skip this test\n                return;\n            }\n            final boolean expected = count > 0;\n            final StringBuilder msg = new StringBuilder(\"Value should \");\n            msg.append(expected ? \"yet \" : \"no longer \");\n            msg.append(\"be present in the underlying map\");\n            assertEquals(expected, getMap().containsValue(value), msg.toString());\n        }\n        assertTrue(getMap().isEmpty());\n    }\n\n    /**\n     * Tests values.removeAll.\n     */\n    @Test\n    public void testValuesRemoveAll() {\n        resetFull();\n        final Collection<V> values = getMap().values();\n        final List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n        if (!values.equals(sampleValuesAsList)) {\n            return;\n        }\n        try {\n            assertFalse(values.removeAll(Collections.<V>emptySet()));\n        } catch (final UnsupportedOperationException e) {\n            // if values.removeAll is unsupported, just skip this test\n            return;\n        }\n        assertEquals(sampleValuesAsList.size(), getMap().size());\n        try {\n            assertTrue(values.removeAll(sampleValuesAsList));\n        } catch (final UnsupportedOperationException e) {\n            // if values.removeAll is unsupported, just skip this test\n            return;\n        }\n        assertTrue(getMap().isEmpty());\n    }\n\n    /**\n     * Tests that the {@link Map#bitMaps} collection is backed by the underlying map by removing from the values collection and testing if the value was removed\n     * from the map.\n     * <p>\n     * We should really test the \"vice versa\" case--that values removed from the map are removed from the values collection--also, but that's a more difficult\n     * test to construct (lacking a \"removeValue\" method.)\n     * </p>\n     * <p>\n     * See bug <a href=\"https://issues.apache.org/jira/browse/COLLECTIONS-92\"> COLLECTIONS-92</a>.\n     * </p>\n     */\n    @Test\n    public void testValuesRemoveChangesMap() {\n        resetFull();\n        final V[] sampleValues = getSampleValues();\n        final Collection<V> values = getMap().values();\n        for (final V sampleValue : sampleValues) {\n            if (map.containsValue(sampleValue)) {\n                int j = 0; // loop counter prevents infinite loops when remove is broken\n                while (values.contains(sampleValue) && j < 10000) {\n                    try {\n                        values.remove(sampleValue);\n                    } catch (final UnsupportedOperationException e) {\n                        // if values.remove is unsupported, just skip this test\n                        return;\n                    }\n                    j++;\n                }\n                assertTrue(j < 10000, \"values().remove(obj) is broken\");\n                assertFalse(getMap().containsValue(sampleValue), \"Value should have been removed from the underlying map.\");\n            }\n        }\n    }\n\n    /**\n     * Test values.retainAll.\n     */\n    @Test\n    public void testValuesRetainAll() {\n        resetFull();\n        final Collection<V> values = getMap().values();\n        final List<V> sampleValuesAsList = Arrays.asList(getSampleValues());\n        if (!values.equals(sampleValuesAsList)) {\n            return;\n        }\n        try {\n            assertFalse(values.retainAll(sampleValuesAsList));\n        } catch (final UnsupportedOperationException e) {\n            // if values.retainAll is unsupported, just skip this test\n            return;\n        }\n        assertEquals(sampleValuesAsList.size(), getMap().size());\n        try {\n            assertTrue(values.retainAll(Collections.<V>emptySet()));\n        } catch (final UnsupportedOperationException e) {\n            // if values.retainAll is unsupported, just skip this test\n            return;\n        }\n        assertTrue(getMap().isEmpty());\n    }\n\n    /**\n     * Verifies that {@link #map} is still equal to {@link #confirmed}. This method checks that the map is equal to the HashMap, <em>and</em> that the map's\n     * collection views are still equal to the HashMap's collection views. An <Code>equals</Code> test is done on the maps and their collection views; their\n     * size and <Code>isEmpty</Code> results are compared; their hashCodes are compared; and <Code>containsAll</Code> tests are run on the collection views.\n     */\n    public void verify() {\n        verifyMap();\n        verifyEntrySet();\n        verifyKeySet();\n        verifyValues();\n    }\n\n    public void verifyEntrySet() {\n        final int size = getConfirmed().size();\n        final boolean empty = getConfirmed().isEmpty();\n        assertEquals(size, entrySet.size(), \"entrySet should be same size as HashMap's\" + \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet());\n        assertEquals(empty, entrySet.isEmpty(), \"entrySet should be empty if HashMap is\" + \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet());\n        assertTrue(entrySet.containsAll(getConfirmed().entrySet()),\n                \"entrySet should contain all HashMap's elements\" + \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet());\n        assertEquals(getConfirmed().entrySet().hashCode(), entrySet.hashCode(),\n                \"entrySet hashCodes should be the same\" + \"\\nTest: \" + entrySet + \"\\nReal: \" + getConfirmed().entrySet());\n        assertEquals(getConfirmed().entrySet(), entrySet, \"Map's entry set should still equal HashMap's\");\n    }\n\n    public void verifyKeySet() {\n        final int size = getConfirmed().size();\n        final boolean empty = getConfirmed().isEmpty();\n        assertEquals(size, keySet.size(), \"keySet should be same size as HashMap's\" + \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet());\n        assertEquals(empty, keySet.isEmpty(), \"keySet should be empty if HashMap is\" + \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet());\n        assertTrue(keySet.containsAll(getConfirmed().keySet()),\n                \"keySet should contain all HashMap's elements\" + \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet());\n        assertEquals(getConfirmed().keySet().hashCode(), keySet.hashCode(),\n                \"keySet hashCodes should be the same\" + \"\\nTest: \" + keySet + \"\\nReal: \" + getConfirmed().keySet());\n        assertEquals(getConfirmed().keySet(), keySet, \"Map's key set should still equal HashMap's\");\n    }\n\n    public void verifyMap() {\n        final int size = getConfirmed().size();\n        final boolean empty = getConfirmed().isEmpty();\n        assertEquals(size, getMap().size(), \"Map should be same size as HashMap\");\n        assertEquals(empty, getMap().isEmpty(), \"Map should be empty if HashMap is\");\n        assertEquals(getConfirmed().hashCode(), getMap().hashCode(), \"hashCodes should be the same\");\n        // changing the order of the assertion below fails for LRUMap because confirmed is\n        // another collection (e.g. treemap) and confirmed.equals() creates a normal iterator (not\n        // #mapIterator()), which modifies the parent expected modCount of the map object, causing\n        // concurrent modification exceptions.\n        // Because of this we have assertEquals(map, confirmed), and not the other way around.\n        assertEquals(map, confirmed, \"Map should still equal HashMap\");\n        assertEquals(getMap(), getConfirmed(), \"Map should still equal HashMap\");\n    }\n\n    public void verifyValues() {\n        final List<V> known = new ArrayList<>(getConfirmed().values());\n\n        values = getMap().values();\n\n        final List<V> test = new ArrayList<>(values);\n\n        final int size = getConfirmed().size();\n        final boolean empty = getConfirmed().isEmpty();\n        assertEquals(size, values.size(), \"values should be same size as HashMap's\" + \"\\nTest: \" + test + \"\\nReal: \" + known);\n        assertEquals(empty, values.isEmpty(), \"values should be empty if HashMap is\" + \"\\nTest: \" + test + \"\\nReal: \" + known);\n        assertTrue(test.containsAll(known), \"values should contain all HashMap's elements\" + \"\\nTest: \" + test + \"\\nReal: \" + known);\n        assertTrue(known.containsAll(test), \"values should contain all HashMap's elements\" + \"\\nTest: \" + test + \"\\nReal: \" + known);\n        // originally coded to use a HashBag, but now separate jar so...\n        for (final V v : known) {\n            final boolean removed = test.remove(v);\n            assertTrue(removed, \"Map's values should still equal HashMap's\");\n        }\n        assertTrue(test.isEmpty(), \"Map's values should still equal HashMap's\");\n    }\n\n    /**\n     * Resets the collection view fields.\n     */\n    private void views() {\n        keySet = getMap().keySet();\n        // see verifyValues: retrieve the values collection only when verifying them\n        // this.values = getMap().values();\n        entrySet = getMap().entrySet();\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Map<K, V> map;", "docstring": " Map created by reset().", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Map<K, V>", "name": "map", "syntax_pass": true}, {"attribute_expression": "protected Set<Map.Entry<K, V>> entrySet;", "docstring": " Entry set of map created by reset().", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Set<Map.Entry<K, V>>", "name": "entrySet", "syntax_pass": true}, {"attribute_expression": "protected Set<K> keySet;", "docstring": " Key set of map created by reset().", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Set<K>", "name": "keySet", "syntax_pass": true}, {"attribute_expression": "protected Collection<V> values;", "docstring": " Values collection of map created by reset().", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Collection<V>", "name": "values", "syntax_pass": true}, {"attribute_expression": "protected Map<K, V> confirmed;", "docstring": " HashMap created by reset().", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Map<K, V>", "name": "confirmed", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/map/AbstractOrderedMapTest.java.AbstractOrderedMapTest", "name": "AbstractOrderedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/AbstractOrderedMapTest.java", "superclasses": "", "methods": ["[]AbstractOrderedMapTest(String)", "[BulkTest]bulkTestOrderedMapIterator()", "[OrderedMap<K, V>]getMap()", "[K[]]getSampleKeys()", "[Map<K, V>]makeConfirmedMap()", "[OrderedMap<K, V>]makeFullMap()", "[OrderedMap<K, V>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/AbstractOrderedMapTest.java.AbstractOrderedMapTest.[]AbstractOrderedMapTest(String)", "src/test/java/org/apache/commons/collections4/map/AbstractOrderedMapTest.java.AbstractOrderedMapTest.[BulkTest]bulkTestOrderedMapIterator()", "src/test/java/org/apache/commons/collections4/map/AbstractOrderedMapTest.java.AbstractOrderedMapTest.[OrderedMap<K, V>]getMap()", "src/test/java/org/apache/commons/collections4/map/AbstractOrderedMapTest.java.AbstractOrderedMapTest.[K[]]getSampleKeys()", "src/test/java/org/apache/commons/collections4/map/AbstractOrderedMapTest.java.AbstractOrderedMapTest.[Map<K, V>]makeConfirmedMap()", "src/test/java/org/apache/commons/collections4/map/AbstractOrderedMapTest.java.AbstractOrderedMapTest.[OrderedMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/map/AbstractOrderedMapTest.java.AbstractOrderedMapTest.[OrderedMap<K, V>]makeObject()"], "overrides": null, "attributes": [{"original_string": "    public class InnerTestOrderedMapIterator extends AbstractOrderedMapIteratorTest<K, V> {\n        public InnerTestOrderedMapIterator() {\n            super(\"InnerTestOrderedMapIterator\");\n        }\n\n        @Override\n        public Map<K, V> getConfirmedMap() {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }\n\n        @Override\n        public OrderedMap<K, V> getMap() {\n            // assumes makeFullMapIterator() called first\n            return AbstractOrderedMapTest.this.getMap();\n        }\n\n        @Override\n        public boolean isGetStructuralModify() {\n            return AbstractOrderedMapTest.this.isGetStructuralModify();\n        }\n\n        @Override\n        public OrderedMapIterator<K, V> makeEmptyIterator() {\n            resetEmpty();\n            return AbstractOrderedMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public OrderedMapIterator<K, V> makeObject() {\n            resetFull();\n            return AbstractOrderedMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }\n\n        @Override\n        public boolean supportsSetValue() {\n            return isSetValueSupported();\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            AbstractOrderedMapTest.this.verify();\n        }\n    }", "definition": "    public class InnerTestOrderedMapIterator extends AbstractOrderedMapIteratorTest<K, V>", "class_docstring": "", "name": "InnerTestOrderedMapIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public InnerTestOrderedMapIterator() {\n            super(\"InnerTestOrderedMapIterator\");\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "InnerTestOrderedMapIterator", "params": [], "body": "                                             {\n            super(\"InnerTestOrderedMapIterator\");\n        }", "signature": "public InnerTestOrderedMapIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map<K, V> getConfirmedMap() {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<K, V>", "classes": []}, "name": "getConfirmedMap", "params": [], "body": "                                           {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }", "signature": "@Override\n        public Map<K, V> getConfirmedMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public OrderedMap<K, V> getMap() {\n            // assumes makeFullMapIterator() called first\n            return AbstractOrderedMapTest.this.getMap();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "OrderedMap<K, V>", "classes": []}, "name": "getMap", "params": [], "body": "                                         {\n            // assumes makeFullMapIterator() called first\n            return AbstractOrderedMapTest.this.getMap();\n        }", "signature": "@Override\n        public OrderedMap<K, V> getMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isGetStructuralModify() {\n            return AbstractOrderedMapTest.this.isGetStructuralModify();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isGetStructuralModify", "params": [], "body": "                                               {\n            return AbstractOrderedMapTest.this.isGetStructuralModify();\n        }", "signature": "@Override\n        public boolean isGetStructuralModify()"}, {"syntax_pass": true, "original_string": "        @Override\n        public OrderedMapIterator<K, V> makeEmptyIterator() {\n            resetEmpty();\n            return AbstractOrderedMapTest.this.getMap().mapIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "OrderedMapIterator<K, V>", "classes": []}, "name": "makeEmptyIterator", "params": [], "body": "                                                            {\n            resetEmpty();\n            return AbstractOrderedMapTest.this.getMap().mapIterator();\n        }", "signature": "@Override\n        public OrderedMapIterator<K, V> makeEmptyIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public OrderedMapIterator<K, V> makeObject() {\n            resetFull();\n            return AbstractOrderedMapTest.this.getMap().mapIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "OrderedMapIterator<K, V>", "classes": []}, "name": "makeObject", "params": [], "body": "                                                     {\n            resetFull();\n            return AbstractOrderedMapTest.this.getMap().mapIterator();\n        }", "signature": "@Override\n        public OrderedMapIterator<K, V> makeObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "supportsRemove", "params": [], "body": "                                        {\n            return isRemoveSupported();\n        }", "signature": "@Override\n        public boolean supportsRemove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean supportsSetValue() {\n            return isSetValueSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "supportsSetValue", "params": [], "body": "                                          {\n            return isSetValueSupported();\n        }", "signature": "@Override\n        public boolean supportsSetValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void verify() {\n            super.verify();\n            AbstractOrderedMapTest.this.verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "verify", "params": [], "body": "                             {\n            super.verify();\n            AbstractOrderedMapTest.this.verify();\n        }", "signature": "@Override\n        public void verify()"}]}], "class_docstring": "\nAbstract test class for {@link OrderedMap} methods and contracts.\n\n@param <K> the type of the keys in the maps tested.\n@param <V> the type of the values in the maps tested.\n", "original_string": "public abstract class AbstractOrderedMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n\n    public class InnerTestOrderedMapIterator extends AbstractOrderedMapIteratorTest<K, V> {\n        public InnerTestOrderedMapIterator() {\n            super(\"InnerTestOrderedMapIterator\");\n        }\n\n        @Override\n        public Map<K, V> getConfirmedMap() {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }\n\n        @Override\n        public OrderedMap<K, V> getMap() {\n            // assumes makeFullMapIterator() called first\n            return AbstractOrderedMapTest.this.getMap();\n        }\n\n        @Override\n        public boolean isGetStructuralModify() {\n            return AbstractOrderedMapTest.this.isGetStructuralModify();\n        }\n\n        @Override\n        public OrderedMapIterator<K, V> makeEmptyIterator() {\n            resetEmpty();\n            return AbstractOrderedMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public OrderedMapIterator<K, V> makeObject() {\n            resetFull();\n            return AbstractOrderedMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }\n\n        @Override\n        public boolean supportsSetValue() {\n            return isSetValueSupported();\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            AbstractOrderedMapTest.this.verify();\n        }\n    }\n\n    /**\n     * JUnit constructor.\n     *\n     * @param testName the test name\n     */\n    public AbstractOrderedMapTest(final String testName) {\n        super(testName);\n    }\n\n    public BulkTest bulkTestOrderedMapIterator() {\n        return new InnerTestOrderedMapIterator();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public OrderedMap<K, V> getMap() {\n        return (OrderedMap<K, V>) super.getMap();\n    }\n\n    /**\n     * The only confirmed collection we have that is ordered is the sorted one. Thus, sort the keys.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public K[] getSampleKeys() {\n        final List<K> list = new ArrayList<>(Arrays.asList(super.getSampleKeys()));\n        list.sort(new NullComparator<>());\n        return (K[]) list.toArray();\n    }\n\n    /**\n     * OrderedMap uses TreeMap as its known comparison.\n     *\n     * @return a map that is known to be valid\n     */\n    @Override\n    public Map<K, V> makeConfirmedMap() {\n        return new TreeMap<>(new NullComparator<>());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public OrderedMap<K, V> makeFullMap() {\n        return (OrderedMap<K, V>) super.makeFullMap();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public abstract OrderedMap<K, V> makeObject();\n\n    @Test\n    public void testFirstKey() {\n        resetEmpty();\n        OrderedMap<K, V> ordered = getMap();\n        final OrderedMap<K, V> finalOrdered = ordered;\n        assertThrows(NoSuchElementException.class, () -> finalOrdered.firstKey());\n\n        resetFull();\n        ordered = getMap();\n        final K confirmedFirst = confirmed.keySet().iterator().next();\n        assertEquals(confirmedFirst, ordered.firstKey());\n    }\n\n    @Test\n    public void testLastKey() {\n        resetEmpty();\n        OrderedMap<K, V> ordered = getMap();\n        final OrderedMap<K, V> finalOrdered = ordered;\n        assertThrows(NoSuchElementException.class, () -> finalOrdered.lastKey());\n\n        resetFull();\n        ordered = getMap();\n        K confirmedLast = null;\n        for (final Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {\n            confirmedLast = it.next();\n        }\n        assertEquals(confirmedLast, ordered.lastKey());\n    }\n\n    @Test\n    public void testNextKey() {\n        resetEmpty();\n        OrderedMap<K, V> ordered = getMap();\n        assertNull(ordered.nextKey(getOtherKeys()[0]));\n        if (!isAllowNullKey()) {\n            try {\n                assertNull(ordered.nextKey(null)); // this is allowed too\n            } catch (final NullPointerException ex) {\n            }\n        } else {\n            assertNull(ordered.nextKey(null));\n        }\n\n        resetFull();\n        ordered = getMap();\n        final Iterator<K> it = confirmed.keySet().iterator();\n        K confirmedLast = it.next();\n        while (it.hasNext()) {\n            final K confirmedObject = it.next();\n            assertEquals(confirmedObject, ordered.nextKey(confirmedLast));\n            confirmedLast = confirmedObject;\n        }\n        assertNull(ordered.nextKey(confirmedLast));\n\n        if (!isAllowNullKey()) {\n            final OrderedMap<K, V> finalOrdered = ordered;\n            assertThrows(NullPointerException.class, () -> finalOrdered.nextKey(null));\n        } else {\n            assertNull(ordered.nextKey(null));\n        }\n    }\n\n    @Test\n    public void testPreviousKey() {\n        resetEmpty();\n        OrderedMap<K, V> ordered = getMap();\n        assertNull(ordered.previousKey(getOtherKeys()[0]));\n        if (!isAllowNullKey()) {\n            try {\n                assertNull(ordered.previousKey(null)); // this is allowed too\n            } catch (final NullPointerException ex) {\n            }\n        } else {\n            assertNull(ordered.previousKey(null));\n        }\n\n        resetFull();\n        ordered = getMap();\n        final List<K> list = new ArrayList<>(confirmed.keySet());\n        Collections.reverse(list);\n        final Iterator<K> it = list.iterator();\n        K confirmedLast = it.next();\n        while (it.hasNext()) {\n            final K confirmedObject = it.next();\n            assertEquals(confirmedObject, ordered.previousKey(confirmedLast));\n            confirmedLast = confirmedObject;\n        }\n        assertNull(ordered.previousKey(confirmedLast));\n\n        if (!isAllowNullKey()) {\n            final OrderedMap<K, V> finalOrdered = ordered;\n            assertThrows(NullPointerException.class, () -> finalOrdered.previousKey(null));\n        } else if (!isAllowNullKey()) {\n            assertNull(ordered.previousKey(null));\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/AbstractIterableMapTest.java.AbstractIterableMapTest", "name": "AbstractIterableMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/AbstractIterableMapTest.java", "superclasses": "", "methods": ["[]AbstractIterableMapTest(String)", "[BulkTest]bulkTestMapIterator()", "[IterableMap<K, V>]getMap()", "[IterableMap<K, V>]makeFullMap()", "[IterableMap<K, V>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/AbstractIterableMapTest.java.AbstractIterableMapTest.[]AbstractIterableMapTest(String)", "src/test/java/org/apache/commons/collections4/map/AbstractIterableMapTest.java.AbstractIterableMapTest.[BulkTest]bulkTestMapIterator()", "src/test/java/org/apache/commons/collections4/map/AbstractIterableMapTest.java.AbstractIterableMapTest.[IterableMap<K, V>]getMap()", "src/test/java/org/apache/commons/collections4/map/AbstractIterableMapTest.java.AbstractIterableMapTest.[IterableMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/map/AbstractIterableMapTest.java.AbstractIterableMapTest.[IterableMap<K, V>]makeObject()"], "overrides": null, "attributes": [{"original_string": "    public class InnerTestMapIterator extends AbstractMapIteratorTest<K, V> {\n        public InnerTestMapIterator() {\n            super(\"InnerTestMapIterator\");\n        }\n\n        @Override\n        public V[] addSetValues() {\n            return getNewSampleValues();\n        }\n\n        @Override\n        public Map<K, V> getConfirmedMap() {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }\n\n        @Override\n        public Map<K, V> getMap() {\n            // assumes makeFullMapIterator() called first\n            return AbstractIterableMapTest.this.getMap();\n        }\n\n        @Override\n        public boolean isGetStructuralModify() {\n            return AbstractIterableMapTest.this.isGetStructuralModify();\n        }\n\n        @Override\n        public MapIterator<K, V> makeEmptyIterator() {\n            resetEmpty();\n            return AbstractIterableMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public MapIterator<K, V> makeObject() {\n            resetFull();\n            return AbstractIterableMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }\n\n        @Override\n        public boolean supportsSetValue() {\n            return isSetValueSupported();\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            AbstractIterableMapTest.this.verify();\n        }\n    }", "definition": "    public class InnerTestMapIterator extends AbstractMapIteratorTest<K, V>", "class_docstring": "", "name": "InnerTestMapIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public InnerTestMapIterator() {\n            super(\"InnerTestMapIterator\");\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "InnerTestMapIterator", "params": [], "body": "                                      {\n            super(\"InnerTestMapIterator\");\n        }", "signature": "public InnerTestMapIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V[] addSetValues() {\n            return getNewSampleValues();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V[]", "classes": []}, "name": "addSetValues", "params": [], "body": "                                  {\n            return getNewSampleValues();\n        }", "signature": "@Override\n        public V[] addSetValues()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map<K, V> getConfirmedMap() {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<K, V>", "classes": []}, "name": "getConfirmedMap", "params": [], "body": "                                           {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }", "signature": "@Override\n        public Map<K, V> getConfirmedMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map<K, V> getMap() {\n            // assumes makeFullMapIterator() called first\n            return AbstractIterableMapTest.this.getMap();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<K, V>", "classes": []}, "name": "getMap", "params": [], "body": "                                  {\n            // assumes makeFullMapIterator() called first\n            return AbstractIterableMapTest.this.getMap();\n        }", "signature": "@Override\n        public Map<K, V> getMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isGetStructuralModify() {\n            return AbstractIterableMapTest.this.isGetStructuralModify();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isGetStructuralModify", "params": [], "body": "                                               {\n            return AbstractIterableMapTest.this.isGetStructuralModify();\n        }", "signature": "@Override\n        public boolean isGetStructuralModify()"}, {"syntax_pass": true, "original_string": "        @Override\n        public MapIterator<K, V> makeEmptyIterator() {\n            resetEmpty();\n            return AbstractIterableMapTest.this.getMap().mapIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "MapIterator<K, V>", "classes": []}, "name": "makeEmptyIterator", "params": [], "body": "                                                     {\n            resetEmpty();\n            return AbstractIterableMapTest.this.getMap().mapIterator();\n        }", "signature": "@Override\n        public MapIterator<K, V> makeEmptyIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public MapIterator<K, V> makeObject() {\n            resetFull();\n            return AbstractIterableMapTest.this.getMap().mapIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "MapIterator<K, V>", "classes": []}, "name": "makeObject", "params": [], "body": "                                              {\n            resetFull();\n            return AbstractIterableMapTest.this.getMap().mapIterator();\n        }", "signature": "@Override\n        public MapIterator<K, V> makeObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "supportsRemove", "params": [], "body": "                                        {\n            return isRemoveSupported();\n        }", "signature": "@Override\n        public boolean supportsRemove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean supportsSetValue() {\n            return isSetValueSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "supportsSetValue", "params": [], "body": "                                          {\n            return isSetValueSupported();\n        }", "signature": "@Override\n        public boolean supportsSetValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void verify() {\n            super.verify();\n            AbstractIterableMapTest.this.verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "verify", "params": [], "body": "                             {\n            super.verify();\n            AbstractIterableMapTest.this.verify();\n        }", "signature": "@Override\n        public void verify()"}]}], "class_docstring": "\nAbstract test class for {@link IterableMap} methods and contracts.\n\n@param <K> the key type.\n@param <V> the value type.\n", "original_string": "public abstract class AbstractIterableMapTest<K, V> extends AbstractMapTest<K, V> {\n\n    public class InnerTestMapIterator extends AbstractMapIteratorTest<K, V> {\n        public InnerTestMapIterator() {\n            super(\"InnerTestMapIterator\");\n        }\n\n        @Override\n        public V[] addSetValues() {\n            return getNewSampleValues();\n        }\n\n        @Override\n        public Map<K, V> getConfirmedMap() {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }\n\n        @Override\n        public Map<K, V> getMap() {\n            // assumes makeFullMapIterator() called first\n            return AbstractIterableMapTest.this.getMap();\n        }\n\n        @Override\n        public boolean isGetStructuralModify() {\n            return AbstractIterableMapTest.this.isGetStructuralModify();\n        }\n\n        @Override\n        public MapIterator<K, V> makeEmptyIterator() {\n            resetEmpty();\n            return AbstractIterableMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public MapIterator<K, V> makeObject() {\n            resetFull();\n            return AbstractIterableMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }\n\n        @Override\n        public boolean supportsSetValue() {\n            return isSetValueSupported();\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            AbstractIterableMapTest.this.verify();\n        }\n    }\n\n    /**\n     * JUnit constructor.\n     *\n     * @param testName  the test name\n     */\n    public AbstractIterableMapTest(final String testName) {\n        super(testName);\n    }\n\n    public BulkTest bulkTestMapIterator() {\n        return new InnerTestMapIterator();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IterableMap<K, V> getMap() {\n        return (IterableMap<K, V>) super.getMap();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public IterableMap<K, V> makeFullMap() {\n        return (IterableMap<K, V>) super.makeFullMap();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public abstract IterableMap<K, V> makeObject();\n\n    @Test\n    public void testFailFastEntrySet() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n        if (!isFailFastExpected()) {\n            return;\n        }\n        resetFull();\n        Iterator<Map.Entry<K, V>> it = getMap().entrySet().iterator();\n        final Map.Entry<K, V> val = it.next();\n        getMap().remove(val.getKey());\n        final Iterator<Map.Entry<K, V>> finalIt0 = it;\n        assertThrows(ConcurrentModificationException.class, () -> finalIt0.next());\n\n        resetFull();\n        it = getMap().entrySet().iterator();\n        it.next();\n        getMap().clear();\n        final Iterator<Map.Entry<K, V>> finalIt1 = it;\n        assertThrows(ConcurrentModificationException.class, () -> finalIt1.next());\n    }\n\n    @Test\n    public void testFailFastKeySet() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n        if (!isFailFastExpected()) {\n            return;\n        }\n        resetFull();\n        Iterator<K> it = getMap().keySet().iterator();\n        final K val = it.next();\n        getMap().remove(val);\n        final Iterator<K> finalIt0 = it;\n        assertThrows(ConcurrentModificationException.class, () -> finalIt0.next());\n\n        resetFull();\n        it = getMap().keySet().iterator();\n        it.next();\n        getMap().clear();\n        final Iterator<K> finalIt1 = it;\n        assertThrows(ConcurrentModificationException.class, () -> finalIt1.next());\n    }\n\n//  public void testCreate() throws Exception {\n//      resetEmpty();\n//      writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/HashedMap.emptyCollection.version3.obj\");\n//      resetFull();\n//      writeExternalFormToDisk((Serializable) map, \"D:/dev/collections/data/test/HashedMap.fullCollection.version3.obj\");\n//  }\n\n    @Test\n    public void testFailFastValues() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n        if (!isFailFastExpected()) {\n            return;\n        }\n        resetFull();\n        Iterator<V> it = getMap().values().iterator();\n        it.next();\n        getMap().remove(getMap().keySet().iterator().next());\n        final Iterator<V> finalIt0 = it;\n        assertThrows(ConcurrentModificationException.class, () -> finalIt0.next());\n\n        resetFull();\n        it = getMap().values().iterator();\n        it.next();\n        getMap().clear();\n        final Iterator<V> finalIt1 = it;\n        assertThrows(ConcurrentModificationException.class, () -> finalIt1.next());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/map/AbstractSortedMapTest.java.AbstractSortedMapTest", "name": "AbstractSortedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/map/AbstractSortedMapTest.java", "superclasses": "", "methods": ["[]AbstractSortedMapTest(String)", "[BulkTest]bulkTestHeadMap()", "[BulkTest]bulkTestSubMap()", "[BulkTest]bulkTestTailMap()", "[SortedMap<K, V>]getConfirmed()", "[SortedMap<K, V>]getMap()", "[boolean]isAllowNullKey()", "[SortedMap<K, V>]makeConfirmedMap()", "[SortedMap<K, V>]makeFullMap()", "[SortedMap<K, V>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/map/AbstractSortedMapTest.java.AbstractSortedMapTest.[]AbstractSortedMapTest(String)", "src/test/java/org/apache/commons/collections4/map/AbstractSortedMapTest.java.AbstractSortedMapTest.[BulkTest]bulkTestHeadMap()", "src/test/java/org/apache/commons/collections4/map/AbstractSortedMapTest.java.AbstractSortedMapTest.[BulkTest]bulkTestSubMap()", "src/test/java/org/apache/commons/collections4/map/AbstractSortedMapTest.java.AbstractSortedMapTest.[BulkTest]bulkTestTailMap()", "src/test/java/org/apache/commons/collections4/map/AbstractSortedMapTest.java.AbstractSortedMapTest.[SortedMap<K, V>]getConfirmed()", "src/test/java/org/apache/commons/collections4/map/AbstractSortedMapTest.java.AbstractSortedMapTest.[SortedMap<K, V>]getMap()", "src/test/java/org/apache/commons/collections4/map/AbstractSortedMapTest.java.AbstractSortedMapTest.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/map/AbstractSortedMapTest.java.AbstractSortedMapTest.[SortedMap<K, V>]makeConfirmedMap()", "src/test/java/org/apache/commons/collections4/map/AbstractSortedMapTest.java.AbstractSortedMapTest.[SortedMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/map/AbstractSortedMapTest.java.AbstractSortedMapTest.[SortedMap<K, V>]makeObject()"], "overrides": null, "attributes": [{"original_string": "    public static class TestHeadMap<K, V> extends TestViewMap<K, V> {\n        static final int SUBSIZE = 6;\n        final K toKey;\n\n        public TestHeadMap(final AbstractMapTest<K, V> main) {\n            super(\"SortedMap.HeadMap\", main);\n            final Map<K, V> sm = main.makeFullMap();\n            for (final Entry<K, V> entry : sm.entrySet()) {\n                this.subSortedKeys.add(entry.getKey());\n                this.subSortedValues.add(entry.getValue());\n            }\n            this.toKey = this.subSortedKeys.get(SUBSIZE);\n            this.subSortedKeys.subList(SUBSIZE, this.subSortedKeys.size()).clear();\n            this.subSortedValues.subList(SUBSIZE, this.subSortedValues.size()).clear();\n            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n        }\n        @Override\n        public String getCompatibilityVersion() {\n            return main.getCompatibilityVersion() + \".HeadMapView\";\n        }\n        @Override\n        public SortedMap<K, V> makeFullMap() {\n            return ((SortedMap<K, V>) main.makeFullMap()).headMap(toKey);\n        }\n\n        @Override\n        public SortedMap<K, V> makeObject() {\n            // done this way so toKey is correctly set in the returned map\n            return ((SortedMap<K, V>) main.makeObject()).headMap(toKey);\n        }\n        @Test\n        public void testHeadMapOutOfRange() {\n            if (!isPutAddSupported()) {\n                return;\n            }\n            resetEmpty();\n            assertThrows(IllegalArgumentException.class, () -> getMap().put(toKey, subSortedValues.get(0)));\n            verify();\n        }\n\n//        public void testCreate() throws Exception {\n//            Map map = makeEmptyMap();\n//            writeExternalFormToDisk(\n//                (java.io.Serializable) map,\n//                \"D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.HeadMapView.obj\");\n//            map = makeFullMap();\n//            writeExternalFormToDisk(\n//                (java.io.Serializable) map,\n//                \"D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.HeadMapView.obj\");\n//        }\n    }", "definition": "    public static class TestHeadMap<K, V> extends TestViewMap<K, V>", "class_docstring": "", "name": "TestHeadMap", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "static final int SUBSIZE = 6;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "SUBSIZE = 6", "syntax_pass": true}, {"attribute_expression": "final K toKey;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "K", "name": "toKey", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestHeadMap(final AbstractMapTest<K, V> main) {\n            super(\"SortedMap.HeadMap\", main);\n            final Map<K, V> sm = main.makeFullMap();\n            for (final Entry<K, V> entry : sm.entrySet()) {\n                this.subSortedKeys.add(entry.getKey());\n                this.subSortedValues.add(entry.getValue());\n            }\n            this.toKey = this.subSortedKeys.get(SUBSIZE);\n            this.subSortedKeys.subList(SUBSIZE, this.subSortedKeys.size()).clear();\n            this.subSortedValues.subList(SUBSIZE, this.subSortedValues.size()).clear();\n            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestHeadMap", "params": [{"name": "main", "type": "AbstractMapTest<K, V>"}], "body": "                                                             {\n            super(\"SortedMap.HeadMap\", main);\n            final Map<K, V> sm = main.makeFullMap();\n            for (final Entry<K, V> entry : sm.entrySet()) {\n                this.subSortedKeys.add(entry.getKey());\n                this.subSortedValues.add(entry.getValue());\n            }\n            this.toKey = this.subSortedKeys.get(SUBSIZE);\n            this.subSortedKeys.subList(SUBSIZE, this.subSortedKeys.size()).clear();\n            this.subSortedValues.subList(SUBSIZE, this.subSortedValues.size()).clear();\n            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n        }", "signature": "public TestHeadMap(final AbstractMapTest<K, V> main)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String getCompatibilityVersion() {\n            return main.getCompatibilityVersion() + \".HeadMapView\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getCompatibilityVersion", "params": [], "body": "                                                {\n            return main.getCompatibilityVersion() + \".HeadMapView\";\n        }", "signature": "@Override\n        public String getCompatibilityVersion()"}, {"syntax_pass": true, "original_string": "        @Override\n        public SortedMap<K, V> makeFullMap() {\n            return ((SortedMap<K, V>) main.makeFullMap()).headMap(toKey);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "name": "makeFullMap", "params": [], "body": "                                             {\n            return ((SortedMap<K, V>) main.makeFullMap()).headMap(toKey);\n        }", "signature": "@Override\n        public SortedMap<K, V> makeFullMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public SortedMap<K, V> makeObject() {\n            // done this way so toKey is correctly set in the returned map\n            return ((SortedMap<K, V>) main.makeObject()).headMap(toKey);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "name": "makeObject", "params": [], "body": "                                            {\n            // done this way so toKey is correctly set in the returned map\n            return ((SortedMap<K, V>) main.makeObject()).headMap(toKey);\n        }", "signature": "@Override\n        public SortedMap<K, V> makeObject()"}, {"syntax_pass": true, "original_string": "        @Test\n        public void testHeadMapOutOfRange() {\n            if (!isPutAddSupported()) {\n                return;\n            }\n            resetEmpty();\n            assertThrows(IllegalArgumentException.class, () -> getMap().put(toKey, subSortedValues.get(0)));\n            verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Test\n        public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testHeadMapOutOfRange", "params": [], "body": "                                            {\n            if (!isPutAddSupported()) {\n                return;\n            }\n            resetEmpty();\n            assertThrows(IllegalArgumentException.class, () -> getMap().put(toKey, subSortedValues.get(0)));\n            verify();\n        }", "signature": "@Test\n        public void testHeadMapOutOfRange()"}]}, {"original_string": "    public static class TestSubMap<K, V> extends TestViewMap<K, V> {\n        static final int SUBSIZE = 3;\n        final K fromKey;\n        final K toKey;\n\n        public TestSubMap(final AbstractMapTest<K, V> main) {\n            super(\"SortedMap.SubMap\", main);\n            final Map<K, V> sm = main.makeFullMap();\n            for (final Entry<K, V> entry : sm.entrySet()) {\n                this.subSortedKeys.add(entry.getKey());\n                this.subSortedValues.add(entry.getValue());\n            }\n            this.fromKey = this.subSortedKeys.get(SUBSIZE);\n            this.toKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n\n            this.subSortedKeys.subList(0, SUBSIZE).clear();\n            this.subSortedKeys.subList(this.subSortedKeys.size() - SUBSIZE, this.subSortedKeys.size()).clear();\n\n            this.subSortedValues.subList(0, SUBSIZE).clear();\n            this.subSortedValues.subList(this.subSortedValues.size() - SUBSIZE, this.subSortedValues.size()).clear();\n\n            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(\n                SUBSIZE, this.main.getNewSampleValues().length - SUBSIZE));\n        }\n\n        @Override\n        public String getCompatibilityVersion() {\n            return main.getCompatibilityVersion() + \".SubMapView\";\n        }\n        @Override\n        public SortedMap<K, V> makeFullMap() {\n            return ((SortedMap<K, V>) main.makeFullMap()).subMap(fromKey, toKey);\n        }\n\n        @Override\n        public SortedMap<K, V> makeObject() {\n            // done this way so toKey is correctly set in the returned map\n            return ((SortedMap<K, V>) main.makeObject()).subMap(fromKey, toKey);\n        }\n        @Test\n        public void testSubMapOutOfRange() {\n            if (!isPutAddSupported()) {\n                return;\n            }\n            resetEmpty();\n            assertThrows(IllegalArgumentException.class, () -> getMap().put(toKey, subSortedValues.get(0)));\n            verify();\n        }\n\n//        public void testCreate() throws Exception {\n//            Map map = makeEmptyMap();\n//            writeExternalFormToDisk(\n//                (java.io.Serializable) map,\n//                \"D:/dev/collections/data/test/TransformedSortedMap.emptyCollection.version3.1.SubMapView.obj\");\n//            map = makeFullMap();\n//            writeExternalFormToDisk(\n//                (java.io.Serializable) map,\n//                \"D:/dev/collections/data/test/TransformedSortedMap.fullCollection.version3.1.SubMapView.obj\");\n//        }\n    }", "definition": "    public static class TestSubMap<K, V> extends TestViewMap<K, V>", "class_docstring": "", "name": "TestSubMap", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "static final int SUBSIZE = 3;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "SUBSIZE = 3", "syntax_pass": true}, {"attribute_expression": "final K fromKey;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "K", "name": "fromKey", "syntax_pass": true}, {"attribute_expression": "final K toKey;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "K", "name": "toKey", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestSubMap(final AbstractMapTest<K, V> main) {\n            super(\"SortedMap.SubMap\", main);\n            final Map<K, V> sm = main.makeFullMap();\n            for (final Entry<K, V> entry : sm.entrySet()) {\n                this.subSortedKeys.add(entry.getKey());\n                this.subSortedValues.add(entry.getValue());\n            }\n            this.fromKey = this.subSortedKeys.get(SUBSIZE);\n            this.toKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n\n            this.subSortedKeys.subList(0, SUBSIZE).clear();\n            this.subSortedKeys.subList(this.subSortedKeys.size() - SUBSIZE, this.subSortedKeys.size()).clear();\n\n            this.subSortedValues.subList(0, SUBSIZE).clear();\n            this.subSortedValues.subList(this.subSortedValues.size() - SUBSIZE, this.subSortedValues.size()).clear();\n\n            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(\n                SUBSIZE, this.main.getNewSampleValues().length - SUBSIZE));\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestSubMap", "params": [{"name": "main", "type": "AbstractMapTest<K, V>"}], "body": "                                                            {\n            super(\"SortedMap.SubMap\", main);\n            final Map<K, V> sm = main.makeFullMap();\n            for (final Entry<K, V> entry : sm.entrySet()) {\n                this.subSortedKeys.add(entry.getKey());\n                this.subSortedValues.add(entry.getValue());\n            }\n            this.fromKey = this.subSortedKeys.get(SUBSIZE);\n            this.toKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n\n            this.subSortedKeys.subList(0, SUBSIZE).clear();\n            this.subSortedKeys.subList(this.subSortedKeys.size() - SUBSIZE, this.subSortedKeys.size()).clear();\n\n            this.subSortedValues.subList(0, SUBSIZE).clear();\n            this.subSortedValues.subList(this.subSortedValues.size() - SUBSIZE, this.subSortedValues.size()).clear();\n\n            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(\n                SUBSIZE, this.main.getNewSampleValues().length - SUBSIZE));\n        }", "signature": "public TestSubMap(final AbstractMapTest<K, V> main)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String getCompatibilityVersion() {\n            return main.getCompatibilityVersion() + \".SubMapView\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getCompatibilityVersion", "params": [], "body": "                                                {\n            return main.getCompatibilityVersion() + \".SubMapView\";\n        }", "signature": "@Override\n        public String getCompatibilityVersion()"}, {"syntax_pass": true, "original_string": "        @Override\n        public SortedMap<K, V> makeFullMap() {\n            return ((SortedMap<K, V>) main.makeFullMap()).subMap(fromKey, toKey);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "name": "makeFullMap", "params": [], "body": "                                             {\n            return ((SortedMap<K, V>) main.makeFullMap()).subMap(fromKey, toKey);\n        }", "signature": "@Override\n        public SortedMap<K, V> makeFullMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public SortedMap<K, V> makeObject() {\n            // done this way so toKey is correctly set in the returned map\n            return ((SortedMap<K, V>) main.makeObject()).subMap(fromKey, toKey);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "name": "makeObject", "params": [], "body": "                                            {\n            // done this way so toKey is correctly set in the returned map\n            return ((SortedMap<K, V>) main.makeObject()).subMap(fromKey, toKey);\n        }", "signature": "@Override\n        public SortedMap<K, V> makeObject()"}, {"syntax_pass": true, "original_string": "        @Test\n        public void testSubMapOutOfRange() {\n            if (!isPutAddSupported()) {\n                return;\n            }\n            resetEmpty();\n            assertThrows(IllegalArgumentException.class, () -> getMap().put(toKey, subSortedValues.get(0)));\n            verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Test\n        public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testSubMapOutOfRange", "params": [], "body": "                                           {\n            if (!isPutAddSupported()) {\n                return;\n            }\n            resetEmpty();\n            assertThrows(IllegalArgumentException.class, () -> getMap().put(toKey, subSortedValues.get(0)));\n            verify();\n        }", "signature": "@Test\n        public void testSubMapOutOfRange()"}]}, {"original_string": "    public static class TestTailMap<K, V> extends TestViewMap<K, V> {\n        static final int SUBSIZE = 6;\n        final K fromKey;\n        final K invalidKey;\n\n        public TestTailMap(final AbstractMapTest<K, V> main) {\n            super(\"SortedMap.TailMap\", main);\n            final Map<K, V> sm = main.makeFullMap();\n            for (final Entry<K, V> entry : sm.entrySet()) {\n                this.subSortedKeys.add(entry.getKey());\n                this.subSortedValues.add(entry.getValue());\n            }\n            this.fromKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n            this.invalidKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE - 1);\n            this.subSortedKeys.subList(0, this.subSortedKeys.size() - SUBSIZE).clear();\n            this.subSortedValues.subList(0, this.subSortedValues.size() - SUBSIZE).clear();\n            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n        }\n        @Override\n        public String getCompatibilityVersion() {\n            return main.getCompatibilityVersion() + \".TailMapView\";\n        }\n        @Override\n        public SortedMap<K, V> makeFullMap() {\n            return ((SortedMap<K, V>) main.makeFullMap()).tailMap(fromKey);\n        }\n\n        @Override\n        public SortedMap<K, V> makeObject() {\n            // done this way so toKey is correctly set in the returned map\n            return ((SortedMap<K, V>) main.makeObject()).tailMap(fromKey);\n        }\n        @Test\n        public void testTailMapOutOfRange() {\n            if (!isPutAddSupported()) {\n                return;\n            }\n            resetEmpty();\n            assertThrows(IllegalArgumentException.class, () -> getMap().put(invalidKey, subSortedValues.get(0)));\n            verify();\n        }\n\n//        public void testCreate() throws Exception {\n//            Map map = makeEmptyMap();\n//            writeExternalFormToDisk(\n//                (java.io.Serializable) map,\n//                \"D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.TailMapView.obj\");\n//            map = makeFullMap();\n//            writeExternalFormToDisk(\n//                (java.io.Serializable) map,\n//                \"D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.TailMapView.obj\");\n//        }\n    }", "definition": "    public static class TestTailMap<K, V> extends TestViewMap<K, V>", "class_docstring": "", "name": "TestTailMap", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "static final int SUBSIZE = 6;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "SUBSIZE = 6", "syntax_pass": true}, {"attribute_expression": "final K fromKey;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "K", "name": "fromKey", "syntax_pass": true}, {"attribute_expression": "final K invalidKey;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "K", "name": "invalidKey", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestTailMap(final AbstractMapTest<K, V> main) {\n            super(\"SortedMap.TailMap\", main);\n            final Map<K, V> sm = main.makeFullMap();\n            for (final Entry<K, V> entry : sm.entrySet()) {\n                this.subSortedKeys.add(entry.getKey());\n                this.subSortedValues.add(entry.getValue());\n            }\n            this.fromKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n            this.invalidKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE - 1);\n            this.subSortedKeys.subList(0, this.subSortedKeys.size() - SUBSIZE).clear();\n            this.subSortedValues.subList(0, this.subSortedValues.size() - SUBSIZE).clear();\n            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestTailMap", "params": [{"name": "main", "type": "AbstractMapTest<K, V>"}], "body": "                                                             {\n            super(\"SortedMap.TailMap\", main);\n            final Map<K, V> sm = main.makeFullMap();\n            for (final Entry<K, V> entry : sm.entrySet()) {\n                this.subSortedKeys.add(entry.getKey());\n                this.subSortedValues.add(entry.getValue());\n            }\n            this.fromKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n            this.invalidKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE - 1);\n            this.subSortedKeys.subList(0, this.subSortedKeys.size() - SUBSIZE).clear();\n            this.subSortedValues.subList(0, this.subSortedValues.size() - SUBSIZE).clear();\n            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n        }", "signature": "public TestTailMap(final AbstractMapTest<K, V> main)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String getCompatibilityVersion() {\n            return main.getCompatibilityVersion() + \".TailMapView\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getCompatibilityVersion", "params": [], "body": "                                                {\n            return main.getCompatibilityVersion() + \".TailMapView\";\n        }", "signature": "@Override\n        public String getCompatibilityVersion()"}, {"syntax_pass": true, "original_string": "        @Override\n        public SortedMap<K, V> makeFullMap() {\n            return ((SortedMap<K, V>) main.makeFullMap()).tailMap(fromKey);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "name": "makeFullMap", "params": [], "body": "                                             {\n            return ((SortedMap<K, V>) main.makeFullMap()).tailMap(fromKey);\n        }", "signature": "@Override\n        public SortedMap<K, V> makeFullMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public SortedMap<K, V> makeObject() {\n            // done this way so toKey is correctly set in the returned map\n            return ((SortedMap<K, V>) main.makeObject()).tailMap(fromKey);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "name": "makeObject", "params": [], "body": "                                            {\n            // done this way so toKey is correctly set in the returned map\n            return ((SortedMap<K, V>) main.makeObject()).tailMap(fromKey);\n        }", "signature": "@Override\n        public SortedMap<K, V> makeObject()"}, {"syntax_pass": true, "original_string": "        @Test\n        public void testTailMapOutOfRange() {\n            if (!isPutAddSupported()) {\n                return;\n            }\n            resetEmpty();\n            assertThrows(IllegalArgumentException.class, () -> getMap().put(invalidKey, subSortedValues.get(0)));\n            verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Test\n        public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testTailMapOutOfRange", "params": [], "body": "                                            {\n            if (!isPutAddSupported()) {\n                return;\n            }\n            resetEmpty();\n            assertThrows(IllegalArgumentException.class, () -> getMap().put(invalidKey, subSortedValues.get(0)));\n            verify();\n        }", "signature": "@Test\n        public void testTailMapOutOfRange()"}]}, {"original_string": "    public abstract static class TestViewMap<K, V> extends AbstractSortedMapTest<K, V> {\n        protected final AbstractMapTest<K, V> main;\n        protected final List<K> subSortedKeys = new ArrayList<>();\n        protected final List<V> subSortedValues = new ArrayList<>();\n        protected final List<V> subSortedNewValues = new ArrayList<>();\n\n        public TestViewMap(final String name, final AbstractMapTest<K, V> main) {\n            super(name);\n            this.main = main;\n        }\n        @Override\n        public BulkTest bulkTestHeadMap() {\n            return null;  // block infinite recursion\n        }\n        @Override\n        public BulkTest bulkTestSubMap() {\n            return null;  // block infinite recursion\n        }\n        @Override\n        public BulkTest bulkTestTailMap() {\n            return null;  // block infinite recursion\n        }\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V[] getNewSampleValues() {\n            return (V[]) subSortedNewValues.toArray();\n        }\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public K[] getSampleKeys() {\n            return (K[]) subSortedKeys.toArray();\n        }\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V[] getSampleValues() {\n            return (V[]) subSortedValues.toArray();\n        }\n\n        @Override\n        public boolean isAllowNullKey() {\n            return main.isAllowNullKey();\n        }\n        @Override\n        public boolean isAllowNullValue() {\n            return main.isAllowNullValue();\n        }\n        @Override\n        public boolean isPutAddSupported() {\n            return main.isPutAddSupported();\n        }\n\n        @Override\n        public boolean isPutChangeSupported() {\n            return main.isPutChangeSupported();\n        }\n        @Override\n        public boolean isRemoveSupported() {\n            return main.isRemoveSupported();\n        }\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n//        public void testSimpleSerialization() throws Exception {\n//            if (main.isSubMapViewsSerializable() == false) return;\n//            super.testSimpleSerialization();\n//        }\n//        public void testSerializeDeserializeThenCompare() throws Exception {\n//            if (main.isSubMapViewsSerializable() == false) return;\n//            super.testSerializeDeserializeThenCompare();\n//        }\n//        public void testEmptyMapCompatibility() throws Exception {\n//            if (main.isSubMapViewsSerializable() == false) return;\n//            super.testEmptyMapCompatibility();\n//        }\n//        public void testFullMapCompatibility() throws Exception {\n//            if (main.isSubMapViewsSerializable() == false) return;\n//            super.testFullMapCompatibility();\n//        }\n        @Override\n        public void resetEmpty() {\n            // needed to init verify correctly\n            main.resetEmpty();\n            super.resetEmpty();\n        }\n        @Override\n        public void resetFull() {\n            // needed to init verify correctly\n            main.resetFull();\n            super.resetFull();\n        }\n        @Override\n        public void verify() {\n            // cross verify changes on view with changes on main map\n            super.verify();\n            main.verify();\n        }\n    }", "definition": "    public abstract static class TestViewMap<K, V> extends AbstractSortedMapTest<K, V>", "class_docstring": "", "name": "TestViewMap", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public abstract static", "marker_annotations": [], "non_marker_annotations": ["public", "abstract", "static"], "comments": [], "fields": [{"attribute_expression": "protected final AbstractMapTest<K, V> main;", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "AbstractMapTest<K, V>", "name": "main", "syntax_pass": true}, {"attribute_expression": "protected final List<K> subSortedKeys = new ArrayList<>();", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "List<K>", "name": "subSortedKeys = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "protected final List<V> subSortedValues = new ArrayList<>();", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "List<V>", "name": "subSortedValues = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "protected final List<V> subSortedNewValues = new ArrayList<>();", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "List<V>", "name": "subSortedNewValues = new ArrayList<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestViewMap(final String name, final AbstractMapTest<K, V> main) {\n            super(name);\n            this.main = main;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestViewMap", "params": [{"name": "name", "type": "String"}, {"name": "main", "type": "AbstractMapTest<K, V>"}], "body": "                                                                                {\n            super(name);\n            this.main = main;\n        }", "signature": "public TestViewMap(final String name, final AbstractMapTest<K, V> main)"}, {"syntax_pass": true, "original_string": "        @Override\n        public BulkTest bulkTestHeadMap() {\n            return null;  // block infinite recursion\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BulkTest", "classes": []}, "name": "bulkTestHeadMap", "params": [], "body": "                                          {\n            return null;  // block infinite recursion\n        }", "signature": "@Override\n        public BulkTest bulkTestHeadMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public BulkTest bulkTestSubMap() {\n            return null;  // block infinite recursion\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BulkTest", "classes": []}, "name": "bulkTestSubMap", "params": [], "body": "                                         {\n            return null;  // block infinite recursion\n        }", "signature": "@Override\n        public BulkTest bulkTestSubMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public BulkTest bulkTestTailMap() {\n            return null;  // block infinite recursion\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BulkTest", "classes": []}, "name": "bulkTestTailMap", "params": [], "body": "                                          {\n            return null;  // block infinite recursion\n        }", "signature": "@Override\n        public BulkTest bulkTestTailMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V[] getNewSampleValues() {\n            return (V[]) subSortedNewValues.toArray();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "V[]", "classes": []}, "name": "getNewSampleValues", "params": [], "body": "                                        {\n            return (V[]) subSortedNewValues.toArray();\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public V[] getNewSampleValues()"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public K[] getSampleKeys() {\n            return (K[]) subSortedKeys.toArray();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "K[]", "classes": []}, "name": "getSampleKeys", "params": [], "body": "                                   {\n            return (K[]) subSortedKeys.toArray();\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public K[] getSampleKeys()"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V[] getSampleValues() {\n            return (V[]) subSortedValues.toArray();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "V[]", "classes": []}, "name": "getSampleValues", "params": [], "body": "                                     {\n            return (V[]) subSortedValues.toArray();\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public V[] getSampleValues()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAllowNullKey() {\n            return main.isAllowNullKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAllowNullKey", "params": [], "body": "                                        {\n            return main.isAllowNullKey();\n        }", "signature": "@Override\n        public boolean isAllowNullKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAllowNullValue() {\n            return main.isAllowNullValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAllowNullValue", "params": [], "body": "                                          {\n            return main.isAllowNullValue();\n        }", "signature": "@Override\n        public boolean isAllowNullValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isPutAddSupported() {\n            return main.isPutAddSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isPutAddSupported", "params": [], "body": "                                           {\n            return main.isPutAddSupported();\n        }", "signature": "@Override\n        public boolean isPutAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isPutChangeSupported() {\n            return main.isPutChangeSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isPutChangeSupported", "params": [], "body": "                                              {\n            return main.isPutChangeSupported();\n        }", "signature": "@Override\n        public boolean isPutChangeSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return main.isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return main.isRemoveSupported();\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetEmpty() {\n            // needed to init verify correctly\n            main.resetEmpty();\n            super.resetEmpty();\n        }", "docstring": "        }", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetEmpty", "params": [], "body": "                                 {\n            // needed to init verify correctly\n            main.resetEmpty();\n            super.resetEmpty();\n        }", "signature": "@Override\n        public void resetEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetFull() {\n            // needed to init verify correctly\n            main.resetFull();\n            super.resetFull();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetFull", "params": [], "body": "                                {\n            // needed to init verify correctly\n            main.resetFull();\n            super.resetFull();\n        }", "signature": "@Override\n        public void resetFull()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void verify() {\n            // cross verify changes on view with changes on main map\n            super.verify();\n            main.verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "verify", "params": [], "body": "                             {\n            // cross verify changes on view with changes on main map\n            super.verify();\n            main.verify();\n        }", "signature": "@Override\n        public void verify()"}]}], "class_docstring": "\nAbstract test class for {@link java.util.SortedMap} methods and contracts.\n", "original_string": "public abstract class AbstractSortedMapTest<K, V> extends AbstractMapTest<K, V> {\n\n    public static class TestHeadMap<K, V> extends TestViewMap<K, V> {\n        static final int SUBSIZE = 6;\n        final K toKey;\n\n        public TestHeadMap(final AbstractMapTest<K, V> main) {\n            super(\"SortedMap.HeadMap\", main);\n            final Map<K, V> sm = main.makeFullMap();\n            for (final Entry<K, V> entry : sm.entrySet()) {\n                this.subSortedKeys.add(entry.getKey());\n                this.subSortedValues.add(entry.getValue());\n            }\n            this.toKey = this.subSortedKeys.get(SUBSIZE);\n            this.subSortedKeys.subList(SUBSIZE, this.subSortedKeys.size()).clear();\n            this.subSortedValues.subList(SUBSIZE, this.subSortedValues.size()).clear();\n            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n        }\n        @Override\n        public String getCompatibilityVersion() {\n            return main.getCompatibilityVersion() + \".HeadMapView\";\n        }\n        @Override\n        public SortedMap<K, V> makeFullMap() {\n            return ((SortedMap<K, V>) main.makeFullMap()).headMap(toKey);\n        }\n\n        @Override\n        public SortedMap<K, V> makeObject() {\n            // done this way so toKey is correctly set in the returned map\n            return ((SortedMap<K, V>) main.makeObject()).headMap(toKey);\n        }\n        @Test\n        public void testHeadMapOutOfRange() {\n            if (!isPutAddSupported()) {\n                return;\n            }\n            resetEmpty();\n            assertThrows(IllegalArgumentException.class, () -> getMap().put(toKey, subSortedValues.get(0)));\n            verify();\n        }\n\n//        public void testCreate() throws Exception {\n//            Map map = makeEmptyMap();\n//            writeExternalFormToDisk(\n//                (java.io.Serializable) map,\n//                \"D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.HeadMapView.obj\");\n//            map = makeFullMap();\n//            writeExternalFormToDisk(\n//                (java.io.Serializable) map,\n//                \"D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.HeadMapView.obj\");\n//        }\n    }\n\n    public static class TestSubMap<K, V> extends TestViewMap<K, V> {\n        static final int SUBSIZE = 3;\n        final K fromKey;\n        final K toKey;\n\n        public TestSubMap(final AbstractMapTest<K, V> main) {\n            super(\"SortedMap.SubMap\", main);\n            final Map<K, V> sm = main.makeFullMap();\n            for (final Entry<K, V> entry : sm.entrySet()) {\n                this.subSortedKeys.add(entry.getKey());\n                this.subSortedValues.add(entry.getValue());\n            }\n            this.fromKey = this.subSortedKeys.get(SUBSIZE);\n            this.toKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n\n            this.subSortedKeys.subList(0, SUBSIZE).clear();\n            this.subSortedKeys.subList(this.subSortedKeys.size() - SUBSIZE, this.subSortedKeys.size()).clear();\n\n            this.subSortedValues.subList(0, SUBSIZE).clear();\n            this.subSortedValues.subList(this.subSortedValues.size() - SUBSIZE, this.subSortedValues.size()).clear();\n\n            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(\n                SUBSIZE, this.main.getNewSampleValues().length - SUBSIZE));\n        }\n\n        @Override\n        public String getCompatibilityVersion() {\n            return main.getCompatibilityVersion() + \".SubMapView\";\n        }\n        @Override\n        public SortedMap<K, V> makeFullMap() {\n            return ((SortedMap<K, V>) main.makeFullMap()).subMap(fromKey, toKey);\n        }\n\n        @Override\n        public SortedMap<K, V> makeObject() {\n            // done this way so toKey is correctly set in the returned map\n            return ((SortedMap<K, V>) main.makeObject()).subMap(fromKey, toKey);\n        }\n        @Test\n        public void testSubMapOutOfRange() {\n            if (!isPutAddSupported()) {\n                return;\n            }\n            resetEmpty();\n            assertThrows(IllegalArgumentException.class, () -> getMap().put(toKey, subSortedValues.get(0)));\n            verify();\n        }\n\n//        public void testCreate() throws Exception {\n//            Map map = makeEmptyMap();\n//            writeExternalFormToDisk(\n//                (java.io.Serializable) map,\n//                \"D:/dev/collections/data/test/TransformedSortedMap.emptyCollection.version3.1.SubMapView.obj\");\n//            map = makeFullMap();\n//            writeExternalFormToDisk(\n//                (java.io.Serializable) map,\n//                \"D:/dev/collections/data/test/TransformedSortedMap.fullCollection.version3.1.SubMapView.obj\");\n//        }\n    }\n\n    public static class TestTailMap<K, V> extends TestViewMap<K, V> {\n        static final int SUBSIZE = 6;\n        final K fromKey;\n        final K invalidKey;\n\n        public TestTailMap(final AbstractMapTest<K, V> main) {\n            super(\"SortedMap.TailMap\", main);\n            final Map<K, V> sm = main.makeFullMap();\n            for (final Entry<K, V> entry : sm.entrySet()) {\n                this.subSortedKeys.add(entry.getKey());\n                this.subSortedValues.add(entry.getValue());\n            }\n            this.fromKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE);\n            this.invalidKey = this.subSortedKeys.get(this.subSortedKeys.size() - SUBSIZE - 1);\n            this.subSortedKeys.subList(0, this.subSortedKeys.size() - SUBSIZE).clear();\n            this.subSortedValues.subList(0, this.subSortedValues.size() - SUBSIZE).clear();\n            this.subSortedNewValues.addAll(Arrays.asList(main.getNewSampleValues()).subList(0, SUBSIZE));\n        }\n        @Override\n        public String getCompatibilityVersion() {\n            return main.getCompatibilityVersion() + \".TailMapView\";\n        }\n        @Override\n        public SortedMap<K, V> makeFullMap() {\n            return ((SortedMap<K, V>) main.makeFullMap()).tailMap(fromKey);\n        }\n\n        @Override\n        public SortedMap<K, V> makeObject() {\n            // done this way so toKey is correctly set in the returned map\n            return ((SortedMap<K, V>) main.makeObject()).tailMap(fromKey);\n        }\n        @Test\n        public void testTailMapOutOfRange() {\n            if (!isPutAddSupported()) {\n                return;\n            }\n            resetEmpty();\n            assertThrows(IllegalArgumentException.class, () -> getMap().put(invalidKey, subSortedValues.get(0)));\n            verify();\n        }\n\n//        public void testCreate() throws Exception {\n//            Map map = makeEmptyMap();\n//            writeExternalFormToDisk(\n//                (java.io.Serializable) map,\n//                \"D:/dev/collections/data/test/FixedSizeSortedMap.emptyCollection.version3.1.TailMapView.obj\");\n//            map = makeFullMap();\n//            writeExternalFormToDisk(\n//                (java.io.Serializable) map,\n//                \"D:/dev/collections/data/test/FixedSizeSortedMap.fullCollection.version3.1.TailMapView.obj\");\n//        }\n    }\n\n    public abstract static class TestViewMap<K, V> extends AbstractSortedMapTest<K, V> {\n        protected final AbstractMapTest<K, V> main;\n        protected final List<K> subSortedKeys = new ArrayList<>();\n        protected final List<V> subSortedValues = new ArrayList<>();\n        protected final List<V> subSortedNewValues = new ArrayList<>();\n\n        public TestViewMap(final String name, final AbstractMapTest<K, V> main) {\n            super(name);\n            this.main = main;\n        }\n        @Override\n        public BulkTest bulkTestHeadMap() {\n            return null;  // block infinite recursion\n        }\n        @Override\n        public BulkTest bulkTestSubMap() {\n            return null;  // block infinite recursion\n        }\n        @Override\n        public BulkTest bulkTestTailMap() {\n            return null;  // block infinite recursion\n        }\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V[] getNewSampleValues() {\n            return (V[]) subSortedNewValues.toArray();\n        }\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public K[] getSampleKeys() {\n            return (K[]) subSortedKeys.toArray();\n        }\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V[] getSampleValues() {\n            return (V[]) subSortedValues.toArray();\n        }\n\n        @Override\n        public boolean isAllowNullKey() {\n            return main.isAllowNullKey();\n        }\n        @Override\n        public boolean isAllowNullValue() {\n            return main.isAllowNullValue();\n        }\n        @Override\n        public boolean isPutAddSupported() {\n            return main.isPutAddSupported();\n        }\n\n        @Override\n        public boolean isPutChangeSupported() {\n            return main.isPutChangeSupported();\n        }\n        @Override\n        public boolean isRemoveSupported() {\n            return main.isRemoveSupported();\n        }\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n//        public void testSimpleSerialization() throws Exception {\n//            if (main.isSubMapViewsSerializable() == false) return;\n//            super.testSimpleSerialization();\n//        }\n//        public void testSerializeDeserializeThenCompare() throws Exception {\n//            if (main.isSubMapViewsSerializable() == false) return;\n//            super.testSerializeDeserializeThenCompare();\n//        }\n//        public void testEmptyMapCompatibility() throws Exception {\n//            if (main.isSubMapViewsSerializable() == false) return;\n//            super.testEmptyMapCompatibility();\n//        }\n//        public void testFullMapCompatibility() throws Exception {\n//            if (main.isSubMapViewsSerializable() == false) return;\n//            super.testFullMapCompatibility();\n//        }\n        @Override\n        public void resetEmpty() {\n            // needed to init verify correctly\n            main.resetEmpty();\n            super.resetEmpty();\n        }\n        @Override\n        public void resetFull() {\n            // needed to init verify correctly\n            main.resetFull();\n            super.resetFull();\n        }\n        @Override\n        public void verify() {\n            // cross verify changes on view with changes on main map\n            super.verify();\n            main.verify();\n        }\n    }\n\n    /**\n     * JUnit constructor.\n     *\n     * @param testName  the test name\n     */\n    public AbstractSortedMapTest(final String testName) {\n        super(testName);\n    }\n\n    public BulkTest bulkTestHeadMap() {\n        return new TestHeadMap<>(this);\n    }\n\n    public BulkTest bulkTestSubMap() {\n        return new TestSubMap<>(this);\n    }\n\n    public BulkTest bulkTestTailMap() {\n        return new TestTailMap<>(this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SortedMap<K, V> getConfirmed() {\n        return (SortedMap<K, V>) super.getConfirmed();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SortedMap<K, V> getMap() {\n        return (SortedMap<K, V>) super.getMap();\n    }\n\n    /**\n     * Can't sort null keys.\n     *\n     * @return false\n     */\n    @Override\n    public boolean isAllowNullKey() {\n        return false;\n    }\n\n    /**\n     * SortedMap uses TreeMap as its known comparison.\n     *\n     * @return a map that is known to be valid\n     */\n    @Override\n    public SortedMap<K, V> makeConfirmedMap() {\n        return new TreeMap<>();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SortedMap<K, V> makeFullMap() {\n        return (SortedMap<K, V>) super.makeFullMap();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public abstract SortedMap<K, V> makeObject();\n\n    @Test\n    public void testComparator() {\n//        SortedMap<K, V> sm = makeFullMap();\n        // no tests I can think of\n    }\n\n    @Test\n    public void testFirstKey() {\n        final SortedMap<K, V> sm = makeFullMap();\n        assertSame(sm.keySet().iterator().next(), sm.firstKey());\n    }\n\n    @Test\n    public void testLastKey() {\n        final SortedMap<K, V> sm = makeFullMap();\n        K obj = null;\n        for (final K k : sm.keySet()) {\n            obj = k;\n        }\n        assertSame(obj, sm.lastKey());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/functors/AbstractClosureTest.java.AbstractClosureTest", "name": "AbstractClosureTest", "file_path": "src/test/java/org/apache/commons/collections4/functors/AbstractClosureTest.java", "superclasses": "", "methods": ["[Closure<T>]generateClosure()"], "method_uris": ["src/test/java/org/apache/commons/collections4/functors/AbstractClosureTest.java.AbstractClosureTest.[Closure<T>]generateClosure()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public abstract class AbstractClosureTest {\n\n    /**\n     * @return a closure for general sanity tests.\n     */\n    protected abstract <T> Closure<T> generateClosure();\n\n    @Test\n    public void testClosureSanityTests() throws Exception {\n        final Closure<?> closure = generateClosure();\n        assertNotNull(closure);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/functors/AbstractPredicateTest.java.AbstractPredicateTest", "name": "AbstractPredicateTest", "file_path": "src/test/java/org/apache/commons/collections4/functors/AbstractPredicateTest.java", "superclasses": "", "methods": ["[void]assertPredicateFalse(Predicate<T>,T)", "[void]assertPredicateTrue(Predicate<T>,T)", "[Predicate<?>]generatePredicate()", "[void]initializeTestObjects()"], "method_uris": ["src/test/java/org/apache/commons/collections4/functors/AbstractPredicateTest.java.AbstractPredicateTest.[void]assertPredicateFalse(Predicate<T>,T)", "src/test/java/org/apache/commons/collections4/functors/AbstractPredicateTest.java.AbstractPredicateTest.[void]assertPredicateTrue(Predicate<T>,T)", "src/test/java/org/apache/commons/collections4/functors/AbstractPredicateTest.java.AbstractPredicateTest.[Predicate<?>]generatePredicate()", "src/test/java/org/apache/commons/collections4/functors/AbstractPredicateTest.java.AbstractPredicateTest.[void]initializeTestObjects()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public abstract class AbstractPredicateTest {\n\n    protected Object cObject;\n    protected String cString;\n    protected Integer cInteger;\n\n    protected <T> void assertPredicateFalse(final Predicate<T> predicate, final T testObject) {\n        assertFalse(predicate.evaluate(testObject));\n    }\n\n    protected <T> void assertPredicateTrue(final Predicate<T> predicate, final T testObject) {\n        assertTrue(predicate.evaluate(testObject));\n    }\n\n    /**\n     * @return a predicate for general sanity tests.\n     */\n    protected abstract Predicate<?> generatePredicate();\n\n    @BeforeEach\n    public void initializeTestObjects() throws Exception {\n        cObject = new Object();\n        cString = \"Hello\";\n        cInteger = Integer.valueOf(6);\n    }\n\n    @Test\n    public void testPredicateSanityTests() throws Exception {\n        final Predicate<?> predicate = generatePredicate();\n        assertNotNull(predicate);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Object cObject;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Object", "name": "cObject", "syntax_pass": true}, {"attribute_expression": "protected String cString;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "cString", "syntax_pass": true}, {"attribute_expression": "protected Integer cInteger;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Integer", "name": "cInteger", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/functors/AbstractMockPredicateTest.java.AbstractMockPredicateTest", "name": "AbstractMockPredicateTest", "file_path": "src/test/java/org/apache/commons/collections4/functors/AbstractMockPredicateTest.java", "superclasses": "", "methods": ["[]AbstractMockPredicateTest(T)", "[Predicate<T>]createMockPredicate(Boolean)", "[void]createVerifyList()", "[T]getTestValue()", "[void]verifyPredicates()"], "method_uris": ["src/test/java/org/apache/commons/collections4/functors/AbstractMockPredicateTest.java.AbstractMockPredicateTest.[]AbstractMockPredicateTest(T)", "src/test/java/org/apache/commons/collections4/functors/AbstractMockPredicateTest.java.AbstractMockPredicateTest.[Predicate<T>]createMockPredicate(Boolean)", "src/test/java/org/apache/commons/collections4/functors/AbstractMockPredicateTest.java.AbstractMockPredicateTest.[void]createVerifyList()", "src/test/java/org/apache/commons/collections4/functors/AbstractMockPredicateTest.java.AbstractMockPredicateTest.[T]getTestValue()", "src/test/java/org/apache/commons/collections4/functors/AbstractMockPredicateTest.java.AbstractMockPredicateTest.[void]verifyPredicates()"], "overrides": null, "attributes": [], "class_docstring": "\nBase class for tests of predicates which delegate to other predicates when evaluating an object.  This class\nprovides methods to create and verify mock predicates to which to delegate.\n", "original_string": "public abstract class AbstractMockPredicateTest<T> {\n    /**\n     * Mock predicates created by a single test case which need to be verified after the test completes.\n     */\n    private List<Predicate<? super T>> mockPredicatesToVerify;\n\n    /**\n     * The value to pass to mocks.\n     */\n    private final T testValue;\n\n    /**\n     * Creates a new {@code PredicateTestBase}.\n     *\n     * @param testValue the value to pass to mock predicates.\n     */\n    protected AbstractMockPredicateTest(final T testValue) {\n        this.testValue = testValue;\n    }\n\n    /**\n     * Creates a single mock predicate.\n     *\n     * @param returnValue the return value for the mock predicate, or null if the mock is not expected to be called.\n     *\n     * @return a single mock predicate.\n     */\n    @SuppressWarnings({\"boxing\"})\n    protected final Predicate<T> createMockPredicate(final Boolean returnValue) {\n        final Predicate<T> mockPredicate = EasyMock.createMock(Predicate.class);\n        if (returnValue != null) {\n            EasyMock.expect(mockPredicate.test(testValue)).andReturn(returnValue);\n        }\n        replay(mockPredicate);\n        mockPredicatesToVerify.add(mockPredicate);\n\n        return mockPredicate;\n    }\n\n    /**\n     * Creates the list of predicates to verify.\n     */\n    @BeforeEach\n    public final void createVerifyList() {\n        mockPredicatesToVerify = new ArrayList<>();\n    }\n\n    /**\n     * Gets the value which will be passed to the mock predicates.\n     *\n     * @return the test value.\n     */\n    protected final T getTestValue() {\n        return testValue;\n    }\n\n    /**\n     * Verifies all the mock predicates created for the test.\n     */\n    @AfterEach\n    public final void verifyPredicates() {\n        for (final Predicate<? super T> predicate : mockPredicatesToVerify) {\n            verify(predicate);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private List<Predicate<? super T>> mockPredicatesToVerify;", "docstring": "\nMock predicates created by a single test case which need to be verified after the test completes.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<Predicate<? super T>>", "name": "mockPredicatesToVerify", "syntax_pass": true}, {"attribute_expression": "private final T testValue;", "docstring": "\nThe value to pass to mocks.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "testValue", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/functors/AbstractAnyAllOnePredicateTest.java.AbstractAnyAllOnePredicateTest", "name": "AbstractAnyAllOnePredicateTest", "file_path": "src/test/java/org/apache/commons/collections4/functors/AbstractAnyAllOnePredicateTest.java", "superclasses": "", "methods": ["[]AbstractAnyAllOnePredicateTest(T)", "[void]singleValues()"], "method_uris": ["src/test/java/org/apache/commons/collections4/functors/AbstractAnyAllOnePredicateTest.java.AbstractAnyAllOnePredicateTest.[]AbstractAnyAllOnePredicateTest(T)", "src/test/java/org/apache/commons/collections4/functors/AbstractAnyAllOnePredicateTest.java.AbstractAnyAllOnePredicateTest.[void]singleValues()"], "overrides": null, "attributes": [], "class_docstring": "\nBase class for tests of AnyPredicate, AllPredicate, and OnePredicate.\n", "original_string": "public abstract class AbstractAnyAllOnePredicateTest<T> extends AbstractCompositePredicateTest<T> {\n\n    /**\n     * Creates a new {@code TestCompositePredicate}.\n     *\n     * @param testValue the value which the mock predicates should expect to see (may be null).\n     */\n    protected AbstractAnyAllOnePredicateTest(final T testValue) {\n        super(testValue);\n    }\n\n    /**\n     * Tests whether {@code getInstance} with a one element array returns the first element in the array.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public final void singleElementArrayToGetInstance() {\n        final Predicate<T> predicate = createMockPredicate(null);\n        final Predicate<T> allPredicate = getPredicateInstance(predicate);\n        assertSame(predicate, allPredicate, \"expected argument to be returned by getInstance()\");\n    }\n\n    /**\n     * Tests that passing a singleton collection to {@code getInstance} returns the single element in the\n     * collection.\n     */\n    @Override\n    @Test\n    public final void singletonCollectionToGetInstance() {\n        final Predicate<T> predicate = createMockPredicate(null);\n        final Predicate<T> allPredicate = getPredicateInstance(\n                Collections.<Predicate<T>>singleton(predicate));\n        assertSame(predicate, allPredicate, \"expected singleton collection member to be returned by getInstance()\");\n    }\n\n    /**\n     * Tests creating composite predicate instances with single predicates and verifies that the composite returns\n     * the same value as the single predicate does.\n     */\n    @SuppressWarnings(\"boxing\")\n    public final void singleValues() {\n        assertTrue(getPredicateInstance(true).evaluate(null));\n        assertFalse(getPredicateInstance(false).evaluate(null));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/functors/AbstractCompositePredicateTest.java.AbstractCompositePredicateTest", "name": "AbstractCompositePredicateTest", "file_path": "src/test/java/org/apache/commons/collections4/functors/AbstractCompositePredicateTest.java", "superclasses": "", "methods": ["[]AbstractCompositePredicateTest(T)", "[Predicate<T>]getPredicateInstance()", "[Predicate<T>]getPredicateInstance(Collection<Predicate<T>>)", "[Predicate<T>]getPredicateInstance()", "[void]singleElementArrayToGetInstance()", "[void]singletonCollectionToGetInstance()"], "method_uris": ["src/test/java/org/apache/commons/collections4/functors/AbstractCompositePredicateTest.java.AbstractCompositePredicateTest.[]AbstractCompositePredicateTest(T)", "src/test/java/org/apache/commons/collections4/functors/AbstractCompositePredicateTest.java.AbstractCompositePredicateTest.[Predicate<T>]getPredicateInstance()", "src/test/java/org/apache/commons/collections4/functors/AbstractCompositePredicateTest.java.AbstractCompositePredicateTest.[Predicate<T>]getPredicateInstance(Collection<Predicate<T>>)", "src/test/java/org/apache/commons/collections4/functors/AbstractCompositePredicateTest.java.AbstractCompositePredicateTest.[Predicate<T>]getPredicateInstance()", "src/test/java/org/apache/commons/collections4/functors/AbstractCompositePredicateTest.java.AbstractCompositePredicateTest.[void]singleElementArrayToGetInstance()", "src/test/java/org/apache/commons/collections4/functors/AbstractCompositePredicateTest.java.AbstractCompositePredicateTest.[void]singletonCollectionToGetInstance()"], "overrides": null, "attributes": [], "class_docstring": "\nBase class for tests of composite predicates.\n", "original_string": "public abstract class AbstractCompositePredicateTest<T> extends AbstractMockPredicateTest<T> {\n\n    /**\n     * Creates a new {@code TestCompositePredicate}.\n     *\n     * @param testValue the value which the mock predicates should expect to see (may be null).\n     */\n    protected AbstractCompositePredicateTest(final T testValue) {\n        super(testValue);\n    }\n\n    /**\n     * Creates an instance of the predicate to test.\n     *\n     * @param mockReturnValues the return values for the mock predicates, or null if that mock is not expected\n     *                         to be called\n     *\n     * @return a predicate to test.\n     */\n    protected final Predicate<T> getPredicateInstance(final Boolean... mockReturnValues) {\n        final List<Predicate<T>> predicates = new ArrayList<>();\n        for (final Boolean returnValue : mockReturnValues) {\n            predicates.add(createMockPredicate(returnValue));\n        }\n        return getPredicateInstance(predicates);\n    }\n\n    /**\n     * Creates an instance of the predicate to test.\n     *\n     * @param predicates the argument to {@code getInstance}.\n     *\n     * @return a predicate to test.\n     */\n    protected abstract Predicate<T> getPredicateInstance(Collection<Predicate<T>> predicates);\n\n    /**\n     * Creates an instance of the predicate to test.\n     *\n     * @param predicates the arguments to {@code getInstance}.\n     *\n     * @return a predicate to test.\n     */\n    protected abstract Predicate<T> getPredicateInstance(Predicate<? super T>... predicates);\n\n    /**\n     * Tests {@code getInstance} with a null predicate array.\n     */\n    @Test\n    public final void nullArrayToGetInstance() {\n        assertThrows(NullPointerException.class, () -> getPredicateInstance((Predicate<T>[]) null));\n    }\n\n    /**\n     * Tests {@code getInstance} with a null predicate collection\n     */\n    @Test\n    public final void nullCollectionToGetInstance() {\n        assertThrows(NullPointerException.class, () -> getPredicateInstance((Collection<Predicate<T>>) null));\n    }\n\n    /**\n     * Tests {@code getInstance} with a single null element in the predicate array.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    @Test\n    public final void nullElementInArrayToGetInstance() {\n        assertThrows(NullPointerException.class, () -> getPredicateInstance(new Predicate[] { null }));\n    }\n\n    /**\n     * Tests {@code getInstance} with two null elements in the predicate array.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    @Test\n    public final void nullElementsInArrayToGetInstance() {\n        assertThrows(NullPointerException.class, () -> getPredicateInstance(new Predicate[] { null, null }));\n    }\n\n    /**\n     * Tests {@code getInstance} with a predicate collection that contains null elements\n     */\n    @Test\n    public final void nullElementsInCollectionToGetInstance() {\n        final Collection<Predicate<T>> coll = new ArrayList<>();\n        coll.add(null);\n        coll.add(null);\n        assertThrows(NullPointerException.class, () -> getPredicateInstance(coll));\n    }\n\n    /**\n     * Tests whether {@code getInstance} with a one element array returns the first element in the array.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public void singleElementArrayToGetInstance() {\n        final Predicate<T> predicate = createMockPredicate(null);\n        final Predicate<T> allPredicate = getPredicateInstance(predicate);\n        assertSame(predicate, allPredicate, \"expected argument to be returned by getInstance()\");\n    }\n\n    /**\n     * Tests that passing a singleton collection to {@code getInstance} returns the single element in the\n     * collection.\n     */\n    public void singletonCollectionToGetInstance() {\n        final Predicate<T> predicate = createMockPredicate(null);\n        final Predicate<T> allPredicate = getPredicateInstance(\n                Collections.<Predicate<T>>singleton(predicate));\n        assertSame(predicate, allPredicate, \"expected argument to be returned by getInstance()\");\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/AbstractComparatorTest.java.AbstractComparatorTest", "name": "AbstractComparatorTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/AbstractComparatorTest.java", "superclasses": "AbstractObjectTest", "methods": ["[]AbstractComparatorTest(String)", "[String]getCanonicalComparatorName(Object)", "[List<T>]getComparableObjectsOrdered()", "[Comparator<T>]makeObject()", "[void]randomizeObjects(List<?>)", "[void]reverseObjects(List<?>)", "[void]sortObjects(List<T>,Comparator<? super T>)", "[boolean]supportsEmptyCollections()", "[boolean]supportsFullCollections()"], "method_uris": ["src/test/java/org/apache/commons/collections4/comparators/AbstractComparatorTest.java.AbstractComparatorTest.[]AbstractComparatorTest(String)", "src/test/java/org/apache/commons/collections4/comparators/AbstractComparatorTest.java.AbstractComparatorTest.[String]getCanonicalComparatorName(Object)", "src/test/java/org/apache/commons/collections4/comparators/AbstractComparatorTest.java.AbstractComparatorTest.[List<T>]getComparableObjectsOrdered()", "src/test/java/org/apache/commons/collections4/comparators/AbstractComparatorTest.java.AbstractComparatorTest.[Comparator<T>]makeObject()", "src/test/java/org/apache/commons/collections4/comparators/AbstractComparatorTest.java.AbstractComparatorTest.[void]randomizeObjects(List<?>)", "src/test/java/org/apache/commons/collections4/comparators/AbstractComparatorTest.java.AbstractComparatorTest.[void]reverseObjects(List<?>)", "src/test/java/org/apache/commons/collections4/comparators/AbstractComparatorTest.java.AbstractComparatorTest.[void]sortObjects(List<T>,Comparator<? super T>)", "src/test/java/org/apache/commons/collections4/comparators/AbstractComparatorTest.java.AbstractComparatorTest.[boolean]supportsEmptyCollections()", "src/test/java/org/apache/commons/collections4/comparators/AbstractComparatorTest.java.AbstractComparatorTest.[boolean]supportsFullCollections()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract test class for testing the Comparator interface.\n<p>\nConcrete subclasses declare the comparator to be tested.\nThey also declare certain aspects of the tests.\n", "original_string": "public abstract class AbstractComparatorTest<T> extends AbstractObjectTest {\n\n    /**\n     * JUnit constructor.\n     *\n     * @param testName  the test class name\n     */\n    public AbstractComparatorTest(final String testName) {\n        super(testName);\n    }\n\n    public String getCanonicalComparatorName(final Object object) {\n        final StringBuilder retval = new StringBuilder();\n        retval.append(TEST_DATA_PATH);\n        String colName = object.getClass().getName();\n        colName = colName.substring(colName.lastIndexOf(\".\") + 1);\n        retval.append(colName);\n        retval.append(\".version\");\n        retval.append(getCompatibilityVersion());\n        retval.append(\".obj\");\n        return retval.toString();\n    }\n\n    /**\n     * Implement this method to return a list of sorted objects.\n     *\n     * @return sorted objects\n     */\n    public abstract List<T> getComparableObjectsOrdered();\n\n    /**\n     * Implements the abstract superclass method to return the comparator.\n     *\n     * @return a full iterator\n     */\n    @Override\n    public abstract Comparator<T> makeObject();\n\n    /**\n     * Randomize the list.\n     */\n    protected void randomizeObjects(final List<?> list) {\n        Collections.shuffle(list);\n    }\n\n    /**\n     * Reverse the list.\n     */\n    protected void reverseObjects(final List<?> list) {\n        Collections.reverse(list);\n    }\n\n    /**\n     * Sort the list.\n     */\n    protected void sortObjects(final List<T> list, final Comparator<? super T> comparator) {\n        list.sort(comparator);\n    }\n\n    /**\n     * Overrides superclass to block tests.\n     */\n    @Override\n    public boolean supportsEmptyCollections() {\n        return false;\n    }\n\n    /**\n     * Overrides superclass to block tests.\n     */\n    @Override\n    public boolean supportsFullCollections() {\n        return false;\n    }\n\n    /**\n     * Compare the current serialized form of the Comparator\n     * against the canonical version in SCM.\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testComparatorCompatibility() throws IOException, ClassNotFoundException {\n        if (!skipSerializedCanonicalTests()) {\n            Comparator<T> comparator = null;\n\n            // test to make sure the canonical form has been preserved\n            try {\n                comparator = (Comparator<T>) readExternalFormFromDisk(getCanonicalComparatorName(makeObject()));\n            } catch (final FileNotFoundException exception) {\n\n                final boolean autoCreateSerialized = false;\n\n                if (autoCreateSerialized) {\n                    comparator = makeObject();\n                    final String fileName = getCanonicalComparatorName(comparator);\n                    writeExternalFormToDisk((Serializable) comparator, fileName);\n                    fail(\"Serialized form could not be found.  A serialized version \"\n                            + \"has now been written (and should be added to CVS): \" + fileName);\n                } else {\n                    fail(\"The Serialized form could be located to test serialization \"\n                            + \"compatibility: \" + exception.getMessage());\n                }\n            }\n\n            // make sure the canonical form produces the ordering we currently\n            // expect\n            final List<T> randomList = getComparableObjectsOrdered();\n            reverseObjects(randomList);\n            sortObjects(randomList, comparator);\n\n            final List<T> orderedList = getComparableObjectsOrdered();\n\n            assertEquals(orderedList, randomList, \"Comparator did not reorder the List correctly\");\n        }\n    }\n\n    /**\n     * Nearly all Comparators should be Serializable.\n     */\n    @Test\n    public void testComparatorIsSerializable() {\n        final Comparator<T> comparator = makeObject();\n        assertInstanceOf(Serializable.class, comparator,\n                   \"This comparator should be Serializable.\");\n    }\n\n    /**\n     * Test sorting an empty list\n     */\n    @Test\n    public void testEmptyListSort() {\n        final List<T> list = new LinkedList<>();\n        sortObjects(list, makeObject());\n\n        final List<T> list2 = new LinkedList<>();\n\n        assertEquals(list2, list, \"Comparator cannot sort empty lists\");\n    }\n\n    /**\n     * Test sorting a random list.\n     */\n    @Test\n    public void testRandomListSort() {\n        final Comparator<T> comparator = makeObject();\n\n        final List<T> randomList = getComparableObjectsOrdered();\n        randomizeObjects(randomList);\n        sortObjects(randomList, comparator);\n\n        final List<T> orderedList = getComparableObjectsOrdered();\n\n        /* debug\n        Iterator i = randomList.iterator();\n        while (i.hasNext()) {\n            System.out.println(i.next());\n        }\n        */\n\n        assertEquals(orderedList, randomList, \"Comparator did not reorder the List correctly\");\n    }\n\n    /**\n     * Test sorting a reversed list.\n     */\n    @Test\n    public void testReverseListSort() {\n        final Comparator<T> comparator = makeObject();\n\n        final List<T> randomList = getComparableObjectsOrdered();\n        reverseObjects(randomList);\n        sortObjects(randomList, comparator);\n\n        final List<T> orderedList = getComparableObjectsOrdered();\n\n        assertEquals(orderedList, randomList, \"Comparator did not reorder the List correctly\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/comparators/AbstractNullComparatorTest.java.AbstractNullComparatorTest", "name": "AbstractNullComparatorTest", "file_path": "src/test/java/org/apache/commons/collections4/comparators/AbstractNullComparatorTest.java", "superclasses": "", "methods": ["[]AbstractNullComparatorTest(String)"], "method_uris": ["src/test/java/org/apache/commons/collections4/comparators/AbstractNullComparatorTest.java.AbstractNullComparatorTest.[]AbstractNullComparatorTest(String)"], "overrides": null, "attributes": [{"original_string": "    public static class TestNullComparator1 extends AbstractNullComparatorTest {\n\n        public TestNullComparator1(final String testName) {\n            super(testName);\n        }\n\n        @Override\n        public String getCanonicalComparatorName(final Object object) {\n            return super.getCanonicalComparatorName(object) + \"1\";\n        }\n\n        @Override\n        public List<Integer> getComparableObjectsOrdered() {\n            final List<Integer> list = new LinkedList<>();\n            list.add(Integer.valueOf(1));\n            list.add(Integer.valueOf(2));\n            list.add(Integer.valueOf(3));\n            list.add(Integer.valueOf(4));\n            list.add(Integer.valueOf(5));\n            list.add(null);\n            return list;\n        }\n\n        @Override\n        public String getCompatibilityVersion() {\n            return \"4\";\n        }\n\n        @Override\n        public Comparator<Integer> makeObject() {\n            return new NullComparator<>();\n        }\n\n//        public void testCreate() throws Exception {\n//            writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/NullComparator.version4.obj1\");\n//        }\n\n    }", "definition": "    public static class TestNullComparator1 extends AbstractNullComparatorTest", "class_docstring": "\n Test the NullComparator with nulls high, using comparable comparator\n", "name": "TestNullComparator1", "super_interfaces": [], "superclasses": "AbstractNullComparatorTest", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestNullComparator1(final String testName) {\n            super(testName);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestNullComparator1", "params": [{"name": "testName", "type": "String"}], "body": "                                                          {\n            super(testName);\n        }", "signature": "public TestNullComparator1(final String testName)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String getCanonicalComparatorName(final Object object) {\n            return super.getCanonicalComparatorName(object) + \"1\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getCanonicalComparatorName", "params": [{"name": "object", "type": "Object"}], "body": "                                                                      {\n            return super.getCanonicalComparatorName(object) + \"1\";\n        }", "signature": "@Override\n        public String getCanonicalComparatorName(final Object object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<Integer> getComparableObjectsOrdered() {\n            final List<Integer> list = new LinkedList<>();\n            list.add(Integer.valueOf(1));\n            list.add(Integer.valueOf(2));\n            list.add(Integer.valueOf(3));\n            list.add(Integer.valueOf(4));\n            list.add(Integer.valueOf(5));\n            list.add(null);\n            return list;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Integer>", "classes": []}, "name": "getComparableObjectsOrdered", "params": [], "body": "                                                           {\n            final List<Integer> list = new LinkedList<>();\n            list.add(Integer.valueOf(1));\n            list.add(Integer.valueOf(2));\n            list.add(Integer.valueOf(3));\n            list.add(Integer.valueOf(4));\n            list.add(Integer.valueOf(5));\n            list.add(null);\n            return list;\n        }", "signature": "@Override\n        public List<Integer> getComparableObjectsOrdered()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String getCompatibilityVersion() {\n            return \"4\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getCompatibilityVersion", "params": [], "body": "                                                {\n            return \"4\";\n        }", "signature": "@Override\n        public String getCompatibilityVersion()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Comparator<Integer> makeObject() {\n            return new NullComparator<>();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Comparator<Integer>", "classes": []}, "name": "makeObject", "params": [], "body": "                                                {\n            return new NullComparator<>();\n        }", "signature": "@Override\n        public Comparator<Integer> makeObject()"}]}, {"original_string": "    public static class TestNullComparator2 extends AbstractNullComparatorTest {\n\n        public TestNullComparator2(final String testName) {\n            super(testName);\n        }\n\n        @Override\n        public String getCanonicalComparatorName(final Object object) {\n            return super.getCanonicalComparatorName(object) + \"2\";\n        }\n\n        @Override\n        public List<Integer> getComparableObjectsOrdered() {\n            final List<Integer> list = new LinkedList<>();\n            list.add(null);\n            list.add(Integer.valueOf(1));\n            list.add(Integer.valueOf(2));\n            list.add(Integer.valueOf(3));\n            list.add(Integer.valueOf(4));\n            list.add(Integer.valueOf(5));\n            return list;\n        }\n\n        @Override\n        public String getCompatibilityVersion() {\n            return \"4\";\n        }\n\n        @Override\n        public Comparator<Integer> makeObject() {\n            return new NullComparator<>(false);\n        }\n\n//        public void testCreate() throws Exception {\n//            writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/NullComparator.version4.obj2\");\n//        }\n\n    }", "definition": "    public static class TestNullComparator2 extends AbstractNullComparatorTest", "class_docstring": "\n Test the NullComparator with nulls low using the comparable comparator\n", "name": "TestNullComparator2", "super_interfaces": [], "superclasses": "AbstractNullComparatorTest", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestNullComparator2(final String testName) {\n            super(testName);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestNullComparator2", "params": [{"name": "testName", "type": "String"}], "body": "                                                          {\n            super(testName);\n        }", "signature": "public TestNullComparator2(final String testName)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String getCanonicalComparatorName(final Object object) {\n            return super.getCanonicalComparatorName(object) + \"2\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getCanonicalComparatorName", "params": [{"name": "object", "type": "Object"}], "body": "                                                                      {\n            return super.getCanonicalComparatorName(object) + \"2\";\n        }", "signature": "@Override\n        public String getCanonicalComparatorName(final Object object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<Integer> getComparableObjectsOrdered() {\n            final List<Integer> list = new LinkedList<>();\n            list.add(null);\n            list.add(Integer.valueOf(1));\n            list.add(Integer.valueOf(2));\n            list.add(Integer.valueOf(3));\n            list.add(Integer.valueOf(4));\n            list.add(Integer.valueOf(5));\n            return list;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<Integer>", "classes": []}, "name": "getComparableObjectsOrdered", "params": [], "body": "                                                           {\n            final List<Integer> list = new LinkedList<>();\n            list.add(null);\n            list.add(Integer.valueOf(1));\n            list.add(Integer.valueOf(2));\n            list.add(Integer.valueOf(3));\n            list.add(Integer.valueOf(4));\n            list.add(Integer.valueOf(5));\n            return list;\n        }", "signature": "@Override\n        public List<Integer> getComparableObjectsOrdered()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String getCompatibilityVersion() {\n            return \"4\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getCompatibilityVersion", "params": [], "body": "                                                {\n            return \"4\";\n        }", "signature": "@Override\n        public String getCompatibilityVersion()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Comparator<Integer> makeObject() {\n            return new NullComparator<>(false);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Comparator<Integer>", "classes": []}, "name": "makeObject", "params": [], "body": "                                                {\n            return new NullComparator<>(false);\n        }", "signature": "@Override\n        public Comparator<Integer> makeObject()"}]}], "class_docstring": "\nTest the NullComparator.\n", "original_string": "public abstract class AbstractNullComparatorTest extends AbstractComparatorTest<Integer> {\n\n    /**\n     *  Test the NullComparator with nulls high, using comparable comparator\n     **/\n    public static class TestNullComparator1 extends AbstractNullComparatorTest {\n\n        public TestNullComparator1(final String testName) {\n            super(testName);\n        }\n\n        @Override\n        public String getCanonicalComparatorName(final Object object) {\n            return super.getCanonicalComparatorName(object) + \"1\";\n        }\n\n        @Override\n        public List<Integer> getComparableObjectsOrdered() {\n            final List<Integer> list = new LinkedList<>();\n            list.add(Integer.valueOf(1));\n            list.add(Integer.valueOf(2));\n            list.add(Integer.valueOf(3));\n            list.add(Integer.valueOf(4));\n            list.add(Integer.valueOf(5));\n            list.add(null);\n            return list;\n        }\n\n        @Override\n        public String getCompatibilityVersion() {\n            return \"4\";\n        }\n\n        @Override\n        public Comparator<Integer> makeObject() {\n            return new NullComparator<>();\n        }\n\n//        public void testCreate() throws Exception {\n//            writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/NullComparator.version4.obj1\");\n//        }\n\n    }\n\n    /**\n     *  Test the NullComparator with nulls low using the comparable comparator\n     **/\n    public static class TestNullComparator2 extends AbstractNullComparatorTest {\n\n        public TestNullComparator2(final String testName) {\n            super(testName);\n        }\n\n        @Override\n        public String getCanonicalComparatorName(final Object object) {\n            return super.getCanonicalComparatorName(object) + \"2\";\n        }\n\n        @Override\n        public List<Integer> getComparableObjectsOrdered() {\n            final List<Integer> list = new LinkedList<>();\n            list.add(null);\n            list.add(Integer.valueOf(1));\n            list.add(Integer.valueOf(2));\n            list.add(Integer.valueOf(3));\n            list.add(Integer.valueOf(4));\n            list.add(Integer.valueOf(5));\n            return list;\n        }\n\n        @Override\n        public String getCompatibilityVersion() {\n            return \"4\";\n        }\n\n        @Override\n        public Comparator<Integer> makeObject() {\n            return new NullComparator<>(false);\n        }\n\n//        public void testCreate() throws Exception {\n//            writeExternalFormToDisk((java.io.Serializable) makeObject(), \"src/test/resources/data/test/NullComparator.version4.obj2\");\n//        }\n\n    }\n\n    public AbstractNullComparatorTest(final String testName) {\n        super(testName);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/AbstractListIteratorTest.java.AbstractListIteratorTest", "name": "AbstractListIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/AbstractListIteratorTest.java", "superclasses": "", "methods": ["[]AbstractListIteratorTest(String)", "[E]addSetValue()", "[ListIterator<E>]makeEmptyIterator()", "[ListIterator<E>]makeObject()", "[boolean]supportsAdd()", "[boolean]supportsSet()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/AbstractListIteratorTest.java.AbstractListIteratorTest.[]AbstractListIteratorTest(String)", "src/test/java/org/apache/commons/collections4/iterators/AbstractListIteratorTest.java.AbstractListIteratorTest.[E]addSetValue()", "src/test/java/org/apache/commons/collections4/iterators/AbstractListIteratorTest.java.AbstractListIteratorTest.[ListIterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/AbstractListIteratorTest.java.AbstractListIteratorTest.[ListIterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/AbstractListIteratorTest.java.AbstractListIteratorTest.[boolean]supportsAdd()", "src/test/java/org/apache/commons/collections4/iterators/AbstractListIteratorTest.java.AbstractListIteratorTest.[boolean]supportsSet()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract class for testing the ListIterator interface.\n<p>\nThis class provides a framework for testing an implementation of ListIterator.\nConcrete subclasses must provide the list iterator to be tested.\nThey must also specify certain details of how the list iterator operates by\noverriding the supportsXxx() methods if necessary.\n</p>\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public abstract class AbstractListIteratorTest<E> extends AbstractIteratorTest<E> {\n\n    /**\n     * JUnit constructor.\n     *\n     * @param testName  the test class name\n     */\n    public AbstractListIteratorTest(final String testName) {\n        super(testName);\n    }\n\n    /**\n     * The value to be used in the add and set tests.\n     * Default is null.\n     */\n    public E addSetValue() {\n        return null;\n    }\n\n    /**\n     * Implements the abstract superclass method to return the list iterator.\n     *\n     * @return an empty iterator\n     */\n    @Override\n    public abstract ListIterator<E> makeEmptyIterator();\n\n    /**\n     * Implements the abstract superclass method to return the list iterator.\n     *\n     * @return a full iterator\n     */\n    @Override\n    public abstract ListIterator<E> makeObject();\n\n    /**\n     * Whether or not we are testing an iterator that supports add().\n     * Default is true.\n     *\n     * @return true if Iterator supports add\n     */\n    public boolean supportsAdd() {\n        return true;\n    }\n\n    /**\n     * Whether or not we are testing an iterator that supports set().\n     * Default is true.\n     *\n     * @return true if Iterator supports set\n     */\n    public boolean supportsSet() {\n        return true;\n    }\n\n    /**\n     * Test add behavior.\n     */\n    @Test\n    public void testAdd() {\n        ListIterator<E> it = makeObject();\n\n        final E addValue = addSetValue();\n        if (!supportsAdd()) {\n            // check for UnsupportedOperationException if not supported\n            final ListIterator<E> finalIt0 = it;\n            assertThrows(UnsupportedOperationException.class, () -> finalIt0.add(addValue),\n                    \"UnsupportedOperationException must be thrown from add of \" + it.getClass().getSimpleName());\n            return;\n        }\n\n        // add at start should be OK, added should be previous\n        it = makeObject();\n        it.add(addValue);\n        assertEquals(addValue, it.previous());\n\n        // add at start should be OK, added should not be next\n        it = makeObject();\n        it.add(addValue);\n        assertNotSame(addValue, it.next());\n\n        // add in middle and at end should be OK\n        it = makeObject();\n        while (it.hasNext()) {\n            it.next();\n            it.add(addValue);\n            // check add OK\n            assertEquals(addValue, it.previous());\n            it.next();\n        }\n    }\n\n    /**\n     * Test remove after add behavior.\n     */\n    @Test\n    public void testAddThenRemove() {\n        final ListIterator<E> it = makeObject();\n\n        // add then remove\n        if (supportsAdd() && supportsRemove()) {\n            it.next();\n            it.add(addSetValue());\n            assertThrows(IllegalStateException.class, () -> it.remove(),\n                    \"IllegalStateException must be thrown from remove after add\");\n        }\n    }\n\n    @Test\n    public void testAddThenSet() {\n        final ListIterator<E> it = makeObject();\n        // add then set\n        if (supportsAdd() && supportsSet()) {\n            it.next();\n            it.add(addSetValue());\n            assertThrows(IllegalStateException.class, () -> it.set(addSetValue()),\n                    \"IllegalStateException must be thrown from set after add\");\n        }\n    }\n\n    /**\n     * Test that the empty list iterator contract is correct.\n     */\n    @Test\n    public void testEmptyListIteratorIsIndeedEmpty() {\n        if (!supportsEmptyIterator()) {\n            return;\n        }\n\n        final ListIterator<E> it = makeEmptyIterator();\n\n        assertFalse(it.hasNext());\n        assertEquals(0, it.nextIndex());\n        assertFalse(it.hasPrevious());\n        assertEquals(-1, it.previousIndex());\n\n        // next() should throw a NoSuchElementException\n        assertThrows(NoSuchElementException.class, () -> it.next(),\n                \"NoSuchElementException must be thrown from empty ListIterator\");\n\n        // previous() should throw a NoSuchElementException\n        assertThrows(NoSuchElementException.class, () -> it.previous(),\n                \"NoSuchElementException must be thrown from empty ListIterator\");\n    }\n\n    @Test\n    public void testRemoveThenSet() {\n        final ListIterator<E> it = makeObject();\n        if (supportsRemove() && supportsSet()) {\n            it.next();\n            it.remove();\n            assertThrows(IllegalStateException.class, () -> it.set(addSetValue()),\n                    \"IllegalStateException must be thrown from set after remove\");\n        }\n    }\n\n    /**\n     * Test set behavior.\n     */\n    @Test\n    public void testSet() {\n        final ListIterator<E> it = makeObject();\n\n        if (!supportsSet()) {\n            // check for UnsupportedOperationException if not supported\n            assertThrows(UnsupportedOperationException.class, () -> it.set(addSetValue()),\n                    \"UnsupportedOperationException must be thrown from set in \" + it.getClass().getSimpleName());\n            return;\n        }\n\n        // should throw IllegalStateException before next() called\n        assertThrows(IllegalStateException.class, () -> it.set(addSetValue()));\n\n        // set after next should be fine\n        it.next();\n        it.set(addSetValue());\n\n        // repeated set calls should be fine\n        it.set(addSetValue());\n\n    }\n\n    /**\n     * Test navigation through the iterator.\n     */\n    @Test\n    public void testWalkForwardAndBack() {\n        final ArrayList<E> list = new ArrayList<>();\n        final ListIterator<E> it = makeObject();\n        while (it.hasNext()) {\n            list.add(it.next());\n        }\n\n        // check state at end\n        assertFalse(it.hasNext());\n        assertTrue(it.hasPrevious());\n        assertThrows(NoSuchElementException.class, () -> it.next(),\n                \"NoSuchElementException must be thrown from next at end of ListIterator\");\n\n        // loop back through comparing\n        for (int i = list.size() - 1; i >= 0; i--) {\n            assertEquals(i + 1, it.nextIndex());\n            assertEquals(i, it.previousIndex());\n\n            final Object obj = list.get(i);\n            assertEquals(obj, it.previous());\n        }\n\n        // check state at start\n        assertTrue(it.hasNext());\n        assertFalse(it.hasPrevious());\n        assertThrows(NoSuchElementException.class, () -> it.previous(),\n                \"NoSuchElementException must be thrown from previous at start of ListIterator\");\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/AbstractMapIteratorTest.java.AbstractMapIteratorTest", "name": "AbstractMapIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/AbstractMapIteratorTest.java", "superclasses": "", "methods": ["[]AbstractMapIteratorTest(String)", "[V[]]addSetValues()", "[Map<K, V>]getConfirmedMap()", "[Map<K, V>]getMap()", "[boolean]isGetStructuralModify()", "[MapIterator<K, V>]makeEmptyIterator()", "[MapIterator<K, V>]makeObject()", "[boolean]supportsSetValue()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/AbstractMapIteratorTest.java.AbstractMapIteratorTest.[]AbstractMapIteratorTest(String)", "src/test/java/org/apache/commons/collections4/iterators/AbstractMapIteratorTest.java.AbstractMapIteratorTest.[V[]]addSetValues()", "src/test/java/org/apache/commons/collections4/iterators/AbstractMapIteratorTest.java.AbstractMapIteratorTest.[Map<K, V>]getConfirmedMap()", "src/test/java/org/apache/commons/collections4/iterators/AbstractMapIteratorTest.java.AbstractMapIteratorTest.[Map<K, V>]getMap()", "src/test/java/org/apache/commons/collections4/iterators/AbstractMapIteratorTest.java.AbstractMapIteratorTest.[boolean]isGetStructuralModify()", "src/test/java/org/apache/commons/collections4/iterators/AbstractMapIteratorTest.java.AbstractMapIteratorTest.[MapIterator<K, V>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/AbstractMapIteratorTest.java.AbstractMapIteratorTest.[MapIterator<K, V>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/AbstractMapIteratorTest.java.AbstractMapIteratorTest.[boolean]supportsSetValue()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract class for testing the MapIterator interface.\n<p>\nThis class provides a framework for testing an implementation of MapIterator.\nConcrete subclasses must provide the list iterator to be tested.\nThey must also specify certain details of how the list iterator operates by\noverriding the supportsXxx() methods if necessary.\n</p>\n\n@param <K> the type of the keys in the maps tested.\n@param <V> the type of the values in the maps tested.\n", "original_string": "public abstract class AbstractMapIteratorTest<K, V> extends AbstractIteratorTest<K> {\n\n    /**\n     * JUnit constructor.\n     *\n     * @param testName  the test class name\n     */\n    public AbstractMapIteratorTest(final String testName) {\n        super(testName);\n    }\n\n    /**\n     * The values to be used in the add and set tests.\n     * Default is two strings.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public V[] addSetValues() {\n        return (V[]) new Object[] { \"A\", \"B\" };\n    }\n\n    /**\n     * Implement this method to return the confirmed map which contains the same\n     * data as the iterator.\n     *\n     * @return a full map which can be updated\n     */\n    public abstract Map<K, V> getConfirmedMap();\n\n    /**\n     * Implement this method to return the map which contains the same data as the\n     * iterator.\n     *\n     * @return a full map which can be updated\n     */\n    public abstract Map<K, V> getMap();\n\n    /**\n     * Whether the get operation on the map structurally modifies the map,\n     * such as with LRUMap. Default is false.\n     *\n     * @return true if the get method structurally modifies the map\n     */\n    public boolean isGetStructuralModify() {\n        return false;\n    }\n\n    /**\n     * Implement this method to return a map iterator over an empty map.\n     *\n     * @return an empty iterator\n     */\n    @Override\n    public abstract MapIterator<K, V> makeEmptyIterator();\n\n    /**\n     * Implement this method to return a map iterator over a map with elements.\n     *\n     * @return a full iterator\n     */\n    @Override\n    public abstract MapIterator<K, V> makeObject();\n\n    /**\n     * Whether or not we are testing an iterator that supports setValue().\n     * Default is true.\n     *\n     * @return true if Iterator supports set\n     */\n    public boolean supportsSetValue() {\n        return true;\n    }\n\n    /**\n     * Test that the empty list iterator contract is correct.\n     */\n    @Test\n    public void testEmptyMapIterator() {\n        if (!supportsEmptyIterator()) {\n            return;\n        }\n\n        final MapIterator<K, V> it = makeEmptyIterator();\n        assertFalse(it.hasNext());\n\n        // next() should throw a NoSuchElementException\n        assertThrows(NoSuchElementException.class, () -> it.next());\n\n        // getKey() should throw an IllegalStateException\n        assertThrows(IllegalStateException.class, () -> it.getKey());\n\n        // getValue() should throw an IllegalStateException\n        assertThrows(IllegalStateException.class, () -> it.getValue());\n\n        if (!supportsSetValue()) {\n            // setValue() should throw an UnsupportedOperationException/IllegalStateException\n            try {\n                it.setValue(addSetValues()[0]);\n                fail();\n            } catch (final UnsupportedOperationException | IllegalStateException ex) {\n                // ignore\n            }\n        } else {\n            // setValue() should throw an IllegalStateException\n            assertThrows(IllegalStateException.class, () -> it.setValue(addSetValues()[0]));\n        }\n    }\n\n    /**\n     * Test that the full list iterator contract is correct.\n     */\n    @Test\n    public void testFullMapIterator() {\n        if (!supportsFullIterator()) {\n            return;\n        }\n\n        final MapIterator<K, V> it = makeObject();\n        final Map<K, V> map = getMap();\n        assertTrue(it.hasNext());\n\n        assertTrue(it.hasNext());\n        final Set<K> set = new HashSet<>();\n        while (it.hasNext()) {\n            // getKey\n            final K key = it.next();\n            assertSame(key, it.getKey(), \"it.next() should equals getKey()\");\n            assertTrue(map.containsKey(key),  \"Key must be in map\");\n            assertTrue(set.add(key), \"Key must be unique\");\n\n            // getValue\n            final V value = it.getValue();\n            if (!isGetStructuralModify()) {\n                assertSame(map.get(key), value, \"Value must be mapped to key\");\n            }\n            assertTrue(map.containsValue(value),  \"Value must be in map\");\n\n            verify();\n        }\n    }\n\n    @Test\n    public void testMapIteratorRemoveGetKey() {\n        if (!supportsRemove()) {\n            return;\n        }\n        final MapIterator<K, V> it = makeObject();\n        final Map<K, V> confirmed = getConfirmedMap();\n\n        assertTrue(it.hasNext());\n        final K key = it.next();\n\n        it.remove();\n        confirmed.remove(key);\n        verify();\n\n        assertThrows(IllegalStateException.class, () -> it.getKey());\n        verify();\n    }\n\n    @Test\n    public void testMapIteratorRemoveGetValue() {\n        if (!supportsRemove()) {\n            return;\n        }\n        final MapIterator<K, V> it = makeObject();\n        final Map<K, V> confirmed = getConfirmedMap();\n\n        assertTrue(it.hasNext());\n        final K key = it.next();\n\n        it.remove();\n        confirmed.remove(key);\n        verify();\n\n        assertThrows(IllegalStateException.class, () -> it.getValue());\n        verify();\n    }\n\n    @Test\n    public void testMapIteratorSet() {\n        if (!supportsFullIterator()) {\n            return;\n        }\n\n        final V newValue = addSetValues()[0];\n        final V newValue2 = addSetValues().length == 1 ? addSetValues()[0] : addSetValues()[1];\n        final MapIterator<K, V> it = makeObject();\n        final Map<K, V> map = getMap();\n        final Map<K, V> confirmed = getConfirmedMap();\n        assertTrue(it.hasNext());\n        final K key = it.next();\n        final V value = it.getValue();\n\n        if (!supportsSetValue()) {\n            assertThrows(UnsupportedOperationException.class, () -> it.setValue(newValue));\n            return;\n        }\n        final V old = it.setValue(newValue);\n        confirmed.put(key, newValue);\n        assertSame(key, it.getKey(), \"Key must not change after setValue\");\n        assertSame(newValue, it.getValue(), \"Value must be changed after setValue\");\n        assertSame(value, old, \"setValue must return old value\");\n        assertTrue(map.containsKey(key), \"Map must contain key\");\n        // test against confirmed, as map may contain value twice\n        assertEquals(confirmed.containsValue(old), map.containsValue(old),\n            \"Map must not contain old value\");\n        assertTrue(map.containsValue(newValue), \"Map must contain new value\");\n        verify();\n\n        it.setValue(newValue);  // same value - should be OK\n        confirmed.put(key, newValue);\n        assertSame(key, it.getKey(), \"Key must not change after setValue\");\n        assertSame(newValue, it.getValue(), \"Value must be changed after setValue\");\n        verify();\n\n        it.setValue(newValue2);  // new value\n        confirmed.put(key, newValue2);\n        assertSame(key, it.getKey(), \"Key must not change after setValue\");\n        assertSame(newValue2, it.getValue(), \"Value must be changed after setValue\");\n        verify();\n    }\n\n    @Test\n    public void testMapIteratorSetRemoveSet() {\n        if (!supportsSetValue() || !supportsRemove()) {\n            return;\n        }\n        final V newValue = addSetValues()[0];\n        final MapIterator<K, V> it = makeObject();\n        final Map<K, V> confirmed = getConfirmedMap();\n\n        assertTrue(it.hasNext());\n        final K key = it.next();\n\n        it.setValue(newValue);\n        it.remove();\n        confirmed.remove(key);\n        verify();\n\n        assertThrows(IllegalStateException.class, () -> it.setValue(newValue));\n        verify();\n    }\n\n    @Test\n    @Override\n    public void testRemove() { // override\n        final MapIterator<K, V> it = makeObject();\n        final Map<K, V> map = getMap();\n        final Map<K, V> confirmed = getConfirmedMap();\n        assertTrue(it.hasNext());\n        final K key = it.next();\n\n        if (!supportsRemove()) {\n            assertThrows(UnsupportedOperationException.class, () -> it.remove());\n            return;\n        }\n\n        it.remove();\n        confirmed.remove(key);\n        assertFalse(map.containsKey(key));\n        verify();\n\n        try {\n            it.remove();  // second remove fails\n        } catch (final IllegalStateException ex) {\n        }\n        verify();\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/AbstractIteratorTest.java.AbstractIteratorTest", "name": "AbstractIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/AbstractIteratorTest.java", "superclasses": "AbstractObjectTest", "methods": ["[]AbstractIteratorTest(String)", "[Iterator<E>]makeEmptyIterator()", "[Iterator<E>]makeObject()", "[boolean]supportsEmptyIterator()", "[boolean]supportsFullIterator()", "[boolean]supportsRemove()", "[void]verify()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/AbstractIteratorTest.java.AbstractIteratorTest.[]AbstractIteratorTest(String)", "src/test/java/org/apache/commons/collections4/iterators/AbstractIteratorTest.java.AbstractIteratorTest.[Iterator<E>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/AbstractIteratorTest.java.AbstractIteratorTest.[Iterator<E>]makeObject()", "src/test/java/org/apache/commons/collections4/iterators/AbstractIteratorTest.java.AbstractIteratorTest.[boolean]supportsEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/AbstractIteratorTest.java.AbstractIteratorTest.[boolean]supportsFullIterator()", "src/test/java/org/apache/commons/collections4/iterators/AbstractIteratorTest.java.AbstractIteratorTest.[boolean]supportsRemove()", "src/test/java/org/apache/commons/collections4/iterators/AbstractIteratorTest.java.AbstractIteratorTest.[void]verify()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract class for testing the Iterator interface.\n<p>\nThis class provides a framework for testing an implementation of Iterator.\nConcrete subclasses must provide the iterator to be tested.\nThey must also specify certain details of how the iterator operates by\noverriding the supportsXxx() methods if necessary.\n</p>\n\n@param <E> the type of elements tested by this iterator.\n", "original_string": "public abstract class AbstractIteratorTest<E> extends AbstractObjectTest {\n\n    /**\n     * JUnit constructor.\n     *\n     * @param testName  the test class name\n     */\n    public AbstractIteratorTest(final String testName) {\n        super(testName);\n    }\n\n    /**\n     * Implement this method to return an iterator over an empty collection.\n     *\n     * @return an empty iterator\n     */\n    public abstract Iterator<E> makeEmptyIterator();\n\n    /**\n     * Implements the abstract superclass method to return the full iterator.\n     *\n     * @return a full iterator\n     */\n    @Override\n    public abstract Iterator<E> makeObject();\n\n    /**\n     * Whether or not we are testing an iterator that can be empty.\n     * Default is true.\n     *\n     * @return true if Iterator can be empty\n     */\n    public boolean supportsEmptyIterator() {\n        return true;\n    }\n\n    /**\n     * Whether or not we are testing an iterator that can contain elements.\n     * Default is true.\n     *\n     * @return true if Iterator can be full\n     */\n    public boolean supportsFullIterator() {\n        return true;\n    }\n\n    /**\n     * Whether or not we are testing an iterator that supports remove().\n     * Default is true.\n     *\n     * @return true if Iterator supports remove\n     */\n    public boolean supportsRemove() {\n        return true;\n    }\n\n    /**\n     * Test the empty iterator.\n     */\n    @Test\n    public void testEmptyIterator() {\n        if (!supportsEmptyIterator()) {\n            return;\n        }\n\n        final Iterator<E> it = makeEmptyIterator();\n\n        // hasNext() should return false\n        assertFalse(it.hasNext(), \"hasNext() should return false for empty iterators\");\n\n        // next() should throw a NoSuchElementException\n        assertThrows(NoSuchElementException.class, () -> it.next(),\n                \"NoSuchElementException must be thrown when Iterator is exhausted\");\n        verify();\n\n        assertNotNull(it.toString());\n    }\n\n    /**\n     * Test normal iteration behavior.\n     */\n    @Test\n    public void testFullIterator() {\n        if (!supportsFullIterator()) {\n            return;\n        }\n\n        final Iterator<E> it = makeObject();\n\n        // hasNext() must be true (ensure makeFullIterator is correct!)\n        assertTrue(it.hasNext(), \"hasNext() should return true for at least one element\");\n\n        // next() must not throw exception (ensure makeFullIterator is correct!)\n        try {\n            it.next();\n        } catch (final NoSuchElementException e) {\n            fail(\"Full iterators must have at least one element\");\n        }\n\n        // iterate through\n        while (it.hasNext()) {\n            it.next();\n            verify();\n        }\n\n        // next() must throw NoSuchElementException now\n        assertThrows(NoSuchElementException.class, () -> it.next(),\n                \"NoSuchElementException must be thrown when Iterator is exhausted\");\n\n        assertNotNull(it.toString());\n    }\n\n    /**\n     * Test remove behavior.\n     */\n    @Test\n    public void testRemove() {\n        final Iterator<E> it = makeObject();\n\n        if (!supportsRemove()) {\n            // check for UnsupportedOperationException if not supported\n            assertThrows(UnsupportedOperationException.class, it::remove);\n            return;\n        }\n\n        // should throw IllegalStateException before next() called\n        assertThrows(IllegalStateException.class, () -> it.remove());\n        verify();\n\n        // remove after next should be fine\n        it.next();\n        it.remove();\n\n        // should throw IllegalStateException for second remove()\n        assertThrows(IllegalStateException.class, () -> it.remove());\n    }\n\n    /**\n     * Allows subclasses to add complex cross verification\n     */\n    public void verify() {\n        // do nothing\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorTest.java.AbstractOrderedMapIteratorTest", "name": "AbstractOrderedMapIteratorTest", "file_path": "src/test/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorTest.java", "superclasses": "", "methods": ["[]AbstractOrderedMapIteratorTest(String)", "[OrderedMapIterator<K, V>]makeEmptyIterator()", "[OrderedMapIterator<K, V>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorTest.java.AbstractOrderedMapIteratorTest.[]AbstractOrderedMapIteratorTest(String)", "src/test/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorTest.java.AbstractOrderedMapIteratorTest.[OrderedMapIterator<K, V>]makeEmptyIterator()", "src/test/java/org/apache/commons/collections4/iterators/AbstractOrderedMapIteratorTest.java.AbstractOrderedMapIteratorTest.[OrderedMapIterator<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract class for testing the OrderedMapIterator interface.\n<p>\nThis class provides a framework for testing an implementation of MapIterator.\nConcrete subclasses must provide the list iterator to be tested.\nThey must also specify certain details of how the list iterator operates by\noverriding the supportsXxx() methods if necessary.\n\n@param <K> the type of the keys in the maps tested.\n@param <V> the type of the values in the maps tested.\n", "original_string": "public abstract class AbstractOrderedMapIteratorTest<K, V> extends AbstractMapIteratorTest<K, V> {\n\n    /**\n     * JUnit constructor.\n     *\n     * @param testName  the test class name\n     */\n    public AbstractOrderedMapIteratorTest(final String testName) {\n        super(testName);\n    }\n\n    @Override\n    public abstract OrderedMapIterator<K, V> makeEmptyIterator();\n\n    @Override\n    public abstract OrderedMapIterator<K, V> makeObject();\n\n    /**\n     * Test that the empty list iterator contract is correct.\n     */\n    @Test\n    @Override\n    public void testEmptyMapIterator() {\n        if (!supportsEmptyIterator()) {\n            return;\n        }\n\n        super.testEmptyMapIterator();\n\n        final OrderedMapIterator<K, V> it = makeEmptyIterator();\n        assertFalse(it.hasPrevious());\n\n        assertThrows(NoSuchElementException.class, () -> it.previous());\n    }\n\n    /**\n     * Test that the full list iterator contract is correct.\n     */\n    @Test\n    @Override\n    public void testFullMapIterator() {\n        if (!supportsFullIterator()) {\n            return;\n        }\n\n        super.testFullMapIterator();\n\n        final OrderedMapIterator<K, V> it = makeObject();\n        final Map<K, V> map = getMap();\n\n        assertTrue(it.hasNext());\n        assertFalse(it.hasPrevious());\n        final Set<K> set = new HashSet<>();\n        while (it.hasNext()) {\n            // getKey\n            final K key = it.next();\n            assertSame(key, it.getKey(), \"it.next() should equals getKey()\");\n            assertTrue(map.containsKey(key),  \"Key must be in map\");\n            assertTrue(set.add(key), \"Key must be unique\");\n\n            // getValue\n            final V value = it.getValue();\n            if (!isGetStructuralModify()) {\n                assertSame(map.get(key), value, \"Value must be mapped to key\");\n            }\n            assertTrue(map.containsValue(value),  \"Value must be in map\");\n\n            assertTrue(it.hasPrevious());\n\n            verify();\n        }\n        while (it.hasPrevious()) {\n            // getKey\n            final Object key = it.previous();\n            assertSame(key, it.getKey(), \"it.previous() should equals getKey()\");\n            assertTrue(map.containsKey(key),  \"Key must be in map\");\n            assertTrue(set.remove(key), \"Key must be unique\");\n\n            // getValue\n            final Object value = it.getValue();\n            if (!isGetStructuralModify()) {\n                assertSame(map.get(key), value, \"Value must be mapped to key\");\n            }\n            assertTrue(map.containsValue(value),  \"Value must be in map\");\n\n            assertTrue(it.hasNext());\n\n            verify();\n        }\n    }\n\n    /**\n     * Test that the iterator order matches the keySet order.\n     */\n    @Test\n    public void testMapIteratorOrder() {\n        if (!supportsFullIterator()) {\n            return;\n        }\n\n        final OrderedMapIterator<K, V> it = makeObject();\n        final Map<K, V> map = getMap();\n\n        assertEquals(new ArrayList<>(map.keySet()), new ArrayList<>(map.keySet()), \"keySet() not consistent\");\n\n        final Iterator<K> it2 = map.keySet().iterator();\n        assertTrue(it.hasNext());\n        assertTrue(it2.hasNext());\n        final List<K> list = new ArrayList<>();\n        while (it.hasNext()) {\n            final K key = it.next();\n            assertEquals(it2.next(), key);\n            list.add(key);\n        }\n        assertEquals(map.size(), list.size());\n        while (it.hasPrevious()) {\n            final K key = it.previous();\n            assertEquals(list.get(list.size() - 1), key);\n            list.remove(list.size() - 1);\n        }\n        assertEquals(0, list.size());\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/properties/AbstractPropertiesFactoryTest.java.AbstractPropertiesFactoryTest", "name": "AbstractPropertiesFactoryTest", "file_path": "src/test/java/org/apache/commons/collections4/properties/AbstractPropertiesFactoryTest.java", "superclasses": "", "methods": ["[Stream<Arguments>]getParameters()", "[]AbstractPropertiesFactoryTest(AbstractPropertiesFactory<T>)", "[void]assertContents(T)", "[String]getPathString(String)", "[boolean]isXmlTest(String)"], "method_uris": ["src/test/java/org/apache/commons/collections4/properties/AbstractPropertiesFactoryTest.java.AbstractPropertiesFactoryTest.[Stream<Arguments>]getParameters()", "src/test/java/org/apache/commons/collections4/properties/AbstractPropertiesFactoryTest.java.AbstractPropertiesFactoryTest.[]AbstractPropertiesFactoryTest(AbstractPropertiesFactory<T>)", "src/test/java/org/apache/commons/collections4/properties/AbstractPropertiesFactoryTest.java.AbstractPropertiesFactoryTest.[void]assertContents(T)", "src/test/java/org/apache/commons/collections4/properties/AbstractPropertiesFactoryTest.java.AbstractPropertiesFactoryTest.[String]getPathString(String)", "src/test/java/org/apache/commons/collections4/properties/AbstractPropertiesFactoryTest.java.AbstractPropertiesFactoryTest.[boolean]isXmlTest(String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public abstract class AbstractPropertiesFactoryTest<T extends Properties> {\n\n    public static Stream<Arguments> getParameters() {\n        return Stream.of(\n                arguments(\".properties\"),\n                arguments(\".xml\")\n        );\n    }\n\n    private final AbstractPropertiesFactory<T> factory;\n\n    protected AbstractPropertiesFactoryTest(final AbstractPropertiesFactory<T> factory) {\n        this.factory = factory;\n    }\n\n    private void assertContents(final T properties) {\n        assertEquals(\"value1\", properties.getProperty(\"key1\"));\n        assertEquals(\"value2\", properties.getProperty(\"key2\"));\n        assertEquals(\"value3\", properties.getProperty(\"key3\"));\n        assertEquals(\"value4\", properties.getProperty(\"key4\"));\n        assertEquals(\"value5\", properties.getProperty(\"key5\"));\n        assertEquals(\"value6\", properties.getProperty(\"key6\"));\n        assertEquals(\"value7\", properties.getProperty(\"key7\"));\n        assertEquals(\"value8\", properties.getProperty(\"key8\"));\n        assertEquals(\"value9\", properties.getProperty(\"key9\"));\n        assertEquals(\"value10\", properties.getProperty(\"key10\"));\n        assertEquals(\"value11\", properties.getProperty(\"key11\"));\n    }\n\n    private String getPathString(final String fileExtension) {\n        return BulkTest.TEST_PROPERTIES_PATH + \"test\" + fileExtension;\n    }\n\n    private boolean isXmlTest(final String fileExtension) {\n        return \".xml\".equals(fileExtension);\n    }\n\n    @Test\n    public void testInstance() {\n        assertNotNull(PropertiesFactory.INSTANCE);\n    }\n\n    @ParameterizedTest\n    @MethodSource(value = \"getParameters\")\n    public void testLoadClassLoaderMissingResource(final String fileExtension) throws Exception {\n        assertNull(factory.load(ClassLoader.getSystemClassLoader(), \"missing/test\" + fileExtension));\n    }\n\n    @ParameterizedTest\n    @MethodSource(value = \"getParameters\")\n    public void testLoadClassLoaderResource(final String fileExtension) throws Exception {\n        assertContents(factory.load(ClassLoader.getSystemClassLoader(), \"org/apache/commons/collections4/properties/test\" + fileExtension));\n    }\n\n    @ParameterizedTest\n    @MethodSource(value = \"getParameters\")\n    public void testLoadFile(final String fileExtension) throws Exception {\n        assertContents(factory.load(Paths.get(getPathString(fileExtension)).toFile()));\n    }\n\n    @ParameterizedTest\n    @MethodSource(value = \"getParameters\")\n    public void testLoadFileName(final String fileExtension) throws Exception {\n        assertContents(factory.load(getPathString(fileExtension)));\n    }\n\n    @ParameterizedTest\n    @MethodSource(value = \"getParameters\")\n    public void testLoadInputStream(final String fileExtension) throws Exception {\n        // Can't tell what we are reading\n        Assumptions.assumeFalse(isXmlTest(fileExtension));\n        //\n        try (FileInputStream inputStream = new FileInputStream(getPathString(fileExtension))) {\n            assertContents(factory.load(inputStream));\n        }\n    }\n\n    @ParameterizedTest\n    @MethodSource(value = \"getParameters\")\n    public void testLoadPath(final String fileExtension) throws Exception {\n        assertContents(factory.load(Paths.get(getPathString(fileExtension))));\n    }\n\n    @ParameterizedTest\n    @MethodSource(value = \"getParameters\")\n    public void testLoadReader(final String fileExtension) throws Exception {\n        // Can't tell what we are reading\n        Assumptions.assumeFalse(isXmlTest(fileExtension));\n        //\n        try (BufferedReader inputStream = Files.newBufferedReader(Paths.get(getPathString(fileExtension)))) {\n            assertContents(factory.load(inputStream));\n        }\n    }\n\n    @ParameterizedTest\n    @MethodSource(value = \"getParameters\")\n    public void testLoadUri(final String fileExtension) throws Exception {\n        assertContents(factory.load(Paths.get(getPathString(fileExtension)).toUri()));\n    }\n\n    @ParameterizedTest\n    @MethodSource(value = \"getParameters\")\n    public void testLoadUrl(final String fileExtension) throws Exception {\n        assertContents(factory.load(Paths.get(getPathString(fileExtension)).toUri().toURL()));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final AbstractPropertiesFactory<T> factory;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractPropertiesFactory<T>", "name": "factory", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest", "name": "AbstractBidiMapTest", "file_path": "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java", "superclasses": "", "methods": ["[]AbstractBidiMapTest()", "[]AbstractBidiMapTest(String)", "[BulkTest]bulkTestBidiMapIterator()", "[BulkTest]bulkTestInverseMap()", "[BulkTest]bulkTestMapEntrySet()", "[void]doTestGetKey(BidiMap<?, ?>,Object,Object)", "[String]getCompatibilityVersion()", "[BidiMap<K, V>]getMap()", "[boolean]isAllowDuplicateValues()", "[BidiMap<K, V>]makeFullMap()", "[BidiMap<K, V>]makeObject()", "[void]modifyEntrySet(BidiMap<?, T>)", "[void]remove(BidiMap<?, ?>,Object)", "[void]removeByEntrySet(BidiMap<?, ?>,Object,Object)", "[void]removeByKeySet(BidiMap<?, ?>,Object,Object)", "[void]removeValue(BidiMap<?, ?>,Object)", "[void]verify()", "[void]verifyInverse()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[]AbstractBidiMapTest()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[]AbstractBidiMapTest(String)", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[BulkTest]bulkTestBidiMapIterator()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[BulkTest]bulkTestInverseMap()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[BulkTest]bulkTestMapEntrySet()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[void]doTestGetKey(BidiMap<?, ?>,Object,Object)", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[BidiMap<K, V>]getMap()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[boolean]isAllowDuplicateValues()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[BidiMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[BidiMap<K, V>]makeObject()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[void]modifyEntrySet(BidiMap<?, T>)", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[void]remove(BidiMap<?, ?>,Object)", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[void]removeByEntrySet(BidiMap<?, ?>,Object,Object)", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[void]removeByKeySet(BidiMap<?, ?>,Object,Object)", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[void]removeValue(BidiMap<?, ?>,Object)", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[void]verify()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractBidiMapTest.java.AbstractBidiMapTest.[void]verifyInverse()"], "overrides": null, "attributes": [{"original_string": "    public class TestBidiMapEntrySet extends TestMapEntrySet {\n\n        public TestBidiMapEntrySet() {\n        }\n\n        @Test\n        public void testMapEntrySetIteratorEntrySetValueCrossCheck() {\n            final K key1 = getSampleKeys()[0];\n            final K key2 = getSampleKeys()[1];\n            final V newValue1 = getNewSampleValues()[0];\n            final V newValue2 = getNewSampleValues()[1];\n\n            resetFull();\n            // explicitly get entries as sample values/keys are connected for some maps\n            // such as BeanMap\n            Iterator<Map.Entry<K, V>> it = TestBidiMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry1 = getEntry(it, key1);\n            it = TestBidiMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry2 = getEntry(it, key2);\n            Iterator<Map.Entry<K, V>> itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n            itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n            TestBidiMapEntrySet.this.verify();\n\n            if (!isSetValueSupported()) {\n                try {\n                    entry1.setValue(newValue1);\n                } catch (final UnsupportedOperationException ex) {\n                }\n                return;\n            }\n\n            // these checked in superclass\n            entry1.setValue(newValue1);\n            entryConfirmed1.setValue(newValue1);\n            entry2.setValue(newValue2);\n            entryConfirmed2.setValue(newValue2);\n\n            // at this point\n            // key1=newValue1, key2=newValue2\n            try {\n                entry2.setValue(newValue1);  // should remove key1\n            } catch (final IllegalArgumentException ex) {\n                return;  // simplest way of dealing with tricky situation\n            }\n            entryConfirmed2.setValue(newValue1);\n            AbstractBidiMapTest.this.getConfirmed().remove(key1);\n            assertEquals(newValue1, entry2.getValue());\n            assertTrue(AbstractBidiMapTest.this.getMap().containsKey(entry2.getKey()));\n            assertTrue(AbstractBidiMapTest.this.getMap().containsValue(newValue1));\n            assertEquals(newValue1, AbstractBidiMapTest.this.getMap().get(entry2.getKey()));\n            assertFalse(AbstractBidiMapTest.this.getMap().containsKey(key1));\n            assertFalse(AbstractBidiMapTest.this.getMap().containsValue(newValue2));\n            TestBidiMapEntrySet.this.verify();\n\n            // check for ConcurrentModification\n            it.next();  // if you fail here, maybe you should be throwing an IAE, see above\n            if (isRemoveSupported()) {\n                it.remove();\n            }\n        }\n\n    }", "definition": "    public class TestBidiMapEntrySet extends TestMapEntrySet", "class_docstring": "", "name": "TestBidiMapEntrySet", "super_interfaces": [], "superclasses": "TestMapEntrySet", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestBidiMapEntrySet() {\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestBidiMapEntrySet", "params": [], "body": "                                     {\n        }", "signature": "public TestBidiMapEntrySet()"}, {"syntax_pass": true, "original_string": "        @Test\n        public void testMapEntrySetIteratorEntrySetValueCrossCheck() {\n            final K key1 = getSampleKeys()[0];\n            final K key2 = getSampleKeys()[1];\n            final V newValue1 = getNewSampleValues()[0];\n            final V newValue2 = getNewSampleValues()[1];\n\n            resetFull();\n            // explicitly get entries as sample values/keys are connected for some maps\n            // such as BeanMap\n            Iterator<Map.Entry<K, V>> it = TestBidiMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry1 = getEntry(it, key1);\n            it = TestBidiMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry2 = getEntry(it, key2);\n            Iterator<Map.Entry<K, V>> itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n            itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n            TestBidiMapEntrySet.this.verify();\n\n            if (!isSetValueSupported()) {\n                try {\n                    entry1.setValue(newValue1);\n                } catch (final UnsupportedOperationException ex) {\n                }\n                return;\n            }\n\n            // these checked in superclass\n            entry1.setValue(newValue1);\n            entryConfirmed1.setValue(newValue1);\n            entry2.setValue(newValue2);\n            entryConfirmed2.setValue(newValue2);\n\n            // at this point\n            // key1=newValue1, key2=newValue2\n            try {\n                entry2.setValue(newValue1);  // should remove key1\n            } catch (final IllegalArgumentException ex) {\n                return;  // simplest way of dealing with tricky situation\n            }\n            entryConfirmed2.setValue(newValue1);\n            AbstractBidiMapTest.this.getConfirmed().remove(key1);\n            assertEquals(newValue1, entry2.getValue());\n            assertTrue(AbstractBidiMapTest.this.getMap().containsKey(entry2.getKey()));\n            assertTrue(AbstractBidiMapTest.this.getMap().containsValue(newValue1));\n            assertEquals(newValue1, AbstractBidiMapTest.this.getMap().get(entry2.getKey()));\n            assertFalse(AbstractBidiMapTest.this.getMap().containsKey(key1));\n            assertFalse(AbstractBidiMapTest.this.getMap().containsValue(newValue2));\n            TestBidiMapEntrySet.this.verify();\n\n            // check for ConcurrentModification\n            it.next();  // if you fail here, maybe you should be throwing an IAE, see above\n            if (isRemoveSupported()) {\n                it.remove();\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Test\n        public", "marker_annotations": ["@Test"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "testMapEntrySetIteratorEntrySetValueCrossCheck", "params": [], "body": "                                                                     {\n            final K key1 = getSampleKeys()[0];\n            final K key2 = getSampleKeys()[1];\n            final V newValue1 = getNewSampleValues()[0];\n            final V newValue2 = getNewSampleValues()[1];\n\n            resetFull();\n            // explicitly get entries as sample values/keys are connected for some maps\n            // such as BeanMap\n            Iterator<Map.Entry<K, V>> it = TestBidiMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry1 = getEntry(it, key1);\n            it = TestBidiMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry2 = getEntry(it, key2);\n            Iterator<Map.Entry<K, V>> itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n            itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n            TestBidiMapEntrySet.this.verify();\n\n            if (!isSetValueSupported()) {\n                try {\n                    entry1.setValue(newValue1);\n                } catch (final UnsupportedOperationException ex) {\n                }\n                return;\n            }\n\n            // these checked in superclass\n            entry1.setValue(newValue1);\n            entryConfirmed1.setValue(newValue1);\n            entry2.setValue(newValue2);\n            entryConfirmed2.setValue(newValue2);\n\n            // at this point\n            // key1=newValue1, key2=newValue2\n            try {\n                entry2.setValue(newValue1);  // should remove key1\n            } catch (final IllegalArgumentException ex) {\n                return;  // simplest way of dealing with tricky situation\n            }\n            entryConfirmed2.setValue(newValue1);\n            AbstractBidiMapTest.this.getConfirmed().remove(key1);\n            assertEquals(newValue1, entry2.getValue());\n            assertTrue(AbstractBidiMapTest.this.getMap().containsKey(entry2.getKey()));\n            assertTrue(AbstractBidiMapTest.this.getMap().containsValue(newValue1));\n            assertEquals(newValue1, AbstractBidiMapTest.this.getMap().get(entry2.getKey()));\n            assertFalse(AbstractBidiMapTest.this.getMap().containsKey(key1));\n            assertFalse(AbstractBidiMapTest.this.getMap().containsValue(newValue2));\n            TestBidiMapEntrySet.this.verify();\n\n            // check for ConcurrentModification\n            it.next();  // if you fail here, maybe you should be throwing an IAE, see above\n            if (isRemoveSupported()) {\n                it.remove();\n            }\n        }", "signature": "@Test\n        public void testMapEntrySetIteratorEntrySetValueCrossCheck()"}]}, {"original_string": "    public class TestBidiMapIterator extends AbstractMapIteratorTest<K, V> {\n\n        public TestBidiMapIterator() {\n            super(\"TestBidiMapIterator\");\n        }\n\n        @Override\n        public V[] addSetValues() {\n            return getNewSampleValues();\n        }\n\n        @Override\n        public Map<K, V> getConfirmedMap() {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }\n\n        @Override\n        public BidiMap<K, V> getMap() {\n            // assumes makeFullMapIterator() called first\n            return AbstractBidiMapTest.this.getMap();\n        }\n\n        @Override\n        public MapIterator<K, V> makeEmptyIterator() {\n            resetEmpty();\n            return AbstractBidiMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public MapIterator<K, V> makeObject() {\n            resetFull();\n            return AbstractBidiMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }\n\n        @Override\n        public boolean supportsSetValue() {\n            return isSetValueSupported();\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            AbstractBidiMapTest.this.verify();\n        }\n\n    }", "definition": "    public class TestBidiMapIterator extends AbstractMapIteratorTest<K, V>", "class_docstring": "", "name": "TestBidiMapIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestBidiMapIterator() {\n            super(\"TestBidiMapIterator\");\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestBidiMapIterator", "params": [], "body": "                                     {\n            super(\"TestBidiMapIterator\");\n        }", "signature": "public TestBidiMapIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V[] addSetValues() {\n            return getNewSampleValues();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V[]", "classes": []}, "name": "addSetValues", "params": [], "body": "                                  {\n            return getNewSampleValues();\n        }", "signature": "@Override\n        public V[] addSetValues()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map<K, V> getConfirmedMap() {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<K, V>", "classes": []}, "name": "getConfirmedMap", "params": [], "body": "                                           {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }", "signature": "@Override\n        public Map<K, V> getConfirmedMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public BidiMap<K, V> getMap() {\n            // assumes makeFullMapIterator() called first\n            return AbstractBidiMapTest.this.getMap();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BidiMap<K, V>", "classes": []}, "name": "getMap", "params": [], "body": "                                      {\n            // assumes makeFullMapIterator() called first\n            return AbstractBidiMapTest.this.getMap();\n        }", "signature": "@Override\n        public BidiMap<K, V> getMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public MapIterator<K, V> makeEmptyIterator() {\n            resetEmpty();\n            return AbstractBidiMapTest.this.getMap().mapIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "MapIterator<K, V>", "classes": []}, "name": "makeEmptyIterator", "params": [], "body": "                                                     {\n            resetEmpty();\n            return AbstractBidiMapTest.this.getMap().mapIterator();\n        }", "signature": "@Override\n        public MapIterator<K, V> makeEmptyIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public MapIterator<K, V> makeObject() {\n            resetFull();\n            return AbstractBidiMapTest.this.getMap().mapIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "MapIterator<K, V>", "classes": []}, "name": "makeObject", "params": [], "body": "                                              {\n            resetFull();\n            return AbstractBidiMapTest.this.getMap().mapIterator();\n        }", "signature": "@Override\n        public MapIterator<K, V> makeObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "supportsRemove", "params": [], "body": "                                        {\n            return isRemoveSupported();\n        }", "signature": "@Override\n        public boolean supportsRemove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean supportsSetValue() {\n            return isSetValueSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "supportsSetValue", "params": [], "body": "                                          {\n            return isSetValueSupported();\n        }", "signature": "@Override\n        public boolean supportsSetValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void verify() {\n            super.verify();\n            AbstractBidiMapTest.this.verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "verify", "params": [], "body": "                             {\n            super.verify();\n            AbstractBidiMapTest.this.verify();\n        }", "signature": "@Override\n        public void verify()"}]}, {"original_string": "    public class TestInverseBidiMap extends AbstractBidiMapTest<V, K> {\n\n        final AbstractBidiMapTest<K, V> main;\n\n        public TestInverseBidiMap(final AbstractBidiMapTest<K, V> main) {\n            this.main = main;\n        }\n\n        @Override\n        public String getCompatibilityVersion() {\n            return main.getCompatibilityVersion();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return main.getIterationBehaviour();\n        }\n\n        @Override\n        public V[] getSampleKeys() {\n            return main.getSampleValues();\n        }\n\n        @Override\n        public K[] getSampleValues() {\n            return main.getSampleKeys();\n        }\n\n        @Override\n        public boolean isAllowNullKey() {\n            return main.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isAllowNullValue() {\n            return main.isAllowNullValue();\n        }\n\n        @Override\n        public boolean isPutAddSupported() {\n            return main.isPutAddSupported();\n        }\n\n        @Override\n        public boolean isPutChangeSupported() {\n            return main.isPutChangeSupported();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return main.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isSetValueSupported() {\n            return main.isSetValueSupported();\n        }\n\n        @Override\n        public BidiMap<V, K> makeFullMap() {\n            return main.makeFullMap().inverseBidiMap();\n        }\n\n        @Override\n        public BidiMap<V, K> makeObject() {\n            return main.makeObject().inverseBidiMap();\n        }\n    }", "definition": "    public class TestInverseBidiMap extends AbstractBidiMapTest<V, K>", "class_docstring": "", "name": "TestInverseBidiMap", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "final AbstractBidiMapTest<K, V> main;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "AbstractBidiMapTest<K, V>", "name": "main", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestInverseBidiMap(final AbstractBidiMapTest<K, V> main) {\n            this.main = main;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestInverseBidiMap", "params": [{"name": "main", "type": "AbstractBidiMapTest<K, V>"}], "body": "                                                                        {\n            this.main = main;\n        }", "signature": "public TestInverseBidiMap(final AbstractBidiMapTest<K, V> main)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String getCompatibilityVersion() {\n            return main.getCompatibilityVersion();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getCompatibilityVersion", "params": [], "body": "                                                {\n            return main.getCompatibilityVersion();\n        }", "signature": "@Override\n        public String getCompatibilityVersion()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected int getIterationBehaviour() {\n            return main.getIterationBehaviour();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "getIterationBehaviour", "params": [], "body": "                                              {\n            return main.getIterationBehaviour();\n        }", "signature": "@Override\n        protected int getIterationBehaviour()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V[] getSampleKeys() {\n            return main.getSampleValues();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V[]", "classes": []}, "name": "getSampleKeys", "params": [], "body": "                                   {\n            return main.getSampleValues();\n        }", "signature": "@Override\n        public V[] getSampleKeys()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K[] getSampleValues() {\n            return main.getSampleKeys();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K[]", "classes": []}, "name": "getSampleValues", "params": [], "body": "                                     {\n            return main.getSampleKeys();\n        }", "signature": "@Override\n        public K[] getSampleValues()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAllowNullKey() {\n            return main.isAllowNullKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAllowNullKey", "params": [], "body": "                                        {\n            return main.isAllowNullKey();\n        }", "signature": "@Override\n        public boolean isAllowNullKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAllowNullValue() {\n            return main.isAllowNullValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAllowNullValue", "params": [], "body": "                                          {\n            return main.isAllowNullValue();\n        }", "signature": "@Override\n        public boolean isAllowNullValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isPutAddSupported() {\n            return main.isPutAddSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isPutAddSupported", "params": [], "body": "                                           {\n            return main.isPutAddSupported();\n        }", "signature": "@Override\n        public boolean isPutAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isPutChangeSupported() {\n            return main.isPutChangeSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isPutChangeSupported", "params": [], "body": "                                              {\n            return main.isPutChangeSupported();\n        }", "signature": "@Override\n        public boolean isPutChangeSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return main.isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return main.isRemoveSupported();\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isSetValueSupported() {\n            return main.isSetValueSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isSetValueSupported", "params": [], "body": "                                             {\n            return main.isSetValueSupported();\n        }", "signature": "@Override\n        public boolean isSetValueSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public BidiMap<V, K> makeFullMap() {\n            return main.makeFullMap().inverseBidiMap();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BidiMap<V, K>", "classes": []}, "name": "makeFullMap", "params": [], "body": "                                           {\n            return main.makeFullMap().inverseBidiMap();\n        }", "signature": "@Override\n        public BidiMap<V, K> makeFullMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public BidiMap<V, K> makeObject() {\n            return main.makeObject().inverseBidiMap();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BidiMap<V, K>", "classes": []}, "name": "makeObject", "params": [], "body": "                                          {\n            return main.makeObject().inverseBidiMap();\n        }", "signature": "@Override\n        public BidiMap<V, K> makeObject()"}]}], "class_docstring": "\nAbstract test class for {@link BidiMap} methods and contracts.\n", "original_string": "public abstract class AbstractBidiMapTest<K, V> extends AbstractIterableMapTest<K, V> {\n\n    public class TestBidiMapEntrySet extends TestMapEntrySet {\n\n        public TestBidiMapEntrySet() {\n        }\n\n        @Test\n        public void testMapEntrySetIteratorEntrySetValueCrossCheck() {\n            final K key1 = getSampleKeys()[0];\n            final K key2 = getSampleKeys()[1];\n            final V newValue1 = getNewSampleValues()[0];\n            final V newValue2 = getNewSampleValues()[1];\n\n            resetFull();\n            // explicitly get entries as sample values/keys are connected for some maps\n            // such as BeanMap\n            Iterator<Map.Entry<K, V>> it = TestBidiMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry1 = getEntry(it, key1);\n            it = TestBidiMapEntrySet.this.getCollection().iterator();\n            final Map.Entry<K, V> entry2 = getEntry(it, key2);\n            Iterator<Map.Entry<K, V>> itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed1 = getEntry(itConfirmed, key1);\n            itConfirmed = TestBidiMapEntrySet.this.getConfirmed().iterator();\n            final Map.Entry<K, V> entryConfirmed2 = getEntry(itConfirmed, key2);\n            TestBidiMapEntrySet.this.verify();\n\n            if (!isSetValueSupported()) {\n                try {\n                    entry1.setValue(newValue1);\n                } catch (final UnsupportedOperationException ex) {\n                }\n                return;\n            }\n\n            // these checked in superclass\n            entry1.setValue(newValue1);\n            entryConfirmed1.setValue(newValue1);\n            entry2.setValue(newValue2);\n            entryConfirmed2.setValue(newValue2);\n\n            // at this point\n            // key1=newValue1, key2=newValue2\n            try {\n                entry2.setValue(newValue1);  // should remove key1\n            } catch (final IllegalArgumentException ex) {\n                return;  // simplest way of dealing with tricky situation\n            }\n            entryConfirmed2.setValue(newValue1);\n            AbstractBidiMapTest.this.getConfirmed().remove(key1);\n            assertEquals(newValue1, entry2.getValue());\n            assertTrue(AbstractBidiMapTest.this.getMap().containsKey(entry2.getKey()));\n            assertTrue(AbstractBidiMapTest.this.getMap().containsValue(newValue1));\n            assertEquals(newValue1, AbstractBidiMapTest.this.getMap().get(entry2.getKey()));\n            assertFalse(AbstractBidiMapTest.this.getMap().containsKey(key1));\n            assertFalse(AbstractBidiMapTest.this.getMap().containsValue(newValue2));\n            TestBidiMapEntrySet.this.verify();\n\n            // check for ConcurrentModification\n            it.next();  // if you fail here, maybe you should be throwing an IAE, see above\n            if (isRemoveSupported()) {\n                it.remove();\n            }\n        }\n\n    }\n\n    public class TestBidiMapIterator extends AbstractMapIteratorTest<K, V> {\n\n        public TestBidiMapIterator() {\n            super(\"TestBidiMapIterator\");\n        }\n\n        @Override\n        public V[] addSetValues() {\n            return getNewSampleValues();\n        }\n\n        @Override\n        public Map<K, V> getConfirmedMap() {\n            // assumes makeFullMapIterator() called first\n            return getConfirmed();\n        }\n\n        @Override\n        public BidiMap<K, V> getMap() {\n            // assumes makeFullMapIterator() called first\n            return AbstractBidiMapTest.this.getMap();\n        }\n\n        @Override\n        public MapIterator<K, V> makeEmptyIterator() {\n            resetEmpty();\n            return AbstractBidiMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public MapIterator<K, V> makeObject() {\n            resetFull();\n            return AbstractBidiMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }\n\n        @Override\n        public boolean supportsSetValue() {\n            return isSetValueSupported();\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            AbstractBidiMapTest.this.verify();\n        }\n\n    }\n\n    public class TestInverseBidiMap extends AbstractBidiMapTest<V, K> {\n\n        final AbstractBidiMapTest<K, V> main;\n\n        public TestInverseBidiMap(final AbstractBidiMapTest<K, V> main) {\n            this.main = main;\n        }\n\n        @Override\n        public String getCompatibilityVersion() {\n            return main.getCompatibilityVersion();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return main.getIterationBehaviour();\n        }\n\n        @Override\n        public V[] getSampleKeys() {\n            return main.getSampleValues();\n        }\n\n        @Override\n        public K[] getSampleValues() {\n            return main.getSampleKeys();\n        }\n\n        @Override\n        public boolean isAllowNullKey() {\n            return main.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isAllowNullValue() {\n            return main.isAllowNullValue();\n        }\n\n        @Override\n        public boolean isPutAddSupported() {\n            return main.isPutAddSupported();\n        }\n\n        @Override\n        public boolean isPutChangeSupported() {\n            return main.isPutChangeSupported();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return main.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isSetValueSupported() {\n            return main.isSetValueSupported();\n        }\n\n        @Override\n        public BidiMap<V, K> makeFullMap() {\n            return main.makeFullMap().inverseBidiMap();\n        }\n\n        @Override\n        public BidiMap<V, K> makeObject() {\n            return main.makeObject().inverseBidiMap();\n        }\n    }\n\n    public AbstractBidiMapTest() {\n        super(\"Inverse\");\n    }\n\n    public AbstractBidiMapTest(final String testName) {\n        super(testName);\n    }\n\n    public BulkTest bulkTestBidiMapIterator() {\n        return new TestBidiMapIterator();\n    }\n\n    public BulkTest bulkTestInverseMap() {\n        return new TestInverseBidiMap(this);\n    }\n\n    @Override\n    public BulkTest bulkTestMapEntrySet() {\n        return new TestBidiMapEntrySet();\n    }\n\n    private void doTestGetKey(final BidiMap<?, ?> map, final Object key, final Object value) {\n        assertEquals(value, map.get(key), \"Value not found for key.\");\n        assertEquals(key, map.getKey(value), \"Key not found for value.\");\n    }\n\n    /**\n     * Override as DualHashBidiMap didn't exist until version 3.\n     */\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4\";\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public BidiMap<K, V> getMap() {\n        return (BidiMap<K, V>) super.getMap();\n    }\n\n    /**\n     * Override to indicate to AbstractTestMap this is a BidiMap.\n     */\n    @Override\n    public boolean isAllowDuplicateValues() {\n        return false;\n    }\n\n    /**\n     * Override to create a full {@code BidiMap} other than the default.\n     *\n     * @return a full {@code BidiMap} implementation.\n     */\n    @Override\n    public BidiMap<K, V> makeFullMap() {\n        return (BidiMap<K, V>) super.makeFullMap();\n    }\n\n    /**\n     * Override to return the empty BidiMap.\n     */\n    @Override\n    public abstract BidiMap<K, V> makeObject();\n\n    @SuppressWarnings(\"unchecked\")\n    private <T> void modifyEntrySet(final BidiMap<?, T> map) {\n        // Gets first entry\n        final Map.Entry<?, T> entry = map.entrySet().iterator().next();\n\n        // Gets key and value\n        final Object key = entry.getKey();\n        final Object oldValue = entry.getValue();\n\n        // Sets new value\n        final Object newValue = \"newValue\";\n        entry.setValue((T) newValue);\n\n        assertEquals(\n            newValue,\n            map.get(key),\n                \"Modifying entrySet did not affect underlying Map.\");\n\n        assertNull(\n            map.getKey(oldValue),\n                \"Modifying entrySet did not affect inverse Map.\");\n    }\n\n    private void remove(final BidiMap<?, ?> map, final Object key) {\n        final Object value = map.remove(key);\n        assertFalse(map.containsKey(key), \"Key was not removed.\");\n        assertNull(map.getKey(value), \"Value was not removed.\");\n    }\n\n    private void removeByEntrySet(final BidiMap<?, ?> map, final Object key, final Object value) {\n        final Map<Object, Object> temp = new HashMap<>();\n        temp.put(key, value);\n        map.entrySet().remove(temp.entrySet().iterator().next());\n\n        assertFalse(map.containsKey(key), \"Key was not removed.\");\n        assertFalse(map.containsValue(value), \"Value was not removed.\");\n\n        assertFalse(map.inverseBidiMap().containsValue(key), \"Key was not removed from inverse map.\");\n        assertFalse(map.inverseBidiMap().containsKey(value), \"Value was not removed from inverse map.\");\n    }\n\n    private void removeByKeySet(final BidiMap<?, ?> map, final Object key, final Object value) {\n        map.remove(key);\n\n        assertFalse(map.containsKey(key), \"Key was not removed.\");\n        assertFalse(map.containsValue(value), \"Value was not removed.\");\n\n        assertFalse(map.inverseBidiMap().containsValue(key), \"Key was not removed from inverse map.\");\n        assertFalse(map.inverseBidiMap().containsKey(value), \"Value was not removed from inverse map.\");\n    }\n\n    private void removeValue(final BidiMap<?, ?> map, final Object value) {\n        final Object key = map.removeValue(value);\n        assertFalse(map.containsKey(key), \"Key was not removed.\");\n        assertNull(map.getKey(value), \"Value was not removed.\");\n    }\n\n    @Test\n    public void testBidiClear() {\n        if (!isRemoveSupported()) {\n            assertThrows(UnsupportedOperationException.class, () -> makeFullMap().clear());\n            return;\n        }\n\n        BidiMap<?, ?> map = makeFullMap();\n        map.clear();\n        assertTrue(map.isEmpty(), \"Map was not cleared.\");\n        assertTrue(map.inverseBidiMap().isEmpty(), \"Inverse map was not cleared.\");\n\n        // Tests clear on inverse\n        map = makeFullMap().inverseBidiMap();\n        map.clear();\n        assertTrue(map.isEmpty(), \"Map was not cleared.\");\n        assertTrue(map.inverseBidiMap().isEmpty(), \"Inverse map was not cleared.\");\n    }\n\n    // testGetKey\n    @Test\n    public void testBidiGetKey() {\n        doTestGetKey(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);\n    }\n\n    @Test\n    public void testBidiGetKeyInverse() {\n        doTestGetKey(\n            makeFullMap().inverseBidiMap(),\n            getSampleValues()[0],\n            getSampleKeys()[0]);\n    }\n\n    // testInverse\n    @Test\n    public void testBidiInverse() {\n        final BidiMap<K, V> map = makeFullMap();\n        final BidiMap<V, K> inverseMap = map.inverseBidiMap();\n\n        assertSame(\n                map,\n                inverseMap.inverseBidiMap(),\n                \"Inverse of inverse is not equal to original.\");\n\n        assertEquals(\n                getSampleKeys()[0],\n                inverseMap.get(getSampleValues()[0]),\n                \"Value not found for key.\");\n\n        assertEquals(\n                getSampleValues()[0],\n                inverseMap.getKey(getSampleKeys()[0]),\n                \"Key not found for value.\");\n    }\n\n    @Test\n    public void testBidiKeySetValuesOrder() {\n        // Skip if collection is unordered\n        Assumptions.assumeFalse((getIterationBehaviour() & AbstractCollectionTest.UNORDERED) != 0);\n        resetFull();\n        final Iterator<K> keys = map.keySet().iterator();\n        final Iterator<V> values = map.values().iterator();\n        while (keys.hasNext() && values.hasNext()) {\n            final K key = keys.next();\n            final V value = values.next();\n            assertSame(map.get(key), value);\n        }\n        assertFalse(keys.hasNext());\n        assertFalse(values.hasNext());\n    }\n\n    @Test\n    public void testBidiMapIteratorSet() {\n        final V newValue1 = getOtherValues()[0];\n        final V newValue2 = getOtherValues()[1];\n\n        resetFull();\n        final BidiMap<K, V> bidi = getMap();\n        final MapIterator<K, V> it = bidi.mapIterator();\n        assertTrue(it.hasNext());\n        final K key1 = it.next();\n\n        if (!isSetValueSupported()) {\n            assertThrows(UnsupportedOperationException.class, () -> it.setValue(newValue1));\n            return;\n        }\n\n        it.setValue(newValue1);\n        confirmed.put(key1, newValue1);\n        assertSame(key1, it.getKey());\n        assertSame(newValue1, it.getValue());\n        assertTrue(bidi.containsKey(key1));\n        assertTrue(bidi.containsValue(newValue1));\n        assertEquals(newValue1, bidi.get(key1));\n        verify();\n\n        it.setValue(newValue1);  // same value - should be OK\n        confirmed.put(key1, newValue1);\n        assertSame(key1, it.getKey());\n        assertSame(newValue1, it.getValue());\n        assertTrue(bidi.containsKey(key1));\n        assertTrue(bidi.containsValue(newValue1));\n        assertEquals(newValue1, bidi.get(key1));\n        verify();\n\n        final K key2 = it.next();\n        it.setValue(newValue2);\n        confirmed.put(key2, newValue2);\n        assertSame(key2, it.getKey());\n        assertSame(newValue2, it.getValue());\n        assertTrue(bidi.containsKey(key2));\n        assertTrue(bidi.containsValue(newValue2));\n        assertEquals(newValue2, bidi.get(key2));\n        verify();\n\n        // at this point\n        // key1=newValue1, key2=newValue2\n        assertThrows(IllegalArgumentException.class, () -> it.setValue(newValue1));  // should remove key1\n        // below code was previously never executed\n//        confirmed.put(key2, newValue1);\n//        AbstractBidiMapTest.this.getConfirmed().remove(key1);\n//        assertEquals(newValue1, it.getValue());\n//        assertTrue(bidi.containsKey(it.getKey()));\n//        assertTrue(bidi.containsValue(newValue1));\n//        assertEquals(newValue1, bidi.get(it.getKey()));\n//        assertFalse(bidi.containsKey(key1));\n//        assertFalse(bidi.containsValue(newValue2));\n//        verify();\n//\n//        // check for ConcurrentModification\n//        it.next();  // if you fail here, maybe you should be throwing an IAE, see above\n//        if (isRemoveSupported()) {\n//            it.remove();\n//        }\n    }\n\n    @Test\n    public void testBidiModifyEntrySet() {\n        if (!isSetValueSupported()) {\n            return;\n        }\n\n        modifyEntrySet(makeFullMap());\n        modifyEntrySet(makeFullMap().inverseBidiMap());\n    }\n\n    // BidiPut\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testBidiPut() {\n        if (!isPutAddSupported() || !isPutChangeSupported()) {\n            return;\n        }\n\n        final BidiMap<K, V> map = makeObject();\n        final BidiMap<V, K> inverse = map.inverseBidiMap();\n        assertEquals(0, map.size());\n        assertEquals(map.size(), inverse.size());\n\n        map.put((K) \"A\", (V) \"B\");\n        assertEquals(1, map.size());\n        assertEquals(map.size(), inverse.size());\n        assertEquals(\"B\", map.get(\"A\"));\n        assertEquals(\"A\", inverse.get(\"B\"));\n\n        map.put((K) \"A\", (V) \"C\");\n        assertEquals(1, map.size());\n        assertEquals(map.size(), inverse.size());\n        assertEquals(\"C\", map.get(\"A\"));\n        assertEquals(\"A\", inverse.get(\"C\"));\n\n        map.put((K) \"B\", (V) \"C\");\n        assertEquals(1, map.size());\n        assertEquals(map.size(), inverse.size());\n        assertEquals(\"C\", map.get(\"B\"));\n        assertEquals(\"B\", inverse.get(\"C\"));\n\n        map.put((K) \"E\", (V) \"F\");\n        assertEquals(2, map.size());\n        assertEquals(map.size(), inverse.size());\n        assertEquals(\"F\", map.get(\"E\"));\n        assertEquals(\"E\", inverse.get(\"F\"));\n    }\n\n    @Test\n    public void testBidiRemove() {\n        if (!isRemoveSupported()) {\n            assertThrows(UnsupportedOperationException.class, () -> makeFullMap().remove(getSampleKeys()[0]));\n\n            assertThrows(UnsupportedOperationException.class, () -> makeFullMap().removeValue(getSampleValues()[0]));\n\n            return;\n        }\n\n        remove(makeFullMap(), getSampleKeys()[0]);\n        remove(makeFullMap().inverseBidiMap(), getSampleValues()[0]);\n\n        removeValue(makeFullMap(), getSampleValues()[0]);\n        removeValue(makeFullMap().inverseBidiMap(), getSampleKeys()[0]);\n\n        assertNull(makeFullMap().removeValue(\"NotPresent\"));\n    }\n\n    @Test\n    public void testBidiRemoveByEntrySet() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        removeByEntrySet(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);\n        removeByEntrySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);\n    }\n\n    @Test\n    public void testBidiRemoveByKeySet() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        removeByKeySet(makeFullMap(), getSampleKeys()[0], getSampleValues()[0]);\n        removeByKeySet(makeFullMap().inverseBidiMap(), getSampleValues()[0], getSampleKeys()[0]);\n    }\n\n    /**\n     * Verifies that {@link #map} is still equal to {@link #confirmed}.\n     * <p>\n     * This implementation checks the inverse map as well.\n     */\n    @Override\n    public void verify() {\n        verifyInverse();\n        super.verify();\n    }\n\n    public void verifyInverse() {\n        assertEquals(map.size(), ((BidiMap<K, V>) map).inverseBidiMap().size());\n        final Map<K, V> map1 = new HashMap<>(map);\n        final Map<V, K> map2 = new HashMap<>(((BidiMap<K, V>) map).inverseBidiMap());\n        final Set<K> keys1 = map1.keySet();\n        final Set<V> keys2 = map2.keySet();\n        final Collection<V> values1 = map1.values();\n        final Collection<K> values2 = map2.values();\n        assertTrue(keys1.containsAll(values2));\n        assertTrue(values2.containsAll(keys1));\n        assertTrue(values1.containsAll(keys2));\n        assertTrue(keys2.containsAll(values1));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapTest.java.AbstractSortedBidiMapTest", "name": "AbstractSortedBidiMapTest", "file_path": "src/test/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapTest.java", "superclasses": "", "methods": ["[]AbstractSortedBidiMapTest(String)", "[BulkTest]bulkTestHeadMap()", "[BulkTest]bulkTestSubMap()", "[BulkTest]bulkTestTailMap()", "[boolean]isAllowNullKey()", "[boolean]isAllowNullValue()", "[SortedMap<K, V>]makeConfirmedMap()", "[SortedBidiMap<K, V>]makeFullMap()", "[SortedBidiMap<K, V>]makeObject()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapTest.java.AbstractSortedBidiMapTest.[]AbstractSortedBidiMapTest(String)", "src/test/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapTest.java.AbstractSortedBidiMapTest.[BulkTest]bulkTestHeadMap()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapTest.java.AbstractSortedBidiMapTest.[BulkTest]bulkTestSubMap()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapTest.java.AbstractSortedBidiMapTest.[BulkTest]bulkTestTailMap()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapTest.java.AbstractSortedBidiMapTest.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapTest.java.AbstractSortedBidiMapTest.[boolean]isAllowNullValue()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapTest.java.AbstractSortedBidiMapTest.[SortedMap<K, V>]makeConfirmedMap()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapTest.java.AbstractSortedBidiMapTest.[SortedBidiMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapTest.java.AbstractSortedBidiMapTest.[SortedBidiMap<K, V>]makeObject()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract test class for {@link SortedBidiMap} methods and contracts.\n", "original_string": "public abstract class AbstractSortedBidiMapTest<K extends Comparable<K>, V extends Comparable<V>> extends AbstractOrderedBidiMapTest<K, V> {\n\n    protected List<K> sortedKeys;\n    protected List<V> sortedValues = new ArrayList<>();\n    protected SortedSet<V> sortedNewValues = new TreeSet<>();\n\n    public AbstractSortedBidiMapTest(final String testName) {\n        super(testName);\n        sortedKeys = getAsList(getSampleKeys());\n        Collections.sort(sortedKeys);\n        sortedKeys = Collections.unmodifiableList(sortedKeys);\n\n        final Map<K, V> map = new TreeMap<>();\n        addSampleMappings(map);\n\n        sortedValues.addAll(map.values());\n        sortedValues = Collections.unmodifiableList(sortedValues);\n\n        sortedNewValues.addAll(getAsList(getNewSampleValues()));\n    }\n\n//    public AbstractTestSortedBidiMap() {\n//        super();\n//        sortedKeys.addAll(Arrays.asList(getSampleValues()));\n//        Collections.sort(sortedKeys);\n//        sortedKeys = Collections.unmodifiableList(sortedKeys);\n//\n//        Map map = new TreeMap();\n//        for (int i = 0; i < getSampleKeys().length; i++) {\n//            map.put(getSampleValues()[i], getSampleKeys()[i]);\n//        }\n//        sortedValues.addAll(map.values());\n//        sortedValues = Collections.unmodifiableList(sortedValues);\n//\n//        sortedNewValues.addAll(Arrays.asList(getNewSampleValues()));\n//    }\n\n    public BulkTest bulkTestHeadMap() {\n        return new AbstractSortedMapTest.TestHeadMap<>(this);\n    }\n\n    public BulkTest bulkTestSubMap() {\n        return new AbstractSortedMapTest.TestSubMap<>(this);\n    }\n\n    public BulkTest bulkTestTailMap() {\n        return new AbstractSortedMapTest.TestTailMap<>(this);\n    }\n\n    @Override\n    public boolean isAllowNullKey() {\n        return false;\n    }\n\n    @Override\n    public boolean isAllowNullValue() {\n        return false;\n    }\n\n    @Override\n    public SortedMap<K, V> makeConfirmedMap() {\n        return new TreeMap<>();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SortedBidiMap<K, V> makeFullMap() {\n        return (SortedBidiMap<K, V>) super.makeFullMap();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public abstract SortedBidiMap<K, V> makeObject();\n\n    @Test\n    public void testBidiClearByHeadMap() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        // extra test as other tests get complex\n        final SortedBidiMap<K, V> sm = makeFullMap();\n        final Iterator<K> it = sm.keySet().iterator();\n        final K first = it.next();\n        final K second = it.next();\n        final K toKey = it.next();\n\n        final V firstValue = sm.get(first);\n        final V secondValue = sm.get(second);\n        final V toKeyValue = sm.get(toKey);\n\n        final SortedMap<K, V> sub = sm.headMap(toKey);\n        final int size = sm.size();\n        assertEquals(2, sub.size());\n        sub.clear();\n        assertEquals(0, sub.size());\n        assertEquals(size - 2, sm.size());\n        assertEquals(size - 2, sm.inverseBidiMap().size());\n\n        assertFalse(sm.containsKey(first));\n        assertFalse(sm.containsValue(firstValue));\n        assertFalse(sm.inverseBidiMap().containsKey(firstValue));\n        assertFalse(sm.inverseBidiMap().containsValue(first));\n        assertFalse(sub.containsKey(first));\n        assertFalse(sub.containsValue(firstValue));\n\n        assertFalse(sm.containsKey(second));\n        assertFalse(sm.containsValue(secondValue));\n        assertFalse(sm.inverseBidiMap().containsKey(secondValue));\n        assertFalse(sm.inverseBidiMap().containsValue(second));\n        assertFalse(sub.containsKey(second));\n        assertFalse(sub.containsValue(secondValue));\n\n        assertTrue(sm.containsKey(toKey));\n        assertTrue(sm.containsValue(toKeyValue));\n        assertTrue(sm.inverseBidiMap().containsKey(toKeyValue));\n        assertTrue(sm.inverseBidiMap().containsValue(toKey));\n        assertFalse(sub.containsKey(toKey));\n        assertFalse(sub.containsValue(toKeyValue));\n    }\n\n    @Test\n    public void testBidiClearBySubMap() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        // extra test as other tests get complex\n        final SortedBidiMap<K, V> sm = makeFullMap();\n        final Iterator<K> it = sm.keySet().iterator();\n        it.next();\n        final K fromKey = it.next();\n        final K first = it.next();\n        final K second = it.next();\n        final K toKey = it.next();\n\n        final V fromKeyValue = sm.get(fromKey);\n        final V firstValue = sm.get(first);\n        final V secondValue = sm.get(second);\n        final V toKeyValue = sm.get(toKey);\n\n        final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n        final int size = sm.size();\n        assertEquals(3, sub.size());\n        sub.clear();\n        assertEquals(0, sub.size());\n        assertEquals(size - 3, sm.size());\n        assertEquals(size - 3, sm.inverseBidiMap().size());\n\n        assertFalse(sm.containsKey(fromKey));\n        assertFalse(sm.containsValue(fromKeyValue));\n        assertFalse(sm.inverseBidiMap().containsKey(fromKeyValue));\n        assertFalse(sm.inverseBidiMap().containsValue(fromKey));\n        assertFalse(sub.containsKey(fromKey));\n        assertFalse(sub.containsValue(fromKeyValue));\n\n        assertFalse(sm.containsKey(first));\n        assertFalse(sm.containsValue(firstValue));\n        assertFalse(sm.inverseBidiMap().containsKey(firstValue));\n        assertFalse(sm.inverseBidiMap().containsValue(first));\n        assertFalse(sub.containsKey(first));\n        assertFalse(sub.containsValue(firstValue));\n\n        assertFalse(sm.containsKey(second));\n        assertFalse(sm.containsValue(secondValue));\n        assertFalse(sm.inverseBidiMap().containsKey(secondValue));\n        assertFalse(sm.inverseBidiMap().containsValue(second));\n        assertFalse(sub.containsKey(second));\n        assertFalse(sub.containsValue(secondValue));\n\n        assertTrue(sm.containsKey(toKey));\n        assertTrue(sm.containsValue(toKeyValue));\n        assertTrue(sm.inverseBidiMap().containsKey(toKeyValue));\n        assertTrue(sm.inverseBidiMap().containsValue(toKey));\n        assertFalse(sub.containsKey(toKey));\n        assertFalse(sub.containsValue(toKeyValue));\n    }\n\n    @Test\n    public void testBidiClearByTailMap() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        // extra test as other tests get complex\n        final SortedBidiMap<K, V> sm = makeFullMap();\n        final Iterator<K> it = sm.keySet().iterator();\n        it.next();\n        it.next();\n        final K first = it.next();\n        final K fromKey = it.next();\n        final K second = it.next();\n\n        final V firstValue = sm.get(first);\n        final V fromKeyValue = sm.get(fromKey);\n        final V secondValue = sm.get(second);\n\n        final SortedMap<K, V> sub = sm.tailMap(fromKey);\n        final int size = sm.size();\n        assertEquals(size - 3, sub.size());\n        sub.clear();\n        assertEquals(0, sub.size());\n        assertEquals(3, sm.size());\n        assertEquals(3, sm.inverseBidiMap().size());\n\n        assertTrue(sm.containsKey(first));\n        assertTrue(sm.containsValue(firstValue));\n        assertTrue(sm.inverseBidiMap().containsKey(firstValue));\n        assertTrue(sm.inverseBidiMap().containsValue(first));\n        assertFalse(sub.containsKey(first));\n        assertFalse(sub.containsValue(firstValue));\n\n        assertFalse(sm.containsKey(fromKey));\n        assertFalse(sm.containsValue(fromKeyValue));\n        assertFalse(sm.inverseBidiMap().containsKey(fromKeyValue));\n        assertFalse(sm.inverseBidiMap().containsValue(fromKey));\n        assertFalse(sub.containsKey(fromKey));\n        assertFalse(sub.containsValue(fromKeyValue));\n\n        assertFalse(sm.containsKey(second));\n        assertFalse(sm.containsValue(secondValue));\n        assertFalse(sm.inverseBidiMap().containsKey(secondValue));\n        assertFalse(sm.inverseBidiMap().containsValue(second));\n        assertFalse(sub.containsKey(second));\n        assertFalse(sub.containsValue(secondValue));\n    }\n\n    @Test\n    public void testBidiHeadMapContains() {\n        // extra test as other tests get complex\n        final SortedBidiMap<K, V> sm = makeFullMap();\n        final Iterator<K> it = sm.keySet().iterator();\n        final K first = it.next();\n        final K toKey = it.next();\n        final K second = it.next();\n        final V firstValue = sm.get(first);\n        final V secondValue = sm.get(second);\n\n        final SortedMap<K, V> head = sm.headMap(toKey);\n        assertEquals(1, head.size());\n        assertTrue(sm.containsKey(first));\n        assertTrue(head.containsKey(first));\n        assertTrue(sm.containsValue(firstValue));\n        assertTrue(head.containsValue(firstValue));\n        assertTrue(sm.containsKey(second));\n        assertFalse(head.containsKey(second));\n        assertTrue(sm.containsValue(secondValue));\n        assertFalse(head.containsValue(secondValue));\n    }\n\n    @Test\n    public void testBidiRemoveByHeadMap() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        // extra test as other tests get complex\n        final SortedBidiMap<K, V> sm = makeFullMap();\n        final Iterator<K> it = sm.keySet().iterator();\n        final K first = it.next();\n        final K second = it.next();\n        final K toKey = it.next();\n\n        final int size = sm.size();\n        final SortedMap<K, V> sub = sm.headMap(toKey);\n        assertEquals(2, sub.size());\n        assertTrue(sm.containsKey(first));\n        assertTrue(sub.containsKey(first));\n        assertTrue(sm.containsKey(second));\n        assertTrue(sub.containsKey(second));\n\n        final V firstValue = sub.remove(first);\n        assertEquals(1, sub.size());\n        assertEquals(size - 1, sm.size());\n        assertEquals(size - 1, sm.inverseBidiMap().size());\n        assertFalse(sm.containsKey(first));\n        assertFalse(sm.containsValue(firstValue));\n        assertFalse(sm.inverseBidiMap().containsKey(firstValue));\n        assertFalse(sm.inverseBidiMap().containsValue(first));\n        assertFalse(sub.containsKey(first));\n        assertFalse(sub.containsValue(firstValue));\n\n        final V secondValue = sub.remove(second);\n        assertEquals(0, sub.size());\n        assertEquals(size - 2, sm.size());\n        assertEquals(size - 2, sm.inverseBidiMap().size());\n        assertFalse(sm.containsKey(second));\n        assertFalse(sm.containsValue(secondValue));\n        assertFalse(sm.inverseBidiMap().containsKey(secondValue));\n        assertFalse(sm.inverseBidiMap().containsValue(second));\n        assertFalse(sub.containsKey(second));\n        assertFalse(sub.containsValue(secondValue));\n    }\n\n    @Test\n    public void testBidiRemoveByHeadMapEntrySet() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        // extra test as other tests get complex\n        final SortedBidiMap<K, V> sm = makeFullMap();\n        final Iterator<K> it = sm.keySet().iterator();\n        final K first = it.next();\n        final K second = it.next();\n        final K toKey = it.next();\n\n        final int size = sm.size();\n        final SortedMap<K, V> sub = sm.headMap(toKey);\n        final Set<Map.Entry<K, V>> set = sub.entrySet();\n        assertEquals(2, sub.size());\n        assertEquals(2, set.size());\n\n        final Iterator<Map.Entry<K, V>> it2 = set.iterator();\n        final Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n        final Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n        assertTrue(sm.containsKey(first));\n        assertTrue(sub.containsKey(first));\n        assertTrue(set.contains(firstEntry));\n        assertTrue(sm.containsKey(second));\n        assertTrue(sub.containsKey(second));\n        assertTrue(set.contains(secondEntry));\n\n        set.remove(firstEntry);\n        assertEquals(1, sub.size());\n        assertEquals(size - 1, sm.size());\n        assertEquals(size - 1, sm.inverseBidiMap().size());\n        assertFalse(sm.containsKey(firstEntry.getKey()));\n        assertFalse(sm.containsValue(firstEntry.getValue()));\n        assertFalse(sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n        assertFalse(sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n        assertFalse(sub.containsKey(firstEntry.getKey()));\n        assertFalse(sub.containsValue(firstEntry.getValue()));\n        assertFalse(set.contains(firstEntry));\n\n        set.remove(secondEntry);\n        assertEquals(0, sub.size());\n        assertEquals(size - 2, sm.size());\n        assertEquals(size - 2, sm.inverseBidiMap().size());\n        assertFalse(sm.containsKey(secondEntry.getKey()));\n        assertFalse(sm.containsValue(secondEntry.getValue()));\n        assertFalse(sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n        assertFalse(sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n        assertFalse(sub.containsKey(secondEntry.getKey()));\n        assertFalse(sub.containsValue(secondEntry.getValue()));\n        assertFalse(set.contains(secondEntry));\n    }\n\n    @Test\n    public void testBidiRemoveBySubMap() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        // extra test as other tests get complex\n        final SortedBidiMap<K, V> sm = makeFullMap();\n        final Iterator<K> it = sm.keySet().iterator();\n        it.next();\n        it.next();\n        final K fromKey = it.next();\n        final K first = it.next();\n        final K second = it.next();\n        final K toKey = it.next();\n\n        final int size = sm.size();\n        final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n        assertTrue(sm.containsKey(first));\n        assertTrue(sub.containsKey(first));\n        assertTrue(sm.containsKey(second));\n        assertTrue(sub.containsKey(second));\n\n        final V firstValue = sub.remove(first);\n        assertEquals(2, sub.size());\n        assertEquals(size - 1, sm.size());\n        assertEquals(size - 1, sm.inverseBidiMap().size());\n        assertFalse(sm.containsKey(first));\n        assertFalse(sm.containsValue(firstValue));\n        assertFalse(sm.inverseBidiMap().containsKey(firstValue));\n        assertFalse(sm.inverseBidiMap().containsValue(first));\n        assertFalse(sub.containsKey(first));\n        assertFalse(sub.containsValue(firstValue));\n\n        final V secondValue = sub.remove(second);\n        assertEquals(1, sub.size());\n        assertEquals(size - 2, sm.size());\n        assertEquals(size - 2, sm.inverseBidiMap().size());\n        assertFalse(sm.containsKey(second));\n        assertFalse(sm.containsValue(secondValue));\n        assertFalse(sm.inverseBidiMap().containsKey(secondValue));\n        assertFalse(sm.inverseBidiMap().containsValue(second));\n        assertFalse(sub.containsKey(second));\n        assertFalse(sub.containsValue(secondValue));\n    }\n\n    @Test\n    public void testBidiRemoveBySubMapEntrySet() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        // extra test as other tests get complex\n        final SortedBidiMap<K, V> sm = makeFullMap();\n        final Iterator<K> it = sm.keySet().iterator();\n        it.next();\n        it.next();\n        final K fromKey = it.next();\n        final K first = it.next();\n        final K second = it.next();\n        final K toKey = it.next();\n\n        final int size = sm.size();\n        final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n        final Set<Map.Entry<K, V>> set = sub.entrySet();\n        assertEquals(3, set.size());\n        final Iterator<Map.Entry<K, V>> it2 = set.iterator();\n        it2.next();\n        final Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n        final Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n        assertTrue(sm.containsKey(first));\n        assertTrue(sub.containsKey(first));\n        assertTrue(set.contains(firstEntry));\n        assertTrue(sm.containsKey(second));\n        assertTrue(sub.containsKey(second));\n        assertTrue(set.contains(secondEntry));\n\n        set.remove(firstEntry);\n        assertEquals(2, sub.size());\n        assertEquals(size - 1, sm.size());\n        assertEquals(size - 1, sm.inverseBidiMap().size());\n        assertFalse(sm.containsKey(firstEntry.getKey()));\n        assertFalse(sm.containsValue(firstEntry.getValue()));\n        assertFalse(sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n        assertFalse(sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n        assertFalse(sub.containsKey(firstEntry.getKey()));\n        assertFalse(sub.containsValue(firstEntry.getValue()));\n        assertFalse(set.contains(firstEntry));\n\n        set.remove(secondEntry);\n        assertEquals(1, sub.size());\n        assertEquals(size - 2, sm.size());\n        assertEquals(size - 2, sm.inverseBidiMap().size());\n        assertFalse(sm.containsKey(secondEntry.getKey()));\n        assertFalse(sm.containsValue(secondEntry.getValue()));\n        assertFalse(sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n        assertFalse(sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n        assertFalse(sub.containsKey(secondEntry.getKey()));\n        assertFalse(sub.containsValue(secondEntry.getValue()));\n        assertFalse(set.contains(secondEntry));\n    }\n\n    @Test\n    public void testBidiRemoveByTailMap() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        // extra test as other tests get complex\n        final SortedBidiMap<K, V> sm = makeFullMap();\n        final Iterator<K> it = sm.keySet().iterator();\n        it.next();\n        it.next();\n        final K fromKey = it.next();\n        final K first = it.next();\n        final K second = it.next();\n\n        final int size = sm.size();\n        final SortedMap<K, V> sub = sm.tailMap(fromKey);\n        assertTrue(sm.containsKey(first));\n        assertTrue(sub.containsKey(first));\n        assertTrue(sm.containsKey(second));\n        assertTrue(sub.containsKey(second));\n\n        final Object firstValue = sub.remove(first);\n        assertEquals(size - 3, sub.size());\n        assertEquals(size - 1, sm.size());\n        assertEquals(size - 1, sm.inverseBidiMap().size());\n        assertFalse(sm.containsKey(first));\n        assertFalse(sm.containsValue(firstValue));\n        assertFalse(sm.inverseBidiMap().containsKey(firstValue));\n        assertFalse(sm.inverseBidiMap().containsValue(first));\n        assertFalse(sub.containsKey(first));\n        assertFalse(sub.containsValue(firstValue));\n\n        final Object secondValue = sub.remove(second);\n        assertEquals(size - 4, sub.size());\n        assertEquals(size - 2, sm.size());\n        assertEquals(size - 2, sm.inverseBidiMap().size());\n        assertFalse(sm.containsKey(second));\n        assertFalse(sm.containsValue(secondValue));\n        assertFalse(sm.inverseBidiMap().containsKey(secondValue));\n        assertFalse(sm.inverseBidiMap().containsValue(second));\n        assertFalse(sub.containsKey(second));\n        assertFalse(sub.containsValue(secondValue));\n    }\n\n    @Test\n    public void testBidiRemoveByTailMapEntrySet() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        // extra test as other tests get complex\n        final SortedBidiMap<K, V> sm = makeFullMap();\n        final Iterator<K> it = sm.keySet().iterator();\n        it.next();\n        it.next();\n        final K fromKey = it.next();\n        final K first = it.next();\n        final K second = it.next();\n\n        final int size = sm.size();\n        final SortedMap<K, V> sub = sm.tailMap(fromKey);\n        final Set<Map.Entry<K, V>> set = sub.entrySet();\n        final Iterator<Map.Entry<K, V>> it2 = set.iterator();\n        it2.next();\n        final Map.Entry<K, V> firstEntry = cloneMapEntry(it2.next());\n        final Map.Entry<K, V> secondEntry = cloneMapEntry(it2.next());\n        assertTrue(sm.containsKey(first));\n        assertTrue(sub.containsKey(first));\n        assertTrue(set.contains(firstEntry));\n        assertTrue(sm.containsKey(second));\n        assertTrue(sub.containsKey(second));\n        assertTrue(set.contains(secondEntry));\n\n        set.remove(firstEntry);\n        assertEquals(size - 3, sub.size());\n        assertEquals(size - 1, sm.size());\n        assertEquals(size - 1, sm.inverseBidiMap().size());\n        assertFalse(sm.containsKey(firstEntry.getKey()));\n        assertFalse(sm.containsValue(firstEntry.getValue()));\n        assertFalse(sm.inverseBidiMap().containsKey(firstEntry.getValue()));\n        assertFalse(sm.inverseBidiMap().containsValue(firstEntry.getKey()));\n        assertFalse(sub.containsKey(firstEntry.getKey()));\n        assertFalse(sub.containsValue(firstEntry.getValue()));\n        assertFalse(set.contains(firstEntry));\n\n        set.remove(secondEntry);\n        assertEquals(size - 4, sub.size());\n        assertEquals(size - 2, sm.size());\n        assertEquals(size - 2, sm.inverseBidiMap().size());\n        assertFalse(sm.containsKey(secondEntry.getKey()));\n        assertFalse(sm.containsValue(secondEntry.getValue()));\n        assertFalse(sm.inverseBidiMap().containsKey(secondEntry.getValue()));\n        assertFalse(sm.inverseBidiMap().containsValue(secondEntry.getKey()));\n        assertFalse(sub.containsKey(secondEntry.getKey()));\n        assertFalse(sub.containsValue(secondEntry.getValue()));\n        assertFalse(set.contains(secondEntry));\n    }\n\n    @Test\n    public void testBidiSubMapContains() {\n        // extra test as other tests get complex\n        final SortedBidiMap<K, V> sm = makeFullMap();\n        final Iterator<K> it = sm.keySet().iterator();\n        final K first = it.next();\n        final K fromKey = it.next();\n        final K second = it.next();\n        final K toKey = it.next();\n        final K third = it.next();\n        final V firstValue = sm.get(first);\n        final V fromKeyValue = sm.get(fromKey);\n        final V secondValue = sm.get(second);\n        final V thirdValue = sm.get(third);\n\n        final SortedMap<K, V> sub = sm.subMap(fromKey, toKey);\n        assertEquals(2, sub.size());\n        assertTrue(sm.containsKey(first));\n        assertFalse(sub.containsKey(first));\n        assertTrue(sm.containsValue(firstValue));\n        assertFalse(sub.containsValue(firstValue));\n        assertTrue(sm.containsKey(fromKey));\n        assertTrue(sub.containsKey(fromKey));\n        assertTrue(sm.containsValue(fromKeyValue));\n        assertTrue(sub.containsValue(fromKeyValue));\n        assertTrue(sm.containsKey(second));\n        assertTrue(sub.containsKey(second));\n        assertTrue(sm.containsValue(secondValue));\n        assertTrue(sub.containsValue(secondValue));\n        assertTrue(sm.containsKey(third));\n        assertFalse(sub.containsKey(third));\n        assertTrue(sm.containsValue(thirdValue));\n        assertFalse(sub.containsValue(thirdValue));\n    }\n\n    @Test\n    public void testBidiTailMapContains() {\n        // extra test as other tests get complex\n        final SortedBidiMap<K, V> sm = makeFullMap();\n        final Iterator<K> it = sm.keySet().iterator();\n        final K first = it.next();\n        final K fromKey = it.next();\n        final K second = it.next();\n        final V firstValue = sm.get(first);\n        final V fromKeyValue = sm.get(fromKey);\n        final V secondValue = sm.get(second);\n\n        final SortedMap<K, V> sub = sm.tailMap(fromKey);\n        assertEquals(sm.size() - 1, sub.size());\n        assertTrue(sm.containsKey(first));\n        assertFalse(sub.containsKey(first));\n        assertTrue(sm.containsValue(firstValue));\n        assertFalse(sub.containsValue(firstValue));\n        assertTrue(sm.containsKey(fromKey));\n        assertTrue(sub.containsKey(fromKey));\n        assertTrue(sm.containsValue(fromKeyValue));\n        assertTrue(sub.containsValue(fromKeyValue));\n        assertTrue(sm.containsKey(second));\n        assertTrue(sub.containsKey(second));\n        assertTrue(sm.containsValue(secondValue));\n        assertTrue(sub.containsValue(secondValue));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected List<K> sortedKeys;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<K>", "name": "sortedKeys", "syntax_pass": true}, {"attribute_expression": "protected List<V> sortedValues = new ArrayList<>();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "List<V>", "name": "sortedValues = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "protected SortedSet<V> sortedNewValues = new TreeSet<>();", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "SortedSet<V>", "name": "sortedNewValues = new TreeSet<>()", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapTest.java.AbstractOrderedBidiMapTest", "name": "AbstractOrderedBidiMapTest", "file_path": "src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapTest.java", "superclasses": "", "methods": ["[]AbstractOrderedBidiMapTest()", "[]AbstractOrderedBidiMapTest(String)", "[BulkTest]bulkTestOrderedMapIterator()", "[OrderedBidiMap<K, V>]getMap()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapTest.java.AbstractOrderedBidiMapTest.[]AbstractOrderedBidiMapTest()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapTest.java.AbstractOrderedBidiMapTest.[]AbstractOrderedBidiMapTest(String)", "src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapTest.java.AbstractOrderedBidiMapTest.[BulkTest]bulkTestOrderedMapIterator()", "src/test/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapTest.java.AbstractOrderedBidiMapTest.[OrderedBidiMap<K, V>]getMap()"], "overrides": null, "attributes": [{"original_string": "    public class TestBidiOrderedMapIterator extends AbstractMapIteratorTest<K, V> {\n\n        public TestBidiOrderedMapIterator() {\n            super(\"TestBidiOrderedMapIterator\");\n        }\n\n        @Override\n        public V[] addSetValues() {\n            return getNewSampleValues();\n        }\n\n        @Override\n        public Map<K, V> getConfirmedMap() {\n            // assumes makeFullMapIterator() called first\n            return AbstractOrderedBidiMapTest.this.confirmed;\n        }\n\n        @Override\n        public Map<K, V> getMap() {\n            // assumes makeFullMapIterator() called first\n            return AbstractOrderedBidiMapTest.this.map;\n        }\n\n        @Override\n        public MapIterator<K, V> makeEmptyIterator() {\n            resetEmpty();\n            return AbstractOrderedBidiMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public MapIterator<K, V> makeObject() {\n            resetFull();\n            return AbstractOrderedBidiMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }\n\n        @Override\n        public boolean supportsSetValue() {\n            return isSetValueSupported();\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            AbstractOrderedBidiMapTest.this.verify();\n        }\n\n    }", "definition": "    public class TestBidiOrderedMapIterator extends AbstractMapIteratorTest<K, V>", "class_docstring": "", "name": "TestBidiOrderedMapIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestBidiOrderedMapIterator() {\n            super(\"TestBidiOrderedMapIterator\");\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestBidiOrderedMapIterator", "params": [], "body": "                                            {\n            super(\"TestBidiOrderedMapIterator\");\n        }", "signature": "public TestBidiOrderedMapIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V[] addSetValues() {\n            return getNewSampleValues();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V[]", "classes": []}, "name": "addSetValues", "params": [], "body": "                                  {\n            return getNewSampleValues();\n        }", "signature": "@Override\n        public V[] addSetValues()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map<K, V> getConfirmedMap() {\n            // assumes makeFullMapIterator() called first\n            return AbstractOrderedBidiMapTest.this.confirmed;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<K, V>", "classes": []}, "name": "getConfirmedMap", "params": [], "body": "                                           {\n            // assumes makeFullMapIterator() called first\n            return AbstractOrderedBidiMapTest.this.confirmed;\n        }", "signature": "@Override\n        public Map<K, V> getConfirmedMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map<K, V> getMap() {\n            // assumes makeFullMapIterator() called first\n            return AbstractOrderedBidiMapTest.this.map;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<K, V>", "classes": []}, "name": "getMap", "params": [], "body": "                                  {\n            // assumes makeFullMapIterator() called first\n            return AbstractOrderedBidiMapTest.this.map;\n        }", "signature": "@Override\n        public Map<K, V> getMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public MapIterator<K, V> makeEmptyIterator() {\n            resetEmpty();\n            return AbstractOrderedBidiMapTest.this.getMap().mapIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "MapIterator<K, V>", "classes": []}, "name": "makeEmptyIterator", "params": [], "body": "                                                     {\n            resetEmpty();\n            return AbstractOrderedBidiMapTest.this.getMap().mapIterator();\n        }", "signature": "@Override\n        public MapIterator<K, V> makeEmptyIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public MapIterator<K, V> makeObject() {\n            resetFull();\n            return AbstractOrderedBidiMapTest.this.getMap().mapIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "MapIterator<K, V>", "classes": []}, "name": "makeObject", "params": [], "body": "                                              {\n            resetFull();\n            return AbstractOrderedBidiMapTest.this.getMap().mapIterator();\n        }", "signature": "@Override\n        public MapIterator<K, V> makeObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "supportsRemove", "params": [], "body": "                                        {\n            return isRemoveSupported();\n        }", "signature": "@Override\n        public boolean supportsRemove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean supportsSetValue() {\n            return isSetValueSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "supportsSetValue", "params": [], "body": "                                          {\n            return isSetValueSupported();\n        }", "signature": "@Override\n        public boolean supportsSetValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void verify() {\n            super.verify();\n            AbstractOrderedBidiMapTest.this.verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "verify", "params": [], "body": "                             {\n            super.verify();\n            AbstractOrderedBidiMapTest.this.verify();\n        }", "signature": "@Override\n        public void verify()"}]}], "class_docstring": "\nAbstract test class for {@link OrderedBidiMap} methods and contracts.\n", "original_string": "public abstract class AbstractOrderedBidiMapTest<K, V> extends AbstractBidiMapTest<K, V> {\n\n    public class TestBidiOrderedMapIterator extends AbstractMapIteratorTest<K, V> {\n\n        public TestBidiOrderedMapIterator() {\n            super(\"TestBidiOrderedMapIterator\");\n        }\n\n        @Override\n        public V[] addSetValues() {\n            return getNewSampleValues();\n        }\n\n        @Override\n        public Map<K, V> getConfirmedMap() {\n            // assumes makeFullMapIterator() called first\n            return AbstractOrderedBidiMapTest.this.confirmed;\n        }\n\n        @Override\n        public Map<K, V> getMap() {\n            // assumes makeFullMapIterator() called first\n            return AbstractOrderedBidiMapTest.this.map;\n        }\n\n        @Override\n        public MapIterator<K, V> makeEmptyIterator() {\n            resetEmpty();\n            return AbstractOrderedBidiMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public MapIterator<K, V> makeObject() {\n            resetFull();\n            return AbstractOrderedBidiMapTest.this.getMap().mapIterator();\n        }\n\n        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }\n\n        @Override\n        public boolean supportsSetValue() {\n            return isSetValueSupported();\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            AbstractOrderedBidiMapTest.this.verify();\n        }\n\n    }\n\n    public AbstractOrderedBidiMapTest() {\n    }\n\n    public AbstractOrderedBidiMapTest(final String testName) {\n        super(testName);\n    }\n\n    public BulkTest bulkTestOrderedMapIterator() {\n        return new TestBidiOrderedMapIterator();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public OrderedBidiMap<K, V> getMap() {\n        return (OrderedBidiMap<K, V>) super.getMap();\n    }\n\n    @Test\n    public void testFirstKey() {\n        resetEmpty();\n        OrderedBidiMap<K, V> bidi = getMap();\n\n        final OrderedBidiMap<K, V> finalBidi = bidi;\n        assertThrows(NoSuchElementException.class, () -> finalBidi.firstKey());\n\n        resetFull();\n        bidi = getMap();\n        final K confirmedFirst = confirmed.keySet().iterator().next();\n        assertEquals(confirmedFirst, bidi.firstKey());\n    }\n\n    @Test\n    public void testLastKey() {\n        resetEmpty();\n        OrderedBidiMap<K, V> bidi = getMap();\n\n        final OrderedBidiMap<K, V> finalBidi = bidi;\n        assertThrows(NoSuchElementException.class, () -> finalBidi.lastKey());\n\n        resetFull();\n        bidi = getMap();\n        K confirmedLast = null;\n        for (final Iterator<K> it = confirmed.keySet().iterator(); it.hasNext();) {\n            confirmedLast = it.next();\n        }\n        assertEquals(confirmedLast, bidi.lastKey());\n    }\n\n    @Test\n    public void testNextKey() {\n        resetEmpty();\n        OrderedBidiMap<K, V> bidi = (OrderedBidiMap<K, V>) map;\n        assertNull(bidi.nextKey(getOtherKeys()[0]));\n        if (!isAllowNullKey()) {\n            try {\n                assertNull(bidi.nextKey(null)); // this is allowed too\n            } catch (final NullPointerException ignore) {\n                // ignore\n            }\n        } else {\n            assertNull(bidi.nextKey(null));\n        }\n\n        resetFull();\n        bidi = (OrderedBidiMap<K, V>) map;\n        final Iterator<K> it = confirmed.keySet().iterator();\n        K confirmedLast = it.next();\n        while (it.hasNext()) {\n            final K confirmedObject = it.next();\n            assertEquals(confirmedObject, bidi.nextKey(confirmedLast));\n            confirmedLast = confirmedObject;\n        }\n        assertNull(bidi.nextKey(confirmedLast));\n\n        if (!isAllowNullKey()) {\n            final OrderedBidiMap<K, V> finalBidi = bidi;\n            assertThrows(NullPointerException.class, () -> finalBidi.nextKey(null));\n\n        } else {\n            assertNull(bidi.nextKey(null));\n        }\n    }\n\n    @Test\n    public void testPreviousKey() {\n        resetEmpty();\n        OrderedBidiMap<K, V> bidi = getMap();\n        assertNull(bidi.previousKey(getOtherKeys()[0]));\n        if (!isAllowNullKey()) {\n            try {\n                assertNull(bidi.previousKey(null)); // this is allowed too\n            } catch (final NullPointerException ignore) {\n                // ignore\n            }\n        } else {\n            assertNull(bidi.previousKey(null));\n        }\n\n        resetFull();\n        bidi = getMap();\n        final List<K> list = new ArrayList<>(confirmed.keySet());\n        Collections.reverse(list);\n        final Iterator<K> it = list.iterator();\n        K confirmedLast = it.next();\n        while (it.hasNext()) {\n            final K confirmedObject = it.next();\n            assertEquals(confirmedObject, bidi.previousKey(confirmedLast));\n            confirmedLast = confirmedObject;\n        }\n        assertNull(bidi.previousKey(confirmedLast));\n\n        if (!isAllowNullKey()) {\n            final OrderedBidiMap<K, V> finalBidi = bidi;\n            assertThrows(NullPointerException.class, () -> finalBidi.previousKey(null));\n\n        } else {\n            assertNull(bidi.previousKey(null));\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java.AbstractNavigableSetTest", "name": "AbstractNavigableSetTest", "file_path": "src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java", "superclasses": "", "methods": ["[]AbstractNavigableSetTest(String)", "[BulkTest]bulkTestNavigableSetHeadSet()", "[BulkTest]bulkTestNavigableSetSubSet()", "[BulkTest]bulkTestNavigableSetTailSet()", "[NavigableSet<E>]getCollection()", "[NavigableSet<E>]getConfirmed()", "[E[]]getFullNonNullElements()", "[E[]]getOtherNonNullElements()", "[NavigableSet<E>]makeConfirmedCollection()", "[NavigableSet<E>]makeFullCollection()", "[NavigableSet<E>]makeObject()", "[void]verify()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java.AbstractNavigableSetTest.[]AbstractNavigableSetTest(String)", "src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java.AbstractNavigableSetTest.[BulkTest]bulkTestNavigableSetHeadSet()", "src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java.AbstractNavigableSetTest.[BulkTest]bulkTestNavigableSetSubSet()", "src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java.AbstractNavigableSetTest.[BulkTest]bulkTestNavigableSetTailSet()", "src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java.AbstractNavigableSetTest.[NavigableSet<E>]getCollection()", "src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java.AbstractNavigableSetTest.[NavigableSet<E>]getConfirmed()", "src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java.AbstractNavigableSetTest.[E[]]getFullNonNullElements()", "src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java.AbstractNavigableSetTest.[E[]]getOtherNonNullElements()", "src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java.AbstractNavigableSetTest.[NavigableSet<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java.AbstractNavigableSetTest.[NavigableSet<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java.AbstractNavigableSetTest.[NavigableSet<E>]makeObject()", "src/test/java/org/apache/commons/collections4/set/AbstractNavigableSetTest.java.AbstractNavigableSetTest.[void]verify()"], "overrides": null, "attributes": [{"original_string": "    public class TestNavigableSetSubSet extends AbstractNavigableSetTest<E> {\n\n        static final int TYPE_SUBSET = 0;\n        static final int TYPE_TAILSET = 1;\n        static final int TYPE_HEADSET = 2;\n        private final int type;\n        private int lowBound;\n        private int highBound;\n\n        private final E[] fullElements;\n\n        private final E[] otherElements;\n\n        private final boolean inclusive;\n        @SuppressWarnings(\"unchecked\")\n        public TestNavigableSetSubSet(final int bound, final boolean head, final boolean inclusive) {\n            super(\"TestNavigableSetSubSet\");\n            if (head) {\n                this.type = TYPE_HEADSET;\n                this.inclusive = inclusive;\n                this.highBound = bound;\n\n                final int realBound = inclusive ? bound + 1 : bound;\n                fullElements = (E[]) new Object[realBound];\n                System.arraycopy(AbstractNavigableSetTest.this.getFullElements(), 0, fullElements, 0, realBound);\n                otherElements = (E[]) new Object[bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractNavigableSetTest.this.getOtherElements(), 0, otherElements, 0, bound - 1);\n            } else {\n                type = TYPE_TAILSET;\n                this.inclusive = inclusive;\n                lowBound = bound;\n                final Object[] allElements = AbstractNavigableSetTest.this.getFullElements();\n                final int realBound = inclusive ? bound : bound + 1;\n                fullElements = (E[]) new Object[allElements.length - realBound];\n                System.arraycopy(allElements, realBound, fullElements, 0, allElements.length - realBound);\n                otherElements = (E[]) new Object[allElements.length - bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractNavigableSetTest.this.getOtherElements(), bound, otherElements, 0, allElements.length - bound - 1);\n            }\n\n        } //type\n        @SuppressWarnings(\"unchecked\")\n        public TestNavigableSetSubSet(final int loBound, final int hiBound, final boolean inclusive) {\n            super(\"TestNavigableSetSubSet\");\n            this.type = TYPE_SUBSET;\n            this.lowBound = loBound;\n            this.highBound = hiBound;\n            this.inclusive = inclusive;\n\n            final int fullLoBound = inclusive ? loBound : loBound + 1;\n            final int length = hiBound - loBound + 1 - (inclusive ? 0 : 2);\n            fullElements = (E[]) new Object[length];\n            System.arraycopy(AbstractNavigableSetTest.this.getFullElements(), fullLoBound, fullElements, 0, length);\n            final int otherLength = hiBound - loBound;\n            otherElements = (E[]) new Object[otherLength - 1];\n            System.arraycopy(//src src_pos dst dst_pos length\n                AbstractNavigableSetTest.this.getOtherElements(), loBound, otherElements, 0, otherLength - 1);\n        }\n        @Override\n        public BulkTest bulkTestNavigableSetHeadSet() {\n            return null;  // prevent infinite recursion\n        }\n\n        @Override\n        public BulkTest bulkTestNavigableSetSubSet() {\n            return null;  // prevent infinite recursion\n        }\n        @Override\n        public BulkTest bulkTestNavigableSetTailSet() {\n            return null;  // prevent infinite recursion\n        }\n\n        @Override\n        public BulkTest bulkTestSortedSetHeadSet() {\n            return null;  // prevent infinite recursion\n        }\n\n        @Override\n        public BulkTest bulkTestSortedSetSubSet() {\n            return null;  // prevent infinite recursion\n        }\n\n        @Override\n        public BulkTest bulkTestSortedSetTailSet() {\n            return null;  // prevent infinite recursion\n        }\n\n        @Override\n        public E[] getFullElements() {\n            return fullElements;\n        }\n\n        @Override\n        public E[] getOtherElements() {\n            return otherElements;\n        }\n        private NavigableSet<E> getSubSet(final NavigableSet<E> set) {\n            final E[] elements = AbstractNavigableSetTest.this.getFullElements();\n            switch (type) {\n            case TYPE_SUBSET :\n                return set.subSet(elements[lowBound], inclusive, elements[highBound], inclusive);\n            case TYPE_HEADSET :\n                return set.headSet(elements[highBound], inclusive);\n            case TYPE_TAILSET :\n                return set.tailSet(elements[lowBound], inclusive);\n            default :\n                return null;\n            }\n        }\n        @Override\n        public boolean isAddSupported() {\n            return AbstractNavigableSetTest.this.isAddSupported();\n        }\n        @Override\n        public boolean isFailFastSupported() {\n            return AbstractNavigableSetTest.this.isFailFastSupported();\n        }\n        @Override\n        public boolean isNullSupported() {\n            return AbstractNavigableSetTest.this.isNullSupported();\n        }\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractNavigableSetTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n        @Override\n        public NavigableSet<E> makeFullCollection() {\n            return getSubSet(AbstractNavigableSetTest.this.makeFullCollection());\n        }\n        @Override\n        public NavigableSet<E> makeObject() {\n            return getSubSet(AbstractNavigableSetTest.this.makeObject());\n        }\n\n    }", "definition": "    public class TestNavigableSetSubSet extends AbstractNavigableSetTest<E>", "class_docstring": "", "name": "TestNavigableSetSubSet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "static final int TYPE_SUBSET = 0;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "TYPE_SUBSET = 0", "syntax_pass": true}, {"attribute_expression": "static final int TYPE_TAILSET = 1;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "TYPE_TAILSET = 1", "syntax_pass": true}, {"attribute_expression": "static final int TYPE_HEADSET = 2;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "TYPE_HEADSET = 2", "syntax_pass": true}, {"attribute_expression": "private final int type;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "type", "syntax_pass": true}, {"attribute_expression": "private int lowBound;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "lowBound", "syntax_pass": true}, {"attribute_expression": "private int highBound;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "highBound", "syntax_pass": true}, {"attribute_expression": "private final E[] fullElements;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "E[]", "name": "fullElements", "syntax_pass": true}, {"attribute_expression": "private final E[] otherElements;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "E[]", "name": "otherElements", "syntax_pass": true}, {"attribute_expression": "private final boolean inclusive;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "inclusive", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        public TestNavigableSetSubSet(final int bound, final boolean head, final boolean inclusive) {\n            super(\"TestNavigableSetSubSet\");\n            if (head) {\n                this.type = TYPE_HEADSET;\n                this.inclusive = inclusive;\n                this.highBound = bound;\n\n                final int realBound = inclusive ? bound + 1 : bound;\n                fullElements = (E[]) new Object[realBound];\n                System.arraycopy(AbstractNavigableSetTest.this.getFullElements(), 0, fullElements, 0, realBound);\n                otherElements = (E[]) new Object[bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractNavigableSetTest.this.getOtherElements(), 0, otherElements, 0, bound - 1);\n            } else {\n                type = TYPE_TAILSET;\n                this.inclusive = inclusive;\n                lowBound = bound;\n                final Object[] allElements = AbstractNavigableSetTest.this.getFullElements();\n                final int realBound = inclusive ? bound : bound + 1;\n                fullElements = (E[]) new Object[allElements.length - realBound];\n                System.arraycopy(allElements, realBound, fullElements, 0, allElements.length - realBound);\n                otherElements = (E[]) new Object[allElements.length - bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractNavigableSetTest.this.getOtherElements(), bound, otherElements, 0, allElements.length - bound - 1);\n            }\n\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "", "classes": []}, "name": "TestNavigableSetSubSet", "params": [{"name": "bound", "type": "int"}, {"name": "head", "type": "boolean"}, {"name": "inclusive", "type": "boolean"}], "body": "                                                                                                    {\n            super(\"TestNavigableSetSubSet\");\n            if (head) {\n                this.type = TYPE_HEADSET;\n                this.inclusive = inclusive;\n                this.highBound = bound;\n\n                final int realBound = inclusive ? bound + 1 : bound;\n                fullElements = (E[]) new Object[realBound];\n                System.arraycopy(AbstractNavigableSetTest.this.getFullElements(), 0, fullElements, 0, realBound);\n                otherElements = (E[]) new Object[bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractNavigableSetTest.this.getOtherElements(), 0, otherElements, 0, bound - 1);\n            } else {\n                type = TYPE_TAILSET;\n                this.inclusive = inclusive;\n                lowBound = bound;\n                final Object[] allElements = AbstractNavigableSetTest.this.getFullElements();\n                final int realBound = inclusive ? bound : bound + 1;\n                fullElements = (E[]) new Object[allElements.length - realBound];\n                System.arraycopy(allElements, realBound, fullElements, 0, allElements.length - realBound);\n                otherElements = (E[]) new Object[allElements.length - bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractNavigableSetTest.this.getOtherElements(), bound, otherElements, 0, allElements.length - bound - 1);\n            }\n\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        public TestNavigableSetSubSet(final int bound, final boolean head, final boolean inclusive)"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        public TestNavigableSetSubSet(final int loBound, final int hiBound, final boolean inclusive) {\n            super(\"TestNavigableSetSubSet\");\n            this.type = TYPE_SUBSET;\n            this.lowBound = loBound;\n            this.highBound = hiBound;\n            this.inclusive = inclusive;\n\n            final int fullLoBound = inclusive ? loBound : loBound + 1;\n            final int length = hiBound - loBound + 1 - (inclusive ? 0 : 2);\n            fullElements = (E[]) new Object[length];\n            System.arraycopy(AbstractNavigableSetTest.this.getFullElements(), fullLoBound, fullElements, 0, length);\n            final int otherLength = hiBound - loBound;\n            otherElements = (E[]) new Object[otherLength - 1];\n            System.arraycopy(//src src_pos dst dst_pos length\n                AbstractNavigableSetTest.this.getOtherElements(), loBound, otherElements, 0, otherLength - 1);\n        }", "docstring": "type", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "", "classes": []}, "name": "TestNavigableSetSubSet", "params": [{"name": "loBound", "type": "int"}, {"name": "hiBound", "type": "int"}, {"name": "inclusive", "type": "boolean"}], "body": "                                                                                                     {\n            super(\"TestNavigableSetSubSet\");\n            this.type = TYPE_SUBSET;\n            this.lowBound = loBound;\n            this.highBound = hiBound;\n            this.inclusive = inclusive;\n\n            final int fullLoBound = inclusive ? loBound : loBound + 1;\n            final int length = hiBound - loBound + 1 - (inclusive ? 0 : 2);\n            fullElements = (E[]) new Object[length];\n            System.arraycopy(AbstractNavigableSetTest.this.getFullElements(), fullLoBound, fullElements, 0, length);\n            final int otherLength = hiBound - loBound;\n            otherElements = (E[]) new Object[otherLength - 1];\n            System.arraycopy(//src src_pos dst dst_pos length\n                AbstractNavigableSetTest.this.getOtherElements(), loBound, otherElements, 0, otherLength - 1);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        public TestNavigableSetSubSet(final int loBound, final int hiBound, final boolean inclusive)"}, {"syntax_pass": true, "original_string": "        @Override\n        public BulkTest bulkTestNavigableSetHeadSet() {\n            return null;  // prevent infinite recursion\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BulkTest", "classes": []}, "name": "bulkTestNavigableSetHeadSet", "params": [], "body": "                                                      {\n            return null;  // prevent infinite recursion\n        }", "signature": "@Override\n        public BulkTest bulkTestNavigableSetHeadSet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public BulkTest bulkTestNavigableSetSubSet() {\n            return null;  // prevent infinite recursion\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BulkTest", "classes": []}, "name": "bulkTestNavigableSetSubSet", "params": [], "body": "                                                     {\n            return null;  // prevent infinite recursion\n        }", "signature": "@Override\n        public BulkTest bulkTestNavigableSetSubSet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public BulkTest bulkTestNavigableSetTailSet() {\n            return null;  // prevent infinite recursion\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BulkTest", "classes": []}, "name": "bulkTestNavigableSetTailSet", "params": [], "body": "                                                      {\n            return null;  // prevent infinite recursion\n        }", "signature": "@Override\n        public BulkTest bulkTestNavigableSetTailSet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public BulkTest bulkTestSortedSetHeadSet() {\n            return null;  // prevent infinite recursion\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BulkTest", "classes": []}, "name": "bulkTestSortedSetHeadSet", "params": [], "body": "                                                   {\n            return null;  // prevent infinite recursion\n        }", "signature": "@Override\n        public BulkTest bulkTestSortedSetHeadSet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public BulkTest bulkTestSortedSetSubSet() {\n            return null;  // prevent infinite recursion\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BulkTest", "classes": []}, "name": "bulkTestSortedSetSubSet", "params": [], "body": "                                                  {\n            return null;  // prevent infinite recursion\n        }", "signature": "@Override\n        public BulkTest bulkTestSortedSetSubSet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public BulkTest bulkTestSortedSetTailSet() {\n            return null;  // prevent infinite recursion\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BulkTest", "classes": []}, "name": "bulkTestSortedSetTailSet", "params": [], "body": "                                                   {\n            return null;  // prevent infinite recursion\n        }", "signature": "@Override\n        public BulkTest bulkTestSortedSetTailSet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E[] getFullElements() {\n            return fullElements;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                     {\n            return fullElements;\n        }", "signature": "@Override\n        public E[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E[] getOtherElements() {\n            return otherElements;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E[]", "classes": []}, "name": "getOtherElements", "params": [], "body": "                                      {\n            return otherElements;\n        }", "signature": "@Override\n        public E[] getOtherElements()"}, {"syntax_pass": true, "original_string": "        private NavigableSet<E> getSubSet(final NavigableSet<E> set) {\n            final E[] elements = AbstractNavigableSetTest.this.getFullElements();\n            switch (type) {\n            case TYPE_SUBSET :\n                return set.subSet(elements[lowBound], inclusive, elements[highBound], inclusive);\n            case TYPE_HEADSET :\n                return set.headSet(elements[highBound], inclusive);\n            case TYPE_TAILSET :\n                return set.tailSet(elements[lowBound], inclusive);\n            default :\n                return null;\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "NavigableSet<E>", "classes": []}, "name": "getSubSet", "params": [{"name": "set", "type": "NavigableSet<E>"}], "body": "                                                                     {\n            final E[] elements = AbstractNavigableSetTest.this.getFullElements();\n            switch (type) {\n            case TYPE_SUBSET :\n                return set.subSet(elements[lowBound], inclusive, elements[highBound], inclusive);\n            case TYPE_HEADSET :\n                return set.headSet(elements[highBound], inclusive);\n            case TYPE_TAILSET :\n                return set.tailSet(elements[lowBound], inclusive);\n            default :\n                return null;\n            }\n        }", "signature": "private NavigableSet<E> getSubSet(final NavigableSet<E> set)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            return AbstractNavigableSetTest.this.isAddSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            return AbstractNavigableSetTest.this.isAddSupported();\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isFailFastSupported() {\n            return AbstractNavigableSetTest.this.isFailFastSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isFailFastSupported", "params": [], "body": "                                             {\n            return AbstractNavigableSetTest.this.isFailFastSupported();\n        }", "signature": "@Override\n        public boolean isFailFastSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isNullSupported() {\n            return AbstractNavigableSetTest.this.isNullSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNullSupported", "params": [], "body": "                                         {\n            return AbstractNavigableSetTest.this.isNullSupported();\n        }", "signature": "@Override\n        public boolean isNullSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return AbstractNavigableSetTest.this.isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return AbstractNavigableSetTest.this.isRemoveSupported();\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public NavigableSet<E> makeFullCollection() {\n            return getSubSet(AbstractNavigableSetTest.this.makeFullCollection());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "NavigableSet<E>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                                    {\n            return getSubSet(AbstractNavigableSetTest.this.makeFullCollection());\n        }", "signature": "@Override\n        public NavigableSet<E> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public NavigableSet<E> makeObject() {\n            return getSubSet(AbstractNavigableSetTest.this.makeObject());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "NavigableSet<E>", "classes": []}, "name": "makeObject", "params": [], "body": "                                            {\n            return getSubSet(AbstractNavigableSetTest.this.makeObject());\n        }", "signature": "@Override\n        public NavigableSet<E> makeObject()"}]}], "class_docstring": "\nAbstract test class for {@link NavigableSet} methods and contracts.\n<p>\nTo use, subclass and override the {@link #makeObject()}\nmethod.  You may have to override other protected methods if your\nset is not modifiable, or if your set restricts what kinds of\nelements may be added; see {@link AbstractSetTest} for more details.\n", "original_string": "public abstract class AbstractNavigableSetTest<E> extends AbstractSortedSetTest<E> {\n\n    public class TestNavigableSetSubSet extends AbstractNavigableSetTest<E> {\n\n        static final int TYPE_SUBSET = 0;\n        static final int TYPE_TAILSET = 1;\n        static final int TYPE_HEADSET = 2;\n        private final int type;\n        private int lowBound;\n        private int highBound;\n\n        private final E[] fullElements;\n\n        private final E[] otherElements;\n\n        private final boolean inclusive;\n        @SuppressWarnings(\"unchecked\")\n        public TestNavigableSetSubSet(final int bound, final boolean head, final boolean inclusive) {\n            super(\"TestNavigableSetSubSet\");\n            if (head) {\n                this.type = TYPE_HEADSET;\n                this.inclusive = inclusive;\n                this.highBound = bound;\n\n                final int realBound = inclusive ? bound + 1 : bound;\n                fullElements = (E[]) new Object[realBound];\n                System.arraycopy(AbstractNavigableSetTest.this.getFullElements(), 0, fullElements, 0, realBound);\n                otherElements = (E[]) new Object[bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractNavigableSetTest.this.getOtherElements(), 0, otherElements, 0, bound - 1);\n            } else {\n                type = TYPE_TAILSET;\n                this.inclusive = inclusive;\n                lowBound = bound;\n                final Object[] allElements = AbstractNavigableSetTest.this.getFullElements();\n                final int realBound = inclusive ? bound : bound + 1;\n                fullElements = (E[]) new Object[allElements.length - realBound];\n                System.arraycopy(allElements, realBound, fullElements, 0, allElements.length - realBound);\n                otherElements = (E[]) new Object[allElements.length - bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractNavigableSetTest.this.getOtherElements(), bound, otherElements, 0, allElements.length - bound - 1);\n            }\n\n        } //type\n        @SuppressWarnings(\"unchecked\")\n        public TestNavigableSetSubSet(final int loBound, final int hiBound, final boolean inclusive) {\n            super(\"TestNavigableSetSubSet\");\n            this.type = TYPE_SUBSET;\n            this.lowBound = loBound;\n            this.highBound = hiBound;\n            this.inclusive = inclusive;\n\n            final int fullLoBound = inclusive ? loBound : loBound + 1;\n            final int length = hiBound - loBound + 1 - (inclusive ? 0 : 2);\n            fullElements = (E[]) new Object[length];\n            System.arraycopy(AbstractNavigableSetTest.this.getFullElements(), fullLoBound, fullElements, 0, length);\n            final int otherLength = hiBound - loBound;\n            otherElements = (E[]) new Object[otherLength - 1];\n            System.arraycopy(//src src_pos dst dst_pos length\n                AbstractNavigableSetTest.this.getOtherElements(), loBound, otherElements, 0, otherLength - 1);\n        }\n        @Override\n        public BulkTest bulkTestNavigableSetHeadSet() {\n            return null;  // prevent infinite recursion\n        }\n\n        @Override\n        public BulkTest bulkTestNavigableSetSubSet() {\n            return null;  // prevent infinite recursion\n        }\n        @Override\n        public BulkTest bulkTestNavigableSetTailSet() {\n            return null;  // prevent infinite recursion\n        }\n\n        @Override\n        public BulkTest bulkTestSortedSetHeadSet() {\n            return null;  // prevent infinite recursion\n        }\n\n        @Override\n        public BulkTest bulkTestSortedSetSubSet() {\n            return null;  // prevent infinite recursion\n        }\n\n        @Override\n        public BulkTest bulkTestSortedSetTailSet() {\n            return null;  // prevent infinite recursion\n        }\n\n        @Override\n        public E[] getFullElements() {\n            return fullElements;\n        }\n\n        @Override\n        public E[] getOtherElements() {\n            return otherElements;\n        }\n        private NavigableSet<E> getSubSet(final NavigableSet<E> set) {\n            final E[] elements = AbstractNavigableSetTest.this.getFullElements();\n            switch (type) {\n            case TYPE_SUBSET :\n                return set.subSet(elements[lowBound], inclusive, elements[highBound], inclusive);\n            case TYPE_HEADSET :\n                return set.headSet(elements[highBound], inclusive);\n            case TYPE_TAILSET :\n                return set.tailSet(elements[lowBound], inclusive);\n            default :\n                return null;\n            }\n        }\n        @Override\n        public boolean isAddSupported() {\n            return AbstractNavigableSetTest.this.isAddSupported();\n        }\n        @Override\n        public boolean isFailFastSupported() {\n            return AbstractNavigableSetTest.this.isFailFastSupported();\n        }\n        @Override\n        public boolean isNullSupported() {\n            return AbstractNavigableSetTest.this.isNullSupported();\n        }\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractNavigableSetTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n        @Override\n        public NavigableSet<E> makeFullCollection() {\n            return getSubSet(AbstractNavigableSetTest.this.makeFullCollection());\n        }\n        @Override\n        public NavigableSet<E> makeObject() {\n            return getSubSet(AbstractNavigableSetTest.this.makeObject());\n        }\n\n    }\n\n    /**\n     * JUnit constructor.\n     *\n     * @param name  name for test\n     */\n    public AbstractNavigableSetTest(final String name) {\n        super(name);\n    }\n\n    /**\n     * Bulk test {@link NavigableSet#headSet(Object, boolean)}.\n     * This method runs through all of the tests in {@link AbstractNavigableSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the set and the other collection views are still valid.\n     *\n     * @return a {@link AbstractNavigableSetTest} instance for testing a headset.\n     */\n    public BulkTest bulkTestNavigableSetHeadSet() {\n        final int length = getFullElements().length;\n\n        final int loBound = length / 3;\n        final int hiBound = loBound * 2;\n        return new TestNavigableSetSubSet(hiBound, true, true);\n    }\n\n    /**\n     * Bulk test {@link NavigableSet#subSet(Object, boolean, Object, boolean)}.\n     * This method runs through all of the tests in {@link AbstractNavigableSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the set and the other collection views are still valid.\n     *\n     * @return a {@link AbstractNavigableSetTest} instance for testing a subset.\n     */\n    public BulkTest bulkTestNavigableSetSubSet() {\n        final int length = getFullElements().length;\n\n        final int loBound = length / 3;\n        final int hiBound = loBound * 2;\n        return new TestNavigableSetSubSet(loBound, hiBound, false);\n    }\n\n    /**\n     * Bulk test {@link NavigableSet#tailSet(Object, boolean)}.\n     * This method runs through all of the tests in {@link AbstractNavigableSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the set and the other collection views are still valid.\n     *\n     * @return a {@link AbstractNavigableSetTest} instance for testing a tailset.\n     */\n    public BulkTest bulkTestNavigableSetTailSet() {\n        final int length = getFullElements().length;\n        final int loBound = length / 3;\n        return new TestNavigableSetSubSet(loBound, false, false);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public NavigableSet<E> getCollection() {\n        return (NavigableSet<E>) super.getCollection();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public NavigableSet<E> getConfirmed() {\n        return (NavigableSet<E>) super.getConfirmed();\n    }\n\n    /**\n     * Override to return comparable objects.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public E[] getFullNonNullElements() {\n        final Object[] elements = new Object[30];\n\n        for (int i = 0; i < 30; i++) {\n            elements[i] = Integer.valueOf(i + i + 1);\n        }\n        return (E[]) elements;\n    }\n\n    /**\n     * Override to return comparable objects.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public E[] getOtherNonNullElements() {\n        final Object[] elements = new Object[30];\n        for (int i = 0; i < 30; i++) {\n            elements[i] = Integer.valueOf(i + i + 2);\n        }\n        return (E[]) elements;\n    }\n\n    /**\n     * Returns an empty {@link TreeSet} for use in modification testing.\n     *\n     * @return a confirmed empty collection\n     */\n    @Override\n    public NavigableSet<E> makeConfirmedCollection() {\n        return new TreeSet<>();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public NavigableSet<E> makeFullCollection() {\n        return (NavigableSet<E>) super.makeFullCollection();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public abstract NavigableSet<E> makeObject();\n\n    /**\n     * Verification extension, will check the order of elements,\n     * the sets should already be verified equal.\n     */\n    @Override\n    public void verify() {\n        super.verify();\n\n        // Check that descending iterator returns elements in order and higher(), lower(),\n        // floor() and ceiling() are consistent\n        final Iterator<E> collIter = getCollection().descendingIterator();\n        final Iterator<E> confIter = getConfirmed().descendingIterator();\n        while (collIter.hasNext()) {\n            final E element = collIter.next();\n            final E confElement = confIter.next();\n            assertEquals(confElement, element, \"Element appears to be out of order.\");\n\n            assertEquals(getConfirmed().higher(element),\n                    getCollection().higher(element), \"Incorrect element returned by higher().\");\n\n            assertEquals(getConfirmed().lower(element),\n                    getCollection().lower(element), \"Incorrect element returned by lower().\");\n\n            assertEquals(getConfirmed().floor(element),\n                    getCollection().floor(element), \"Incorrect element returned by floor().\");\n\n            assertEquals(getConfirmed().ceiling(element),\n                    getCollection().ceiling(element), \"Incorrect element returned by ceiling().\");\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/set/AbstractSetTest.java.AbstractSetTest", "name": "AbstractSetTest", "file_path": "src/test/java/org/apache/commons/collections4/set/AbstractSetTest.java", "superclasses": "", "methods": ["[]AbstractSetTest(String)", "[Set<E>]getCollection()", "[Set<E>]getConfirmed()", "[boolean]isEqualsCheckable()", "[Collection<E>]makeConfirmedCollection()", "[Collection<E>]makeConfirmedFullCollection()", "[Set<E>]makeFullCollection()", "[Set<E>]makeObject()", "[void]verify()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/AbstractSetTest.java.AbstractSetTest.[]AbstractSetTest(String)", "src/test/java/org/apache/commons/collections4/set/AbstractSetTest.java.AbstractSetTest.[Set<E>]getCollection()", "src/test/java/org/apache/commons/collections4/set/AbstractSetTest.java.AbstractSetTest.[Set<E>]getConfirmed()", "src/test/java/org/apache/commons/collections4/set/AbstractSetTest.java.AbstractSetTest.[boolean]isEqualsCheckable()", "src/test/java/org/apache/commons/collections4/set/AbstractSetTest.java.AbstractSetTest.[Collection<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/set/AbstractSetTest.java.AbstractSetTest.[Collection<E>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/set/AbstractSetTest.java.AbstractSetTest.[Set<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/set/AbstractSetTest.java.AbstractSetTest.[Set<E>]makeObject()", "src/test/java/org/apache/commons/collections4/set/AbstractSetTest.java.AbstractSetTest.[void]verify()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract test class for {@link Set} methods and contracts.\n<p>\nSince {@link Set} doesn't stipulate much new behavior that isn't already\nfound in {@link Collection}, this class basically just adds tests for\n{@link Set#equals} and {@link Set#hashCode()} along with an updated\n{@link #verify()} that ensures elements do not appear more than once in the\nset.\n<p>\nTo use, subclass and override the {@link #makeObject()}\nmethod.  You may have to override other protected methods if your\nset is not modifiable, or if your set restricts what kinds of\nelements may be added; see {@link AbstractCollectionTest} for more details.\n", "original_string": "public abstract class AbstractSetTest<E> extends AbstractCollectionTest<E> {\n\n    /**\n     * JUnit constructor.\n     *\n     * @param name  name for test\n     */\n    public AbstractSetTest(final String name) {\n        super(name);\n    }\n\n    /**\n     * Gets the {@link AbstractCollectionTest#collection} fixture, but cast as a Set.\n     */\n    @Override\n    public Set<E> getCollection() {\n        return (Set<E>) super.getCollection();\n    }\n\n    /**\n     * Gets the {@link AbstractCollectionTest#confirmed} fixture, but cast as a Set.\n     */\n    @Override\n    public Set<E> getConfirmed() {\n        return (Set<E>) super.getConfirmed();\n    }\n\n    /**\n     * Sets equals method is defined.\n     */\n    @Override\n    public boolean isEqualsCheckable() {\n        return true;\n    }\n\n    /**\n     * Returns an empty Set for use in modification testing.\n     *\n     * @return a confirmed empty collection\n     */\n    @Override\n    public Collection<E> makeConfirmedCollection() {\n        return new HashSet<>();\n    }\n\n    /**\n     * Returns a full Set for use in modification testing.\n     *\n     * @return a confirmed full collection\n     */\n    @Override\n    public Collection<E> makeConfirmedFullCollection() {\n        final Collection<E> set = makeConfirmedCollection();\n        set.addAll(Arrays.asList(getFullElements()));\n        return set;\n    }\n\n    /**\n     * Makes a full set by first creating an empty set and then adding\n     * all the elements returned by {@link #getFullElements()}.\n     *\n     * Override if your set does not support the add operation.\n     *\n     * @return a full set\n     */\n    @Override\n    public Set<E> makeFullCollection() {\n        final Set<E> set = makeObject();\n        set.addAll(Arrays.asList(getFullElements()));\n        return set;\n    }\n\n    /**\n     * Makes an empty set.  The returned set should have no elements.\n     *\n     * @return an empty set\n     */\n    @Override\n    public abstract Set<E> makeObject();\n\n    /**\n     * Tests {@link Set#equals(Object)}.\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSetEquals() {\n        resetEmpty();\n        assertEquals(getCollection(), getConfirmed(), \"Empty sets should be equal\");\n        verify();\n\n        final Collection<E> set2 = makeConfirmedCollection();\n        set2.add((E) \"foo\");\n        assertFalse(getCollection().equals(set2), \"Empty set shouldn't equal nonempty set\");\n\n        resetFull();\n        assertEquals(getCollection(), getConfirmed(), \"Full sets should be equal\");\n        verify();\n\n        set2.clear();\n        set2.addAll(Arrays.asList(getOtherElements()));\n        assertFalse(getCollection().equals(set2), \"Sets with different contents shouldn't be equal\");\n    }\n\n    /**\n     * Tests {@link Set#hashCode()}.\n     */\n    @Test\n    public void testSetHashCode() {\n        resetEmpty();\n        assertEquals(getCollection().hashCode(), getConfirmed().hashCode(),\n                \"Empty sets have equal hashCodes\");\n\n        resetFull();\n        assertEquals(getCollection().hashCode(), getConfirmed().hashCode(),\n                \"Equal sets have equal hashCodes\");\n    }\n\n    /**\n     * Provides additional verifications for sets.\n     */\n    @Override\n    public void verify() {\n        super.verify();\n\n        assertEquals(getConfirmed(), getCollection(), \"Sets should be equal\");\n        assertEquals(getConfirmed().hashCode(), getCollection().hashCode(),\n                     \"Sets should have equal hashCodes\");\n        final Collection<E> set = makeConfirmedCollection();\n        for (final E element : getCollection()) {\n            assertTrue(set.add(element), \"Set.iterator should only return unique elements\");\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java.AbstractSortedSetTest", "name": "AbstractSortedSetTest", "file_path": "src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java", "superclasses": "", "methods": ["[]AbstractSortedSetTest(String)", "[BulkTest]bulkTestSortedSetHeadSet()", "[BulkTest]bulkTestSortedSetSubSet()", "[BulkTest]bulkTestSortedSetTailSet()", "[SortedSet<E>]getCollection()", "[SortedSet<E>]getConfirmed()", "[E[]]getFullNonNullElements()", "[E[]]getOtherNonNullElements()", "[boolean]isNullSupported()", "[SortedSet<E>]makeConfirmedCollection()", "[SortedSet<E>]makeFullCollection()", "[SortedSet<E>]makeObject()", "[void]verify()"], "method_uris": ["src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java.AbstractSortedSetTest.[]AbstractSortedSetTest(String)", "src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java.AbstractSortedSetTest.[BulkTest]bulkTestSortedSetHeadSet()", "src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java.AbstractSortedSetTest.[BulkTest]bulkTestSortedSetSubSet()", "src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java.AbstractSortedSetTest.[BulkTest]bulkTestSortedSetTailSet()", "src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java.AbstractSortedSetTest.[SortedSet<E>]getCollection()", "src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java.AbstractSortedSetTest.[SortedSet<E>]getConfirmed()", "src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java.AbstractSortedSetTest.[E[]]getFullNonNullElements()", "src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java.AbstractSortedSetTest.[E[]]getOtherNonNullElements()", "src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java.AbstractSortedSetTest.[boolean]isNullSupported()", "src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java.AbstractSortedSetTest.[SortedSet<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java.AbstractSortedSetTest.[SortedSet<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java.AbstractSortedSetTest.[SortedSet<E>]makeObject()", "src/test/java/org/apache/commons/collections4/set/AbstractSortedSetTest.java.AbstractSortedSetTest.[void]verify()"], "overrides": null, "attributes": [{"original_string": "    public class TestSortedSetSubSet extends AbstractSortedSetTest<E> {\n\n        static final int TYPE_SUBSET = 0;\n        static final int TYPE_TAILSET = 1;\n        static final int TYPE_HEADSET = 2;\n        private final int type;\n        private int lowBound;\n\n        private int highBound;\n\n        private final E[] fullElements;\n\n        private final E[] otherElements;\n        @SuppressWarnings(\"unchecked\")\n        public TestSortedSetSubSet(final int bound, final boolean head) {\n            super(\"TestSortedSetSubSet\");\n            if (head) {\n                //System.out.println(\"HEADSET\");\n                this.type = TYPE_HEADSET;\n                this.highBound = bound;\n                this.fullElements = (E[]) new Object[bound];\n                System.arraycopy(AbstractSortedSetTest.this.getFullElements(), 0, fullElements, 0, bound);\n                this.otherElements = (E[]) new Object[bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractSortedSetTest.this.getOtherElements(), 0, otherElements, 0, bound - 1);\n                //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n                //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n            } else {\n                //System.out.println(\"TAILSET\");\n                this.type = TYPE_TAILSET;\n                this.lowBound = bound;\n                final Object[] allElements = AbstractSortedSetTest.this.getFullElements();\n                //System.out.println(\"bound = \"+bound +\"::length=\"+allElements.length);\n                this.fullElements = (E[]) new Object[allElements.length - bound];\n                System.arraycopy(allElements, bound, fullElements, 0, allElements.length - bound);\n                this.otherElements = (E[]) new Object[allElements.length - bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractSortedSetTest.this.getOtherElements(), bound, otherElements, 0, allElements.length - bound - 1);\n                //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n                //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n                //resetFull();\n                //System.out.println(collection);\n                //System.out.println(confirmed);\n\n            }\n\n        } //type\n        @SuppressWarnings(\"unchecked\")\n        public TestSortedSetSubSet(final int loBound, final int hiBound) {\n            super(\"TestSortedSetSubSet\");\n            //System.out.println(\"SUBSET\");\n            this.type = TYPE_SUBSET;\n            this.lowBound = loBound;\n            this.highBound = hiBound;\n            final int length = hiBound - loBound;\n            //System.out.println(\"Low=\" + loBound + \"::High=\" + hiBound + \"::Length=\" + length);\n            this.fullElements = (E[]) new Object[length];\n            System.arraycopy(AbstractSortedSetTest.this.getFullElements(), loBound, fullElements, 0, length);\n            this.otherElements = (E[]) new Object[length - 1];\n            System.arraycopy(//src src_pos dst dst_pos length\n                AbstractSortedSetTest.this.getOtherElements(), loBound, otherElements, 0, length - 1);\n\n            //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n            //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n\n        }\n        @Override\n        public BulkTest bulkTestSortedSetHeadSet() {\n            return null;  // prevent infinite recursion\n        }\n\n        @Override\n        public BulkTest bulkTestSortedSetSubSet() {\n            return null;  // prevent infinite recursion\n        }\n        @Override\n        public BulkTest bulkTestSortedSetTailSet() {\n            return null;  // prevent infinite recursion\n        }\n\n        @Override\n        public E[] getFullElements() {\n            return fullElements;\n        }\n\n        @Override\n        public E[] getOtherElements() {\n            return otherElements;\n        }\n\n        private SortedSet<E> getSubSet(final SortedSet<E> set) {\n            final E[] elements = AbstractSortedSetTest.this.getFullElements();\n            switch (type) {\n            case TYPE_SUBSET :\n                return set.subSet(elements[lowBound], elements[highBound]);\n            case TYPE_HEADSET :\n                return set.headSet(elements[highBound]);\n            case TYPE_TAILSET :\n                return set.tailSet(elements[lowBound]);\n            default :\n                return null;\n            }\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return AbstractSortedSetTest.this.isAddSupported();\n        }\n\n        @Override\n        public boolean isFailFastSupported() {\n            return AbstractSortedSetTest.this.isFailFastSupported();\n        }\n        @Override\n        public boolean isNullSupported() {\n            return AbstractSortedSetTest.this.isNullSupported();\n        }\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractSortedSetTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n        @Override\n        public SortedSet<E> makeFullCollection() {\n            return getSubSet(AbstractSortedSetTest.this.makeFullCollection());\n        }\n        @Override\n        public SortedSet<E> makeObject() {\n            return getSubSet(AbstractSortedSetTest.this.makeObject());\n        }\n\n    }", "definition": "    public class TestSortedSetSubSet extends AbstractSortedSetTest<E>", "class_docstring": "", "name": "TestSortedSetSubSet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [{"attribute_expression": "static final int TYPE_SUBSET = 0;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "TYPE_SUBSET = 0", "syntax_pass": true}, {"attribute_expression": "static final int TYPE_TAILSET = 1;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "TYPE_TAILSET = 1", "syntax_pass": true}, {"attribute_expression": "static final int TYPE_HEADSET = 2;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "TYPE_HEADSET = 2", "syntax_pass": true}, {"attribute_expression": "private final int type;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "type", "syntax_pass": true}, {"attribute_expression": "private int lowBound;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "lowBound", "syntax_pass": true}, {"attribute_expression": "private int highBound;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "highBound", "syntax_pass": true}, {"attribute_expression": "private final E[] fullElements;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "E[]", "name": "fullElements", "syntax_pass": true}, {"attribute_expression": "private final E[] otherElements;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "E[]", "name": "otherElements", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        public TestSortedSetSubSet(final int bound, final boolean head) {\n            super(\"TestSortedSetSubSet\");\n            if (head) {\n                //System.out.println(\"HEADSET\");\n                this.type = TYPE_HEADSET;\n                this.highBound = bound;\n                this.fullElements = (E[]) new Object[bound];\n                System.arraycopy(AbstractSortedSetTest.this.getFullElements(), 0, fullElements, 0, bound);\n                this.otherElements = (E[]) new Object[bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractSortedSetTest.this.getOtherElements(), 0, otherElements, 0, bound - 1);\n                //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n                //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n            } else {\n                //System.out.println(\"TAILSET\");\n                this.type = TYPE_TAILSET;\n                this.lowBound = bound;\n                final Object[] allElements = AbstractSortedSetTest.this.getFullElements();\n                //System.out.println(\"bound = \"+bound +\"::length=\"+allElements.length);\n                this.fullElements = (E[]) new Object[allElements.length - bound];\n                System.arraycopy(allElements, bound, fullElements, 0, allElements.length - bound);\n                this.otherElements = (E[]) new Object[allElements.length - bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractSortedSetTest.this.getOtherElements(), bound, otherElements, 0, allElements.length - bound - 1);\n                //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n                //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n                //resetFull();\n                //System.out.println(collection);\n                //System.out.println(confirmed);\n\n            }\n\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "", "classes": []}, "name": "TestSortedSetSubSet", "params": [{"name": "bound", "type": "int"}, {"name": "head", "type": "boolean"}], "body": "                                                                        {\n            super(\"TestSortedSetSubSet\");\n            if (head) {\n                //System.out.println(\"HEADSET\");\n                this.type = TYPE_HEADSET;\n                this.highBound = bound;\n                this.fullElements = (E[]) new Object[bound];\n                System.arraycopy(AbstractSortedSetTest.this.getFullElements(), 0, fullElements, 0, bound);\n                this.otherElements = (E[]) new Object[bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractSortedSetTest.this.getOtherElements(), 0, otherElements, 0, bound - 1);\n                //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n                //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n            } else {\n                //System.out.println(\"TAILSET\");\n                this.type = TYPE_TAILSET;\n                this.lowBound = bound;\n                final Object[] allElements = AbstractSortedSetTest.this.getFullElements();\n                //System.out.println(\"bound = \"+bound +\"::length=\"+allElements.length);\n                this.fullElements = (E[]) new Object[allElements.length - bound];\n                System.arraycopy(allElements, bound, fullElements, 0, allElements.length - bound);\n                this.otherElements = (E[]) new Object[allElements.length - bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractSortedSetTest.this.getOtherElements(), bound, otherElements, 0, allElements.length - bound - 1);\n                //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n                //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n                //resetFull();\n                //System.out.println(collection);\n                //System.out.println(confirmed);\n\n            }\n\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        public TestSortedSetSubSet(final int bound, final boolean head)"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        public TestSortedSetSubSet(final int loBound, final int hiBound) {\n            super(\"TestSortedSetSubSet\");\n            //System.out.println(\"SUBSET\");\n            this.type = TYPE_SUBSET;\n            this.lowBound = loBound;\n            this.highBound = hiBound;\n            final int length = hiBound - loBound;\n            //System.out.println(\"Low=\" + loBound + \"::High=\" + hiBound + \"::Length=\" + length);\n            this.fullElements = (E[]) new Object[length];\n            System.arraycopy(AbstractSortedSetTest.this.getFullElements(), loBound, fullElements, 0, length);\n            this.otherElements = (E[]) new Object[length - 1];\n            System.arraycopy(//src src_pos dst dst_pos length\n                AbstractSortedSetTest.this.getOtherElements(), loBound, otherElements, 0, length - 1);\n\n            //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n            //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n\n        }", "docstring": "type", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "", "classes": []}, "name": "TestSortedSetSubSet", "params": [{"name": "loBound", "type": "int"}, {"name": "hiBound", "type": "int"}], "body": "                                                                         {\n            super(\"TestSortedSetSubSet\");\n            //System.out.println(\"SUBSET\");\n            this.type = TYPE_SUBSET;\n            this.lowBound = loBound;\n            this.highBound = hiBound;\n            final int length = hiBound - loBound;\n            //System.out.println(\"Low=\" + loBound + \"::High=\" + hiBound + \"::Length=\" + length);\n            this.fullElements = (E[]) new Object[length];\n            System.arraycopy(AbstractSortedSetTest.this.getFullElements(), loBound, fullElements, 0, length);\n            this.otherElements = (E[]) new Object[length - 1];\n            System.arraycopy(//src src_pos dst dst_pos length\n                AbstractSortedSetTest.this.getOtherElements(), loBound, otherElements, 0, length - 1);\n\n            //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n            //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        public TestSortedSetSubSet(final int loBound, final int hiBound)"}, {"syntax_pass": true, "original_string": "        @Override\n        public BulkTest bulkTestSortedSetHeadSet() {\n            return null;  // prevent infinite recursion\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BulkTest", "classes": []}, "name": "bulkTestSortedSetHeadSet", "params": [], "body": "                                                   {\n            return null;  // prevent infinite recursion\n        }", "signature": "@Override\n        public BulkTest bulkTestSortedSetHeadSet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public BulkTest bulkTestSortedSetSubSet() {\n            return null;  // prevent infinite recursion\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BulkTest", "classes": []}, "name": "bulkTestSortedSetSubSet", "params": [], "body": "                                                  {\n            return null;  // prevent infinite recursion\n        }", "signature": "@Override\n        public BulkTest bulkTestSortedSetSubSet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public BulkTest bulkTestSortedSetTailSet() {\n            return null;  // prevent infinite recursion\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "BulkTest", "classes": []}, "name": "bulkTestSortedSetTailSet", "params": [], "body": "                                                   {\n            return null;  // prevent infinite recursion\n        }", "signature": "@Override\n        public BulkTest bulkTestSortedSetTailSet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E[] getFullElements() {\n            return fullElements;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                     {\n            return fullElements;\n        }", "signature": "@Override\n        public E[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E[] getOtherElements() {\n            return otherElements;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E[]", "classes": []}, "name": "getOtherElements", "params": [], "body": "                                      {\n            return otherElements;\n        }", "signature": "@Override\n        public E[] getOtherElements()"}, {"syntax_pass": true, "original_string": "        private SortedSet<E> getSubSet(final SortedSet<E> set) {\n            final E[] elements = AbstractSortedSetTest.this.getFullElements();\n            switch (type) {\n            case TYPE_SUBSET :\n                return set.subSet(elements[lowBound], elements[highBound]);\n            case TYPE_HEADSET :\n                return set.headSet(elements[highBound]);\n            case TYPE_TAILSET :\n                return set.tailSet(elements[lowBound]);\n            default :\n                return null;\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "SortedSet<E>", "classes": []}, "name": "getSubSet", "params": [{"name": "set", "type": "SortedSet<E>"}], "body": "                                                               {\n            final E[] elements = AbstractSortedSetTest.this.getFullElements();\n            switch (type) {\n            case TYPE_SUBSET :\n                return set.subSet(elements[lowBound], elements[highBound]);\n            case TYPE_HEADSET :\n                return set.headSet(elements[highBound]);\n            case TYPE_TAILSET :\n                return set.tailSet(elements[lowBound]);\n            default :\n                return null;\n            }\n        }", "signature": "private SortedSet<E> getSubSet(final SortedSet<E> set)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            return AbstractSortedSetTest.this.isAddSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            return AbstractSortedSetTest.this.isAddSupported();\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isFailFastSupported() {\n            return AbstractSortedSetTest.this.isFailFastSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isFailFastSupported", "params": [], "body": "                                             {\n            return AbstractSortedSetTest.this.isFailFastSupported();\n        }", "signature": "@Override\n        public boolean isFailFastSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isNullSupported() {\n            return AbstractSortedSetTest.this.isNullSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNullSupported", "params": [], "body": "                                         {\n            return AbstractSortedSetTest.this.isNullSupported();\n        }", "signature": "@Override\n        public boolean isNullSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return AbstractSortedSetTest.this.isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return AbstractSortedSetTest.this.isRemoveSupported();\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public SortedSet<E> makeFullCollection() {\n            return getSubSet(AbstractSortedSetTest.this.makeFullCollection());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedSet<E>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                                 {\n            return getSubSet(AbstractSortedSetTest.this.makeFullCollection());\n        }", "signature": "@Override\n        public SortedSet<E> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public SortedSet<E> makeObject() {\n            return getSubSet(AbstractSortedSetTest.this.makeObject());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedSet<E>", "classes": []}, "name": "makeObject", "params": [], "body": "                                         {\n            return getSubSet(AbstractSortedSetTest.this.makeObject());\n        }", "signature": "@Override\n        public SortedSet<E> makeObject()"}]}], "class_docstring": "\nAbstract test class for {@link SortedSet} methods and contracts.\n<p>\nTo use, subclass and override the {@link #makeObject()}\nmethod.  You may have to override other protected methods if your\nset is not modifiable, or if your set restricts what kinds of\nelements may be added; see {@link AbstractSetTest} for more details.\n", "original_string": "public abstract class AbstractSortedSetTest<E> extends AbstractSetTest<E> {\n\n    public class TestSortedSetSubSet extends AbstractSortedSetTest<E> {\n\n        static final int TYPE_SUBSET = 0;\n        static final int TYPE_TAILSET = 1;\n        static final int TYPE_HEADSET = 2;\n        private final int type;\n        private int lowBound;\n\n        private int highBound;\n\n        private final E[] fullElements;\n\n        private final E[] otherElements;\n        @SuppressWarnings(\"unchecked\")\n        public TestSortedSetSubSet(final int bound, final boolean head) {\n            super(\"TestSortedSetSubSet\");\n            if (head) {\n                //System.out.println(\"HEADSET\");\n                this.type = TYPE_HEADSET;\n                this.highBound = bound;\n                this.fullElements = (E[]) new Object[bound];\n                System.arraycopy(AbstractSortedSetTest.this.getFullElements(), 0, fullElements, 0, bound);\n                this.otherElements = (E[]) new Object[bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractSortedSetTest.this.getOtherElements(), 0, otherElements, 0, bound - 1);\n                //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n                //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n            } else {\n                //System.out.println(\"TAILSET\");\n                this.type = TYPE_TAILSET;\n                this.lowBound = bound;\n                final Object[] allElements = AbstractSortedSetTest.this.getFullElements();\n                //System.out.println(\"bound = \"+bound +\"::length=\"+allElements.length);\n                this.fullElements = (E[]) new Object[allElements.length - bound];\n                System.arraycopy(allElements, bound, fullElements, 0, allElements.length - bound);\n                this.otherElements = (E[]) new Object[allElements.length - bound - 1];\n                System.arraycopy(//src src_pos dst dst_pos length\n                    AbstractSortedSetTest.this.getOtherElements(), bound, otherElements, 0, allElements.length - bound - 1);\n                //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n                //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n                //resetFull();\n                //System.out.println(collection);\n                //System.out.println(confirmed);\n\n            }\n\n        } //type\n        @SuppressWarnings(\"unchecked\")\n        public TestSortedSetSubSet(final int loBound, final int hiBound) {\n            super(\"TestSortedSetSubSet\");\n            //System.out.println(\"SUBSET\");\n            this.type = TYPE_SUBSET;\n            this.lowBound = loBound;\n            this.highBound = hiBound;\n            final int length = hiBound - loBound;\n            //System.out.println(\"Low=\" + loBound + \"::High=\" + hiBound + \"::Length=\" + length);\n            this.fullElements = (E[]) new Object[length];\n            System.arraycopy(AbstractSortedSetTest.this.getFullElements(), loBound, fullElements, 0, length);\n            this.otherElements = (E[]) new Object[length - 1];\n            System.arraycopy(//src src_pos dst dst_pos length\n                AbstractSortedSetTest.this.getOtherElements(), loBound, otherElements, 0, length - 1);\n\n            //System.out.println(new TreeSet(Arrays.asList(m_FullElements)));\n            //System.out.println(new TreeSet(Arrays.asList(m_OtherElements)));\n\n        }\n        @Override\n        public BulkTest bulkTestSortedSetHeadSet() {\n            return null;  // prevent infinite recursion\n        }\n\n        @Override\n        public BulkTest bulkTestSortedSetSubSet() {\n            return null;  // prevent infinite recursion\n        }\n        @Override\n        public BulkTest bulkTestSortedSetTailSet() {\n            return null;  // prevent infinite recursion\n        }\n\n        @Override\n        public E[] getFullElements() {\n            return fullElements;\n        }\n\n        @Override\n        public E[] getOtherElements() {\n            return otherElements;\n        }\n\n        private SortedSet<E> getSubSet(final SortedSet<E> set) {\n            final E[] elements = AbstractSortedSetTest.this.getFullElements();\n            switch (type) {\n            case TYPE_SUBSET :\n                return set.subSet(elements[lowBound], elements[highBound]);\n            case TYPE_HEADSET :\n                return set.headSet(elements[highBound]);\n            case TYPE_TAILSET :\n                return set.tailSet(elements[lowBound]);\n            default :\n                return null;\n            }\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return AbstractSortedSetTest.this.isAddSupported();\n        }\n\n        @Override\n        public boolean isFailFastSupported() {\n            return AbstractSortedSetTest.this.isFailFastSupported();\n        }\n        @Override\n        public boolean isNullSupported() {\n            return AbstractSortedSetTest.this.isNullSupported();\n        }\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractSortedSetTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n        @Override\n        public SortedSet<E> makeFullCollection() {\n            return getSubSet(AbstractSortedSetTest.this.makeFullCollection());\n        }\n        @Override\n        public SortedSet<E> makeObject() {\n            return getSubSet(AbstractSortedSetTest.this.makeObject());\n        }\n\n    }\n\n    /**\n     * JUnit constructor.\n     *\n     * @param name  name for test\n     */\n    public AbstractSortedSetTest(final String name) {\n        super(name);\n    }\n\n    /**\n     * Bulk test {@link SortedSet#headSet(Object)}.  This method runs through all of\n     * the tests in {@link AbstractSortedSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the set and the other collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing a headset.\n     */\n    public BulkTest bulkTestSortedSetHeadSet() {\n        final int length = getFullElements().length;\n\n        final int loBound = length / 3;\n        final int hiBound = loBound * 2;\n        return new TestSortedSetSubSet(hiBound, true);\n    }\n\n    /**\n     * Bulk test {@link SortedSet#subSet(Object, Object)}.  This method runs through all of\n     * the tests in {@link AbstractSortedSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the set and the other collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing a subset.\n     */\n    public BulkTest bulkTestSortedSetSubSet() {\n        final int length = getFullElements().length;\n\n        final int loBound = length / 3;\n        final int hiBound = loBound * 2;\n        return new TestSortedSetSubSet(loBound, hiBound);\n\n    }\n\n    /**\n     * Bulk test {@link SortedSet#tailSet(Object)}.  This method runs through all of\n     * the tests in {@link AbstractSortedSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the set and the other collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing a tailset.\n     */\n    public BulkTest bulkTestSortedSetTailSet() {\n        final int length = getFullElements().length;\n        final int loBound = length / 3;\n        return new TestSortedSetSubSet(loBound, false);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SortedSet<E> getCollection() {\n        return (SortedSet<E>) super.getCollection();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SortedSet<E> getConfirmed() {\n        return (SortedSet<E>) super.getConfirmed();\n    }\n\n    /**\n     * Override to return comparable objects.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public E[] getFullNonNullElements() {\n        final Object[] elements = new Object[30];\n\n        for (int i = 0; i < 30; i++) {\n            elements[i] = Integer.valueOf(i + i + 1);\n        }\n        return (E[]) elements;\n    }\n\n    /**\n     * Override to return comparable objects.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public E[] getOtherNonNullElements() {\n        final Object[] elements = new Object[30];\n        for (int i = 0; i < 30; i++) {\n            elements[i] = Integer.valueOf(i + i + 2);\n        }\n        return (E[]) elements;\n    }\n\n    /**\n     * Overridden because SortedSets don't allow null elements (normally).\n     * @return false\n     */\n    @Override\n    public boolean isNullSupported() {\n        return false;\n    }\n\n    /**\n     * Returns an empty {@link TreeSet} for use in modification testing.\n     *\n     * @return a confirmed empty collection\n     */\n    @Override\n    public SortedSet<E> makeConfirmedCollection() {\n        return new TreeSet<>();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SortedSet<E> makeFullCollection() {\n        return (SortedSet<E>) super.makeFullCollection();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public abstract SortedSet<E> makeObject();\n\n    /**\n     * Verification extension, will check the order of elements,\n     * the sets should already be verified equal.\n     */\n    @Override\n    public void verify() {\n        super.verify();\n\n        // Check that iterator returns elements in order and first() and last()\n        // are consistent\n        final Iterator<E> collIter = getCollection().iterator();\n        final Iterator<E> confIter = getConfirmed().iterator();\n        E first = null;\n        E last = null;\n        while (collIter.hasNext()) {\n            if (first == null) {\n                first = collIter.next();\n                last = first;\n            } else {\n                last = collIter.next();\n            }\n            assertEquals(last, confIter.next(), \"Element appears to be out of order.\");\n        }\n        if (!getCollection().isEmpty()) {\n            assertEquals(first,\n                getCollection().first(), \"Incorrect element returned by first().\");\n            assertEquals(last,\n                getCollection().last(), \"Incorrect element returned by last().\");\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/list/AbstractLinkedListTest.java.AbstractLinkedListTest", "name": "AbstractLinkedListTest", "file_path": "src/test/java/org/apache/commons/collections4/list/AbstractLinkedListTest.java", "superclasses": "", "methods": ["[]AbstractLinkedListTest(String)", "[void]checkNodes()", "[AbstractLinkedList<E>]getCollection()"], "method_uris": ["src/test/java/org/apache/commons/collections4/list/AbstractLinkedListTest.java.AbstractLinkedListTest.[]AbstractLinkedListTest(String)", "src/test/java/org/apache/commons/collections4/list/AbstractLinkedListTest.java.AbstractLinkedListTest.[void]checkNodes()", "src/test/java/org/apache/commons/collections4/list/AbstractLinkedListTest.java.AbstractLinkedListTest.[AbstractLinkedList<E>]getCollection()"], "overrides": null, "attributes": [], "class_docstring": "\nTest case for {@link AbstractLinkedList}.\n", "original_string": "public abstract class AbstractLinkedListTest<E> extends AbstractListTest<E> {\n\n    public AbstractLinkedListTest(final String testName) {\n        super(testName);\n    }\n\n    protected void checkNodes() {\n        final AbstractLinkedList<E> list = getCollection();\n        for (int i = 0; i < list.size; i++) {\n            assertEquals(list.getNode(i, false).next, list.getNode(i + 1, true));\n            if (i < list.size - 1) {\n                assertEquals(list.getNode(i + 1, false).previous, list.getNode(i, false));\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public AbstractLinkedList<E> getCollection() {\n        return (AbstractLinkedList<E>) super.getCollection();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddNodeAfter() {\n        resetEmpty();\n        final AbstractLinkedList<E> list = getCollection();\n        if (!isAddSupported()) {\n            try {\n                list.addFirst(null);\n            } catch (final UnsupportedOperationException ex) {\n            }\n        }\n\n        list.addFirst((E) \"value1\");\n        list.addNodeAfter(list.getNode(0, false), (E) \"value2\");\n        assertEquals(\"value1\", list.getFirst());\n        assertEquals(\"value2\", list.getLast());\n        list.removeFirst();\n        checkNodes();\n        list.addNodeAfter(list.getNode(0, false), (E) \"value3\");\n        checkNodes();\n        assertEquals(\"value2\", list.getFirst());\n        assertEquals(\"value3\", list.getLast());\n        list.addNodeAfter(list.getNode(0, false), (E) \"value4\");\n        checkNodes();\n        assertEquals(\"value2\", list.getFirst());\n        assertEquals(\"value3\", list.getLast());\n        assertEquals(\"value4\", list.get(1));\n        list.addNodeAfter(list.getNode(2, false), (E) \"value5\");\n        checkNodes();\n        assertEquals(\"value2\", list.getFirst());\n        assertEquals(\"value4\", list.get(1));\n        assertEquals(\"value3\", list.get(2));\n        assertEquals(\"value5\", list.getLast());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testGetNode() {\n        resetEmpty();\n        final AbstractLinkedList<E> list = getCollection();\n        // get marker\n        assertEquals(list.getNode(0, true).previous, list.getNode(0, true).next);\n        assertThrows(IndexOutOfBoundsException.class, () -> list.getNode(0, false), \"Expecting IndexOutOfBoundsException.\");\n        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n        checkNodes();\n        list.addFirst((E) \"value0\");\n        checkNodes();\n        list.removeNode(list.getNode(1, false));\n        checkNodes();\n        assertThrows(IndexOutOfBoundsException.class, () -> list.getNode(2, false), \"Expecting IndexOutOfBoundsException.\");\n        assertThrows(IndexOutOfBoundsException.class, () -> list.getNode(-1, false), \"Expecting IndexOutOfBoundsException.\");\n        assertThrows(IndexOutOfBoundsException.class, () -> list.getNode(3, true), \"Expecting IndexOutOfBoundsException.\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveFirst() {\n        resetEmpty();\n        final AbstractLinkedList<E> list = getCollection();\n        if (!isRemoveSupported()) {\n            try {\n                list.removeFirst();\n            } catch (final UnsupportedOperationException ex) {\n            }\n        }\n\n        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n        assertEquals(\"value1\", list.removeFirst());\n        checkNodes();\n        list.addLast((E) \"value3\");\n        checkNodes();\n        assertEquals(\"value2\", list.removeFirst());\n        assertEquals(\"value3\", list.removeFirst());\n        checkNodes();\n        list.addLast((E) \"value4\");\n        checkNodes();\n        assertEquals(\"value4\", list.removeFirst());\n        checkNodes();\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveLast() {\n        resetEmpty();\n        final AbstractLinkedList<E> list = getCollection();\n        if (!isRemoveSupported()) {\n            try {\n                list.removeLast();\n            } catch (final UnsupportedOperationException ex) {\n            }\n        }\n\n        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n        assertEquals(\"value2\", list.removeLast());\n        list.addFirst((E) \"value3\");\n        checkNodes();\n        assertEquals(\"value1\", list.removeLast());\n        assertEquals(\"value3\", list.removeLast());\n        list.addFirst((E) \"value4\");\n        checkNodes();\n        assertEquals(\"value4\", list.removeFirst());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveNode() {\n        resetEmpty();\n        if (!isAddSupported() || !isRemoveSupported()) {\n            return;\n        }\n        final AbstractLinkedList<E> list = getCollection();\n\n        list.addAll(Arrays.asList((E[]) new String[] { \"value1\", \"value2\" }));\n        list.removeNode(list.getNode(0, false));\n        checkNodes();\n        assertEquals(\"value2\", list.getFirst());\n        assertEquals(\"value2\", list.getLast());\n        list.addFirst((E) \"value1\");\n        list.addFirst((E) \"value0\");\n        checkNodes();\n        list.removeNode(list.getNode(1, false));\n        assertEquals(\"value0\", list.getFirst());\n        assertEquals(\"value2\", list.getLast());\n        checkNodes();\n        list.removeNode(list.getNode(1, false));\n        assertEquals(\"value0\", list.getFirst());\n        assertEquals(\"value0\", list.getLast());\n        checkNodes();\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest", "name": "AbstractListTest", "file_path": "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java", "superclasses": "", "methods": ["[]AbstractListTest(String)", "[void]backwardTest(ListIterator<E>,int)", "[BulkTest]bulkTestListIterator()", "[BulkTest]bulkTestSubList()", "[void]failFastAll(List<E>)", "[void]failFastMethod(List<E>,Method)", "[void]forwardTest(ListIterator<E>,int)", "[List<E>]getCollection()", "[List<E>]getConfirmed()", "[boolean]isEqualsCheckable()", "[boolean]isSetSupported()", "[Collection<E>]makeConfirmedCollection()", "[Collection<E>]makeConfirmedFullCollection()", "[List<E>]makeFullCollection()", "[List<E>]makeObject()", "[void]verify()"], "method_uris": ["src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[]AbstractListTest(String)", "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[void]backwardTest(ListIterator<E>,int)", "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[BulkTest]bulkTestListIterator()", "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[BulkTest]bulkTestSubList()", "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[void]failFastAll(List<E>)", "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[void]failFastMethod(List<E>,Method)", "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[void]forwardTest(ListIterator<E>,int)", "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[List<E>]getCollection()", "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[List<E>]getConfirmed()", "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[boolean]isEqualsCheckable()", "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[boolean]isSetSupported()", "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[Collection<E>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[Collection<E>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[List<E>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[List<E>]makeObject()", "src/test/java/org/apache/commons/collections4/list/AbstractListTest.java.AbstractListTest.[void]verify()"], "overrides": null, "attributes": [{"original_string": "    public static class BulkTestSubList<E> extends AbstractListTest<E> {\n\n        private final AbstractListTest<E> outer;\n\n        public BulkTestSubList(final AbstractListTest<E> outer) {\n            super(StringUtils.EMPTY);\n            this.outer = outer;\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public E[] getFullElements() {\n            final List<E> l = Arrays.asList(outer.getFullElements());\n            return (E[]) l.subList(3, l.size() - 3).toArray();\n        }\n\n        @Override\n        public E[] getOtherElements() {\n            return outer.getOtherElements();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return outer.isAddSupported();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return outer.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isSetSupported() {\n            return outer.isSetSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public List<E> makeFullCollection() {\n            final int size = getFullElements().length;\n            return outer.makeFullCollection().subList(3, size - 3);\n        }\n\n        @Override\n        public List<E> makeObject() {\n            return outer.makeFullCollection().subList(4, 4);\n        }\n\n        @Override\n        public void resetEmpty() {\n            outer.resetFull();\n            setCollection(outer.getCollection().subList(4, 4));\n            setConfirmed(outer.getConfirmed().subList(4, 4));\n        }\n\n        @Override\n        public void resetFull() {\n            outer.resetFull();\n            final int size = outer.getConfirmed().size();\n            setCollection(outer.getCollection().subList(3, size - 3));\n            setConfirmed(outer.getConfirmed().subList(3, size - 3));\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            outer.verify();\n        }\n    }", "definition": "    public static class BulkTestSubList<E> extends AbstractListTest<E>", "class_docstring": "", "name": "BulkTestSubList", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private final AbstractListTest<E> outer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractListTest<E>", "name": "outer", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public BulkTestSubList(final AbstractListTest<E> outer) {\n            super(StringUtils.EMPTY);\n            this.outer = outer;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BulkTestSubList", "params": [{"name": "outer", "type": "AbstractListTest<E>"}], "body": "                                                                {\n            super(StringUtils.EMPTY);\n            this.outer = outer;\n        }", "signature": "public BulkTestSubList(final AbstractListTest<E> outer)"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public E[] getFullElements() {\n            final List<E> l = Arrays.asList(outer.getFullElements());\n            return (E[]) l.subList(3, l.size() - 3).toArray();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "E[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                     {\n            final List<E> l = Arrays.asList(outer.getFullElements());\n            return (E[]) l.subList(3, l.size() - 3).toArray();\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public E[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E[] getOtherElements() {\n            return outer.getOtherElements();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E[]", "classes": []}, "name": "getOtherElements", "params": [], "body": "                                      {\n            return outer.getOtherElements();\n        }", "signature": "@Override\n        public E[] getOtherElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            return outer.isAddSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            return outer.isAddSupported();\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return outer.isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return outer.isRemoveSupported();\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isSetSupported() {\n            return outer.isSetSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isSetSupported", "params": [], "body": "                                        {\n            return outer.isSetSupported();\n        }", "signature": "@Override\n        public boolean isSetSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<E> makeFullCollection() {\n            final int size = getFullElements().length;\n            return outer.makeFullCollection().subList(3, size - 3);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<E>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                            {\n            final int size = getFullElements().length;\n            return outer.makeFullCollection().subList(3, size - 3);\n        }", "signature": "@Override\n        public List<E> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<E> makeObject() {\n            return outer.makeFullCollection().subList(4, 4);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<E>", "classes": []}, "name": "makeObject", "params": [], "body": "                                    {\n            return outer.makeFullCollection().subList(4, 4);\n        }", "signature": "@Override\n        public List<E> makeObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetEmpty() {\n            outer.resetFull();\n            setCollection(outer.getCollection().subList(4, 4));\n            setConfirmed(outer.getConfirmed().subList(4, 4));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetEmpty", "params": [], "body": "                                 {\n            outer.resetFull();\n            setCollection(outer.getCollection().subList(4, 4));\n            setConfirmed(outer.getConfirmed().subList(4, 4));\n        }", "signature": "@Override\n        public void resetEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetFull() {\n            outer.resetFull();\n            final int size = outer.getConfirmed().size();\n            setCollection(outer.getCollection().subList(3, size - 3));\n            setConfirmed(outer.getConfirmed().subList(3, size - 3));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetFull", "params": [], "body": "                                {\n            outer.resetFull();\n            final int size = outer.getConfirmed().size();\n            setCollection(outer.getCollection().subList(3, size - 3));\n            setConfirmed(outer.getConfirmed().subList(3, size - 3));\n        }", "signature": "@Override\n        public void resetFull()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void verify() {\n            super.verify();\n            outer.verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "verify", "params": [], "body": "                             {\n            super.verify();\n            outer.verify();\n        }", "signature": "@Override\n        public void verify()"}]}, {"original_string": "    public class TestListIterator extends AbstractListIteratorTest<E> {\n        public TestListIterator() {\n            super(\"TestListIterator\");\n        }\n\n        @Override\n        public E addSetValue() {\n            return getOtherElements()[0];\n        }\n\n        @Override\n        public ListIterator<E> makeEmptyIterator() {\n            resetEmpty();\n            return AbstractListTest.this.getCollection().listIterator();\n        }\n\n        @Override\n        public ListIterator<E> makeObject() {\n            resetFull();\n            return AbstractListTest.this.getCollection().listIterator();\n        }\n\n        @Override\n        public boolean supportsAdd() {\n            return isAddSupported();\n        }\n\n        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }\n\n        @Override\n        public boolean supportsSet() {\n            return AbstractListTest.this.isSetSupported();\n        }\n    }", "definition": "    public class TestListIterator extends AbstractListIteratorTest<E>", "class_docstring": "", "name": "TestListIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestListIterator() {\n            super(\"TestListIterator\");\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestListIterator", "params": [], "body": "                                  {\n            super(\"TestListIterator\");\n        }", "signature": "public TestListIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E addSetValue() {\n            return getOtherElements()[0];\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "addSetValue", "params": [], "body": "                               {\n            return getOtherElements()[0];\n        }", "signature": "@Override\n        public E addSetValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public ListIterator<E> makeEmptyIterator() {\n            resetEmpty();\n            return AbstractListTest.this.getCollection().listIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListIterator<E>", "classes": []}, "name": "makeEmptyIterator", "params": [], "body": "                                                   {\n            resetEmpty();\n            return AbstractListTest.this.getCollection().listIterator();\n        }", "signature": "@Override\n        public ListIterator<E> makeEmptyIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public ListIterator<E> makeObject() {\n            resetFull();\n            return AbstractListTest.this.getCollection().listIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListIterator<E>", "classes": []}, "name": "makeObject", "params": [], "body": "                                            {\n            resetFull();\n            return AbstractListTest.this.getCollection().listIterator();\n        }", "signature": "@Override\n        public ListIterator<E> makeObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean supportsAdd() {\n            return isAddSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "supportsAdd", "params": [], "body": "                                     {\n            return isAddSupported();\n        }", "signature": "@Override\n        public boolean supportsAdd()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "supportsRemove", "params": [], "body": "                                        {\n            return isRemoveSupported();\n        }", "signature": "@Override\n        public boolean supportsRemove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean supportsSet() {\n            return AbstractListTest.this.isSetSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "supportsSet", "params": [], "body": "                                     {\n            return AbstractListTest.this.isSetSupported();\n        }", "signature": "@Override\n        public boolean supportsSet()"}]}], "class_docstring": "\nAbstract test class for {@link java.util.List} methods and contracts.\n<p>\nTo use, simply extend this class, and implement\nthe {@link #makeObject} method.\n</p>\n<p>\nIf your {@link List} fails one of these tests by design,\nyou may still use this base set of cases.  Simply override the\ntest case (method) your {@link List} fails or override one of the\nprotected methods from AbstractCollectionTest.\n</p>\n\n@param <E> the type of elements returned by this iterator\n", "original_string": "public abstract class AbstractListTest<E> extends AbstractCollectionTest<E> {\n\n    public static class BulkTestSubList<E> extends AbstractListTest<E> {\n\n        private final AbstractListTest<E> outer;\n\n        public BulkTestSubList(final AbstractListTest<E> outer) {\n            super(StringUtils.EMPTY);\n            this.outer = outer;\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public E[] getFullElements() {\n            final List<E> l = Arrays.asList(outer.getFullElements());\n            return (E[]) l.subList(3, l.size() - 3).toArray();\n        }\n\n        @Override\n        public E[] getOtherElements() {\n            return outer.getOtherElements();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return outer.isAddSupported();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return outer.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isSetSupported() {\n            return outer.isSetSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public List<E> makeFullCollection() {\n            final int size = getFullElements().length;\n            return outer.makeFullCollection().subList(3, size - 3);\n        }\n\n        @Override\n        public List<E> makeObject() {\n            return outer.makeFullCollection().subList(4, 4);\n        }\n\n        @Override\n        public void resetEmpty() {\n            outer.resetFull();\n            setCollection(outer.getCollection().subList(4, 4));\n            setConfirmed(outer.getConfirmed().subList(4, 4));\n        }\n\n        @Override\n        public void resetFull() {\n            outer.resetFull();\n            final int size = outer.getConfirmed().size();\n            setCollection(outer.getCollection().subList(3, size - 3));\n            setConfirmed(outer.getConfirmed().subList(3, size - 3));\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n            outer.verify();\n        }\n    }\n\n    public class TestListIterator extends AbstractListIteratorTest<E> {\n        public TestListIterator() {\n            super(\"TestListIterator\");\n        }\n\n        @Override\n        public E addSetValue() {\n            return getOtherElements()[0];\n        }\n\n        @Override\n        public ListIterator<E> makeEmptyIterator() {\n            resetEmpty();\n            return AbstractListTest.this.getCollection().listIterator();\n        }\n\n        @Override\n        public ListIterator<E> makeObject() {\n            resetFull();\n            return AbstractListTest.this.getCollection().listIterator();\n        }\n\n        @Override\n        public boolean supportsAdd() {\n            return isAddSupported();\n        }\n\n        @Override\n        public boolean supportsRemove() {\n            return isRemoveSupported();\n        }\n\n        @Override\n        public boolean supportsSet() {\n            return AbstractListTest.this.isSetSupported();\n        }\n    }\n\n    /**\n     * JUnit constructor.\n     *\n     * @param testName  the test class name\n     */\n    public AbstractListTest(final String testName) {\n        super(testName);\n    }\n\n    /**\n     *  Traverses to the beginning of the given iterator.\n     *\n     *  @param iter  the iterator to traverse\n     *  @param i     the starting index\n     */\n    private void backwardTest(final ListIterator<E> iter, int i) {\n        final List<E> list = getCollection();\n\n        while (i > 0) {\n            assertTrue(iter.hasPrevious(),\n                \"Iterator should have previous, i:\" + i);\n            assertEquals(i, iter.nextIndex(),\n                \"Iterator.nextIndex should work, i:\" + i);\n            assertEquals(i - 1, iter.previousIndex(),\n                \"Iterator.previousIndex should work, i:\" + i);\n            final E o = iter.previous();\n            assertEquals(list.get(i - 1), o,\n                \"Iterator returned correct element\");\n            i--;\n        }\n\n        assertFalse(iter.hasPrevious(), \"Iterator shouldn't have previous\");\n        final int nextIndex = iter.nextIndex();\n        assertEquals(0, nextIndex, \"nextIndex should be 0\");\n        final int prevIndex = iter.previousIndex();\n        assertEquals(-1, prevIndex, \"previousIndex should be -1\");\n\n        assertThrows(NoSuchElementException.class, () -> iter.previous(),\n                \"Exhausted iterator should raise NoSuchElement\");\n    }\n\n    public BulkTest bulkTestListIterator() {\n        return new TestListIterator();\n    }\n\n    /**\n     *  Returns a {@link BulkTest} for testing {@link List#subList(int,int)}.\n     *  The returned bulk test will run through every {@code TestList}\n     *  method, <em>including</em> another {@code bulkTestSubList}.\n     *  Sublists are tested until the size of the sublist is less than 10.\n     *  Each sublist is 6 elements smaller than its parent list.\n     *  (By default this means that two rounds of sublists will be tested).\n     *  The verify() method is overloaded to test that the original list is\n     *  modified when the sublist is.\n     */\n    public BulkTest bulkTestSubList() {\n        if (getFullElements().length - 6 < 10) {\n            return null;\n        }\n        return new BulkTestSubList<>(this);\n    }\n\n    /**\n     * Invokes all the methods on the given sublist to make sure they raise\n     * a {@link java.util.ConcurrentModificationException ConcurrentModificationException}.\n     */\n    protected void failFastAll(final List<E> list) {\n        final Method[] methods = List.class.getMethods();\n        for (final Method method : methods) {\n            failFastMethod(list, method);\n        }\n    }\n\n    /**\n     * Invokes the given method on the given sublist to make sure it raises\n     * a {@link java.util.ConcurrentModificationException ConcurrentModificationException}.\n     *\n     * Unless the method happens to be the equals() method, in which case\n     * the test is skipped. There seems to be a bug in\n     * java.util.AbstractList.subList(int,int).equals(Object) -- it never\n     * raises a ConcurrentModificationException.\n     *\n     * @param list the sublist to test\n     * @param m the method to invoke\n     */\n    protected void failFastMethod(final List<E> list, final Method m) {\n        if (m.getName().equals(\"equals\")) {\n            return;\n        }\n\n        final E element = getOtherElements()[0];\n        final Collection<E> c = Collections.singleton(element);\n\n        final Class<?>[] types = m.getParameterTypes();\n        final Object[] params = new Object[types.length];\n        for (int i = 0; i < params.length; i++) {\n            if (types[i] == Integer.TYPE) {\n                params[i] = Integer.valueOf(0);\n            } else if (types[i] == Collection.class) {\n                params[i] = c;\n            } else if (types[i] == Object.class) {\n                params[i] = element;\n            } else if (types[i] == Object[].class) {\n                params[i] = new Object[0];\n            }\n        }\n\n        final InvocationTargetException thrown = assertThrows(InvocationTargetException.class, () -> m.invoke(list, params),\n                m.getName() + \" should raise ConcurrentModification\");\n        assertTrue(thrown.getTargetException() instanceof ConcurrentModificationException,\n                m.getName() + \" raised unexpected \" + thrown.getTargetException());\n    }\n\n    /**\n     *  Traverses to the end of the given iterator.\n     *\n     *  @param iter  the iterator to traverse\n     *  @param i     the starting index\n     */\n    private void forwardTest(final ListIterator<E> iter, int i) {\n        final List<E> list = getCollection();\n        final int max = getFullElements().length;\n\n        while (i < max) {\n            assertTrue(iter.hasNext(), \"Iterator should have next\");\n            assertEquals(i, iter.nextIndex(),\n                \"Iterator.nextIndex should work\");\n            assertEquals(i - 1, iter.previousIndex(),\n                \"Iterator.previousIndex should work\");\n            final Object o = iter.next();\n            assertEquals(list.get(i), o, \"Iterator returned correct element\");\n            i++;\n        }\n\n        assertFalse(iter.hasNext(), \"Iterator shouldn't have next\");\n        assertEquals(max, iter.nextIndex(), \"nextIndex should be size\");\n        assertEquals(max - 1, iter.previousIndex(), \"previousIndex should be size - 1\");\n\n        assertThrows(NoSuchElementException.class, () -> iter.next(),\n                \"Exhausted iterator should raise NoSuchElement\");\n    }\n\n    /**\n     * Returns the {@link #collection} field cast to a {@link List}.\n     *\n     * @return the collection field as a List\n     */\n    @Override\n    public List<E> getCollection() {\n        return (List<E>) super.getCollection();\n    }\n\n    /**\n     * Returns the {@link #confirmed} field cast to a {@link List}.\n     *\n     * @return the confirmed field as a List\n     */\n    @Override\n    public List<E> getConfirmed() {\n        return (List<E>) super.getConfirmed();\n    }\n\n    /**\n     * List equals method is defined.\n     */\n    @Override\n    public boolean isEqualsCheckable() {\n        return true;\n    }\n\n    /**\n     *  Returns true if the collections produced by\n     *  {@link #makeObject()} and {@link #makeFullCollection()}\n     *  support the <code>set operation.<p>\n     *  Default implementation returns true.  Override if your collection\n     *  class does not support set.\n     */\n    public boolean isSetSupported() {\n        return true;\n    }\n\n    /**\n     * Returns an empty {@link ArrayList}.\n     */\n    @Override\n    public Collection<E> makeConfirmedCollection() {\n        return new ArrayList<>();\n    }\n\n    /**\n     * Returns a full {@link ArrayList}.\n     */\n    @Override\n    public Collection<E> makeConfirmedFullCollection() {\n        return new ArrayList<>(Arrays.asList(getFullElements()));\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List<E> makeFullCollection() {\n        // only works if list supports optional \"addAll(Collection)\"\n        final List<E> list = makeObject();\n        list.addAll(Arrays.asList(getFullElements()));\n        return list;\n    }\n\n    /**\n     * Returns {@link #makeObject()}.\n     *\n     * @return an empty list to be used for testing\n     */\n    @Override\n    public abstract List<E> makeObject();\n\n    /**\n     * Compare the current serialized form of the List\n     * against the canonical version in SCM.\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEmptyListCompatibility() throws IOException, ClassNotFoundException {\n        /*\n         * Create canonical objects with this code\n        List list = makeEmptyList();\n        if (!(list instanceof Serializable)) return;\n\n        writeExternalFormToDisk((Serializable) list, getCanonicalEmptyCollectionName(list));\n        */\n\n        // test to make sure the canonical form has been preserved\n        final List<E> list = makeObject();\n        if (list instanceof Serializable && !skipSerializedCanonicalTests()\n                && isTestSerialization()) {\n            final List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(list));\n            assertEquals(0, list2.size(), \"List is empty\");\n            assertEquals(list, list2);\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEmptyListSerialization() throws IOException, ClassNotFoundException {\n        final List<E> list = makeObject();\n        if (!(list instanceof Serializable && isTestSerialization())) {\n            return;\n        }\n\n        final byte[] object = writeExternalFormToBytes((Serializable) list);\n        final List<E> list2 = (List<E>) readExternalFormFromBytes(object);\n\n        assertEquals(0, list.size(), \"Both lists are empty\");\n        assertEquals(0, list2.size(), \"Both lists are empty\");\n    }\n\n    /**\n     * Compare the current serialized form of the List\n     * against the canonical version in SCM.\n     */\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testFullListCompatibility() throws IOException, ClassNotFoundException {\n        /*\n         * Create canonical objects with this code\n        List list = makeFullList();\n        if (!(list instanceof Serializable)) return;\n\n        writeExternalFormToDisk((Serializable) list, getCanonicalFullCollectionName(list));\n        */\n\n        // test to make sure the canonical form has been preserved\n        final List<E> list = makeFullCollection();\n        if (list instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n            final List<E> list2 = (List<E>) readExternalFormFromDisk(getCanonicalFullCollectionName(list));\n            if (list2.size() == 4) {\n                // old serialized tests\n                return;\n            }\n            assertEquals(list.size(), list2.size(), \"List is the right size\");\n            assertEquals(list, list2);\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testFullListSerialization() throws IOException, ClassNotFoundException {\n        final List<E> list = makeFullCollection();\n        final int size = getFullElements().length;\n        if (!(list instanceof Serializable && isTestSerialization())) {\n            return;\n        }\n\n        final byte[] object = writeExternalFormToBytes((Serializable) list);\n        final List<E> list2 = (List<E>) readExternalFormFromBytes(object);\n\n        assertEquals(size, list.size(), \"Both lists are same size\");\n        assertEquals(size, list2.size(), \"Both lists are same size\");\n    }\n\n    /**\n     *  Tests {@link List#add(int,Object)}.\n     */\n    @Test\n    public void testListAddByIndex() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final E element = getOtherElements()[0];\n        final int max = getFullElements().length;\n\n        for (int i = 0; i <= max; i++) {\n            resetFull();\n            getCollection().add(i, element);\n            getConfirmed().add(i, element);\n            verify();\n        }\n    }\n\n    /**\n     *  Tests bounds checking for {@link List#add(int, Object)} on an\n     *  empty list.\n     */\n    @Test\n    public void testListAddByIndexBoundsChecking() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final E element = getOtherElements()[0];\n\n        final List<E> finalList0 = makeObject();\n        assertThrows(IndexOutOfBoundsException.class, () -> finalList0.add(Integer.MIN_VALUE, element),\n                \"List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n\n        final List<E> finalList1 = makeObject();\n        assertThrows(IndexOutOfBoundsException.class, () -> finalList1.add(-1, element),\n                \"List.add should throw IndexOutOfBoundsException [-1]\");\n\n        final List<E> finalList2 = makeObject();\n        assertThrows(IndexOutOfBoundsException.class, () -> finalList2.add(1, element),\n                \"List.add should throw IndexOutOfBoundsException [1]\");\n\n        final List<E> finalList3 = makeObject();\n        assertThrows(IndexOutOfBoundsException.class, () -> finalList3.add(Integer.MAX_VALUE, element),\n                \"List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n    }\n\n    /**\n     *  Tests bounds checking for {@link List#add(int, Object)} on a\n     *  full list.\n     */\n    @Test\n    public void testListAddByIndexBoundsChecking2() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final E element = getOtherElements()[0];\n\n        final List<E> finalList0 = makeFullCollection();\n        assertThrows(IndexOutOfBoundsException.class, () -> finalList0.add(Integer.MIN_VALUE, element),\n                \"List.add should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n\n        final List<E> finalList1 = makeFullCollection();\n        assertThrows(IndexOutOfBoundsException.class, () -> finalList1.add(-1, element),\n                \"List.add should throw IndexOutOfBoundsException [-1]\");\n\n        final List<E> finalList2 = makeFullCollection();\n        assertThrows(IndexOutOfBoundsException.class, () -> finalList2.add(finalList2.size() + 1, element),\n                \"List.add should throw IndexOutOfBoundsException [size + 1]\");\n\n        final List<E> finalList3 = makeFullCollection();\n        assertThrows(IndexOutOfBoundsException.class, () -> finalList3.add(Integer.MAX_VALUE, element),\n                \"List.add should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n    }\n\n    /**\n     *  Tests {@link List#equals(Object)}.\n     */\n    @Test\n    public void testListEquals() {\n        resetEmpty();\n        List<E> list = getCollection();\n        assertTrue(list.equals(getConfirmed()), \"Empty lists should be equal\");\n        verify();\n        assertTrue(list.equals(list), \"Empty list should equal self\");\n        verify();\n\n        List<E> list2 = Arrays.asList(getFullElements());\n        assertFalse(list.equals(list2), \"Empty list shouldn't equal full\");\n        verify();\n\n        list2 = Arrays.asList(getOtherElements());\n        assertFalse(list.equals(list2), \"Empty list shouldn't equal other\");\n        verify();\n\n        resetFull();\n        list = getCollection();\n        assertTrue(list.equals(getConfirmed()), \"Full lists should be equal\");\n        verify();\n        assertTrue(list.equals(list), \"Full list should equal self\");\n        verify();\n\n        list2 = makeObject();\n        assertFalse(list.equals(list2), \"Full list shouldn't equal empty\");\n        verify();\n\n        list2 = Arrays.asList(getOtherElements());\n        assertFalse(list.equals(list2), \"Full list shouldn't equal other\");\n        verify();\n\n        list2 = Arrays.asList(getFullElements());\n        if (list2.size() < 2 && isAddSupported()) {\n            // main list is only size 1, so let's add other elements to get a better list\n            list.addAll(Arrays.asList(getOtherElements()));\n            getConfirmed().addAll(Arrays.asList(getOtherElements()));\n            list2 = new ArrayList<>(list2);\n            list2.addAll(Arrays.asList(getOtherElements()));\n        }\n        if (list2.size() > 1) {\n            Collections.reverse(list2);\n            assertFalse(list.equals(list2), \"Full list shouldn't equal full list with same elements but different order\");\n            verify();\n        }\n\n        resetFull();\n        list = getCollection();\n        assertFalse(list.isEmpty(), \"List shouldn't equal String\");\n        verify();\n\n        final List<E> listForC = Arrays.asList(getFullElements());\n        final Collection<E> c = new AbstractCollection<E>() {\n            @Override\n            public Iterator<E> iterator() {\n                return listForC.iterator();\n            }\n\n            @Override\n            public int size() {\n                return listForC.size();\n            }\n        };\n\n        assertFalse(list.equals(c), \"List shouldn't equal nonlist with same elements in same order\");\n        verify();\n    }\n\n    /**\n     *  Tests {@link List#get(int)}.\n     */\n    @Test\n    public void testListGetByIndex() {\n        resetFull();\n        final List<E> list = getCollection();\n        final E[] elements = getFullElements();\n        for (int i = 0; i < elements.length; i++) {\n            assertEquals(elements[i], list.get(i), \"List should contain correct elements\");\n            verify();\n        }\n    }\n\n    /**\n     *  Tests bounds checking for {@link List#get(int)} on an\n     *  empty list.\n     */\n    @Test\n    public void testListGetByIndexBoundsChecking() {\n        final List<E> list = makeObject();\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.get(Integer.MIN_VALUE),\n                \"List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.get(-1),\n                \"List.get should throw IndexOutOfBoundsException [-1]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.get(0),\n                \"List.get should throw IndexOutOfBoundsException [0]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.get(1),\n                \"List.get should throw IndexOutOfBoundsException [1]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.get(Integer.MAX_VALUE),\n                \"List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n    }\n\n    /**\n     *  Tests bounds checking for {@link List#get(int)} on a\n     *  full list.\n     */\n    @Test\n    public void testListGetByIndexBoundsChecking2() {\n        final List<E> list = makeFullCollection();\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.get(Integer.MIN_VALUE),\n                \"List.get should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.get(-1),\n                \"List.get should throw IndexOutOfBoundsException [-1]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.get(getFullElements().length),\n                \"List.get should throw IndexOutOfBoundsException [size]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.get(Integer.MAX_VALUE),\n                \"List.get should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n    }\n\n    /**\n     *  Tests {@link List#hashCode()}.\n     */\n    @Test\n    public void testListHashCode() {\n        resetEmpty();\n        int hash1 = getCollection().hashCode();\n        int hash2 = getConfirmed().hashCode();\n        assertEquals(hash1, hash2, \"Empty lists should have equal hashCodes\");\n        verify();\n\n        resetFull();\n        hash1 = getCollection().hashCode();\n        hash2 = getConfirmed().hashCode();\n        assertEquals(hash1, hash2, \"Full lists should have equal hashCodes\");\n        verify();\n    }\n\n    /**\n     *  Tests {@link List#indexOf}.\n     */\n    @Test\n    public void testListIndexOf() {\n        resetFull();\n        final List<E> list1 = getCollection();\n        final List<E> list2 = getConfirmed();\n\n        for (final E element : list2) {\n            assertEquals(list1.indexOf(element),\n                    list2.indexOf(element), \"indexOf should return correct result\");\n            verify();\n        }\n\n        final E[] other = getOtherElements();\n        for (final E element : other) {\n            assertEquals(-1, list1.indexOf(element),\n                    \"indexOf should return -1 for nonexistent element\");\n            verify();\n        }\n    }\n\n    /**\n     *  Tests the {@link ListIterator#add(Object)} method of the list\n     *  iterator.\n     */\n    @Test\n    public void testListIteratorAdd() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        resetEmpty();\n        final List<E> list1 = getCollection();\n        final List<E> list2 = getConfirmed();\n\n        final E[] elements = getFullElements();\n        ListIterator<E> iter1 = list1.listIterator();\n        ListIterator<E> iter2 = list2.listIterator();\n\n        for (final E element : elements) {\n            iter1.add(element);\n            iter2.add(element);\n            verify();\n        }\n\n        resetFull();\n        iter1 = getCollection().listIterator();\n        iter2 = getConfirmed().listIterator();\n        for (final E element : elements) {\n            iter1.next();\n            iter2.next();\n            iter1.add(element);\n            iter2.add(element);\n            verify();\n        }\n    }\n\n    /**\n     *  Tests the {@link ListIterator#set(Object)} method of the list\n     *  iterator.\n     */\n    @Test\n    public void testListIteratorSet() {\n        if (!isSetSupported()) {\n            return;\n        }\n\n        final E[] elements = getFullElements();\n\n        resetFull();\n        final ListIterator<E> iter1 = getCollection().listIterator();\n        final ListIterator<E> iter2 = getConfirmed().listIterator();\n        for (final E element : elements) {\n            iter1.next();\n            iter2.next();\n            iter1.set(element);\n            iter2.set(element);\n            verify();\n        }\n    }\n\n    /**\n     *  Tests {@link List#lastIndexOf}.\n     */\n    @Test\n    public void testListLastIndexOf() {\n        resetFull();\n        final List<E> list1 = getCollection();\n        final List<E> list2 = getConfirmed();\n\n        for (final E element : list2) {\n            assertEquals(list1.lastIndexOf(element), list2.lastIndexOf(element),\n                    \"lastIndexOf should return correct result\");\n            verify();\n        }\n\n        final E[] other = getOtherElements();\n        for (final E element : other) {\n            assertEquals(-1, list1.lastIndexOf(element),\n                    \"lastIndexOf should return -1 for nonexistent \" + \"element\");\n            verify();\n        }\n    }\n\n    /**\n     *  Tests the read-only bits of {@link List#listIterator()}.\n     */\n    @Test\n    public void testListListIterator() {\n        resetFull();\n        forwardTest(getCollection().listIterator(), 0);\n        backwardTest(getCollection().listIterator(), 0);\n    }\n\n    /**\n     *  Tests the read-only bits of {@link List#listIterator(int)}.\n     */\n    @Test\n    public void testListListIteratorByIndex() {\n        resetFull();\n        try {\n            getCollection().listIterator(-1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        resetFull();\n        try {\n            getCollection().listIterator(getCollection().size() + 1);\n        } catch (final IndexOutOfBoundsException ex) {\n        }\n        resetFull();\n        for (int i = 0; i <= getConfirmed().size(); i++) {\n            forwardTest(getCollection().listIterator(i), i);\n            backwardTest(getCollection().listIterator(i), i);\n        }\n        resetFull();\n        for (int i = 0; i <= getConfirmed().size(); i++) {\n            backwardTest(getCollection().listIterator(i), i);\n        }\n    }\n\n    /**\n     * Tests remove on list iterator is correct.\n     */\n    @Test\n    public void testListListIteratorNextRemoveNext() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n        resetFull();\n        if (getCollection().size() < 4) {\n            return;\n        }\n        final ListIterator<E> it = getCollection().listIterator();\n        final E zero = it.next();\n        final E one = it.next();\n        final E two = it.next();\n        assertEquals(zero, getCollection().get(0));\n        assertEquals(one, getCollection().get(1));\n        assertEquals(two, getCollection().get(2));\n        final E three = getCollection().get(3);\n\n        it.remove(); // removed element at index 2 (two)\n        assertEquals(zero, getCollection().get(0));\n        assertEquals(one, getCollection().get(1));\n        final E three2 = it.next();  // do next after remove\n        assertEquals(three, three2);\n        assertEquals(getCollection().size() > 3, it.hasNext());\n        assertTrue(it.hasPrevious());\n    }\n\n    /**\n     * Tests remove on list iterator is correct.\n     */\n    @Test\n    public void testListListIteratorNextRemovePrevious() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n        resetFull();\n        if (getCollection().size() < 4) {\n            return;\n        }\n        final ListIterator<E> it = getCollection().listIterator();\n        final E zero = it.next();\n        final E one = it.next();\n        final E two = it.next();\n        assertEquals(zero, getCollection().get(0));\n        assertEquals(one, getCollection().get(1));\n        assertEquals(two, getCollection().get(2));\n\n        it.remove(); // removed element at index 2 (two)\n        assertEquals(zero, getCollection().get(0));\n        assertEquals(one, getCollection().get(1));\n        final E one2 = it.previous();  // do previous after remove\n        assertEquals(one, one2);\n        assertTrue(it.hasNext());\n        assertTrue(it.hasPrevious());\n    }\n\n    /**\n     * Tests remove on list iterator is correct.\n     */\n    @Test\n    public void testListListIteratorPreviousRemoveNext() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n        resetFull();\n        if (getCollection().size() < 4) {\n            return;\n        }\n        final ListIterator<E> it = getCollection().listIterator();\n        final E zero = it.next();\n        final E one = it.next();\n        final E two = it.next();\n        final E two2 = it.previous();\n        final E one2 = it.previous();\n        assertEquals(one, one2);\n        assertEquals(two, two2);\n        assertEquals(zero, getCollection().get(0));\n        assertEquals(one, getCollection().get(1));\n        assertEquals(two, getCollection().get(2));\n\n        it.remove(); // removed element at index 1 (one)\n        assertEquals(zero, getCollection().get(0));\n        assertEquals(two, getCollection().get(1));\n        final E two3 = it.next();  // do next after remove\n        assertEquals(two, two3);\n        assertEquals(getCollection().size() > 2, it.hasNext());\n        assertTrue(it.hasPrevious());\n    }\n\n    /**\n     * Tests remove on list iterator is correct.\n     */\n    @Test\n    public void testListListIteratorPreviousRemovePrevious() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n        resetFull();\n        if (getCollection().size() < 4) {\n            return;\n        }\n        final ListIterator<E> it = getCollection().listIterator();\n        final E zero = it.next();\n        final E one = it.next();\n        final E two = it.next();\n        final E two2 = it.previous();\n        final E one2 = it.previous();\n        assertEquals(one, one2);\n        assertEquals(two, two2);\n        assertEquals(zero, getCollection().get(0));\n        assertEquals(one, getCollection().get(1));\n        assertEquals(two, getCollection().get(2));\n\n        it.remove(); // removed element at index 1 (one)\n        assertEquals(zero, getCollection().get(0));\n        assertEquals(two, getCollection().get(1));\n        final E zero3 = it.previous();  // do previous after remove\n        assertEquals(zero, zero3);\n        assertFalse(it.hasPrevious());\n        assertEquals(getCollection().size() > 2, it.hasNext());\n    }\n\n    /**\n     *  Tests {@link List#remove(int)}.\n     */\n    @Test\n    public void testListRemoveByIndex() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        final int max = getFullElements().length;\n        for (int i = 0; i < max; i++) {\n            resetFull();\n            final E o1 = getCollection().remove(i);\n            final E o2 = getConfirmed().remove(i);\n            assertEquals(o1, o2, \"remove should return correct element\");\n            verify();\n        }\n    }\n\n    /**\n     *  Tests bounds checking for {@link List#remove(int)} on an\n     *  empty list.\n     */\n    @Test\n    public void testListRemoveByIndexBoundsChecking() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        final List<E> list = makeObject();\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.remove(Integer.MIN_VALUE),\n                \"List.remove should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.remove(-1),\n                \"List.remove should throw IndexOutOfBoundsException [-1]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.remove(0),\n                \"List.remove should throw IndexOutOfBoundsException [0]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.remove(1),\n                \"List.remove should throw IndexOutOfBoundsException [1]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.remove(Integer.MAX_VALUE),\n                \"List.remove should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n    }\n\n    /**\n     *  Tests bounds checking for {@link List#remove(int)} on a\n     *  full list.\n     */\n    @Test\n    public void testListRemoveByIndexBoundsChecking2() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        final List<E> list = makeFullCollection();\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.remove(Integer.MIN_VALUE),\n                \"List.remove should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.remove(-1),\n                \"List.remove should throw IndexOutOfBoundsException [-1]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.remove(getFullElements().length),\n                \"List.remove should throw IndexOutOfBoundsException [size]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.remove(Integer.MAX_VALUE),\n                \"List.remove should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n    }\n\n    /**\n     *  Test {@link List#set(int,Object)}.\n     */\n    @Test\n    public void testListSetByIndex() {\n        if (!isSetSupported()) {\n            return;\n        }\n\n        resetFull();\n        final E[] elements = getFullElements();\n        final E[] other = getOtherElements();\n\n        for (int i = 0; i < elements.length; i++) {\n            final E n = other[i % other.length];\n            final E v = getCollection().set(i, n);\n            assertEquals(elements[i], v, \"Set should return correct element\");\n            getConfirmed().set(i, n);\n            verify();\n        }\n    }\n\n    /**\n     *  Tests bounds checking for {@link List#set(int,Object)} on an\n     *  empty list.\n     */\n    @Test\n    public void testListSetByIndexBoundsChecking() {\n        if (!isSetSupported()) {\n            return;\n        }\n\n        final List<E> list = makeObject();\n        final E element = getOtherElements()[0];\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.set(Integer.MIN_VALUE, element),\n                \"List.set should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.set(-1, element),\n                \"List.set should throw IndexOutOfBoundsException [-1]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.set(0, element),\n                \"List.set should throw IndexOutOfBoundsException [0]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.set(1, element),\n                \"List.set should throw IndexOutOfBoundsException [1]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.set(Integer.MAX_VALUE, element),\n                \"List.set should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n    }\n\n    /**\n     *  Tests bounds checking for {@link List#set(int,Object)} on a\n     *  full list.\n     */\n    @Test\n    public void testListSetByIndexBoundsChecking2() {\n        if (!isSetSupported()) {\n            return;\n        }\n\n        final List<E> list = makeFullCollection();\n        final E element = getOtherElements()[0];\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.set(Integer.MIN_VALUE, element),\n                \"List.set should throw IndexOutOfBoundsException [Integer.MIN_VALUE]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.set(-1, element),\n                \"List.set should throw IndexOutOfBoundsException [-1]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.set(getFullElements().length, element),\n                \"List.set should throw IndexOutOfBoundsException [size]\");\n\n        assertThrows(IndexOutOfBoundsException.class, () -> list.set(Integer.MAX_VALUE, element),\n                \"List.set should throw IndexOutOfBoundsException [Integer.MAX_VALUE]\");\n    }\n\n    /**\n     * Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}\n     * if elements are added to the original list.\n     */\n    @Test\n    public void testListSubListFailFastOnAdd() {\n        if (!isFailFastSupported()) {\n            return;\n        }\n        if (!isAddSupported()) {\n            return;\n        }\n\n        resetFull();\n        final int size = getCollection().size();\n        List<E> sub = getCollection().subList(1, size);\n        getCollection().add(getOtherElements()[0]);\n        failFastAll(sub);\n\n        resetFull();\n        sub = getCollection().subList(1, size);\n        getCollection().add(0, getOtherElements()[0]);\n        failFastAll(sub);\n\n        resetFull();\n        sub = getCollection().subList(1, size);\n        getCollection().addAll(Arrays.asList(getOtherElements()));\n        failFastAll(sub);\n\n        resetFull();\n        sub = getCollection().subList(1, size);\n        getCollection().addAll(0, Arrays.asList(getOtherElements()));\n        failFastAll(sub);\n    }\n\n    /**\n     * Tests that a sublist raises a {@link java.util.ConcurrentModificationException ConcurrentModificationException}\n     * if elements are removed from the original list.\n     */\n    @Test\n    public void testListSubListFailFastOnRemove() {\n        if (!isFailFastSupported()) {\n            return;\n        }\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        resetFull();\n        final int size = getCollection().size();\n        List<E> sub = getCollection().subList(1, size);\n        getCollection().remove(0);\n        failFastAll(sub);\n\n        resetFull();\n        sub = getCollection().subList(1, size);\n        getCollection().remove(getFullElements()[2]);\n        failFastAll(sub);\n\n        resetFull();\n        sub = getCollection().subList(1, size);\n        getCollection().removeAll(Arrays.asList(getFullElements()));\n        failFastAll(sub);\n\n        resetFull();\n        sub = getCollection().subList(1, size);\n        getCollection().retainAll(Arrays.asList(getOtherElements()));\n        failFastAll(sub);\n\n        resetFull();\n        sub = getCollection().subList(1, size);\n        getCollection().clear();\n        failFastAll(sub);\n    }\n\n    /**\n     *  If {@link #isSetSupported()} returns false, tests that set operation\n     *  raises <Code>UnsupportedOperationException.\n     */\n    @Test\n    public void testUnsupportedSet() {\n        if (isSetSupported()) {\n            return;\n        }\n\n        resetFull();\n        assertThrows(UnsupportedOperationException.class, () -> getCollection().set(0, getFullElements()[0]),\n                \"Empty collection should not support set.\");\n        // make sure things didn't change even if the expected exception was\n        // thrown.\n        verify();\n    }\n\n    /**\n     *  Verifies that the test list implementation matches the confirmed list\n     *  implementation.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public void verify() {\n        super.verify();\n\n        final List<E> list1 = getCollection();\n        final List<E> list2 = getConfirmed();\n\n        assertEquals(list1, list2, \"List should equal confirmed\");\n        assertEquals(list2, list1, \"Confirmed should equal list\");\n\n        assertEquals(list1.hashCode(), list2.hashCode(), \"Hash codes should be equal\");\n\n        int i = 0;\n        final Iterator<E> iterator1 = list1.iterator();\n        final E[] array = (E[]) list1.toArray();\n        for (Object o2 : list2) {\n            assertTrue(iterator1.hasNext(), \"List iterator should have next\");\n            final Object o1 = iterator1.next();\n            assertEquals(o1, o2, \"Iterator elements should be equal\");\n            o2 = list1.get(i);\n            assertEquals(o1, o2, \"get should return correct element\");\n            o2 = array[i];\n            assertEquals(o1, o2, \"toArray should have correct element\");\n            i++;\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java.AbstractCountingBloomFilterTest", "name": "AbstractCountingBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java", "superclasses": "", "methods": ["[void]assertCounts(CountingBloomFilter,int[])", "[void]assertCell3(CountingBloomFilter,int)", "[CellExtractor]getMaximumValueExtractor(int)", "[void]verifyMaxInsert(CountingBloomFilter,int,int)"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java.AbstractCountingBloomFilterTest.[void]assertCounts(CountingBloomFilter,int[])", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java.AbstractCountingBloomFilterTest.[void]assertCell3(CountingBloomFilter,int)", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java.AbstractCountingBloomFilterTest.[CellExtractor]getMaximumValueExtractor(int)", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCountingBloomFilterTest.java.AbstractCountingBloomFilterTest.[void]verifyMaxInsert(CountingBloomFilter,int,int)"], "overrides": null, "attributes": [], "class_docstring": "\nTests for the {@link ArrayCountingBloomFilter}.\n", "original_string": "public abstract class AbstractCountingBloomFilterTest<T extends CountingBloomFilter>\n        extends AbstractBloomFilterTest<T> {\n\n    private static final int[] from1Counts = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0};\n\n    private static final int[] bigHashCounts = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 0};\n\n    private static final long bigHashValue = 0xffffffeL;\n\n    /**\n     * Assert the counts match the expected values. Values are for indices starting\n     * at 0. Assert the cardinality equals the number of non-zero counts.\n     *\n     * @param bf the bloom filter\n     * @param expected the expected counts\n     */\n    private static void assertCounts(final CountingBloomFilter bf, final int[] expected) {\n        final Map<Integer, Integer> m = new HashMap<>();\n        bf.processCells((i, c) -> {\n            m.put(i, c);\n            return true;\n        });\n        int zeros = 0;\n        for (int i = 0; i < expected.length; i++) {\n            if (m.get(i) == null) {\n                assertEquals(expected[i], 0, \"Wrong value for \" + i);\n                zeros++;\n            } else {\n                assertEquals(expected[i], m.get(i).intValue(), \"Wrong value for \" + i);\n            }\n        }\n        assertEquals(expected.length - zeros, bf.cardinality());\n    }\n\n    private void assertCell3(final CountingBloomFilter bf, final int value) {\n        bf.processCells((k, v) -> {\n            if (k == 3) {\n                assertEquals(value, v, \"Mismatch at position 3\");\n            } else {\n                assertEquals(0, v, \"Mismatch at position \" + k);\n            }\n            return true;\n        });\n    }\n\n    protected final CellExtractor getMaximumValueExtractor(final int maxValue) {\n        return consumer -> {\n            for (int i = 1; i < 18; i++) {\n                if (!consumer.test(i, maxValue)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    }\n\n    @Test\n    public void mergeIncrementsAllCellsTest() {\n        final CountingBloomFilter f1 = createEmptyFilter(Shape.fromKM(1, 10));\n        final CountingBloomFilter f2 = f1.copy();\n        final CountingBloomFilter f3 = f1.copy();\n        // index extractor produces 3 two times.\n        final IndexExtractor ip = p -> {\n            p.test(3);\n            p.test(3);\n            return true;\n        };\n        // The merge should increment cell 3 by 1\n        f1.merge(ip);\n        assertCell3(f1, 1);\n\n        // The add should increment cells 3 by 2\n        f2.add(CellExtractor.from(ip));\n        assertCell3(f2, 2);\n    }\n\n    @Test\n    public void removeDecrementsAllCellsTest() {\n        final CountingBloomFilter f1 = createEmptyFilter(Shape.fromKM(1, 10));\n        final CellExtractor cp = p -> {\n            p.test(3, 3);\n            return true;\n        };\n        f1.add(cp);\n        final CountingBloomFilter f2 = f1.copy();\n        final CountingBloomFilter f3 = f1.copy();\n        // index extractor produces 3 two times.\n        final IndexExtractor ip = p -> {\n            p.test(3);\n            p.test(3);\n            return true;\n        };\n        // The merge should decrement cell 3 by 1\n        f1.remove(ip);\n        assertCell3(f1, 2);\n\n        // The add should decrement cells 3 by 2\n        f2.subtract(CellExtractor.from(ip));\n        assertCell3(f2, 1);\n\n        // This merge will decrement by 1 as the round-trip makes the indices unique\n        f3.remove(IndexExtractor.fromIndexArray(ip.asIndexArray()));\n        assertCell3(f3, 2);\n    }\n\n    /**\n     * Tests that merge correctly updates the counts when a CountingBloomFilter is\n     * passed.\n     */\n    @Test\n    public void testAdd() {\n        final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n        assertTrue(bf1.add(createFilter(getTestShape(), TestingHashers.FROM11)), \"Add should work\");\n        assertTrue(bf1.contains(TestingHashers.FROM1), \"Should contain\");\n        assertTrue(bf1.contains(TestingHashers.FROM11), \"Should contain\");\n        assertCounts(bf1, bigHashCounts);\n\n        // test overflow\n\n        final CountingBloomFilter bf2 = createEmptyFilter(getTestShape());\n        assertTrue(bf2.add(getMaximumValueExtractor(bf2.getMaxCell())), \"Should add to empty\");\n        assertTrue(bf2.isValid(), \"Should be valid\");\n\n        assertFalse(bf2.add(createFilter(getTestShape(), TestingHashers.FROM1)), \"Should not add\");\n        assertFalse(bf2.isValid(), \"Should not be valid\");\n    }\n\n    @Test\n    public final void testCountingBloomFilterSpecificContains() {\n        final BloomFilter bf = new SimpleBloomFilter(getTestShape());\n        bf.merge(TestingHashers.FROM1);\n        final CountingBloomFilter bf2 = TestingHashers.populateFromHashersFrom1AndFrom11( createEmptyFilter(getTestShape()));\n\n        assertTrue(bf.contains(bf), \"BF Should contain itself\");\n        assertTrue(bf2.contains(bf2), \"BF2 Should contain itself\");\n        assertFalse(bf.contains(bf2), \"BF should not contain BF2\");\n        assertTrue(bf2.contains(bf), \"BF2 should contain BF\");\n        final BitMapExtractor extractor = bf2;\n        assertTrue(bf2.contains(extractor), \"BF2 should contain BF bitMapExtractor\");\n    }\n\n    /**\n     * Tests that counts are correct when a hasher with duplicates is used in the\n     * constructor.\n     */\n    @Test\n    public final void testCountingSpecificConstructor() {\n        // verify hasher duplicates are counted.\n        // bit hasher has duplicates for 11, 12,13,14,15,16, and 17\n        final CountingBloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);\n        bf.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));\n\n        final long[] lb = bf.asBitMapArray();\n        assertEquals(2, lb.length);\n        assertEquals(bigHashValue, lb[0]);\n\n        assertCounts(bf, bigHashCounts);\n    }\n\n    /**\n     * Tests that merging bloom filters works as expected with a generic BloomFilter.\n     */\n    @Test\n    public final void testCountingSpecificMerge() {\n        final BloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n\n        final BloomFilter bf2 = new SimpleBloomFilter(getTestShape());\n        bf2.merge(TestingHashers.FROM11);\n\n        final BloomFilter bf3 = bf1.copy();\n        bf3.merge(bf2);\n        assertTrue(bf3.contains(bf1), \"Should contain\");\n        assertTrue(bf3.contains(bf2), \"Should contain\");\n\n        final BloomFilter bf4 = bf2.copy();\n        bf4.merge(bf1);\n        assertTrue(bf4.contains(bf1), \"Should contain\");\n        assertTrue(bf4.contains(bf2), \"Should contain\");\n        assertTrue(bf4.contains(bf3), \"Should contain\");\n        assertTrue(bf3.contains(bf4), \"Should contain\");\n\n        // test overflow\n\n        final CountingBloomFilter bf5 = createEmptyFilter(getTestShape());\n        assertTrue(bf5.add(getMaximumValueExtractor(bf5.getMaxCell())), \"Should add to empty\");\n        assertTrue(bf5.isValid(), \"Should be valid\");\n\n        final CountingBloomFilter bf6 = bf5.copy();\n        final BloomFilter bf7 = new SimpleBloomFilter(getTestShape());\n        bf7.merge(TestingHashers.FROM1);\n        bf6.merge(bf7);\n        assertFalse(bf6.isValid(), \"Should not be valid\");\n    }\n\n    @Test\n    public void testExcludesDuplicates() {\n\n        // create a hasher that produces duplicates with the specified shape.\n        // this setup produces 5, 17, 29, 41, 53, 65 two times\n        final Shape shape = Shape.fromKM(12, 72);\n        final Hasher hasher = new IncrementingHasher(5, 12);\n\n        CountingBloomFilter bf1 = createFilter(shape, hasher);\n        assertEquals(6, bf1.cardinality());\n        bf1.processCells((x, y) -> {\n            assertEquals(1, y, \"Hasher in constructor results in value not equal to 1\");\n            return true;\n        });\n\n        bf1 = createEmptyFilter(shape);\n        bf1.merge(hasher);\n        assertEquals(6, bf1.cardinality());\n        bf1.processCells((x, y) -> {\n            assertEquals(1, y, \"Hasher in merge results in value not equal to 1\");\n            return true;\n        });\n\n        bf1 = createEmptyFilter(shape);\n        bf1.merge(hasher);\n        bf1.remove(hasher);\n        assertEquals(0, bf1.cardinality());\n        assertTrue(bf1.processCells((x, y) -> false), \"Hasher in removes results in value not equal to 0\");\n    }\n\n    @Test\n    public void testGetMaxInsert() {\n        final CountingBloomFilter bf = createEmptyFilter(getTestShape());\n        verifyMaxInsert(bf, 0, 0);\n        bf.merge(TestingHashers.FROM1);\n        verifyMaxInsert(bf, 1, 0);\n        bf.merge(TestingHashers.FROM1);\n        verifyMaxInsert(bf, 2, 0);\n        bf.merge(TestingHashers.FROM11);\n        verifyMaxInsert(bf, 2, 1);\n        bf.remove(TestingHashers.FROM1);\n        verifyMaxInsert(bf, 1, 1);\n        // verify remove false positive works\n        // Incrementing hasher 5,1 spans the single count cells for both FROM1 and FROM11\n        assertEquals(1, bf.getMaxInsert(new IncrementingHasher(5, 1)));\n        bf.remove(new IncrementingHasher(5, 1));\n        verifyMaxInsert(bf, 0, 0);\n        assertEquals(0, bf.getMaxInsert(new IncrementingHasher(5, 1)));\n    }\n\n    /**\n     * Tests that merge correctly updates the counts when a CountingBloomFilter is\n     * passed.\n     */\n    @Test\n    public final void testRemove() {\n        final BloomFilter simple = new SimpleBloomFilter(getTestShape());\n        simple.merge(TestingHashers.FROM11);\n\n        final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n        bf1.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));\n\n        assertTrue(bf1.remove(simple), \"Remove should work\");\n        assertFalse(bf1.contains(TestingHashers.FROM11), \"Should not contain\");\n        assertTrue(bf1.contains(TestingHashers.FROM1), \"Should contain\");\n\n        assertCounts(bf1, from1Counts);\n\n        // with hasher\n        final CountingBloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM1);\n        bf2.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));\n\n        assertTrue(bf2.remove(TestingHashers.FROM11), \"Remove should work\");\n        assertFalse(bf2.contains(TestingHashers.FROM11), \"Should not contain\");\n        assertTrue(bf2.contains(TestingHashers.FROM1), \"Should contain\");\n\n        assertCounts(bf2, from1Counts);\n\n        // test underflow\n        final CountingBloomFilter bf3 = createFilter(getTestShape(), TestingHashers.FROM1);\n        assertFalse(bf3.remove(simple), \"Subtract should not work\");\n        assertFalse(bf3.isValid(), \"isValid should return false\");\n        assertFalse(bf3.contains(TestingHashers.FROM1), \"Should not contain\");\n        assertFalse(bf3.contains(simple), \"Should not contain\");\n\n        assertCounts(bf3, new int[] {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1});\n\n        // with IndexExtractor\n        final IndexExtractor ip = TestingHashers.FROM11.indices(getTestShape());\n\n        final CountingBloomFilter bf4 = createFilter(getTestShape(), TestingHashers.FROM1);\n        bf4.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));\n\n        assertTrue(bf4.remove(ip), \"Remove should work\");\n        assertFalse(bf4.contains(TestingHashers.FROM11), \"Should not contain\");\n        assertTrue(bf4.contains(TestingHashers.FROM1), \"Should contain\");\n\n        assertCounts(bf4, from1Counts);\n\n        // with BitMapExtractor\n        final BitMapExtractor bmp = BitMapExtractor.fromIndexExtractor(ip, getTestShape().getNumberOfBits());\n        final CountingBloomFilter bf5 = createFilter(getTestShape(), TestingHashers.FROM1);\n        bf5.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));\n\n        assertTrue(bf5.remove(bmp), \"Remove should work\");\n        assertFalse(bf5.contains(TestingHashers.FROM11), \"Should not contain\");\n        assertTrue(bf5.contains(TestingHashers.FROM1), \"Should contain\");\n\n        assertCounts(bf5, from1Counts);\n\n        // test extractor errors\n        final IndexExtractor ip2 = IndexExtractor.fromIndexArray(1, 2, getTestShape().getNumberOfBits());\n        final CountingBloomFilter bf6 = createFilter(getTestShape(), TestingHashers.FROM1);\n        assertThrows(IllegalArgumentException.class, () -> bf6.remove(ip2));\n\n        final CountingBloomFilter bf7 = createFilter(getTestShape(), TestingHashers.FROM1);\n        final BitMapExtractor bmp2 = BitMapExtractor.fromIndexExtractor(ip2, getTestShape().getNumberOfBits());\n        assertThrows(IllegalArgumentException.class, () -> bf7.remove(bmp2));\n        assertThrows(IllegalArgumentException.class, () -> bf7.remove( new BadHasher(-1)));\n        assertThrows(IllegalArgumentException.class, () -> bf7.remove( new BadHasher(getTestShape().getNumberOfBits())));\n    }\n\n    /**\n     * Tests that merge correctly updates the counts when a CountingBloomFilter is\n     * passed.\n     */\n    @Test\n    public final void testSubtract() {\n        final CountingBloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n        bf1.add(CellExtractor.from(TestingHashers.FROM11.indices(getTestShape())));\n\n        final CountingBloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM11);\n\n        assertTrue(bf1.subtract(bf2), \"Subtract should work\");\n        assertFalse(bf1.contains( TestingHashers.populateFromHashersFrom1AndFrom11(new SimpleBloomFilter(getTestShape()))), \"Should not contain bitHasher\");\n        assertTrue(bf1.contains(TestingHashers.FROM1), \"Should contain TestingHashers.from1\");\n\n        assertCounts(bf1, from1Counts);\n\n        // test underflow\n        final CountingBloomFilter bf3 = createFilter(getTestShape(), TestingHashers.FROM1);\n\n        final CountingBloomFilter bf4 = createFilter(getTestShape(), TestingHashers.FROM11);\n\n        assertFalse(bf3.subtract(bf4), \"Subtract should not work\");\n        assertFalse(bf3.isValid(), \"isValid should return false\");\n        assertFalse(bf3.contains(TestingHashers.FROM1), \"Should not contain\");\n        assertFalse(bf3.contains(bf4), \"Should not contain\");\n\n        assertCounts(bf3, new int[] {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0});\n\n        assertThrows(IllegalArgumentException.class, () -> bf3.remove( new BadHasher(-1)));\n        assertThrows(IllegalArgumentException.class, () -> bf3.remove( new BadHasher(getTestShape().getNumberOfBits())));\n    }\n\n    private void verifyMaxInsert(final CountingBloomFilter bf, final int from1, final int from11) {\n        final BloomFilter bfFrom0 = new DefaultBloomFilterTest.SparseDefaultBloomFilter(getTestShape());\n        bfFrom0.merge(new IncrementingHasher(0, 1));\n        final BloomFilter bfFrom1 = new DefaultBloomFilterTest.SparseDefaultBloomFilter(getTestShape());\n        bfFrom1.merge(TestingHashers.FROM1);\n        final BloomFilter bfFrom11 = new DefaultBloomFilterTest.SparseDefaultBloomFilter(getTestShape());\n        bfFrom11.merge(TestingHashers.FROM11);\n\n        assertEquals(0, bf.getMaxInsert(new IncrementingHasher(0, 1)));\n        assertEquals(0, bf.getMaxInsert(bfFrom0));\n        assertEquals(0, bf.getMaxInsert((BitMapExtractor) bfFrom0));\n        assertEquals(0, bf.getMaxInsert((IndexExtractor) bfFrom0));\n\n        assertEquals(from1, bf.getMaxInsert(TestingHashers.FROM1));\n        assertEquals(from1, bf.getMaxInsert(bfFrom1));\n        assertEquals(from1, bf.getMaxInsert((BitMapExtractor) bfFrom1));\n        assertEquals(from1, bf.getMaxInsert((IndexExtractor) bfFrom1));\n\n        assertEquals(from11, bf.getMaxInsert(TestingHashers.FROM11));\n        assertEquals(from11, bf.getMaxInsert(bfFrom11));\n        assertEquals(from11, bf.getMaxInsert((BitMapExtractor) bfFrom11));\n        assertEquals(from11, bf.getMaxInsert((IndexExtractor) bfFrom11));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final int[] from1Counts = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int[]", "name": "from1Counts = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0}", "syntax_pass": true}, {"attribute_expression": "private static final int[] bigHashCounts = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 0};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int[]", "name": "bigHashCounts = {0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n        1, 0}", "syntax_pass": true}, {"attribute_expression": "private static final long bigHashValue = 0xffffffeL;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "bigHashValue = 0xffffffeL", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapExtractorTest.java.AbstractBitMapExtractorTest", "name": "AbstractBitMapExtractorTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapExtractorTest.java", "superclasses": "", "methods": ["[BitMapExtractor]createEmptyExtractor()", "[BitMapExtractor]createExtractor()", "[boolean]emptyIsZeroLength()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapExtractorTest.java.AbstractBitMapExtractorTest.[BitMapExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapExtractorTest.java.AbstractBitMapExtractorTest.[BitMapExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBitMapExtractorTest.java.AbstractBitMapExtractorTest.[boolean]emptyIsZeroLength()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public abstract class AbstractBitMapExtractorTest {\n\n    /**\n     * A testing consumer that always returns false.\n     */\n    static final LongPredicate FALSE_CONSUMER = arg0 -> false;\n\n    /**\n     * A testing consumer that always returns true.\n     */\n    static final LongPredicate TRUE_CONSUMER = arg0 -> true;\n\n    /**\n     * Creates a BitMapExtractor without data.\n     * @return a BitMap extractor that has no data.\n     */\n    protected abstract BitMapExtractor createEmptyExtractor();\n\n    /**\n     * Creates a BitMapExtractor with some data.\n     * @return a BitMap extractor with some data\n     */\n    protected abstract BitMapExtractor createExtractor();\n\n    protected boolean emptyIsZeroLength() {\n        return false;\n    }\n\n    @Test\n    public final void testAsBitMapArray() {\n        long[] array = createEmptyExtractor().asBitMapArray();\n        for (int i = 0; i < array.length; i++) {\n            assertEquals(0, array[i], \"Wrong value at \" + i);\n        }\n\n        array = createExtractor().asBitMapArray();\n        assertFalse(array.length == 0);\n    }\n\n    @Test\n    public final void testForEachBitMap() {\n        assertFalse(createExtractor().processBitMaps(FALSE_CONSUMER), \"non-empty should be false\");\n        if (emptyIsZeroLength()) {\n            assertTrue(createEmptyExtractor().processBitMaps(FALSE_CONSUMER), \"empty should be true\");\n        } else {\n            assertFalse(createEmptyExtractor().processBitMaps(FALSE_CONSUMER), \"empty should be false\");\n        }\n\n        assertTrue(createExtractor().processBitMaps(TRUE_CONSUMER), \"non-empty should be true\");\n        assertTrue(createEmptyExtractor().processBitMaps(TRUE_CONSUMER), \"empty should be true\");\n    }\n\n    @Test\n    public void testForEachBitMapEarlyExit() {\n        final int[] passes = new int[1];\n        assertFalse(createExtractor().processBitMaps(l -> {\n            passes[0]++;\n            return false;\n        }));\n        assertEquals(1, passes[0]);\n\n        passes[0] = 0;\n        if (emptyIsZeroLength()) {\n            assertTrue(createEmptyExtractor().processBitMaps(l -> {\n                passes[0]++;\n                return false;\n            }));\n            assertEquals(0, passes[0]);\n        } else {\n            assertFalse(createEmptyExtractor().processBitMaps(l -> {\n                passes[0]++;\n                return false;\n            }));\n            assertEquals(1, passes[0]);\n        }\n    }\n\n    @Test\n    public final void testForEachBitMapPair() {\n        final LongBiPredicate func = (x, y) -> x == y;\n        assertTrue(createEmptyExtractor().processBitMapPairs(createEmptyExtractor(), func), \"empty == empty failed\");\n        assertFalse(createEmptyExtractor().processBitMapPairs(createExtractor(), func), \"empty == not_empty failed\");\n        assertFalse(createExtractor().processBitMapPairs(createEmptyExtractor(), func), \"not_empty == empty passed\");\n        assertTrue(createExtractor().processBitMapPairs(createExtractor(), func), \"not_empty == not_empty failed\");\n\n        // test BitMapExtractors of different length send 0 for missing values.\n        final int[] count = new int[3];\n        final LongBiPredicate lbp = (x, y) -> {\n            if (x == 0) {\n                count[0]++;\n            }\n            if (y == 0) {\n                count[1]++;\n            }\n            count[2]++;\n            return true;\n        };\n        createEmptyExtractor().processBitMapPairs(createExtractor(), lbp);\n        assertEquals(count[2], count[0]);\n\n        Arrays.fill(count, 0);\n        createExtractor().processBitMapPairs(createEmptyExtractor(), lbp);\n        assertEquals(count[2], count[1]);\n\n        // test where the created extractor does not process all records because the predicate function\n        // returns false before the processing is completed.\n        final int[] limit = new int[1];\n        final LongBiPredicate shortFunc =  (x, y) -> {\n            limit[0]++;\n            return limit[0] < 2;\n        };\n        final BitMapExtractor shortExtractor = l -> true;\n        assertFalse(createExtractor().processBitMapPairs(shortExtractor, shortFunc));\n    }\n\n    @Test\n    public void testForEachBitMapPairEarlyExit() {\n\n        // test BitMapExtractir of different length send 0 for missing values.\n        final int[] count = new int[1];\n        final LongBiPredicate lbp = (x, y) -> {\n            count[0]++;\n            return false;\n        };\n        createExtractor().processBitMapPairs(createEmptyExtractor(), lbp);\n        assertEquals(1, count[0]);\n\n        Arrays.fill(count, 0);\n        createEmptyExtractor().processBitMapPairs(createExtractor(), lbp);\n        assertEquals(1, count[0]);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static final LongPredicate FALSE_CONSUMER = arg0 -> false;", "docstring": "\nA testing consumer that always returns false.\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "LongPredicate", "name": "FALSE_CONSUMER = arg0 -> false", "syntax_pass": true}, {"attribute_expression": "static final LongPredicate TRUE_CONSUMER = arg0 -> true;", "docstring": "\nA testing consumer that always returns true.\n", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "LongPredicate", "name": "TRUE_CONSUMER = arg0 -> true", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java.AbstractHasherTest", "name": "AbstractHasherTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java", "superclasses": "AbstractIndexExtractorTest", "methods": ["[IndexExtractor]createEmptyExtractor()", "[Hasher]createEmptyHasher()", "[IndexExtractor]createExtractor()", "[Hasher]createHasher()", "[int]getHasherSize(Hasher)", "[Shape]getTestShape()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java.AbstractHasherTest.[IndexExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java.AbstractHasherTest.[Hasher]createEmptyHasher()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java.AbstractHasherTest.[IndexExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java.AbstractHasherTest.[Hasher]createHasher()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java.AbstractHasherTest.[int]getHasherSize(Hasher)", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractHasherTest.java.AbstractHasherTest.[Shape]getTestShape()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public abstract class AbstractHasherTest extends AbstractIndexExtractorTest {\n\n    @Override\n    protected IndexExtractor createEmptyExtractor() {\n        return createEmptyHasher().indices(getTestShape());\n    }\n\n    protected abstract Hasher createEmptyHasher();\n\n    @Override\n    protected IndexExtractor createExtractor() {\n        return createHasher().indices(getTestShape());\n    }\n\n    protected abstract Hasher createHasher();\n\n    /**\n     * A method to get the number of items in a hasher. Mostly applies to\n     * Collections of hashers.\n     * @param hasher the hasher to check.\n     * @return the number of hashers in the hasher\n     */\n    protected abstract int getHasherSize(Hasher hasher);\n\n    /**\n     * The shape of the Hashers filters for testing.\n     * <ul>\n     *  <li>Hash functions (k) = 17\n     *  <li>Number of bits (m) = 72\n     * </ul>\n     * @return the testing shape.\n     */\n    protected final Shape getTestShape() {\n        return Shape.fromKM(17, 72);\n    }\n\n    @ParameterizedTest\n    @CsvSource({\n        \"17, 72\",\n        \"3, 14\",\n        \"5, 67868\",\n        \"75, 10\"\n    })\n    public void testHashing(final int k, final int m) {\n        final int[] count = {0};\n        final Hasher hasher = createHasher();\n        hasher.indices(Shape.fromKM(k, m)).processIndices(i -> {\n            assertTrue(i >= 0 && i < m, () -> \"Out of range: \" + i + \", m=\" + m);\n            count[0]++;\n            return true;\n        });\n        assertEquals(k * getHasherSize(hasher), count[0],\n                () -> String.format(\"Did not produce k=%d * m=%d indices\", k, getHasherSize(hasher)));\n\n        // test early exit\n        count[0] = 0;\n        hasher.indices(Shape.fromKM(k, m)).processIndices(i -> {\n            assertTrue(i >= 0 && i < m, () -> \"Out of range: \" + i + \", m=\" + m);\n            count[0]++;\n            return false;\n        });\n        assertEquals(1, count[0], \"did not exit early\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellExtractorTest.java.AbstractCellExtractorTest", "name": "AbstractCellExtractorTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellExtractorTest.java", "superclasses": "AbstractIndexExtractorTest", "methods": ["[CellExtractor]createEmptyExtractor()", "[CellExtractor]createExtractor()", "[int]getAsIndexArrayBehaviour()", "[int[]]getExpectedValues()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellExtractorTest.java.AbstractCellExtractorTest.[CellExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellExtractorTest.java.AbstractCellExtractorTest.[CellExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellExtractorTest.java.AbstractCellExtractorTest.[int]getAsIndexArrayBehaviour()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractCellExtractorTest.java.AbstractCellExtractorTest.[int[]]getExpectedValues()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public abstract class AbstractCellExtractorTest extends AbstractIndexExtractorTest {\n\n    /**\n     * A testing CellConsumer that always returns true.\n     */\n    private static final CellPredicate TRUE_CONSUMER = (i, j) -> true;\n    /**\n     * A testing CellConsumer that always returns false.\n     */\n    private static final CellPredicate FALSE_CONSUMER = (i, j) -> false;\n\n    /**\n     * Creates a CellExtractor without data.\n     * @return a cell extractor that has no data.\n     */\n    @Override\n    protected abstract CellExtractor createEmptyExtractor();\n\n    /**\n     * Creates a CellExtractor with some data.\n     * @return a cell extractor with some data\n     */\n    @Override\n    protected abstract CellExtractor createExtractor();\n\n    @Override\n    protected final int getAsIndexArrayBehaviour() {\n        return ORDERED | DISTINCT;\n    }\n\n    /**\n     * Creates an array of expected values that aligns with the expected indices entries.\n     * @return an array of expected values.\n     * @see AbstractIndexExtractorTest#getExpectedIndices()\n     */\n    protected abstract int[] getExpectedValues();\n\n    /**\n     * Test the behavior of {@link CellExtractor#processCells(CellPredicate)} with respect\n     * to ordered and distinct indices. Currently the behavior is assumed to be the same as\n     * {@link IndexExtractor#processIndices(java.util.function.IntPredicate)}.\n     */\n    @Test\n    public final void testBehaviourForEachCell() {\n        final IntList list = new IntList();\n        createExtractor().processCells((i, j) -> list.add(i));\n        final int[] actual = list.toArray();\n        // check order\n        final int[] expected = Arrays.stream(actual).sorted().toArray();\n        assertArrayEquals(expected, actual);\n        // check distinct\n        final long count = Arrays.stream(actual).distinct().count();\n        assertEquals(count, actual.length);\n    }\n\n    @Test\n    public final void testEmptyCellExtractor() {\n        final CellExtractor empty = createEmptyExtractor();\n        final int[] ary = empty.asIndexArray();\n        assertEquals(0, ary.length);\n        assertTrue(empty.processCells((i, j) -> {\n            fail(\"forEachCell consumer should not be called\");\n            return false;\n        }));\n    }\n\n    @Test\n    public void testForEachCellEarlyExit() {\n        final int[] passes = new int[1];\n        assertTrue(createEmptyExtractor().processCells((i, j) -> {\n            passes[0]++;\n            return false;\n        }));\n        assertEquals(0, passes[0]);\n\n        assertFalse(createExtractor().processCells((i, j) -> {\n            passes[0]++;\n            return false;\n        }));\n        assertEquals(1, passes[0]);\n    }\n\n    @Test\n    public final void testForEachCellPredicates() {\n        final CellExtractor populated = createExtractor();\n        final CellExtractor empty = createEmptyExtractor();\n\n        assertFalse(populated.processCells(FALSE_CONSUMER), \"non-empty should be false\");\n        assertTrue(empty.processCells(FALSE_CONSUMER), \"empty should be true\");\n\n        assertTrue(populated.processCells(TRUE_CONSUMER), \"non-empty should be true\");\n        assertTrue(empty.processCells(TRUE_CONSUMER), \"empty should be true\");\n    }\n\n    @Test\n    public void testForEachCellValues() {\n        final int[] expectedIdx = getExpectedIndices();\n        final int[] expectedValue = getExpectedValues();\n        assertEquals(expectedIdx.length, expectedValue.length, \"expected index length and value length do not match\");\n        final int[] idx = {0};\n        createExtractor().processCells((i, j) -> {\n            assertEquals(expectedIdx[idx[0]], i, \"bad index at \" + idx[0]);\n            assertEquals(expectedValue[idx[0]], j, \"bad value at \" + idx[0]);\n            idx[0]++;\n            return true;\n        });\n    }\n\n    @Test\n    public final void testIndexConsistency() {\n        final CellExtractor extractor = createExtractor();\n        final BitSet bs1 = new BitSet();\n        final BitSet bs2 = new BitSet();\n        extractor.processIndices(i -> {\n            bs1.set(i);\n            return true;\n        });\n        extractor.processCells((i, j) -> {\n            bs2.set(i);\n            return true;\n        });\n        assertEquals(bs1, bs2);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final CellPredicate TRUE_CONSUMER = (i, j) -> true;", "docstring": "\nA testing CellConsumer that always returns true.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "CellPredicate", "name": "TRUE_CONSUMER = (i, j) -> true", "syntax_pass": true}, {"attribute_expression": "private static final CellPredicate FALSE_CONSUMER = (i, j) -> false;", "docstring": "\nA testing CellConsumer that always returns false.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "CellPredicate", "name": "FALSE_CONSUMER = (i, j) -> false", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexExtractorTest.java.AbstractIndexExtractorTest", "name": "AbstractIndexExtractorTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexExtractorTest.java", "superclasses": "", "methods": ["[IndexExtractor]createEmptyExtractor()", "[IndexExtractor]createExtractor()", "[int]getAsIndexArrayBehaviour()", "[int[]]getExpectedIndices()", "[int]getForEachIndexBehaviour()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexExtractorTest.java.AbstractIndexExtractorTest.[IndexExtractor]createEmptyExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexExtractorTest.java.AbstractIndexExtractorTest.[IndexExtractor]createExtractor()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexExtractorTest.java.AbstractIndexExtractorTest.[int]getAsIndexArrayBehaviour()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexExtractorTest.java.AbstractIndexExtractorTest.[int[]]getExpectedIndices()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractIndexExtractorTest.java.AbstractIndexExtractorTest.[int]getForEachIndexBehaviour()"], "overrides": null, "attributes": [{"original_string": "    protected static class IntList {\n        private int size;\n        private int[] data = {0};\n\n        /**\n         * Adds the value to the list.\n         *\n         * @param value the value\n         * @return true if the list was modified\n         */\n        boolean add(final int value) {\n            if (size == data.length) {\n                data = Arrays.copyOf(data, size << 1);\n            }\n            data[size++] = value;\n            return true;\n        }\n\n        /**\n         * Convert to an array.\n         *\n         * @return the array\n         */\n        int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n    }", "definition": "    protected static class IntList", "class_docstring": "\nAn expandable list of int values.\n", "name": "IntList", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "private int size;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}, {"attribute_expression": "private int[] data = {0};", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int[]", "name": "data = {0}", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        boolean add(final int value) {\n            if (size == data.length) {\n                data = Arrays.copyOf(data, size << 1);\n            }\n            data[size++] = value;\n            return true;\n        }", "docstring": "\nAdds the value to the list.\n\n@param value the value\n@return true if the list was modified\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "boolean", "classes": []}, "name": "add", "params": [{"name": "value", "type": "int"}], "body": "                                     {\n            if (size == data.length) {\n                data = Arrays.copyOf(data, size << 1);\n            }\n            data[size++] = value;\n            return true;\n        }", "signature": "boolean add(final int value)"}, {"syntax_pass": true, "original_string": "        int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }", "docstring": "\nConvert to an array.\n\n@return the array\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "int[]", "classes": []}, "name": "toArray", "params": [], "body": "                        {\n            return Arrays.copyOf(data, size);\n        }", "signature": "int[] toArray()"}]}], "class_docstring": "\nTest for IndexExtractor.\n", "original_string": "public abstract class AbstractIndexExtractorTest {\n\n    /**\n     * An expandable list of int values.\n     */\n    protected static class IntList {\n        private int size;\n        private int[] data = {0};\n\n        /**\n         * Adds the value to the list.\n         *\n         * @param value the value\n         * @return true if the list was modified\n         */\n        boolean add(final int value) {\n            if (size == data.length) {\n                data = Arrays.copyOf(data, size << 1);\n            }\n            data[size++] = value;\n            return true;\n        }\n\n        /**\n         * Convert to an array.\n         *\n         * @return the array\n         */\n        int[] toArray() {\n            return Arrays.copyOf(data, size);\n        }\n    }\n    private static final IntPredicate TRUE_PREDICATE = i -> true;\n\n    private static final IntPredicate FALSE_PREDICATE = i -> false;\n    /** Flag to indicate the indices are ordered, e.g. from {@link IndexExtractor#processIndices(IntPredicate)}. */\n    protected static final int ORDERED = 0x1;\n\n    /** Flag to indicate the indices are distinct, e.g. from {@link IndexExtractor#processIndices(IntPredicate)}. */\n    protected static final int DISTINCT = 0x2;\n\n    /**\n     * Creates an extractor without data.\n     * @return an IndexExtractor that has no data.\n     */\n    protected abstract IndexExtractor createEmptyExtractor();\n\n    /**\n     * Creates an extractor with some data.\n     * @return an IndexExtractor with some data\n     */\n    protected abstract IndexExtractor createExtractor();\n\n    /**\n     * Gets the behavior of the {@link IndexExtractor#asIndexArray()} method.\n     * @return the behavior.\n     * @see #ORDERED\n     * @see #DISTINCT\n     */\n    protected abstract int getAsIndexArrayBehaviour();\n\n    /**\n     * Creates an array of expected indices.\n     * The expected indices are dependent upon the extractor created in the {@code createExtractor()} method.\n     * @return an array of expected indices.\n     */\n    protected abstract int[] getExpectedIndices();\n\n    /**\n     * Gets the behavior of the {@link IndexExtractor#processIndices(IntPredicate)} method.\n     * By default returns the value of {@code getAsIndexArrayBehaviour()} method.\n     * @return the behavior.\n     * @see #ORDERED\n     * @see #DISTINCT\n     */\n    protected int getForEachIndexBehaviour() {\n        return getAsIndexArrayBehaviour();\n    }\n\n    /**\n     * Test to ensure that all expected values are generated at least once.\n     */\n    @Test\n    public final void testAsIndexArrayValues() {\n        final BitSet bs = new BitSet();\n        Arrays.stream(createExtractor().asIndexArray()).forEach(bs::set);\n        for (final int i : getExpectedIndices()) {\n            assertTrue(bs.get(i), () -> \"Missing \" + i);\n        }\n    }\n\n    /**\n     * Tests the behavior of {@code IndexExtractor.asIndexArray()}.\n     * The expected behavior is defined by the {@code getBehaviour()} method.\n     * The index array may be Ordered, Distinct or both.\n     * If the index array is not distinct then all elements returned by the {@code getExpectedIndices()}\n     * method, including duplicates, are expected to be returned by the {@code asIndexArray()} method.\n     */\n    @Test\n    public final void testBehaviourAsIndexArray() {\n        final int flags = getAsIndexArrayBehaviour();\n        final int[] actual = createExtractor().asIndexArray();\n        if ((flags & ORDERED) != 0) {\n            final int[] expected = Arrays.stream(actual).sorted().toArray();\n            assertArrayEquals(expected, actual);\n        }\n        if ((flags & DISTINCT) != 0) {\n            final long count = Arrays.stream(actual).distinct().count();\n            assertEquals(count, actual.length);\n        } else {\n            // if the array is not distinct all expected elements must be generated\n            // This is modified so use a copy\n            final int[] expected = getExpectedIndices().clone();\n            Arrays.sort(expected);\n            Arrays.sort(actual);\n            assertArrayEquals(expected, actual);\n        }\n    }\n\n    /**\n     * Tests the behavior of {@code IndexExtractor.forEachIndex()}.\n     * The expected behavior is defined by the {@code getBehaviour()} method.\n     * The order is assumed to follow the order produced by {@code IndexExtractor.asIndexArray()}.\n     */\n    @Test\n    public final void testBehaviourForEachIndex() {\n        final int flags = getForEachIndexBehaviour();\n        final IntList list = new IntList();\n        createExtractor().processIndices(list::add);\n        final int[] actual = list.toArray();\n        if ((flags & ORDERED) != 0) {\n            final int[] expected = Arrays.stream(actual).sorted().toArray();\n            assertArrayEquals(expected, actual);\n        }\n        if ((flags & DISTINCT) != 0) {\n            final long count = Arrays.stream(actual).distinct().count();\n            assertEquals(count, actual.length);\n        } else {\n            // if forEach is not distinct all expected elements must be generated\n            final int[] expected = getExpectedIndices().clone();\n            Arrays.sort(expected);\n            Arrays.sort(actual);\n            assertArrayEquals(expected, actual);\n        }\n    }\n\n    /**\n     * Test the distinct indices output from the extractor are consistent.\n     */\n    @Test\n    public final void testConsistency() {\n        final IndexExtractor extractor = createExtractor();\n        final BitSet bs1 = new BitSet();\n        final BitSet bs2 = new BitSet();\n        Arrays.stream(extractor.asIndexArray()).forEach(bs1::set);\n        extractor.processIndices(i -> {\n            bs2.set(i);\n            return true;\n        });\n        assertEquals(bs1, bs2);\n    }\n\n    @Test\n    public final void testEmptyExtractor() {\n        final IndexExtractor empty = createEmptyExtractor();\n        final int[] ary = empty.asIndexArray();\n        assertEquals(0, ary.length);\n        assertTrue(empty.processIndices(i -> {\n            throw new AssertionError(\"processIndices predictate should not be called\");\n        }));\n    }\n\n    /**\n     * Test to ensure that processIndices returns each expected index at least once.\n     */\n    @Test\n    public final void testForEachIndex() {\n        final BitSet bs1 = new BitSet();\n        final BitSet bs2 = new BitSet();\n        Arrays.stream(getExpectedIndices()).forEach(bs1::set);\n        createExtractor().processIndices(i -> {\n            bs2.set(i);\n            return true;\n        });\n        assertEquals(bs1, bs2);\n    }\n\n    @Test\n    public void testForEachIndexEarlyExit() {\n        final int[] passes = new int[1];\n        assertFalse(createExtractor().processIndices(i -> {\n            passes[0]++;\n            return false;\n        }));\n        assertEquals(1, passes[0]);\n\n        passes[0] = 0;\n        assertTrue(createEmptyExtractor().processIndices(i -> {\n            passes[0]++;\n            return false;\n        }));\n        assertEquals(0, passes[0]);\n    }\n\n    @Test\n    public final void testForEachIndexPredicates() {\n        final IndexExtractor populated = createExtractor();\n        final IndexExtractor empty = createEmptyExtractor();\n\n        assertFalse(populated.processIndices(FALSE_PREDICATE), \"non-empty should be false\");\n        assertTrue(empty.processIndices(FALSE_PREDICATE), \"empty should be true\");\n\n        assertTrue(populated.processIndices(TRUE_PREDICATE), \"non-empty should be true\");\n        assertTrue(empty.processIndices(TRUE_PREDICATE), \"empty should be true\");\n    }\n\n    @Test\n    public void testUniqueReturnsSelf() {\n        final IndexExtractor expected = createExtractor().uniqueIndices();\n        assertSame(expected, expected.uniqueIndices());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final IntPredicate TRUE_PREDICATE = i -> true;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "IntPredicate", "name": "TRUE_PREDICATE = i -> true", "syntax_pass": true}, {"attribute_expression": "private static final IntPredicate FALSE_PREDICATE = i -> false;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "IntPredicate", "name": "FALSE_PREDICATE = i -> false", "syntax_pass": true}, {"attribute_expression": "protected static final int ORDERED = 0x1;", "docstring": " Flag to indicate the indices are ordered, e.g. from {@link IndexExtractor#processIndices(IntPredicate)}.", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "int", "name": "ORDERED = 0x1", "syntax_pass": true}, {"attribute_expression": "protected static final int DISTINCT = 0x2;", "docstring": " Flag to indicate the indices are distinct, e.g. from {@link IndexExtractor#processIndices(IntPredicate)}.", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "int", "name": "DISTINCT = 0x2", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterExtractorTest.java.AbstractBloomFilterExtractorTest", "name": "AbstractBloomFilterExtractorTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterExtractorTest.java", "superclasses": "", "methods": ["[BloomFilterExtractor]createUnderTest()", "[BloomFilterExtractor]createUnderTest()", "[Shape]getTestShape()", "[void]setup()"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterExtractorTest.java.AbstractBloomFilterExtractorTest.[BloomFilterExtractor]createUnderTest()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterExtractorTest.java.AbstractBloomFilterExtractorTest.[BloomFilterExtractor]createUnderTest()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterExtractorTest.java.AbstractBloomFilterExtractorTest.[Shape]getTestShape()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterExtractorTest.java.AbstractBloomFilterExtractorTest.[void]setup()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public abstract class AbstractBloomFilterExtractorTest {\n    private final Shape shape = Shape.fromKM(17, 72);\n\n    BloomFilter one = new SimpleBloomFilter(shape);\n    BloomFilter two = new SimpleBloomFilter(shape);\n    int[] nullCount = { 0, 0 };\n    int[] equalityCount = { 0 };\n    BiPredicate<BloomFilter, BloomFilter> counter = (x, y) -> {\n        if (x == null) {\n            nullCount[0]++;\n        }\n        if (y == null) {\n            nullCount[1]++;\n        }\n        if (x != null && y != null && x.cardinality() == y.cardinality()) {\n            equalityCount[0]++;\n        }\n        return true;\n    };\n\n    private BloomFilterExtractor createUnderTest() {\n        return createUnderTest(one, two);\n    }\n\n    /**\n     * Creates a BloomFilterExtractor that returns the filters (or their copy) in the order presented.\n     * @param filters The filters to return.\n     * @return A BloomFilterExtractor that returns the filters in order.\n     */\n    protected abstract BloomFilterExtractor createUnderTest(BloomFilter... filters);\n\n    /**\n     * The shape of the Bloom filters for testing.\n     * <ul>\n     *  <li>Hash functions (k) = 17\n     *  <li>Number of bits (m) = 72\n     * </ul>\n     * @return the testing shape.\n     */\n    protected Shape getTestShape() {\n        return shape;\n    }\n\n    @BeforeEach\n    public void setup() {\n        one.clear();\n        one.merge(IndexExtractor.fromIndexArray(1));\n        two.clear();\n        two.merge(IndexExtractor.fromIndexArray(2, 3));\n        nullCount[0] = 0;\n        nullCount[1] = 0;\n        equalityCount[0] = 0;\n    }\n\n    @Test\n    public void testAsBloomFilterArray() {\n        final BloomFilter[] result = createUnderTest().asBloomFilterArray();\n        assertEquals(2, result.length);\n        assertEquals(1, result[0].cardinality());\n        assertEquals(2, result[1].cardinality());\n    }\n\n    @Test\n    public void testFlatten() {\n        final BloomFilter underTest = createUnderTest().flatten();\n        final BloomFilter expected = new SimpleBloomFilter(shape);\n        expected.merge(IndexExtractor.fromIndexArray(1, 2, 3));\n        assertArrayEquals(expected.asBitMapArray(), underTest.asBitMapArray());\n    }\n\n    @Test\n    public void testForEachPairArrayTooLong() {\n        assertTrue(createUnderTest().processBloomFilterPair(BloomFilterExtractor.fromBloomFilterArray(one, two, one),\n                counter));\n        assertEquals(1, nullCount[0]);\n        assertEquals(0, nullCount[1]);\n        assertEquals(2, equalityCount[0]);\n    }\n\n    @Test\n    public void testForEachPairArrayTooShort() {\n        assertTrue(createUnderTest().processBloomFilterPair(BloomFilterExtractor.fromBloomFilterArray(one), counter));\n        assertEquals(0, nullCount[0]);\n        assertEquals(1, nullCount[1]);\n        assertEquals(1, equalityCount[0]);\n    }\n\n    @Test\n    public void testForEachPairCompleteMatch() {\n        assertTrue(createUnderTest().processBloomFilterPair(createUnderTest(), counter));\n        assertArrayEquals(new int[] { 0, 0 }, nullCount);\n        assertEquals(2, equalityCount[0]);\n    }\n\n    @Test\n    public void testForEachPairReturnFalseEarly() {\n        assertFalse(createUnderTest().processBloomFilterPair(BloomFilterExtractor.fromBloomFilterArray(one, two, one),\n                (x, y) -> false));\n    }\n\n    @Test\n    public void testForEachPairReturnFalseLate() {\n        assertFalse(createUnderTest().processBloomFilterPair(BloomFilterExtractor.fromBloomFilterArray(one, two, one),\n                counter.and((x, y) -> x != null && y != null)));\n        assertEquals(1, nullCount[0]);\n        assertEquals(0, nullCount[1]);\n        assertEquals(2, equalityCount[0]);\n    }\n\n    @Test\n    public void testForEachPairReturnFalseLateShortArray() {\n        assertFalse(createUnderTest().processBloomFilterPair(BloomFilterExtractor.fromBloomFilterArray(one),\n                counter.and((x, y) -> x != null && y != null)));\n        assertEquals(0, nullCount[0]);\n        assertEquals(1, nullCount[1]);\n        assertEquals(1, equalityCount[0]);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Shape shape = Shape.fromKM(17, 72);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Shape", "name": "shape = Shape.fromKM(17, 72)", "syntax_pass": true}, {"attribute_expression": "BloomFilter one = new SimpleBloomFilter(shape);", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "BloomFilter", "name": "one = new SimpleBloomFilter(shape)", "syntax_pass": true}, {"attribute_expression": "BloomFilter two = new SimpleBloomFilter(shape);", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "BloomFilter", "name": "two = new SimpleBloomFilter(shape)", "syntax_pass": true}, {"attribute_expression": "int[] nullCount = { 0, 0 };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int[]", "name": "nullCount = { 0, 0 }", "syntax_pass": true}, {"attribute_expression": "int[] equalityCount = { 0 };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int[]", "name": "equalityCount = { 0 }", "syntax_pass": true}, {"attribute_expression": "BiPredicate<BloomFilter, BloomFilter> counter = (x, y) -> {\n        if (x == null) {\n            nullCount[0]++;\n        }\n        if (y == null) {\n            nullCount[1]++;\n        }\n        if (x != null && y != null && x.cardinality() == y.cardinality()) {\n            equalityCount[0]++;\n        }\n        return true;\n    };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "BiPredicate<BloomFilter, BloomFilter>", "name": "counter = (x, y) -> {\n        if (x == null) {\n            nullCount[0]++;\n        }\n        if (y == null) {\n            nullCount[1]++;\n        }\n        if (x != null && y != null && x.cardinality() == y.cardinality()) {\n            equalityCount[0]++;\n        }\n        return true;\n    }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java.AbstractBloomFilterTest", "name": "AbstractBloomFilterTest", "file_path": "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java", "superclasses": "", "methods": ["[void]assertFailedIndexExtractorConstructor(Shape,int[])", "[void]assertIndexExtractorMerge(Shape,int[],int[])", "[T]createEmptyFilter(Shape)", "[T]createFilter(Shape,BitMapExtractor)", "[T]createFilter(Shape,Hasher)", "[T]createFilter(Shape,IndexExtractor)", "[Shape]getTestShape()", "[void]testCardinalityAndIsEmpty(BloomFilter)"], "method_uris": ["src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java.AbstractBloomFilterTest.[void]assertFailedIndexExtractorConstructor(Shape,int[])", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java.AbstractBloomFilterTest.[void]assertIndexExtractorMerge(Shape,int[],int[])", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java.AbstractBloomFilterTest.[T]createEmptyFilter(Shape)", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java.AbstractBloomFilterTest.[T]createFilter(Shape,BitMapExtractor)", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java.AbstractBloomFilterTest.[T]createFilter(Shape,Hasher)", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java.AbstractBloomFilterTest.[T]createFilter(Shape,IndexExtractor)", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java.AbstractBloomFilterTest.[Shape]getTestShape()", "src/test/java/org/apache/commons/collections4/bloomfilter/AbstractBloomFilterTest.java.AbstractBloomFilterTest.[void]testCardinalityAndIsEmpty(BloomFilter)"], "overrides": null, "attributes": [{"original_string": "    public static class BadHasher implements Hasher {\n\n        IndexExtractor extractor;\n\n        public BadHasher(final int value) {\n            this.extractor = IndexExtractor.fromIndexArray(value);\n        }\n\n        @Override\n        public IndexExtractor indices(final Shape shape) {\n            return extractor;\n        }\n    }", "definition": "    public static class BadHasher implements Hasher", "class_docstring": "\nTesting class returns the value as the only value.\n", "name": "BadHasher", "super_interfaces": ["Hasher"], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "IndexExtractor extractor;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "IndexExtractor", "name": "extractor", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public BadHasher(final int value) {\n            this.extractor = IndexExtractor.fromIndexArray(value);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "BadHasher", "params": [{"name": "value", "type": "int"}], "body": "                                          {\n            this.extractor = IndexExtractor.fromIndexArray(value);\n        }", "signature": "public BadHasher(final int value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public IndexExtractor indices(final Shape shape) {\n            return extractor;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "IndexExtractor", "classes": []}, "name": "indices", "params": [{"name": "shape", "type": "Shape"}], "body": "                                                         {\n            return extractor;\n        }", "signature": "@Override\n        public IndexExtractor indices(final Shape shape)"}]}], "class_docstring": "\nTest standard methods in the {@link BloomFilter} interface.\n", "original_string": "public abstract class AbstractBloomFilterTest<T extends BloomFilter> {\n\n    /**\n     * Testing class returns the value as the only value.\n     */\n    public static class BadHasher implements Hasher {\n\n        IndexExtractor extractor;\n\n        public BadHasher(final int value) {\n            this.extractor = IndexExtractor.fromIndexArray(value);\n        }\n\n        @Override\n        public IndexExtractor indices(final Shape shape) {\n            return extractor;\n        }\n    }\n\n    private void assertFailedIndexExtractorConstructor(final Shape shape, final int[] values) {\n        final IndexExtractor indices = IndexExtractor.fromIndexArray(values);\n        assertThrows(IllegalArgumentException.class, () -> createFilter(shape, indices));\n    }\n\n    private void assertIndexExtractorMerge(final Shape shape, final int[] values, final int[] expected) {\n        final IndexExtractor indices = IndexExtractor.fromIndexArray(values);\n        final BloomFilter filter = createFilter(shape, indices);\n        final List<Integer> lst = new ArrayList<>();\n        filter.processIndices(x -> {\n            lst.add(x);\n            return true;\n        });\n        assertEquals(expected.length, lst.size());\n        for (final int value : expected) {\n            assertTrue(lst.contains(Integer.valueOf(value)), \"Missing \" + value);\n        }\n    }\n\n    /**\n     * Create an empty version of the BloomFilter implementation we are testing.\n     *\n     * @param shape the shape of the filter.\n     * @return a BloomFilter implementation.\n     */\n    protected abstract T createEmptyFilter(Shape shape);\n\n    /**\n     * Create the BloomFilter implementation we are testing.\n     *\n     * @param shape the shape of the filter.\n     * @param extractor A BitMap extractor to build the filter with.\n     * @return a BloomFilter implementation.\n     */\n    protected final T createFilter(final Shape shape, final BitMapExtractor extractor) {\n        final T bf = createEmptyFilter(shape);\n        bf.merge(extractor);\n        return bf;\n    }\n\n    /**\n     * Create the BloomFilter implementation we are testing.\n     *\n     * @param shape the shape of the filter.\n     * @param hasher the hasher to use to create the filter.\n     * @return a BloomFilter implementation.\n     */\n    protected final T createFilter(final Shape shape, final Hasher hasher) {\n        final T bf = createEmptyFilter(shape);\n        bf.merge(hasher);\n        return bf;\n    }\n\n    /**\n     * Create the BloomFilter implementation we are testing.\n     *\n     * @param shape the shape of the filter.\n     * @param extractor An Index extractor to build the filter with.\n     * @return a BloomFilter implementation.\n     */\n    protected final T createFilter(final Shape shape, final IndexExtractor extractor) {\n        final T bf = createEmptyFilter(shape);\n        bf.merge(extractor);\n        return bf;\n    }\n\n    /**\n     * The shape of the Bloom filters for testing.\n     * <ul>\n     *  <li>Hash functions (k) = 17\n     *  <li>Number of bits (m) = 72\n     * </ul>\n     * @return the testing shape.\n     */\n    protected Shape getTestShape() {\n        return Shape.fromKM(17, 72);\n    }\n\n    /**\n     * Tests that asBitMapArray works correctly.\n     */\n    @Test\n    public final void testAsBitMapArray() {\n\n        // test when multiple long values are returned.\n        final IncrementingHasher hasher = new IncrementingHasher(63, 1);\n        final BloomFilter bf = createFilter(Shape.fromKM(2, 72), hasher);\n        final long[] lb = bf.asBitMapArray();\n        assertEquals(2, lb.length);\n        assertEquals(0x8000000000000000L, lb[0]);\n        assertEquals(0x1, lb[1]);\n    }\n\n    @Test\n    public void testBitMapExtractorSize() {\n        final int[] idx = new int[1];\n        createFilter(getTestShape(), TestingHashers.FROM1).processBitMaps(i -> {\n            idx[0]++;\n            return true;\n        });\n        assertEquals(BitMaps.numberOfBitMaps(getTestShape().getNumberOfBits()), idx[0]);\n\n        idx[0] = 0;\n        createEmptyFilter(getTestShape()).processBitMaps(i -> {\n            idx[0]++;\n            return true;\n        });\n        assertEquals(BitMaps.numberOfBitMaps(getTestShape().getNumberOfBits()), idx[0]);\n    }\n\n    @Test\n    public void testCardinalityAndIsEmpty() {\n        testCardinalityAndIsEmpty(createEmptyFilter(getTestShape()));\n    }\n\n    /**\n     * Test cardinality and isEmpty. Bloom filter must be able to accept multiple\n     * IndexExtractor merges until all the bits are populated.\n     *\n     * @param bf The Bloom filter to test.\n     */\n    protected void testCardinalityAndIsEmpty(final BloomFilter bf) {\n        assertTrue(bf.isEmpty());\n        assertEquals(0, bf.cardinality());\n        for (int i = 0; i < getTestShape().getNumberOfBits(); i++) {\n            bf.merge(IndexExtractor.fromIndexArray(i));\n            assertFalse(bf.isEmpty(), \"Wrong value at \" + i);\n            assertEquals(i + 1, bf.cardinality(), \"Wrong value at \" + i);\n        }\n\n        // check operations in reverse order\n        bf.clear();\n        assertEquals(0, bf.cardinality());\n        assertTrue(bf.isEmpty());\n        for (int i = 0; i < getTestShape().getNumberOfBits(); i++) {\n            bf.merge(IndexExtractor.fromIndexArray(i));\n            assertEquals(i + 1, bf.cardinality(), \"Wrong value at \" + i);\n            assertFalse(bf.isEmpty(), \"Wrong value at \" + i);\n        }\n    }\n    @Test\n    public void testClear() {\n        final BloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n        assertNotEquals(0, bf1.cardinality());\n        bf1.clear();\n        assertEquals(0, bf1.cardinality());\n    }\n\n    @Test\n    public final void testContains() {\n        BloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n        final BloomFilter bf2 = TestingHashers.populateFromHashersFrom1AndFrom11(createEmptyFilter(getTestShape()));\n\n        assertTrue(bf1.contains(bf1), \"BF1 Should contain itself\");\n        assertTrue(bf2.contains(bf2), \"BF2 Should contain itself\");\n        assertFalse(bf1.contains(bf2), \"BF1 should not contain BF2\");\n        assertTrue(bf2.contains(bf1), \"BF2 should contain BF1\");\n\n        assertTrue(bf2.contains(new IncrementingHasher(1, 1)), \"BF2 Should contain this hasher\");\n        assertFalse(bf2.contains(new IncrementingHasher(1, 3)), \"BF2 Should not contain this hasher\");\n\n        IndexExtractor indexExtractor = new IncrementingHasher(1, 1).indices(getTestShape());\n        assertTrue(bf2.contains(indexExtractor), \"BF2 Should contain this hasher\");\n        indexExtractor = new IncrementingHasher(1, 3).indices(getTestShape());\n        assertFalse(bf2.contains(indexExtractor), \"BF2 Should not contain this hasher\");\n\n        BitMapExtractor bitMapExtractor = BitMapExtractor.fromIndexExtractor(new IncrementingHasher(1, 1).indices(getTestShape()),\n                getTestShape().getNumberOfBits());\n        assertTrue(bf2.contains(bitMapExtractor), \"BF2 Should contain this hasher\");\n        bitMapExtractor = BitMapExtractor.fromIndexExtractor(new IncrementingHasher(1, 3).indices(getTestShape()), getTestShape().getNumberOfBits());\n        assertFalse(bf2.contains(bitMapExtractor), \"BF2 Should not contain this hasher\");\n\n        // Test different lengths\n        bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n        final BloomFilter bf3 = createFilter(Shape.fromKM(getTestShape().getNumberOfHashFunctions(), Long.SIZE - 1), TestingHashers.FROM1);\n        assertTrue(bf1.contains(bf3));\n        assertTrue(bf3.contains(bf1));\n\n        final BloomFilter bf4 = TestingHashers.populateRange(createEmptyFilter(Shape.fromKM(getTestShape().getNumberOfHashFunctions(), Long.SIZE - 1)), 1,\n                11 + getTestShape().getNumberOfHashFunctions());\n\n        assertFalse(bf1.contains(bf4));\n        assertTrue(bf4.contains(bf1));\n    }\n\n    @Test\n    public void testEmptyAfterMergeWithNothing() {\n        // test the case where is empty after merge\n        // in this case the internal cardinality == -1\n        final BloomFilter bf = createEmptyFilter(getTestShape());\n        bf.merge(IndexExtractor.fromIndexArray());\n        assertTrue(bf.isEmpty());\n    }\n\n    /**\n     * Tests that the estimated intersection calculations are correct.\n     */\n    @Test\n    public final void testEstimateIntersection() {\n        final BloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);\n        final BloomFilter bf2 = TestingHashers.populateFromHashersFrom1AndFrom11(createEmptyFilter(getTestShape()));\n\n        final BloomFilter bf3 = TestingHashers.populateEntireFilter(createEmptyFilter(getTestShape()));\n\n        assertEquals(1, bf.estimateIntersection(bf2));\n        assertEquals(1, bf2.estimateIntersection(bf));\n        assertEquals(1, bf.estimateIntersection(bf3));\n        assertEquals(1, bf2.estimateIntersection(bf));\n        assertEquals(2, bf3.estimateIntersection(bf2));\n\n        final BloomFilter bf4 = createEmptyFilter(getTestShape());\n\n        assertEquals(0, bf.estimateIntersection(bf4));\n        assertEquals(0, bf4.estimateIntersection(bf));\n\n        final int midPoint = getTestShape().getNumberOfBits() / 2;\n        final BloomFilter bf5 = TestingHashers.populateRange(createEmptyFilter(getTestShape()), 0, midPoint);\n        final BloomFilter bf6 = TestingHashers.populateRange(createEmptyFilter(getTestShape()), midPoint + 1, getTestShape().getNumberOfBits() - 1);\n        assertThrows(IllegalArgumentException.class, () -> bf5.estimateIntersection(bf6));\n\n        // infinite with infinite\n        assertEquals(Integer.MAX_VALUE, bf3.estimateIntersection(bf3));\n    }\n\n    /**\n     * Tests that the size estimate is correctly calculated.\n     */\n    @Test\n    public final void testEstimateN() {\n        // build a filter\n        BloomFilter filter1 = createFilter(getTestShape(), TestingHashers.FROM1);\n        assertEquals(1, filter1.estimateN());\n\n        // the data provided above do not generate an estimate that is equivalent to the\n        // actual.\n        filter1.merge(new IncrementingHasher(4, 1));\n        assertEquals(1, filter1.estimateN());\n\n        filter1.merge(new IncrementingHasher(17, 1));\n\n        assertEquals(3, filter1.estimateN());\n\n        filter1 = TestingHashers.populateEntireFilter(createEmptyFilter(getTestShape()));\n        assertEquals(Integer.MAX_VALUE, filter1.estimateN());\n    }\n\n    /**\n     * Tests that the estimated union calculations are correct.\n     */\n    @Test\n    public final void testEstimateUnion() {\n        final BloomFilter bf = createFilter(getTestShape(), TestingHashers.FROM1);\n        final BloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM11);\n\n        assertEquals(2, bf.estimateUnion(bf2));\n        assertEquals(2, bf2.estimateUnion(bf));\n\n        final BloomFilter bf3 = createEmptyFilter(getTestShape());\n\n        assertEquals(1, bf.estimateUnion(bf3));\n        assertEquals(1, bf3.estimateUnion(bf));\n    }\n\n    @Test\n    public void testIndexExtractorMerge() {\n        final Shape shape = Shape.fromKM(5, 10);\n\n        assertIndexExtractorMerge(shape, new int[] {0, 2, 4, 6, 8}, new int[] {0, 2, 4, 6, 8});\n        // test duplicate values\n        assertIndexExtractorMerge(shape, new int[] {0, 2, 4, 2, 8}, new int[] {0, 2, 4, 8});\n        // test negative values\n        assertFailedIndexExtractorConstructor(shape, new int[] {0, 2, 4, -2, 8});\n        // test index too large\n        assertFailedIndexExtractorConstructor(shape, new int[] {0, 2, 4, 12, 8});\n        // test no indices\n        assertIndexExtractorMerge(shape, new int[0], new int[0]);\n    }\n\n    /**\n     * Tests that isFull() returns the proper values.\n     */\n    @Test\n    public final void testIsFull() {\n\n        // create empty filter\n        BloomFilter filter = createEmptyFilter(getTestShape());\n        assertFalse(filter.isFull(), \"Should not be full\");\n\n        filter = TestingHashers.populateEntireFilter(filter);\n        assertTrue(filter.isFull(), \"Should be full\");\n\n        filter = createFilter(getTestShape(), new IncrementingHasher(1, 3));\n        assertFalse(filter.isFull(), \"Should not be full\");\n    }\n\n    /**\n     * Tests that merging bloom filters works as expected with a generic BloomFilter.\n     */\n    @Test\n    public final void testMerge() {\n\n        final BloomFilter bf1 = createFilter(getTestShape(), TestingHashers.FROM1);\n        final BloomFilter bf2 = createFilter(getTestShape(), TestingHashers.FROM11);\n        final BloomFilter bf3 = bf1.copy();\n        bf3.merge(bf2);\n\n        // test with BloomFilter\n\n        final long[] bf1Val = bf1.asBitMapArray();\n        final long[] bf2Val = bf2.asBitMapArray();\n        for (int i = 0; i < bf1Val.length; i++) {\n            bf1Val[i] |= bf2Val[i];\n        }\n        bf1.merge(bf2);\n\n        final long[] bf1New = bf1.asBitMapArray();\n        for (int i = 0; i < bf1Val.length; i++) {\n            assertEquals(bf1Val[i], bf1New[i], \"Bad value at \" + i);\n        }\n\n        assertTrue(bf1.contains(bf2), \"Should contain bf2\");\n        assertTrue(bf1.contains(bf3), \"Should contain bf3\");\n\n        // test with hasher\n\n        final BloomFilter bf4 = createFilter(getTestShape(), TestingHashers.FROM1);\n        bf4.merge(TestingHashers.FROM11);\n\n        assertTrue(bf4.contains(bf2), \"Should contain Bf2\");\n        assertTrue(bf4.contains(bf3), \"Should contain Bf3\");\n\n        // test with hasher returning numbers out of range\n        assertThrows(IllegalArgumentException.class,\n                () -> bf1.merge(new BadHasher(bf1.getShape().getNumberOfBits())));\n        assertThrows(IllegalArgumentException.class, () -> bf1.merge(new BadHasher(-1)));\n\n        // test error when bloom filter returns values out of range\n        final Shape s = Shape.fromKM(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits() * 3);\n        final Hasher h = new IncrementingHasher(getTestShape().getNumberOfBits() * 2, 1);\n        final BloomFilter bf5 = new SimpleBloomFilter(s);\n        bf5.merge(h);\n        assertThrows(IllegalArgumentException.class, () -> bf1.merge(bf5));\n\n        final BloomFilter bf6 = new SparseBloomFilter(s);\n        bf6.merge(h);\n        assertThrows(IllegalArgumentException.class, () -> bf1.merge(bf6));\n    }\n\n    @Test\n    public void testMergeWithBadHasher() {\n        // value too large\n        final BloomFilter f = createEmptyFilter(getTestShape());\n        assertThrows(IllegalArgumentException.class,\n                () -> f.merge(new BadHasher(getTestShape().getNumberOfBits())));\n        // negative value\n        final BloomFilter f2 = createEmptyFilter(getTestShape());\n        assertThrows(IllegalArgumentException.class, () -> f2.merge(new BadHasher(-1)));\n    }\n\n    @Test\n    public void testMergeWithBitMapExtractor() {\n        final int bitMapCount = BitMaps.numberOfBitMaps(getTestShape().getNumberOfBits());\n        for (int i = 0; i < 5; i++) {\n            final long[] values = new long[bitMapCount];\n            for (final int idx : DefaultIndexExtractorTest.generateIntArray(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits())) {\n                BitMaps.set(values, idx);\n            }\n            final BloomFilter f = createFilter(getTestShape(), BitMapExtractor.fromBitMapArray(values));\n            final List<Long> lst = new ArrayList<>();\n            for (final long l : values) {\n                lst.add(l);\n            }\n            assertTrue(f.processBitMaps(l -> lst.remove(Long.valueOf(l))));\n            assertTrue(lst.isEmpty());\n        }\n        // values too large\n        final long[] values = new long[bitMapCount];\n        Arrays.fill(values, Long.MAX_VALUE);\n        final BitMapExtractor badExtractor = BitMapExtractor.fromBitMapArray(values);\n        final BloomFilter bf = createEmptyFilter(getTestShape());\n        assertThrows(IllegalArgumentException.class, () -> bf.merge(badExtractor));\n\n        // test where merged bits exceed expected bits but both bitmaps are the same length.\n        final BitMapExtractor badExtractor2 = BitMapExtractor.fromBitMapArray(0x80_00_00_00_00_00_00_00L);\n        final BloomFilter bf2 = createEmptyFilter(Shape.fromKM(3, 32));\n        assertThrows(IllegalArgumentException.class, () -> bf2.merge(badExtractor2));\n    }\n\n    @Test\n    public void testMergeWithHasher() {\n        for (int i = 0; i < 5; i++) {\n            final BloomFilter f = createEmptyFilter(getTestShape());\n            final int[] expected = DefaultIndexExtractorTest.generateIntArray(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits());\n            final Hasher hasher = new ArrayHasher(expected);\n            f.merge(hasher);\n            // create sorted unique array of expected values\n            assertArrayEquals(DefaultIndexExtractorTest.unique(expected), f.asIndexArray());\n        }\n    }\n\n    @Test\n    public void testMergeWithIndexExtractor() {\n        for (int i = 0; i < 5; i++) {\n            final int[] values = DefaultIndexExtractorTest.generateIntArray(getTestShape().getNumberOfHashFunctions(), getTestShape().getNumberOfBits());\n            final BloomFilter f = createFilter(getTestShape(), IndexExtractor.fromIndexArray(values));\n            final BitSet uniqueValues = DefaultIndexExtractorTest.uniqueSet(values);\n            assertTrue(f.processIndices(idx -> {\n                final boolean result = uniqueValues.get(idx);\n                uniqueValues.clear(idx);\n                return result;\n            }));\n            assertTrue(uniqueValues.isEmpty());\n        }\n        // value to large\n        final BloomFilter f1 = createEmptyFilter(getTestShape());\n        assertThrows(IllegalArgumentException.class,\n                () -> f1.merge(IndexExtractor.fromIndexArray(getTestShape().getNumberOfBits())));\n        // negative value\n        final BloomFilter f2 = createEmptyFilter(getTestShape());\n        assertThrows(IllegalArgumentException.class,\n                () -> f2.merge(IndexExtractor.fromIndexArray(-1)));\n    }\n\n    @Test\n    public final void testNegativeIntersection() {\n        final IndexExtractor p1 = IndexExtractor.fromIndexArray(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 20, 26, 28, 30, 32, 34, 35, 36, 37, 39, 40, 41, 42, 43, 45, 46, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71);\n        final IndexExtractor p2 = IndexExtractor.fromIndexArray(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27);\n\n        final BloomFilter filter1 = createEmptyFilter(Shape.fromKM(17, 72));\n        filter1.merge(p1);\n        final BloomFilter filter2 = createEmptyFilter(Shape.fromKM(17, 72));\n        filter2.merge(p2);\n        assertEquals(0, filter1.estimateIntersection(filter2));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest", "name": "AbstractMultiValuedMapTest", "file_path": "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java", "superclasses": "AbstractObjectTest", "methods": ["[]AbstractMultiValuedMapTest(String)", "[void]addSampleMappings(MultiValuedMap<? super K, ? super V>)", "[BulkTest]bulkTestAsMap()", "[BulkTest]bulkTestMultiValuedMapEntries()", "[BulkTest]bulkTestMultiValuedMapKeys()", "[BulkTest]bulkTestMultiValuedMapKeySet()", "[BulkTest]bulkTestMultiValuedMapValues()", "[String]getCompatibilityVersion()", "[MultiValuedMap<K, V>]getConfirmed()", "[int]getIterationBehaviour()", "[MultiValuedMap<K, V>]getMap()", "[int]getSampleCountPerKey()", "[K[]]getSampleKeys()", "[int]getSampleKeySize()", "[int]getSampleTotalValueCount()", "[V[]]getSampleValues()", "[boolean]isAddSupported()", "[boolean]isAllowNullKey()", "[boolean]isHashSetValue()", "[boolean]isRemoveSupported()", "[boolean]isTestSerialization()", "[MultiValuedMap<K, V>]makeConfirmedMap()", "[MultiValuedMap<K, V>]makeFullMap()", "[E]makeKey(int)", "[MultiValuedMap<K, V>]makeObject()", "[E]makeValue(int,int)", "[void]resetEmpty()", "[void]resetFull()", "[void]setConfirmed(MultiValuedMap<K, V>)"], "method_uris": ["src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[]AbstractMultiValuedMapTest(String)", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[void]addSampleMappings(MultiValuedMap<? super K, ? super V>)", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[BulkTest]bulkTestAsMap()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[BulkTest]bulkTestMultiValuedMapEntries()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[BulkTest]bulkTestMultiValuedMapKeys()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[BulkTest]bulkTestMultiValuedMapKeySet()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[BulkTest]bulkTestMultiValuedMapValues()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[String]getCompatibilityVersion()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[MultiValuedMap<K, V>]getConfirmed()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[int]getIterationBehaviour()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[MultiValuedMap<K, V>]getMap()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[int]getSampleCountPerKey()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[K[]]getSampleKeys()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[int]getSampleKeySize()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[int]getSampleTotalValueCount()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[V[]]getSampleValues()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[boolean]isAddSupported()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[boolean]isAllowNullKey()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[boolean]isHashSetValue()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[boolean]isRemoveSupported()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[boolean]isTestSerialization()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[MultiValuedMap<K, V>]makeConfirmedMap()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[MultiValuedMap<K, V>]makeFullMap()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[E]makeKey(int)", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[MultiValuedMap<K, V>]makeObject()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[E]makeValue(int,int)", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[void]resetEmpty()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[void]resetFull()", "src/test/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapTest.java.AbstractMultiValuedMapTest.[void]setConfirmed(MultiValuedMap<K, V>)"], "overrides": null, "attributes": [{"original_string": "    public class TestMultiValuedMapAsMap extends AbstractMapTest<K, Collection<V>> {\n\n        public TestMultiValuedMapAsMap() {\n            super(StringUtils.EMPTY);\n        }\n\n        @Override\n        public boolean areEqualElementsDistinguishable() {\n            // work-around for a problem with the EntrySet: the entries contain\n            // the wrapped collection, which will be automatically cleared\n            // when the associated key is removed from the map as the collection\n            // is not cached atm.\n            return true;\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public Collection<V>[] getNewSampleValues() {\n            // See comment in getSampleValues() to understand why we are calling makeObject() and not\n            // getMap(). See COLLECTIONS-661 for more.\n            final boolean isSetValuedMap = AbstractMultiValuedMapTest.this.makeObject() instanceof SetValuedMap;\n            final int maxV = getSampleTotalValueCount();\n            final int maxK = getSampleKeySize();\n            final V[] sampleValues = (V[]) new Object[maxV];\n            for (int v = 0; v < maxV; v++) {\n                // + something so that the key is different from an existing key.\n                sampleValues[v] = makeValue(maxK + 9, v);\n            }\n            final int cpk = getSampleCountPerKey();\n            final Collection<V>[] colArr = new Collection[maxK];\n            for (int i = 0; i < maxK; i++) {\n                final List<V> coll = new ArrayList<>(cpk);\n                for (int j = 0; j < cpk; j++) {\n                    coll.add(sampleValues[i * cpk + j]);\n                }\n                colArr[i] = isSetValuedMap ? new HashSet<>(coll) : coll;\n            }\n            return colArr;\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public K[] getSampleKeys() {\n            final K[] samplekeys = AbstractMultiValuedMapTest.this.getSampleKeys();\n            final int maxK = getSampleKeySize();\n            final int cpk = getSampleCountPerKey();\n            final Object[] finalKeys = new Object[maxK];\n            for (int i = 0; i < maxK; i++) {\n                finalKeys[i] = samplekeys[i * cpk];\n            }\n            return (K[]) finalKeys;\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public Collection<V>[] getSampleValues() {\n            // Calling getMap() instead of makeObject() would make more sense, but due to concurrency\n            // issues, this may lead to intermittent issues. See COLLECTIONS-661. A better solution\n            // would be to re-design the tests, or add a boolean method to the parent.\n            final boolean isSetValuedMap = AbstractMultiValuedMapTest.this.makeObject() instanceof SetValuedMap;\n            final V[] sampleValues = AbstractMultiValuedMapTest.this.getSampleValues();\n            final int maxK = getSampleKeySize();\n            final int cpk = getSampleCountPerKey();\n            final Collection<V>[] colArr = new Collection[maxK];\n            for (int i = 0; i < maxK; i++) {\n                final List<V> coll = new ArrayList<>(cpk);\n                for (int j = 0; j < cpk; j++) {\n                    coll.add(sampleValues[i * cpk + j]);\n                }\n                colArr[i] = isSetValuedMap ? new HashSet<>(coll) : coll;\n            }\n            return colArr;\n        }\n\n        @Override\n        public boolean isAllowNullKey() {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isPutAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isPutChangeSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Map<K, Collection<V>> makeFullMap() {\n            return AbstractMultiValuedMapTest.this.makeFullMap().asMap();\n        }\n\n        @Override\n        public Map<K, Collection<V>> makeObject() {\n            return AbstractMultiValuedMapTest.this.makeObject().asMap();\n        }\n    }", "definition": "    public class TestMultiValuedMapAsMap extends AbstractMapTest<K, Collection<V>>", "class_docstring": "", "name": "TestMultiValuedMapAsMap", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestMultiValuedMapAsMap() {\n            super(StringUtils.EMPTY);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestMultiValuedMapAsMap", "params": [], "body": "                                         {\n            super(StringUtils.EMPTY);\n        }", "signature": "public TestMultiValuedMapAsMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean areEqualElementsDistinguishable() {\n            // work-around for a problem with the EntrySet: the entries contain\n            // the wrapped collection, which will be automatically cleared\n            // when the associated key is removed from the map as the collection\n            // is not cached atm.\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "areEqualElementsDistinguishable", "params": [], "body": "                                                         {\n            // work-around for a problem with the EntrySet: the entries contain\n            // the wrapped collection, which will be automatically cleared\n            // when the associated key is removed from the map as the collection\n            // is not cached atm.\n            return true;\n        }", "signature": "@Override\n        public boolean areEqualElementsDistinguishable()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "getIterationBehaviour", "params": [], "body": "                                              {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }", "signature": "@Override\n        protected int getIterationBehaviour()"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public Collection<V>[] getNewSampleValues() {\n            // See comment in getSampleValues() to understand why we are calling makeObject() and not\n            // getMap(). See COLLECTIONS-661 for more.\n            final boolean isSetValuedMap = AbstractMultiValuedMapTest.this.makeObject() instanceof SetValuedMap;\n            final int maxV = getSampleTotalValueCount();\n            final int maxK = getSampleKeySize();\n            final V[] sampleValues = (V[]) new Object[maxV];\n            for (int v = 0; v < maxV; v++) {\n                // + something so that the key is different from an existing key.\n                sampleValues[v] = makeValue(maxK + 9, v);\n            }\n            final int cpk = getSampleCountPerKey();\n            final Collection<V>[] colArr = new Collection[maxK];\n            for (int i = 0; i < maxK; i++) {\n                final List<V> coll = new ArrayList<>(cpk);\n                for (int j = 0; j < cpk; j++) {\n                    coll.add(sampleValues[i * cpk + j]);\n                }\n                colArr[i] = isSetValuedMap ? new HashSet<>(coll) : coll;\n            }\n            return colArr;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Collection<V>[]", "classes": []}, "name": "getNewSampleValues", "params": [], "body": "                                                    {\n            // See comment in getSampleValues() to understand why we are calling makeObject() and not\n            // getMap(). See COLLECTIONS-661 for more.\n            final boolean isSetValuedMap = AbstractMultiValuedMapTest.this.makeObject() instanceof SetValuedMap;\n            final int maxV = getSampleTotalValueCount();\n            final int maxK = getSampleKeySize();\n            final V[] sampleValues = (V[]) new Object[maxV];\n            for (int v = 0; v < maxV; v++) {\n                // + something so that the key is different from an existing key.\n                sampleValues[v] = makeValue(maxK + 9, v);\n            }\n            final int cpk = getSampleCountPerKey();\n            final Collection<V>[] colArr = new Collection[maxK];\n            for (int i = 0; i < maxK; i++) {\n                final List<V> coll = new ArrayList<>(cpk);\n                for (int j = 0; j < cpk; j++) {\n                    coll.add(sampleValues[i * cpk + j]);\n                }\n                colArr[i] = isSetValuedMap ? new HashSet<>(coll) : coll;\n            }\n            return colArr;\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public Collection<V>[] getNewSampleValues()"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public K[] getSampleKeys() {\n            final K[] samplekeys = AbstractMultiValuedMapTest.this.getSampleKeys();\n            final int maxK = getSampleKeySize();\n            final int cpk = getSampleCountPerKey();\n            final Object[] finalKeys = new Object[maxK];\n            for (int i = 0; i < maxK; i++) {\n                finalKeys[i] = samplekeys[i * cpk];\n            }\n            return (K[]) finalKeys;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "K[]", "classes": []}, "name": "getSampleKeys", "params": [], "body": "                                   {\n            final K[] samplekeys = AbstractMultiValuedMapTest.this.getSampleKeys();\n            final int maxK = getSampleKeySize();\n            final int cpk = getSampleCountPerKey();\n            final Object[] finalKeys = new Object[maxK];\n            for (int i = 0; i < maxK; i++) {\n                finalKeys[i] = samplekeys[i * cpk];\n            }\n            return (K[]) finalKeys;\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public K[] getSampleKeys()"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public Collection<V>[] getSampleValues() {\n            // Calling getMap() instead of makeObject() would make more sense, but due to concurrency\n            // issues, this may lead to intermittent issues. See COLLECTIONS-661. A better solution\n            // would be to re-design the tests, or add a boolean method to the parent.\n            final boolean isSetValuedMap = AbstractMultiValuedMapTest.this.makeObject() instanceof SetValuedMap;\n            final V[] sampleValues = AbstractMultiValuedMapTest.this.getSampleValues();\n            final int maxK = getSampleKeySize();\n            final int cpk = getSampleCountPerKey();\n            final Collection<V>[] colArr = new Collection[maxK];\n            for (int i = 0; i < maxK; i++) {\n                final List<V> coll = new ArrayList<>(cpk);\n                for (int j = 0; j < cpk; j++) {\n                    coll.add(sampleValues[i * cpk + j]);\n                }\n                colArr[i] = isSetValuedMap ? new HashSet<>(coll) : coll;\n            }\n            return colArr;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Collection<V>[]", "classes": []}, "name": "getSampleValues", "params": [], "body": "                                                 {\n            // Calling getMap() instead of makeObject() would make more sense, but due to concurrency\n            // issues, this may lead to intermittent issues. See COLLECTIONS-661. A better solution\n            // would be to re-design the tests, or add a boolean method to the parent.\n            final boolean isSetValuedMap = AbstractMultiValuedMapTest.this.makeObject() instanceof SetValuedMap;\n            final V[] sampleValues = AbstractMultiValuedMapTest.this.getSampleValues();\n            final int maxK = getSampleKeySize();\n            final int cpk = getSampleCountPerKey();\n            final Collection<V>[] colArr = new Collection[maxK];\n            for (int i = 0; i < maxK; i++) {\n                final List<V> coll = new ArrayList<>(cpk);\n                for (int j = 0; j < cpk; j++) {\n                    coll.add(sampleValues[i * cpk + j]);\n                }\n                colArr[i] = isSetValuedMap ? new HashSet<>(coll) : coll;\n            }\n            return colArr;\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public Collection<V>[] getSampleValues()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAllowNullKey() {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAllowNullKey", "params": [], "body": "                                        {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }", "signature": "@Override\n        public boolean isAllowNullKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isPutAddSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isPutAddSupported", "params": [], "body": "                                           {\n            return false;\n        }", "signature": "@Override\n        public boolean isPutAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isPutChangeSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isPutChangeSupported", "params": [], "body": "                                              {\n            return false;\n        }", "signature": "@Override\n        public boolean isPutChangeSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map<K, Collection<V>> makeFullMap() {\n            return AbstractMultiValuedMapTest.this.makeFullMap().asMap();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<K, Collection<V>>", "classes": []}, "name": "makeFullMap", "params": [], "body": "                                                   {\n            return AbstractMultiValuedMapTest.this.makeFullMap().asMap();\n        }", "signature": "@Override\n        public Map<K, Collection<V>> makeFullMap()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map<K, Collection<V>> makeObject() {\n            return AbstractMultiValuedMapTest.this.makeObject().asMap();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map<K, Collection<V>>", "classes": []}, "name": "makeObject", "params": [], "body": "                                                  {\n            return AbstractMultiValuedMapTest.this.makeObject().asMap();\n        }", "signature": "@Override\n        public Map<K, Collection<V>> makeObject()"}]}, {"original_string": "    public class TestMultiValuedMapEntries extends AbstractCollectionTest<Entry<K, V>> {\n        public TestMultiValuedMapEntries() {\n            super(StringUtils.EMPTY);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Entry<K, V>[] getFullElements() {\n            return makeFullMap().entries().toArray(new Entry[0]);\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            // Add not supported in entries view\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Collection<Entry<K, V>> makeConfirmedCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }\n\n        @Override\n        public Collection<Entry<K, V>> makeConfirmedFullCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }\n\n        @Override\n        public Collection<Entry<K, V>> makeFullCollection() {\n            return AbstractMultiValuedMapTest.this.makeFullMap().entries();\n        }\n\n        @Override\n        public Collection<Entry<K, V>> makeObject() {\n            return AbstractMultiValuedMapTest.this.makeObject().entries();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractMultiValuedMapTest.this.resetEmpty();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().entries());\n            TestMultiValuedMapEntries.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().entries());\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractMultiValuedMapTest.this.resetFull();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().entries());\n            TestMultiValuedMapEntries.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().entries());\n        }\n\n    }", "definition": "    public class TestMultiValuedMapEntries extends AbstractCollectionTest<Entry<K, V>>", "class_docstring": "", "name": "TestMultiValuedMapEntries", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestMultiValuedMapEntries() {\n            super(StringUtils.EMPTY);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestMultiValuedMapEntries", "params": [], "body": "                                           {\n            super(StringUtils.EMPTY);\n        }", "signature": "public TestMultiValuedMapEntries()"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Entry<K, V>[] getFullElements() {\n            return makeFullMap().entries().toArray(new Entry[0]);\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        @Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Entry<K, V>[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                               {\n            return makeFullMap().entries().toArray(new Entry[0]);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        @Override\n        public Entry<K, V>[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "getIterationBehaviour", "params": [], "body": "                                              {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }", "signature": "@Override\n        protected int getIterationBehaviour()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            // Add not supported in entries view\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            // Add not supported in entries view\n            return false;\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isNullSupported() {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNullSupported", "params": [], "body": "                                         {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }", "signature": "@Override\n        public boolean isNullSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<Entry<K, V>> makeConfirmedCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<Entry<K, V>>", "classes": []}, "name": "makeConfirmedCollection", "params": [], "body": "                                                                 {\n            // never gets called, reset methods are overridden\n            return null;\n        }", "signature": "@Override\n        public Collection<Entry<K, V>> makeConfirmedCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<Entry<K, V>> makeConfirmedFullCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<Entry<K, V>>", "classes": []}, "name": "makeConfirmedFullCollection", "params": [], "body": "                                                                     {\n            // never gets called, reset methods are overridden\n            return null;\n        }", "signature": "@Override\n        public Collection<Entry<K, V>> makeConfirmedFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<Entry<K, V>> makeFullCollection() {\n            return AbstractMultiValuedMapTest.this.makeFullMap().entries();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<Entry<K, V>>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                                            {\n            return AbstractMultiValuedMapTest.this.makeFullMap().entries();\n        }", "signature": "@Override\n        public Collection<Entry<K, V>> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<Entry<K, V>> makeObject() {\n            return AbstractMultiValuedMapTest.this.makeObject().entries();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<Entry<K, V>>", "classes": []}, "name": "makeObject", "params": [], "body": "                                                    {\n            return AbstractMultiValuedMapTest.this.makeObject().entries();\n        }", "signature": "@Override\n        public Collection<Entry<K, V>> makeObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetEmpty() {\n            AbstractMultiValuedMapTest.this.resetEmpty();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().entries());\n            TestMultiValuedMapEntries.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().entries());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetEmpty", "params": [], "body": "                                 {\n            AbstractMultiValuedMapTest.this.resetEmpty();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().entries());\n            TestMultiValuedMapEntries.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().entries());\n        }", "signature": "@Override\n        public void resetEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetFull() {\n            AbstractMultiValuedMapTest.this.resetFull();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().entries());\n            TestMultiValuedMapEntries.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().entries());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetFull", "params": [], "body": "                                {\n            AbstractMultiValuedMapTest.this.resetFull();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().entries());\n            TestMultiValuedMapEntries.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().entries());\n        }", "signature": "@Override\n        public void resetFull()"}]}, {"original_string": "    public class TestMultiValuedMapKeys extends AbstractMultiSetTest<K> {\n\n        public TestMultiValuedMapKeys() {\n            super(StringUtils.EMPTY);\n        }\n\n        @Override\n        public K[] getFullElements() {\n            return getSampleKeys();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public MultiSet<K> makeFullCollection() {\n            return AbstractMultiValuedMapTest.this.makeFullMap().keys();\n        }\n\n        @Override\n        public MultiSet<K> makeObject() {\n            return AbstractMultiValuedMapTest.this.makeObject().keys();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractMultiValuedMapTest.this.resetEmpty();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().keys());\n            TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractMultiValuedMapTest.this.resetFull();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().keys());\n            TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());\n        }\n    }", "definition": "    public class TestMultiValuedMapKeys extends AbstractMultiSetTest<K>", "class_docstring": "", "name": "TestMultiValuedMapKeys", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestMultiValuedMapKeys() {\n            super(StringUtils.EMPTY);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestMultiValuedMapKeys", "params": [], "body": "                                        {\n            super(StringUtils.EMPTY);\n        }", "signature": "public TestMultiValuedMapKeys()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K[] getFullElements() {\n            return getSampleKeys();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                     {\n            return getSampleKeys();\n        }", "signature": "@Override\n        public K[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "getIterationBehaviour", "params": [], "body": "                                              {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }", "signature": "@Override\n        protected int getIterationBehaviour()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            return false;\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isNullSupported() {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNullSupported", "params": [], "body": "                                         {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }", "signature": "@Override\n        public boolean isNullSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return false;\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public MultiSet<K> makeFullCollection() {\n            return AbstractMultiValuedMapTest.this.makeFullMap().keys();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "MultiSet<K>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                                {\n            return AbstractMultiValuedMapTest.this.makeFullMap().keys();\n        }", "signature": "@Override\n        public MultiSet<K> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public MultiSet<K> makeObject() {\n            return AbstractMultiValuedMapTest.this.makeObject().keys();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "MultiSet<K>", "classes": []}, "name": "makeObject", "params": [], "body": "                                        {\n            return AbstractMultiValuedMapTest.this.makeObject().keys();\n        }", "signature": "@Override\n        public MultiSet<K> makeObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetEmpty() {\n            AbstractMultiValuedMapTest.this.resetEmpty();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().keys());\n            TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetEmpty", "params": [], "body": "                                 {\n            AbstractMultiValuedMapTest.this.resetEmpty();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().keys());\n            TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());\n        }", "signature": "@Override\n        public void resetEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetFull() {\n            AbstractMultiValuedMapTest.this.resetFull();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().keys());\n            TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetFull", "params": [], "body": "                                {\n            AbstractMultiValuedMapTest.this.resetFull();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().keys());\n            TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());\n        }", "signature": "@Override\n        public void resetFull()"}]}, {"original_string": "    public class TestMultiValuedMapKeySet extends AbstractSetTest<K> {\n        public TestMultiValuedMapKeySet() {\n            super(StringUtils.EMPTY);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public K[] getFullElements() {\n            return (K[]) AbstractMultiValuedMapTest.this.makeFullMap().keySet().toArray();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Set<K> makeFullCollection() {\n            return AbstractMultiValuedMapTest.this.makeFullMap().keySet();\n        }\n\n        @Override\n        public Set<K> makeObject() {\n            return AbstractMultiValuedMapTest.this.makeObject().keySet();\n        }\n    }", "definition": "    public class TestMultiValuedMapKeySet extends AbstractSetTest<K>", "class_docstring": "", "name": "TestMultiValuedMapKeySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestMultiValuedMapKeySet() {\n            super(StringUtils.EMPTY);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestMultiValuedMapKeySet", "params": [], "body": "                                          {\n            super(StringUtils.EMPTY);\n        }", "signature": "public TestMultiValuedMapKeySet()"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        @Override\n        public K[] getFullElements() {\n            return (K[]) AbstractMultiValuedMapTest.this.makeFullMap().keySet().toArray();\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        @Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "K[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                     {\n            return (K[]) AbstractMultiValuedMapTest.this.makeFullMap().keySet().toArray();\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        @Override\n        public K[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "getIterationBehaviour", "params": [], "body": "                                              {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }", "signature": "@Override\n        protected int getIterationBehaviour()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            return false;\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isNullSupported() {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNullSupported", "params": [], "body": "                                         {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }", "signature": "@Override\n        public boolean isNullSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<K> makeFullCollection() {\n            return AbstractMultiValuedMapTest.this.makeFullMap().keySet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<K>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                           {\n            return AbstractMultiValuedMapTest.this.makeFullMap().keySet();\n        }", "signature": "@Override\n        public Set<K> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<K> makeObject() {\n            return AbstractMultiValuedMapTest.this.makeObject().keySet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<K>", "classes": []}, "name": "makeObject", "params": [], "body": "                                   {\n            return AbstractMultiValuedMapTest.this.makeObject().keySet();\n        }", "signature": "@Override\n        public Set<K> makeObject()"}]}, {"original_string": "    public class TestMultiValuedMapValues extends AbstractCollectionTest<V> {\n        public TestMultiValuedMapValues() {\n            super(StringUtils.EMPTY);\n        }\n\n        @Override\n        public V[] getFullElements() {\n            return getSampleValues();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Collection<V> makeConfirmedCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }\n\n        @Override\n        public Collection<V> makeConfirmedFullCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }\n\n        @Override\n        public Collection<V> makeFullCollection() {\n            return AbstractMultiValuedMapTest.this.makeFullMap().values();\n        }\n\n        @Override\n        public Collection<V> makeObject() {\n            return AbstractMultiValuedMapTest.this.makeObject().values();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractMultiValuedMapTest.this.resetEmpty();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().values());\n            TestMultiValuedMapValues.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().values());\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractMultiValuedMapTest.this.resetFull();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().values());\n            TestMultiValuedMapValues.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().values());\n        }\n    }", "definition": "    public class TestMultiValuedMapValues extends AbstractCollectionTest<V>", "class_docstring": "", "name": "TestMultiValuedMapValues", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestMultiValuedMapValues() {\n            super(StringUtils.EMPTY);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestMultiValuedMapValues", "params": [], "body": "                                          {\n            super(StringUtils.EMPTY);\n        }", "signature": "public TestMultiValuedMapValues()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V[] getFullElements() {\n            return getSampleValues();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                     {\n            return getSampleValues();\n        }", "signature": "@Override\n        public V[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "getIterationBehaviour", "params": [], "body": "                                              {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }", "signature": "@Override\n        protected int getIterationBehaviour()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            return false;\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isNullSupported() {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNullSupported", "params": [], "body": "                                         {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }", "signature": "@Override\n        public boolean isNullSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<V> makeConfirmedCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<V>", "classes": []}, "name": "makeConfirmedCollection", "params": [], "body": "                                                       {\n            // never gets called, reset methods are overridden\n            return null;\n        }", "signature": "@Override\n        public Collection<V> makeConfirmedCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<V> makeConfirmedFullCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<V>", "classes": []}, "name": "makeConfirmedFullCollection", "params": [], "body": "                                                           {\n            // never gets called, reset methods are overridden\n            return null;\n        }", "signature": "@Override\n        public Collection<V> makeConfirmedFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<V> makeFullCollection() {\n            return AbstractMultiValuedMapTest.this.makeFullMap().values();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<V>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                                  {\n            return AbstractMultiValuedMapTest.this.makeFullMap().values();\n        }", "signature": "@Override\n        public Collection<V> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<V> makeObject() {\n            return AbstractMultiValuedMapTest.this.makeObject().values();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<V>", "classes": []}, "name": "makeObject", "params": [], "body": "                                          {\n            return AbstractMultiValuedMapTest.this.makeObject().values();\n        }", "signature": "@Override\n        public Collection<V> makeObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetEmpty() {\n            AbstractMultiValuedMapTest.this.resetEmpty();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().values());\n            TestMultiValuedMapValues.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().values());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetEmpty", "params": [], "body": "                                 {\n            AbstractMultiValuedMapTest.this.resetEmpty();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().values());\n            TestMultiValuedMapValues.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().values());\n        }", "signature": "@Override\n        public void resetEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetFull() {\n            AbstractMultiValuedMapTest.this.resetFull();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().values());\n            TestMultiValuedMapValues.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().values());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetFull", "params": [], "body": "                                {\n            AbstractMultiValuedMapTest.this.resetFull();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().values());\n            TestMultiValuedMapValues.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().values());\n        }", "signature": "@Override\n        public void resetFull()"}]}], "class_docstring": "\nAbstract test class for {@link MultiValuedMap} contract and methods.\n<p>\nTo use, extend this class and implement the {@link #makeObject} method and if\nnecessary override the {@link #makeFullMap()} method.\n</p>\n", "original_string": "public abstract class AbstractMultiValuedMapTest<K, V> extends AbstractObjectTest {\n\n    public class TestMultiValuedMapAsMap extends AbstractMapTest<K, Collection<V>> {\n\n        public TestMultiValuedMapAsMap() {\n            super(StringUtils.EMPTY);\n        }\n\n        @Override\n        public boolean areEqualElementsDistinguishable() {\n            // work-around for a problem with the EntrySet: the entries contain\n            // the wrapped collection, which will be automatically cleared\n            // when the associated key is removed from the map as the collection\n            // is not cached atm.\n            return true;\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public Collection<V>[] getNewSampleValues() {\n            // See comment in getSampleValues() to understand why we are calling makeObject() and not\n            // getMap(). See COLLECTIONS-661 for more.\n            final boolean isSetValuedMap = AbstractMultiValuedMapTest.this.makeObject() instanceof SetValuedMap;\n            final int maxV = getSampleTotalValueCount();\n            final int maxK = getSampleKeySize();\n            final V[] sampleValues = (V[]) new Object[maxV];\n            for (int v = 0; v < maxV; v++) {\n                // + something so that the key is different from an existing key.\n                sampleValues[v] = makeValue(maxK + 9, v);\n            }\n            final int cpk = getSampleCountPerKey();\n            final Collection<V>[] colArr = new Collection[maxK];\n            for (int i = 0; i < maxK; i++) {\n                final List<V> coll = new ArrayList<>(cpk);\n                for (int j = 0; j < cpk; j++) {\n                    coll.add(sampleValues[i * cpk + j]);\n                }\n                colArr[i] = isSetValuedMap ? new HashSet<>(coll) : coll;\n            }\n            return colArr;\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public K[] getSampleKeys() {\n            final K[] samplekeys = AbstractMultiValuedMapTest.this.getSampleKeys();\n            final int maxK = getSampleKeySize();\n            final int cpk = getSampleCountPerKey();\n            final Object[] finalKeys = new Object[maxK];\n            for (int i = 0; i < maxK; i++) {\n                finalKeys[i] = samplekeys[i * cpk];\n            }\n            return (K[]) finalKeys;\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public Collection<V>[] getSampleValues() {\n            // Calling getMap() instead of makeObject() would make more sense, but due to concurrency\n            // issues, this may lead to intermittent issues. See COLLECTIONS-661. A better solution\n            // would be to re-design the tests, or add a boolean method to the parent.\n            final boolean isSetValuedMap = AbstractMultiValuedMapTest.this.makeObject() instanceof SetValuedMap;\n            final V[] sampleValues = AbstractMultiValuedMapTest.this.getSampleValues();\n            final int maxK = getSampleKeySize();\n            final int cpk = getSampleCountPerKey();\n            final Collection<V>[] colArr = new Collection[maxK];\n            for (int i = 0; i < maxK; i++) {\n                final List<V> coll = new ArrayList<>(cpk);\n                for (int j = 0; j < cpk; j++) {\n                    coll.add(sampleValues[i * cpk + j]);\n                }\n                colArr[i] = isSetValuedMap ? new HashSet<>(coll) : coll;\n            }\n            return colArr;\n        }\n\n        @Override\n        public boolean isAllowNullKey() {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isPutAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isPutChangeSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Map<K, Collection<V>> makeFullMap() {\n            return AbstractMultiValuedMapTest.this.makeFullMap().asMap();\n        }\n\n        @Override\n        public Map<K, Collection<V>> makeObject() {\n            return AbstractMultiValuedMapTest.this.makeObject().asMap();\n        }\n    }\n\n    public class TestMultiValuedMapEntries extends AbstractCollectionTest<Entry<K, V>> {\n        public TestMultiValuedMapEntries() {\n            super(StringUtils.EMPTY);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Entry<K, V>[] getFullElements() {\n            return makeFullMap().entries().toArray(new Entry[0]);\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            // Add not supported in entries view\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Collection<Entry<K, V>> makeConfirmedCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }\n\n        @Override\n        public Collection<Entry<K, V>> makeConfirmedFullCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }\n\n        @Override\n        public Collection<Entry<K, V>> makeFullCollection() {\n            return AbstractMultiValuedMapTest.this.makeFullMap().entries();\n        }\n\n        @Override\n        public Collection<Entry<K, V>> makeObject() {\n            return AbstractMultiValuedMapTest.this.makeObject().entries();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractMultiValuedMapTest.this.resetEmpty();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().entries());\n            TestMultiValuedMapEntries.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().entries());\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractMultiValuedMapTest.this.resetFull();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().entries());\n            TestMultiValuedMapEntries.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().entries());\n        }\n\n    }\n\n    public class TestMultiValuedMapKeys extends AbstractMultiSetTest<K> {\n\n        public TestMultiValuedMapKeys() {\n            super(StringUtils.EMPTY);\n        }\n\n        @Override\n        public K[] getFullElements() {\n            return getSampleKeys();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public MultiSet<K> makeFullCollection() {\n            return AbstractMultiValuedMapTest.this.makeFullMap().keys();\n        }\n\n        @Override\n        public MultiSet<K> makeObject() {\n            return AbstractMultiValuedMapTest.this.makeObject().keys();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractMultiValuedMapTest.this.resetEmpty();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().keys());\n            TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractMultiValuedMapTest.this.resetFull();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().keys());\n            TestMultiValuedMapKeys.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().keys());\n        }\n    }\n\n    public class TestMultiValuedMapKeySet extends AbstractSetTest<K> {\n        public TestMultiValuedMapKeySet() {\n            super(StringUtils.EMPTY);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public K[] getFullElements() {\n            return (K[]) AbstractMultiValuedMapTest.this.makeFullMap().keySet().toArray();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Set<K> makeFullCollection() {\n            return AbstractMultiValuedMapTest.this.makeFullMap().keySet();\n        }\n\n        @Override\n        public Set<K> makeObject() {\n            return AbstractMultiValuedMapTest.this.makeObject().keySet();\n        }\n    }\n\n    public class TestMultiValuedMapValues extends AbstractCollectionTest<V> {\n        public TestMultiValuedMapValues() {\n            super(StringUtils.EMPTY);\n        }\n\n        @Override\n        public V[] getFullElements() {\n            return getSampleValues();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiValuedMapTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractMultiValuedMapTest.this.isAllowNullKey();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMultiValuedMapTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Collection<V> makeConfirmedCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }\n\n        @Override\n        public Collection<V> makeConfirmedFullCollection() {\n            // never gets called, reset methods are overridden\n            return null;\n        }\n\n        @Override\n        public Collection<V> makeFullCollection() {\n            return AbstractMultiValuedMapTest.this.makeFullMap().values();\n        }\n\n        @Override\n        public Collection<V> makeObject() {\n            return AbstractMultiValuedMapTest.this.makeObject().values();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractMultiValuedMapTest.this.resetEmpty();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().values());\n            TestMultiValuedMapValues.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().values());\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractMultiValuedMapTest.this.resetFull();\n            setCollection(AbstractMultiValuedMapTest.this.getMap().values());\n            TestMultiValuedMapValues.this.setConfirmed(AbstractMultiValuedMapTest.this.getConfirmed().values());\n        }\n    }\n\n    /** Map created by reset(). */\n    protected MultiValuedMap<K, V> map;\n\n    /** MultiValuedHashMap created by reset(). */\n    protected MultiValuedMap<K, V> confirmed;\n\n    public AbstractMultiValuedMapTest(final String testName) {\n        super(testName);\n    }\n\n    protected void addSampleMappings(final MultiValuedMap<? super K, ? super V> map) {\n        final K[] keys = getSampleKeys();\n        final V[] values = getSampleValues();\n        for (int i = 0; i < keys.length; i++) {\n            map.put(keys[i], values[i]);\n        }\n    }\n\n    public BulkTest bulkTestAsMap() {\n        return new TestMultiValuedMapAsMap();\n    }\n\n    // Bulk Tests\n    /**\n     * Bulk test {@link MultiValuedMap#entries()}. This method runs through all\n     * of the tests in {@link AbstractCollectionTest}. After modification\n     * operations, {@link #verify()} is invoked to ensure that the map and the\n     * other collection views are still valid.\n     *\n     * @return a {@link AbstractCollectionTest} instance for testing the map's\n     *         values collection\n     */\n    public BulkTest bulkTestMultiValuedMapEntries() {\n        return new TestMultiValuedMapEntries();\n    }\n\n    /**\n     * Bulk test {@link MultiValuedMap#keys()}. This method runs through all of\n     * the tests in {@link AbstractBagTest}. After modification operations,\n     * {@link #verify()} is invoked to ensure that the map and the other\n     * collection views are still valid.\n     *\n     * @return a {@link AbstractBagTest} instance for testing the map's values\n     *         collection\n     */\n    public BulkTest bulkTestMultiValuedMapKeys() {\n        return new TestMultiValuedMapKeys();\n    }\n\n    /**\n     * Bulk test {@link MultiValuedMap#keySet()}. This method runs through all\n     * of the tests in {@link AbstractSetTest}. After modification operations,\n     * {@link #verify()} is invoked to ensure that the map and the other\n     * collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing the map's key set\n     */\n    public BulkTest bulkTestMultiValuedMapKeySet() {\n        return new TestMultiValuedMapKeySet();\n    }\n\n    /**\n     * Bulk test {@link MultiValuedMap#values()}. This method runs through all\n     * of the tests in {@link AbstractCollectionTest}. After modification\n     * operations, {@link #verify()} is invoked to ensure that the map and the\n     * other collection views are still valid.\n     *\n     * @return a {@link AbstractCollectionTest} instance for testing the map's\n     *         values collection\n     */\n    public BulkTest bulkTestMultiValuedMapValues() {\n        return new TestMultiValuedMapValues();\n    }\n\n    @Override\n    public String getCompatibilityVersion() {\n        return \"4.1\"; // MultiValuedMap has been added in version 4.1\n    }\n\n    public MultiValuedMap<K, V> getConfirmed() {\n        return confirmed;\n    }\n\n    /**\n     * Gets a flag specifying the iteration behavior of the map.\n     * This is used to change the assertions used by specific tests.\n     * The default implementation returns 0 which indicates ordered iteration behavior.\n     *\n     * @return the iteration behavior\n     * @see AbstractCollectionTest#UNORDERED\n     */\n    protected int getIterationBehaviour() {\n        return 0;\n    }\n\n    public MultiValuedMap<K, V> getMap() {\n        return map;\n    }\n\n    public int getSampleCountPerKey() {\n        return 8;\n    }\n\n    /**\n     * Returns the set of keys in the mappings used to test the map. This method\n     * must return an array with the same length as {@link #getSampleValues()}\n     * and all array elements must be different. The default implementation\n     * constructs a set of String keys, and includes a single null key if\n     * {@link #isAllowNullKey()} returns {@code true}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public K[] getSampleKeys() {\n        final Object[] result = new Object[getSampleTotalValueCount()];\n        final int cpk = getSampleCountPerKey();\n        int k = 0;\n        for (int i = 0; i < result.length; i += cpk, k++) {\n            final K key = makeKey(k);\n            for (int j = 0; j < cpk; j++) {\n                result[i + j] = key;\n            }\n        }\n        return (K[]) result;\n    }\n\n    public int getSampleKeySize() {\n        return 256;\n    }\n\n    public int getSampleTotalValueCount() {\n        return getSampleCountPerKey() * getSampleKeySize();\n    }\n\n    /**\n     * Returns the set of values in the mappings used to test the map. This\n     * method must return an array with the same length as\n     * {@link #getSampleKeys()}. The default implementation constructs a set of\n     * String values\n     */\n    @SuppressWarnings(\"unchecked\")\n    public V[] getSampleValues() {\n        final Object[] result = new Object[getSampleTotalValueCount()];\n        final int cpk = getSampleCountPerKey();\n        int k = 0;\n        for (int i = 0; i < result.length; i += cpk, k++) {\n            for (int j = 0; j < cpk; j++) {\n                result[i + j] = makeValue(k, j);\n            }\n        }\n        return (V[]) result;\n    }\n\n    /**\n     * Returns true if the maps produced by {@link #makeObject()} and\n     * {@link #makeFullMap()} support the {@code put} and\n     * {@code putAll} operations adding new mappings.\n     * <p>\n     * Default implementation returns true. Override if your collection class\n     * does not support put adding.\n     * </p>\n     */\n    public boolean isAddSupported() {\n        return true;\n    }\n\n    /**\n     * Returns true if the maps produced by {@link #makeObject()} and\n     * {@link #makeFullMap()} supports null keys.\n     * <p>\n     * Default implementation returns true. Override if your collection class\n     * does not support null keys.\n     * </p>\n     */\n    public boolean isAllowNullKey() {\n        return true;\n    }\n\n    /**\n     * Returns true if the maps produced by {@link #makeObject()} and\n     * {@link #makeFullMap()} supports set value.\n     * <p>\n     * Default implementation returns false. Override if your collection class\n     * supports set value.\n     * </p>\n     */\n    public boolean isHashSetValue() {\n        return false;\n    }\n\n    /**\n     * Returns true if the maps produced by {@link #makeObject()} and\n     * {@link #makeFullMap()} support the {@code remove} and\n     * {@code clear} operations.\n     * <p>\n     * Default implementation returns true. Override if your collection class\n     * does not support removal operations.\n     * </p>\n     */\n    public boolean isRemoveSupported() {\n        return true;\n    }\n\n    @Override\n    public boolean isTestSerialization() {\n        return true;\n    }\n\n    /**\n     * Override to return a MultiValuedMap other than ArrayListValuedHashMap\n     * as the confirmed map.\n     *\n     * @return a MultiValuedMap that is known to be valid\n     */\n    public MultiValuedMap<K, V> makeConfirmedMap() {\n        return new ArrayListValuedHashMap<>();\n    }\n\n    protected MultiValuedMap<K, V> makeFullMap() {\n        final MultiValuedMap<K, V> map = makeObject();\n        addSampleMappings(map);\n        return map;\n    }\n\n    <E> E makeKey(final int key) {\n        return (E) new StringBuilder(\"k\").append(key).toString();\n    }\n\n    @Override\n    public abstract MultiValuedMap<K, V> makeObject();\n\n    <E> E makeValue(final int key, final int value) {\n        return (E) new StringBuilder(\"v\").append(key).append('_').append(value).toString();\n    }\n\n    /**\n     * Resets the {@link #map} and {@link #confirmed} fields to empty.\n     */\n    public void resetEmpty() {\n        map = makeObject();\n        confirmed = makeConfirmedMap();\n    }\n\n    /**\n     * Resets the {@link #map} and {@link #confirmed} fields to full.\n     */\n    public void resetFull() {\n        map = makeFullMap();\n        confirmed = makeConfirmedMap();\n        final K[] k = getSampleKeys();\n        final V[] v = getSampleValues();\n        for (int i = 0; i < k.length; i++) {\n            confirmed.put(k[i], v[i]);\n        }\n    }\n\n//    public void testKeyedIterator() {\n//        final MultiValuedMap<K, V> map = makeFullMap();\n//        final ArrayList<Object> actual = new ArrayList<Object>(IteratorUtils.toList(map.iterator(\"k0\")));\n//        final ArrayList<Object> expected = new ArrayList<Object>(Arrays.asList(\"v1_1\", \"v0_1\"));\n//        assertEquals(expected, actual);\n//    }\n\n    public void setConfirmed(final MultiValuedMap<K, V> confirmed) {\n        this.confirmed = confirmed;\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAddMappingThroughGet() {\n        assumeTrue(isAddSupported());\n        resetEmpty();\n        final MultiValuedMap<K, V> map = getMap();\n        final Collection<V> col1 = map.get((K) \"k0\");\n        final Collection<V> col2 = map.get((K) \"k0\");\n        assertTrue(col1.isEmpty());\n        assertTrue(col2.isEmpty());\n        assertEquals(0, map.size());\n        col1.add((V) \"v1_1\");\n        col2.add((V) \"v0_1\");\n        assertTrue(map.containsKey(\"k0\"));\n        assertTrue(map.containsMapping(\"k0\", \"v1_1\"));\n        assertTrue(map.containsMapping(\"k0\", \"v0_1\"));\n        assertTrue(map.containsValue(\"v1_1\"));\n        assertTrue(map.containsValue(\"v0_1\"));\n        assertTrue(col1.contains(\"v0_1\"));\n        assertTrue(col2.contains(\"v1_1\"));\n    }\n\n    /*public void testRemoveViaGetCollectionRemove() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n        final MultiValuedMap<K, V> map = makeFullMap();\n        Collection<V> values = map.get(\"k0\");\n        values.remove(\"v1_1\");\n        values.remove(\"v0_1\");\n        assertFalse(map.containsKey(\"k0\"));\n        assertEquals(4, map.size());\n    }*/\n\n//    public void testRemoveAllViaKeyedIterator() {\n//        if (!isRemoveSupported()) {\n//            return;\n//        }\n//        final MultiValuedMap<K, V> map = makeFullMap();\n//        for (final Iterator<?> i = map.iterator(\"k0\"); i.hasNext();) {\n//            i.next();\n//            i.remove();\n//        }\n//        assertNull(map.get(\"k0\"));\n//        assertEquals(4, map.size());\n//    }\n\n    @Test\n    public void testAsMapGet_Empty() {\n        resetEmpty();\n        final Map<K, Collection<V>> mapCol = getMap().asMap();\n        assertNull(mapCol.get(\"k0\"));\n        assertEquals(0, mapCol.size());\n    }\n\n    @Test\n    public void testAsMapGet_Full() {\n        resetFull();\n        final Map<K, Collection<V>> mapCol = getMap().asMap();\n        final int maxK = getSampleKeySize();\n        final int maxV = getSampleCountPerKey();\n        for (int k = 0; k < maxK; k++) {\n            final Collection<V> col = mapCol.get(makeKey(k));\n            for (int v = 0; v < maxV; v++) {\n                assertTrue(col.contains(makeValue(k, v)));\n            }\n        }\n    }\n\n    @Test\n    public void testAsMapRemove() {\n        assumeTrue(isRemoveSupported());\n        resetFull();\n        final Map<K, Collection<V>> mapCol = getMap().asMap();\n        final int maxK = getSampleKeySize();\n        int expectedSize = getMap().size();\n        for (int k = 0; k < maxK; k++) {\n            final K key = makeKey(k);\n            mapCol.remove(key);\n            assertFalse(getMap().containsKey(key));\n            expectedSize -= getSampleCountPerKey();\n            assertEquals(expectedSize, getMap().size());\n        }\n        assertFalse(getMap().containsKey(\"k0\"));\n        assertEquals(0, getMap().size());\n    }\n\n    @Test\n    public void testContainsValue() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        final int maxK = getSampleKeySize();\n        final int maxV = getSampleCountPerKey();\n        for (int k = 0; k < maxK; k++) {\n            for (int v = 0; v < maxV; v++) {\n                assertTrue(map.containsValue(makeValue(k, v)));\n            }\n        }\n        assertFalse(map.containsValue(\"quatro\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testContainsValue_Key() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        final int maxK = getSampleKeySize();\n        final int maxV = getSampleCountPerKey();\n        for (int k = 0; k < maxK; k++) {\n            for (int v = 0; v < maxV; v++) {\n                assertTrue(map.containsMapping(makeKey(k), makeValue(k, v)));            }\n        }\n        assertFalse(map.containsMapping(\"k1\", \"2\"));\n        if (!isAddSupported()) {\n            return;\n        }\n        map.put((K) \"A\", (V) \"AA\");\n        assertTrue(map.containsMapping(\"A\", \"AA\"));\n        assertFalse(map.containsMapping(\"A\", \"AB\"));\n    }\n\n    /**\n     * Manual serialization testing as this class cannot easily extend the AbstractTestMap\n     */\n    @Test\n    public void testEmptyMapCompatibility() throws Exception {\n        final MultiValuedMap<?, ?> map = makeObject();\n        final MultiValuedMap<?, ?> map2 =\n                (MultiValuedMap<?, ?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(map));\n        assertEquals(0, map2.size(), \"Map is empty\");\n    }\n\n    @Test\n    public void testEntriesCollectionIterator() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        final Collection<V> values = new ArrayList<>(map.values());\n        for (final Entry<K, V> entry : map.entries()) {\n            assertTrue(map.containsMapping(entry.getKey(), entry.getValue()));\n            assertTrue(values.contains(entry.getValue()));\n            if (isRemoveSupported()) {\n                assertTrue(values.remove(entry.getValue()));\n            }\n        }\n        if (isRemoveSupported()) {\n            assertTrue(values.isEmpty());\n        }\n    }\n\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    @Test\n    @Disabled(\"There is no code to create this test fixture?\")\n    public void testFullMapCompatibility() throws Exception {\n        final MultiValuedMap map = makeFullMap();\n        final MultiValuedMap map2 =\n                (MultiValuedMap) readExternalFormFromDisk(getCanonicalFullCollectionName(map));\n        assertEquals(map.size(), map2.size(), \"Map is the right size\");\n        for (final Object key : map.keySet()) {\n            assertTrue(CollectionUtils.isEqualCollection(map.get(key), map2.get(key)),\n                    \"Map had inequal elements\");\n            if (isRemoveSupported()) {\n                map2.remove(key);\n            }\n        }\n        if (isRemoveSupported()) {\n            assertEquals(0, map2.size(), \"Map had extra values\");\n        }\n    }\n\n//    @SuppressWarnings(\"unchecked\")\n//    public void testIterator_Key() {\n//        final MultiValuedMap<K, V> map = makeFullMap();\n//        Iterator<V> it = map.iterator(\"k0\");\n//        assertTrue( it.hasNext());\n//        Set<V> values = new HashSet<V>();\n//        while (it.hasNext()) {\n//            values.add(it.next());\n//        }\n//        assertTrue( values.contains(\"v0_1\"));\n//        assertTrue( values.contains(\"v1_1\"));\n//        assertFalse(map.iterator(\"A\").hasNext());\n//        assertFalse(map.iterator(\"A\").hasNext());\n//        if (!isAddSupported()) {\n//            return;\n//        }\n//        map.put((K) \"A\", (V) \"AA\");\n//        it = map.iterator(\"A\");\n//        assertTrue( it.hasNext());\n//        it.next();\n//        assertFalse(it.hasNext());\n//    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testGet() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        final int maxK = getSampleKeySize();\n        final int maxV = getSampleCountPerKey();\n        for (int k = 0; k < maxK; k++) {\n            for (int v = 0; v < maxV; v++) {\n                assertTrue(map.get((K) makeKey(k)).contains(makeValue(k, v)));\n            }\n        }\n    }\n\n    @Test\n    public void testKeyContainsValue() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        final int maxK = getSampleKeySize();\n        final int maxV = getSampleCountPerKey();\n        for (int k = 0; k < maxK; k++) {\n            for (int v = 0; v < maxV; v++) {\n                assertTrue(map.containsMapping(makeKey(k), makeValue(k, v)));\n            }\n        }\n        assertFalse(map.containsMapping(\"k\", \"v\"));\n    }\n\n    @Test\n    @SuppressWarnings({ \"unchecked\", \"cast\" })\n    public void testKeysBagContainsAll() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        final MultiSet<K> keyMultiSet = map.keys();\n\n        final List<String> col = new ArrayList<>();\n        final int maxK = getSampleKeySize();\n        for (int k = 0; k < maxK; k++) {\n            col.add(makeKey(k));\n        }\n        for (int k = 0; k < maxK; k++) {\n            col.add(makeKey(k));\n        }\n        // Make sure we test Collection API\n        assertTrue(keyMultiSet.containsAll((Collection<K>) col));\n    }\n\n    @Test\n    public void testKeysBagIterator1() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        final Collection<K> col = new ArrayList<>(map.keys());\n        final Bag<K> bag = new HashBag<>(col);\n        final int maxK = getSampleKeySize();\n        for (int k = 0; k < maxK; k++) {\n            assertEquals(getSampleCountPerKey(), bag.getCount(makeKey(k)));\n        }\n        assertEquals(getSampleTotalValueCount(), bag.size());\n    }\n\n    @Test\n    public void testKeysBagIterator2() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        final Iterable<K> iterable = new ArrayList<>(map.keys());\n        final Bag<K> bag = new HashBag<>(iterable);\n        final int maxK = getSampleKeySize();\n        for (int k = 0; k < maxK; k++) {\n            assertEquals(getSampleCountPerKey(), bag.getCount(makeKey(k)));\n        }\n        assertEquals(getSampleTotalValueCount(), bag.size());\n    }\n\n    @Test\n    public void testKeySetSize() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        assertEquals(getSampleKeySize(), map.keySet().size());\n    }\n\n    @Test\n    public void testKeysMultiSet() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        final MultiSet<K> keyMultiSet = map.keys();\n        final int maxK = getSampleKeySize();\n        for (int k = 0; k < maxK; k++) {\n            assertEquals(getSampleCountPerKey(), keyMultiSet.getCount(makeKey(k)));\n        }\n        assertEquals(0, keyMultiSet.getCount(\"conut\"));\n        assertEquals(getSampleTotalValueCount(), keyMultiSet.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMapEquals() {\n        assumeTrue(isAddSupported());\n        final MultiValuedMap<K, V> one = makeObject();\n        final Integer value = Integer.valueOf(1);\n        one.put((K) \"One\", (V) value);\n        one.removeMapping(\"One\", value);\n\n        final MultiValuedMap<K, V> two = makeObject();\n        assertEquals(two, one);\n    }\n\n    @Test\n    public void testMapIterator() {\n        resetEmpty();\n        MapIterator<K, V> mapIt  = getMap().mapIterator();\n        assertFalse(mapIt.hasNext());\n\n        resetFull();\n        mapIt = getMap().mapIterator();\n        while (mapIt.hasNext()) {\n            final K key = mapIt.next();\n            final V value = mapIt.getValue();\n            assertTrue(getMap().containsMapping(key, value));\n        }\n    }\n\n    @Test\n    public void testMapIteratorRemove() {\n        assumeTrue(isRemoveSupported());\n        resetFull();\n        final MapIterator<K, V> mapIt = getMap().mapIterator();\n        while (mapIt.hasNext()) {\n            mapIt.next();\n            mapIt.remove();\n        }\n        assertTrue(getMap().isEmpty());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMapIteratorUnsupportedSet() {\n        resetFull();\n        final MapIterator<K, V> mapIt = getMap().mapIterator();\n        mapIt.next();\n        assertThrows(UnsupportedOperationException.class, () -> mapIt.setValue((V) \"some value\"));\n    }\n\n    @Test\n    public void testMultipleValues() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        final int maxK = getSampleKeySize();\n        final int maxV = getSampleCountPerKey();\n        for (int k = 0; k < maxK; k++) {\n            final Collection<V> col = map.get(makeKey(k));\n            for (int v = 0; v < maxV; v++) {\n                assertTrue(col.contains(makeValue(k, v)));\n            }\n        }\n\n    }\n\n    @Test\n    public void testMultiValuedMapIterator() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        final MapIterator<K, V> it = map.mapIterator();\n        assertThrows(IllegalStateException.class, () -> it.getKey());\n        assertThrows(IllegalStateException.class, () -> it.getValue());\n        if (isAddSupported()) {\n            assertThrows(IllegalStateException.class, () -> it.setValue((V) \"V\"));\n        }\n        if (!isHashSetValue() && isAddSupported()) {\n            assertTrue(it.hasNext());\n            final MultiValuedMap<K, V> dejaVu = makeObject();\n            while (it.hasNext()) {\n                final K next = it.next();\n                assertNotNull(next);\n                final K itKey = it.getKey();\n                assertEquals(next, itKey);\n                final V itValue = it.getValue();\n                dejaVu.put(itKey, itValue);\n                assertThrows(UnsupportedOperationException.class, () -> it.setValue((V) \"threetrois\"));\n            }\n            assertEquals(map, dejaVu);\n            assertEquals(dejaVu, map);\n            assertThrows(UnsupportedOperationException.class, () -> it.setValue((V) \"threetrois\"));\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testNoMappingReturnsEmptyCol() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        assertTrue(map.get((K) \"whatever\").isEmpty());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testPutAll_KeyIterable() {\n        assumeTrue(isAddSupported());\n        final MultiValuedMap<K, V> map = makeObject();\n        Collection<V> coll = (Collection<V>) Arrays.asList(\"X\", \"Y\", \"Z\");\n\n        assertTrue(map.putAll((K) \"A\", coll));\n        assertEquals(3, map.get((K) \"A\").size());\n        assertTrue(map.containsMapping(\"A\", \"X\"));\n        assertTrue(map.containsMapping(\"A\", \"Y\"));\n        assertTrue(map.containsMapping(\"A\", \"Z\"));\n\n        assertThrows(NullPointerException.class, () -> map.putAll((K) \"A\", null),\n                \"expecting NullPointerException\");\n\n        assertEquals(3, map.get((K) \"A\").size());\n        assertTrue(map.containsMapping(\"A\", \"X\"));\n        assertTrue(map.containsMapping(\"A\", \"Y\"));\n        assertTrue(map.containsMapping(\"A\", \"Z\"));\n\n        assertFalse(map.putAll((K) \"A\", new ArrayList<>()));\n        assertEquals(3, map.get((K) \"A\").size());\n        assertTrue(map.containsMapping(\"A\", \"X\"));\n        assertTrue(map.containsMapping(\"A\", \"Y\"));\n        assertTrue(map.containsMapping(\"A\", \"Z\"));\n\n        coll = (Collection<V>) Arrays.asList(\"M\");\n        assertTrue(map.putAll((K) \"A\", coll));\n        assertEquals(4, map.get((K) \"A\").size());\n        assertTrue(map.containsMapping(\"A\", \"X\"));\n        assertTrue(map.containsMapping(\"A\", \"Y\"));\n        assertTrue(map.containsMapping(\"A\", \"Z\"));\n        assertTrue(map.containsMapping(\"A\", \"M\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testPutAll_Map1() {\n        assumeTrue(isAddSupported());\n        final MultiValuedMap<K, V> original = makeObject();\n        original.put((K) \"key\", (V) \"object1\");\n        original.put((K) \"key\", (V) \"object2\");\n\n        final MultiValuedMap<K, V> test = makeObject();\n        test.put((K) \"keyA\", (V) \"objectA\");\n        test.put((K) \"key\", (V) \"object0\");\n        test.putAll(original);\n\n        final MultiValuedMap<K, V> originalNull = null;\n        assertThrows(NullPointerException.class, () -> test.putAll(originalNull),\n                \"expecting NullPointerException\");\n\n        assertEquals(2, test.keySet().size());\n        assertEquals(4, test.size());\n        assertEquals(1, test.get((K) \"keyA\").size());\n        assertEquals(3, test.get((K) \"key\").size());\n        assertTrue(test.containsValue(\"objectA\"));\n        assertTrue(test.containsValue(\"object0\"));\n        assertTrue(test.containsValue(\"object1\"));\n        assertTrue(test.containsValue(\"object2\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testPutAll_Map2() {\n        assumeTrue(isAddSupported());\n        final Map<K, V> original = new HashMap<>();\n        original.put((K) \"keyX\", (V) \"object1\");\n        original.put((K) \"keyY\", (V) \"object2\");\n\n        final MultiValuedMap<K, V> test = makeObject();\n        test.put((K) \"keyA\", (V) \"objectA\");\n        test.put((K) \"keyX\", (V) \"object0\");\n        test.putAll(original);\n\n        final Map<K, V> originalNull = null;\n        assertThrows(NullPointerException.class, () -> test.putAll(originalNull),\n                \"expecting NullPointerException\");\n\n        assertEquals(3, test.keySet().size());\n        assertEquals(4, test.size());\n        assertEquals(1, test.get((K) \"keyA\").size());\n        assertEquals(2, test.get((K) \"keyX\").size());\n        assertEquals(1, test.get((K) \"keyY\").size());\n        assertTrue(test.containsValue(\"objectA\"));\n        assertTrue(test.containsValue(\"object0\"));\n        assertTrue(test.containsValue(\"object1\"));\n        assertTrue(test.containsValue(\"object2\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemove_KeyItem() {\n        assumeTrue(isAddSupported());\n        assumeTrue(isRemoveSupported());\n        final MultiValuedMap<K, V> map = makeObject();\n        map.put((K) \"A\", (V) \"AA\");\n        map.put((K) \"A\", (V) \"AB\");\n        map.put((K) \"A\", (V) \"AC\");\n        assertFalse(map.removeMapping(\"C\", \"CA\"));\n        assertFalse(map.removeMapping(\"A\", \"AD\"));\n        assertTrue(map.removeMapping(\"A\", \"AC\"));\n        assertTrue(map.removeMapping(\"A\", \"AB\"));\n        assertTrue(map.removeMapping(\"A\", \"AA\"));\n        //assertEquals(new MultiValuedHashMap<K, V>(), map);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveAllViaEntriesIterator() {\n        assumeTrue(isRemoveSupported());\n        final MultiValuedMap<K, V> map = makeFullMap();\n        for (final Iterator<?> i = map.entries().iterator(); i.hasNext();) {\n            i.next();\n            i.remove();\n        }\n        assertTrue(map.get((K) \"k0\").isEmpty());\n        assertEquals(0, map.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testRemoveAllViaValuesIterator() {\n        assumeTrue(isRemoveSupported());\n        final MultiValuedMap<K, V> map = makeFullMap();\n        for (final Iterator<?> i = map.values().iterator(); i.hasNext();) {\n            i.next();\n            i.remove();\n        }\n        assertTrue(map.get((K) \"k0\").isEmpty());\n        assertTrue(map.isEmpty());\n    }\n\n    @Test\n    public void testRemoveMappingThroughGet() {\n        assumeTrue(isRemoveSupported());\n        resetFull();\n        final MultiValuedMap<K, V> map = getMap();\n        final int cpk = getSampleCountPerKey();\n        int expectedCount = getSampleTotalValueCount();\n        assertEquals(expectedCount, map.size());\n        for (int k = 0; k < getSampleKeySize(); k++) {\n            final Object key = makeKey(k);\n            @SuppressWarnings(\"unchecked\")\n            Collection<V> col = map.get((K) key);\n            assertEquals(cpk, col.size());\n            for (int i = 0; i < cpk; i++) {\n                final Object value = makeValue(k, i);\n                assertTrue(col.remove(value), () -> value.toString());\n            }\n            for (int i = 0; i < cpk; i++) {\n                assertFalse(col.remove(makeValue(k, i)));\n            }\n            assertFalse(map.containsKey(key));\n            for (int i = 0; i < cpk; i++) {\n                assertFalse(map.containsMapping(key, i));\n            }\n            for (int i = 0; i < cpk; i++) {\n                assertFalse(map.containsValue(makeValue(k, i)));\n            }\n            expectedCount -= cpk;\n            assertEquals(expectedCount, map.size());\n            col = map.remove(key);\n            assertNotNull(col);\n            assertEquals(0, col.size());\n        }\n    }\n\n    @Test\n    public void testRemoveMappingThroughGetIterator() {\n        assumeTrue(isRemoveSupported());\n        resetFull();\n        final MultiValuedMap<K, V> map = getMap();\n        int expectedSize = map.size();\n        final int maxK = getSampleKeySize();\n        for (int k = 0; k < maxK; k++) {\n            final String key = makeKey(k);\n            final int cpk = getSampleCountPerKey();\n            @SuppressWarnings(\"unchecked\")\n            final Iterator<V> it = map.get((K) key).iterator();\n            while (it.hasNext()) {\n                it.next();\n                it.remove();\n            }\n            assertFalse(map.containsKey(key));\n            for (int j = 0; j < cpk; j++) {\n                assertFalse(map.containsMapping(key, makeValue(k + 1, j)));\n                final Object value = makeValue(k, j);\n                assertFalse(map.containsMapping(key, value));\n                assertFalse(map.containsValue(value));\n            }\n            expectedSize -= cpk;\n            assertEquals(expectedSize, map.size());\n            final Collection<V> coll = map.remove(\"k0\");\n            assertNotNull(coll);\n            assertEquals(0, coll.size());\n        }\n    }\n\n    @Test\n    public void testRemoveViaValuesRemove() {\n        assumeTrue(isRemoveSupported());\n        final MultiValuedMap<K, V> map = makeFullMap();\n        final Collection<V> values = map.values();\n        final int maxK = getSampleKeySize();\n        final int maxV = getSampleCountPerKey();\n        int expectedSize = map.size();\n        for (int k = 0; k < maxK; k++) {\n            for (int v = 0; v < maxV; v++) {\n                values.remove(makeValue(k, v));\n            }\n            assertFalse(map.containsKey(makeKey(k)));\n            expectedSize -= maxV;\n            assertEquals(expectedSize, map.size());\n        }\n        assertEquals(0, map.size());\n    }\n\n    @Test\n    public void testSize() {\n        assertEquals(getSampleTotalValueCount(), makeFullMap().size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSize_Key() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        final int maxK = getSampleKeySize();\n        for (int k = 0; k < maxK; k++) {\n            assertEquals(getSampleCountPerKey(), map.get((K) makeKey(k)).size());\n        }\n        if (!isAddSupported()) {\n            return;\n        }\n        map.put((K) \"A\", (V) \"AA\");\n        assertEquals(1, map.get((K) \"A\").size());\n        // assertEquals(0, map.get(\"B\").size());\n        map.put((K) \"B\", (V) \"BA\");\n        assertEquals(1, map.get((K) \"A\").size());\n        assertEquals(1, map.get((K) \"B\").size());\n        map.put((K) \"B\", (V) \"BB\");\n        assertEquals(1, map.get((K) \"A\").size());\n        assertEquals(2, map.get((K) \"B\").size());\n        map.put((K) \"B\", (V) \"BC\");\n        assertEquals(1, map.get((K) \"A\").size());\n        assertEquals(3, map.get((K) \"B\").size());\n        if (!isRemoveSupported()) {\n            return;\n        }\n        map.remove(\"A\");\n        // assertEquals(0, map.get(\"A\").size());\n        assertEquals(3, map.get((K) \"B\").size());\n        map.removeMapping(\"B\", \"BC\");\n        // assertEquals(0, map.get(\"A\").size());\n        assertEquals(2, map.get((K) \"B\").size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSizeWithPutRemove() {\n        assumeTrue(isAddSupported());\n        assumeTrue(isRemoveSupported());\n        final MultiValuedMap<K, V> map = makeObject();\n        assertEquals(0, map.size());\n        map.put((K) \"A\", (V) \"AA\");\n        assertEquals(1, map.size());\n        map.put((K) \"B\", (V) \"BA\");\n        assertEquals(2, map.size());\n        map.put((K) \"B\", (V) \"BB\");\n        assertEquals(3, map.size());\n        map.put((K) \"B\", (V) \"BC\");\n        assertEquals(4, map.size());\n        map.remove(\"A\");\n        assertEquals(3, map.size());\n        map.removeMapping(\"B\", \"BC\");\n        assertEquals(2, map.size());\n    }\n\n    @Test\n    public void testToString() {\n        assumeTrue(isAddSupported());\n        final MultiValuedMap<K, V> map = makeObject();\n        map.put((K) \"A\", (V) \"X\");\n        map.put((K) \"A\", (V) \"Y\");\n        map.put((K) \"A\", (V) \"Z\");\n        map.put((K) \"B\", (V) \"U\");\n        map.put((K) \"B\", (V) \"V\");\n        map.put((K) \"B\", (V) \"W\");\n        assertTrue(\"{A=[X, Y, Z], B=[U, V, W]}\".equals(map.toString()) || \"{B=[U, V, W], A=[X, Y, Z]}\".equals(map.toString()));\n\n        final MultiValuedMap<K, V> originalNull = null;\n        assertThrows(NullPointerException.class, () -> map.putAll(originalNull), \"expecting NullPointerException\");\n        assertTrue(\"{A=[X, Y, Z], B=[U, V, W]}\".equals(map.toString()) || \"{B=[U, V, W], A=[X, Y, Z]}\".equals(map.toString()));\n\n        map.remove(\"A\");\n        map.remove(\"B\");\n        assertEquals(\"{}\", map.toString());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testValues() {\n        final MultiValuedMap<K, V> map = makeFullMap();\n        final HashSet<V> expected = new HashSet<>();\n        final int maxK = getSampleKeySize();\n        final int maxV = getSampleCountPerKey();\n        for (int k = 0; k < maxK; k++) {\n            for (int v = 0; v < maxV; v++) {\n                expected.add((V) makeValue(k, v));\n            }\n        }\n        final Collection<V> c = map.values();\n        assertEquals(getSampleTotalValueCount(), c.size());\n        assertEquals(expected, new HashSet<>(c));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected MultiValuedMap<K, V> map;", "docstring": " Map created by reset().", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "MultiValuedMap<K, V>", "name": "map", "syntax_pass": true}, {"attribute_expression": "protected MultiValuedMap<K, V> confirmed;", "docstring": " MultiValuedHashMap created by reset().", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "MultiValuedMap<K, V>", "name": "confirmed", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/collections4/multiset/AbstractMultiSetTest.java.AbstractMultiSetTest", "name": "AbstractMultiSetTest", "file_path": "src/test/java/org/apache/commons/collections4/multiset/AbstractMultiSetTest.java", "superclasses": "", "methods": ["[]AbstractMultiSetTest(String)", "[BulkTest]bulkTestMultiSetUniqueSet()", "[MultiSet<T>]getCollection()", "[Collection<T>]makeConfirmedCollection()", "[Collection<T>]makeConfirmedFullCollection()", "[MultiSet<T>]makeFullCollection()", "[MultiSet<T>]makeObject()", "[void]resetEmpty()", "[void]resetFull()"], "method_uris": ["src/test/java/org/apache/commons/collections4/multiset/AbstractMultiSetTest.java.AbstractMultiSetTest.[]AbstractMultiSetTest(String)", "src/test/java/org/apache/commons/collections4/multiset/AbstractMultiSetTest.java.AbstractMultiSetTest.[BulkTest]bulkTestMultiSetUniqueSet()", "src/test/java/org/apache/commons/collections4/multiset/AbstractMultiSetTest.java.AbstractMultiSetTest.[MultiSet<T>]getCollection()", "src/test/java/org/apache/commons/collections4/multiset/AbstractMultiSetTest.java.AbstractMultiSetTest.[Collection<T>]makeConfirmedCollection()", "src/test/java/org/apache/commons/collections4/multiset/AbstractMultiSetTest.java.AbstractMultiSetTest.[Collection<T>]makeConfirmedFullCollection()", "src/test/java/org/apache/commons/collections4/multiset/AbstractMultiSetTest.java.AbstractMultiSetTest.[MultiSet<T>]makeFullCollection()", "src/test/java/org/apache/commons/collections4/multiset/AbstractMultiSetTest.java.AbstractMultiSetTest.[MultiSet<T>]makeObject()", "src/test/java/org/apache/commons/collections4/multiset/AbstractMultiSetTest.java.AbstractMultiSetTest.[void]resetEmpty()", "src/test/java/org/apache/commons/collections4/multiset/AbstractMultiSetTest.java.AbstractMultiSetTest.[void]resetFull()"], "overrides": null, "attributes": [{"original_string": "    public class TestMultiSetUniqueSet extends AbstractSetTest<T> {\n        public TestMultiSetUniqueSet() {\n            super(StringUtils.EMPTY);\n        }\n\n        @Override\n        public T[] getFullElements() {\n            return AbstractMultiSetTest.this.getFullElements();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiSetTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public T[] getOtherElements() {\n            return AbstractMultiSetTest.this.getOtherElements();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractMultiSetTest.this.isNullSupported();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMultiSetTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Set<T> makeFullCollection() {\n            return AbstractMultiSetTest.this.makeFullCollection().uniqueSet();\n        }\n\n        @Override\n        public Set<T> makeObject() {\n            return AbstractMultiSetTest.this.makeObject().uniqueSet();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractMultiSetTest.this.resetEmpty();\n            TestMultiSetUniqueSet.this.setCollection(AbstractMultiSetTest.this.getCollection().uniqueSet());\n            TestMultiSetUniqueSet.this.setConfirmed(new HashSet<>(AbstractMultiSetTest.this.getConfirmed()));\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractMultiSetTest.this.resetFull();\n            TestMultiSetUniqueSet.this.setCollection(AbstractMultiSetTest.this.getCollection().uniqueSet());\n            TestMultiSetUniqueSet.this.setConfirmed(new HashSet<>(AbstractMultiSetTest.this.getConfirmed()));\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n        }\n    }", "definition": "    public class TestMultiSetUniqueSet extends AbstractSetTest<T>", "class_docstring": "", "name": "TestMultiSetUniqueSet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TestMultiSetUniqueSet() {\n            super(StringUtils.EMPTY);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TestMultiSetUniqueSet", "params": [], "body": "                                       {\n            super(StringUtils.EMPTY);\n        }", "signature": "public TestMultiSetUniqueSet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public T[] getFullElements() {\n            return AbstractMultiSetTest.this.getFullElements();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T[]", "classes": []}, "name": "getFullElements", "params": [], "body": "                                     {\n            return AbstractMultiSetTest.this.getFullElements();\n        }", "signature": "@Override\n        public T[] getFullElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiSetTest.this.getIterationBehaviour();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "getIterationBehaviour", "params": [], "body": "                                              {\n            return AbstractMultiSetTest.this.getIterationBehaviour();\n        }", "signature": "@Override\n        protected int getIterationBehaviour()"}, {"syntax_pass": true, "original_string": "        @Override\n        public T[] getOtherElements() {\n            return AbstractMultiSetTest.this.getOtherElements();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T[]", "classes": []}, "name": "getOtherElements", "params": [], "body": "                                      {\n            return AbstractMultiSetTest.this.getOtherElements();\n        }", "signature": "@Override\n        public T[] getOtherElements()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isAddSupported() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isAddSupported", "params": [], "body": "                                        {\n            return false;\n        }", "signature": "@Override\n        public boolean isAddSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isNullSupported() {\n            return AbstractMultiSetTest.this.isNullSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isNullSupported", "params": [], "body": "                                         {\n            return AbstractMultiSetTest.this.isNullSupported();\n        }", "signature": "@Override\n        public boolean isNullSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMultiSetTest.this.isRemoveSupported();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isRemoveSupported", "params": [], "body": "                                           {\n            return AbstractMultiSetTest.this.isRemoveSupported();\n        }", "signature": "@Override\n        public boolean isRemoveSupported()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isTestSerialization", "params": [], "body": "                                             {\n            return false;\n        }", "signature": "@Override\n        public boolean isTestSerialization()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<T> makeFullCollection() {\n            return AbstractMultiSetTest.this.makeFullCollection().uniqueSet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<T>", "classes": []}, "name": "makeFullCollection", "params": [], "body": "                                           {\n            return AbstractMultiSetTest.this.makeFullCollection().uniqueSet();\n        }", "signature": "@Override\n        public Set<T> makeFullCollection()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<T> makeObject() {\n            return AbstractMultiSetTest.this.makeObject().uniqueSet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<T>", "classes": []}, "name": "makeObject", "params": [], "body": "                                   {\n            return AbstractMultiSetTest.this.makeObject().uniqueSet();\n        }", "signature": "@Override\n        public Set<T> makeObject()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetEmpty() {\n            AbstractMultiSetTest.this.resetEmpty();\n            TestMultiSetUniqueSet.this.setCollection(AbstractMultiSetTest.this.getCollection().uniqueSet());\n            TestMultiSetUniqueSet.this.setConfirmed(new HashSet<>(AbstractMultiSetTest.this.getConfirmed()));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetEmpty", "params": [], "body": "                                 {\n            AbstractMultiSetTest.this.resetEmpty();\n            TestMultiSetUniqueSet.this.setCollection(AbstractMultiSetTest.this.getCollection().uniqueSet());\n            TestMultiSetUniqueSet.this.setConfirmed(new HashSet<>(AbstractMultiSetTest.this.getConfirmed()));\n        }", "signature": "@Override\n        public void resetEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void resetFull() {\n            AbstractMultiSetTest.this.resetFull();\n            TestMultiSetUniqueSet.this.setCollection(AbstractMultiSetTest.this.getCollection().uniqueSet());\n            TestMultiSetUniqueSet.this.setConfirmed(new HashSet<>(AbstractMultiSetTest.this.getConfirmed()));\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "resetFull", "params": [], "body": "                                {\n            AbstractMultiSetTest.this.resetFull();\n            TestMultiSetUniqueSet.this.setCollection(AbstractMultiSetTest.this.getCollection().uniqueSet());\n            TestMultiSetUniqueSet.this.setConfirmed(new HashSet<>(AbstractMultiSetTest.this.getConfirmed()));\n        }", "signature": "@Override\n        public void resetFull()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void verify() {\n            super.verify();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "verify", "params": [], "body": "                             {\n            super.verify();\n        }", "signature": "@Override\n        public void verify()"}]}], "class_docstring": "\nAbstract test class for {@link org.apache.commons.collections4.MultiSet MultiSet}\nmethods and contracts.\n<p>\nTo use, simply extend this class, and implement\nthe {@link #makeObject} method.\n<p>\nIf your multiset fails one of these tests by design,\nyou may still use this base set of cases.  Simply override the\ntest case (method) your multiset fails.\n<p>\nThis abstract test class does wrap the concrete multiset implementation\nwith such a decorator, see the overridden {@link #resetEmpty()} and\n{@link #resetFull()} methods.\n<p>\nIn addition to the generic collection tests (prefix testCollection) inherited\nfrom AbstractCollectionTest, there are test methods that test the \"normal\" MultiSet\ninterface (prefix testMultiSet). For MultiSet specific tests use the {@link #makeObject()} and\n{@link #makeFullCollection()} methods instead of {@link #resetEmpty()} and resetFull().\n", "original_string": "public abstract class AbstractMultiSetTest<T> extends AbstractCollectionTest<T> {\n\n    public class TestMultiSetUniqueSet extends AbstractSetTest<T> {\n        public TestMultiSetUniqueSet() {\n            super(StringUtils.EMPTY);\n        }\n\n        @Override\n        public T[] getFullElements() {\n            return AbstractMultiSetTest.this.getFullElements();\n        }\n\n        @Override\n        protected int getIterationBehaviour() {\n            return AbstractMultiSetTest.this.getIterationBehaviour();\n        }\n\n        @Override\n        public T[] getOtherElements() {\n            return AbstractMultiSetTest.this.getOtherElements();\n        }\n\n        @Override\n        public boolean isAddSupported() {\n            return false;\n        }\n\n        @Override\n        public boolean isNullSupported() {\n            return AbstractMultiSetTest.this.isNullSupported();\n        }\n\n        @Override\n        public boolean isRemoveSupported() {\n            return AbstractMultiSetTest.this.isRemoveSupported();\n        }\n\n        @Override\n        public boolean isTestSerialization() {\n            return false;\n        }\n\n        @Override\n        public Set<T> makeFullCollection() {\n            return AbstractMultiSetTest.this.makeFullCollection().uniqueSet();\n        }\n\n        @Override\n        public Set<T> makeObject() {\n            return AbstractMultiSetTest.this.makeObject().uniqueSet();\n        }\n\n        @Override\n        public void resetEmpty() {\n            AbstractMultiSetTest.this.resetEmpty();\n            TestMultiSetUniqueSet.this.setCollection(AbstractMultiSetTest.this.getCollection().uniqueSet());\n            TestMultiSetUniqueSet.this.setConfirmed(new HashSet<>(AbstractMultiSetTest.this.getConfirmed()));\n        }\n\n        @Override\n        public void resetFull() {\n            AbstractMultiSetTest.this.resetFull();\n            TestMultiSetUniqueSet.this.setCollection(AbstractMultiSetTest.this.getCollection().uniqueSet());\n            TestMultiSetUniqueSet.this.setConfirmed(new HashSet<>(AbstractMultiSetTest.this.getConfirmed()));\n        }\n\n        @Override\n        public void verify() {\n            super.verify();\n        }\n    }\n\n    /**\n     * JUnit constructor.\n     *\n     * @param testName  the test class name\n     */\n    public AbstractMultiSetTest(final String testName) {\n        super(testName);\n    }\n\n    /**\n     * Bulk test {@link MultiSet#uniqueSet()}.  This method runs through all of\n     * the tests in {@link AbstractSetTest}.\n     * After modification operations, {@link #verify()} is invoked to ensure\n     * that the multiset and the other collection views are still valid.\n     *\n     * @return a {@link AbstractSetTest} instance for testing the multiset's unique set\n     */\n    public BulkTest bulkTestMultiSetUniqueSet() {\n        return new TestMultiSetUniqueSet();\n    }\n\n    /**\n     * Returns the {@link #collection} field cast to a {@link MultiSet}.\n     *\n     * @return the collection field as a MultiSet\n     */\n    @Override\n    public MultiSet<T> getCollection() {\n        return (MultiSet<T>) super.getCollection();\n    }\n\n    /**\n     * Returns an empty {@link ArrayList}.\n     */\n    @Override\n    public Collection<T> makeConfirmedCollection() {\n        return new ArrayList<>();\n    }\n\n    /**\n     * Returns a full collection.\n     */\n    @Override\n    public Collection<T> makeConfirmedFullCollection() {\n        final Collection<T> coll = makeConfirmedCollection();\n        coll.addAll(Arrays.asList(getFullElements()));\n        return coll;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MultiSet<T> makeFullCollection() {\n        final MultiSet<T> multiset = makeObject();\n        multiset.addAll(Arrays.asList(getFullElements()));\n        return multiset;\n    }\n\n    /**\n     * Return a new, empty multiset to used for testing.\n     *\n     * @return the multiset to be tested\n     */\n    @Override\n    public abstract MultiSet<T> makeObject();\n\n    @Override\n    public void resetEmpty() {\n        setCollection(makeObject());\n        setConfirmed(makeConfirmedCollection());\n    }\n\n    @Override\n    public void resetFull() {\n        setCollection(makeFullCollection());\n        setConfirmed(makeConfirmedFullCollection());\n    }\n\n    /**\n     * Compare the current serialized form of the MultiSet\n     * against the canonical version in SCM.\n     */\n    @Test\n    public void testEmptyMultiSetCompatibility() throws IOException, ClassNotFoundException {\n        // test to make sure the canonical form has been preserved\n        final MultiSet<T> multiset = makeObject();\n        if (multiset instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n            final MultiSet<?> multiset2 = (MultiSet<?>) readExternalFormFromDisk(getCanonicalEmptyCollectionName(multiset));\n            assertTrue(multiset2.isEmpty(), \"MultiSet is empty\");\n            assertEquals(multiset, multiset2);\n        }\n    }\n\n    /**\n     * Compare the current serialized form of the MultiSet\n     * against the canonical version in SCM.\n     */\n    @Test\n    public void testFullMultiSetCompatibility() throws IOException, ClassNotFoundException {\n        // test to make sure the canonical form has been preserved\n        final MultiSet<T> multiset = makeFullCollection();\n        if (multiset instanceof Serializable && !skipSerializedCanonicalTests() && isTestSerialization()) {\n            final MultiSet<?> multiset2 = (MultiSet<?>) readExternalFormFromDisk(getCanonicalFullCollectionName(multiset));\n            assertEquals(multiset.size(), multiset2.size(), \"MultiSet is the right size\");\n            assertEquals(multiset, multiset2);\n        }\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetAdd() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        multiset.add((T) \"A\");\n        assertTrue(multiset.contains(\"A\"), \"Should contain 'A'\");\n        assertEquals(1, multiset.getCount(\"A\"), \"Should have count of 1\");\n        multiset.add((T) \"A\");\n        assertTrue(multiset.contains(\"A\"), \"Should contain 'A'\");\n        assertEquals(2, multiset.getCount(\"A\"), \"Should have count of 2\");\n        multiset.add((T) \"B\");\n        assertTrue(multiset.contains(\"A\"));\n        assertTrue(multiset.contains(\"B\"));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetContains() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n\n        assertFalse(multiset.contains(\"A\"), \"MultiSet does not have at least 1 'A'\");\n        assertFalse(multiset.contains(\"B\"), \"MultiSet does not have at least 1 'B'\");\n\n        multiset.add((T) \"A\");  // multiset 1A\n        assertTrue(multiset.contains(\"A\"), \"MultiSet has at least 1 'A'\");\n        assertFalse(multiset.contains(\"B\"), \"MultiSet does not have at least 1 'B'\");\n\n        multiset.add((T) \"A\");  // multiset 2A\n        assertTrue(multiset.contains(\"A\"), \"MultiSet has at least 1 'A'\");\n        assertFalse(multiset.contains(\"B\"), \"MultiSet does not have at least 1 'B'\");\n\n        multiset.add((T) \"B\");  // multiset 2A,1B\n        assertTrue(multiset.contains(\"A\"), \"MultiSet has at least 1 'A'\");\n        assertTrue(multiset.contains(\"B\"), \"MultiSet has at least 1 'B'\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetContainsAll() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        final List<String> known = new ArrayList<>();\n        final List<String> known1A = new ArrayList<>();\n        known1A.add(\"A\");\n        final List<String> known2A = new ArrayList<>();\n        known2A.add(\"A\");\n        known2A.add(\"A\");\n        final List<String> known1B = new ArrayList<>();\n        known1B.add(\"B\");\n        final List<String> known1A1B = new ArrayList<>();\n        known1A1B.add(\"A\");\n        known1A1B.add(\"B\");\n\n        assertTrue(multiset.containsAll(known), \"MultiSet containsAll of empty\");\n        assertFalse(multiset.containsAll(known1A), \"MultiSet does not containsAll of 1 'A'\");\n        assertFalse(multiset.containsAll(known2A), \"MultiSet does not containsAll of 2 'A'\");\n        assertFalse(multiset.containsAll(known1B), \"MultiSet does not containsAll of 1 'B'\");\n        assertFalse(multiset.containsAll(known1A1B), \"MultiSet does not containsAll of 1 'A' 1 'B'\");\n\n        multiset.add((T) \"A\");  // multiset 1A\n        assertTrue(multiset.containsAll(known), \"MultiSet containsAll of empty\");\n        assertTrue(multiset.containsAll(known1A), \"MultiSet containsAll of 1 'A'\");\n        assertTrue(multiset.containsAll(known2A), \"MultiSet does not containsAll 'A'\");\n        assertFalse(multiset.containsAll(known1B), \"MultiSet does not containsAll of 1 'B'\");\n        assertFalse(multiset.containsAll(known1A1B), \"MultiSet does not containsAll of 1 'A' 1 'B'\");\n\n        multiset.add((T) \"A\");  // multiset 2A\n        assertTrue(multiset.containsAll(known), \"MultiSet containsAll of empty\");\n        assertTrue(multiset.containsAll(known1A), \"MultiSet containsAll of 1 'A'\");\n        assertTrue(multiset.containsAll(known2A), \"MultiSet containsAll of 2 'A'\");\n        assertFalse(multiset.containsAll(known1B), \"MultiSet does not containsAll of 1 'B'\");\n        assertFalse(multiset.containsAll(known1A1B), \"MultiSet does not containsAll of 1 'A' 1 'B'\");\n\n        multiset.add((T) \"A\");  // multiset 3A\n        assertTrue(multiset.containsAll(known), \"MultiSet containsAll of empty\");\n        assertTrue(multiset.containsAll(known1A), \"MultiSet containsAll of 1 'A'\");\n        assertTrue(multiset.containsAll(known2A), \"MultiSet containsAll of 2 'A'\");\n        assertFalse(multiset.containsAll(known1B), \"MultiSet does not containsAll of 1 'B'\");\n        assertFalse(multiset.containsAll(known1A1B), \"MultiSet does not containsAll of 1 'A' 1 'B'\");\n\n        multiset.add((T) \"B\");  // multiset 3A1B\n        assertTrue(multiset.containsAll(known), \"MultiSet containsAll of empty\");\n        assertTrue(multiset.containsAll(known1A), \"MultiSet containsAll of 1 'A'\");\n        assertTrue(multiset.containsAll(known2A), \"MultiSet containsAll of 2 'A'\");\n        assertTrue(multiset.containsAll(known1B), \"MultiSet containsAll of 1 'B'\");\n        assertTrue(multiset.containsAll(known1A1B), \"MultiSet containsAll of 1 'A' 1 'B'\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetEntrySetUpdatedToZero() {\n        if (!isAddSupported()) {\n            return;\n        }\n        final MultiSet<T> multiset = makeObject();\n        multiset.add((T) \"A\");\n        multiset.add((T) \"A\");\n        final MultiSet.Entry<T> entry = multiset.entrySet().iterator().next();\n        assertEquals(2, entry.getCount());\n        multiset.remove(\"A\");\n        assertEquals(1, entry.getCount());\n        multiset.remove(\"A\");\n        assertEquals(0, entry.getCount());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetEquals() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        final MultiSet<T> multiset2 = makeObject();\n        assertTrue(multiset.equals(multiset2));\n        multiset.add((T) \"A\");\n        assertFalse(multiset.equals(multiset2));\n        multiset2.add((T) \"A\");\n        assertTrue(multiset.equals(multiset2));\n        multiset.add((T) \"A\");\n        multiset.add((T) \"B\");\n        multiset.add((T) \"B\");\n        multiset.add((T) \"C\");\n        multiset2.add((T) \"A\");\n        multiset2.add((T) \"B\");\n        multiset2.add((T) \"B\");\n        multiset2.add((T) \"C\");\n        assertTrue(multiset.equals(multiset2));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetEqualsHashMultiSet() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        final MultiSet<T> multiset2 = new HashMultiSet<>();\n        assertTrue(multiset.equals(multiset2));\n        multiset.add((T) \"A\");\n        assertFalse(multiset.equals(multiset2));\n        multiset2.add((T) \"A\");\n        assertTrue(multiset.equals(multiset2));\n        multiset.add((T) \"A\");\n        multiset.add((T) \"B\");\n        multiset.add((T) \"B\");\n        multiset.add((T) \"C\");\n        multiset2.add((T) \"A\");\n        multiset2.add((T) \"B\");\n        multiset2.add((T) \"B\");\n        multiset2.add((T) \"C\");\n        assertTrue(multiset.equals(multiset2));\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetEqualsSelf() {\n        final MultiSet<T> multiset = makeObject();\n        assertEquals(multiset, multiset);\n\n        if (!isAddSupported()) {\n            return;\n        }\n\n        multiset.add((T) \"elt\");\n        assertEquals(multiset, multiset);\n        multiset.add((T) \"elt\"); // again\n        assertEquals(multiset, multiset);\n        multiset.add((T) \"elt2\");\n        assertEquals(multiset, multiset);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetHashCode() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        final MultiSet<T> multiset2 = makeObject();\n        assertEquals(0, multiset.hashCode());\n        assertEquals(0, multiset2.hashCode());\n        assertEquals(multiset.hashCode(), multiset2.hashCode());\n        multiset.add((T) \"A\");\n        multiset.add((T) \"A\");\n        multiset.add((T) \"B\");\n        multiset.add((T) \"B\");\n        multiset.add((T) \"C\");\n        multiset2.add((T) \"A\");\n        multiset2.add((T) \"A\");\n        multiset2.add((T) \"B\");\n        multiset2.add((T) \"B\");\n        multiset2.add((T) \"C\");\n        assertEquals(multiset.hashCode(), multiset2.hashCode());\n\n        int total = 0;\n        total += \"A\".hashCode() ^ 2;\n        total += \"B\".hashCode() ^ 2;\n        total += \"C\".hashCode() ^ 1;\n        assertEquals(total, multiset.hashCode());\n        assertEquals(total, multiset2.hashCode());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetIterator() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        multiset.add((T) \"A\");\n        multiset.add((T) \"A\");\n        multiset.add((T) \"B\");\n        assertEquals(3, multiset.size(), \"MultiSet should have 3 items\");\n        final Iterator<T> i = multiset.iterator();\n\n        boolean foundA = false;\n        while (i.hasNext()) {\n            final String element = (String) i.next();\n            // ignore the first A, remove the second via Iterator.remove()\n            if (element.equals(\"A\")) {\n                if (!foundA) {\n                    foundA = true;\n                } else {\n                    i.remove();\n                }\n            }\n        }\n\n        assertTrue(multiset.contains(\"A\"), \"MultiSet should still contain 'A'\");\n        assertEquals(2, multiset.size(), \"MultiSet should have 2 items\");\n        assertEquals(1, multiset.getCount(\"A\"), \"MultiSet should have 1 'A'\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetIteratorFail() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        multiset.add((T) \"A\");\n        multiset.add((T) \"A\");\n        multiset.add((T) \"B\");\n        final Iterator<T> it = multiset.iterator();\n        it.next();\n        multiset.remove(\"A\");\n        assertThrows(ConcurrentModificationException.class, () -> it.next(),\n                \"Should throw ConcurrentModificationException\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetIteratorFailDoubleRemove() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        multiset.add((T) \"A\");\n        multiset.add((T) \"A\");\n        multiset.add((T) \"B\");\n        final Iterator<T> it = multiset.iterator();\n        it.next();\n        it.next();\n        assertEquals(3, multiset.size());\n        it.remove();\n        assertEquals(2, multiset.size());\n        assertThrows(IllegalStateException.class, () -> it.remove(),\n                \"Should throw IllegalStateException\");\n        assertEquals(2, multiset.size());\n        it.next();\n        it.remove();\n        assertEquals(1, multiset.size());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetIteratorFailNoMore() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        multiset.add((T) \"A\");\n        multiset.add((T) \"A\");\n        multiset.add((T) \"B\");\n        final Iterator<T> it = multiset.iterator();\n        it.next();\n        it.next();\n        it.next();\n        assertThrows(NoSuchElementException.class, () -> it.next(),\n                \"Should throw NoSuchElementException\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetIteratorRemoveProtectsInvariants() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        multiset.add((T) \"A\");\n        multiset.add((T) \"A\");\n        assertEquals(2, multiset.size());\n        final Iterator<T> it = multiset.iterator();\n        assertEquals(\"A\", it.next());\n        assertTrue(it.hasNext());\n        it.remove();\n        assertEquals(1, multiset.size());\n        assertTrue(it.hasNext());\n        assertEquals(\"A\", it.next());\n        assertFalse(it.hasNext());\n        it.remove();\n        assertEquals(0, multiset.size());\n        assertFalse(it.hasNext());\n\n        final Iterator<T> it2 = multiset.iterator();\n        assertFalse(it2.hasNext());\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetRemove() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        multiset.add((T) \"A\");\n        assertEquals(1, multiset.getCount(\"A\"), \"Should have count of 1\");\n        multiset.remove(\"A\");\n        assertEquals(0, multiset.getCount(\"A\"), \"Should have count of 0\");\n        multiset.add((T) \"A\");\n        multiset.add((T) \"A\");\n        multiset.add((T) \"A\");\n        multiset.add((T) \"A\");\n        assertEquals(4, multiset.getCount(\"A\"), \"Should have count of 4\");\n        multiset.remove(\"A\", 0);\n        assertEquals(4, multiset.getCount(\"A\"), \"Should have count of 4\");\n        multiset.remove(\"A\", 2);\n        assertEquals(2, multiset.getCount(\"A\"), \"Should have count of 2\");\n        multiset.remove(\"A\");\n        assertEquals(1, multiset.getCount(\"A\"), \"Should have count of 1\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetRemoveAll() {\n        if (!isRemoveSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        multiset.add((T) \"A\", 2);\n        assertEquals(2, multiset.getCount(\"A\"), \"Should have count of 2\");\n        multiset.add((T) \"B\");\n        multiset.add((T) \"C\");\n        assertEquals(4, multiset.size(), \"Should have count of 4\");\n        final List<String> delete = new ArrayList<>();\n        delete.add(\"A\");\n        delete.add(\"B\");\n        multiset.removeAll(delete);\n        assertEquals(0, multiset.getCount(\"A\"), \"Should have count of 0\");\n        assertEquals(0, multiset.getCount(\"B\"), \"Should have count of 0\");\n        assertEquals(1, multiset.getCount(\"C\"), \"Should have count of 1\");\n        assertEquals(1, multiset.size(), \"Should have count of 1\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetRetainAll() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        multiset.add((T) \"A\");\n        multiset.add((T) \"A\");\n        multiset.add((T) \"A\");\n        multiset.add((T) \"B\");\n        multiset.add((T) \"B\");\n        multiset.add((T) \"C\");\n        final List<String> retains = new ArrayList<>();\n        retains.add(\"B\");\n        retains.add(\"C\");\n        multiset.retainAll(retains);\n        assertEquals(3, multiset.size(), \"Should have 3 total items\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetSize() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        assertEquals(0, multiset.size(), \"Should have 0 total items\");\n        multiset.add((T) \"A\");\n        assertEquals(1, multiset.size(), \"Should have 1 total items\");\n        multiset.add((T) \"A\");\n        assertEquals(2, multiset.size(), \"Should have 2 total items\");\n        multiset.add((T) \"A\");\n        assertEquals(3, multiset.size(), \"Should have 3 total items\");\n        multiset.add((T) \"B\");\n        assertEquals(4, multiset.size(), \"Should have 4 total items\");\n        multiset.add((T) \"B\");\n        assertEquals(5, multiset.size(), \"Should have 5 total items\");\n        multiset.remove(\"A\", 2);\n        assertEquals(1, multiset.getCount(\"A\"), \"Should have 1 'A'\");\n        assertEquals(3, multiset.size(), \"Should have 3 total items\");\n        multiset.remove(\"B\");\n        assertEquals(2, multiset.size(), \"Should have 2 total item\");\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetToArray() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        multiset.add((T) \"A\");\n        multiset.add((T) \"A\");\n        multiset.add((T) \"B\");\n        multiset.add((T) \"B\");\n        multiset.add((T) \"C\");\n        final Object[] array = multiset.toArray();\n        int a = 0, b = 0, c = 0;\n        for (final Object element : array) {\n            a += element.equals(\"A\") ? 1 : 0;\n            b += element.equals(\"B\") ? 1 : 0;\n            c += element.equals(\"C\") ? 1 : 0;\n        }\n        assertEquals(2, a);\n        assertEquals(2, b);\n        assertEquals(1, c);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testMultiSetToArrayPopulate() {\n        if (!isAddSupported()) {\n            return;\n        }\n\n        final MultiSet<T> multiset = makeObject();\n        multiset.add((T) \"A\");\n        multiset.add((T) \"A\");\n        multiset.add((T) \"B\");\n        multiset.add((T) \"B\");\n        multiset.add((T) \"C\");\n        final String[] array = multiset.toArray(ArrayUtils.EMPTY_STRING_ARRAY);\n        int a = 0, b = 0, c = 0;\n        for (final String element : array) {\n            a += element.equals(\"A\") ? 1 : 0;\n            b += element.equals(\"B\") ? 1 : 0;\n            c += element.equals(\"C\") ? 1 : 0;\n        }\n        assertEquals(2, a);\n        assertEquals(2, b);\n        assertEquals(1, c);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryTest.java.AbstractMapEntryTest", "name": "AbstractMapEntryTest", "file_path": "src/test/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryTest.java", "superclasses": "", "methods": ["[Map.Entry<K, V>]makeKnownMapEntry()", "[Map.Entry<K, V>]makeKnownMapEntry(K,V)", "[Map.Entry<K, V>]makeMapEntry()", "[Map.Entry<K, V>]makeMapEntry(K,V)", "[void]testConstructors()"], "method_uris": ["src/test/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryTest.java.AbstractMapEntryTest.[Map.Entry<K, V>]makeKnownMapEntry()", "src/test/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryTest.java.AbstractMapEntryTest.[Map.Entry<K, V>]makeKnownMapEntry(K,V)", "src/test/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryTest.java.AbstractMapEntryTest.[Map.Entry<K, V>]makeMapEntry()", "src/test/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryTest.java.AbstractMapEntryTest.[Map.Entry<K, V>]makeMapEntry(K,V)", "src/test/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryTest.java.AbstractMapEntryTest.[void]testConstructors()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract tests that can be extended to test any Map.Entry implementation.\nSubclasses must implement {@link #makeMapEntry(Object, Object)} to return\na new Map.Entry of the type being tested. Subclasses must also implement\n{@link #testConstructors()} to test the constructors of the Map.Entry\ntype being tested.\n", "original_string": "public abstract class AbstractMapEntryTest<K, V> {\n\n    protected final String key = \"name\";\n    protected final String value = \"duke\";\n\n    /**\n     * Makes a Map.Entry of a type that's known to work correctly.\n     */\n    public Map.Entry<K, V> makeKnownMapEntry() {\n        return makeKnownMapEntry(null, null);\n    }\n\n    /**\n     * Makes a Map.Entry of a type that's known to work correctly.\n     */\n    public Map.Entry<K, V> makeKnownMapEntry(final K key, final V value) {\n        final Map<K, V> map = new HashMap<>(1);\n        map.put(key, value);\n        return map.entrySet().iterator().next();\n    }\n\n    /**\n     * Make an instance of Map.Entry with the default (null) key and value.\n     * This implementation simply calls {@link #makeMapEntry(Object, Object)}\n     * with null for key and value. Subclasses can override this method if desired.\n     */\n    public Map.Entry<K, V> makeMapEntry() {\n        return makeMapEntry(null, null);\n    }\n\n    /**\n     * Make an instance of Map.Entry with the specified key and value.\n     * Subclasses should override this method to return a Map.Entry\n     * of the type being tested.\n     */\n    public abstract Map.Entry<K, V> makeMapEntry(K key, V value);\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testAccessorsAndMutators() {\n        Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);\n\n        assertSame(key, entry.getKey());\n\n        entry.setValue((V) value);\n        assertSame(value, entry.getValue());\n\n        // check that null doesn't do anything funny\n        entry = makeMapEntry(null, null);\n        assertNull(entry.getKey());\n\n        entry.setValue(null);\n        assertNull(entry.getValue());\n    }\n\n    /**\n     * Subclasses should provide tests for their constructors.\n     */\n    public abstract void testConstructors();\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testEqualsAndHashCode() {\n        // 1. test with object data\n        Map.Entry<K, V> e1 = makeMapEntry((K) key, (V) value);\n        Map.Entry<K, V> e2 = makeKnownMapEntry((K) key, (V) value);\n\n        assertEquals(e1, e1);\n        assertEquals(e2, e1);\n        assertEquals(e1, e2);\n        assertEquals(e1.hashCode(), e2.hashCode());\n\n        // 2. test with nulls\n        e1 = makeMapEntry();\n        e2 = makeKnownMapEntry();\n\n        assertEquals(e1, e1);\n        assertEquals(e2, e1);\n        assertEquals(e1, e2);\n        assertEquals(e1.hashCode(), e2.hashCode());\n    }\n\n    /**\n     * Subclasses should override this method to test the\n     * desired behavior of the class with respect to\n     * handling of self-references.\n     */\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testSelfReferenceHandling() {\n        // test that #setValue does not permit\n        //  the MapEntry to contain itself (and thus cause infinite recursion\n        //  in #hashCode and #toString)\n\n        final Map.Entry<K, V> entry = makeMapEntry();\n\n        assertThrows(IllegalArgumentException.class, () -> entry.setValue((V) entry));\n\n        // check that the KVP's state has not changed\n        assertTrue(entry.getKey() == null && entry.getValue() == null);\n    }\n\n    @Test\n    @SuppressWarnings(\"unchecked\")\n    public void testToString() {\n        Map.Entry<K, V> entry = makeMapEntry((K) key, (V) value);\n        assertEquals(entry.toString(), entry.getKey() + \"=\" + entry.getValue());\n\n        // test with nulls\n        entry = makeMapEntry();\n        assertEquals(entry.toString(), entry.getKey() + \"=\" + entry.getValue());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected final String key = \"name\";", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "String", "name": "key = \"name\"", "syntax_pass": true}, {"attribute_expression": "protected final String value = \"duke\";", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "String", "name": "value = \"duke\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java.AbstractQueueDecorator", "name": "AbstractQueueDecorator", "file_path": "src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java", "superclasses": "", "methods": ["[]AbstractQueueDecorator()", "[]AbstractQueueDecorator(Queue<E>)", "[Queue<E>]decorated()", "[E]element()", "[boolean]offer(E)", "[E]peek()", "[E]poll()", "[E]remove()"], "method_uris": ["src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java.AbstractQueueDecorator.[]AbstractQueueDecorator()", "src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java.AbstractQueueDecorator.[]AbstractQueueDecorator(Queue<E>)", "src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java.AbstractQueueDecorator.[Queue<E>]decorated()", "src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java.AbstractQueueDecorator.[E]element()", "src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java.AbstractQueueDecorator.[boolean]offer(E)", "src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java.AbstractQueueDecorator.[E]peek()", "src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java.AbstractQueueDecorator.[E]poll()", "src/main/java/org/apache/commons/collections4/queue/AbstractQueueDecorator.java.AbstractQueueDecorator.[E]remove()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link Queue} to provide additional behavior.\n<p>\nMethods are forwarded directly to the decorated queue.\n</p>\n<p>\nThis implementation does not forward the hashCode and equals methods through\nto the backing object, but relies on Object's implementation. This is\nnecessary as some Queue implementations, e.g. LinkedList, have a custom\nequals implementation for which symmetry can not be preserved.\nSee class Javadoc of AbstractCollectionDecorator for more information.\n</p>\n\n@param <E> the type of the elements in the queue\n@since 4.0\n", "original_string": "public abstract class AbstractQueueDecorator<E> extends AbstractCollectionDecorator<E>\n        implements Queue<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2629815475789577029L;\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     */\n    protected AbstractQueueDecorator() {\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param queue  the queue to decorate, must not be null\n     * @throws NullPointerException if queue is null\n     */\n    protected AbstractQueueDecorator(final Queue<E> queue) {\n        super(queue);\n    }\n\n    /**\n     * Gets the queue being decorated.\n     *\n     * @return the decorated queue\n     */\n    @Override\n    protected Queue<E> decorated() {\n        return (Queue<E>) super.decorated();\n    }\n\n    @Override\n    public E element() {\n        return decorated().element();\n    }\n\n    @Override\n    public boolean offer(final E obj) {\n        return decorated().offer(obj);\n    }\n\n    @Override\n    public E peek() {\n        return decorated().peek();\n    }\n\n    @Override\n    public E poll() {\n        return decorated().poll();\n    }\n\n    @Override\n    public E remove() {\n        return decorated().remove();\n    }\n\n}", "super_interfaces": ["Queue<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -2629815475789577029L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -2629815475789577029L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag", "name": "AbstractMapBag", "file_path": "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java", "superclasses": "", "methods": ["[]AbstractMapBag()", "[]AbstractMapBag(Map<E, MutableInteger>)", "[]AbstractMapBag(Map<E, MutableInteger>,Iterable<? extends E>)", "[boolean]add(E)", "[boolean]add(E,int)", "[boolean]addAll(Collection<? extends E>)", "[void]clear()", "[boolean]contains(Object)", "[boolean]containsAll(Bag<?>)", "[boolean]containsAll(Collection<?>)", "[void]doReadObject(Map<E, MutableInteger>,ObjectInputStream)", "[void]doWriteObject(ObjectOutputStream)", "[boolean]equals(Object)", "[int]getCount(Object)", "[Map<E, MutableInteger>]getMap()", "[int]hashCode()", "[boolean]isEmpty()", "[Iterator<E>]iterator()", "[boolean]remove(Object)", "[boolean]remove(Object,int)", "[boolean]removeAll(Collection<?>)", "[boolean]retainAll(Bag<?>)", "[boolean]retainAll(Collection<?>)", "[int]size()", "[Object[]]toArray()", "[T[]]toArray(T[])", "[String]toString()", "[Set<E>]uniqueSet()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[]AbstractMapBag()", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[]AbstractMapBag(Map<E, MutableInteger>)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[]AbstractMapBag(Map<E, MutableInteger>,Iterable<? extends E>)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[boolean]add(E,int)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[void]clear()", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[boolean]contains(Object)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[boolean]containsAll(Bag<?>)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[boolean]containsAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[void]doReadObject(Map<E, MutableInteger>,ObjectInputStream)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[void]doWriteObject(ObjectOutputStream)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[int]getCount(Object)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[Map<E, MutableInteger>]getMap()", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[int]hashCode()", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[boolean]remove(Object,int)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[boolean]retainAll(Bag<?>)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[int]size()", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[Object[]]toArray()", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[T[]]toArray(T[])", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[String]toString()", "src/main/java/org/apache/commons/collections4/bag/AbstractMapBag.java.AbstractMapBag.[Set<E>]uniqueSet()"], "overrides": null, "attributes": [{"original_string": "    static class BagIterator<E> implements Iterator<E> {\n        private final AbstractMapBag<E> parent;\n        private final Iterator<Map.Entry<E, MutableInteger>> entryIterator;\n        private Map.Entry<E, MutableInteger> current;\n        private int itemCount;\n        private final int mods;\n        private boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent the parent bag\n         */\n        BagIterator(final AbstractMapBag<E> parent) {\n            this.parent = parent;\n            this.entryIterator = parent.map.entrySet().iterator();\n            this.current = null;\n            this.mods = parent.modCount;\n            this.canRemove = false;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean hasNext() {\n            return itemCount > 0 || entryIterator.hasNext();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public E next() {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (itemCount == 0) {\n                current = entryIterator.next();\n                itemCount = current.getValue().value;\n            }\n            canRemove = true;\n            itemCount--;\n            return current.getKey();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void remove() {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (!canRemove) {\n                throw new IllegalStateException();\n            }\n            final MutableInteger mut = current.getValue();\n            if (mut.value > 1) {\n                mut.value--;\n            } else {\n                entryIterator.remove();\n            }\n            parent.size--;\n            canRemove = false;\n        }\n    }", "definition": "    static class BagIterator<E> implements Iterator<E>", "class_docstring": "\nInner class iterator for the Bag.\n", "name": "BagIterator", "super_interfaces": ["Iterator<E>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final AbstractMapBag<E> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractMapBag<E>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private final Iterator<Map.Entry<E, MutableInteger>> entryIterator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<Map.Entry<E, MutableInteger>>", "name": "entryIterator", "syntax_pass": true}, {"attribute_expression": "private Map.Entry<E, MutableInteger> current;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map.Entry<E, MutableInteger>", "name": "current", "syntax_pass": true}, {"attribute_expression": "private int itemCount;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "itemCount", "syntax_pass": true}, {"attribute_expression": "private final int mods;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "mods", "syntax_pass": true}, {"attribute_expression": "private boolean canRemove;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "canRemove", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        BagIterator(final AbstractMapBag<E> parent) {\n            this.parent = parent;\n            this.entryIterator = parent.map.entrySet().iterator();\n            this.current = null;\n            this.mods = parent.modCount;\n            this.canRemove = false;\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent the parent bag\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "BagIterator", "params": [{"name": "parent", "type": "AbstractMapBag<E>"}], "body": "                                                    {\n            this.parent = parent;\n            this.entryIterator = parent.map.entrySet().iterator();\n            this.current = null;\n            this.mods = parent.modCount;\n            this.canRemove = false;\n        }", "signature": "BagIterator(final AbstractMapBag<E> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return itemCount > 0 || entryIterator.hasNext();\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return itemCount > 0 || entryIterator.hasNext();\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E next() {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (itemCount == 0) {\n                current = entryIterator.next();\n                itemCount = current.getValue().value;\n            }\n            canRemove = true;\n            itemCount--;\n            return current.getKey();\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "next", "params": [], "body": "                        {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (itemCount == 0) {\n                current = entryIterator.next();\n                itemCount = current.getValue().value;\n            }\n            canRemove = true;\n            itemCount--;\n            return current.getKey();\n        }", "signature": "@Override\n        public E next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (!canRemove) {\n                throw new IllegalStateException();\n            }\n            final MutableInteger mut = current.getValue();\n            if (mut.value > 1) {\n                mut.value--;\n            } else {\n                entryIterator.remove();\n            }\n            parent.size--;\n            canRemove = false;\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (!canRemove) {\n                throw new IllegalStateException();\n            }\n            final MutableInteger mut = current.getValue();\n            if (mut.value > 1) {\n                mut.value--;\n            } else {\n                entryIterator.remove();\n            }\n            parent.size--;\n            canRemove = false;\n        }", "signature": "@Override\n        public void remove()"}]}, {"original_string": "    protected static class MutableInteger {\n\n        /** The value of this mutable. */\n        protected int value;\n\n        /**\n         * Constructs a new instance.\n         * @param value the initial value\n         */\n        MutableInteger(final int value) {\n            this.value = value;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (!(obj instanceof MutableInteger)) {\n                return false;\n            }\n            return ((MutableInteger) obj).value == value;\n        }\n\n        @Override\n        public int hashCode() {\n            return value;\n        }\n    }", "definition": "    protected static class MutableInteger", "class_docstring": "\nMutable integer class for storing the data.\n", "name": "MutableInteger", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected int value;", "docstring": " The value of this mutable.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        MutableInteger(final int value) {\n            this.value = value;\n        }", "docstring": "\nConstructs a new instance.\n@param value the initial value\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MutableInteger", "params": [{"name": "value", "type": "int"}], "body": "                                        {\n            this.value = value;\n        }", "signature": "MutableInteger(final int value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            if (!(obj instanceof MutableInteger)) {\n                return false;\n            }\n            return ((MutableInteger) obj).value == value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (!(obj instanceof MutableInteger)) {\n                return false;\n            }\n            return ((MutableInteger) obj).value == value;\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return value;\n        }", "signature": "@Override\n        public int hashCode()"}]}], "class_docstring": "\nAbstract implementation of the {@link Bag} interface to simplify the creation\nof subclass implementations.\n<p>\nSubclasses specify a Map implementation to use as the internal storage. The\nmap will be used to map bag elements to a number; the number represents the\nnumber of occurrences of that element in the bag.\n</p>\n\n@param <E> the type of elements in this bag\n@since 3.0 (previously DefaultMapBag v2.0)\n", "original_string": "public abstract class AbstractMapBag<E> implements Bag<E> {\n\n    /**\n     * Inner class iterator for the Bag.\n     */\n    static class BagIterator<E> implements Iterator<E> {\n        private final AbstractMapBag<E> parent;\n        private final Iterator<Map.Entry<E, MutableInteger>> entryIterator;\n        private Map.Entry<E, MutableInteger> current;\n        private int itemCount;\n        private final int mods;\n        private boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent the parent bag\n         */\n        BagIterator(final AbstractMapBag<E> parent) {\n            this.parent = parent;\n            this.entryIterator = parent.map.entrySet().iterator();\n            this.current = null;\n            this.mods = parent.modCount;\n            this.canRemove = false;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean hasNext() {\n            return itemCount > 0 || entryIterator.hasNext();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public E next() {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (itemCount == 0) {\n                current = entryIterator.next();\n                itemCount = current.getValue().value;\n            }\n            canRemove = true;\n            itemCount--;\n            return current.getKey();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void remove() {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (!canRemove) {\n                throw new IllegalStateException();\n            }\n            final MutableInteger mut = current.getValue();\n            if (mut.value > 1) {\n                mut.value--;\n            } else {\n                entryIterator.remove();\n            }\n            parent.size--;\n            canRemove = false;\n        }\n    }\n\n    /**\n     * Mutable integer class for storing the data.\n     */\n    protected static class MutableInteger {\n\n        /** The value of this mutable. */\n        protected int value;\n\n        /**\n         * Constructs a new instance.\n         * @param value the initial value\n         */\n        MutableInteger(final int value) {\n            this.value = value;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (!(obj instanceof MutableInteger)) {\n                return false;\n            }\n            return ((MutableInteger) obj).value == value;\n        }\n\n        @Override\n        public int hashCode() {\n            return value;\n        }\n    }\n\n    /** The map to use to store the data */\n    private transient Map<E, MutableInteger> map;\n\n    /** The current total size of the bag */\n    private int size;\n\n    /** The modification count for fail fast iterators */\n    private transient int modCount;\n\n    /** Unique view of the elements */\n    private transient Set<E> uniqueSet;\n\n    /**\n     * Constructor needed for subclass serialisation.\n     */\n    protected AbstractMapBag() {\n    }\n\n    /**\n     * Constructor that assigns the specified Map as the backing store. The map\n     * must be empty and non-null.\n     *\n     * @param map the map to assign\n     */\n    protected AbstractMapBag(final Map<E, MutableInteger> map) {\n        this.map = Objects.requireNonNull(map, \"map\");\n    }\n\n    /**\n     * Constructs a new instance that assigns the specified Map as the backing store. The map\n     * must be empty and non-null. The bag is filled from the iterable elements.\n     *\n     * @param map the map to assign.\n     * @param iterable The bag is filled from these iterable elements.\n     */\n    protected AbstractMapBag(final Map<E, MutableInteger> map, final Iterable<? extends E> iterable) {\n        this(map);\n        iterable.forEach(this::add);\n    }\n\n    /**\n     * Adds a new element to the bag, incrementing its count in the underlying map.\n     *\n     * @param object the object to add\n     * @return {@code true} if the object was not already in the {@code uniqueSet}\n     */\n    @Override\n    public boolean add(final E object) {\n        return add(object, 1);\n    }\n\n    /**\n     * Adds a new element to the bag, incrementing its count in the map.\n     *\n     * @param object the object to search for\n     * @param nCopies the number of copies to add\n     * @return {@code true} if the object was not already in the {@code uniqueSet}\n     */\n    @Override\n    public boolean add(final E object, final int nCopies) {\n        modCount++;\n        if (nCopies > 0) {\n            final MutableInteger mut = map.get(object);\n            size += nCopies;\n            if (mut == null) {\n                map.put(object, new MutableInteger(nCopies));\n                return true;\n            }\n            mut.value += nCopies;\n        }\n        return false;\n    }\n\n    /**\n     * Invokes {@link #add(Object)} for each element in the given collection.\n     *\n     * @param coll the collection to add\n     * @return {@code true} if this call changed the bag\n     */\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        boolean changed = false;\n        for (final E current : coll) {\n            final boolean added = add(current);\n            changed = changed || added;\n        }\n        return changed;\n    }\n\n    /**\n     * Clears the bag by clearing the underlying map.\n     */\n    @Override\n    public void clear() {\n        modCount++;\n        map.clear();\n        size = 0;\n    }\n\n    /**\n     * Determines if the bag contains the given element by checking if the\n     * underlying map contains the element as a key.\n     *\n     * @param object the object to search for\n     * @return true if the bag contains the given element\n     */\n    @Override\n    public boolean contains(final Object object) {\n        return map.containsKey(object);\n    }\n\n    /**\n     * Returns {@code true} if the bag contains all elements in the given\n     * collection, respecting cardinality.\n     *\n     * @param other the bag to check against\n     * @return {@code true} if the Bag contains all the collection\n     */\n    boolean containsAll(final Bag<?> other) {\n        for (final Object current : other.uniqueSet()) {\n            if (getCount(current) < other.getCount(current)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Determines if the bag contains the given elements.\n     *\n     * @param coll the collection to check against\n     * @return {@code true} if the Bag contains all the collection\n     */\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        if (coll instanceof Bag) {\n            return containsAll((Bag<?>) coll);\n        }\n        return containsAll(new HashBag<>(coll));\n    }\n\n    /**\n     * Read the map in using a custom routine.\n     * @param map the map to use\n     * @param in the input stream\n     * @throws IOException any of the usual I/O related exceptions\n     * @throws ClassNotFoundException if the stream contains an object which class can not be loaded\n     * @throws ClassCastException if the stream does not contain the correct objects\n     */\n    protected void doReadObject(final Map<E, MutableInteger> map, final ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n        this.map = map;\n        final int entrySize = in.readInt();\n        for (int i = 0; i < entrySize; i++) {\n            @SuppressWarnings(\"unchecked\") // This will fail at runtime if the stream is incorrect\n            final E obj = (E) in.readObject();\n            final int count = in.readInt();\n            map.put(obj, new MutableInteger(count));\n            size += count;\n        }\n    }\n\n    /**\n     * Write the map out using a custom routine.\n     * @param out the output stream\n     * @throws IOException any of the usual I/O related exceptions\n     */\n    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n        out.writeInt(map.size());\n        for (final Entry<E, MutableInteger> entry : map.entrySet()) {\n            out.writeObject(entry.getKey());\n            out.writeInt(entry.getValue().value);\n        }\n    }\n\n    /**\n     * Compares this Bag to another. This Bag equals another Bag if it contains\n     * the same number of occurrences of the same elements.\n     *\n     * @param object the Bag to compare to\n     * @return true if equal\n     */\n    @Override\n    public boolean equals(final Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof Bag)) {\n            return false;\n        }\n        final Bag<?> other = (Bag<?>) object;\n        if (other.size() != size()) {\n            return false;\n        }\n        for (final E element : map.keySet()) {\n            if (other.getCount(element) != getCount(element)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the number of occurrence of the given element in this bag by\n     * looking up its count in the underlying map.\n     *\n     * @param object the object to search for\n     * @return the number of occurrences of the object, zero if not found\n     */\n    @Override\n    public int getCount(final Object object) {\n        final MutableInteger count = map.get(object);\n        if (count != null) {\n            return count.value;\n        }\n        return 0;\n    }\n\n    /**\n     * Utility method for implementations to access the map that backs this bag.\n     * Not intended for interactive use outside of subclasses.\n     *\n     * @return the map being used by the Bag\n     */\n    protected Map<E, MutableInteger> getMap() {\n        return map;\n    }\n\n    /**\n     * Gets a hash code for the Bag compatible with the definition of equals.\n     * The hash code is defined as the sum total of a hash code for each\n     * element. The per element hash code is defined as\n     * {@code (e==null ? 0 : e.hashCode()) ^ noOccurrences)}. This hash code\n     * is compatible with the Set interface.\n     *\n     * @return the hash code of the Bag\n     */\n    @Override\n    public int hashCode() {\n        int total = 0;\n        for (final Entry<E, MutableInteger> entry : map.entrySet()) {\n            final E element = entry.getKey();\n            final MutableInteger count = entry.getValue();\n            total += (element == null ? 0 : element.hashCode()) ^ count.value;\n        }\n        return total;\n    }\n\n    /**\n     * Returns true if the underlying map is empty.\n     *\n     * @return true if bag is empty\n     */\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    /**\n     * Gets an iterator over the bag elements. Elements present in the Bag more\n     * than once will be returned repeatedly.\n     *\n     * @return the iterator\n     */\n    @Override\n    public Iterator<E> iterator() {\n        return new BagIterator<>(this);\n    }\n\n    /**\n     * Removes all copies of the specified object from the bag.\n     *\n     * @param object the object to remove\n     * @return true if the bag changed\n     */\n    @Override\n    public boolean remove(final Object object) {\n        final MutableInteger mut = map.get(object);\n        if (mut == null) {\n            return false;\n        }\n        modCount++;\n        map.remove(object);\n        size -= mut.value;\n        return true;\n    }\n\n    /**\n     * Removes a specified number of copies of an object from the bag.\n     *\n     * @param object the object to remove\n     * @param nCopies the number of copies to remove\n     * @return true if the bag changed\n     */\n    @Override\n    public boolean remove(final Object object, final int nCopies) {\n        final MutableInteger mut = map.get(object);\n        if (mut == null) {\n            return false;\n        }\n        if (nCopies <= 0) {\n            return false;\n        }\n        modCount++;\n        if (nCopies < mut.value) {\n            mut.value -= nCopies;\n            size -= nCopies;\n        } else {\n            map.remove(object);\n            size -= mut.value;\n        }\n        return true;\n    }\n\n    /**\n     * Removes objects from the bag according to their count in the specified\n     * collection.\n     *\n     * @param coll the collection to use\n     * @return true if the bag changed\n     */\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        boolean result = false;\n        if (coll != null) {\n            for (final Object current : coll) {\n                final boolean changed = remove(current, 1);\n                result = result || changed;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Remove any members of the bag that are not in the given bag, respecting\n     * cardinality.\n     * @see #retainAll(Collection)\n     *\n     * @param other the bag to retain\n     * @return {@code true} if this call changed the collection\n     */\n    boolean retainAll(final Bag<?> other) {\n        boolean result = false;\n        final Bag<E> excess = new HashBag<>();\n        for (final E current : uniqueSet()) {\n            final int myCount = getCount(current);\n            final int otherCount = other.getCount(current);\n            if (1 <= otherCount && otherCount <= myCount) {\n                excess.add(current, myCount - otherCount);\n            } else {\n                excess.add(current, myCount);\n            }\n        }\n        if (!excess.isEmpty()) {\n            result = removeAll(excess);\n        }\n        return result;\n    }\n\n    /**\n     * Remove any members of the bag that are not in the given bag, respecting\n     * cardinality.\n     *\n     * @param coll the collection to retain\n     * @return true if this call changed the collection\n     */\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        if (coll instanceof Bag) {\n            return retainAll((Bag<?>) coll);\n        }\n        return retainAll(new HashBag<>(coll));\n    }\n\n    /**\n     * Returns the number of elements in this bag.\n     *\n     * @return current size of the bag\n     */\n    @Override\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Returns an array of all of this bag's elements.\n     *\n     * @return an array of all of this bag's elements\n     */\n    @Override\n    public Object[] toArray() {\n        final Object[] result = new Object[size()];\n        int i = 0;\n        for (final E current : map.keySet()) {\n            for (int index = getCount(current); index > 0; index--) {\n                result[i++] = current;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns an array of all of this bag's elements.\n     * If the input array has more elements than are in the bag,\n     * trailing elements will be set to null.\n     *\n     * @param <T> the type of the array elements\n     * @param array the array to populate\n     * @return an array of all of this bag's elements\n     * @throws ArrayStoreException if the runtime type of the specified array is not\n     *   a supertype of the runtime type of the elements in this list\n     * @throws NullPointerException if the specified array is null\n     */\n    @Override\n    public <T> T[] toArray(T[] array) {\n        final int size = size();\n        if (array.length < size) {\n            @SuppressWarnings(\"unchecked\") // safe as both are of type T\n            final T[] unchecked = (T[]) Array.newInstance(array.getClass().getComponentType(), size);\n            array = unchecked;\n        }\n\n        int i = 0;\n        for (final E current : map.keySet()) {\n            for (int index = getCount(current); index > 0; index--) {\n                // unsafe, will throw ArrayStoreException if types are not compatible, see Javadoc\n                @SuppressWarnings(\"unchecked\")\n                final T unchecked = (T) current;\n                array[i++] = unchecked;\n            }\n        }\n        while (i < array.length) {\n            array[i++] = null;\n        }\n        return array;\n    }\n\n    /**\n     * Implement a toString() method suitable for debugging.\n     *\n     * @return a debugging toString\n     */\n    @Override\n    public String toString() {\n        if (isEmpty()) {\n            return \"[]\";\n        }\n        final StringBuilder buf = new StringBuilder();\n        buf.append(CollectionUtils.DEFAULT_TOSTRING_PREFIX);\n        final Iterator<E> it = uniqueSet().iterator();\n        while (it.hasNext()) {\n            final Object current = it.next();\n            final int count = getCount(current);\n            buf.append(count);\n            buf.append(CollectionUtils.COLON);\n            buf.append(current);\n            if (it.hasNext()) {\n                buf.append(CollectionUtils.COMMA);\n            }\n        }\n        buf.append(CollectionUtils.DEFAULT_TOSTRING_SUFFIX);\n        return buf.toString();\n    }\n\n    /**\n     * Returns an unmodifiable view of the underlying map's key set.\n     *\n     * @return the set of unique elements in this bag\n     */\n    @Override\n    public Set<E> uniqueSet() {\n        if (uniqueSet == null) {\n            uniqueSet = UnmodifiableSet.<E>unmodifiableSet(map.keySet());\n        }\n        return uniqueSet;\n    }\n\n}", "super_interfaces": ["Bag<E>"], "fields": [{"attribute_expression": "private transient Map<E, MutableInteger> map;", "docstring": " The map to use to store the data", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Map<E, MutableInteger>", "name": "map", "syntax_pass": true}, {"attribute_expression": "private int size;", "docstring": " The current total size of the bag", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}, {"attribute_expression": "private transient int modCount;", "docstring": " The modification count for fail fast iterators", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "modCount", "syntax_pass": true}, {"attribute_expression": "private transient Set<E> uniqueSet;", "docstring": " Unique view of the elements", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Set<E>", "name": "uniqueSet", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java.AbstractBagDecorator", "name": "AbstractBagDecorator", "file_path": "src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java", "superclasses": "", "methods": ["[]AbstractBagDecorator()", "[]AbstractBagDecorator(Bag<E>)", "[boolean]add(E,int)", "[Bag<E>]decorated()", "[boolean]equals(Object)", "[int]getCount(Object)", "[int]hashCode()", "[boolean]remove(Object,int)", "[Set<E>]uniqueSet()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java.AbstractBagDecorator.[]AbstractBagDecorator()", "src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java.AbstractBagDecorator.[]AbstractBagDecorator(Bag<E>)", "src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java.AbstractBagDecorator.[boolean]add(E,int)", "src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java.AbstractBagDecorator.[Bag<E>]decorated()", "src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java.AbstractBagDecorator.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java.AbstractBagDecorator.[int]getCount(Object)", "src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java.AbstractBagDecorator.[int]hashCode()", "src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java.AbstractBagDecorator.[boolean]remove(Object,int)", "src/main/java/org/apache/commons/collections4/bag/AbstractBagDecorator.java.AbstractBagDecorator.[Set<E>]uniqueSet()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code Bag} to provide additional behavior.\n<p>\nMethods are forwarded directly to the decorated bag.\n</p>\n\n@param <E> the type of elements in this bag\n@since 3.0\n", "original_string": "public abstract class AbstractBagDecorator<E>\n        extends AbstractCollectionDecorator<E> implements Bag<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -3768146017343785417L;\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     * @since 3.1\n     */\n    protected AbstractBagDecorator() {\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param bag  the bag to decorate, must not be null\n     * @throws NullPointerException if bag is null\n     */\n    protected AbstractBagDecorator(final Bag<E> bag) {\n        super(bag);\n    }\n\n    @Override\n    public boolean add(final E object, final int count) {\n        return decorated().add(object, count);\n    }\n\n    /**\n     * Gets the bag being decorated.\n     *\n     * @return the decorated bag\n     */\n    @Override\n    protected Bag<E> decorated() {\n        return (Bag<E>) super.decorated();\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        return object == this || decorated().equals(object);\n    }\n\n    @Override\n    public int getCount(final Object object) {\n        return decorated().getCount(object);\n    }\n\n    @Override\n    public int hashCode() {\n        return decorated().hashCode();\n    }\n\n    @Override\n    public boolean remove(final Object object, final int count) {\n        return decorated().remove(object, count);\n    }\n\n    @Override\n    public Set<E> uniqueSet() {\n        return decorated().uniqueSet();\n    }\n\n}", "super_interfaces": ["Bag<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -3768146017343785417L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -3768146017343785417L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java.AbstractSortedBagDecorator", "name": "AbstractSortedBagDecorator", "file_path": "src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java", "superclasses": "", "methods": ["[]AbstractSortedBagDecorator()", "[]AbstractSortedBagDecorator(SortedBag<E>)", "[Comparator<? super E>]comparator()", "[SortedBag<E>]decorated()", "[E]first()", "[E]last()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java.AbstractSortedBagDecorator.[]AbstractSortedBagDecorator()", "src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java.AbstractSortedBagDecorator.[]AbstractSortedBagDecorator(SortedBag<E>)", "src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java.AbstractSortedBagDecorator.[Comparator<? super E>]comparator()", "src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java.AbstractSortedBagDecorator.[SortedBag<E>]decorated()", "src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java.AbstractSortedBagDecorator.[E]first()", "src/main/java/org/apache/commons/collections4/bag/AbstractSortedBagDecorator.java.AbstractSortedBagDecorator.[E]last()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code SortedBag} to provide additional behavior.\n<p>\nMethods are forwarded directly to the decorated bag.\n</p>\n\n@param <E> the type of elements in this bag\n@since 3.0\n", "original_string": "public abstract class AbstractSortedBagDecorator<E>\n        extends AbstractBagDecorator<E> implements SortedBag<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -8223473624050467718L;\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     * @since 3.1\n     */\n    protected AbstractSortedBagDecorator() {\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param bag  the bag to decorate, must not be null\n     * @throws NullPointerException if bag is null\n     */\n    protected AbstractSortedBagDecorator(final SortedBag<E> bag) {\n        super(bag);\n    }\n\n    @Override\n    public Comparator<? super E> comparator() {\n        return decorated().comparator();\n    }\n\n    /**\n     * Gets the bag being decorated.\n     *\n     * @return the decorated bag\n     */\n    @Override\n    protected SortedBag<E> decorated() {\n        return (SortedBag<E>) super.decorated();\n    }\n\n    @Override\n    public E first() {\n        return decorated().first();\n    }\n\n    @Override\n    public E last() {\n        return decorated().last();\n    }\n\n}", "super_interfaces": ["SortedBag<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -8223473624050467718L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -8223473624050467718L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator", "name": "AbstractCollectionDecorator", "file_path": "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java", "superclasses": "", "methods": ["[]AbstractCollectionDecorator()", "[]AbstractCollectionDecorator(Collection<E>)", "[boolean]add(E)", "[boolean]addAll(Collection<? extends E>)", "[void]clear()", "[boolean]contains(Object)", "[boolean]containsAll(Collection<?>)", "[Collection<E>]decorated()", "[boolean]isEmpty()", "[Iterator<E>]iterator()", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[boolean]removeIf(Predicate<? super E>)", "[boolean]retainAll(Collection<?>)", "[void]setCollection(Collection<E>)", "[int]size()", "[Object[]]toArray()", "[T[]]toArray(T[])", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[]AbstractCollectionDecorator()", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[]AbstractCollectionDecorator(Collection<E>)", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[void]clear()", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[boolean]contains(Object)", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[boolean]containsAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[Collection<E>]decorated()", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[boolean]removeIf(Predicate<? super E>)", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[void]setCollection(Collection<E>)", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[int]size()", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[Object[]]toArray()", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[T[]]toArray(T[])", "src/main/java/org/apache/commons/collections4/collection/AbstractCollectionDecorator.java.AbstractCollectionDecorator.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code Collection} to provide additional behavior.\n<p>\nEach method call made on this {@code Collection} is forwarded to the\ndecorated {@code Collection}. This class is used as a framework on which\nto build to extensions such as synchronized and unmodifiable behavior. The\nmain advantage of decoration is that one decorator can wrap any implementation\nof {@code Collection}, whereas sub-classing requires a new class to be\nwritten for each implementation.\n</p>\n<p>\nThis implementation does not perform any special processing with\n{@link #iterator()}. Instead it simply returns the value from the\nwrapped collection. This may be undesirable, for example if you are trying\nto write an unmodifiable implementation it might provide a loophole.\n</p>\n<p>\nThis implementation does not forward the hashCode and equals methods through\nto the backing object, but relies on Object's implementation. This is necessary\nto preserve the symmetry of equals. Custom definitions of equality are usually\nbased on an interface, such as Set or List, so that the implementation of equals\ncan cast the object being tested for equality to the custom interface.\nAbstractCollectionDecorator does not implement such custom interfaces directly;\nthey are implemented only in subclasses. Therefore, forwarding equals would break\nsymmetry, as the forwarding object might consider itself equal to the object being\ntested, but the reverse could not be true. This behavior is consistent with the\nJDK's collection wrappers, such as {@link java.util.Collections#unmodifiableCollection(Collection)}.\nUse an interface-specific subclass of AbstractCollectionDecorator, such as\nAbstractListDecorator, to preserve equality behavior, or override equals directly.\n</p>\n\n@param <E> the type of the elements in the collection\n@since 3.0\n", "original_string": "public abstract class AbstractCollectionDecorator<E>\n        implements Collection<E>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 6249888059822088500L;\n\n    /** The collection being decorated */\n    private Collection<E> collection;\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     * @since 3.1\n     */\n    protected AbstractCollectionDecorator() {\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param collection  the collection to decorate, must not be null\n     * @throws NullPointerException if the collection is null\n     */\n    protected AbstractCollectionDecorator(final Collection<E> collection) {\n        this.collection = Objects.requireNonNull(collection, \"collection\");\n    }\n\n    @Override\n    public boolean add(final E object) {\n        return decorated().add(object);\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        return decorated().addAll(coll);\n    }\n\n    @Override\n    public void clear() {\n        decorated().clear();\n    }\n\n    @Override\n    public boolean contains(final Object object) {\n        return decorated().contains(object);\n    }\n\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        return decorated().containsAll(coll);\n    }\n\n    /**\n     * Gets the collection being decorated.\n     * All access to the decorated collection goes via this method.\n     *\n     * @return the decorated collection\n     */\n    protected Collection<E> decorated() {\n        return collection;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return decorated().isEmpty();\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return decorated().iterator();\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        return decorated().remove(object);\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        return decorated().removeAll(coll);\n    }\n\n    /**\n     * @since 4.4\n     */\n    @Override\n    public boolean removeIf(final Predicate<? super E> filter) {\n        return decorated().removeIf(filter);\n    }\n\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        return decorated().retainAll(coll);\n    }\n\n    /**\n     * Sets the collection being decorated.\n     * <p>\n     * <b>NOTE:</b> this method should only be used during deserialization\n     *\n     * @param collection  the decorated collection\n     */\n    protected void setCollection(final Collection<E> collection) {\n        this.collection = collection;\n    }\n\n    @Override\n    public int size() {\n        return decorated().size();\n    }\n\n    @Override\n    public Object[] toArray() {\n        return decorated().toArray();\n    }\n\n    @Override\n    public <T> T[] toArray(final T[] object) {\n        return decorated().toArray(object);\n    }\n\n    @Override\n    public String toString() {\n        return decorated().toString();\n    }\n\n}", "super_interfaces": ["Collection<E>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 6249888059822088500L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 6249888059822088500L", "syntax_pass": true}, {"attribute_expression": "private Collection<E> collection;", "docstring": " The collection being decorated", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<E>", "name": "collection", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator", "name": "AbstractMapDecorator", "file_path": "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java", "superclasses": "", "methods": ["[]AbstractMapDecorator()", "[]AbstractMapDecorator(Map<K, V>)", "[void]clear()", "[boolean]containsKey(Object)", "[boolean]containsValue(Object)", "[Map<K, V>]decorated()", "[Set<Map.Entry<K, V>>]entrySet()", "[boolean]equals(Object)", "[V]get(Object)", "[int]hashCode()", "[boolean]isEmpty()", "[Set<K>]keySet()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[V]remove(Object)", "[int]size()", "[String]toString()", "[Collection<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[]AbstractMapDecorator()", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[]AbstractMapDecorator(Map<K, V>)", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[void]clear()", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[Map<K, V>]decorated()", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[V]get(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[int]hashCode()", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[int]size()", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[String]toString()", "src/main/java/org/apache/commons/collections4/map/AbstractMapDecorator.java.AbstractMapDecorator.[Collection<V>]values()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides a base decorator that enables additional functionality to be added\nto a Map via decoration.\n<p>\nMethods are forwarded directly to the decorated map.\n</p>\n<p>\nThis implementation does not perform any special processing with\n{@link #entrySet()}, {@link #keySet()} or {@link #values()}. Instead\nit simply returns the set/collection from the wrapped map. This may be\nundesirable, for example if you are trying to write a validating\nimplementation it would provide a loophole around the validation.\nBut, you might want that loophole, so this class is kept simple.\n</p>\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n@since 3.0\n", "original_string": "public abstract class AbstractMapDecorator<K, V> extends AbstractIterableMap<K, V> {\n\n    /** The map to decorate */\n    transient Map<K, V> map;\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     * @since 3.1\n     */\n    protected AbstractMapDecorator() {\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if the map is null\n     */\n    protected AbstractMapDecorator(final Map<K, V> map) {\n        this.map = Objects.requireNonNull(map, \"map\");\n    }\n\n    @Override\n    public void clear() {\n        decorated().clear();\n    }\n\n    @Override\n    public boolean containsKey(final Object key) {\n        return decorated().containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(final Object value) {\n        return decorated().containsValue(value);\n    }\n\n    /**\n     * Gets the map being decorated.\n     *\n     * @return the decorated map\n     */\n    protected Map<K, V> decorated() {\n        return map;\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        return decorated().entrySet();\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        if (object == this) {\n            return true;\n        }\n        return decorated().equals(object);\n    }\n\n    @Override\n    public V get(final Object key) {\n        return decorated().get(key);\n    }\n\n    @Override\n    public int hashCode() {\n        return decorated().hashCode();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return decorated().isEmpty();\n    }\n\n    @Override\n    public Set<K> keySet() {\n        return decorated().keySet();\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        return decorated().put(key, value);\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> mapToCopy) {\n        decorated().putAll(mapToCopy);\n    }\n\n    @Override\n    public V remove(final Object key) {\n        return decorated().remove(key);\n    }\n\n    @Override\n    public int size() {\n        return decorated().size();\n    }\n\n    @Override\n    public String toString() {\n        return decorated().toString();\n    }\n\n    @Override\n    public Collection<V> values() {\n        return decorated().values();\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "transient Map<K, V> map;", "docstring": " The map to decorate", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "Map<K, V>", "name": "map", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap", "name": "AbstractLinkedMap", "file_path": "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java", "superclasses": "", "methods": ["[]AbstractLinkedMap()", "[]AbstractLinkedMap(int)", "[]AbstractLinkedMap(int,float)", "[]AbstractLinkedMap(int,float,int)", "[]AbstractLinkedMap(Map<? extends K, ? extends V>)", "[void]addEntry(HashEntry<K, V>,int)", "[void]clear()", "[boolean]containsValue(Object)", "[LinkEntry<K, V>]createEntry(HashEntry<K, V>,int,K,V)", "[Iterator<Map.Entry<K, V>>]createEntrySetIterator()", "[Iterator<K>]createKeySetIterator()", "[Iterator<V>]createValuesIterator()", "[LinkEntry<K, V>]entryAfter(LinkEntry<K, V>)", "[LinkEntry<K, V>]entryBefore(LinkEntry<K, V>)", "[K]firstKey()", "[LinkEntry<K, V>]getEntry(int)", "[LinkEntry<K, V>]getEntry(Object)", "[void]init()", "[K]lastKey()", "[OrderedMapIterator<K, V>]mapIterator()", "[K]nextKey(Object)", "[K]previousKey(Object)", "[void]removeEntry(HashEntry<K, V>,int,HashEntry<K, V>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[]AbstractLinkedMap()", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[]AbstractLinkedMap(int)", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[]AbstractLinkedMap(int,float)", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[]AbstractLinkedMap(int,float,int)", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[]AbstractLinkedMap(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[void]addEntry(HashEntry<K, V>,int)", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[void]clear()", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[LinkEntry<K, V>]createEntry(HashEntry<K, V>,int,K,V)", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[Iterator<Map.Entry<K, V>>]createEntrySetIterator()", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[Iterator<K>]createKeySetIterator()", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[Iterator<V>]createValuesIterator()", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[LinkEntry<K, V>]entryAfter(LinkEntry<K, V>)", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[LinkEntry<K, V>]entryBefore(LinkEntry<K, V>)", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[K]firstKey()", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[LinkEntry<K, V>]getEntry(int)", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[LinkEntry<K, V>]getEntry(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[void]init()", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[K]lastKey()", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[OrderedMapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[K]nextKey(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[K]previousKey(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractLinkedMap.java.AbstractLinkedMap.[void]removeEntry(HashEntry<K, V>,int,HashEntry<K, V>)"], "overrides": null, "attributes": [{"original_string": "    protected static class EntrySetIterator<K, V> extends LinkIterator<K, V> implements\n            OrderedIterator<Map.Entry<K, V>>, ResettableIterator<Map.Entry<K, V>> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractLinkedMap.\n         */\n        protected EntrySetIterator(final AbstractLinkedMap<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            return super.nextEntry();\n        }\n\n        @Override\n        public Map.Entry<K, V> previous() {\n            return super.previousEntry();\n        }\n    }", "definition": "    protected static class EntrySetIterator<K, V> extends LinkIterator<K, V> implements\n            OrderedIterator<Map.Entry<K, V>>, ResettableIterator<Map.Entry<K, V>>", "class_docstring": "\nEntrySet iterator.\n\n@param <K> the key type.\n@param <V> the value type.\n", "name": "EntrySetIterator", "super_interfaces": ["OrderedIterator<Map.Entry<K, V>>", "ResettableIterator<Map.Entry<K, V>>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected EntrySetIterator(final AbstractLinkedMap<K, V> parent) {\n            super(parent);\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent The parent AbstractLinkedMap.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "EntrySetIterator", "params": [{"name": "parent", "type": "AbstractLinkedMap<K, V>"}], "body": "                                                                         {\n            super(parent);\n        }", "signature": "protected EntrySetIterator(final AbstractLinkedMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<K, V> next() {\n            return super.nextEntry();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "next", "params": [], "body": "                                      {\n            return super.nextEntry();\n        }", "signature": "@Override\n        public Map.Entry<K, V> next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<K, V> previous() {\n            return super.previousEntry();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "previous", "params": [], "body": "                                          {\n            return super.previousEntry();\n        }", "signature": "@Override\n        public Map.Entry<K, V> previous()"}]}, {"original_string": "    protected static class KeySetIterator<K> extends LinkIterator<K, Object> implements\n            OrderedIterator<K>, ResettableIterator<K> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractLinkedMap.\n         */\n        @SuppressWarnings(\"unchecked\")\n        protected KeySetIterator(final AbstractLinkedMap<K, ?> parent) {\n            super((AbstractLinkedMap<K, Object>) parent);\n        }\n\n        @Override\n        public K next() {\n            return super.nextEntry().getKey();\n        }\n\n        @Override\n        public K previous() {\n            return super.previousEntry().getKey();\n        }\n    }", "definition": "    protected static class KeySetIterator<K> extends LinkIterator<K, Object> implements\n            OrderedIterator<K>, ResettableIterator<K>", "class_docstring": "\nKeySet iterator.\n\n@param <K> the key type.\n", "name": "KeySetIterator", "super_interfaces": ["OrderedIterator<K>", "ResettableIterator<K>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        protected KeySetIterator(final AbstractLinkedMap<K, ?> parent) {\n            super((AbstractLinkedMap<K, Object>) parent);\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent The parent AbstractLinkedMap.\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        protected", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "protected"], "comments": [], "return_type": "", "classes": []}, "name": "KeySetIterator", "params": [{"name": "parent", "type": "AbstractLinkedMap<K, ?>"}], "body": "                                                                       {\n            super((AbstractLinkedMap<K, Object>) parent);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        protected KeySetIterator(final AbstractLinkedMap<K, ?> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            return super.nextEntry().getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return super.nextEntry().getKey();\n        }", "signature": "@Override\n        public K next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K previous() {\n            return super.previousEntry().getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            return super.previousEntry().getKey();\n        }", "signature": "@Override\n        public K previous()"}]}, {"original_string": "    protected static class LinkEntry<K, V> extends HashEntry<K, V> {\n        /** The entry before this one in the order */\n        protected LinkEntry<K, V> before;\n        /** The entry after this one in the order */\n        protected LinkEntry<K, V> after;\n\n        /**\n         * Constructs a new entry.\n         *\n         * @param next  the next entry in the hash bucket sequence\n         * @param hashCode  the hash code\n         * @param key  the key\n         * @param value  the value\n         */\n        protected LinkEntry(final HashEntry<K, V> next, final int hashCode, final Object key, final V value) {\n            super(next, hashCode, key, value);\n        }\n    }", "definition": "    protected static class LinkEntry<K, V> extends HashEntry<K, V>", "class_docstring": "\nLinkEntry that stores the data.\n<p>\nIf you subclass {@code AbstractLinkedMap} but not {@code LinkEntry}\nthen you will not be able to access the protected fields.\nThe {@code entryXxx()} methods on {@code AbstractLinkedMap} exist\nto provide the necessary access.\n</p>\n\n@param <K> the key type.\n@param <V> the value type.\n", "name": "LinkEntry", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected LinkEntry<K, V> before;", "docstring": " The entry before this one in the order", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "LinkEntry<K, V>", "name": "before", "syntax_pass": true}, {"attribute_expression": "protected LinkEntry<K, V> after;", "docstring": " The entry after this one in the order", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "LinkEntry<K, V>", "name": "after", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected LinkEntry(final HashEntry<K, V> next, final int hashCode, final Object key, final V value) {\n            super(next, hashCode, key, value);\n        }", "docstring": "\nConstructs a new entry.\n\n@param next  the next entry in the hash bucket sequence\n@param hashCode  the hash code\n@param key  the key\n@param value  the value\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "LinkEntry", "params": [{"name": "next", "type": "HashEntry<K, V>"}, {"name": "hashCode", "type": "int"}, {"name": "key", "type": "Object"}, {"name": "value", "type": "V"}], "body": "                                                                                                             {\n            super(next, hashCode, key, value);\n        }", "signature": "protected LinkEntry(final HashEntry<K, V> next, final int hashCode, final Object key, final V value)"}]}, {"original_string": "    protected abstract static class LinkIterator<K, V> {\n\n        /** The parent map */\n        protected final AbstractLinkedMap<K, V> parent;\n\n        /** The current (last returned) entry */\n        protected LinkEntry<K, V> last;\n\n        /** The next entry */\n        protected LinkEntry<K, V> next;\n\n        /** The modification count expected */\n        protected int expectedModCount;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractLinkedMap.\n         */\n        protected LinkIterator(final AbstractLinkedMap<K, V> parent) {\n            this.parent = Objects.requireNonNull(parent);\n            this.next = parent.header.after;\n            this.expectedModCount = parent.modCount;\n        }\n\n        /**\n         * Gets the current entry.\n         *\n         * @return the current entry.\n         */\n        protected LinkEntry<K, V> currentEntry() {\n            return last;\n        }\n\n        /**\n         * Tests whether there is another entry.\n         *\n         * @return whether there is another entry.\n         */\n        public boolean hasNext() {\n            return next != parent.header;\n        }\n\n        /**\n         * Tests whether there is a previous entry.\n         *\n         * @return whether there is a previous entry.\n         */\n        public boolean hasPrevious() {\n            return next.before != parent.header;\n        }\n\n        /**\n         * Gets the next entry.\n         *\n         * @return the next entry.\n         */\n        protected LinkEntry<K, V> nextEntry() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            if (next == parent.header)  {\n                throw new NoSuchElementException(NO_NEXT_ENTRY);\n            }\n            last = next;\n            next = next.after;\n            return last;\n        }\n\n        /**\n         * Gets the previous entry.\n         *\n         * @return the previous entry.\n         */\n        protected LinkEntry<K, V> previousEntry() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            final LinkEntry<K, V> previous = next.before;\n            if (previous == parent.header)  {\n                throw new NoSuchElementException(NO_PREVIOUS_ENTRY);\n            }\n            next = previous;\n            last = previous;\n            return last;\n        }\n\n        /**\n         * Removes the current entry.\n         */\n        public void remove() {\n            if (last == null) {\n                throw new IllegalStateException(REMOVE_INVALID);\n            }\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            parent.remove(last.getKey());\n            last = null;\n            expectedModCount = parent.modCount;\n        }\n\n        /**\n         * Resets the state to the end.\n         */\n        public void reset() {\n            last = null;\n            next = parent.header.after;\n        }\n\n        @Override\n        public String toString() {\n            if (last != null) {\n                return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }\n    }", "definition": "    protected abstract static class LinkIterator<K, V>", "class_docstring": "\nBase Iterator that iterates in link order.\n\n@param <K> the key type.\n@param <V> the value type.\n", "name": "LinkIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected abstract static", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract", "static"], "comments": [], "fields": [{"attribute_expression": "protected final AbstractLinkedMap<K, V> parent;", "docstring": " The parent map", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "AbstractLinkedMap<K, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "protected LinkEntry<K, V> last;", "docstring": " The current (last returned) entry", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "LinkEntry<K, V>", "name": "last", "syntax_pass": true}, {"attribute_expression": "protected LinkEntry<K, V> next;", "docstring": " The next entry", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "LinkEntry<K, V>", "name": "next", "syntax_pass": true}, {"attribute_expression": "protected int expectedModCount;", "docstring": " The modification count expected", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "expectedModCount", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected LinkIterator(final AbstractLinkedMap<K, V> parent) {\n            this.parent = Objects.requireNonNull(parent);\n            this.next = parent.header.after;\n            this.expectedModCount = parent.modCount;\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent The parent AbstractLinkedMap.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "LinkIterator", "params": [{"name": "parent", "type": "AbstractLinkedMap<K, V>"}], "body": "                                                                     {\n            this.parent = Objects.requireNonNull(parent);\n            this.next = parent.header.after;\n            this.expectedModCount = parent.modCount;\n        }", "signature": "protected LinkIterator(final AbstractLinkedMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        protected LinkEntry<K, V> currentEntry() {\n            return last;\n        }", "docstring": "\nGets the current entry.\n\n@return the current entry.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "LinkEntry<K, V>", "classes": []}, "name": "currentEntry", "params": [], "body": "                                                 {\n            return last;\n        }", "signature": "protected LinkEntry<K, V> currentEntry()"}, {"syntax_pass": true, "original_string": "        public boolean hasNext() {\n            return next != parent.header;\n        }", "docstring": "\nTests whether there is another entry.\n\n@return whether there is another entry.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return next != parent.header;\n        }", "signature": "public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        public boolean hasPrevious() {\n            return next.before != parent.header;\n        }", "docstring": "\nTests whether there is a previous entry.\n\n@return whether there is a previous entry.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasPrevious", "params": [], "body": "                                     {\n            return next.before != parent.header;\n        }", "signature": "public boolean hasPrevious()"}, {"syntax_pass": true, "original_string": "        protected LinkEntry<K, V> nextEntry() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            if (next == parent.header)  {\n                throw new NoSuchElementException(NO_NEXT_ENTRY);\n            }\n            last = next;\n            next = next.after;\n            return last;\n        }", "docstring": "\nGets the next entry.\n\n@return the next entry.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "LinkEntry<K, V>", "classes": []}, "name": "nextEntry", "params": [], "body": "                                              {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            if (next == parent.header)  {\n                throw new NoSuchElementException(NO_NEXT_ENTRY);\n            }\n            last = next;\n            next = next.after;\n            return last;\n        }", "signature": "protected LinkEntry<K, V> nextEntry()"}, {"syntax_pass": true, "original_string": "        protected LinkEntry<K, V> previousEntry() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            final LinkEntry<K, V> previous = next.before;\n            if (previous == parent.header)  {\n                throw new NoSuchElementException(NO_PREVIOUS_ENTRY);\n            }\n            next = previous;\n            last = previous;\n            return last;\n        }", "docstring": "\nGets the previous entry.\n\n@return the previous entry.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "LinkEntry<K, V>", "classes": []}, "name": "previousEntry", "params": [], "body": "                                                  {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            final LinkEntry<K, V> previous = next.before;\n            if (previous == parent.header)  {\n                throw new NoSuchElementException(NO_PREVIOUS_ENTRY);\n            }\n            next = previous;\n            last = previous;\n            return last;\n        }", "signature": "protected LinkEntry<K, V> previousEntry()"}, {"syntax_pass": true, "original_string": "        public void remove() {\n            if (last == null) {\n                throw new IllegalStateException(REMOVE_INVALID);\n            }\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            parent.remove(last.getKey());\n            last = null;\n            expectedModCount = parent.modCount;\n        }", "docstring": "\nRemoves the current entry.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (last == null) {\n                throw new IllegalStateException(REMOVE_INVALID);\n            }\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            parent.remove(last.getKey());\n            last = null;\n            expectedModCount = parent.modCount;\n        }", "signature": "public void remove()"}, {"syntax_pass": true, "original_string": "        public void reset() {\n            last = null;\n            next = parent.header.after;\n        }", "docstring": "\nResets the state to the end.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "reset", "params": [], "body": "                            {\n            last = null;\n            next = parent.header.after;\n        }", "signature": "public void reset()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            if (last != null) {\n                return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            if (last != null) {\n                return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    protected static class LinkMapIterator<K, V> extends LinkIterator<K, V> implements\n            OrderedMapIterator<K, V>, ResettableIterator<K> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractLinkedMap.\n         */\n        protected LinkMapIterator(final AbstractLinkedMap<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public K getKey() {\n            final LinkEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETKEY_INVALID);\n            }\n            return current.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            final LinkEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETVALUE_INVALID);\n            }\n            return current.getValue();\n        }\n\n        @Override\n        public K next() {\n            return super.nextEntry().getKey();\n        }\n\n        @Override\n        public K previous() {\n            return super.previousEntry().getKey();\n        }\n\n        @Override\n        public V setValue(final V value) {\n            final LinkEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(SETVALUE_INVALID);\n            }\n            return current.setValue(value);\n        }\n    }", "definition": "    protected static class LinkMapIterator<K, V> extends LinkIterator<K, V> implements\n            OrderedMapIterator<K, V>, ResettableIterator<K>", "class_docstring": "\nMapIterator implementation.\n\n@param <K> the key type.\n@param <V> the value type.\n", "name": "LinkMapIterator", "super_interfaces": ["OrderedMapIterator<K, V>", "ResettableIterator<K>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected LinkMapIterator(final AbstractLinkedMap<K, V> parent) {\n            super(parent);\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent The parent AbstractLinkedMap.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "LinkMapIterator", "params": [{"name": "parent", "type": "AbstractLinkedMap<K, V>"}], "body": "                                                                        {\n            super(parent);\n        }", "signature": "protected LinkMapIterator(final AbstractLinkedMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            final LinkEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETKEY_INVALID);\n            }\n            return current.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            final LinkEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETKEY_INVALID);\n            }\n            return current.getKey();\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            final LinkEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETVALUE_INVALID);\n            }\n            return current.getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            final LinkEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETVALUE_INVALID);\n            }\n            return current.getValue();\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            return super.nextEntry().getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return super.nextEntry().getKey();\n        }", "signature": "@Override\n        public K next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K previous() {\n            return super.previousEntry().getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            return super.previousEntry().getKey();\n        }", "signature": "@Override\n        public K previous()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            final LinkEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(SETVALUE_INVALID);\n            }\n            return current.setValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            final LinkEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(SETVALUE_INVALID);\n            }\n            return current.setValue(value);\n        }", "signature": "@Override\n        public V setValue(final V value)"}]}, {"original_string": "    protected static class ValuesIterator<V> extends LinkIterator<Object, V> implements\n            OrderedIterator<V>, ResettableIterator<V> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractLinkedMap.\n         */\n        @SuppressWarnings(\"unchecked\")\n        protected ValuesIterator(final AbstractLinkedMap<?, V> parent) {\n            super((AbstractLinkedMap<Object, V>) parent);\n        }\n\n        @Override\n        public V next() {\n            return super.nextEntry().getValue();\n        }\n\n        @Override\n        public V previous() {\n            return super.previousEntry().getValue();\n        }\n    }", "definition": "    protected static class ValuesIterator<V> extends LinkIterator<Object, V> implements\n            OrderedIterator<V>, ResettableIterator<V>", "class_docstring": "\nValues iterator.\n\n@param <V> the value type.\n", "name": "ValuesIterator", "super_interfaces": ["OrderedIterator<V>", "ResettableIterator<V>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        protected ValuesIterator(final AbstractLinkedMap<?, V> parent) {\n            super((AbstractLinkedMap<Object, V>) parent);\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent The parent AbstractLinkedMap.\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        protected", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "protected"], "comments": [], "return_type": "", "classes": []}, "name": "ValuesIterator", "params": [{"name": "parent", "type": "AbstractLinkedMap<?, V>"}], "body": "                                                                       {\n            super((AbstractLinkedMap<Object, V>) parent);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        protected ValuesIterator(final AbstractLinkedMap<?, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V next() {\n            return super.nextEntry().getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return super.nextEntry().getValue();\n        }", "signature": "@Override\n        public V next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V previous() {\n            return super.previousEntry().getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            return super.previousEntry().getValue();\n        }", "signature": "@Override\n        public V previous()"}]}], "class_docstring": "\nAn abstract implementation of a hash-based map that links entries to create an\nordered map and which provides numerous points for subclasses to override.\n<p>\nThis class implements all the features necessary for a subclass linked\nhash-based map. Key-value entries are stored in instances of the\n{@code LinkEntry} class which can be overridden and replaced.\nThe iterators can similarly be replaced, without the need to replace the KeySet,\nEntrySet and Values view classes.\n</p>\n<p>\nOverridable methods are provided to change the default hashing behavior, and\nto change how entries are added to and removed from the map. Hopefully, all you\nneed for unusual subclasses is here.\n</p>\n<p>\nThis implementation maintains order by original insertion, but subclasses\nmay work differently. The {@code OrderedMap} interface is implemented\nto provide access to bidirectional iteration and extra convenience methods.\n</p>\n<p>\nThe {@code orderedMapIterator()} method provides direct access to a\nbidirectional iterator. The iterators from the other views can also be cast\nto {@code OrderedIterator} if required.\n</p>\n<p>\nAll the available iterators can be reset back to the start by casting to\n{@code ResettableIterator} and calling {@code reset()}.\n</p>\n<p>\nThe implementation is also designed to be subclassed, with lots of useful\nmethods exposed.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public abstract class AbstractLinkedMap<K, V> extends AbstractHashedMap<K, V> implements OrderedMap<K, V> {\n\n    /**\n     * EntrySet iterator.\n     *\n     * @param <K> the key type.\n     * @param <V> the value type.\n     */\n    protected static class EntrySetIterator<K, V> extends LinkIterator<K, V> implements\n            OrderedIterator<Map.Entry<K, V>>, ResettableIterator<Map.Entry<K, V>> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractLinkedMap.\n         */\n        protected EntrySetIterator(final AbstractLinkedMap<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            return super.nextEntry();\n        }\n\n        @Override\n        public Map.Entry<K, V> previous() {\n            return super.previousEntry();\n        }\n    }\n\n    /**\n     * KeySet iterator.\n     *\n     * @param <K> the key type.\n     */\n    protected static class KeySetIterator<K> extends LinkIterator<K, Object> implements\n            OrderedIterator<K>, ResettableIterator<K> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractLinkedMap.\n         */\n        @SuppressWarnings(\"unchecked\")\n        protected KeySetIterator(final AbstractLinkedMap<K, ?> parent) {\n            super((AbstractLinkedMap<K, Object>) parent);\n        }\n\n        @Override\n        public K next() {\n            return super.nextEntry().getKey();\n        }\n\n        @Override\n        public K previous() {\n            return super.previousEntry().getKey();\n        }\n    }\n\n    /**\n     * LinkEntry that stores the data.\n     * <p>\n     * If you subclass {@code AbstractLinkedMap} but not {@code LinkEntry}\n     * then you will not be able to access the protected fields.\n     * The {@code entryXxx()} methods on {@code AbstractLinkedMap} exist\n     * to provide the necessary access.\n     * </p>\n     *\n     * @param <K> the key type.\n     * @param <V> the value type.\n     */\n    protected static class LinkEntry<K, V> extends HashEntry<K, V> {\n        /** The entry before this one in the order */\n        protected LinkEntry<K, V> before;\n        /** The entry after this one in the order */\n        protected LinkEntry<K, V> after;\n\n        /**\n         * Constructs a new entry.\n         *\n         * @param next  the next entry in the hash bucket sequence\n         * @param hashCode  the hash code\n         * @param key  the key\n         * @param value  the value\n         */\n        protected LinkEntry(final HashEntry<K, V> next, final int hashCode, final Object key, final V value) {\n            super(next, hashCode, key, value);\n        }\n    }\n\n    /**\n     * Base Iterator that iterates in link order.\n     *\n     * @param <K> the key type.\n     * @param <V> the value type.\n     */\n    protected abstract static class LinkIterator<K, V> {\n\n        /** The parent map */\n        protected final AbstractLinkedMap<K, V> parent;\n\n        /** The current (last returned) entry */\n        protected LinkEntry<K, V> last;\n\n        /** The next entry */\n        protected LinkEntry<K, V> next;\n\n        /** The modification count expected */\n        protected int expectedModCount;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractLinkedMap.\n         */\n        protected LinkIterator(final AbstractLinkedMap<K, V> parent) {\n            this.parent = Objects.requireNonNull(parent);\n            this.next = parent.header.after;\n            this.expectedModCount = parent.modCount;\n        }\n\n        /**\n         * Gets the current entry.\n         *\n         * @return the current entry.\n         */\n        protected LinkEntry<K, V> currentEntry() {\n            return last;\n        }\n\n        /**\n         * Tests whether there is another entry.\n         *\n         * @return whether there is another entry.\n         */\n        public boolean hasNext() {\n            return next != parent.header;\n        }\n\n        /**\n         * Tests whether there is a previous entry.\n         *\n         * @return whether there is a previous entry.\n         */\n        public boolean hasPrevious() {\n            return next.before != parent.header;\n        }\n\n        /**\n         * Gets the next entry.\n         *\n         * @return the next entry.\n         */\n        protected LinkEntry<K, V> nextEntry() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            if (next == parent.header)  {\n                throw new NoSuchElementException(NO_NEXT_ENTRY);\n            }\n            last = next;\n            next = next.after;\n            return last;\n        }\n\n        /**\n         * Gets the previous entry.\n         *\n         * @return the previous entry.\n         */\n        protected LinkEntry<K, V> previousEntry() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            final LinkEntry<K, V> previous = next.before;\n            if (previous == parent.header)  {\n                throw new NoSuchElementException(NO_PREVIOUS_ENTRY);\n            }\n            next = previous;\n            last = previous;\n            return last;\n        }\n\n        /**\n         * Removes the current entry.\n         */\n        public void remove() {\n            if (last == null) {\n                throw new IllegalStateException(REMOVE_INVALID);\n            }\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n            parent.remove(last.getKey());\n            last = null;\n            expectedModCount = parent.modCount;\n        }\n\n        /**\n         * Resets the state to the end.\n         */\n        public void reset() {\n            last = null;\n            next = parent.header.after;\n        }\n\n        @Override\n        public String toString() {\n            if (last != null) {\n                return \"Iterator[\" + last.getKey() + \"=\" + last.getValue() + \"]\";\n            }\n            return \"Iterator[]\";\n        }\n    }\n\n    /**\n     * MapIterator implementation.\n     *\n     * @param <K> the key type.\n     * @param <V> the value type.\n     */\n    protected static class LinkMapIterator<K, V> extends LinkIterator<K, V> implements\n            OrderedMapIterator<K, V>, ResettableIterator<K> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractLinkedMap.\n         */\n        protected LinkMapIterator(final AbstractLinkedMap<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public K getKey() {\n            final LinkEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETKEY_INVALID);\n            }\n            return current.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            final LinkEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETVALUE_INVALID);\n            }\n            return current.getValue();\n        }\n\n        @Override\n        public K next() {\n            return super.nextEntry().getKey();\n        }\n\n        @Override\n        public K previous() {\n            return super.previousEntry().getKey();\n        }\n\n        @Override\n        public V setValue(final V value) {\n            final LinkEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(SETVALUE_INVALID);\n            }\n            return current.setValue(value);\n        }\n    }\n\n    /**\n     * Values iterator.\n     *\n     * @param <V> the value type.\n     */\n    protected static class ValuesIterator<V> extends LinkIterator<Object, V> implements\n            OrderedIterator<V>, ResettableIterator<V> {\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractLinkedMap.\n         */\n        @SuppressWarnings(\"unchecked\")\n        protected ValuesIterator(final AbstractLinkedMap<?, V> parent) {\n            super((AbstractLinkedMap<Object, V>) parent);\n        }\n\n        @Override\n        public V next() {\n            return super.nextEntry().getValue();\n        }\n\n        @Override\n        public V previous() {\n            return super.previousEntry().getValue();\n        }\n    }\n\n    /** Header in the linked list */\n    transient LinkEntry<K, V> header;\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     */\n    protected AbstractLinkedMap() {\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity.\n     *\n     * @param initialCapacity  the initial capacity\n     * @throws IllegalArgumentException if the initial capacity is negative\n     */\n    protected AbstractLinkedMap(final int initialCapacity) {\n        super(initialCapacity);\n    }\n\n    /**\n     * Constructs a new, empty map with the specified initial capacity and\n     * load factor.\n     *\n     * @param initialCapacity  the initial capacity\n     * @param loadFactor  the load factor\n     * @throws IllegalArgumentException if the initial capacity is negative\n     * @throws IllegalArgumentException if the load factor is less than zero\n     */\n    protected AbstractLinkedMap(final int initialCapacity, final float loadFactor) {\n        super(initialCapacity, loadFactor);\n    }\n\n    /**\n     * Constructor which performs no validation on the passed in parameters.\n     *\n     * @param initialCapacity  the initial capacity, must be a power of two\n     * @param loadFactor  the load factor, must be &gt; 0.0f and generally &lt; 1.0f\n     * @param threshold  the threshold, must be sensible\n     */\n    protected AbstractLinkedMap(final int initialCapacity, final float loadFactor, final int threshold) {\n        super(initialCapacity, loadFactor, threshold);\n    }\n\n    /**\n     * Constructor copying elements from another map.\n     *\n     * @param map  the map to copy\n     * @throws NullPointerException if the map is null\n     */\n    protected AbstractLinkedMap(final Map<? extends K, ? extends V> map) {\n        super(map);\n    }\n\n    /**\n     * Adds an entry into this map, maintaining insertion order.\n     * <p>\n     * This implementation adds the entry to the data storage table and\n     * to the end of the linked list.\n     *\n     * @param entry  the entry to add\n     * @param hashIndex  the index into the data array to store at\n     */\n    @Override\n    protected void addEntry(final HashEntry<K, V> entry, final int hashIndex) {\n        final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;\n        link.after  = header;\n        link.before = header.before;\n        header.before.after = link;\n        header.before = link;\n        data[hashIndex] = link;\n    }\n\n    /**\n     * Clears the map, resetting the size to zero and nullifying references\n     * to avoid garbage collection issues.\n     */\n    @Override\n    public void clear() {\n        // override to reset the linked list\n        super.clear();\n        header.before = header.after = header;\n    }\n\n    /**\n     * Checks whether the map contains the specified value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    @Override\n    public boolean containsValue(final Object value) {\n        // override uses faster iterator\n        if (value == null) {\n            for (LinkEntry<K, V> entry = header.after; entry != header; entry = entry.after) {\n                if (entry.getValue() == null) {\n                    return true;\n                }\n            }\n        } else {\n            for (LinkEntry<K, V> entry = header.after; entry != header; entry = entry.after) {\n                if (isEqualValue(value, entry.getValue())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Creates an entry to store the data.\n     * <p>\n     * This implementation creates a new LinkEntry instance.\n     *\n     * @param next  the next entry in sequence\n     * @param hashCode  the hash code to use\n     * @param key  the key to store\n     * @param value  the value to store\n     * @return the newly created entry\n     */\n    @Override\n    protected LinkEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode, final K key, final V value) {\n        return new LinkEntry<>(next, hashCode, convertKey(key), value);\n    }\n\n    /**\n     * Creates an entry set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the entrySet iterator\n     */\n    @Override\n    protected Iterator<Map.Entry<K, V>> createEntrySetIterator() {\n        if (isEmpty()) {\n            return EmptyOrderedIterator.<Map.Entry<K, V>>emptyOrderedIterator();\n        }\n        return new EntrySetIterator<>(this);\n    }\n\n    /**\n     * Creates a key set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the keySet iterator\n     */\n    @Override\n    protected Iterator<K> createKeySetIterator() {\n        if (isEmpty()) {\n            return EmptyOrderedIterator.<K>emptyOrderedIterator();\n        }\n        return new KeySetIterator<>(this);\n    }\n\n    /**\n     * Creates a values iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the values iterator\n     */\n    @Override\n    protected Iterator<V> createValuesIterator() {\n        if (isEmpty()) {\n            return EmptyOrderedIterator.<V>emptyOrderedIterator();\n        }\n        return new ValuesIterator<>(this);\n    }\n\n    /**\n     * Gets the {@code after} field from a {@code LinkEntry}.\n     * Used in subclasses that have no visibility of the field.\n     *\n     * @param entry  the entry to query, must not be null\n     * @return the {@code after} field of the entry\n     * @throws NullPointerException if the entry is null\n     * @since 3.1\n     */\n    protected LinkEntry<K, V> entryAfter(final LinkEntry<K, V> entry) {\n        return entry.after;\n    }\n\n    /**\n     * Gets the {@code before} field from a {@code LinkEntry}.\n     * Used in subclasses that have no visibility of the field.\n     *\n     * @param entry  the entry to query, must not be null\n     * @return the {@code before} field of the entry\n     * @throws NullPointerException if the entry is null\n     * @since 3.1\n     */\n    protected LinkEntry<K, V> entryBefore(final LinkEntry<K, V> entry) {\n        return entry.before;\n    }\n\n    /**\n     * Gets the first key in the map, which is the first inserted.\n     *\n     * @return the eldest key\n     */\n    @Override\n    public K firstKey() {\n        if (size == 0) {\n            throw new NoSuchElementException(\"Map is empty\");\n        }\n        return header.after.getKey();\n    }\n\n    /**\n     * Gets the key at the specified index.\n     *\n     * @param index  the index to retrieve\n     * @return the key at the specified index\n     * @throws IndexOutOfBoundsException if the index is invalid\n     */\n    protected LinkEntry<K, V> getEntry(final int index) {\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"Index \" + index + \" is less than zero\");\n        }\n        if (index >= size) {\n            throw new IndexOutOfBoundsException(\"Index \" + index + \" is invalid for size \" + size);\n        }\n        LinkEntry<K, V> entry;\n        if (index < size / 2) {\n            // Search forwards\n            entry = header.after;\n            for (int currentIndex = 0; currentIndex < index; currentIndex++) {\n                entry = entry.after;\n            }\n        } else {\n            // Search backwards\n            entry = header;\n            for (int currentIndex = size; currentIndex > index; currentIndex--) {\n                entry = entry.before;\n            }\n        }\n        return entry;\n    }\n\n    @Override\n    protected LinkEntry<K, V> getEntry(final Object key) {\n        return (LinkEntry<K, V>) super.getEntry(key);\n    }\n\n    /**\n     * Initialize this subclass during construction.\n     * <p>\n     * NOTE: As from v3.2 this method calls\n     * {@link #createEntry(HashEntry, int, Object, Object)} to create\n     * the map entry object.\n     */\n    @Override\n    protected void init() {\n        header = createEntry(null, -1, null, null);\n        header.before = header.after = header;\n    }\n\n    /**\n     * Gets the last key in the map, which is the most recently inserted.\n     *\n     * @return the most recently inserted key\n     */\n    @Override\n    public K lastKey() {\n        if (size == 0) {\n            throw new NoSuchElementException(\"Map is empty\");\n        }\n        return header.before.getKey();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        if (size == 0) {\n            return EmptyOrderedMapIterator.<K, V>emptyOrderedMapIterator();\n        }\n        return new LinkMapIterator<>(this);\n    }\n\n    /**\n     * Gets the next key in sequence.\n     *\n     * @param key  the key to get after\n     * @return the next key\n     */\n    @Override\n    public K nextKey(final Object key) {\n        final LinkEntry<K, V> entry = getEntry(key);\n        return entry == null || entry.after == header ? null : entry.after.getKey();\n    }\n\n    /**\n     * Gets the previous key in sequence.\n     *\n     * @param key  the key to get before\n     * @return the previous key\n     */\n    @Override\n    public K previousKey(final Object key) {\n        final LinkEntry<K, V> entry = getEntry(key);\n        return entry == null || entry.before == header ? null : entry.before.getKey();\n    }\n\n    /**\n     * Removes an entry from the map and the linked list.\n     * <p>\n     * This implementation removes the entry from the linked list chain, then\n     * calls the superclass implementation.\n     *\n     * @param entry  the entry to remove\n     * @param hashIndex  the index into the data structure\n     * @param previous  the previous entry in the chain\n     */\n    @Override\n    protected void removeEntry(final HashEntry<K, V> entry, final int hashIndex, final HashEntry<K, V> previous) {\n        final LinkEntry<K, V> link = (LinkEntry<K, V>) entry;\n        link.before.after = link.after;\n        link.after.before = link.before;\n        link.after = null;\n        link.before = null;\n        super.removeEntry(entry, hashIndex, previous);\n    }\n\n}", "super_interfaces": ["OrderedMap<K, V>"], "fields": [{"attribute_expression": "transient LinkEntry<K, V> header;", "docstring": " Header in the linked list", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "LinkEntry<K, V>", "name": "header", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java.AbstractSortedMapDecorator", "name": "AbstractSortedMapDecorator", "file_path": "src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java", "superclasses": "", "methods": ["[]AbstractSortedMapDecorator()", "[]AbstractSortedMapDecorator(SortedMap<K, V>)", "[Comparator<? super K>]comparator()", "[SortedMap<K, V>]decorated()", "[K]firstKey()", "[SortedMap<K, V>]headMap(K)", "[K]lastKey()", "[OrderedMapIterator<K, V>]mapIterator()", "[K]nextKey(K)", "[K]previousKey(K)", "[SortedMap<K, V>]subMap(K,K)", "[SortedMap<K, V>]tailMap(K)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java.AbstractSortedMapDecorator.[]AbstractSortedMapDecorator()", "src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java.AbstractSortedMapDecorator.[]AbstractSortedMapDecorator(SortedMap<K, V>)", "src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java.AbstractSortedMapDecorator.[Comparator<? super K>]comparator()", "src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java.AbstractSortedMapDecorator.[SortedMap<K, V>]decorated()", "src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java.AbstractSortedMapDecorator.[K]firstKey()", "src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java.AbstractSortedMapDecorator.[SortedMap<K, V>]headMap(K)", "src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java.AbstractSortedMapDecorator.[K]lastKey()", "src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java.AbstractSortedMapDecorator.[OrderedMapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java.AbstractSortedMapDecorator.[K]nextKey(K)", "src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java.AbstractSortedMapDecorator.[K]previousKey(K)", "src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java.AbstractSortedMapDecorator.[SortedMap<K, V>]subMap(K,K)", "src/main/java/org/apache/commons/collections4/map/AbstractSortedMapDecorator.java.AbstractSortedMapDecorator.[SortedMap<K, V>]tailMap(K)"], "overrides": null, "attributes": [{"original_string": "    protected static class SortedMapIterator<K, V> extends EntrySetToMapIteratorAdapter<K, V>\n            implements OrderedMapIterator<K, V> {\n\n        /**\n         * Create a new AbstractSortedMapDecorator.SortedMapIterator.\n         * @param entrySet  the entrySet to iterate\n         */\n        protected SortedMapIterator(final Set<Map.Entry<K, V>> entrySet) {\n            super(entrySet);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean hasPrevious() {\n            return ((ListIterator<Map.Entry<K, V>>) iterator).hasPrevious();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public K previous() {\n            entry = ((ListIterator<Map.Entry<K, V>>) iterator).previous();\n            return getKey();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public synchronized void reset() {\n            super.reset();\n            iterator = new ListIteratorWrapper<>(iterator);\n        }\n    }", "definition": "    protected static class SortedMapIterator<K, V> extends EntrySetToMapIteratorAdapter<K, V>\n            implements OrderedMapIterator<K, V>", "class_docstring": "\nOrderedMapIterator implementation.\n\n@param <K>  the key type\n@param <V>  the value type\n", "name": "SortedMapIterator", "super_interfaces": ["OrderedMapIterator<K, V>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected SortedMapIterator(final Set<Map.Entry<K, V>> entrySet) {\n            super(entrySet);\n        }", "docstring": "\nCreate a new AbstractSortedMapDecorator.SortedMapIterator.\n@param entrySet  the entrySet to iterate\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "SortedMapIterator", "params": [{"name": "entrySet", "type": "Set<Map.Entry<K, V>>"}], "body": "                                                                         {\n            super(entrySet);\n        }", "signature": "protected SortedMapIterator(final Set<Map.Entry<K, V>> entrySet)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasPrevious() {\n            return ((ListIterator<Map.Entry<K, V>>) iterator).hasPrevious();\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasPrevious", "params": [], "body": "                                     {\n            return ((ListIterator<Map.Entry<K, V>>) iterator).hasPrevious();\n        }", "signature": "@Override\n        public boolean hasPrevious()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K previous() {\n            entry = ((ListIterator<Map.Entry<K, V>>) iterator).previous();\n            return getKey();\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            entry = ((ListIterator<Map.Entry<K, V>>) iterator).previous();\n            return getKey();\n        }", "signature": "@Override\n        public K previous()"}, {"syntax_pass": true, "original_string": "        @Override\n        public synchronized void reset() {\n            super.reset();\n            iterator = new ListIteratorWrapper<>(iterator);\n        }", "docstring": "\n{@inheritDoc}\n", "attributes": {"modifiers": "@Override\n        public synchronized", "marker_annotations": ["@Override"], "non_marker_annotations": ["public", "synchronized"], "comments": [], "return_type": "void", "classes": []}, "name": "reset", "params": [], "body": "                                         {\n            super.reset();\n            iterator = new ListIteratorWrapper<>(iterator);\n        }", "signature": "@Override\n        public synchronized void reset()"}]}], "class_docstring": "\nProvides a base decorator that enables additional functionality to be added\nto a Map via decoration.\n<p>\nMethods are forwarded directly to the decorated map.\n</p>\n<p>\nThis implementation does not perform any special processing with the map views.\nInstead it simply returns the set/collection from the wrapped map. This may be\nundesirable, for example if you are trying to write a validating implementation\nit would provide a loophole around the validation.\nBut, you might want that loophole, so this class is kept simple.\n</p>\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n@since 3.0\n", "original_string": "public abstract class AbstractSortedMapDecorator<K, V> extends AbstractMapDecorator<K, V> implements\n        IterableSortedMap<K, V> {\n\n    /**\n     * OrderedMapIterator implementation.\n     *\n     * @param <K>  the key type\n     * @param <V>  the value type\n     */\n    protected static class SortedMapIterator<K, V> extends EntrySetToMapIteratorAdapter<K, V>\n            implements OrderedMapIterator<K, V> {\n\n        /**\n         * Create a new AbstractSortedMapDecorator.SortedMapIterator.\n         * @param entrySet  the entrySet to iterate\n         */\n        protected SortedMapIterator(final Set<Map.Entry<K, V>> entrySet) {\n            super(entrySet);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean hasPrevious() {\n            return ((ListIterator<Map.Entry<K, V>>) iterator).hasPrevious();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public K previous() {\n            entry = ((ListIterator<Map.Entry<K, V>>) iterator).previous();\n            return getKey();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public synchronized void reset() {\n            super.reset();\n            iterator = new ListIteratorWrapper<>(iterator);\n        }\n    }\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     * @since 3.1\n     */\n    protected AbstractSortedMapDecorator() {\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if the map is null\n     */\n    public AbstractSortedMapDecorator(final SortedMap<K, V> map) {\n        super(map);\n    }\n\n    @Override\n    public Comparator<? super K> comparator() {\n        return decorated().comparator();\n    }\n\n    /**\n     * Gets the map being decorated.\n     *\n     * @return the decorated map\n     */\n    @Override\n    protected SortedMap<K, V> decorated() {\n        return (SortedMap<K, V>) super.decorated();\n    }\n\n    @Override\n    public K firstKey() {\n        return decorated().firstKey();\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        return decorated().headMap(toKey);\n    }\n\n    @Override\n    public K lastKey() {\n        return decorated().lastKey();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        return new SortedMapIterator<>(entrySet());\n    }\n\n    @Override\n    public K nextKey(final K key) {\n        final Iterator<K> it = tailMap(key).keySet().iterator();\n        it.next();\n        return it.hasNext() ? it.next() : null;\n    }\n\n    @Override\n    public K previousKey(final K key) {\n        final SortedMap<K, V> headMap = headMap(key);\n        return headMap.isEmpty() ? null : headMap.lastKey();\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        return decorated().subMap(fromKey, toKey);\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        return decorated().tailMap(fromKey);\n    }\n}", "super_interfaces": ["IterableSortedMap<K, V>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap", "name": "AbstractReferenceMap", "file_path": "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java", "superclasses": "", "methods": ["[]AbstractReferenceMap()", "[]AbstractReferenceMap(ReferenceStrength,ReferenceStrength,int,float,boolean)", "[void]clear()", "[boolean]containsKey(Object)", "[boolean]containsValue(Object)", "[ReferenceEntry<K, V>]createEntry(HashEntry<K, V>,int,K,V)", "[Iterator<Map.Entry<K, V>>]createEntrySetIterator()", "[Iterator<K>]createKeySetIterator()", "[Iterator<V>]createValuesIterator()", "[void]doReadObject(ObjectInputStream)", "[void]doWriteObject(ObjectOutputStream)", "[Set<Map.Entry<K, V>>]entrySet()", "[V]get(Object)", "[HashEntry<K, V>]getEntry(Object)", "[int]hashEntry(Object,Object)", "[void]init()", "[boolean]isEmpty()", "[boolean]isEqualKey(Object,Object)", "[boolean]isKeyType(ReferenceStrength)", "[boolean]isValueType(ReferenceStrength)", "[Set<K>]keySet()", "[MapIterator<K, V>]mapIterator()", "[void]purge()", "[void]purge(Reference<?>)", "[void]purgeBeforeRead()", "[void]purgeBeforeWrite()", "[V]put(K,V)", "[V]remove(Object)", "[int]size()", "[Collection<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[]AbstractReferenceMap()", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[]AbstractReferenceMap(ReferenceStrength,ReferenceStrength,int,float,boolean)", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[void]clear()", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[ReferenceEntry<K, V>]createEntry(HashEntry<K, V>,int,K,V)", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[Iterator<Map.Entry<K, V>>]createEntrySetIterator()", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[Iterator<K>]createKeySetIterator()", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[Iterator<V>]createValuesIterator()", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[void]doReadObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[void]doWriteObject(ObjectOutputStream)", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[V]get(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[HashEntry<K, V>]getEntry(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[int]hashEntry(Object,Object)", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[void]init()", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[boolean]isEqualKey(Object,Object)", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[boolean]isKeyType(ReferenceStrength)", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[boolean]isValueType(ReferenceStrength)", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[MapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[void]purge()", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[void]purge(Reference<?>)", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[void]purgeBeforeRead()", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[void]purgeBeforeWrite()", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[int]size()", "src/main/java/org/apache/commons/collections4/map/AbstractReferenceMap.java.AbstractReferenceMap.[Collection<V>]values()"], "overrides": null, "attributes": [{"original_string": "    static class ReferenceBaseIterator<K, V> {\n        /** The parent map */\n        final AbstractReferenceMap<K, V> parent;\n\n        // These fields keep track of where we are in the table.\n        int index;\n        ReferenceEntry<K, V> next;\n        ReferenceEntry<K, V> current;\n\n        // These Object fields provide hard references to the\n        // current and next entry; this assures that if hasNext()\n        // returns true, next() will actually return a valid element.\n        K currentKey, nextKey;\n        V currentValue, nextValue;\n\n        int expectedModCount;\n\n        ReferenceBaseIterator(final AbstractReferenceMap<K, V> parent) {\n            this.parent = parent;\n            index = !parent.isEmpty() ? parent.data.length : 0;\n            // have to do this here!  size() invocation above\n            // may have altered the modCount.\n            expectedModCount = parent.modCount;\n        }\n\n        private void checkMod() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        protected ReferenceEntry<K, V> currentEntry() {\n            checkMod();\n            return current;\n        }\n\n        public boolean hasNext() {\n            checkMod();\n            while (nextNull()) {\n                ReferenceEntry<K, V> e = next;\n                int i = index;\n                while (e == null && i > 0) {\n                    i--;\n                    e = (ReferenceEntry<K, V>) parent.data[i];\n                }\n                next = e;\n                index = i;\n                if (e == null) {\n                    return false;\n                }\n                nextKey = e.getKey();\n                nextValue = e.getValue();\n                if (nextNull()) {\n                    next = next.next();\n                }\n            }\n            return true;\n        }\n\n        protected ReferenceEntry<K, V> nextEntry() {\n            checkMod();\n            if (nextNull() && !hasNext()) {\n                throw new NoSuchElementException();\n            }\n            current = next;\n            next = next.next();\n            currentKey = nextKey;\n            currentValue = nextValue;\n            nextKey = null;\n            nextValue = null;\n            return current;\n        }\n\n        private boolean nextNull() {\n            return nextKey == null || nextValue == null;\n        }\n\n        public void remove() {\n            checkMod();\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            parent.remove(currentKey);\n            current = null;\n            currentKey = null;\n            currentValue = null;\n            expectedModCount = parent.modCount;\n        }\n    }", "definition": "    static class ReferenceBaseIterator<K, V>", "class_docstring": "\nBase iterator class.\n", "name": "ReferenceBaseIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "final AbstractReferenceMap<K, V> parent;", "docstring": " The parent map", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "AbstractReferenceMap<K, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "int index;", "docstring": " These fields keep track of where we are in the table.", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "index", "syntax_pass": true}, {"attribute_expression": "ReferenceEntry<K, V> next;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ReferenceEntry<K, V>", "name": "next", "syntax_pass": true}, {"attribute_expression": "ReferenceEntry<K, V> current;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ReferenceEntry<K, V>", "name": "current", "syntax_pass": true}, {"attribute_expression": "K currentKey, nextKey;", "docstring": " returns true, next() will actually return a valid element.", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "K", "name": "currentKey", "syntax_pass": true}, {"attribute_expression": "V currentValue, nextValue;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "V", "name": "currentValue", "syntax_pass": true}, {"attribute_expression": "int expectedModCount;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "expectedModCount", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        ReferenceBaseIterator(final AbstractReferenceMap<K, V> parent) {\n            this.parent = parent;\n            index = !parent.isEmpty() ? parent.data.length : 0;\n            // have to do this here!  size() invocation above\n            // may have altered the modCount.\n            expectedModCount = parent.modCount;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ReferenceBaseIterator", "params": [{"name": "parent", "type": "AbstractReferenceMap<K, V>"}], "body": "                                                                       {\n            this.parent = parent;\n            index = !parent.isEmpty() ? parent.data.length : 0;\n            // have to do this here!  size() invocation above\n            // may have altered the modCount.\n            expectedModCount = parent.modCount;\n        }", "signature": "ReferenceBaseIterator(final AbstractReferenceMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        private void checkMod() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "checkMod", "params": [], "body": "                                {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }", "signature": "private void checkMod()"}, {"syntax_pass": true, "original_string": "        protected ReferenceEntry<K, V> currentEntry() {\n            checkMod();\n            return current;\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "ReferenceEntry<K, V>", "classes": []}, "name": "currentEntry", "params": [], "body": "                                                      {\n            checkMod();\n            return current;\n        }", "signature": "protected ReferenceEntry<K, V> currentEntry()"}, {"syntax_pass": true, "original_string": "        public boolean hasNext() {\n            checkMod();\n            while (nextNull()) {\n                ReferenceEntry<K, V> e = next;\n                int i = index;\n                while (e == null && i > 0) {\n                    i--;\n                    e = (ReferenceEntry<K, V>) parent.data[i];\n                }\n                next = e;\n                index = i;\n                if (e == null) {\n                    return false;\n                }\n                nextKey = e.getKey();\n                nextValue = e.getValue();\n                if (nextNull()) {\n                    next = next.next();\n                }\n            }\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            checkMod();\n            while (nextNull()) {\n                ReferenceEntry<K, V> e = next;\n                int i = index;\n                while (e == null && i > 0) {\n                    i--;\n                    e = (ReferenceEntry<K, V>) parent.data[i];\n                }\n                next = e;\n                index = i;\n                if (e == null) {\n                    return false;\n                }\n                nextKey = e.getKey();\n                nextValue = e.getValue();\n                if (nextNull()) {\n                    next = next.next();\n                }\n            }\n            return true;\n        }", "signature": "public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        protected ReferenceEntry<K, V> nextEntry() {\n            checkMod();\n            if (nextNull() && !hasNext()) {\n                throw new NoSuchElementException();\n            }\n            current = next;\n            next = next.next();\n            currentKey = nextKey;\n            currentValue = nextValue;\n            nextKey = null;\n            nextValue = null;\n            return current;\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "ReferenceEntry<K, V>", "classes": []}, "name": "nextEntry", "params": [], "body": "                                                   {\n            checkMod();\n            if (nextNull() && !hasNext()) {\n                throw new NoSuchElementException();\n            }\n            current = next;\n            next = next.next();\n            currentKey = nextKey;\n            currentValue = nextValue;\n            nextKey = null;\n            nextValue = null;\n            return current;\n        }", "signature": "protected ReferenceEntry<K, V> nextEntry()"}, {"syntax_pass": true, "original_string": "        private boolean nextNull() {\n            return nextKey == null || nextValue == null;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "nextNull", "params": [], "body": "                                   {\n            return nextKey == null || nextValue == null;\n        }", "signature": "private boolean nextNull()"}, {"syntax_pass": true, "original_string": "        public void remove() {\n            checkMod();\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            parent.remove(currentKey);\n            current = null;\n            currentKey = null;\n            currentValue = null;\n            expectedModCount = parent.modCount;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            checkMod();\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            parent.remove(currentKey);\n            current = null;\n            currentKey = null;\n            currentValue = null;\n            expectedModCount = parent.modCount;\n        }", "signature": "public void remove()"}]}, {"original_string": "    protected static class ReferenceEntry<K, V> extends HashEntry<K, V> {\n        /** The parent map */\n        private final AbstractReferenceMap<K, V> parent;\n\n        /**\n         * Creates a new entry object for the ReferenceMap.\n         *\n         * @param parent  the parent map\n         * @param next  the next entry in the hash bucket\n         * @param hashCode  the hash code of the key\n         * @param key  the key\n         * @param value  the value\n         */\n        public ReferenceEntry(final AbstractReferenceMap<K, V> parent, final HashEntry<K, V> next,\n                              final int hashCode, final K key, final V value) {\n            super(next, hashCode, null, null);\n            this.parent = parent;\n            this.key = toReference(parent.keyType, key, hashCode);\n            this.value = toReference(parent.valueType, value, hashCode); // the key hashCode is passed in deliberately\n        }\n\n        /**\n         * Compares this map entry to another.\n         * <p>\n         * This implementation uses {@code isEqualKey} and\n         * {@code isEqualValue} on the main map for comparison.\n         *\n         * @param obj  the other map entry to compare to\n         * @return true if equal, false if not\n         */\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object entryKey = entry.getKey();  // convert to hard reference\n            final Object entryValue = entry.getValue();  // convert to hard reference\n            if (entryKey == null || entryValue == null) {\n                return false;\n            }\n            // compare using map methods, aiding identity subclass\n            // note that key is direct access and value is via method\n            return parent.isEqualKey(entryKey, key) &&\n                   parent.isEqualValue(entryValue, getValue());\n        }\n\n        /**\n         * Gets the key from the entry.\n         * This method dereferences weak and soft keys and thus may return null.\n         *\n         * @return the key, which may be null if it was garbage collected\n         */\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public K getKey() {\n            return (K) (parent.keyType == ReferenceStrength.HARD ? key : ((Reference<K>) key).get());\n        }\n\n        /**\n         * Gets the value from the entry.\n         * This method dereferences weak and soft value and thus may return null.\n         *\n         * @return the value, which may be null if it was garbage collected\n         */\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V getValue() {\n            return (V) (parent.valueType == ReferenceStrength.HARD ? value : ((Reference<V>) value).get());\n        }\n\n        /**\n         * Gets the hash code of the entry using temporary hard references.\n         * <p>\n         * This implementation uses {@code hashEntry} on the main map.\n         *\n         * @return the hash code of the entry\n         */\n        @Override\n        public int hashCode() {\n            return parent.hashEntry(getKey(), getValue());\n        }\n\n        /**\n         * Gets the next entry in the bucket.\n         *\n         * @return the next entry in the bucket\n         */\n        protected ReferenceEntry<K, V> next() {\n            return (ReferenceEntry<K, V>) next;\n        }\n\n        /**\n         * This method can be overridden to provide custom logic to purge value\n         */\n        protected void nullValue() {\n            value = null;\n        }\n\n        /**\n         * This is the callback for custom \"after purge\" logic\n         */\n        protected void onPurge() {\n            // empty\n        }\n\n        /**\n         * Purges the specified reference\n         * @param ref  the reference to purge\n         * @return true or false\n         */\n        protected boolean purge(final Reference<?> ref) {\n            boolean r = parent.keyType != ReferenceStrength.HARD && key == ref;\n            r = r || parent.valueType != ReferenceStrength.HARD && value == ref;\n            if (r) {\n                if (parent.keyType != ReferenceStrength.HARD) {\n                    ((Reference<?>) key).clear();\n                }\n                if (parent.valueType != ReferenceStrength.HARD) {\n                    ((Reference<?>) value).clear();\n                } else if (parent.purgeValues) {\n                    nullValue();\n                }\n            }\n            return r;\n        }\n\n        /**\n         * Sets the value of the entry.\n         *\n         * @param value  the object to store\n         * @return the previous value\n         */\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V setValue(final V value) {\n            final V old = getValue();\n            if (parent.valueType != ReferenceStrength.HARD) {\n                ((Reference<V>) this.value).clear();\n            }\n            this.value = toReference(parent.valueType, value, hashCode);\n            return old;\n        }\n\n        /**\n         * Constructs a reference of the given type to the given referent.\n         * The reference is registered with the queue for later purging.\n         *\n         * @param <T> the type of the referenced object\n         * @param type  HARD, SOFT or WEAK\n         * @param referent  the object to refer to\n         * @param hash  the hash code of the <em>key</em> of the mapping;\n         *    this number might be different from referent.hashCode() if\n         *    the referent represents a value and not a key\n         * @return the reference to the object\n         */\n        protected <T> Object toReference(final ReferenceStrength type, final T referent, final int hash) {\n            switch (type) {\n            case HARD:\n                return referent;\n            case SOFT:\n                return new SoftRef<>(hash, referent, parent.queue);\n            case WEAK:\n                return new WeakRef<>(hash, referent, parent.queue);\n            default:\n                break;\n            }\n            throw new Error();\n        }\n    }", "definition": "    protected static class ReferenceEntry<K, V> extends HashEntry<K, V>", "class_docstring": "\nA MapEntry implementation for the map.\n<p>\nIf getKey() or getValue() returns null, it means\nthe mapping is stale and should be removed.\n</p>\n\n@param <K> the type of the keys\n@param <V> the type of the values\n@since 3.1\n", "name": "ReferenceEntry", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "private final AbstractReferenceMap<K, V> parent;", "docstring": " The parent map", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractReferenceMap<K, V>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public ReferenceEntry(final AbstractReferenceMap<K, V> parent, final HashEntry<K, V> next,\n                              final int hashCode, final K key, final V value) {\n            super(next, hashCode, null, null);\n            this.parent = parent;\n            this.key = toReference(parent.keyType, key, hashCode);\n            this.value = toReference(parent.valueType, value, hashCode); // the key hashCode is passed in deliberately\n        }", "docstring": "\nCreates a new entry object for the ReferenceMap.\n\n@param parent  the parent map\n@param next  the next entry in the hash bucket\n@param hashCode  the hash code of the key\n@param key  the key\n@param value  the value\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "ReferenceEntry", "params": [{"name": "parent", "type": "AbstractReferenceMap<K, V>"}, {"name": "next", "type": "HashEntry<K, V>"}, {"name": "hashCode", "type": "int"}, {"name": "key", "type": "K"}, {"name": "value", "type": "V"}], "body": "                                                                              {\n            super(next, hashCode, null, null);\n            this.parent = parent;\n            this.key = toReference(parent.keyType, key, hashCode);\n            this.value = toReference(parent.valueType, value, hashCode); // the key hashCode is passed in deliberately\n        }", "signature": "public ReferenceEntry(final AbstractReferenceMap<K, V> parent, final HashEntry<K, V> next,\n                              final int hashCode, final K key, final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object entryKey = entry.getKey();  // convert to hard reference\n            final Object entryValue = entry.getValue();  // convert to hard reference\n            if (entryKey == null || entryValue == null) {\n                return false;\n            }\n            // compare using map methods, aiding identity subclass\n            // note that key is direct access and value is via method\n            return parent.isEqualKey(entryKey, key) &&\n                   parent.isEqualValue(entryValue, getValue());\n        }", "docstring": "\nCompares this map entry to another.\n<p>\nThis implementation uses {@code isEqualKey} and\n{@code isEqualValue} on the main map for comparison.\n\n@param obj  the other map entry to compare to\n@return true if equal, false if not\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object entryKey = entry.getKey();  // convert to hard reference\n            final Object entryValue = entry.getValue();  // convert to hard reference\n            if (entryKey == null || entryValue == null) {\n                return false;\n            }\n            // compare using map methods, aiding identity subclass\n            // note that key is direct access and value is via method\n            return parent.isEqualKey(entryKey, key) &&\n                   parent.isEqualValue(entryValue, getValue());\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public K getKey() {\n            return (K) (parent.keyType == ReferenceStrength.HARD ? key : ((Reference<K>) key).get());\n        }", "docstring": "\nGets the key from the entry.\nThis method dereferences weak and soft keys and thus may return null.\n\n@return the key, which may be null if it was garbage collected\n", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            return (K) (parent.keyType == ReferenceStrength.HARD ? key : ((Reference<K>) key).get());\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V getValue() {\n            return (V) (parent.valueType == ReferenceStrength.HARD ? value : ((Reference<V>) value).get());\n        }", "docstring": "\nGets the value from the entry.\nThis method dereferences weak and soft value and thus may return null.\n\n@return the value, which may be null if it was garbage collected\n", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            return (V) (parent.valueType == ReferenceStrength.HARD ? value : ((Reference<V>) value).get());\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return parent.hashEntry(getKey(), getValue());\n        }", "docstring": "\nGets the hash code of the entry using temporary hard references.\n<p>\nThis implementation uses {@code hashEntry} on the main map.\n\n@return the hash code of the entry\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return parent.hashEntry(getKey(), getValue());\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        protected ReferenceEntry<K, V> next() {\n            return (ReferenceEntry<K, V>) next;\n        }", "docstring": "\nGets the next entry in the bucket.\n\n@return the next entry in the bucket\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "ReferenceEntry<K, V>", "classes": []}, "name": "next", "params": [], "body": "                                              {\n            return (ReferenceEntry<K, V>) next;\n        }", "signature": "protected ReferenceEntry<K, V> next()"}, {"syntax_pass": true, "original_string": "        protected void nullValue() {\n            value = null;\n        }", "docstring": "\nThis method can be overridden to provide custom logic to purge value\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "nullValue", "params": [], "body": "                                   {\n            value = null;\n        }", "signature": "protected void nullValue()"}, {"syntax_pass": true, "original_string": "        protected void onPurge() {\n            // empty\n        }", "docstring": "\nThis is the callback for custom \"after purge\" logic\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "onPurge", "params": [], "body": "                                 {\n            // empty\n        }", "signature": "protected void onPurge()"}, {"syntax_pass": true, "original_string": "        protected boolean purge(final Reference<?> ref) {\n            boolean r = parent.keyType != ReferenceStrength.HARD && key == ref;\n            r = r || parent.valueType != ReferenceStrength.HARD && value == ref;\n            if (r) {\n                if (parent.keyType != ReferenceStrength.HARD) {\n                    ((Reference<?>) key).clear();\n                }\n                if (parent.valueType != ReferenceStrength.HARD) {\n                    ((Reference<?>) value).clear();\n                } else if (parent.purgeValues) {\n                    nullValue();\n                }\n            }\n            return r;\n        }", "docstring": "\nPurges the specified reference\n@param ref  the reference to purge\n@return true or false\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "name": "purge", "params": [{"name": "ref", "type": "Reference<?>"}], "body": "                                                        {\n            boolean r = parent.keyType != ReferenceStrength.HARD && key == ref;\n            r = r || parent.valueType != ReferenceStrength.HARD && value == ref;\n            if (r) {\n                if (parent.keyType != ReferenceStrength.HARD) {\n                    ((Reference<?>) key).clear();\n                }\n                if (parent.valueType != ReferenceStrength.HARD) {\n                    ((Reference<?>) value).clear();\n                } else if (parent.purgeValues) {\n                    nullValue();\n                }\n            }\n            return r;\n        }", "signature": "protected boolean purge(final Reference<?> ref)"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V setValue(final V value) {\n            final V old = getValue();\n            if (parent.valueType != ReferenceStrength.HARD) {\n                ((Reference<V>) this.value).clear();\n            }\n            this.value = toReference(parent.valueType, value, hashCode);\n            return old;\n        }", "docstring": "\nSets the value of the entry.\n\n@param value  the object to store\n@return the previous value\n", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            final V old = getValue();\n            if (parent.valueType != ReferenceStrength.HARD) {\n                ((Reference<V>) this.value).clear();\n            }\n            this.value = toReference(parent.valueType, value, hashCode);\n            return old;\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public V setValue(final V value)"}, {"syntax_pass": true, "original_string": "        protected <T> Object toReference(final ReferenceStrength type, final T referent, final int hash) {\n            switch (type) {\n            case HARD:\n                return referent;\n            case SOFT:\n                return new SoftRef<>(hash, referent, parent.queue);\n            case WEAK:\n                return new WeakRef<>(hash, referent, parent.queue);\n            default:\n                break;\n            }\n            throw new Error();\n        }", "docstring": "\nConstructs a reference of the given type to the given referent.\nThe reference is registered with the queue for later purging.\n\n@param <T> the type of the referenced object\n@param type  HARD, SOFT or WEAK\n@param referent  the object to refer to\n@param hash  the hash code of the <em>key</em> of the mapping;\n   this number might be different from referent.hashCode() if\n   the referent represents a value and not a key\n@return the reference to the object\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Object", "classes": []}, "name": "toReference", "params": [{"name": "type", "type": "ReferenceStrength"}, {"name": "referent", "type": "T"}, {"name": "hash", "type": "int"}], "body": "                                                                                                         {\n            switch (type) {\n            case HARD:\n                return referent;\n            case SOFT:\n                return new SoftRef<>(hash, referent, parent.queue);\n            case WEAK:\n                return new WeakRef<>(hash, referent, parent.queue);\n            default:\n                break;\n            }\n            throw new Error();\n        }", "signature": "protected <T> Object toReference(final ReferenceStrength type, final T referent, final int hash)"}]}, {"original_string": "    static class ReferenceEntrySet<K, V> extends EntrySet<K, V> {\n\n        protected ReferenceEntrySet(final AbstractHashedMap<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public Object[] toArray() {\n            return toArray(new Object[size()]);\n        }\n\n        @Override\n        public <T> T[] toArray(final T[] arr) {\n            // special implementation to handle disappearing entries\n            final ArrayList<Map.Entry<K, V>> list = new ArrayList<>(size());\n            for (final Map.Entry<K, V> entry : this) {\n                list.add(new DefaultMapEntry<>(entry));\n            }\n            return list.toArray(arr);\n        }\n    }", "definition": "    static class ReferenceEntrySet<K, V> extends EntrySet<K, V>", "class_docstring": "\nEntrySet implementation.\n", "name": "ReferenceEntrySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected ReferenceEntrySet(final AbstractHashedMap<K, V> parent) {\n            super(parent);\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "ReferenceEntrySet", "params": [{"name": "parent", "type": "AbstractHashedMap<K, V>"}], "body": "                                                                          {\n            super(parent);\n        }", "signature": "protected ReferenceEntrySet(final AbstractHashedMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Object[] toArray() {\n            return toArray(new Object[size()]);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object[]", "classes": []}, "name": "toArray", "params": [], "body": "                                  {\n            return toArray(new Object[size()]);\n        }", "signature": "@Override\n        public Object[] toArray()"}, {"syntax_pass": true, "original_string": "        @Override\n        public <T> T[] toArray(final T[] arr) {\n            // special implementation to handle disappearing entries\n            final ArrayList<Map.Entry<K, V>> list = new ArrayList<>(size());\n            for (final Map.Entry<K, V> entry : this) {\n                list.add(new DefaultMapEntry<>(entry));\n            }\n            return list.toArray(arr);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T[]", "classes": []}, "name": "toArray", "params": [{"name": "arr", "type": "T[]"}], "body": "                                              {\n            // special implementation to handle disappearing entries\n            final ArrayList<Map.Entry<K, V>> list = new ArrayList<>(size());\n            for (final Map.Entry<K, V> entry : this) {\n                list.add(new DefaultMapEntry<>(entry));\n            }\n            return list.toArray(arr);\n        }", "signature": "@Override\n        public <T> T[] toArray(final T[] arr)"}]}, {"original_string": "    static class ReferenceEntrySetIterator<K, V>\n            extends ReferenceBaseIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n\n        ReferenceEntrySetIterator(final AbstractReferenceMap<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            return nextEntry();\n        }\n\n    }", "definition": "    static class ReferenceEntrySetIterator<K, V>\n            extends ReferenceBaseIterator<K, V> implements Iterator<Map.Entry<K, V>>", "class_docstring": "\nThe EntrySet iterator.\n", "name": "ReferenceEntrySetIterator", "super_interfaces": ["Iterator<Map.Entry<K, V>>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        ReferenceEntrySetIterator(final AbstractReferenceMap<K, V> parent) {\n            super(parent);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ReferenceEntrySetIterator", "params": [{"name": "parent", "type": "AbstractReferenceMap<K, V>"}], "body": "                                                                           {\n            super(parent);\n        }", "signature": "ReferenceEntrySetIterator(final AbstractReferenceMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<K, V> next() {\n            return nextEntry();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "next", "params": [], "body": "                                      {\n            return nextEntry();\n        }", "signature": "@Override\n        public Map.Entry<K, V> next()"}]}, {"original_string": "    static class ReferenceKeySet<K> extends KeySet<K> {\n\n        protected ReferenceKeySet(final AbstractHashedMap<K, ?> parent) {\n            super(parent);\n        }\n\n        @Override\n        public Object[] toArray() {\n            return toArray(new Object[size()]);\n        }\n\n        @Override\n        public <T> T[] toArray(final T[] arr) {\n            // special implementation to handle disappearing keys\n            final List<K> list = new ArrayList<>(size());\n            for (final K key : this) {\n                list.add(key);\n            }\n            return list.toArray(arr);\n        }\n    }", "definition": "    static class ReferenceKeySet<K> extends KeySet<K>", "class_docstring": "\nKeySet implementation.\n", "name": "ReferenceKeySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected ReferenceKeySet(final AbstractHashedMap<K, ?> parent) {\n            super(parent);\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "ReferenceKeySet", "params": [{"name": "parent", "type": "AbstractHashedMap<K, ?>"}], "body": "                                                                        {\n            super(parent);\n        }", "signature": "protected ReferenceKeySet(final AbstractHashedMap<K, ?> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Object[] toArray() {\n            return toArray(new Object[size()]);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object[]", "classes": []}, "name": "toArray", "params": [], "body": "                                  {\n            return toArray(new Object[size()]);\n        }", "signature": "@Override\n        public Object[] toArray()"}, {"syntax_pass": true, "original_string": "        @Override\n        public <T> T[] toArray(final T[] arr) {\n            // special implementation to handle disappearing keys\n            final List<K> list = new ArrayList<>(size());\n            for (final K key : this) {\n                list.add(key);\n            }\n            return list.toArray(arr);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T[]", "classes": []}, "name": "toArray", "params": [{"name": "arr", "type": "T[]"}], "body": "                                              {\n            // special implementation to handle disappearing keys\n            final List<K> list = new ArrayList<>(size());\n            for (final K key : this) {\n                list.add(key);\n            }\n            return list.toArray(arr);\n        }", "signature": "@Override\n        public <T> T[] toArray(final T[] arr)"}]}, {"original_string": "    static class ReferenceKeySetIterator<K> extends ReferenceBaseIterator<K, Object> implements Iterator<K> {\n\n        @SuppressWarnings(\"unchecked\")\n        ReferenceKeySetIterator(final AbstractReferenceMap<K, ?> parent) {\n            super((AbstractReferenceMap<K, Object>) parent);\n        }\n\n        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }\n    }", "definition": "    static class ReferenceKeySetIterator<K> extends ReferenceBaseIterator<K, Object> implements Iterator<K>", "class_docstring": "\nThe keySet iterator.\n", "name": "ReferenceKeySetIterator", "super_interfaces": ["Iterator<K>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        ReferenceKeySetIterator(final AbstractReferenceMap<K, ?> parent) {\n            super((AbstractReferenceMap<K, Object>) parent);\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")"], "comments": [], "return_type": "", "classes": []}, "name": "ReferenceKeySetIterator", "params": [{"name": "parent", "type": "AbstractReferenceMap<K, ?>"}], "body": "                                                                         {\n            super((AbstractReferenceMap<K, Object>) parent);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        ReferenceKeySetIterator(final AbstractReferenceMap<K, ?> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return nextEntry().getKey();\n        }", "signature": "@Override\n        public K next()"}]}, {"original_string": "    static class ReferenceMapIterator<K, V> extends ReferenceBaseIterator<K, V> implements MapIterator<K, V> {\n\n        protected ReferenceMapIterator(final AbstractReferenceMap<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public K getKey() {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETKEY_INVALID);\n            }\n            return current.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETVALUE_INVALID);\n            }\n            return current.getValue();\n        }\n\n        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }\n\n        @Override\n        public V setValue(final V value) {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(SETVALUE_INVALID);\n            }\n            return current.setValue(value);\n        }\n    }", "definition": "    static class ReferenceMapIterator<K, V> extends ReferenceBaseIterator<K, V> implements MapIterator<K, V>", "class_docstring": "\nThe MapIterator implementation.\n", "name": "ReferenceMapIterator", "super_interfaces": ["MapIterator<K, V>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected ReferenceMapIterator(final AbstractReferenceMap<K, V> parent) {\n            super(parent);\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "ReferenceMapIterator", "params": [{"name": "parent", "type": "AbstractReferenceMap<K, V>"}], "body": "                                                                                {\n            super(parent);\n        }", "signature": "protected ReferenceMapIterator(final AbstractReferenceMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETKEY_INVALID);\n            }\n            return current.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETKEY_INVALID);\n            }\n            return current.getKey();\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETVALUE_INVALID);\n            }\n            return current.getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETVALUE_INVALID);\n            }\n            return current.getValue();\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return nextEntry().getKey();\n        }", "signature": "@Override\n        public K next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(SETVALUE_INVALID);\n            }\n            return current.setValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(SETVALUE_INVALID);\n            }\n            return current.setValue(value);\n        }", "signature": "@Override\n        public V setValue(final V value)"}]}, {"original_string": "    static class ReferenceValues<V> extends Values<V> {\n\n        protected ReferenceValues(final AbstractHashedMap<?, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public Object[] toArray() {\n            return toArray(new Object[size()]);\n        }\n\n        @Override\n        public <T> T[] toArray(final T[] arr) {\n            // special implementation to handle disappearing values\n            final List<V> list = new ArrayList<>(size());\n            for (final V value : this) {\n                list.add(value);\n            }\n            return list.toArray(arr);\n        }\n    }", "definition": "    static class ReferenceValues<V> extends Values<V>", "class_docstring": "\nValues implementation.\n", "name": "ReferenceValues", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected ReferenceValues(final AbstractHashedMap<?, V> parent) {\n            super(parent);\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "ReferenceValues", "params": [{"name": "parent", "type": "AbstractHashedMap<?, V>"}], "body": "                                                                        {\n            super(parent);\n        }", "signature": "protected ReferenceValues(final AbstractHashedMap<?, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Object[] toArray() {\n            return toArray(new Object[size()]);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object[]", "classes": []}, "name": "toArray", "params": [], "body": "                                  {\n            return toArray(new Object[size()]);\n        }", "signature": "@Override\n        public Object[] toArray()"}, {"syntax_pass": true, "original_string": "        @Override\n        public <T> T[] toArray(final T[] arr) {\n            // special implementation to handle disappearing values\n            final List<V> list = new ArrayList<>(size());\n            for (final V value : this) {\n                list.add(value);\n            }\n            return list.toArray(arr);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T[]", "classes": []}, "name": "toArray", "params": [{"name": "arr", "type": "T[]"}], "body": "                                              {\n            // special implementation to handle disappearing values\n            final List<V> list = new ArrayList<>(size());\n            for (final V value : this) {\n                list.add(value);\n            }\n            return list.toArray(arr);\n        }", "signature": "@Override\n        public <T> T[] toArray(final T[] arr)"}]}, {"original_string": "    static class ReferenceValuesIterator<V> extends ReferenceBaseIterator<Object, V> implements Iterator<V> {\n\n        @SuppressWarnings(\"unchecked\")\n        ReferenceValuesIterator(final AbstractReferenceMap<?, V> parent) {\n            super((AbstractReferenceMap<Object, V>) parent);\n        }\n\n        @Override\n        public V next() {\n            return nextEntry().getValue();\n        }\n    }", "definition": "    static class ReferenceValuesIterator<V> extends ReferenceBaseIterator<Object, V> implements Iterator<V>", "class_docstring": "\nThe values iterator.\n", "name": "ReferenceValuesIterator", "super_interfaces": ["Iterator<V>"], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        ReferenceValuesIterator(final AbstractReferenceMap<?, V> parent) {\n            super((AbstractReferenceMap<Object, V>) parent);\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")"], "comments": [], "return_type": "", "classes": []}, "name": "ReferenceValuesIterator", "params": [{"name": "parent", "type": "AbstractReferenceMap<?, V>"}], "body": "                                                                         {\n            super((AbstractReferenceMap<Object, V>) parent);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        ReferenceValuesIterator(final AbstractReferenceMap<?, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V next() {\n            return nextEntry().getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return nextEntry().getValue();\n        }", "signature": "@Override\n        public V next()"}]}, {"original_string": "    static class SoftRef<T> extends SoftReference<T> {\n        /** The hashCode of the key (even if the reference points to a value) */\n        private final int hash;\n\n        SoftRef(final int hash, final T r, final ReferenceQueue<? super T> q) {\n            super(r, q);\n            this.hash = hash;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final SoftRef<?> other = (SoftRef<?>) obj;\n            return hash == other.hash;\n        }\n\n        @Override\n        public int hashCode() {\n            return hash;\n        }\n    }", "definition": "    static class SoftRef<T> extends SoftReference<T>", "class_docstring": "\nA soft reference holder.\n", "name": "SoftRef", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final int hash;", "docstring": " The hashCode of the key (even if the reference points to a value)", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "hash", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        SoftRef(final int hash, final T r, final ReferenceQueue<? super T> q) {\n            super(r, q);\n            this.hash = hash;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SoftRef", "params": [{"name": "hash", "type": "int"}, {"name": "r", "type": "T"}, {"name": "q", "type": "ReferenceQueue<? super T>"}], "body": "                                                                              {\n            super(r, q);\n            this.hash = hash;\n        }", "signature": "SoftRef(final int hash, final T r, final ReferenceQueue<? super T> q)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final SoftRef<?> other = (SoftRef<?>) obj;\n            return hash == other.hash;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final SoftRef<?> other = (SoftRef<?>) obj;\n            return hash == other.hash;\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return hash;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return hash;\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    static class WeakRef<T> extends WeakReference<T> {\n        /** The hashCode of the key (even if the reference points to a value) */\n        private final int hash;\n\n        WeakRef(final int hash, final T r, final ReferenceQueue<? super T> q) {\n            super(r, q);\n            this.hash = hash;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final WeakRef<?> other = (WeakRef<?>) obj;\n            return hash == other.hash;\n        }\n\n        @Override\n        public int hashCode() {\n            return hash;\n        }\n    }", "definition": "    static class WeakRef<T> extends WeakReference<T>", "class_docstring": "\nA weak reference holder.\n", "name": "WeakRef", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [{"attribute_expression": "private final int hash;", "docstring": " The hashCode of the key (even if the reference points to a value)", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "hash", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        WeakRef(final int hash, final T r, final ReferenceQueue<? super T> q) {\n            super(r, q);\n            this.hash = hash;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "WeakRef", "params": [{"name": "hash", "type": "int"}, {"name": "r", "type": "T"}, {"name": "q", "type": "ReferenceQueue<? super T>"}], "body": "                                                                              {\n            super(r, q);\n            this.hash = hash;\n        }", "signature": "WeakRef(final int hash, final T r, final ReferenceQueue<? super T> q)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final WeakRef<?> other = (WeakRef<?>) obj;\n            return hash == other.hash;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final WeakRef<?> other = (WeakRef<?>) obj;\n            return hash == other.hash;\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return hash;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return hash;\n        }", "signature": "@Override\n        public int hashCode()"}]}], "class_docstring": "\nAn abstract implementation of a hash-based map that allows the entries to\nbe removed by the garbage collector.\n<p>\nThis class implements all the features necessary for a subclass reference\nhash-based map. Key-value entries are stored in instances of the\n{@code ReferenceEntry} class which can be overridden and replaced.\nThe iterators can similarly be replaced, without the need to replace the KeySet,\nEntrySet and Values view classes.\n</p>\n<p>\nOverridable methods are provided to change the default hashing behavior, and\nto change how entries are added to and removed from the map. Hopefully, all you\nneed for unusual subclasses is here.\n</p>\n<p>\nWhen you construct an {@code AbstractReferenceMap}, you can specify what\nkind of references are used to store the map's keys and values.\nIf non-hard references are used, then the garbage collector can remove\nmappings if a key or value becomes unreachable, or if the JVM's memory is\nrunning low. For information on how the different reference types behave,\nsee {@link Reference}.\n</p>\n<p>\nDifferent types of references can be specified for keys and values.\nThe keys can be configured to be weak but the values hard,\nin which case this class will behave like a\n<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/WeakHashMap.html\">\n{@code WeakHashMap}</a>. However, you can also specify hard keys and\nweak values, or any other combination. The default constructor uses\nhard keys and soft values, providing a memory-sensitive cache.\n</p>\n<p>\nThis {@link Map} implementation does <em>not</em> allow null elements.\nAttempting to add a null key or value to the map will raise a\n{@code NullPointerException}.\n</p>\n<p>\nAll the available iterators can be reset back to the start by casting to\n{@code ResettableIterator} and calling {@code reset()}.\n</p>\n<p>\nThis implementation is not synchronized.\nYou can use {@link java.util.Collections#synchronizedMap} to\nprovide synchronized access to a {@code ReferenceMap}.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n\n@see java.lang.ref.Reference\n@since 3.1 (extracted from ReferenceMap in 3.0)\n", "original_string": "public abstract class AbstractReferenceMap<K, V> extends AbstractHashedMap<K, V> {\n\n    /**\n     * Base iterator class.\n     */\n    static class ReferenceBaseIterator<K, V> {\n        /** The parent map */\n        final AbstractReferenceMap<K, V> parent;\n\n        // These fields keep track of where we are in the table.\n        int index;\n        ReferenceEntry<K, V> next;\n        ReferenceEntry<K, V> current;\n\n        // These Object fields provide hard references to the\n        // current and next entry; this assures that if hasNext()\n        // returns true, next() will actually return a valid element.\n        K currentKey, nextKey;\n        V currentValue, nextValue;\n\n        int expectedModCount;\n\n        ReferenceBaseIterator(final AbstractReferenceMap<K, V> parent) {\n            this.parent = parent;\n            index = !parent.isEmpty() ? parent.data.length : 0;\n            // have to do this here!  size() invocation above\n            // may have altered the modCount.\n            expectedModCount = parent.modCount;\n        }\n\n        private void checkMod() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        protected ReferenceEntry<K, V> currentEntry() {\n            checkMod();\n            return current;\n        }\n\n        public boolean hasNext() {\n            checkMod();\n            while (nextNull()) {\n                ReferenceEntry<K, V> e = next;\n                int i = index;\n                while (e == null && i > 0) {\n                    i--;\n                    e = (ReferenceEntry<K, V>) parent.data[i];\n                }\n                next = e;\n                index = i;\n                if (e == null) {\n                    return false;\n                }\n                nextKey = e.getKey();\n                nextValue = e.getValue();\n                if (nextNull()) {\n                    next = next.next();\n                }\n            }\n            return true;\n        }\n\n        protected ReferenceEntry<K, V> nextEntry() {\n            checkMod();\n            if (nextNull() && !hasNext()) {\n                throw new NoSuchElementException();\n            }\n            current = next;\n            next = next.next();\n            currentKey = nextKey;\n            currentValue = nextValue;\n            nextKey = null;\n            nextValue = null;\n            return current;\n        }\n\n        private boolean nextNull() {\n            return nextKey == null || nextValue == null;\n        }\n\n        public void remove() {\n            checkMod();\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            parent.remove(currentKey);\n            current = null;\n            currentKey = null;\n            currentValue = null;\n            expectedModCount = parent.modCount;\n        }\n    }\n\n    /**\n     * A MapEntry implementation for the map.\n     * <p>\n     * If getKey() or getValue() returns null, it means\n     * the mapping is stale and should be removed.\n     * </p>\n     *\n     * @param <K> the type of the keys\n     * @param <V> the type of the values\n     * @since 3.1\n     */\n    protected static class ReferenceEntry<K, V> extends HashEntry<K, V> {\n        /** The parent map */\n        private final AbstractReferenceMap<K, V> parent;\n\n        /**\n         * Creates a new entry object for the ReferenceMap.\n         *\n         * @param parent  the parent map\n         * @param next  the next entry in the hash bucket\n         * @param hashCode  the hash code of the key\n         * @param key  the key\n         * @param value  the value\n         */\n        public ReferenceEntry(final AbstractReferenceMap<K, V> parent, final HashEntry<K, V> next,\n                              final int hashCode, final K key, final V value) {\n            super(next, hashCode, null, null);\n            this.parent = parent;\n            this.key = toReference(parent.keyType, key, hashCode);\n            this.value = toReference(parent.valueType, value, hashCode); // the key hashCode is passed in deliberately\n        }\n\n        /**\n         * Compares this map entry to another.\n         * <p>\n         * This implementation uses {@code isEqualKey} and\n         * {@code isEqualValue} on the main map for comparison.\n         *\n         * @param obj  the other map entry to compare to\n         * @return true if equal, false if not\n         */\n        @Override\n        public boolean equals(final Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object entryKey = entry.getKey();  // convert to hard reference\n            final Object entryValue = entry.getValue();  // convert to hard reference\n            if (entryKey == null || entryValue == null) {\n                return false;\n            }\n            // compare using map methods, aiding identity subclass\n            // note that key is direct access and value is via method\n            return parent.isEqualKey(entryKey, key) &&\n                   parent.isEqualValue(entryValue, getValue());\n        }\n\n        /**\n         * Gets the key from the entry.\n         * This method dereferences weak and soft keys and thus may return null.\n         *\n         * @return the key, which may be null if it was garbage collected\n         */\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public K getKey() {\n            return (K) (parent.keyType == ReferenceStrength.HARD ? key : ((Reference<K>) key).get());\n        }\n\n        /**\n         * Gets the value from the entry.\n         * This method dereferences weak and soft value and thus may return null.\n         *\n         * @return the value, which may be null if it was garbage collected\n         */\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V getValue() {\n            return (V) (parent.valueType == ReferenceStrength.HARD ? value : ((Reference<V>) value).get());\n        }\n\n        /**\n         * Gets the hash code of the entry using temporary hard references.\n         * <p>\n         * This implementation uses {@code hashEntry} on the main map.\n         *\n         * @return the hash code of the entry\n         */\n        @Override\n        public int hashCode() {\n            return parent.hashEntry(getKey(), getValue());\n        }\n\n        /**\n         * Gets the next entry in the bucket.\n         *\n         * @return the next entry in the bucket\n         */\n        protected ReferenceEntry<K, V> next() {\n            return (ReferenceEntry<K, V>) next;\n        }\n\n        /**\n         * This method can be overridden to provide custom logic to purge value\n         */\n        protected void nullValue() {\n            value = null;\n        }\n\n        /**\n         * This is the callback for custom \"after purge\" logic\n         */\n        protected void onPurge() {\n            // empty\n        }\n\n        /**\n         * Purges the specified reference\n         * @param ref  the reference to purge\n         * @return true or false\n         */\n        protected boolean purge(final Reference<?> ref) {\n            boolean r = parent.keyType != ReferenceStrength.HARD && key == ref;\n            r = r || parent.valueType != ReferenceStrength.HARD && value == ref;\n            if (r) {\n                if (parent.keyType != ReferenceStrength.HARD) {\n                    ((Reference<?>) key).clear();\n                }\n                if (parent.valueType != ReferenceStrength.HARD) {\n                    ((Reference<?>) value).clear();\n                } else if (parent.purgeValues) {\n                    nullValue();\n                }\n            }\n            return r;\n        }\n\n        /**\n         * Sets the value of the entry.\n         *\n         * @param value  the object to store\n         * @return the previous value\n         */\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V setValue(final V value) {\n            final V old = getValue();\n            if (parent.valueType != ReferenceStrength.HARD) {\n                ((Reference<V>) this.value).clear();\n            }\n            this.value = toReference(parent.valueType, value, hashCode);\n            return old;\n        }\n\n        /**\n         * Constructs a reference of the given type to the given referent.\n         * The reference is registered with the queue for later purging.\n         *\n         * @param <T> the type of the referenced object\n         * @param type  HARD, SOFT or WEAK\n         * @param referent  the object to refer to\n         * @param hash  the hash code of the <em>key</em> of the mapping;\n         *    this number might be different from referent.hashCode() if\n         *    the referent represents a value and not a key\n         * @return the reference to the object\n         */\n        protected <T> Object toReference(final ReferenceStrength type, final T referent, final int hash) {\n            switch (type) {\n            case HARD:\n                return referent;\n            case SOFT:\n                return new SoftRef<>(hash, referent, parent.queue);\n            case WEAK:\n                return new WeakRef<>(hash, referent, parent.queue);\n            default:\n                break;\n            }\n            throw new Error();\n        }\n    }\n\n    /**\n     * EntrySet implementation.\n     */\n    static class ReferenceEntrySet<K, V> extends EntrySet<K, V> {\n\n        protected ReferenceEntrySet(final AbstractHashedMap<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public Object[] toArray() {\n            return toArray(new Object[size()]);\n        }\n\n        @Override\n        public <T> T[] toArray(final T[] arr) {\n            // special implementation to handle disappearing entries\n            final ArrayList<Map.Entry<K, V>> list = new ArrayList<>(size());\n            for (final Map.Entry<K, V> entry : this) {\n                list.add(new DefaultMapEntry<>(entry));\n            }\n            return list.toArray(arr);\n        }\n    }\n\n    /**\n     * The EntrySet iterator.\n     */\n    static class ReferenceEntrySetIterator<K, V>\n            extends ReferenceBaseIterator<K, V> implements Iterator<Map.Entry<K, V>> {\n\n        ReferenceEntrySetIterator(final AbstractReferenceMap<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            return nextEntry();\n        }\n\n    }\n\n    /**\n     * KeySet implementation.\n     */\n    static class ReferenceKeySet<K> extends KeySet<K> {\n\n        protected ReferenceKeySet(final AbstractHashedMap<K, ?> parent) {\n            super(parent);\n        }\n\n        @Override\n        public Object[] toArray() {\n            return toArray(new Object[size()]);\n        }\n\n        @Override\n        public <T> T[] toArray(final T[] arr) {\n            // special implementation to handle disappearing keys\n            final List<K> list = new ArrayList<>(size());\n            for (final K key : this) {\n                list.add(key);\n            }\n            return list.toArray(arr);\n        }\n    }\n\n    /**\n     * The keySet iterator.\n     */\n    static class ReferenceKeySetIterator<K> extends ReferenceBaseIterator<K, Object> implements Iterator<K> {\n\n        @SuppressWarnings(\"unchecked\")\n        ReferenceKeySetIterator(final AbstractReferenceMap<K, ?> parent) {\n            super((AbstractReferenceMap<K, Object>) parent);\n        }\n\n        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }\n    }\n\n    /**\n     * The MapIterator implementation.\n     */\n    static class ReferenceMapIterator<K, V> extends ReferenceBaseIterator<K, V> implements MapIterator<K, V> {\n\n        protected ReferenceMapIterator(final AbstractReferenceMap<K, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public K getKey() {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETKEY_INVALID);\n            }\n            return current.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(GETVALUE_INVALID);\n            }\n            return current.getValue();\n        }\n\n        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }\n\n        @Override\n        public V setValue(final V value) {\n            final HashEntry<K, V> current = currentEntry();\n            if (current == null) {\n                throw new IllegalStateException(SETVALUE_INVALID);\n            }\n            return current.setValue(value);\n        }\n    }\n\n    /**\n     * Enumerates reference types.\n     */\n    public enum ReferenceStrength {\n\n        /**\n         * Hard reference type.\n         */\n        HARD(0),\n\n        /**\n         * Soft reference type.\n         */\n        SOFT(1),\n\n        /**\n         * Weak reference type.\n         */\n        WEAK(2);\n\n        /**\n         * Resolve enum from int.\n         * @param value  the int value\n         * @return ReferenceType\n         * @throws IllegalArgumentException if the specified value is invalid.\n         */\n        public static ReferenceStrength resolve(final int value) {\n            switch (value) {\n            case 0:\n                return HARD;\n            case 1:\n                return SOFT;\n            case 2:\n                return WEAK;\n            default:\n                throw new IllegalArgumentException();\n            }\n        }\n\n        /** Value */\n        public final int value;\n\n        ReferenceStrength(final int value) {\n            this.value = value;\n        }\n\n    }\n\n    /**\n     * Values implementation.\n     */\n    static class ReferenceValues<V> extends Values<V> {\n\n        protected ReferenceValues(final AbstractHashedMap<?, V> parent) {\n            super(parent);\n        }\n\n        @Override\n        public Object[] toArray() {\n            return toArray(new Object[size()]);\n        }\n\n        @Override\n        public <T> T[] toArray(final T[] arr) {\n            // special implementation to handle disappearing values\n            final List<V> list = new ArrayList<>(size());\n            for (final V value : this) {\n                list.add(value);\n            }\n            return list.toArray(arr);\n        }\n    }\n\n    /**\n     * The values iterator.\n     */\n    static class ReferenceValuesIterator<V> extends ReferenceBaseIterator<Object, V> implements Iterator<V> {\n\n        @SuppressWarnings(\"unchecked\")\n        ReferenceValuesIterator(final AbstractReferenceMap<?, V> parent) {\n            super((AbstractReferenceMap<Object, V>) parent);\n        }\n\n        @Override\n        public V next() {\n            return nextEntry().getValue();\n        }\n    }\n\n    /**\n     * A soft reference holder.\n     */\n    static class SoftRef<T> extends SoftReference<T> {\n        /** The hashCode of the key (even if the reference points to a value) */\n        private final int hash;\n\n        SoftRef(final int hash, final T r, final ReferenceQueue<? super T> q) {\n            super(r, q);\n            this.hash = hash;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final SoftRef<?> other = (SoftRef<?>) obj;\n            return hash == other.hash;\n        }\n\n        @Override\n        public int hashCode() {\n            return hash;\n        }\n    }\n\n    /**\n     * A weak reference holder.\n     */\n    static class WeakRef<T> extends WeakReference<T> {\n        /** The hashCode of the key (even if the reference points to a value) */\n        private final int hash;\n\n        WeakRef(final int hash, final T r, final ReferenceQueue<? super T> q) {\n            super(r, q);\n            this.hash = hash;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final WeakRef<?> other = (WeakRef<?>) obj;\n            return hash == other.hash;\n        }\n\n        @Override\n        public int hashCode() {\n            return hash;\n        }\n    }\n\n    /**\n     * The reference type for keys.\n     */\n    private ReferenceStrength keyType;\n\n    /**\n     * The reference type for values.\n     */\n    private ReferenceStrength valueType;\n\n    /**\n     * Should the value be automatically purged when the associated key has been collected?\n     */\n    private boolean purgeValues;\n\n    /**\n     * ReferenceQueue used to eliminate stale mappings.\n     * See purge.\n     */\n    private transient ReferenceQueue<Object> queue;\n\n    /**\n     * Constructor used during deserialization.\n     */\n    protected AbstractReferenceMap() {\n    }\n\n    /**\n     * Constructs a new empty map with the specified reference types,\n     * load factor and initial capacity.\n     *\n     * @param keyType  the type of reference to use for keys;\n     *   must be {@link ReferenceStrength#HARD HARD},\n     *   {@link ReferenceStrength#SOFT SOFT},\n     *   {@link ReferenceStrength#WEAK WEAK}\n     * @param valueType  the type of reference to use for values;\n     *   must be {@link ReferenceStrength#HARD},\n     *   {@link ReferenceStrength#SOFT SOFT},\n     *   {@link ReferenceStrength#WEAK WEAK}\n     * @param capacity  the initial capacity for the map\n     * @param loadFactor  the load factor for the map\n     * @param purgeValues  should the value be automatically purged when the\n     *   key is garbage collected\n     */\n    protected AbstractReferenceMap(\n            final ReferenceStrength keyType, final ReferenceStrength valueType, final int capacity,\n            final float loadFactor, final boolean purgeValues) {\n        super(capacity, loadFactor);\n        this.keyType = keyType;\n        this.valueType = valueType;\n        this.purgeValues = purgeValues;\n    }\n\n    /**\n     * Clears this map.\n     */\n    @Override\n    public void clear() {\n        super.clear();\n        // Drain the queue\n        while (queue.poll() != null) { // NOPMD\n        }\n    }\n\n    /**\n     * Checks whether the map contains the specified key.\n     *\n     * @param key  the key to search for\n     * @return true if the map contains the key\n     */\n    @Override\n    public boolean containsKey(final Object key) {\n        purgeBeforeRead();\n        final Entry<K, V> entry = getEntry(key);\n        if (entry == null) {\n            return false;\n        }\n        return entry.getValue() != null;\n    }\n\n    /**\n     * Checks whether the map contains the specified value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    @Override\n    public boolean containsValue(final Object value) {\n        purgeBeforeRead();\n        if (value == null) {\n            return false;\n        }\n        return super.containsValue(value);\n    }\n\n    /**\n     * Creates a ReferenceEntry instead of a HashEntry.\n     *\n     * @param next  the next entry in sequence\n     * @param hashCode  the hash code to use\n     * @param key  the key to store\n     * @param value  the value to store\n     * @return the newly created entry\n     */\n    @Override\n    protected ReferenceEntry<K, V> createEntry(final HashEntry<K, V> next, final int hashCode,\n                                               final K key, final V value) {\n        return new ReferenceEntry<>(this, next, hashCode, key, value);\n    }\n\n    /**\n     * Creates an entry set iterator.\n     *\n     * @return the entrySet iterator\n     */\n    @Override\n    protected Iterator<Map.Entry<K, V>> createEntrySetIterator() {\n        return new ReferenceEntrySetIterator<>(this);\n    }\n\n    /**\n     * Creates a key set iterator.\n     *\n     * @return the keySet iterator\n     */\n    @Override\n    protected Iterator<K> createKeySetIterator() {\n        return new ReferenceKeySetIterator<>(this);\n    }\n\n    /**\n     * Creates a values iterator.\n     *\n     * @return the values iterator\n     */\n    @Override\n    protected Iterator<V> createValuesIterator() {\n        return new ReferenceValuesIterator<>(this);\n    }\n\n    /**\n     * Replaces the superclass method to read the state of this class.\n     * <p>\n     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n     * initialize the superclass before the subclass. Sometimes however, this isn't\n     * what you want, as in this case the {@code put()} method on read can be\n     * affected by subclass state.\n     * <p>\n     * The solution adopted here is to deserialize the state data of this class in\n     * this protected method. This method must be called by the\n     * {@code readObject()} of the first serializable subclass.\n     * <p>\n     * Subclasses may override if the subclass has a specific field that must be present\n     * before {@code put()} or {@code calculateThreshold()} will work correctly.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected void doReadObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        keyType = ReferenceStrength.resolve(in.readInt());\n        valueType = ReferenceStrength.resolve(in.readInt());\n        purgeValues = in.readBoolean();\n        loadFactor = in.readFloat();\n        final int capacity = in.readInt();\n        init();\n        data = new HashEntry[capacity];\n\n        // COLLECTIONS-599: Calculate threshold before populating, otherwise it will be 0\n        // when it hits AbstractHashedMap.checkCapacity() and so will unnecessarily\n        // double up the size of the \"data\" array during population.\n        //\n        // NB: AbstractHashedMap.doReadObject() DOES calculate the threshold before populating.\n        //\n        threshold = calculateThreshold(data.length, loadFactor);\n\n        while (true) {\n            final K key = (K) in.readObject();\n            if (key == null) {\n                break;\n            }\n            final V value = (V) in.readObject();\n            put(key, value);\n        }\n        // do not call super.doReadObject() as code there doesn't work for reference map\n    }\n\n    /**\n     * Replaces the superclass method to store the state of this class.\n     * <p>\n     * Serialization is not one of the JDK's nicest topics. Normal serialization will\n     * initialize the superclass before the subclass. Sometimes however, this isn't\n     * what you want, as in this case the {@code put()} method on read can be\n     * affected by subclass state.\n     * <p>\n     * The solution adopted here is to serialize the state data of this class in\n     * this protected method. This method must be called by the\n     * {@code writeObject()} of the first serializable subclass.\n     * <p>\n     * Subclasses may override if they have a specific field that must be present\n     * on read before this implementation will work. Generally, the read determines\n     * what must be serialized here, if anything.\n     *\n     * @param out  the output stream\n     * @throws IOException if an error occurs while writing to the stream\n     */\n    @Override\n    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n        out.writeInt(keyType.value);\n        out.writeInt(valueType.value);\n        out.writeBoolean(purgeValues);\n        out.writeFloat(loadFactor);\n        out.writeInt(data.length);\n        for (final MapIterator<K, V> it = mapIterator(); it.hasNext();) {\n            out.writeObject(it.next());\n            out.writeObject(it.getValue());\n        }\n        out.writeObject(null);  // null terminate map\n        // do not call super.doWriteObject() as code there doesn't work for reference map\n    }\n\n    /**\n     * Returns a set view of this map's entries.\n     * An iterator returned entry is valid until {@code next()} is called again.\n     * The {@code setValue()} method on the {@code toArray} entries has no effect.\n     *\n     * @return a set view of this map's entries\n     */\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        if (entrySet == null) {\n            entrySet = new ReferenceEntrySet<>(this);\n        }\n        return entrySet;\n    }\n\n    /**\n     * Gets the value mapped to the key specified.\n     *\n     * @param key  the key\n     * @return the mapped value, null if no match\n     */\n    @Override\n    public V get(final Object key) {\n        purgeBeforeRead();\n        final Entry<K, V> entry = getEntry(key);\n        if (entry == null) {\n            return null;\n        }\n        return entry.getValue();\n    }\n\n    /**\n     * Gets the entry mapped to the key specified.\n     *\n     * @param key  the key\n     * @return the entry, null if no match\n     */\n    @Override\n    protected HashEntry<K, V> getEntry(final Object key) {\n        if (key == null) {\n            return null;\n        }\n        return super.getEntry(key);\n    }\n\n    /**\n     * Gets the hash code for a MapEntry.\n     * Subclasses can override this, for example to use the identityHashCode.\n     *\n     * @param key  the key to get a hash code for, may be null\n     * @param value  the value to get a hash code for, may be null\n     * @return the hash code, as per the MapEntry specification\n     */\n    protected int hashEntry(final Object key, final Object value) {\n        return (key == null ? 0 : key.hashCode()) ^\n               (value == null ? 0 : value.hashCode());\n    }\n\n    /**\n     * Initialize this subclass during construction, cloning or deserialization.\n     */\n    @Override\n    protected void init() {\n        queue = new ReferenceQueue<>();\n    }\n\n    /**\n     * Checks whether the map is currently empty.\n     *\n     * @return true if the map is currently size zero\n     */\n    @Override\n    public boolean isEmpty() {\n        purgeBeforeRead();\n        return super.isEmpty();\n    }\n\n    /**\n     * Compares two keys, in internal converted form, to see if they are equal.\n     * <p>\n     * This implementation converts the key from the entry to a real reference\n     * before comparison.\n     *\n     * @param key1  the first key to compare passed in from outside\n     * @param key2  the second key extracted from the entry via {@code entry.key}\n     * @return true if equal\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected boolean isEqualKey(final Object key1, Object key2) {\n        key2 = keyType == ReferenceStrength.HARD ? key2 : ((Reference<K>) key2).get();\n        return key1 == key2 || key1.equals(key2);\n    }\n\n    /**\n     * Provided protected read-only access to the key type.\n     * @param type the type to check against.\n     * @return true if keyType has the specified type\n     */\n    protected boolean isKeyType(final ReferenceStrength type) {\n        return keyType == type;\n    }\n\n    /**\n     * Provided protected read-only access to the value type.\n     * @param type the type to check against.\n     * @return true if valueType has the specified type\n     */\n    protected boolean isValueType(final ReferenceStrength type) {\n        return valueType == type;\n    }\n\n    /**\n     * Returns a set view of this map's keys.\n     *\n     * @return a set view of this map's keys\n     */\n    @Override\n    public Set<K> keySet() {\n        if (keySet == null) {\n            keySet = new ReferenceKeySet<>(this);\n        }\n        return keySet;\n    }\n\n    /**\n     * Gets a MapIterator over the reference map.\n     * The iterator only returns valid key/value pairs.\n     *\n     * @return a map iterator\n     */\n    @Override\n    public MapIterator<K, V> mapIterator() {\n        return new ReferenceMapIterator<>(this);\n    }\n\n    /**\n     * Purges stale mappings from this map.\n     * <p>\n     * Note that this method is not synchronized!  Special\n     * care must be taken if, for instance, you want stale\n     * mappings to be removed on a periodic basis by some\n     * background thread.\n     */\n    protected void purge() {\n        Reference<?> ref = queue.poll();\n        while (ref != null) {\n            purge(ref);\n            ref = queue.poll();\n        }\n    }\n\n    /**\n     * Purges the specified reference.\n     *\n     * @param ref  the reference to purge\n     */\n    protected void purge(final Reference<?> ref) {\n        // The hashCode of the reference is the hashCode of the\n        // mapping key, even if the reference refers to the\n        // mapping value...\n        final int hash = ref.hashCode();\n        final int index = hashIndex(hash, data.length);\n        HashEntry<K, V> previous = null;\n        HashEntry<K, V> entry = data[index];\n        while (entry != null) {\n            final ReferenceEntry<K, V> refEntry = (ReferenceEntry<K, V>) entry;\n            if (refEntry.purge(ref)) {\n                if (previous == null) {\n                    data[index] = entry.next;\n                } else {\n                    previous.next = entry.next;\n                }\n                size--;\n                refEntry.onPurge();\n                return;\n            }\n            previous = entry;\n            entry = entry.next;\n        }\n\n    }\n\n    // These two classes store the hashCode of the key of\n    // the mapping, so that after they're dequeued a quick\n    // lookup of the bucket in the table can occur.\n\n    /**\n     * Purges stale mappings from this map before read operations.\n     * <p>\n     * This implementation calls {@link #purge()} to maintain a consistent state.\n     */\n    protected void purgeBeforeRead() {\n        purge();\n    }\n\n    /**\n     * Purges stale mappings from this map before write operations.\n     * <p>\n     * This implementation calls {@link #purge()} to maintain a consistent state.\n     */\n    protected void purgeBeforeWrite() {\n        purge();\n    }\n\n    /**\n     * Puts a key-value mapping into this map.\n     * Neither the key nor the value may be null.\n     *\n     * @param key  the key to add, must not be null\n     * @param value  the value to add, must not be null\n     * @return the value previously mapped to this key, null if none\n     * @throws NullPointerException if either the key or value is null\n     */\n    @Override\n    public V put(final K key, final V value) {\n        Objects.requireNonNull(key, \"key\");\n        Objects.requireNonNull(value, \"value\");\n        purgeBeforeWrite();\n        return super.put(key, value);\n    }\n\n    /**\n     * Removes the specified mapping from this map.\n     *\n     * @param key  the mapping to remove\n     * @return the value mapped to the removed key, null if key not in map\n     */\n    @Override\n    public V remove(final Object key) {\n        if (key == null) {\n            return null;\n        }\n        purgeBeforeWrite();\n        return super.remove(key);\n    }\n\n    /**\n     * Gets the size of the map.\n     *\n     * @return the size\n     */\n    @Override\n    public int size() {\n        purgeBeforeRead();\n        return super.size();\n    }\n\n    /**\n     * Returns a collection view of this map's values.\n     *\n     * @return a set view of this map's values\n     */\n    @Override\n    public Collection<V> values() {\n        if (values == null) {\n            values = new ReferenceValues<>(this);\n        }\n        return values;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ReferenceStrength keyType;", "docstring": "\nThe reference type for keys.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ReferenceStrength", "name": "keyType", "syntax_pass": true}, {"attribute_expression": "private ReferenceStrength valueType;", "docstring": "\nThe reference type for values.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ReferenceStrength", "name": "valueType", "syntax_pass": true}, {"attribute_expression": "private boolean purgeValues;", "docstring": "\nShould the value be automatically purged when the associated key has been collected?\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "purgeValues", "syntax_pass": true}, {"attribute_expression": "private transient ReferenceQueue<Object> queue;", "docstring": "\nReferenceQueue used to eliminate stale mappings.\nSee purge.\n", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "ReferenceQueue<Object>", "name": "queue", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/map/AbstractIterableMap.java.AbstractIterableMap", "name": "AbstractIterableMap", "file_path": "src/main/java/org/apache/commons/collections4/map/AbstractIterableMap.java", "superclasses": "", "methods": ["[MapIterator<K, V>]mapIterator()"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/AbstractIterableMap.java.AbstractIterableMap.[MapIterator<K, V>]mapIterator()"], "overrides": null, "attributes": [], "class_docstring": "\nProvide a basic {@link IterableMap} implementation.\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.0\n", "original_string": "public abstract class AbstractIterableMap<K, V> implements IterableMap<K, V> {\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MapIterator<K, V> mapIterator() {\n        return new EntrySetToMapIteratorAdapter<>(entrySet());\n    }\n}", "super_interfaces": ["IterableMap<K, V>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java.AbstractOrderedMapDecorator", "name": "AbstractOrderedMapDecorator", "file_path": "src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java", "superclasses": "", "methods": ["[]AbstractOrderedMapDecorator()", "[]AbstractOrderedMapDecorator(OrderedMap<K, V>)", "[OrderedMap<K, V>]decorated()", "[K]firstKey()", "[K]lastKey()", "[OrderedMapIterator<K, V>]mapIterator()", "[K]nextKey(K)", "[K]previousKey(K)"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java.AbstractOrderedMapDecorator.[]AbstractOrderedMapDecorator()", "src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java.AbstractOrderedMapDecorator.[]AbstractOrderedMapDecorator(OrderedMap<K, V>)", "src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java.AbstractOrderedMapDecorator.[OrderedMap<K, V>]decorated()", "src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java.AbstractOrderedMapDecorator.[K]firstKey()", "src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java.AbstractOrderedMapDecorator.[K]lastKey()", "src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java.AbstractOrderedMapDecorator.[OrderedMapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java.AbstractOrderedMapDecorator.[K]nextKey(K)", "src/main/java/org/apache/commons/collections4/map/AbstractOrderedMapDecorator.java.AbstractOrderedMapDecorator.[K]previousKey(K)"], "overrides": null, "attributes": [], "class_docstring": "\nProvides a base decorator that enables additional functionality to be added\nto an OrderedMap via decoration.\n<p>\nMethods are forwarded directly to the decorated map.\n</p>\n<p>\nThis implementation does not perform any special processing with the map views.\nInstead it simply returns the set/collection from the wrapped map. This may be\nundesirable, for example if you are trying to write a validating implementation\nit would provide a loophole around the validation.\nBut, you might want that loophole, so this class is kept simple.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public abstract class AbstractOrderedMapDecorator<K, V> extends AbstractMapDecorator<K, V>\n        implements OrderedMap<K, V> {\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     * @since 3.1\n     */\n    protected AbstractOrderedMapDecorator() {\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if the map is null\n     */\n    public AbstractOrderedMapDecorator(final OrderedMap<K, V> map) {\n        super(map);\n    }\n\n    /**\n     * Gets the map being decorated.\n     *\n     * @return the decorated map\n     */\n    @Override\n    protected OrderedMap<K, V> decorated() {\n        return (OrderedMap<K, V>) super.decorated();\n    }\n\n    @Override\n    public K firstKey() {\n        return decorated().firstKey();\n    }\n\n    @Override\n    public K lastKey() {\n        return decorated().lastKey();\n    }\n\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        return decorated().mapIterator();\n    }\n\n    @Override\n    public K nextKey(final K key) {\n        return decorated().nextKey(key);\n    }\n\n    @Override\n    public K previousKey(final K key) {\n        return decorated().previousKey(key);\n    }\n\n}", "super_interfaces": ["OrderedMap<K, V>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java.AbstractInputCheckedMapDecorator", "name": "AbstractInputCheckedMapDecorator", "file_path": "src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java", "superclasses": "", "methods": ["[]AbstractInputCheckedMapDecorator()", "[]AbstractInputCheckedMapDecorator(Map<K, V>)", "[V]checkSetValue(V)", "[Set<Map.Entry<K, V>>]entrySet()", "[boolean]isSetValueChecking()"], "method_uris": ["src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java.AbstractInputCheckedMapDecorator.[]AbstractInputCheckedMapDecorator()", "src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java.AbstractInputCheckedMapDecorator.[]AbstractInputCheckedMapDecorator(Map<K, V>)", "src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java.AbstractInputCheckedMapDecorator.[V]checkSetValue(V)", "src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java.AbstractInputCheckedMapDecorator.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/map/AbstractInputCheckedMapDecorator.java.AbstractInputCheckedMapDecorator.[boolean]isSetValueChecking()"], "overrides": null, "attributes": [{"original_string": "    private final class EntrySet extends AbstractSetDecorator<Map.Entry<K, V>> {\n\n        /** Generated serial version ID. */\n        private static final long serialVersionUID = 4354731610923110264L;\n\n        /** The parent map */\n        private final AbstractInputCheckedMapDecorator<K, V> parent;\n\n        protected EntrySet(final Set<Map.Entry<K, V>> set, final AbstractInputCheckedMapDecorator<K, V> parent) {\n            super(set);\n            this.parent = parent;\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new EntrySetIterator(decorated().iterator(), parent);\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public Object[] toArray() {\n            final Object[] array = decorated().toArray();\n            for (int i = 0; i < array.length; i++) {\n                array[i] = new MapEntry((Map.Entry<K, V>) array[i], parent);\n            }\n            return array;\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T[] toArray(final T[] array) {\n            Object[] result = array;\n            if (array.length > 0) {\n                // we must create a new array to handle multithreaded situations\n                // where another thread could access data before we decorate it\n                result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n            }\n            result = decorated().toArray(result);\n            for (int i = 0; i < result.length; i++) {\n                result[i] = new MapEntry((Map.Entry<K, V>) result[i], parent);\n            }\n\n            // check to see if result should be returned straight\n            if (result.length > array.length) {\n                return (T[]) result;\n            }\n\n            // copy back into input array to fulfil the method contract\n            System.arraycopy(result, 0, array, 0, result.length);\n            if (array.length > result.length) {\n                array[result.length] = null;\n            }\n            return array;\n        }\n    }", "definition": "    private final class EntrySet extends AbstractSetDecorator<Map.Entry<K, V>>", "class_docstring": "\nImplements an entry set that checks additions via setValue.\n", "name": "EntrySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 4354731610923110264L;", "docstring": " Generated serial version ID.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 4354731610923110264L", "syntax_pass": true}, {"attribute_expression": "private final AbstractInputCheckedMapDecorator<K, V> parent;", "docstring": " The parent map", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractInputCheckedMapDecorator<K, V>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected EntrySet(final Set<Map.Entry<K, V>> set, final AbstractInputCheckedMapDecorator<K, V> parent) {\n            super(set);\n            this.parent = parent;\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "EntrySet", "params": [{"name": "set", "type": "Set<Map.Entry<K, V>>"}, {"name": "parent", "type": "AbstractInputCheckedMapDecorator<K, V>"}], "body": "                                                                                                                {\n            super(set);\n            this.parent = parent;\n        }", "signature": "protected EntrySet(final Set<Map.Entry<K, V>> set, final AbstractInputCheckedMapDecorator<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new EntrySetIterator(decorated().iterator(), parent);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Map.Entry<K, V>>", "classes": []}, "name": "iterator", "params": [], "body": "                                                    {\n            return new EntrySetIterator(decorated().iterator(), parent);\n        }", "signature": "@Override\n        public Iterator<Map.Entry<K, V>> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public Object[] toArray() {\n            final Object[] array = decorated().toArray();\n            for (int i = 0; i < array.length; i++) {\n                array[i] = new MapEntry((Map.Entry<K, V>) array[i], parent);\n            }\n            return array;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "Object[]", "classes": []}, "name": "toArray", "params": [], "body": "                                  {\n            final Object[] array = decorated().toArray();\n            for (int i = 0; i < array.length; i++) {\n                array[i] = new MapEntry((Map.Entry<K, V>) array[i], parent);\n            }\n            return array;\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public Object[] toArray()"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T[] toArray(final T[] array) {\n            Object[] result = array;\n            if (array.length > 0) {\n                // we must create a new array to handle multithreaded situations\n                // where another thread could access data before we decorate it\n                result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n            }\n            result = decorated().toArray(result);\n            for (int i = 0; i < result.length; i++) {\n                result[i] = new MapEntry((Map.Entry<K, V>) result[i], parent);\n            }\n\n            // check to see if result should be returned straight\n            if (result.length > array.length) {\n                return (T[]) result;\n            }\n\n            // copy back into input array to fulfil the method contract\n            System.arraycopy(result, 0, array, 0, result.length);\n            if (array.length > result.length) {\n                array[result.length] = null;\n            }\n            return array;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "T[]", "classes": []}, "name": "toArray", "params": [{"name": "array", "type": "T[]"}], "body": "                                                {\n            Object[] result = array;\n            if (array.length > 0) {\n                // we must create a new array to handle multithreaded situations\n                // where another thread could access data before we decorate it\n                result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n            }\n            result = decorated().toArray(result);\n            for (int i = 0; i < result.length; i++) {\n                result[i] = new MapEntry((Map.Entry<K, V>) result[i], parent);\n            }\n\n            // check to see if result should be returned straight\n            if (result.length > array.length) {\n                return (T[]) result;\n            }\n\n            // copy back into input array to fulfil the method contract\n            System.arraycopy(result, 0, array, 0, result.length);\n            if (array.length > result.length) {\n                array[result.length] = null;\n            }\n            return array;\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T[] toArray(final T[] array)"}]}, {"original_string": "    private final class EntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n\n        /** The parent map */\n        private final AbstractInputCheckedMapDecorator<K, V> parent;\n\n        protected EntrySetIterator(final Iterator<Map.Entry<K, V>> iterator,\n                                   final AbstractInputCheckedMapDecorator<K, V> parent) {\n            super(iterator);\n            this.parent = parent;\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            final Map.Entry<K, V> entry = getIterator().next();\n            return new MapEntry(entry, parent);\n        }\n    }", "definition": "    private final class EntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, V>>", "class_docstring": "\nImplements an entry set iterator that checks additions via setValue.\n", "name": "EntrySetIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private final AbstractInputCheckedMapDecorator<K, V> parent;", "docstring": " The parent map", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractInputCheckedMapDecorator<K, V>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected EntrySetIterator(final Iterator<Map.Entry<K, V>> iterator,\n                                   final AbstractInputCheckedMapDecorator<K, V> parent) {\n            super(iterator);\n            this.parent = parent;\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "EntrySetIterator", "params": [{"name": "iterator", "type": "Iterator<Map.Entry<K, V>>"}, {"name": "parent", "type": "AbstractInputCheckedMapDecorator<K, V>"}], "body": "                                                                                        {\n            super(iterator);\n            this.parent = parent;\n        }", "signature": "protected EntrySetIterator(final Iterator<Map.Entry<K, V>> iterator,\n                                   final AbstractInputCheckedMapDecorator<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<K, V> next() {\n            final Map.Entry<K, V> entry = getIterator().next();\n            return new MapEntry(entry, parent);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "next", "params": [], "body": "                                      {\n            final Map.Entry<K, V> entry = getIterator().next();\n            return new MapEntry(entry, parent);\n        }", "signature": "@Override\n        public Map.Entry<K, V> next()"}]}, {"original_string": "    private final class MapEntry extends AbstractMapEntryDecorator<K, V> {\n\n        /** The parent map */\n        private final AbstractInputCheckedMapDecorator<K, V> parent;\n\n        protected MapEntry(final Map.Entry<K, V> entry, final AbstractInputCheckedMapDecorator<K, V> parent) {\n            super(entry);\n            this.parent = parent;\n        }\n\n        @Override\n        public V setValue(V value) {\n            value = parent.checkSetValue(value);\n            return getMapEntry().setValue(value);\n        }\n    }", "definition": "    private final class MapEntry extends AbstractMapEntryDecorator<K, V>", "class_docstring": "\nImplements a map entry that checks additions via setValue.\n", "name": "MapEntry", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private final AbstractInputCheckedMapDecorator<K, V> parent;", "docstring": " The parent map", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractInputCheckedMapDecorator<K, V>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected MapEntry(final Map.Entry<K, V> entry, final AbstractInputCheckedMapDecorator<K, V> parent) {\n            super(entry);\n            this.parent = parent;\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "MapEntry", "params": [{"name": "entry", "type": "Map.Entry<K, V>"}, {"name": "parent", "type": "AbstractInputCheckedMapDecorator<K, V>"}], "body": "                                                                                                             {\n            super(entry);\n            this.parent = parent;\n        }", "signature": "protected MapEntry(final Map.Entry<K, V> entry, final AbstractInputCheckedMapDecorator<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(V value) {\n            value = parent.checkSetValue(value);\n            return getMapEntry().setValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                   {\n            value = parent.checkSetValue(value);\n            return getMapEntry().setValue(value);\n        }", "signature": "@Override\n        public V setValue(V value)"}]}], "class_docstring": "\nAn abstract base class that simplifies the task of creating map decorators.\n<p>\nThe Map API is very difficult to decorate correctly, and involves implementing\nlots of different classes. This class exists to provide a simpler API.\n</p>\n<p>\nSpecial hook methods are provided that are called when objects are added to\nthe map. By overriding these methods, the input can be validated or manipulated.\nIn addition to the main map methods, the entrySet is also affected, which is\nthe hardest part of writing map implementations.\n</p>\n<p>\nThis class is package-scoped, and may be withdrawn or replaced in future\nversions of Commons Collections.\n</p>\n\n@since 3.1\n", "original_string": "abstract class AbstractInputCheckedMapDecorator<K, V>\n        extends AbstractMapDecorator<K, V> {\n\n    /**\n     * Implements an entry set that checks additions via setValue.\n     */\n    private final class EntrySet extends AbstractSetDecorator<Map.Entry<K, V>> {\n\n        /** Generated serial version ID. */\n        private static final long serialVersionUID = 4354731610923110264L;\n\n        /** The parent map */\n        private final AbstractInputCheckedMapDecorator<K, V> parent;\n\n        protected EntrySet(final Set<Map.Entry<K, V>> set, final AbstractInputCheckedMapDecorator<K, V> parent) {\n            super(set);\n            this.parent = parent;\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new EntrySetIterator(decorated().iterator(), parent);\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public Object[] toArray() {\n            final Object[] array = decorated().toArray();\n            for (int i = 0; i < array.length; i++) {\n                array[i] = new MapEntry((Map.Entry<K, V>) array[i], parent);\n            }\n            return array;\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T[] toArray(final T[] array) {\n            Object[] result = array;\n            if (array.length > 0) {\n                // we must create a new array to handle multithreaded situations\n                // where another thread could access data before we decorate it\n                result = (Object[]) Array.newInstance(array.getClass().getComponentType(), 0);\n            }\n            result = decorated().toArray(result);\n            for (int i = 0; i < result.length; i++) {\n                result[i] = new MapEntry((Map.Entry<K, V>) result[i], parent);\n            }\n\n            // check to see if result should be returned straight\n            if (result.length > array.length) {\n                return (T[]) result;\n            }\n\n            // copy back into input array to fulfil the method contract\n            System.arraycopy(result, 0, array, 0, result.length);\n            if (array.length > result.length) {\n                array[result.length] = null;\n            }\n            return array;\n        }\n    }\n\n    /**\n     * Implements an entry set iterator that checks additions via setValue.\n     */\n    private final class EntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n\n        /** The parent map */\n        private final AbstractInputCheckedMapDecorator<K, V> parent;\n\n        protected EntrySetIterator(final Iterator<Map.Entry<K, V>> iterator,\n                                   final AbstractInputCheckedMapDecorator<K, V> parent) {\n            super(iterator);\n            this.parent = parent;\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            final Map.Entry<K, V> entry = getIterator().next();\n            return new MapEntry(entry, parent);\n        }\n    }\n\n    /**\n     * Implements a map entry that checks additions via setValue.\n     */\n    private final class MapEntry extends AbstractMapEntryDecorator<K, V> {\n\n        /** The parent map */\n        private final AbstractInputCheckedMapDecorator<K, V> parent;\n\n        protected MapEntry(final Map.Entry<K, V> entry, final AbstractInputCheckedMapDecorator<K, V> parent) {\n            super(entry);\n            this.parent = parent;\n        }\n\n        @Override\n        public V setValue(V value) {\n            value = parent.checkSetValue(value);\n            return getMapEntry().setValue(value);\n        }\n    }\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     */\n    protected AbstractInputCheckedMapDecorator() {\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if map is null\n     */\n    protected AbstractInputCheckedMapDecorator(final Map<K, V> map) {\n        super(map);\n    }\n\n    /**\n     * Hook method called when a value is being set using {@code setValue}.\n     * <p>\n     * An implementation may validate the value and throw an exception\n     * or it may transform the value into another object.\n     * </p>\n     * <p>\n     * This implementation returns the input value.\n     * </p>\n     *\n     * @param value  the value to check\n     * @return the input value\n     * @throws UnsupportedOperationException if the map may not be changed by setValue\n     * @throws IllegalArgumentException if the specified value is invalid\n     * @throws ClassCastException if the class of the specified value is invalid\n     * @throws NullPointerException if the specified value is null and nulls are invalid\n     */\n    protected abstract V checkSetValue(V value);\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        if (isSetValueChecking()) {\n            return new EntrySet(map.entrySet(), this);\n        }\n        return map.entrySet();\n    }\n\n    /**\n     * Hook method called to determine if {@code checkSetValue} has any effect.\n     * <p>\n     * An implementation should return false if the {@code checkSetValue} method\n     * has no effect as this optimizes the implementation.\n     * <p>\n     * This implementation returns {@code true}.\n     *\n     * @return true always\n     */\n    protected boolean isSetValueChecking() {\n        return true;\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/sequence/EditCommand.java.EditCommand", "name": "EditCommand", "file_path": "src/main/java/org/apache/commons/collections4/sequence/EditCommand.java", "superclasses": "", "methods": ["[]EditCommand(T)", "[void]accept(CommandVisitor<T>)", "[T]getObject()"], "method_uris": ["src/main/java/org/apache/commons/collections4/sequence/EditCommand.java.EditCommand.[]EditCommand(T)", "src/main/java/org/apache/commons/collections4/sequence/EditCommand.java.EditCommand.[void]accept(CommandVisitor<T>)", "src/main/java/org/apache/commons/collections4/sequence/EditCommand.java.EditCommand.[T]getObject()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract base class for all commands used to transform an objects sequence\ninto another one.\n<p>\nWhen two objects sequences are compared through the\n{@link SequencesComparator#getScript SequencesComparator.getScript} method,\nthe result is provided has a {@link EditScript script} containing the commands\nthat progressively transform the first sequence into the second one.\n</p>\n<p>\nThere are only three types of commands, all of which are subclasses of this\nabstract class. Each command is associated with one object belonging to at\nleast one of the sequences. These commands are {@link InsertCommand\nInsertCommand} which correspond to an object of the second sequence being\ninserted into the first sequence, {@link DeleteCommand DeleteCommand} which\ncorrespond to an object of the first sequence being removed and\n{@link KeepCommand KeepCommand} which correspond to an object of the first\nsequence which {@code equals} an object in the second sequence. It is\nguaranteed that comparison is always performed this way (i.e. the\n{@code equals} method of the object from the first sequence is used and\nthe object passed as an argument comes from the second sequence) ; this can\nbe important if subclassing is used for some elements in the first sequence\nand the {@code equals} method is specialized.\n</p>\n\n@param <T> the type of object to apply this command.\n@see SequencesComparator\n@see EditScript\n@since 4.0\n", "original_string": "public abstract class EditCommand<T> {\n\n    /** Object on which the command should be applied. */\n    private final T object;\n\n    /**\n     * Simple constructor. Creates a new instance of EditCommand\n     *\n     * @param object  reference to the object associated with this command, this\n     *   refers to an element of one of the sequences being compared\n     */\n    protected EditCommand(final T object) {\n        this.object = object;\n    }\n\n    /**\n     * Accept a visitor.\n     * <p>\n     * This method is invoked for each command belonging to\n     * an {@link EditScript EditScript}, in order to implement the visitor design pattern\n     *\n     * @param visitor  the visitor to be accepted\n     */\n    public abstract void accept(CommandVisitor<T> visitor);\n\n    /**\n     * Returns the object associated with this command.\n     *\n     * @return the object on which the command is applied\n     */\n    protected T getObject() {\n        return object;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final T object;", "docstring": " Object on which the command should be applied.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "T", "name": "object", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/functors/CatchAndRethrowClosure.java.CatchAndRethrowClosure", "name": "CatchAndRethrowClosure", "file_path": "src/main/java/org/apache/commons/collections4/functors/CatchAndRethrowClosure.java", "superclasses": "", "methods": ["[void]execute(T)", "[void]executeAndThrow(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/CatchAndRethrowClosure.java.CatchAndRethrowClosure.[void]execute(T)", "src/main/java/org/apache/commons/collections4/functors/CatchAndRethrowClosure.java.CatchAndRethrowClosure.[void]executeAndThrow(T)"], "overrides": null, "attributes": [], "class_docstring": "\n{@link Closure} that catches any checked exception and re-throws it as a\n{@link FunctorException} runtime exception. Example usage:\n\n<pre>\n// Create a catch and re-throw closure via anonymous subclass\nCatchAndRethrowClosure&lt;String&gt; writer = new ThrowingClosure() {\n    private java.io.Writer out = // some writer\n\n    protected void executeAndThrow(String input) throws IOException {\n        out.write(input); // throwing of IOException allowed\n    }\n};\n\n// use catch and re-throw closure\njava.util.List&lt;String&gt; strList = // some list\ntry {\n    CollectionUtils.forAllDo(strList, writer);\n} catch (FunctorException ex) {\n    Throwable originalError = ex.getCause();\n    // handle error\n}\n</pre>\n\n@param <T> the type of the input to the operation.\n@since 4.0\n", "original_string": "public abstract class CatchAndRethrowClosure<T> implements Closure<T> {\n\n    /**\n     * Execute this closure on the specified input object.\n     *\n     * @param input the input to execute on\n     * @throws FunctorException (runtime) if the closure execution resulted in a\n     *             checked exception.\n     */\n    @Override\n    public void execute(final T input) {\n        try {\n            executeAndThrow(input);\n        } catch (final RuntimeException ex) {\n            throw ex;\n        } catch (final Throwable t) {\n            throw new FunctorException(t);\n        }\n    }\n\n    /**\n     * Execute this closure on the specified input object.\n     *\n     * @param input the input to execute on\n     * @throws Throwable if the closure execution resulted in a checked\n     *             exception.\n     */\n    protected abstract void executeAndThrow(T input) throws Throwable;\n}", "super_interfaces": ["Closure<T>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/functors/AbstractPredicate.java.AbstractPredicate", "name": "AbstractPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/AbstractPredicate.java", "superclasses": "", "methods": ["[boolean]evaluate(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/AbstractPredicate.java.AbstractPredicate.[boolean]evaluate(T)"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract base class for predicates.\n\n@param <T> the type of the input to the predicate.\n@since 4.5.0\n", "original_string": "public abstract class AbstractPredicate<T> implements Predicate<T> {\n\n    @Override\n    public boolean evaluate(final T object) {\n        return test(object);\n    }\n}", "super_interfaces": ["Predicate<T>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/functors/AbstractQuantifierPredicate.java.AbstractQuantifierPredicate", "name": "AbstractQuantifierPredicate", "file_path": "src/main/java/org/apache/commons/collections4/functors/AbstractQuantifierPredicate.java", "superclasses": "", "methods": ["[]AbstractQuantifierPredicate()", "[Predicate<? super T>[]]getPredicates()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/AbstractQuantifierPredicate.java.AbstractQuantifierPredicate.[]AbstractQuantifierPredicate()", "src/main/java/org/apache/commons/collections4/functors/AbstractQuantifierPredicate.java.AbstractQuantifierPredicate.[Predicate<? super T>[]]getPredicates()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract base class for quantification predicates, e.g. All, Any, None.\n\n@param <T> the type of the input to the predicate.\n@since 4.0\n", "original_string": "public abstract class AbstractQuantifierPredicate<T> extends AbstractPredicate<T> implements PredicateDecorator<T>, Serializable {\n\n    /** Serial version UID */\n    private static final long serialVersionUID = -3094696765038308799L;\n\n    /** The array of predicates to call */\n    protected final Predicate<? super T>[] iPredicates;\n\n    /**\n     * Constructor that performs no validation.\n     *\n     * @param predicates  the predicates to check, not cloned, not null\n     */\n    public AbstractQuantifierPredicate(final Predicate<? super T>... predicates) {\n        iPredicates = predicates;\n    }\n\n    /**\n     * Gets the predicates.\n     *\n     * @return a copy of the predicates\n     * @since 3.1\n     */\n    @Override\n    public Predicate<? super T>[] getPredicates() {\n        return FunctorUtils.copy(iPredicates);\n    }\n\n}", "super_interfaces": ["PredicateDecorator<T>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -3094696765038308799L;", "docstring": " Serial version UID", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -3094696765038308799L", "syntax_pass": true}, {"attribute_expression": "protected final Predicate<? super T>[] iPredicates;", "docstring": " The array of predicates to call", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Predicate<? super T>[]", "name": "iPredicates", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java.KeyAnalyzer", "name": "KeyAnalyzer", "file_path": "src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java", "superclasses": "", "methods": ["[boolean]isEqualBitKey(int)", "[boolean]isNullBitKey(int)", "[boolean]isOutOfBoundsIndex(int)", "[boolean]isValidBitIndex(int)", "[int]bitIndex(K,int,int,K,int,int)", "[int]bitsPerElement()", "[int]compare(K,K)", "[boolean]isBitSet(K,int,int)", "[boolean]isPrefix(K,int,int,K)", "[int]lengthInBits(K)"], "method_uris": ["src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java.KeyAnalyzer.[boolean]isEqualBitKey(int)", "src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java.KeyAnalyzer.[boolean]isNullBitKey(int)", "src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java.KeyAnalyzer.[boolean]isOutOfBoundsIndex(int)", "src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java.KeyAnalyzer.[boolean]isValidBitIndex(int)", "src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java.KeyAnalyzer.[int]bitIndex(K,int,int,K,int,int)", "src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java.KeyAnalyzer.[int]bitsPerElement()", "src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java.KeyAnalyzer.[int]compare(K,K)", "src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java.KeyAnalyzer.[boolean]isBitSet(K,int,int)", "src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java.KeyAnalyzer.[boolean]isPrefix(K,int,int,K)", "src/main/java/org/apache/commons/collections4/trie/KeyAnalyzer.java.KeyAnalyzer.[int]lengthInBits(K)"], "overrides": null, "attributes": [], "class_docstring": "\nDefines the interface to analyze {@link org.apache.commons.collections4.Trie Trie} keys on a bit level.\n{@link KeyAnalyzer}'s methods return the length of the key in bits, whether or not a bit is set,\nand bits per element in the key.\n<p>\nAdditionally, a method determines if a key is a prefix of another\nkey and returns the bit index where one key is different from another\nkey (if the key and found key are equal than the return value is\n{@link #EQUAL_BIT_KEY}).\n</p>\n\n@param <K> the type of objects that may be compared by this analyzer\n@since 4.0\n", "original_string": "public abstract class KeyAnalyzer<K> implements Comparator<K>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -20497563720380683L;\n\n    /**\n     * Returned by {@link #bitIndex(Object, int, int, Object, int, int)}\n     * if key's bits are all 0.\n     */\n    public static final int NULL_BIT_KEY = -1;\n\n    /**\n     * Returned by {@link #bitIndex(Object, int, int, Object, int, int)} if key and found key are equal.\n     * This is a very specific case and shouldn't happen on a regular basis.\n     */\n    public static final int EQUAL_BIT_KEY = -2;\n\n    /**\n     * Used to test a {@code bitIndex} in {@link #isOutOfBoundsIndex(int)}.\n     */\n    public static final int OUT_OF_BOUNDS_BIT_KEY = -3;\n\n    /**\n     * Returns true if bitIndex is a {@link KeyAnalyzer#EQUAL_BIT_KEY}.\n     */\n    static boolean isEqualBitKey(final int bitIndex) {\n        return bitIndex == EQUAL_BIT_KEY;\n    }\n\n    /**\n     * Returns true if bitIndex is a {@link KeyAnalyzer#NULL_BIT_KEY}.\n     */\n    static boolean isNullBitKey(final int bitIndex) {\n        return bitIndex == NULL_BIT_KEY;\n    }\n\n    /**\n     * Returns true if bitIndex is a {@link KeyAnalyzer#OUT_OF_BOUNDS_BIT_KEY}.\n     */\n    static boolean isOutOfBoundsIndex(final int bitIndex) {\n        return bitIndex == OUT_OF_BOUNDS_BIT_KEY;\n    }\n\n    /**\n     * Returns true if the given bitIndex is valid.\n     * Indices are considered valid if they're between 0 and {@link Integer#MAX_VALUE}\n     */\n    static boolean isValidBitIndex(final int bitIndex) {\n        return bitIndex >= 0;\n    }\n\n    /**\n     * Returns the n-th different bit between key and other. This starts the comparison in\n     * key at 'offsetInBits' and goes for 'lengthInBits' bits, and compares to the other key starting\n     * at 'otherOffsetInBits' and going for 'otherLengthInBits' bits.\n     *\n     * @param key  the key to use\n     * @param offsetInBits  the bit offset in the key\n     * @param lengthInBits  the maximum key length in bits to use\n     * @param other  the other key to use\n     * @param otherOffsetInBits  the bit offset in the other key\n     * @param otherLengthInBits  the maximum key length in bits for the other key\n     * @return the bit index where the key and other first differ\n     */\n    public abstract int bitIndex(K key, int offsetInBits, int lengthInBits,\n                                 K other, int otherOffsetInBits, int otherLengthInBits);\n\n    /**\n     * Returns the number of bits per element in the key.\n     * This is only useful for variable-length keys, such as Strings.\n     *\n     * @return the number of bits per element\n     */\n    public abstract int bitsPerElement();\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public int compare(final K o1, final K o2) {\n        if (o1 == null) {\n            return o2 == null ? 0 : -1;\n        }\n        if (o2 == null) {\n            return 1;\n        }\n\n        return ((Comparable<K>) o1).compareTo(o2);\n    }\n\n    /**\n     * Returns whether or not a bit is set.\n     *\n     * @param key  the key to check, may not be null\n     * @param bitIndex  the bit index to check\n     * @param lengthInBits  the maximum key length in bits to check\n     * @return {@code true} if the bit is set in the given key and\n     *   {@code bitIndex} &lt; {@code lengthInBits}, {@code false} otherwise.\n     */\n    public abstract boolean isBitSet(K key, int bitIndex, int lengthInBits);\n\n    /**\n     * Determines whether or not the given prefix (from offset to length) is a prefix of the given key.\n     *\n     * @param prefix  the prefix to check\n     * @param offsetInBits  the bit offset in the key\n     * @param lengthInBits  the maximum key length in bits to use\n     * @param key  the key to check\n     * @return {@code true} if this is a valid prefix for the given key\n     */\n    public abstract boolean isPrefix(K prefix, int offsetInBits, int lengthInBits, K key);\n\n    /**\n     * Returns the length of the Key in bits.\n     *\n     * @param key  the key\n     * @return the bit length of the key\n     */\n    public abstract int lengthInBits(K key);\n\n}", "super_interfaces": ["Comparator<K>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -20497563720380683L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -20497563720380683L", "syntax_pass": true}, {"attribute_expression": "public static final int NULL_BIT_KEY = -1;", "docstring": "\nReturned by {@link #bitIndex(Object, int, int, Object, int, int)}\nif key's bits are all 0.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "NULL_BIT_KEY = -1", "syntax_pass": true}, {"attribute_expression": "public static final int EQUAL_BIT_KEY = -2;", "docstring": "\nReturned by {@link #bitIndex(Object, int, int, Object, int, int)} if key and found key are equal.\nThis is a very specific case and shouldn't happen on a regular basis.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "EQUAL_BIT_KEY = -2", "syntax_pass": true}, {"attribute_expression": "public static final int OUT_OF_BOUNDS_BIT_KEY = -3;", "docstring": "\nUsed to test a {@code bitIndex} in {@link #isOutOfBoundsIndex(int)}.\n", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "OUT_OF_BOUNDS_BIT_KEY = -3", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie", "name": "AbstractPatriciaTrie", "file_path": "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java", "superclasses": "", "methods": ["[boolean]isValidUplink(TrieEntry<?, ?>,TrieEntry<?, ?>)", "[]AbstractPatriciaTrie(KeyAnalyzer<? super K>)", "[]AbstractPatriciaTrie(KeyAnalyzer<? super K>,Map<? extends K, ? extends V>)", "[TrieEntry<K, V>]addEntry(TrieEntry<K, V>,int)", "[TrieEntry<K, V>]ceilingEntry(K)", "[void]clear()", "[Comparator<? super K>]comparator()", "[boolean]containsKey(Object)", "[void]decrementSize()", "[Set<Map.Entry<K, V>>]entrySet()", "[TrieEntry<K, V>]firstEntry()", "[K]firstKey()", "[TrieEntry<K, V>]floorEntry(K)", "[TrieEntry<K, V>]followLeft(TrieEntry<K, V>)", "[TrieEntry<K, V>]followRight(TrieEntry<K, V>)", "[V]get(Object)", "[TrieEntry<K, V>]getEntry(Object)", "[TrieEntry<K, V>]getNearestEntryForKey(K,int)", "[SortedMap<K, V>]getPrefixMapByBits(K,int,int)", "[SortedMap<K, V>]headMap(K)", "[TrieEntry<K, V>]higherEntry(K)", "[void]incrementModCount()", "[void]incrementSize()", "[Set<K>]keySet()", "[TrieEntry<K, V>]lastEntry()", "[K]lastKey()", "[TrieEntry<K, V>]lowerEntry(K)", "[OrderedMapIterator<K, V>]mapIterator()", "[TrieEntry<K, V>]nextEntry(TrieEntry<K, V>)", "[TrieEntry<K, V>]nextEntryImpl(TrieEntry<K, V>,TrieEntry<K, V>,TrieEntry<K, V>)", "[TrieEntry<K, V>]nextEntryInSubtree(TrieEntry<K, V>,TrieEntry<K, V>)", "[K]nextKey(K)", "[SortedMap<K, V>]prefixMap(K)", "[TrieEntry<K, V>]previousEntry(TrieEntry<K, V>)", "[K]previousKey(K)", "[V]put(K,V)", "[void]readObject(ObjectInputStream)", "[V]remove(Object)", "[V]removeEntry(TrieEntry<K, V>)", "[void]removeExternalEntry(TrieEntry<K, V>)", "[void]removeInternalEntry(TrieEntry<K, V>)", "[Map.Entry<K, V>]select(K)", "[K]selectKey(K)", "[boolean]selectR(TrieEntry<K, V>,int,K,int,Reference<Map.Entry<K, V>>)", "[V]selectValue(K)", "[int]size()", "[SortedMap<K, V>]subMap(K,K)", "[TrieEntry<K, V>]subtree(K,int,int)", "[SortedMap<K, V>]tailMap(K)", "[Collection<V>]values()", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[boolean]isValidUplink(TrieEntry<?, ?>,TrieEntry<?, ?>)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[]AbstractPatriciaTrie(KeyAnalyzer<? super K>)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[]AbstractPatriciaTrie(KeyAnalyzer<? super K>,Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]addEntry(TrieEntry<K, V>,int)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]ceilingEntry(K)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[void]clear()", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[Comparator<? super K>]comparator()", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[void]decrementSize()", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]firstEntry()", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[K]firstKey()", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]floorEntry(K)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]followLeft(TrieEntry<K, V>)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]followRight(TrieEntry<K, V>)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[V]get(Object)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]getEntry(Object)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]getNearestEntryForKey(K,int)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[SortedMap<K, V>]getPrefixMapByBits(K,int,int)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[SortedMap<K, V>]headMap(K)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]higherEntry(K)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[void]incrementModCount()", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[void]incrementSize()", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]lastEntry()", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[K]lastKey()", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]lowerEntry(K)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[OrderedMapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]nextEntry(TrieEntry<K, V>)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]nextEntryImpl(TrieEntry<K, V>,TrieEntry<K, V>,TrieEntry<K, V>)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]nextEntryInSubtree(TrieEntry<K, V>,TrieEntry<K, V>)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[K]nextKey(K)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[SortedMap<K, V>]prefixMap(K)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]previousEntry(TrieEntry<K, V>)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[K]previousKey(K)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[V]removeEntry(TrieEntry<K, V>)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[void]removeExternalEntry(TrieEntry<K, V>)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[void]removeInternalEntry(TrieEntry<K, V>)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[Map.Entry<K, V>]select(K)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[K]selectKey(K)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[boolean]selectR(TrieEntry<K, V>,int,K,int,Reference<Map.Entry<K, V>>)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[V]selectValue(K)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[int]size()", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[SortedMap<K, V>]subMap(K,K)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[TrieEntry<K, V>]subtree(K,int,int)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[SortedMap<K, V>]tailMap(K)", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[Collection<V>]values()", "src/main/java/org/apache/commons/collections4/trie/AbstractPatriciaTrie.java.AbstractPatriciaTrie.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [{"original_string": "    private abstract class AbstractRangeMap extends AbstractMap<K, V>\n            implements SortedMap<K, V> {\n\n        /** The {@link #entrySet()} view. */\n        private transient volatile Set<Map.Entry<K, V>> entrySet;\n\n        @Override\n        public Comparator<? super K> comparator() {\n            return AbstractPatriciaTrie.this.comparator();\n        }\n\n        @Override\n        public boolean containsKey(final Object key) {\n            if (!inRange(castKey(key))) {\n                return false;\n            }\n\n            return AbstractPatriciaTrie.this.containsKey(key);\n        }\n\n        /**\n         * Creates and returns an {@link #entrySet()} view of the {@link AbstractRangeMap}.\n         */\n        protected abstract Set<Map.Entry<K, V>> createEntrySet();\n\n        /**\n         * Creates and returns a sub-range view of the current {@link AbstractRangeMap}.\n         */\n        protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive,\n                                                          K toKey, boolean toInclusive);\n\n        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            if (entrySet == null) {\n                entrySet = createEntrySet();\n            }\n            return entrySet;\n        }\n\n        @Override\n        public V get(final Object key) {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.get(key);\n        }\n\n        /**\n         * Returns the FROM Key.\n         */\n        protected abstract K getFromKey();\n\n        /**\n         * Returns the TO Key.\n         */\n        protected abstract K getToKey();\n\n        @Override\n        public SortedMap<K, V> headMap(final K toKey) {\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n            return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive());\n        }\n\n        /**\n         * Returns true if the provided key is in the FROM range of the {@link AbstractRangeMap}.\n         */\n        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n            final K fromKey = getFromKey();\n            final boolean fromInclusive = isFromInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, fromKey);\n            if (fromInclusive || forceInclusive) {\n                return ret >= 0;\n            }\n            return ret > 0;\n        }\n\n        /**\n         * Returns true if the provided key is greater than TO and less than FROM.\n         */\n        protected boolean inRange(final K key) {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, false));\n        }\n\n        /**\n         * This form allows the high endpoint (as well as all legit keys).\n         */\n        protected boolean inRange2(final K key) {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, true));\n        }\n\n        /**\n         * Returns true if the provided key is in the TO range of the {@link AbstractRangeMap}.\n         */\n        protected boolean inToRange(final K key, final boolean forceInclusive) {\n            final K toKey = getToKey();\n            final boolean toInclusive = isToInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, toKey);\n            if (toInclusive || forceInclusive) {\n                return ret <= 0;\n            }\n            return ret < 0;\n        }\n\n        /**\n         * Whether or not the {@link #getFromKey()} is in the range.\n         */\n        protected abstract boolean isFromInclusive();\n\n        /**\n         * Whether or not the {@link #getToKey()} is in the range.\n         */\n        protected abstract boolean isToInclusive();\n\n        @Override\n        public V put(final K key, final V value) {\n            if (!inRange(key)) {\n                throw new IllegalArgumentException(\"Key is out of range: \" + key);\n            }\n            return AbstractPatriciaTrie.this.put(key, value);\n        }\n\n        @Override\n        public V remove(final Object key) {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.remove(key);\n        }\n\n        @Override\n        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n\n            return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive());\n        }\n\n        @Override\n        public SortedMap<K, V> tailMap(final K fromKey) {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n            return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive());\n        }\n    }", "definition": "    private abstract class AbstractRangeMap extends AbstractMap<K, V>\n            implements SortedMap<K, V>", "class_docstring": "\nA range view of the {@link org.apache.commons.collections4.Trie}.\n", "name": "AbstractRangeMap", "super_interfaces": ["SortedMap<K, V>"], "superclasses": "", "attributes": {"modifiers": "private abstract", "marker_annotations": [], "non_marker_annotations": ["private", "abstract"], "comments": [], "fields": [{"attribute_expression": "private transient volatile Set<Map.Entry<K, V>> entrySet;", "docstring": " The {@link #entrySet()} view.", "modifiers": "private transient volatile", "marker_annotations": [], "non_marker_annotations": ["private", "transient", "volatile"], "comments": [], "type": "Set<Map.Entry<K, V>>", "name": "entrySet", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Comparator<? super K> comparator() {\n            return AbstractPatriciaTrie.this.comparator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Comparator<? super K>", "classes": []}, "name": "comparator", "params": [], "body": "                                                  {\n            return AbstractPatriciaTrie.this.comparator();\n        }", "signature": "@Override\n        public Comparator<? super K> comparator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsKey(final Object key) {\n            if (!inRange(castKey(key))) {\n                return false;\n            }\n\n            return AbstractPatriciaTrie.this.containsKey(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsKey", "params": [{"name": "key", "type": "Object"}], "body": "                                                     {\n            if (!inRange(castKey(key))) {\n                return false;\n            }\n\n            return AbstractPatriciaTrie.this.containsKey(key);\n        }", "signature": "@Override\n        public boolean containsKey(final Object key)"}, {"syntax_pass": true, "original_string": "        protected abstract Set<Map.Entry<K, V>> createEntrySet();", "docstring": "\nCreates and returns an {@link #entrySet()} view of the {@link AbstractRangeMap}.\n", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "Set<Map.Entry<K, V>>", "classes": []}, "name": "createEntrySet", "params": [], "body": "", "signature": "protected abstract Set<Map.Entry<K, V>> createEntrySet()"}, {"syntax_pass": true, "original_string": "        protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive,\n                                                          K toKey, boolean toInclusive);", "docstring": "\nCreates and returns a sub-range view of the current {@link AbstractRangeMap}.\n", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "name": "createRangeMap", "params": [{"name": "fromKey", "type": "K"}, {"name": "fromInclusive", "type": "boolean"}, {"name": "toKey", "type": "K"}, {"name": "toInclusive", "type": "boolean"}], "body": "", "signature": "protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive,\n                                                          K toKey, boolean toInclusive)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            if (entrySet == null) {\n                entrySet = createEntrySet();\n            }\n            return entrySet;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<Map.Entry<K, V>>", "classes": []}, "name": "entrySet", "params": [], "body": "                                               {\n            if (entrySet == null) {\n                entrySet = createEntrySet();\n            }\n            return entrySet;\n        }", "signature": "@Override\n        public Set<Map.Entry<K, V>> entrySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V get(final Object key) {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.get(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "get", "params": [{"name": "key", "type": "Object"}], "body": "                                       {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.get(key);\n        }", "signature": "@Override\n        public V get(final Object key)"}, {"syntax_pass": true, "original_string": "        protected abstract K getFromKey();", "docstring": "\nReturns the FROM Key.\n", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "K", "classes": []}, "name": "getFromKey", "params": [], "body": "", "signature": "protected abstract K getFromKey()"}, {"syntax_pass": true, "original_string": "        protected abstract K getToKey();", "docstring": "\nReturns the TO Key.\n", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "K", "classes": []}, "name": "getToKey", "params": [], "body": "", "signature": "protected abstract K getToKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public SortedMap<K, V> headMap(final K toKey) {\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n            return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "name": "headMap", "params": [{"name": "toKey", "type": "K"}], "body": "                                                      {\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n            return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive());\n        }", "signature": "@Override\n        public SortedMap<K, V> headMap(final K toKey)"}, {"syntax_pass": true, "original_string": "        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n            final K fromKey = getFromKey();\n            final boolean fromInclusive = isFromInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, fromKey);\n            if (fromInclusive || forceInclusive) {\n                return ret >= 0;\n            }\n            return ret > 0;\n        }", "docstring": "\nReturns true if the provided key is in the FROM range of the {@link AbstractRangeMap}.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "name": "inFromRange", "params": [{"name": "key", "type": "K"}, {"name": "forceInclusive", "type": "boolean"}], "body": "                                                                                 {\n            final K fromKey = getFromKey();\n            final boolean fromInclusive = isFromInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, fromKey);\n            if (fromInclusive || forceInclusive) {\n                return ret >= 0;\n            }\n            return ret > 0;\n        }", "signature": "protected boolean inFromRange(final K key, final boolean forceInclusive)"}, {"syntax_pass": true, "original_string": "        protected boolean inRange(final K key) {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, false));\n        }", "docstring": "\nReturns true if the provided key is greater than TO and less than FROM.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "name": "inRange", "params": [{"name": "key", "type": "K"}], "body": "                                               {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, false));\n        }", "signature": "protected boolean inRange(final K key)"}, {"syntax_pass": true, "original_string": "        protected boolean inRange2(final K key) {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, true));\n        }", "docstring": "\nThis form allows the high endpoint (as well as all legit keys).\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "name": "inRange2", "params": [{"name": "key", "type": "K"}], "body": "                                                {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, true));\n        }", "signature": "protected boolean inRange2(final K key)"}, {"syntax_pass": true, "original_string": "        protected boolean inToRange(final K key, final boolean forceInclusive) {\n            final K toKey = getToKey();\n            final boolean toInclusive = isToInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, toKey);\n            if (toInclusive || forceInclusive) {\n                return ret <= 0;\n            }\n            return ret < 0;\n        }", "docstring": "\nReturns true if the provided key is in the TO range of the {@link AbstractRangeMap}.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "name": "inToRange", "params": [{"name": "key", "type": "K"}, {"name": "forceInclusive", "type": "boolean"}], "body": "                                                                               {\n            final K toKey = getToKey();\n            final boolean toInclusive = isToInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, toKey);\n            if (toInclusive || forceInclusive) {\n                return ret <= 0;\n            }\n            return ret < 0;\n        }", "signature": "protected boolean inToRange(final K key, final boolean forceInclusive)"}, {"syntax_pass": true, "original_string": "        protected abstract boolean isFromInclusive();", "docstring": "\nWhether or not the {@link #getFromKey()} is in the range.\n", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isFromInclusive", "params": [], "body": "", "signature": "protected abstract boolean isFromInclusive()"}, {"syntax_pass": true, "original_string": "        protected abstract boolean isToInclusive();", "docstring": "\nWhether or not the {@link #getToKey()} is in the range.\n", "attributes": {"modifiers": "protected abstract", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isToInclusive", "params": [], "body": "", "signature": "protected abstract boolean isToInclusive()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V put(final K key, final V value) {\n            if (!inRange(key)) {\n                throw new IllegalArgumentException(\"Key is out of range: \" + key);\n            }\n            return AbstractPatriciaTrie.this.put(key, value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "put", "params": [{"name": "key", "type": "K"}, {"name": "value", "type": "V"}], "body": "                                                 {\n            if (!inRange(key)) {\n                throw new IllegalArgumentException(\"Key is out of range: \" + key);\n            }\n            return AbstractPatriciaTrie.this.put(key, value);\n        }", "signature": "@Override\n        public V put(final K key, final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V remove(final Object key) {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.remove(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "remove", "params": [{"name": "key", "type": "Object"}], "body": "                                          {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.remove(key);\n        }", "signature": "@Override\n        public V remove(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n\n            return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "name": "subMap", "params": [{"name": "fromKey", "type": "K"}, {"name": "toKey", "type": "K"}], "body": "                                                                      {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n\n            return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive());\n        }", "signature": "@Override\n        public SortedMap<K, V> subMap(final K fromKey, final K toKey)"}, {"syntax_pass": true, "original_string": "        @Override\n        public SortedMap<K, V> tailMap(final K fromKey) {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n            return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "name": "tailMap", "params": [{"name": "fromKey", "type": "K"}], "body": "                                                        {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n            return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive());\n        }", "signature": "@Override\n        public SortedMap<K, V> tailMap(final K fromKey)"}]}, {"original_string": "    abstract class AbstractTrieIterator<E> implements Iterator<E> {\n\n        /** For fast-fail. */\n        protected int expectedModCount = AbstractPatriciaTrie.this.modCount;\n\n        protected TrieEntry<K, V> next; // the next node to return\n        protected TrieEntry<K, V> current; // the current entry we're on\n\n        /**\n         * Starts iteration from the root.\n         */\n        protected AbstractTrieIterator() {\n            next = AbstractPatriciaTrie.this.nextEntry(null);\n        }\n\n        /**\n         * Starts iteration at the given entry.\n         */\n        protected AbstractTrieIterator(final TrieEntry<K, V> firstEntry) {\n            next = firstEntry;\n        }\n\n        /**\n         * @see PatriciaTrie#nextEntry(TrieEntry)\n         */\n        protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n            return AbstractPatriciaTrie.this.nextEntry(prior);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return next != null;\n        }\n\n        /**\n         * Returns the next {@link TrieEntry}.\n         */\n        protected TrieEntry<K, V> nextEntry() {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> e = next;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            next = findNext(e);\n            current = e;\n            return e;\n        }\n\n        @Override\n        public void remove() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> node = current;\n            current = null;\n            AbstractPatriciaTrie.this.removeEntry(node);\n\n            expectedModCount = AbstractPatriciaTrie.this.modCount;\n        }\n    }", "definition": "    abstract class AbstractTrieIterator<E> implements Iterator<E>", "class_docstring": "\nAn iterator for the entries.\n", "name": "AbstractTrieIterator", "super_interfaces": ["Iterator<E>"], "superclasses": "", "attributes": {"modifiers": "abstract", "marker_annotations": [], "non_marker_annotations": ["abstract"], "comments": [], "fields": [{"attribute_expression": "protected int expectedModCount = AbstractPatriciaTrie.this.modCount;", "docstring": " For fast-fail.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "expectedModCount = AbstractPatriciaTrie.this.modCount", "syntax_pass": true}, {"attribute_expression": "protected TrieEntry<K, V> next;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "TrieEntry<K, V>", "name": "next", "syntax_pass": true}, {"attribute_expression": "protected TrieEntry<K, V> current;", "docstring": " the next node to return", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "TrieEntry<K, V>", "name": "current", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected AbstractTrieIterator() {\n            next = AbstractPatriciaTrie.this.nextEntry(null);\n        }", "docstring": "\nStarts iteration from the root.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "AbstractTrieIterator", "params": [], "body": "                                         {\n            next = AbstractPatriciaTrie.this.nextEntry(null);\n        }", "signature": "protected AbstractTrieIterator()"}, {"syntax_pass": true, "original_string": "        protected AbstractTrieIterator(final TrieEntry<K, V> firstEntry) {\n            next = firstEntry;\n        }", "docstring": "\nStarts iteration at the given entry.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "AbstractTrieIterator", "params": [{"name": "firstEntry", "type": "TrieEntry<K, V>"}], "body": "                                                                         {\n            next = firstEntry;\n        }", "signature": "protected AbstractTrieIterator(final TrieEntry<K, V> firstEntry)"}, {"syntax_pass": true, "original_string": "        protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n            return AbstractPatriciaTrie.this.nextEntry(prior);\n        }", "docstring": "\n@see PatriciaTrie#nextEntry(TrieEntry)\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "TrieEntry<K, V>", "classes": []}, "name": "findNext", "params": [{"name": "prior", "type": "TrieEntry<K, V>"}], "body": "                                                                        {\n            return AbstractPatriciaTrie.this.nextEntry(prior);\n        }", "signature": "protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return next != null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return next != null;\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        protected TrieEntry<K, V> nextEntry() {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> e = next;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            next = findNext(e);\n            current = e;\n            return e;\n        }", "docstring": "\nReturns the next {@link TrieEntry}.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "TrieEntry<K, V>", "classes": []}, "name": "nextEntry", "params": [], "body": "                                              {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> e = next;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            next = findNext(e);\n            current = e;\n            return e;\n        }", "signature": "protected TrieEntry<K, V> nextEntry()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> node = current;\n            current = null;\n            AbstractPatriciaTrie.this.removeEntry(node);\n\n            expectedModCount = AbstractPatriciaTrie.this.modCount;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> node = current;\n            current = null;\n            AbstractPatriciaTrie.this.removeEntry(node);\n\n            expectedModCount = AbstractPatriciaTrie.this.modCount;\n        }", "signature": "@Override\n        public void remove()"}]}, {"original_string": "    private final class EntrySet extends AbstractSet<Map.Entry<K, V>> {\n\n        /**\n         * An {@link Iterator} that returns {@link Entry} Objects.\n         */\n        private final class EntryIterator extends AbstractTrieIterator<Map.Entry<K, V>> {\n            @Override\n            public Map.Entry<K, V> next() {\n                return nextEntry();\n            }\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> candidate = getEntry(((Map.Entry<?, ?>) o).getKey());\n            return candidate != null && candidate.equals(o);\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new EntryIterator();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            if (!contains(obj)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            AbstractPatriciaTrie.this.remove(entry.getKey());\n            return true;\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n    }", "definition": "    private final class EntrySet extends AbstractSet<Map.Entry<K, V>>", "class_docstring": "\nThis is an entry set view of the {@link org.apache.commons.collections4.Trie} as returned by {@link Map#entrySet()}.\n", "name": "EntrySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": [{"original_string": "        private final class EntryIterator extends AbstractTrieIterator<Map.Entry<K, V>> {\n            @Override\n            public Map.Entry<K, V> next() {\n                return nextEntry();\n            }\n        }", "definition": "        private final class EntryIterator extends AbstractTrieIterator<Map.Entry<K, V>>", "class_docstring": "\nAn {@link Iterator} that returns {@link Entry} Objects.\n", "name": "EntryIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "            @Override\n            public Map.Entry<K, V> next() {\n                return nextEntry();\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "next", "params": [], "body": "                                          {\n                return nextEntry();\n            }", "signature": "@Override\n            public Map.Entry<K, V> next()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            AbstractPatriciaTrie.this.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> candidate = getEntry(((Map.Entry<?, ?>) o).getKey());\n            return candidate != null && candidate.equals(o);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "o", "type": "Object"}], "body": "                                                {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> candidate = getEntry(((Map.Entry<?, ?>) o).getKey());\n            return candidate != null && candidate.equals(o);\n        }", "signature": "@Override\n        public boolean contains(final Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new EntryIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Map.Entry<K, V>>", "classes": []}, "name": "iterator", "params": [], "body": "                                                    {\n            return new EntryIterator();\n        }", "signature": "@Override\n        public Iterator<Map.Entry<K, V>> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            if (!contains(obj)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            AbstractPatriciaTrie.this.remove(entry.getKey());\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            if (!contains(obj)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            AbstractPatriciaTrie.this.remove(entry.getKey());\n            return true;\n        }", "signature": "@Override\n        public boolean remove(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return AbstractPatriciaTrie.this.size();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    private final class KeySet extends AbstractSet<K> {\n\n        /**\n         * An {@link Iterator} that returns Key Objects.\n         */\n        private final class KeyIterator extends AbstractTrieIterator<K> {\n            @Override\n            public K next() {\n                return nextEntry().getKey();\n            }\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            return containsKey(o);\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return new KeyIterator();\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            final int size = size();\n            AbstractPatriciaTrie.this.remove(o);\n            return size != size();\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n    }", "definition": "    private final class KeySet extends AbstractSet<K>", "class_docstring": "\nThis is a key set view of the {@link org.apache.commons.collections4.Trie} as returned by {@link Map#keySet()}.\n", "name": "KeySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": [{"original_string": "        private final class KeyIterator extends AbstractTrieIterator<K> {\n            @Override\n            public K next() {\n                return nextEntry().getKey();\n            }\n        }", "definition": "        private final class KeyIterator extends AbstractTrieIterator<K>", "class_docstring": "\nAn {@link Iterator} that returns Key Objects.\n", "name": "KeyIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "            @Override\n            public K next() {\n                return nextEntry().getKey();\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                            {\n                return nextEntry().getKey();\n            }", "signature": "@Override\n            public K next()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            AbstractPatriciaTrie.this.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object o) {\n            return containsKey(o);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "o", "type": "Object"}], "body": "                                                {\n            return containsKey(o);\n        }", "signature": "@Override\n        public boolean contains(final Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<K> iterator() {\n            return new KeyIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<K>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return new KeyIterator();\n        }", "signature": "@Override\n        public Iterator<K> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object o) {\n            final int size = size();\n            AbstractPatriciaTrie.this.remove(o);\n            return size != size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n            final int size = size();\n            AbstractPatriciaTrie.this.remove(o);\n            return size != size();\n        }", "signature": "@Override\n        public boolean remove(final Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return AbstractPatriciaTrie.this.size();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    private final class PrefixRangeEntrySet extends RangeEntrySet {\n\n        /**\n         * An {@link Iterator} for iterating over a prefix search.\n         */\n        private final class EntryIterator extends AbstractTrieIterator<Map.Entry<K, V>> {\n\n            // values to reset the subtree if we remove it.\n            private final K prefix;\n            private final int offset;\n            private final int lengthInBits;\n            private boolean lastOne;\n\n            private TrieEntry<K, V> subtree; // the subtree to search within\n\n            /**\n             * Starts iteration at the given entry &amp; search only\n             * within the given subtree.\n             */\n            EntryIterator(final TrieEntry<K, V> startScan, final K prefix,\n                    final int offset, final int lengthInBits) {\n                subtree = startScan;\n                next = AbstractPatriciaTrie.this.followLeft(startScan);\n                this.prefix = prefix;\n                this.offset = offset;\n                this.lengthInBits = lengthInBits;\n            }\n\n            @Override\n            protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n                return AbstractPatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n            }\n\n            @Override\n            public Map.Entry<K, V> next() {\n                final Map.Entry<K, V> entry = nextEntry();\n                if (lastOne) {\n                    next = null;\n                }\n                return entry;\n            }\n\n            @Override\n            public void remove() {\n                // If the current entry we're removing is the subtree\n                // then we need to find a new subtree parent.\n                boolean needsFixing = false;\n                final int bitIdx = subtree.bitIndex;\n                if (current == subtree) {\n                    needsFixing = true;\n                }\n\n                super.remove();\n\n                // If the subtree changed its bitIndex or we\n                // removed the old subtree, get a new one.\n                if (bitIdx != subtree.bitIndex || needsFixing) {\n                    subtree = subtree(prefix, offset, lengthInBits);\n                }\n\n                // If the subtree's bitIndex is less than the\n                // length of our prefix, it's the last item\n                // in the prefix tree.\n                if (lengthInBits >= subtree.bitIndex) {\n                    lastOne = true;\n                }\n            }\n        }\n\n        /**\n         * An {@link Iterator} that holds a single {@link TrieEntry}.\n         */\n        private final class SingletonIterator implements Iterator<Map.Entry<K, V>> {\n\n            private final TrieEntry<K, V> entry;\n\n            private int hit;\n\n            SingletonIterator(final TrieEntry<K, V> entry) {\n                this.entry = entry;\n            }\n\n            @Override\n            public boolean hasNext() {\n                return hit == 0;\n            }\n\n            @Override\n            public Map.Entry<K, V> next() {\n                if (hit != 0) {\n                    throw new NoSuchElementException();\n                }\n\n                ++hit;\n                return entry;\n            }\n\n            @Override\n            public void remove() {\n                if (hit != 1) {\n                    throw new IllegalStateException();\n                }\n\n                ++hit;\n                AbstractPatriciaTrie.this.removeEntry(entry);\n            }\n        }\n\n        private final PrefixRangeMap delegate;\n\n        private TrieEntry<K, V> prefixStart;\n\n        private int expectedModCount;\n\n        /**\n         * Creates a {@link PrefixRangeEntrySet}.\n         */\n        PrefixRangeEntrySet(final PrefixRangeMap delegate) {\n            super(delegate);\n            this.delegate = delegate;\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            if (AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                prefixStart = subtree(delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            if (prefixStart == null) {\n                final Set<Map.Entry<K, V>> empty = Collections.emptySet();\n                return empty.iterator();\n            }\n            if (delegate.lengthInBits > prefixStart.bitIndex) {\n                return new SingletonIterator(prefixStart);\n            }\n            return new EntryIterator(prefixStart, delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n        }\n\n        @Override\n        public int size() {\n            return delegate.fixup();\n        }\n    }", "definition": "    private final class PrefixRangeEntrySet extends RangeEntrySet", "class_docstring": "\nA prefix {@link RangeEntrySet} view of the {@link org.apache.commons.collections4.Trie}.\n", "name": "PrefixRangeEntrySet", "super_interfaces": [], "superclasses": "RangeEntrySet", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private final PrefixRangeMap delegate;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PrefixRangeMap", "name": "delegate", "syntax_pass": true}, {"attribute_expression": "private TrieEntry<K, V> prefixStart;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TrieEntry<K, V>", "name": "prefixStart", "syntax_pass": true}, {"attribute_expression": "private int expectedModCount;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "expectedModCount", "syntax_pass": true}], "classes": [{"original_string": "        private final class EntryIterator extends AbstractTrieIterator<Map.Entry<K, V>> {\n\n            // values to reset the subtree if we remove it.\n            private final K prefix;\n            private final int offset;\n            private final int lengthInBits;\n            private boolean lastOne;\n\n            private TrieEntry<K, V> subtree; // the subtree to search within\n\n            /**\n             * Starts iteration at the given entry &amp; search only\n             * within the given subtree.\n             */\n            EntryIterator(final TrieEntry<K, V> startScan, final K prefix,\n                    final int offset, final int lengthInBits) {\n                subtree = startScan;\n                next = AbstractPatriciaTrie.this.followLeft(startScan);\n                this.prefix = prefix;\n                this.offset = offset;\n                this.lengthInBits = lengthInBits;\n            }\n\n            @Override\n            protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n                return AbstractPatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n            }\n\n            @Override\n            public Map.Entry<K, V> next() {\n                final Map.Entry<K, V> entry = nextEntry();\n                if (lastOne) {\n                    next = null;\n                }\n                return entry;\n            }\n\n            @Override\n            public void remove() {\n                // If the current entry we're removing is the subtree\n                // then we need to find a new subtree parent.\n                boolean needsFixing = false;\n                final int bitIdx = subtree.bitIndex;\n                if (current == subtree) {\n                    needsFixing = true;\n                }\n\n                super.remove();\n\n                // If the subtree changed its bitIndex or we\n                // removed the old subtree, get a new one.\n                if (bitIdx != subtree.bitIndex || needsFixing) {\n                    subtree = subtree(prefix, offset, lengthInBits);\n                }\n\n                // If the subtree's bitIndex is less than the\n                // length of our prefix, it's the last item\n                // in the prefix tree.\n                if (lengthInBits >= subtree.bitIndex) {\n                    lastOne = true;\n                }\n            }\n        }", "definition": "        private final class EntryIterator extends AbstractTrieIterator<Map.Entry<K, V>>", "class_docstring": "\nAn {@link Iterator} for iterating over a prefix search.\n", "name": "EntryIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private final K prefix;", "docstring": " values to reset the subtree if we remove it.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "K", "name": "prefix", "syntax_pass": true}, {"attribute_expression": "private final int offset;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "offset", "syntax_pass": true}, {"attribute_expression": "private final int lengthInBits;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "lengthInBits", "syntax_pass": true}, {"attribute_expression": "private boolean lastOne;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "lastOne", "syntax_pass": true}, {"attribute_expression": "private TrieEntry<K, V> subtree;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TrieEntry<K, V>", "name": "subtree", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "            EntryIterator(final TrieEntry<K, V> startScan, final K prefix,\n                    final int offset, final int lengthInBits) {\n                subtree = startScan;\n                next = AbstractPatriciaTrie.this.followLeft(startScan);\n                this.prefix = prefix;\n                this.offset = offset;\n                this.lengthInBits = lengthInBits;\n            }", "docstring": "\nStarts iteration at the given entry &amp; search only\nwithin the given subtree.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "EntryIterator", "params": [{"name": "startScan", "type": "TrieEntry<K, V>"}, {"name": "prefix", "type": "K"}, {"name": "offset", "type": "int"}, {"name": "lengthInBits", "type": "int"}], "body": "                                                              {\n                subtree = startScan;\n                next = AbstractPatriciaTrie.this.followLeft(startScan);\n                this.prefix = prefix;\n                this.offset = offset;\n                this.lengthInBits = lengthInBits;\n            }", "signature": "EntryIterator(final TrieEntry<K, V> startScan, final K prefix,\n                    final int offset, final int lengthInBits)"}, {"syntax_pass": true, "original_string": "            @Override\n            protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n                return AbstractPatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "TrieEntry<K, V>", "classes": []}, "name": "findNext", "params": [{"name": "prior", "type": "TrieEntry<K, V>"}], "body": "                                                                            {\n                return AbstractPatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n            }", "signature": "@Override\n            protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior)"}, {"syntax_pass": true, "original_string": "            @Override\n            public Map.Entry<K, V> next() {\n                final Map.Entry<K, V> entry = nextEntry();\n                if (lastOne) {\n                    next = null;\n                }\n                return entry;\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "next", "params": [], "body": "                                          {\n                final Map.Entry<K, V> entry = nextEntry();\n                if (lastOne) {\n                    next = null;\n                }\n                return entry;\n            }", "signature": "@Override\n            public Map.Entry<K, V> next()"}, {"syntax_pass": true, "original_string": "            @Override\n            public void remove() {\n                // If the current entry we're removing is the subtree\n                // then we need to find a new subtree parent.\n                boolean needsFixing = false;\n                final int bitIdx = subtree.bitIndex;\n                if (current == subtree) {\n                    needsFixing = true;\n                }\n\n                super.remove();\n\n                // If the subtree changed its bitIndex or we\n                // removed the old subtree, get a new one.\n                if (bitIdx != subtree.bitIndex || needsFixing) {\n                    subtree = subtree(prefix, offset, lengthInBits);\n                }\n\n                // If the subtree's bitIndex is less than the\n                // length of our prefix, it's the last item\n                // in the prefix tree.\n                if (lengthInBits >= subtree.bitIndex) {\n                    lastOne = true;\n                }\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                                 {\n                // If the current entry we're removing is the subtree\n                // then we need to find a new subtree parent.\n                boolean needsFixing = false;\n                final int bitIdx = subtree.bitIndex;\n                if (current == subtree) {\n                    needsFixing = true;\n                }\n\n                super.remove();\n\n                // If the subtree changed its bitIndex or we\n                // removed the old subtree, get a new one.\n                if (bitIdx != subtree.bitIndex || needsFixing) {\n                    subtree = subtree(prefix, offset, lengthInBits);\n                }\n\n                // If the subtree's bitIndex is less than the\n                // length of our prefix, it's the last item\n                // in the prefix tree.\n                if (lengthInBits >= subtree.bitIndex) {\n                    lastOne = true;\n                }\n            }", "signature": "@Override\n            public void remove()"}]}, {"original_string": "        private final class SingletonIterator implements Iterator<Map.Entry<K, V>> {\n\n            private final TrieEntry<K, V> entry;\n\n            private int hit;\n\n            SingletonIterator(final TrieEntry<K, V> entry) {\n                this.entry = entry;\n            }\n\n            @Override\n            public boolean hasNext() {\n                return hit == 0;\n            }\n\n            @Override\n            public Map.Entry<K, V> next() {\n                if (hit != 0) {\n                    throw new NoSuchElementException();\n                }\n\n                ++hit;\n                return entry;\n            }\n\n            @Override\n            public void remove() {\n                if (hit != 1) {\n                    throw new IllegalStateException();\n                }\n\n                ++hit;\n                AbstractPatriciaTrie.this.removeEntry(entry);\n            }\n        }", "definition": "        private final class SingletonIterator implements Iterator<Map.Entry<K, V>>", "class_docstring": "\nAn {@link Iterator} that holds a single {@link TrieEntry}.\n", "name": "SingletonIterator", "super_interfaces": ["Iterator<Map.Entry<K, V>>"], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private final TrieEntry<K, V> entry;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TrieEntry<K, V>", "name": "entry", "syntax_pass": true}, {"attribute_expression": "private int hit;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "hit", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "            SingletonIterator(final TrieEntry<K, V> entry) {\n                this.entry = entry;\n            }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "SingletonIterator", "params": [{"name": "entry", "type": "TrieEntry<K, V>"}], "body": "                                                           {\n                this.entry = entry;\n            }", "signature": "SingletonIterator(final TrieEntry<K, V> entry)"}, {"syntax_pass": true, "original_string": "            @Override\n            public boolean hasNext() {\n                return hit == 0;\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                     {\n                return hit == 0;\n            }", "signature": "@Override\n            public boolean hasNext()"}, {"syntax_pass": true, "original_string": "            @Override\n            public Map.Entry<K, V> next() {\n                if (hit != 0) {\n                    throw new NoSuchElementException();\n                }\n\n                ++hit;\n                return entry;\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "next", "params": [], "body": "                                          {\n                if (hit != 0) {\n                    throw new NoSuchElementException();\n                }\n\n                ++hit;\n                return entry;\n            }", "signature": "@Override\n            public Map.Entry<K, V> next()"}, {"syntax_pass": true, "original_string": "            @Override\n            public void remove() {\n                if (hit != 1) {\n                    throw new IllegalStateException();\n                }\n\n                ++hit;\n                AbstractPatriciaTrie.this.removeEntry(entry);\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                                 {\n                if (hit != 1) {\n                    throw new IllegalStateException();\n                }\n\n                ++hit;\n                AbstractPatriciaTrie.this.removeEntry(entry);\n            }", "signature": "@Override\n            public void remove()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        PrefixRangeEntrySet(final PrefixRangeMap delegate) {\n            super(delegate);\n            this.delegate = delegate;\n        }", "docstring": "\nCreates a {@link PrefixRangeEntrySet}.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "PrefixRangeEntrySet", "params": [{"name": "delegate", "type": "PrefixRangeMap"}], "body": "                                                           {\n            super(delegate);\n            this.delegate = delegate;\n        }", "signature": "PrefixRangeEntrySet(final PrefixRangeMap delegate)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            if (AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                prefixStart = subtree(delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            if (prefixStart == null) {\n                final Set<Map.Entry<K, V>> empty = Collections.emptySet();\n                return empty.iterator();\n            }\n            if (delegate.lengthInBits > prefixStart.bitIndex) {\n                return new SingletonIterator(prefixStart);\n            }\n            return new EntryIterator(prefixStart, delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Map.Entry<K, V>>", "classes": []}, "name": "iterator", "params": [], "body": "                                                    {\n            if (AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                prefixStart = subtree(delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            if (prefixStart == null) {\n                final Set<Map.Entry<K, V>> empty = Collections.emptySet();\n                return empty.iterator();\n            }\n            if (delegate.lengthInBits > prefixStart.bitIndex) {\n                return new SingletonIterator(prefixStart);\n            }\n            return new EntryIterator(prefixStart, delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n        }", "signature": "@Override\n        public Iterator<Map.Entry<K, V>> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return delegate.fixup();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return delegate.fixup();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    private final class PrefixRangeMap extends AbstractRangeMap {\n\n        private final K prefix;\n\n        private final int offsetInBits;\n\n        private final int lengthInBits;\n\n        private K fromKey;\n\n        private K toKey;\n\n        private transient int expectedModCount;\n\n        private int size = -1;\n\n        /**\n         * Creates a {@link PrefixRangeMap}.\n         */\n        private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits) {\n            this.prefix = prefix;\n            this.offsetInBits = offsetInBits;\n            this.lengthInBits = lengthInBits;\n        }\n\n        @Override\n        public void clear() {\n            final Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();\n            final Set<K> currentKeys = keySet();\n            while (it.hasNext()) {\n                if (currentKeys.contains(it.next().getKey())) {\n                    it.remove();\n                }\n            }\n        }\n\n        @Override\n        protected Set<Map.Entry<K, V>> createEntrySet() {\n            return new PrefixRangeEntrySet(this);\n        }\n\n        @Override\n        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n                                                 final K toKey, final boolean toInclusive) {\n            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n        }\n\n        @Override\n        public K firstKey() {\n            fixup();\n\n            Map.Entry<K, V> e = null;\n            if (fromKey == null) {\n                e = firstEntry();\n            } else {\n                e = higherEntry(fromKey);\n            }\n\n            final K first = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, first)) {\n                throw new NoSuchElementException();\n            }\n\n            return first;\n        }\n\n        /**\n         * This method does two things. It determines the FROM\n         * and TO range of the {@link PrefixRangeMap} and the number\n         * of elements in the range. This method must be called every\n         * time the {@link org.apache.commons.collections4.Trie} has changed.\n         */\n        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\n                if (it.hasNext()) {\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>) entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>) entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }\n\n        @Override\n        public K getFromKey() {\n            return fromKey;\n        }\n\n        @Override\n        public K getToKey() {\n            return toKey;\n        }\n\n        /**\n         * Returns true if the provided Key is in the FROM range of the {@link PrefixRangeMap}.\n         */\n        @Override\n        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        /**\n         * Returns true if this {@link PrefixRangeMap}'s key is a prefix of the provided key.\n         */\n        @Override\n        protected boolean inRange(final K key) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        /**\n         * Same as {@link #inRange(Object)}.\n         */\n        @Override\n        protected boolean inRange2(final K key) {\n            return inRange(key);\n        }\n\n        /**\n         * Returns true if the provided Key is in the TO range of the {@link PrefixRangeMap}.\n         */\n        @Override\n        protected boolean inToRange(final K key, final boolean forceInclusive) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        @Override\n        public boolean isFromInclusive() {\n            return false;\n        }\n\n        @Override\n        public boolean isToInclusive() {\n            return false;\n        }\n\n        @Override\n        public K lastKey() {\n            fixup();\n\n            Map.Entry<K, V> e = null;\n            if (toKey == null) {\n                e = lastEntry();\n            } else {\n                e = lowerEntry(toKey);\n            }\n\n            final K last = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, last)) {\n                throw new NoSuchElementException();\n            }\n\n            return last;\n        }\n    }", "definition": "    private final class PrefixRangeMap extends AbstractRangeMap", "class_docstring": "\nA submap used for prefix views over the {@link org.apache.commons.collections4.Trie}.\n", "name": "PrefixRangeMap", "super_interfaces": [], "superclasses": "AbstractRangeMap", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private final K prefix;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "K", "name": "prefix", "syntax_pass": true}, {"attribute_expression": "private final int offsetInBits;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "offsetInBits", "syntax_pass": true}, {"attribute_expression": "private final int lengthInBits;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "lengthInBits", "syntax_pass": true}, {"attribute_expression": "private K fromKey;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "K", "name": "fromKey", "syntax_pass": true}, {"attribute_expression": "private K toKey;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "K", "name": "toKey", "syntax_pass": true}, {"attribute_expression": "private transient int expectedModCount;", "docstring": "", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "expectedModCount", "syntax_pass": true}, {"attribute_expression": "private int size = -1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "size = -1", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits) {\n            this.prefix = prefix;\n            this.offsetInBits = offsetInBits;\n            this.lengthInBits = lengthInBits;\n        }", "docstring": "\nCreates a {@link PrefixRangeMap}.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "PrefixRangeMap", "params": [{"name": "prefix", "type": "K"}, {"name": "offsetInBits", "type": "int"}, {"name": "lengthInBits", "type": "int"}], "body": "                                                                                               {\n            this.prefix = prefix;\n            this.offsetInBits = offsetInBits;\n            this.lengthInBits = lengthInBits;\n        }", "signature": "private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            final Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();\n            final Set<K> currentKeys = keySet();\n            while (it.hasNext()) {\n                if (currentKeys.contains(it.next().getKey())) {\n                    it.remove();\n                }\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            final Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();\n            final Set<K> currentKeys = keySet();\n            while (it.hasNext()) {\n                if (currentKeys.contains(it.next().getKey())) {\n                    it.remove();\n                }\n            }\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected Set<Map.Entry<K, V>> createEntrySet() {\n            return new PrefixRangeEntrySet(this);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Set<Map.Entry<K, V>>", "classes": []}, "name": "createEntrySet", "params": [], "body": "                                                        {\n            return new PrefixRangeEntrySet(this);\n        }", "signature": "@Override\n        protected Set<Map.Entry<K, V>> createEntrySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n                                                 final K toKey, final boolean toInclusive) {\n            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "name": "createRangeMap", "params": [{"name": "fromKey", "type": "K"}, {"name": "fromInclusive", "type": "boolean"}, {"name": "toKey", "type": "K"}, {"name": "toInclusive", "type": "boolean"}], "body": "                                                                                           {\n            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n        }", "signature": "@Override\n        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n                                                 final K toKey, final boolean toInclusive)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K firstKey() {\n            fixup();\n\n            Map.Entry<K, V> e = null;\n            if (fromKey == null) {\n                e = firstEntry();\n            } else {\n                e = higherEntry(fromKey);\n            }\n\n            final K first = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, first)) {\n                throw new NoSuchElementException();\n            }\n\n            return first;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "firstKey", "params": [], "body": "                            {\n            fixup();\n\n            Map.Entry<K, V> e = null;\n            if (fromKey == null) {\n                e = firstEntry();\n            } else {\n                e = higherEntry(fromKey);\n            }\n\n            final K first = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, first)) {\n                throw new NoSuchElementException();\n            }\n\n            return first;\n        }", "signature": "@Override\n        public K firstKey()"}, {"syntax_pass": true, "original_string": "        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\n                if (it.hasNext()) {\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>) entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>) entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }", "docstring": "\nThis method does two things. It determines the FROM\nand TO range of the {@link PrefixRangeMap} and the number\nof elements in the range. This method must be called every\ntime the {@link org.apache.commons.collections4.Trie} has changed.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "int", "classes": []}, "name": "fixup", "params": [], "body": "                            {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\n                if (it.hasNext()) {\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>) entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>) entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }", "signature": "private int fixup()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getFromKey() {\n            return fromKey;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getFromKey", "params": [], "body": "                              {\n            return fromKey;\n        }", "signature": "@Override\n        public K getFromKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getToKey() {\n            return toKey;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getToKey", "params": [], "body": "                            {\n            return toKey;\n        }", "signature": "@Override\n        public K getToKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }", "docstring": "\nReturns true if the provided Key is in the FROM range of the {@link PrefixRangeMap}.\n", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "name": "inFromRange", "params": [{"name": "key", "type": "K"}, {"name": "forceInclusive", "type": "boolean"}], "body": "                                                                                 {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }", "signature": "@Override\n        protected boolean inFromRange(final K key, final boolean forceInclusive)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected boolean inRange(final K key) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }", "docstring": "\nReturns true if this {@link PrefixRangeMap}'s key is a prefix of the provided key.\n", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "name": "inRange", "params": [{"name": "key", "type": "K"}], "body": "                                               {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }", "signature": "@Override\n        protected boolean inRange(final K key)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected boolean inRange2(final K key) {\n            return inRange(key);\n        }", "docstring": "\nSame as {@link #inRange(Object)}.\n", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "name": "inRange2", "params": [{"name": "key", "type": "K"}], "body": "                                                {\n            return inRange(key);\n        }", "signature": "@Override\n        protected boolean inRange2(final K key)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected boolean inToRange(final K key, final boolean forceInclusive) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }", "docstring": "\nReturns true if the provided Key is in the TO range of the {@link PrefixRangeMap}.\n", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "boolean", "classes": []}, "name": "inToRange", "params": [{"name": "key", "type": "K"}, {"name": "forceInclusive", "type": "boolean"}], "body": "                                                                               {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }", "signature": "@Override\n        protected boolean inToRange(final K key, final boolean forceInclusive)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isFromInclusive() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isFromInclusive", "params": [], "body": "                                         {\n            return false;\n        }", "signature": "@Override\n        public boolean isFromInclusive()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isToInclusive() {\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isToInclusive", "params": [], "body": "                                       {\n            return false;\n        }", "signature": "@Override\n        public boolean isToInclusive()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K lastKey() {\n            fixup();\n\n            Map.Entry<K, V> e = null;\n            if (toKey == null) {\n                e = lastEntry();\n            } else {\n                e = lowerEntry(toKey);\n            }\n\n            final K last = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, last)) {\n                throw new NoSuchElementException();\n            }\n\n            return last;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "lastKey", "params": [], "body": "                           {\n            fixup();\n\n            Map.Entry<K, V> e = null;\n            if (toKey == null) {\n                e = lastEntry();\n            } else {\n                e = lowerEntry(toKey);\n            }\n\n            final K last = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, last)) {\n                throw new NoSuchElementException();\n            }\n\n            return last;\n        }", "signature": "@Override\n        public K lastKey()"}]}, {"original_string": "    private final class RangeEntryMap extends AbstractRangeMap {\n\n        /** The key to start from, null if the beginning. */\n        private final K fromKey;\n\n        /** The key to end at, null if till the end. */\n        private final K toKey;\n\n        /** Whether or not the 'from' is inclusive. */\n        private final boolean fromInclusive;\n\n        /** Whether or not the 'to' is inclusive. */\n        private final boolean toInclusive;\n\n        /**\n         * Creates a {@link RangeEntryMap}.\n         */\n        protected RangeEntryMap(final K fromKey, final boolean fromInclusive,\n                                final K toKey, final boolean toInclusive) {\n\n            if (fromKey == null && toKey == null) {\n                throw new IllegalArgumentException(\"must have a from or to!\");\n            }\n\n            if (fromKey != null && toKey != null && getKeyAnalyzer().compare(fromKey, toKey) > 0) {\n                throw new IllegalArgumentException(\"fromKey > toKey\");\n            }\n\n            this.fromKey = fromKey;\n            this.fromInclusive = fromInclusive;\n            this.toKey = toKey;\n            this.toInclusive = toInclusive;\n        }\n\n        /**\n         * Creates a {@link RangeEntryMap} with the fromKey included and\n         * the toKey excluded from the range.\n         */\n        protected RangeEntryMap(final K fromKey, final K toKey) {\n            this(fromKey, true, toKey, false);\n        }\n\n        @Override\n        protected Set<Entry<K, V>> createEntrySet() {\n            return new RangeEntrySet(this);\n        }\n\n        @Override\n        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n                                                 final K toKey, final boolean toInclusive) {\n            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n        }\n\n        @Override\n        public K firstKey() {\n            Map.Entry<K, V> e = null;\n            if (fromKey == null) {\n                e = firstEntry();\n            } else if (fromInclusive) {\n                e = ceilingEntry(fromKey);\n            } else {\n                e = higherEntry(fromKey);\n            }\n\n            final K first = e != null ? e.getKey() : null;\n            if (e == null || toKey != null && !inToRange(first, false)) {\n                throw new NoSuchElementException();\n            }\n            return first;\n        }\n\n        @Override\n        public K getFromKey() {\n            return fromKey;\n        }\n\n        @Override\n        public K getToKey() {\n            return toKey;\n        }\n\n        @Override\n        public boolean isFromInclusive() {\n            return fromInclusive;\n        }\n\n        @Override\n        public boolean isToInclusive() {\n            return toInclusive;\n        }\n\n        @Override\n        public K lastKey() {\n            final Map.Entry<K, V> e;\n            if (toKey == null) {\n                e = lastEntry();\n            } else if (toInclusive) {\n                e = floorEntry(toKey);\n            } else {\n                e = lowerEntry(toKey);\n            }\n\n            final K last = e != null ? e.getKey() : null;\n            if (e == null || fromKey != null && !inFromRange(last, false)) {\n                throw new NoSuchElementException();\n            }\n            return last;\n        }\n    }", "definition": "    private final class RangeEntryMap extends AbstractRangeMap", "class_docstring": "\nA {@link AbstractRangeMap} that deals with {@link Entry}s.\n", "name": "RangeEntryMap", "super_interfaces": [], "superclasses": "AbstractRangeMap", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private final K fromKey;", "docstring": " The key to start from, null if the beginning.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "K", "name": "fromKey", "syntax_pass": true}, {"attribute_expression": "private final K toKey;", "docstring": " The key to end at, null if till the end.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "K", "name": "toKey", "syntax_pass": true}, {"attribute_expression": "private final boolean fromInclusive;", "docstring": " Whether or not the 'from' is inclusive.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "fromInclusive", "syntax_pass": true}, {"attribute_expression": "private final boolean toInclusive;", "docstring": " Whether or not the 'to' is inclusive.", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "toInclusive", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected RangeEntryMap(final K fromKey, final boolean fromInclusive,\n                                final K toKey, final boolean toInclusive) {\n\n            if (fromKey == null && toKey == null) {\n                throw new IllegalArgumentException(\"must have a from or to!\");\n            }\n\n            if (fromKey != null && toKey != null && getKeyAnalyzer().compare(fromKey, toKey) > 0) {\n                throw new IllegalArgumentException(\"fromKey > toKey\");\n            }\n\n            this.fromKey = fromKey;\n            this.fromInclusive = fromInclusive;\n            this.toKey = toKey;\n            this.toInclusive = toInclusive;\n        }", "docstring": "\nCreates a {@link RangeEntryMap}.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "RangeEntryMap", "params": [{"name": "fromKey", "type": "K"}, {"name": "fromInclusive", "type": "boolean"}, {"name": "toKey", "type": "K"}, {"name": "toInclusive", "type": "boolean"}], "body": "                                                                          {\n\n            if (fromKey == null && toKey == null) {\n                throw new IllegalArgumentException(\"must have a from or to!\");\n            }\n\n            if (fromKey != null && toKey != null && getKeyAnalyzer().compare(fromKey, toKey) > 0) {\n                throw new IllegalArgumentException(\"fromKey > toKey\");\n            }\n\n            this.fromKey = fromKey;\n            this.fromInclusive = fromInclusive;\n            this.toKey = toKey;\n            this.toInclusive = toInclusive;\n        }", "signature": "protected RangeEntryMap(final K fromKey, final boolean fromInclusive,\n                                final K toKey, final boolean toInclusive)"}, {"syntax_pass": true, "original_string": "        protected RangeEntryMap(final K fromKey, final K toKey) {\n            this(fromKey, true, toKey, false);\n        }", "docstring": "\nCreates a {@link RangeEntryMap} with the fromKey included and\nthe toKey excluded from the range.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "RangeEntryMap", "params": [{"name": "fromKey", "type": "K"}, {"name": "toKey", "type": "K"}], "body": "                                                                {\n            this(fromKey, true, toKey, false);\n        }", "signature": "protected RangeEntryMap(final K fromKey, final K toKey)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected Set<Entry<K, V>> createEntrySet() {\n            return new RangeEntrySet(this);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Set<Entry<K, V>>", "classes": []}, "name": "createEntrySet", "params": [], "body": "                                                    {\n            return new RangeEntrySet(this);\n        }", "signature": "@Override\n        protected Set<Entry<K, V>> createEntrySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n                                                 final K toKey, final boolean toInclusive) {\n            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "SortedMap<K, V>", "classes": []}, "name": "createRangeMap", "params": [{"name": "fromKey", "type": "K"}, {"name": "fromInclusive", "type": "boolean"}, {"name": "toKey", "type": "K"}, {"name": "toInclusive", "type": "boolean"}], "body": "                                                                                           {\n            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n        }", "signature": "@Override\n        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n                                                 final K toKey, final boolean toInclusive)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K firstKey() {\n            Map.Entry<K, V> e = null;\n            if (fromKey == null) {\n                e = firstEntry();\n            } else if (fromInclusive) {\n                e = ceilingEntry(fromKey);\n            } else {\n                e = higherEntry(fromKey);\n            }\n\n            final K first = e != null ? e.getKey() : null;\n            if (e == null || toKey != null && !inToRange(first, false)) {\n                throw new NoSuchElementException();\n            }\n            return first;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "firstKey", "params": [], "body": "                            {\n            Map.Entry<K, V> e = null;\n            if (fromKey == null) {\n                e = firstEntry();\n            } else if (fromInclusive) {\n                e = ceilingEntry(fromKey);\n            } else {\n                e = higherEntry(fromKey);\n            }\n\n            final K first = e != null ? e.getKey() : null;\n            if (e == null || toKey != null && !inToRange(first, false)) {\n                throw new NoSuchElementException();\n            }\n            return first;\n        }", "signature": "@Override\n        public K firstKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getFromKey() {\n            return fromKey;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getFromKey", "params": [], "body": "                              {\n            return fromKey;\n        }", "signature": "@Override\n        public K getFromKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getToKey() {\n            return toKey;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getToKey", "params": [], "body": "                            {\n            return toKey;\n        }", "signature": "@Override\n        public K getToKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isFromInclusive() {\n            return fromInclusive;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isFromInclusive", "params": [], "body": "                                         {\n            return fromInclusive;\n        }", "signature": "@Override\n        public boolean isFromInclusive()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isToInclusive() {\n            return toInclusive;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isToInclusive", "params": [], "body": "                                       {\n            return toInclusive;\n        }", "signature": "@Override\n        public boolean isToInclusive()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K lastKey() {\n            final Map.Entry<K, V> e;\n            if (toKey == null) {\n                e = lastEntry();\n            } else if (toInclusive) {\n                e = floorEntry(toKey);\n            } else {\n                e = lowerEntry(toKey);\n            }\n\n            final K last = e != null ? e.getKey() : null;\n            if (e == null || fromKey != null && !inFromRange(last, false)) {\n                throw new NoSuchElementException();\n            }\n            return last;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "lastKey", "params": [], "body": "                           {\n            final Map.Entry<K, V> e;\n            if (toKey == null) {\n                e = lastEntry();\n            } else if (toInclusive) {\n                e = floorEntry(toKey);\n            } else {\n                e = lowerEntry(toKey);\n            }\n\n            final K last = e != null ? e.getKey() : null;\n            if (e == null || fromKey != null && !inFromRange(last, false)) {\n                throw new NoSuchElementException();\n            }\n            return last;\n        }", "signature": "@Override\n        public K lastKey()"}]}, {"original_string": "    private class RangeEntrySet extends AbstractSet<Map.Entry<K, V>> {\n\n        /**\n         * An {@link Iterator} for {@link RangeEntrySet}s.\n         */\n        private final class EntryIterator extends AbstractTrieIterator<Map.Entry<K, V>> {\n\n            private final K excludedKey;\n\n            /**\n             * Creates a {@link EntryIterator}.\n             */\n            private EntryIterator(final TrieEntry<K, V> first, final TrieEntry<K, V> last) {\n                super(first);\n                this.excludedKey = last != null ? last.getKey() : null;\n            }\n\n            @Override\n            public boolean hasNext() {\n                return next != null && !compare(next.key, excludedKey);\n            }\n\n            @Override\n            public Map.Entry<K, V> next() {\n                if (next == null || compare(next.key, excludedKey)) {\n                    throw new NoSuchElementException();\n                }\n                return nextEntry();\n            }\n        }\n\n        private final AbstractRangeMap delegate;\n\n        private transient int size = -1;\n\n        private transient int expectedModCount;\n\n        /**\n         * Creates a {@link RangeEntrySet}.\n         */\n        RangeEntrySet(final AbstractRangeMap delegate) {\n            this.delegate = Objects.requireNonNull(delegate, \"delegate\");\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean contains(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            return node != null && compare(node.getValue(), entry.getValue());\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return !iterator().hasNext();\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            final K fromKey = delegate.getFromKey();\n            final K toKey = delegate.getToKey();\n\n            TrieEntry<K, V> first = null;\n            if (fromKey == null) {\n                first = firstEntry();\n            } else {\n                first = ceilingEntry(fromKey);\n            }\n\n            TrieEntry<K, V> last = null;\n            if (toKey != null) {\n                last = ceilingEntry(toKey);\n            }\n\n            return new EntryIterator(first, last);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean remove(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            if (node != null && compare(node.getValue(), entry.getValue())) {\n                removeEntry(node);\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public int size() {\n            if (size == -1 || expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                size = 0;\n\n                for (final Iterator<?> it = iterator(); it.hasNext(); it.next()) {\n                    ++size;\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n            return size;\n        }\n    }", "definition": "    private class RangeEntrySet extends AbstractSet<Map.Entry<K, V>>", "class_docstring": "\nA {@link Set} view of a {@link AbstractRangeMap}.\n", "name": "RangeEntrySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "fields": [{"attribute_expression": "private final AbstractRangeMap delegate;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractRangeMap", "name": "delegate", "syntax_pass": true}, {"attribute_expression": "private transient int size = -1;", "docstring": "", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "size = -1", "syntax_pass": true}, {"attribute_expression": "private transient int expectedModCount;", "docstring": "", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "expectedModCount", "syntax_pass": true}], "classes": [{"original_string": "        private final class EntryIterator extends AbstractTrieIterator<Map.Entry<K, V>> {\n\n            private final K excludedKey;\n\n            /**\n             * Creates a {@link EntryIterator}.\n             */\n            private EntryIterator(final TrieEntry<K, V> first, final TrieEntry<K, V> last) {\n                super(first);\n                this.excludedKey = last != null ? last.getKey() : null;\n            }\n\n            @Override\n            public boolean hasNext() {\n                return next != null && !compare(next.key, excludedKey);\n            }\n\n            @Override\n            public Map.Entry<K, V> next() {\n                if (next == null || compare(next.key, excludedKey)) {\n                    throw new NoSuchElementException();\n                }\n                return nextEntry();\n            }\n        }", "definition": "        private final class EntryIterator extends AbstractTrieIterator<Map.Entry<K, V>>", "class_docstring": "\nAn {@link Iterator} for {@link RangeEntrySet}s.\n", "name": "EntryIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private final K excludedKey;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "K", "name": "excludedKey", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "            private EntryIterator(final TrieEntry<K, V> first, final TrieEntry<K, V> last) {\n                super(first);\n                this.excludedKey = last != null ? last.getKey() : null;\n            }", "docstring": "\nCreates a {@link EntryIterator}.\n", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "EntryIterator", "params": [{"name": "first", "type": "TrieEntry<K, V>"}, {"name": "last", "type": "TrieEntry<K, V>"}], "body": "                                                                                           {\n                super(first);\n                this.excludedKey = last != null ? last.getKey() : null;\n            }", "signature": "private EntryIterator(final TrieEntry<K, V> first, final TrieEntry<K, V> last)"}, {"syntax_pass": true, "original_string": "            @Override\n            public boolean hasNext() {\n                return next != null && !compare(next.key, excludedKey);\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                     {\n                return next != null && !compare(next.key, excludedKey);\n            }", "signature": "@Override\n            public boolean hasNext()"}, {"syntax_pass": true, "original_string": "            @Override\n            public Map.Entry<K, V> next() {\n                if (next == null || compare(next.key, excludedKey)) {\n                    throw new NoSuchElementException();\n                }\n                return nextEntry();\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "next", "params": [], "body": "                                          {\n                if (next == null || compare(next.key, excludedKey)) {\n                    throw new NoSuchElementException();\n                }\n                return nextEntry();\n            }", "signature": "@Override\n            public Map.Entry<K, V> next()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        RangeEntrySet(final AbstractRangeMap delegate) {\n            this.delegate = Objects.requireNonNull(delegate, \"delegate\");\n        }", "docstring": "\nCreates a {@link RangeEntrySet}.\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "RangeEntrySet", "params": [{"name": "delegate", "type": "AbstractRangeMap"}], "body": "                                                       {\n            this.delegate = Objects.requireNonNull(delegate, \"delegate\");\n        }", "signature": "RangeEntrySet(final AbstractRangeMap delegate)"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean contains(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            return node != null && compare(node.getValue(), entry.getValue());\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        @Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "o", "type": "Object"}], "body": "                                                {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            return node != null && compare(node.getValue(), entry.getValue());\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean contains(final Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isEmpty() {\n            return !iterator().hasNext();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [], "body": "                                 {\n            return !iterator().hasNext();\n        }", "signature": "@Override\n        public boolean isEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            final K fromKey = delegate.getFromKey();\n            final K toKey = delegate.getToKey();\n\n            TrieEntry<K, V> first = null;\n            if (fromKey == null) {\n                first = firstEntry();\n            } else {\n                first = ceilingEntry(fromKey);\n            }\n\n            TrieEntry<K, V> last = null;\n            if (toKey != null) {\n                last = ceilingEntry(toKey);\n            }\n\n            return new EntryIterator(first, last);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Map.Entry<K, V>>", "classes": []}, "name": "iterator", "params": [], "body": "                                                    {\n            final K fromKey = delegate.getFromKey();\n            final K toKey = delegate.getToKey();\n\n            TrieEntry<K, V> first = null;\n            if (fromKey == null) {\n                first = firstEntry();\n            } else {\n                first = ceilingEntry(fromKey);\n            }\n\n            TrieEntry<K, V> last = null;\n            if (toKey != null) {\n                last = ceilingEntry(toKey);\n            }\n\n            return new EntryIterator(first, last);\n        }", "signature": "@Override\n        public Iterator<Map.Entry<K, V>> iterator()"}, {"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean remove(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            if (node != null && compare(node.getValue(), entry.getValue())) {\n                removeEntry(node);\n                return true;\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        @Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            if (node != null && compare(node.getValue(), entry.getValue())) {\n                removeEntry(node);\n                return true;\n            }\n            return false;\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean remove(final Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            if (size == -1 || expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                size = 0;\n\n                for (final Iterator<?> it = iterator(); it.hasNext(); it.next()) {\n                    ++size;\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n            return size;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            if (size == -1 || expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                size = 0;\n\n                for (final Iterator<?> it = iterator(); it.hasNext(); it.next()) {\n                    ++size;\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n            return size;\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    private static final class Reference<E> {\n\n        private E item;\n\n        public E get() {\n            return item;\n        }\n\n        public void set(final E item) {\n            this.item = item;\n        }\n    }", "definition": "    private static final class Reference<E>", "class_docstring": "\nA {@link Reference} allows us to return something through a Method's\nargument list. An alternative would be to an Array with a length of\none (1) but that leads to compiler warnings. Computationally and memory\nwise there's no difference (except for the need to load the\n{@link Reference} Class but that happens only once).\n", "name": "Reference", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private E item;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "E", "name": "item", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public E get() {\n            return item;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "get", "params": [], "body": "                       {\n            return item;\n        }", "signature": "public E get()"}, {"syntax_pass": true, "original_string": "        public void set(final E item) {\n            this.item = item;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "set", "params": [{"name": "item", "type": "E"}], "body": "                                      {\n            this.item = item;\n        }", "signature": "public void set(final E item)"}]}, {"original_string": "    protected static class TrieEntry<K, V> extends BasicEntry<K, V> {\n\n        private static final long serialVersionUID = 4596023148184140013L;\n\n        /** The index this entry is comparing. */\n        protected int bitIndex;\n\n        /** The parent of this entry. */\n        protected TrieEntry<K, V> parent;\n\n        /** The left child of this entry. */\n        protected TrieEntry<K, V> left;\n\n        /** The right child of this entry. */\n        protected TrieEntry<K, V> right;\n\n        /** The entry who uplinks to this entry. */\n        protected TrieEntry<K, V> predecessor;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param key The entry's key.\n         * @param value The entry's value.\n         * @param bitIndex The entry's bitIndex.\n         */\n        public TrieEntry(final K key, final V value, final int bitIndex) {\n            super(key, value);\n            this.bitIndex = bitIndex;\n            this.parent = null;\n            this.left = this;\n            this.right = null;\n            this.predecessor = this;\n        }\n\n        /**\n         * Whether the entry is storing a key.\n         * Only the root can potentially be empty, all other\n         * nodes must have a key.\n         *\n         * @return Whether the entry is storing a key\n         */\n        public boolean isEmpty() {\n            return key == null;\n        }\n\n        /**\n         * Whether the left or right child is a loopback.\n         *\n         * @return Whether the left or right child is a loopback.\n         */\n        public boolean isExternalNode() {\n            return !isInternalNode();\n        }\n\n        /**\n         * Tests that neither the left nor right child is a loopback.\n         *\n         * @return That neither the left nor right child is a loopback.\n         */\n        public boolean isInternalNode() {\n            return left != this && right != this;\n        }\n\n        @Override\n        public String toString() {\n            final StringBuilder buffer = new StringBuilder();\n\n            if (bitIndex == -1) {\n                buffer.append(\"RootEntry(\");\n            } else {\n                buffer.append(\"Entry(\");\n            }\n\n            buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\n            buffer.append(\"value=\").append(getValue()).append(\", \");\n            //buffer.append(\"bitIndex=\").append(bitIndex).append(\", \");\n\n            if (parent != null) {\n                if (parent.bitIndex == -1) {\n                    buffer.append(\"parent=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"parent=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (left != null) {\n                if (left.bitIndex == -1) {\n                    buffer.append(\"left=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"left=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (right != null) {\n                if (right.bitIndex == -1) {\n                    buffer.append(\"right=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"right=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (predecessor != null) {\n                if (predecessor.bitIndex == -1) {\n                    buffer.append(\"predecessor=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\").\n                           append(predecessor.bitIndex).append(\"]\");\n                }\n            }\n\n            buffer.append(\")\");\n            return buffer.toString();\n        }\n    }", "definition": "    protected static class TrieEntry<K, V> extends BasicEntry<K, V>", "class_docstring": "\nA {@link org.apache.commons.collections4.Trie} is a set of {@link TrieEntry} nodes.\n\n@param <K> the key type.\n@param <V> the value type.\n", "name": "TrieEntry", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 4596023148184140013L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 4596023148184140013L", "syntax_pass": true}, {"attribute_expression": "protected int bitIndex;", "docstring": " The index this entry is comparing.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "bitIndex", "syntax_pass": true}, {"attribute_expression": "protected TrieEntry<K, V> parent;", "docstring": " The parent of this entry.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "TrieEntry<K, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "protected TrieEntry<K, V> left;", "docstring": " The left child of this entry.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "TrieEntry<K, V>", "name": "left", "syntax_pass": true}, {"attribute_expression": "protected TrieEntry<K, V> right;", "docstring": " The right child of this entry.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "TrieEntry<K, V>", "name": "right", "syntax_pass": true}, {"attribute_expression": "protected TrieEntry<K, V> predecessor;", "docstring": " The entry who uplinks to this entry.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "TrieEntry<K, V>", "name": "predecessor", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public TrieEntry(final K key, final V value, final int bitIndex) {\n            super(key, value);\n            this.bitIndex = bitIndex;\n            this.parent = null;\n            this.left = this;\n            this.right = null;\n            this.predecessor = this;\n        }", "docstring": "\nConstructs a new instance.\n\n@param key The entry's key.\n@param value The entry's value.\n@param bitIndex The entry's bitIndex.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "TrieEntry", "params": [{"name": "key", "type": "K"}, {"name": "value", "type": "V"}, {"name": "bitIndex", "type": "int"}], "body": "                                                                         {\n            super(key, value);\n            this.bitIndex = bitIndex;\n            this.parent = null;\n            this.left = this;\n            this.right = null;\n            this.predecessor = this;\n        }", "signature": "public TrieEntry(final K key, final V value, final int bitIndex)"}, {"syntax_pass": true, "original_string": "        public boolean isEmpty() {\n            return key == null;\n        }", "docstring": "\nWhether the entry is storing a key.\nOnly the root can potentially be empty, all other\nnodes must have a key.\n\n@return Whether the entry is storing a key\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [], "body": "                                 {\n            return key == null;\n        }", "signature": "public boolean isEmpty()"}, {"syntax_pass": true, "original_string": "        public boolean isExternalNode() {\n            return !isInternalNode();\n        }", "docstring": "\nWhether the left or right child is a loopback.\n\n@return Whether the left or right child is a loopback.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isExternalNode", "params": [], "body": "                                        {\n            return !isInternalNode();\n        }", "signature": "public boolean isExternalNode()"}, {"syntax_pass": true, "original_string": "        public boolean isInternalNode() {\n            return left != this && right != this;\n        }", "docstring": "\nTests that neither the left nor right child is a loopback.\n\n@return That neither the left nor right child is a loopback.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isInternalNode", "params": [], "body": "                                        {\n            return left != this && right != this;\n        }", "signature": "public boolean isInternalNode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            final StringBuilder buffer = new StringBuilder();\n\n            if (bitIndex == -1) {\n                buffer.append(\"RootEntry(\");\n            } else {\n                buffer.append(\"Entry(\");\n            }\n\n            buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\n            buffer.append(\"value=\").append(getValue()).append(\", \");\n            //buffer.append(\"bitIndex=\").append(bitIndex).append(\", \");\n\n            if (parent != null) {\n                if (parent.bitIndex == -1) {\n                    buffer.append(\"parent=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"parent=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (left != null) {\n                if (left.bitIndex == -1) {\n                    buffer.append(\"left=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"left=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (right != null) {\n                if (right.bitIndex == -1) {\n                    buffer.append(\"right=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"right=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (predecessor != null) {\n                if (predecessor.bitIndex == -1) {\n                    buffer.append(\"predecessor=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\").\n                           append(predecessor.bitIndex).append(\"]\");\n                }\n            }\n\n            buffer.append(\")\");\n            return buffer.toString();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            final StringBuilder buffer = new StringBuilder();\n\n            if (bitIndex == -1) {\n                buffer.append(\"RootEntry(\");\n            } else {\n                buffer.append(\"Entry(\");\n            }\n\n            buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\n            buffer.append(\"value=\").append(getValue()).append(\", \");\n            //buffer.append(\"bitIndex=\").append(bitIndex).append(\", \");\n\n            if (parent != null) {\n                if (parent.bitIndex == -1) {\n                    buffer.append(\"parent=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"parent=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (left != null) {\n                if (left.bitIndex == -1) {\n                    buffer.append(\"left=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"left=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (right != null) {\n                if (right.bitIndex == -1) {\n                    buffer.append(\"right=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"right=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (predecessor != null) {\n                if (predecessor.bitIndex == -1) {\n                    buffer.append(\"predecessor=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\").\n                           append(predecessor.bitIndex).append(\"]\");\n                }\n            }\n\n            buffer.append(\")\");\n            return buffer.toString();\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    private final class TrieMapIterator extends AbstractTrieIterator<K> implements OrderedMapIterator<K, V> {\n\n        protected TrieEntry<K, V> previous; // the previous node to return\n\n        @Override\n        public K getKey() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getValue();\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return previous != null;\n        }\n\n        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }\n\n        @Override\n        protected TrieEntry<K, V> nextEntry() {\n            final TrieEntry<K, V> nextEntry = super.nextEntry();\n            previous = nextEntry;\n            return nextEntry;\n        }\n\n        @Override\n        public K previous() {\n            return previousEntry().getKey();\n        }\n\n        protected TrieEntry<K, V> previousEntry() {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> e = previous;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            previous = AbstractPatriciaTrie.this.previousEntry(e);\n            next = current;\n            current = e;\n            return current;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.setValue(value);\n        }\n\n    }", "definition": "    private final class TrieMapIterator extends AbstractTrieIterator<K> implements OrderedMapIterator<K, V>", "class_docstring": "\nAn {@link OrderedMapIterator} for a {@link org.apache.commons.collections4.Trie}.\n", "name": "TrieMapIterator", "super_interfaces": ["OrderedMapIterator<K, V>"], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "protected TrieEntry<K, V> previous;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "TrieEntry<K, V>", "name": "previous", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getKey();\n        }", "docstring": " the previous node to return", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getKey();\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getValue();\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasPrevious() {\n            return previous != null;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasPrevious", "params": [], "body": "                                     {\n            return previous != null;\n        }", "signature": "@Override\n        public boolean hasPrevious()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return nextEntry().getKey();\n        }", "signature": "@Override\n        public K next()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected TrieEntry<K, V> nextEntry() {\n            final TrieEntry<K, V> nextEntry = super.nextEntry();\n            previous = nextEntry;\n            return nextEntry;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "TrieEntry<K, V>", "classes": []}, "name": "nextEntry", "params": [], "body": "                                              {\n            final TrieEntry<K, V> nextEntry = super.nextEntry();\n            previous = nextEntry;\n            return nextEntry;\n        }", "signature": "@Override\n        protected TrieEntry<K, V> nextEntry()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K previous() {\n            return previousEntry().getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            return previousEntry().getKey();\n        }", "signature": "@Override\n        public K previous()"}, {"syntax_pass": true, "original_string": "        protected TrieEntry<K, V> previousEntry() {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> e = previous;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            previous = AbstractPatriciaTrie.this.previousEntry(e);\n            next = current;\n            current = e;\n            return current;\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "TrieEntry<K, V>", "classes": []}, "name": "previousEntry", "params": [], "body": "                                                  {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> e = previous;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            previous = AbstractPatriciaTrie.this.previousEntry(e);\n            next = current;\n            current = e;\n            return current;\n        }", "signature": "protected TrieEntry<K, V> previousEntry()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.setValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.setValue(value);\n        }", "signature": "@Override\n        public V setValue(final V value)"}]}, {"original_string": "    private final class Values extends AbstractCollection<V> {\n\n        /**\n         * An {@link Iterator} that returns Value Objects.\n         */\n        private final class ValueIterator extends AbstractTrieIterator<V> {\n            @Override\n            public V next() {\n                return nextEntry().getValue();\n            }\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            return containsValue(o);\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return new ValueIterator();\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            for (final Iterator<V> it = iterator(); it.hasNext(); ) {\n                final V value = it.next();\n                if (compare(value, o)) {\n                    it.remove();\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n    }", "definition": "    private final class Values extends AbstractCollection<V>", "class_docstring": "\nThis is a value view of the {@link org.apache.commons.collections4.Trie} as returned by {@link Map#values()}.\n", "name": "Values", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": [{"original_string": "        private final class ValueIterator extends AbstractTrieIterator<V> {\n            @Override\n            public V next() {\n                return nextEntry().getValue();\n            }\n        }", "definition": "        private final class ValueIterator extends AbstractTrieIterator<V>", "class_docstring": "\nAn {@link Iterator} that returns Value Objects.\n", "name": "ValueIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "            @Override\n            public V next() {\n                return nextEntry().getValue();\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "next", "params": [], "body": "                            {\n                return nextEntry().getValue();\n            }", "signature": "@Override\n            public V next()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            AbstractPatriciaTrie.this.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object o) {\n            return containsValue(o);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "o", "type": "Object"}], "body": "                                                {\n            return containsValue(o);\n        }", "signature": "@Override\n        public boolean contains(final Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<V> iterator() {\n            return new ValueIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<V>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return new ValueIterator();\n        }", "signature": "@Override\n        public Iterator<V> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object o) {\n            for (final Iterator<V> it = iterator(); it.hasNext(); ) {\n                final V value = it.next();\n                if (compare(value, o)) {\n                    it.remove();\n                    return true;\n                }\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n            for (final Iterator<V> it = iterator(); it.hasNext(); ) {\n                final V value = it.next();\n                if (compare(value, o)) {\n                    it.remove();\n                    return true;\n                }\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean remove(final Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return AbstractPatriciaTrie.this.size();\n        }", "signature": "@Override\n        public int size()"}]}], "class_docstring": "\nThis class implements the base PATRICIA algorithm and everything that\nis related to the {@link Map} interface.\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.0\n", "original_string": "public abstract class AbstractPatriciaTrie<K, V> extends AbstractBitwiseTrie<K, V> {\n\n    /**\n     * A range view of the {@link org.apache.commons.collections4.Trie}.\n     */\n    private abstract class AbstractRangeMap extends AbstractMap<K, V>\n            implements SortedMap<K, V> {\n\n        /** The {@link #entrySet()} view. */\n        private transient volatile Set<Map.Entry<K, V>> entrySet;\n\n        @Override\n        public Comparator<? super K> comparator() {\n            return AbstractPatriciaTrie.this.comparator();\n        }\n\n        @Override\n        public boolean containsKey(final Object key) {\n            if (!inRange(castKey(key))) {\n                return false;\n            }\n\n            return AbstractPatriciaTrie.this.containsKey(key);\n        }\n\n        /**\n         * Creates and returns an {@link #entrySet()} view of the {@link AbstractRangeMap}.\n         */\n        protected abstract Set<Map.Entry<K, V>> createEntrySet();\n\n        /**\n         * Creates and returns a sub-range view of the current {@link AbstractRangeMap}.\n         */\n        protected abstract SortedMap<K, V> createRangeMap(K fromKey, boolean fromInclusive,\n                                                          K toKey, boolean toInclusive);\n\n        @Override\n        public Set<Map.Entry<K, V>> entrySet() {\n            if (entrySet == null) {\n                entrySet = createEntrySet();\n            }\n            return entrySet;\n        }\n\n        @Override\n        public V get(final Object key) {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.get(key);\n        }\n\n        /**\n         * Returns the FROM Key.\n         */\n        protected abstract K getFromKey();\n\n        /**\n         * Returns the TO Key.\n         */\n        protected abstract K getToKey();\n\n        @Override\n        public SortedMap<K, V> headMap(final K toKey) {\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n            return createRangeMap(getFromKey(), isFromInclusive(), toKey, isToInclusive());\n        }\n\n        /**\n         * Returns true if the provided key is in the FROM range of the {@link AbstractRangeMap}.\n         */\n        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n            final K fromKey = getFromKey();\n            final boolean fromInclusive = isFromInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, fromKey);\n            if (fromInclusive || forceInclusive) {\n                return ret >= 0;\n            }\n            return ret > 0;\n        }\n\n        /**\n         * Returns true if the provided key is greater than TO and less than FROM.\n         */\n        protected boolean inRange(final K key) {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, false));\n        }\n\n        /**\n         * This form allows the high endpoint (as well as all legit keys).\n         */\n        protected boolean inRange2(final K key) {\n            final K fromKey = getFromKey();\n            final K toKey = getToKey();\n\n            return (fromKey == null || inFromRange(key, false)) && (toKey == null || inToRange(key, true));\n        }\n\n        /**\n         * Returns true if the provided key is in the TO range of the {@link AbstractRangeMap}.\n         */\n        protected boolean inToRange(final K key, final boolean forceInclusive) {\n            final K toKey = getToKey();\n            final boolean toInclusive = isToInclusive();\n\n            final int ret = getKeyAnalyzer().compare(key, toKey);\n            if (toInclusive || forceInclusive) {\n                return ret <= 0;\n            }\n            return ret < 0;\n        }\n\n        /**\n         * Whether or not the {@link #getFromKey()} is in the range.\n         */\n        protected abstract boolean isFromInclusive();\n\n        /**\n         * Whether or not the {@link #getToKey()} is in the range.\n         */\n        protected abstract boolean isToInclusive();\n\n        @Override\n        public V put(final K key, final V value) {\n            if (!inRange(key)) {\n                throw new IllegalArgumentException(\"Key is out of range: \" + key);\n            }\n            return AbstractPatriciaTrie.this.put(key, value);\n        }\n\n        @Override\n        public V remove(final Object key) {\n            if (!inRange(castKey(key))) {\n                return null;\n            }\n\n            return AbstractPatriciaTrie.this.remove(key);\n        }\n\n        @Override\n        public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n\n            if (!inRange2(toKey)) {\n                throw new IllegalArgumentException(\"ToKey is out of range: \" + toKey);\n            }\n\n            return createRangeMap(fromKey, isFromInclusive(), toKey, isToInclusive());\n        }\n\n        @Override\n        public SortedMap<K, V> tailMap(final K fromKey) {\n            if (!inRange2(fromKey)) {\n                throw new IllegalArgumentException(\"FromKey is out of range: \" + fromKey);\n            }\n            return createRangeMap(fromKey, isFromInclusive(), getToKey(), isToInclusive());\n        }\n    }\n\n    /**\n     * An iterator for the entries.\n     */\n    abstract class AbstractTrieIterator<E> implements Iterator<E> {\n\n        /** For fast-fail. */\n        protected int expectedModCount = AbstractPatriciaTrie.this.modCount;\n\n        protected TrieEntry<K, V> next; // the next node to return\n        protected TrieEntry<K, V> current; // the current entry we're on\n\n        /**\n         * Starts iteration from the root.\n         */\n        protected AbstractTrieIterator() {\n            next = AbstractPatriciaTrie.this.nextEntry(null);\n        }\n\n        /**\n         * Starts iteration at the given entry.\n         */\n        protected AbstractTrieIterator(final TrieEntry<K, V> firstEntry) {\n            next = firstEntry;\n        }\n\n        /**\n         * @see PatriciaTrie#nextEntry(TrieEntry)\n         */\n        protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n            return AbstractPatriciaTrie.this.nextEntry(prior);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return next != null;\n        }\n\n        /**\n         * Returns the next {@link TrieEntry}.\n         */\n        protected TrieEntry<K, V> nextEntry() {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> e = next;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            next = findNext(e);\n            current = e;\n            return e;\n        }\n\n        @Override\n        public void remove() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> node = current;\n            current = null;\n            AbstractPatriciaTrie.this.removeEntry(node);\n\n            expectedModCount = AbstractPatriciaTrie.this.modCount;\n        }\n    }\n\n    /**\n     * This is an entry set view of the {@link org.apache.commons.collections4.Trie} as returned by {@link Map#entrySet()}.\n     */\n    private final class EntrySet extends AbstractSet<Map.Entry<K, V>> {\n\n        /**\n         * An {@link Iterator} that returns {@link Entry} Objects.\n         */\n        private final class EntryIterator extends AbstractTrieIterator<Map.Entry<K, V>> {\n            @Override\n            public Map.Entry<K, V> next() {\n                return nextEntry();\n            }\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> candidate = getEntry(((Map.Entry<?, ?>) o).getKey());\n            return candidate != null && candidate.equals(o);\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return new EntryIterator();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            if (!contains(obj)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            AbstractPatriciaTrie.this.remove(entry.getKey());\n            return true;\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n    }\n    /**\n     * This is a key set view of the {@link org.apache.commons.collections4.Trie} as returned by {@link Map#keySet()}.\n     */\n    private final class KeySet extends AbstractSet<K> {\n\n        /**\n         * An {@link Iterator} that returns Key Objects.\n         */\n        private final class KeyIterator extends AbstractTrieIterator<K> {\n            @Override\n            public K next() {\n                return nextEntry().getKey();\n            }\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            return containsKey(o);\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return new KeyIterator();\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            final int size = size();\n            AbstractPatriciaTrie.this.remove(o);\n            return size != size();\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n    }\n    /**\n     * A prefix {@link RangeEntrySet} view of the {@link org.apache.commons.collections4.Trie}.\n     */\n    private final class PrefixRangeEntrySet extends RangeEntrySet {\n\n        /**\n         * An {@link Iterator} for iterating over a prefix search.\n         */\n        private final class EntryIterator extends AbstractTrieIterator<Map.Entry<K, V>> {\n\n            // values to reset the subtree if we remove it.\n            private final K prefix;\n            private final int offset;\n            private final int lengthInBits;\n            private boolean lastOne;\n\n            private TrieEntry<K, V> subtree; // the subtree to search within\n\n            /**\n             * Starts iteration at the given entry &amp; search only\n             * within the given subtree.\n             */\n            EntryIterator(final TrieEntry<K, V> startScan, final K prefix,\n                    final int offset, final int lengthInBits) {\n                subtree = startScan;\n                next = AbstractPatriciaTrie.this.followLeft(startScan);\n                this.prefix = prefix;\n                this.offset = offset;\n                this.lengthInBits = lengthInBits;\n            }\n\n            @Override\n            protected TrieEntry<K, V> findNext(final TrieEntry<K, V> prior) {\n                return AbstractPatriciaTrie.this.nextEntryInSubtree(prior, subtree);\n            }\n\n            @Override\n            public Map.Entry<K, V> next() {\n                final Map.Entry<K, V> entry = nextEntry();\n                if (lastOne) {\n                    next = null;\n                }\n                return entry;\n            }\n\n            @Override\n            public void remove() {\n                // If the current entry we're removing is the subtree\n                // then we need to find a new subtree parent.\n                boolean needsFixing = false;\n                final int bitIdx = subtree.bitIndex;\n                if (current == subtree) {\n                    needsFixing = true;\n                }\n\n                super.remove();\n\n                // If the subtree changed its bitIndex or we\n                // removed the old subtree, get a new one.\n                if (bitIdx != subtree.bitIndex || needsFixing) {\n                    subtree = subtree(prefix, offset, lengthInBits);\n                }\n\n                // If the subtree's bitIndex is less than the\n                // length of our prefix, it's the last item\n                // in the prefix tree.\n                if (lengthInBits >= subtree.bitIndex) {\n                    lastOne = true;\n                }\n            }\n        }\n\n        /**\n         * An {@link Iterator} that holds a single {@link TrieEntry}.\n         */\n        private final class SingletonIterator implements Iterator<Map.Entry<K, V>> {\n\n            private final TrieEntry<K, V> entry;\n\n            private int hit;\n\n            SingletonIterator(final TrieEntry<K, V> entry) {\n                this.entry = entry;\n            }\n\n            @Override\n            public boolean hasNext() {\n                return hit == 0;\n            }\n\n            @Override\n            public Map.Entry<K, V> next() {\n                if (hit != 0) {\n                    throw new NoSuchElementException();\n                }\n\n                ++hit;\n                return entry;\n            }\n\n            @Override\n            public void remove() {\n                if (hit != 1) {\n                    throw new IllegalStateException();\n                }\n\n                ++hit;\n                AbstractPatriciaTrie.this.removeEntry(entry);\n            }\n        }\n\n        private final PrefixRangeMap delegate;\n\n        private TrieEntry<K, V> prefixStart;\n\n        private int expectedModCount;\n\n        /**\n         * Creates a {@link PrefixRangeEntrySet}.\n         */\n        PrefixRangeEntrySet(final PrefixRangeMap delegate) {\n            super(delegate);\n            this.delegate = delegate;\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            if (AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                prefixStart = subtree(delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            if (prefixStart == null) {\n                final Set<Map.Entry<K, V>> empty = Collections.emptySet();\n                return empty.iterator();\n            }\n            if (delegate.lengthInBits > prefixStart.bitIndex) {\n                return new SingletonIterator(prefixStart);\n            }\n            return new EntryIterator(prefixStart, delegate.prefix, delegate.offsetInBits, delegate.lengthInBits);\n        }\n\n        @Override\n        public int size() {\n            return delegate.fixup();\n        }\n    }\n\n    /**\n     * A submap used for prefix views over the {@link org.apache.commons.collections4.Trie}.\n     */\n    private final class PrefixRangeMap extends AbstractRangeMap {\n\n        private final K prefix;\n\n        private final int offsetInBits;\n\n        private final int lengthInBits;\n\n        private K fromKey;\n\n        private K toKey;\n\n        private transient int expectedModCount;\n\n        private int size = -1;\n\n        /**\n         * Creates a {@link PrefixRangeMap}.\n         */\n        private PrefixRangeMap(final K prefix, final int offsetInBits, final int lengthInBits) {\n            this.prefix = prefix;\n            this.offsetInBits = offsetInBits;\n            this.lengthInBits = lengthInBits;\n        }\n\n        @Override\n        public void clear() {\n            final Iterator<Map.Entry<K, V>> it = AbstractPatriciaTrie.this.entrySet().iterator();\n            final Set<K> currentKeys = keySet();\n            while (it.hasNext()) {\n                if (currentKeys.contains(it.next().getKey())) {\n                    it.remove();\n                }\n            }\n        }\n\n        @Override\n        protected Set<Map.Entry<K, V>> createEntrySet() {\n            return new PrefixRangeEntrySet(this);\n        }\n\n        @Override\n        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n                                                 final K toKey, final boolean toInclusive) {\n            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n        }\n\n        @Override\n        public K firstKey() {\n            fixup();\n\n            Map.Entry<K, V> e = null;\n            if (fromKey == null) {\n                e = firstEntry();\n            } else {\n                e = higherEntry(fromKey);\n            }\n\n            final K first = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, first)) {\n                throw new NoSuchElementException();\n            }\n\n            return first;\n        }\n\n        /**\n         * This method does two things. It determines the FROM\n         * and TO range of the {@link PrefixRangeMap} and the number\n         * of elements in the range. This method must be called every\n         * time the {@link org.apache.commons.collections4.Trie} has changed.\n         */\n        private int fixup() {\n            // The trie has changed since we last found our toKey / fromKey\n            if (size == - 1 || AbstractPatriciaTrie.this.modCount != expectedModCount) {\n                final Iterator<Map.Entry<K, V>> it = super.entrySet().iterator();\n                size = 0;\n\n                Map.Entry<K, V> entry = null;\n                if (it.hasNext()) {\n                    entry = it.next();\n                    size = 1;\n                }\n\n                fromKey = entry == null ? null : entry.getKey();\n                if (fromKey != null) {\n                    final TrieEntry<K, V> prior = previousEntry((TrieEntry<K, V>) entry);\n                    fromKey = prior == null ? null : prior.getKey();\n                }\n\n                toKey = fromKey;\n\n                while (it.hasNext()) {\n                    ++size;\n                    entry = it.next();\n                }\n\n                toKey = entry == null ? null : entry.getKey();\n\n                if (toKey != null) {\n                    entry = nextEntry((TrieEntry<K, V>) entry);\n                    toKey = entry == null ? null : entry.getKey();\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n\n            return size;\n        }\n\n        @Override\n        public K getFromKey() {\n            return fromKey;\n        }\n\n        @Override\n        public K getToKey() {\n            return toKey;\n        }\n\n        /**\n         * Returns true if the provided Key is in the FROM range of the {@link PrefixRangeMap}.\n         */\n        @Override\n        protected boolean inFromRange(final K key, final boolean forceInclusive) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        /**\n         * Returns true if this {@link PrefixRangeMap}'s key is a prefix of the provided key.\n         */\n        @Override\n        protected boolean inRange(final K key) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        /**\n         * Same as {@link #inRange(Object)}.\n         */\n        @Override\n        protected boolean inRange2(final K key) {\n            return inRange(key);\n        }\n\n        /**\n         * Returns true if the provided Key is in the TO range of the {@link PrefixRangeMap}.\n         */\n        @Override\n        protected boolean inToRange(final K key, final boolean forceInclusive) {\n            return getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, key);\n        }\n\n        @Override\n        public boolean isFromInclusive() {\n            return false;\n        }\n\n        @Override\n        public boolean isToInclusive() {\n            return false;\n        }\n\n        @Override\n        public K lastKey() {\n            fixup();\n\n            Map.Entry<K, V> e = null;\n            if (toKey == null) {\n                e = lastEntry();\n            } else {\n                e = lowerEntry(toKey);\n            }\n\n            final K last = e != null ? e.getKey() : null;\n            if (e == null || !getKeyAnalyzer().isPrefix(prefix, offsetInBits, lengthInBits, last)) {\n                throw new NoSuchElementException();\n            }\n\n            return last;\n        }\n    }\n\n    /**\n     * A {@link AbstractRangeMap} that deals with {@link Entry}s.\n     */\n    private final class RangeEntryMap extends AbstractRangeMap {\n\n        /** The key to start from, null if the beginning. */\n        private final K fromKey;\n\n        /** The key to end at, null if till the end. */\n        private final K toKey;\n\n        /** Whether or not the 'from' is inclusive. */\n        private final boolean fromInclusive;\n\n        /** Whether or not the 'to' is inclusive. */\n        private final boolean toInclusive;\n\n        /**\n         * Creates a {@link RangeEntryMap}.\n         */\n        protected RangeEntryMap(final K fromKey, final boolean fromInclusive,\n                                final K toKey, final boolean toInclusive) {\n\n            if (fromKey == null && toKey == null) {\n                throw new IllegalArgumentException(\"must have a from or to!\");\n            }\n\n            if (fromKey != null && toKey != null && getKeyAnalyzer().compare(fromKey, toKey) > 0) {\n                throw new IllegalArgumentException(\"fromKey > toKey\");\n            }\n\n            this.fromKey = fromKey;\n            this.fromInclusive = fromInclusive;\n            this.toKey = toKey;\n            this.toInclusive = toInclusive;\n        }\n\n        /**\n         * Creates a {@link RangeEntryMap} with the fromKey included and\n         * the toKey excluded from the range.\n         */\n        protected RangeEntryMap(final K fromKey, final K toKey) {\n            this(fromKey, true, toKey, false);\n        }\n\n        @Override\n        protected Set<Entry<K, V>> createEntrySet() {\n            return new RangeEntrySet(this);\n        }\n\n        @Override\n        protected SortedMap<K, V> createRangeMap(final K fromKey, final boolean fromInclusive,\n                                                 final K toKey, final boolean toInclusive) {\n            return new RangeEntryMap(fromKey, fromInclusive, toKey, toInclusive);\n        }\n\n        @Override\n        public K firstKey() {\n            Map.Entry<K, V> e = null;\n            if (fromKey == null) {\n                e = firstEntry();\n            } else if (fromInclusive) {\n                e = ceilingEntry(fromKey);\n            } else {\n                e = higherEntry(fromKey);\n            }\n\n            final K first = e != null ? e.getKey() : null;\n            if (e == null || toKey != null && !inToRange(first, false)) {\n                throw new NoSuchElementException();\n            }\n            return first;\n        }\n\n        @Override\n        public K getFromKey() {\n            return fromKey;\n        }\n\n        @Override\n        public K getToKey() {\n            return toKey;\n        }\n\n        @Override\n        public boolean isFromInclusive() {\n            return fromInclusive;\n        }\n\n        @Override\n        public boolean isToInclusive() {\n            return toInclusive;\n        }\n\n        @Override\n        public K lastKey() {\n            final Map.Entry<K, V> e;\n            if (toKey == null) {\n                e = lastEntry();\n            } else if (toInclusive) {\n                e = floorEntry(toKey);\n            } else {\n                e = lowerEntry(toKey);\n            }\n\n            final K last = e != null ? e.getKey() : null;\n            if (e == null || fromKey != null && !inFromRange(last, false)) {\n                throw new NoSuchElementException();\n            }\n            return last;\n        }\n    }\n\n    /**\n     * A {@link Set} view of a {@link AbstractRangeMap}.\n     */\n    private class RangeEntrySet extends AbstractSet<Map.Entry<K, V>> {\n\n        /**\n         * An {@link Iterator} for {@link RangeEntrySet}s.\n         */\n        private final class EntryIterator extends AbstractTrieIterator<Map.Entry<K, V>> {\n\n            private final K excludedKey;\n\n            /**\n             * Creates a {@link EntryIterator}.\n             */\n            private EntryIterator(final TrieEntry<K, V> first, final TrieEntry<K, V> last) {\n                super(first);\n                this.excludedKey = last != null ? last.getKey() : null;\n            }\n\n            @Override\n            public boolean hasNext() {\n                return next != null && !compare(next.key, excludedKey);\n            }\n\n            @Override\n            public Map.Entry<K, V> next() {\n                if (next == null || compare(next.key, excludedKey)) {\n                    throw new NoSuchElementException();\n                }\n                return nextEntry();\n            }\n        }\n\n        private final AbstractRangeMap delegate;\n\n        private transient int size = -1;\n\n        private transient int expectedModCount;\n\n        /**\n         * Creates a {@link RangeEntrySet}.\n         */\n        RangeEntrySet(final AbstractRangeMap delegate) {\n            this.delegate = Objects.requireNonNull(delegate, \"delegate\");\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean contains(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            return node != null && compare(node.getValue(), entry.getValue());\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return !iterator().hasNext();\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            final K fromKey = delegate.getFromKey();\n            final K toKey = delegate.getToKey();\n\n            TrieEntry<K, V> first = null;\n            if (fromKey == null) {\n                first = firstEntry();\n            } else {\n                first = ceilingEntry(fromKey);\n            }\n\n            TrieEntry<K, V> last = null;\n            if (toKey != null) {\n                last = ceilingEntry(toKey);\n            }\n\n            return new EntryIterator(first, last);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public boolean remove(final Object o) {\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<K, V> entry = (Map.Entry<K, V>) o;\n            final K key = entry.getKey();\n            if (!delegate.inRange(key)) {\n                return false;\n            }\n\n            final TrieEntry<K, V> node = getEntry(key);\n            if (node != null && compare(node.getValue(), entry.getValue())) {\n                removeEntry(node);\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public int size() {\n            if (size == -1 || expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                size = 0;\n\n                for (final Iterator<?> it = iterator(); it.hasNext(); it.next()) {\n                    ++size;\n                }\n\n                expectedModCount = AbstractPatriciaTrie.this.modCount;\n            }\n            return size;\n        }\n    }\n\n    /**\n     * A {@link Reference} allows us to return something through a Method's\n     * argument list. An alternative would be to an Array with a length of\n     * one (1) but that leads to compiler warnings. Computationally and memory\n     * wise there's no difference (except for the need to load the\n     * {@link Reference} Class but that happens only once).\n     */\n    private static final class Reference<E> {\n\n        private E item;\n\n        public E get() {\n            return item;\n        }\n\n        public void set(final E item) {\n            this.item = item;\n        }\n    }\n\n    /**\n     * A {@link org.apache.commons.collections4.Trie} is a set of {@link TrieEntry} nodes.\n     *\n     * @param <K> the key type.\n     * @param <V> the value type.\n     */\n    protected static class TrieEntry<K, V> extends BasicEntry<K, V> {\n\n        private static final long serialVersionUID = 4596023148184140013L;\n\n        /** The index this entry is comparing. */\n        protected int bitIndex;\n\n        /** The parent of this entry. */\n        protected TrieEntry<K, V> parent;\n\n        /** The left child of this entry. */\n        protected TrieEntry<K, V> left;\n\n        /** The right child of this entry. */\n        protected TrieEntry<K, V> right;\n\n        /** The entry who uplinks to this entry. */\n        protected TrieEntry<K, V> predecessor;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param key The entry's key.\n         * @param value The entry's value.\n         * @param bitIndex The entry's bitIndex.\n         */\n        public TrieEntry(final K key, final V value, final int bitIndex) {\n            super(key, value);\n            this.bitIndex = bitIndex;\n            this.parent = null;\n            this.left = this;\n            this.right = null;\n            this.predecessor = this;\n        }\n\n        /**\n         * Whether the entry is storing a key.\n         * Only the root can potentially be empty, all other\n         * nodes must have a key.\n         *\n         * @return Whether the entry is storing a key\n         */\n        public boolean isEmpty() {\n            return key == null;\n        }\n\n        /**\n         * Whether the left or right child is a loopback.\n         *\n         * @return Whether the left or right child is a loopback.\n         */\n        public boolean isExternalNode() {\n            return !isInternalNode();\n        }\n\n        /**\n         * Tests that neither the left nor right child is a loopback.\n         *\n         * @return That neither the left nor right child is a loopback.\n         */\n        public boolean isInternalNode() {\n            return left != this && right != this;\n        }\n\n        @Override\n        public String toString() {\n            final StringBuilder buffer = new StringBuilder();\n\n            if (bitIndex == -1) {\n                buffer.append(\"RootEntry(\");\n            } else {\n                buffer.append(\"Entry(\");\n            }\n\n            buffer.append(\"key=\").append(getKey()).append(\" [\").append(bitIndex).append(\"], \");\n            buffer.append(\"value=\").append(getValue()).append(\", \");\n            //buffer.append(\"bitIndex=\").append(bitIndex).append(\", \");\n\n            if (parent != null) {\n                if (parent.bitIndex == -1) {\n                    buffer.append(\"parent=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"parent=\").append(parent.getKey()).append(\" [\").append(parent.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"parent=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (left != null) {\n                if (left.bitIndex == -1) {\n                    buffer.append(\"left=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"left=\").append(left.getKey()).append(\" [\").append(left.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"left=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (right != null) {\n                if (right.bitIndex == -1) {\n                    buffer.append(\"right=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"right=\").append(right.getKey()).append(\" [\").append(right.bitIndex).append(\"]\");\n                }\n            } else {\n                buffer.append(\"right=\").append(\"null\");\n            }\n            buffer.append(\", \");\n\n            if (predecessor != null) {\n                if (predecessor.bitIndex == -1) {\n                    buffer.append(\"predecessor=\").append(\"ROOT\");\n                } else {\n                    buffer.append(\"predecessor=\").append(predecessor.getKey()).append(\" [\").\n                           append(predecessor.bitIndex).append(\"]\");\n                }\n            }\n\n            buffer.append(\")\");\n            return buffer.toString();\n        }\n    }\n\n    /**\n     * An {@link OrderedMapIterator} for a {@link org.apache.commons.collections4.Trie}.\n     */\n    private final class TrieMapIterator extends AbstractTrieIterator<K> implements OrderedMapIterator<K, V> {\n\n        protected TrieEntry<K, V> previous; // the previous node to return\n\n        @Override\n        public K getKey() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getValue();\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return previous != null;\n        }\n\n        @Override\n        public K next() {\n            return nextEntry().getKey();\n        }\n\n        @Override\n        protected TrieEntry<K, V> nextEntry() {\n            final TrieEntry<K, V> nextEntry = super.nextEntry();\n            previous = nextEntry;\n            return nextEntry;\n        }\n\n        @Override\n        public K previous() {\n            return previousEntry().getKey();\n        }\n\n        protected TrieEntry<K, V> previousEntry() {\n            if (expectedModCount != AbstractPatriciaTrie.this.modCount) {\n                throw new ConcurrentModificationException();\n            }\n\n            final TrieEntry<K, V> e = previous;\n            if (e == null) {\n                throw new NoSuchElementException();\n            }\n\n            previous = AbstractPatriciaTrie.this.previousEntry(e);\n            next = current;\n            current = e;\n            return current;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.setValue(value);\n        }\n\n    }\n\n    /**\n     * This is a value view of the {@link org.apache.commons.collections4.Trie} as returned by {@link Map#values()}.\n     */\n    private final class Values extends AbstractCollection<V> {\n\n        /**\n         * An {@link Iterator} that returns Value Objects.\n         */\n        private final class ValueIterator extends AbstractTrieIterator<V> {\n            @Override\n            public V next() {\n                return nextEntry().getValue();\n            }\n        }\n\n        @Override\n        public void clear() {\n            AbstractPatriciaTrie.this.clear();\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            return containsValue(o);\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return new ValueIterator();\n        }\n\n        @Override\n        public boolean remove(final Object o) {\n            for (final Iterator<V> it = iterator(); it.hasNext(); ) {\n                final V value = it.next();\n                if (compare(value, o)) {\n                    it.remove();\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public int size() {\n            return AbstractPatriciaTrie.this.size();\n        }\n    }\n\n    private static final long serialVersionUID = 5155253417231339498L;\n\n    /**\n     * Returns true if 'next' is a valid uplink coming from 'from'.\n     */\n    static boolean isValidUplink(final TrieEntry<?, ?> next, final TrieEntry<?, ?> from) {\n        return next != null && next.bitIndex <= from.bitIndex && !next.isEmpty();\n    }\n\n    /** The root node of the {@link org.apache.commons.collections4.Trie}. */\n    private transient TrieEntry<K, V> root = new TrieEntry<>(null, null, -1);\n\n    /**\n     * Each of these fields are initialized to contain an instance of the\n     * appropriate view the first time this view is requested. The views are\n     * stateless, so there's no reason to create more than one of each.\n     */\n    private transient volatile Set<K> keySet;\n\n    private transient volatile Collection<V> values;\n\n    private transient volatile Set<Map.Entry<K, V>> entrySet;\n\n    /** The current size of the {@link org.apache.commons.collections4.Trie}. */\n    private transient int size;\n\n    /**\n     * The number of times this {@link org.apache.commons.collections4.Trie} has been modified.\n     * It's used to detect concurrent modifications and fail-fast the {@link Iterator}s.\n     */\n    protected transient int modCount;\n\n    /**\n     * Constructs a new {@link Trie} using the given {@link KeyAnalyzer}.\n     *\n     * @param keyAnalyzer  the {@link KeyAnalyzer}.\n     */\n    protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n        super(keyAnalyzer);\n    }\n\n    /**\n     * Constructs a new {@link org.apache.commons.collections4.Trie} using the given {@link KeyAnalyzer} and initializes the\n     * {@link org.apache.commons.collections4.Trie} with the values from the provided {@link Map}.\n     *\n     * @param keyAnalyzer  the {@link KeyAnalyzer}.\n     * @param map The source map.\n     */\n    protected AbstractPatriciaTrie(final KeyAnalyzer<? super K> keyAnalyzer, final Map<? extends K, ? extends V> map) {\n        super(keyAnalyzer);\n        putAll(map);\n    }\n\n    /**\n     * Adds the given {@link TrieEntry} to the {@link org.apache.commons.collections4.Trie}.\n     */\n    TrieEntry<K, V> addEntry(final TrieEntry<K, V> entry, final int lengthInBits) {\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while (true) {\n            if (current.bitIndex >= entry.bitIndex\n                    || current.bitIndex <= path.bitIndex) {\n                entry.predecessor = entry;\n\n                if (!isBitSet(entry.key, entry.bitIndex, lengthInBits)) {\n                    entry.left = entry;\n                    entry.right = current;\n                } else {\n                    entry.left = current;\n                    entry.right = entry;\n                }\n\n                entry.parent = path;\n                if (current.bitIndex >= entry.bitIndex) {\n                    current.parent = entry;\n                }\n\n                // if we inserted an uplink, set the predecessor on it\n                if (current.bitIndex <= path.bitIndex) {\n                    current.predecessor = entry;\n                }\n\n                if (path == root || !isBitSet(entry.key, path.bitIndex, lengthInBits)) {\n                    path.left = entry;\n                } else {\n                    path.right = entry;\n                }\n\n                return entry;\n            }\n\n            path = current;\n\n            if (!isBitSet(entry.key, current.bitIndex, lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n\n    /**\n     * Returns a key-value mapping associated with the least key greater\n     * than or equal to the given key, or null if there is no such key.\n     */\n    TrieEntry<K, V> ceilingEntry(final K key) {\n        // Basically:\n        // Follow the steps of adding an entry, but instead...\n        //\n        // - If we ever encounter a situation where we found an equal\n        //   key, we return it immediately.\n        //\n        // - If we hit an empty root, return the first iterable item.\n        //\n        // - If we have to add a new item, we temporarily add it,\n        //   find the successor to it, then remove the added item.\n        //\n        // These steps ensure that the returned value is either the\n        // entry for the key itself, or the first entry directly after\n        // the key.\n\n        // TODO: Cleanup so that we don't actually have to add/remove from the\n        //       tree.  (We do it here because there are other well-defined\n        //       functions to perform the search.)\n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return firstEntry();\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return found;\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); // must increment because remove will decrement\n            final TrieEntry<K, V> ceil = nextEntry(added);\n            removeEntry(added);\n            modCount -= 2; // we didn't really modify it.\n            return ceil;\n        }\n        if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return firstEntry();\n        }\n        if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return found;\n        }\n\n        // we should have exited above.\n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    @Override\n    public void clear() {\n        root.key = null;\n        root.bitIndex = -1;\n        root.value = null;\n\n        root.parent = null;\n        root.left = root;\n        root.right = null;\n        root.predecessor = root;\n\n        size = 0;\n        incrementModCount();\n    }\n\n    @Override\n    public Comparator<? super K> comparator() {\n        return getKeyAnalyzer();\n    }\n\n    @Override\n    public boolean containsKey(final Object k) {\n        if (k == null) {\n            return false;\n        }\n\n        final K key = castKey(k);\n        final int lengthInBits = lengthInBits(key);\n        final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);\n        return !entry.isEmpty() && compareKeys(key, entry.key);\n    }\n\n    /**\n     * A helper method to decrement the {@link org.apache.commons.collections4.Trie} size and increment the modification counter.\n     */\n    void decrementSize() {\n        size--;\n        incrementModCount();\n    }\n\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        if (entrySet == null) {\n            entrySet = new EntrySet();\n        }\n        return entrySet;\n    }\n\n    /**\n     * Returns the first entry the {@link org.apache.commons.collections4.Trie} is storing.\n     * <p>\n     * This is implemented by going always to the left until\n     * we encounter a valid uplink. That uplink is the first key.\n     */\n    TrieEntry<K, V> firstEntry() {\n        // if Trie is empty, no first node.\n        if (isEmpty()) {\n            return null;\n        }\n\n        return followLeft(root);\n    }\n\n    @Override\n    public K firstKey() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        return firstEntry().getKey();\n    }\n\n    /**\n     * Returns a key-value mapping associated with the greatest key\n     * less than or equal to the given key, or null if there is no such key.\n     */\n    TrieEntry<K, V> floorEntry(final K key) {\n        // TODO: Cleanup so that we don't actually have to add/remove from the\n        //       tree.  (We do it here because there are other well-defined\n        //       functions to perform the search.)\n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return null;\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return found;\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); // must increment because remove will decrement\n            final TrieEntry<K, V> floor = previousEntry(added);\n            removeEntry(added);\n            modCount -= 2; // we didn't really modify it.\n            return floor;\n        }\n        if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            if (!root.isEmpty()) {\n                return root;\n            }\n            return null;\n        }\n        if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return found;\n        }\n\n        // we should have exited above.\n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    /**\n     * Goes left through the tree until it finds a valid node.\n     */\n    TrieEntry<K, V> followLeft(TrieEntry<K, V> node) {\n        while (true) {\n            TrieEntry<K, V> child = node.left;\n            // if we hit root and it didn't have a node, go right instead.\n            if (child.isEmpty()) {\n                child = node.right;\n            }\n\n            if (child.bitIndex <= node.bitIndex) {\n                return child;\n            }\n\n            node = child;\n        }\n    }\n\n    /**\n     * Traverses down the right path until it finds an uplink.\n     */\n    TrieEntry<K, V> followRight(TrieEntry<K, V> node) {\n        // if Trie is empty, no last entry.\n        if (node.right == null) {\n            return null;\n        }\n\n        // Go as far right as possible, until we encounter an uplink.\n        while (node.right.bitIndex > node.bitIndex) {\n            node = node.right;\n        }\n\n        return node.right;\n    }\n\n    @Override\n    public V get(final Object k) {\n        final TrieEntry<K, V> entry = getEntry(k);\n        return entry != null ? entry.getValue() : null;\n    }\n\n    /**\n     * Returns the entry associated with the specified key in the\n     * PatriciaTrieBase.  Returns null if the map contains no mapping\n     * for this key.\n     * <p>\n     * This may throw ClassCastException if the object is not of type K.\n     */\n    TrieEntry<K, V> getEntry(final Object k) {\n        final K key = castKey(k);\n        if (key == null) {\n            return null;\n        }\n\n        final int lengthInBits = lengthInBits(key);\n        final TrieEntry<K, V> entry = getNearestEntryForKey(key, lengthInBits);\n        return !entry.isEmpty() && compareKeys(key, entry.key) ? entry : null;\n    }\n\n    /**\n     * Returns the nearest entry for a given key.  This is useful\n     * for finding knowing if a given key exists (and finding the value\n     * for it), or for inserting the key.\n     *\n     * The actual get implementation. This is very similar to\n     * selectR but with the exception that it might return the\n     * root Entry even if it's empty.\n     */\n    TrieEntry<K, V> getNearestEntryForKey(final K key, final int lengthInBits) {\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while (true) {\n            if (current.bitIndex <= path.bitIndex) {\n                return current;\n            }\n\n            path = current;\n            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n\n    /**\n     * Returns a view of this {@link org.apache.commons.collections4.Trie} of all elements that are prefixed\n     * by the number of bits in the given Key.\n     * <p>\n     * The view that this returns is optimized to have a very efficient\n     * {@link Iterator}. The {@link SortedMap#firstKey()},\n     * {@link SortedMap#lastKey()} &amp; {@link Map#size()} methods must\n     * iterate over all possible values in order to determine the results.\n     * This information is cached until the PATRICIA {@link org.apache.commons.collections4.Trie} changes.\n     * All other methods (except {@link Iterator}) must compare the given\n     * key to the prefix to ensure that it is within the range of the view.\n     * The {@link Iterator}'s remove method must also relocate the subtree\n     * that contains the prefixes if the entry holding the subtree is\n     * removed or changes. Changing the subtree takes O(K) time.\n     *\n     * @param key  the key to use in the search\n     * @param offsetInBits  the prefix offset\n     * @param lengthInBits  the number of significant prefix bits\n     * @return a {@link SortedMap} view of this {@link org.apache.commons.collections4.Trie} with all elements whose\n     *   key is prefixed by the search key\n     */\n    private SortedMap<K, V> getPrefixMapByBits(final K key, final int offsetInBits, final int lengthInBits) {\n\n        final int offsetLength = offsetInBits + lengthInBits;\n        if (offsetLength > lengthInBits(key)) {\n            throw new IllegalArgumentException(offsetInBits + \" + \"\n                    + lengthInBits + \" > \" + lengthInBits(key));\n        }\n\n        if (offsetLength == 0) {\n            return this;\n        }\n\n        return new PrefixRangeMap(key, offsetInBits, lengthInBits);\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        return new RangeEntryMap(null, toKey);\n    }\n\n    /**\n     * Returns an entry strictly higher than the given key,\n     * or null if no such entry exists.\n     */\n    TrieEntry<K, V> higherEntry(final K key) {\n        // TODO: Cleanup so that we don't actually have to add/remove from the\n        //       tree.  (We do it here because there are other well-defined\n        //       functions to perform the search.)\n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            if (!root.isEmpty()) {\n                // If data in root, and more after -- return it.\n                if (size() > 1) {\n                    return nextEntry(root);\n                }\n                // If no more after, no higher entry.\n                return null;\n            }\n            // Root is empty & we want something after empty, return first.\n            return firstEntry();\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return nextEntry(found);\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); // must increment because remove will decrement\n            final TrieEntry<K, V> ceil = nextEntry(added);\n            removeEntry(added);\n            modCount -= 2; // we didn't really modify it.\n            return ceil;\n        }\n        if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            if (!root.isEmpty()) {\n                return firstEntry();\n            }\n            if (size() > 1) {\n                return nextEntry(firstEntry());\n            }\n            return null;\n        }\n        if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return nextEntry(found);\n        }\n\n        // we should have exited above.\n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    /**\n     * A helper method to increment the modification counter.\n     */\n    private void incrementModCount() {\n        ++modCount;\n    }\n\n    /**\n     * A helper method to increment the {@link org.apache.commons.collections4.Trie} size and the modification counter.\n     */\n    void incrementSize() {\n        size++;\n        incrementModCount();\n    }\n\n    @Override\n    public Set<K> keySet() {\n        if (keySet == null) {\n            keySet = new KeySet();\n        }\n        return keySet;\n    }\n\n    /**\n     * Returns the last entry the {@link org.apache.commons.collections4.Trie} is storing.\n     *\n     * <p>This is implemented by going always to the right until\n     * we encounter a valid uplink. That uplink is the last key.\n     */\n    TrieEntry<K, V> lastEntry() {\n        return followRight(root.left);\n    }\n\n    @Override\n    public K lastKey() {\n        final TrieEntry<K, V> entry = lastEntry();\n        if (entry != null) {\n            return entry.getKey();\n        }\n        throw new NoSuchElementException();\n    }\n\n    /**\n     * Returns a key-value mapping associated with the greatest key\n     * strictly less than the given key, or null if there is no such key.\n     */\n    TrieEntry<K, V> lowerEntry(final K key) {\n        // Basically:\n        // Follow the steps of adding an entry, but instead...\n        //\n        // - If we ever encounter a situation where we found an equal\n        //   key, we return it's previousEntry immediately.\n        //\n        // - If we hit root (empty or not), return null.\n        //\n        // - If we have to add a new item, we temporarily add it,\n        //   find the previousEntry to it, then remove the added item.\n        //\n        // These steps ensure that the returned value is always just before\n        // the key or null (if there was nothing before it).\n\n        // TODO: Cleanup so that we don't actually have to add/remove from the\n        //       tree.  (We do it here because there are other well-defined\n        //       functions to perform the search.)\n        final int lengthInBits = lengthInBits(key);\n\n        if (lengthInBits == 0) {\n            return null; // there can never be anything before root.\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            return previousEntry(found);\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (KeyAnalyzer.isValidBitIndex(bitIndex)) {\n            final TrieEntry<K, V> added = new TrieEntry<>(key, null, bitIndex);\n            addEntry(added, lengthInBits);\n            incrementSize(); // must increment because remove will decrement\n            final TrieEntry<K, V> prior = previousEntry(added);\n            removeEntry(added);\n            modCount -= 2; // we didn't really modify it.\n            return prior;\n        }\n        if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n            return null;\n        }\n        if (KeyAnalyzer.isEqualBitKey(bitIndex)) {\n            return previousEntry(found);\n        }\n\n        // we should have exited above.\n        throw new IllegalStateException(\"invalid lookup: \" + key);\n    }\n\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        return new TrieMapIterator();\n    }\n\n    /**\n     * Returns the entry lexicographically after the given entry.\n     * If the given entry is null, returns the first node.\n     */\n    TrieEntry<K, V> nextEntry(final TrieEntry<K, V> node) {\n        if (node == null) {\n            return firstEntry();\n        }\n        return nextEntryImpl(node.predecessor, node, null);\n    }\n\n    /**\n     * Scans for the next node, starting at the specified point, and using 'previous'\n     * as a hint that the last node we returned was 'previous' (so we know not to return\n     * it again).  If 'tree' is non-null, this will limit the search to the given tree.\n     *\n     * The basic premise is that each iteration can follow the following steps:\n     *\n     * 1) Scan all the way to the left.\n     *   a) If we already started from this node last time, proceed to Step 2.\n     *   b) If a valid uplink is found, use it.\n     *   c) If the result is an empty node (root not set), break the scan.\n     *   d) If we already returned the left node, break the scan.\n     *\n     * 2) Check the right.\n     *   a) If we already returned the right node, proceed to Step 3.\n     *   b) If it is a valid uplink, use it.\n     *   c) Do Step 1 from the right node.\n     *\n     * 3) Back up through the parents until we encounter find a parent\n     *    that we're not the right child of.\n     *\n     * 4) If there's no right child of that parent, the iteration is finished.\n     *    Otherwise continue to Step 5.\n     *\n     * 5) Check to see if the right child is a valid uplink.\n     *    a) If we already returned that child, proceed to Step 6.\n     *       Otherwise, use it.\n     *\n     * 6) If the right child of the parent is the parent itself, we've\n     *    already found &amp; returned the end of the Trie, so exit.\n     *\n     * 7) Do Step 1 on the parent's right child.\n     */\n    TrieEntry<K, V> nextEntryImpl(final TrieEntry<K, V> start,\n            final TrieEntry<K, V> previous, final TrieEntry<K, V> tree) {\n\n        TrieEntry<K, V> current = start;\n\n        // Only look at the left if this was a recursive or\n        // the first check, otherwise we know we've already looked\n        // at the left.\n        if (previous == null || start != previous.predecessor) {\n            while (!current.left.isEmpty()) {\n                // stop traversing if we've already\n                // returned the left of this node.\n                if (previous == current.left) {\n                    break;\n                }\n\n                if (isValidUplink(current.left, current)) {\n                    return current.left;\n                }\n\n                current = current.left;\n            }\n        }\n\n        // If there's no data at all, exit.\n        if (current.isEmpty()) {\n            return null;\n        }\n\n        // If we've already returned the left,\n        // and the immediate right is null,\n        // there's only one entry in the Trie\n        // which is stored at the root.\n        //\n        //  / (\"\")   <-- root\n        //  \\_/  \\\n        //       null <-- 'current'\n        //\n        if (current.right == null) {\n            return null;\n        }\n\n        // If nothing valid on the left, try the right.\n        if (previous != current.right) {\n            // See if it immediately is valid.\n            if (isValidUplink(current.right, current)) {\n                return current.right;\n            }\n\n            // Must search on the right's side if it wasn't initially valid.\n            return nextEntryImpl(current.right, previous, tree);\n        }\n\n        // Neither left nor right are valid, find the first parent\n        // whose child did not come from the right & traverse it.\n        while (current == current.parent.right) {\n            // If we're going to traverse to above the subtree, stop.\n            if (current == tree) {\n                return null;\n            }\n\n            current = current.parent;\n        }\n\n        // If we're on the top of the subtree, we can't go any higher.\n        if (current == tree) {\n            return null;\n        }\n\n        // If there's no right, the parent must be root, so we're done.\n        if (current.parent.right == null) {\n            return null;\n        }\n\n        // If the parent's right points to itself, we've found one.\n        if (previous != current.parent.right\n                && isValidUplink(current.parent.right, current.parent)) {\n            return current.parent.right;\n        }\n\n        // If the parent's right is itself, there can't be any more nodes.\n        if (current.parent.right == current.parent) {\n            return null;\n        }\n\n        // We need to traverse down the parent's right's path.\n        return nextEntryImpl(current.parent.right, previous, tree);\n    }\n\n    /**\n     * Returns the entry lexicographically after the given entry.\n     * If the given entry is null, returns the first node.\n     *\n     * This will traverse only within the subtree.  If the given node\n     * is not within the subtree, this will have undefined results.\n     */\n    TrieEntry<K, V> nextEntryInSubtree(final TrieEntry<K, V> node,\n            final TrieEntry<K, V> parentOfSubtree) {\n        if (node == null) {\n            return firstEntry();\n        }\n        return nextEntryImpl(node.predecessor, node, parentOfSubtree);\n    }\n\n    @Override\n    public K nextKey(final K key) {\n        Objects.requireNonNull(key, \"key\");\n        final TrieEntry<K, V> entry = getEntry(key);\n        if (entry != null) {\n            final TrieEntry<K, V> nextEntry = nextEntry(entry);\n            return nextEntry != null ? nextEntry.getKey() : null;\n        }\n        return null;\n    }\n\n    @Override\n    public SortedMap<K, V> prefixMap(final K key) {\n        return getPrefixMapByBits(key, 0, lengthInBits(key));\n    }\n\n    /**\n     * Returns the node lexicographically before the given node (or null if none).\n     *\n     * This follows four simple branches:\n     *  - If the uplink that returned us was a right uplink:\n     *      - If predecessor's left is a valid uplink from predecessor, return it.\n     *      - Else, follow the right path from the predecessor's left.\n     *  - If the uplink that returned us was a left uplink:\n     *      - Loop back through parents until we encounter a node where\n     *        node != node.parent.left.\n     *          - If node.parent.left is uplink from node.parent:\n     *              - If node.parent.left is not root, return it.\n     *              - If it is root &amp; root isEmpty, return null.\n     *              - If it is root &amp; root !isEmpty, return root.\n     *          - If node.parent.left is not uplink from node.parent:\n     *              - Follow right path for first right child from node.parent.left\n     *\n     * @param start  the start entry\n     */\n    TrieEntry<K, V> previousEntry(final TrieEntry<K, V> start) {\n        if (start.predecessor == null) {\n            throw new IllegalArgumentException(\"must have come from somewhere!\");\n        }\n\n        if (start.predecessor.right == start) {\n            if (isValidUplink(start.predecessor.left, start.predecessor)) {\n                return start.predecessor.left;\n            }\n            return followRight(start.predecessor.left);\n        }\n        TrieEntry<K, V> node = start.predecessor;\n        while (node.parent != null && node == node.parent.left) {\n            node = node.parent;\n        }\n\n        if (node.parent == null) { // can be null if we're looking up root.\n            return null;\n        }\n\n        if (isValidUplink(node.parent.left, node.parent)) {\n            if (node.parent.left == root) {\n                if (root.isEmpty()) {\n                    return null;\n                }\n                return root;\n\n            }\n            return node.parent.left;\n        }\n        return followRight(node.parent.left);\n    }\n\n    @Override\n    public K previousKey(final K key) {\n        Objects.requireNonNull(key, \"key\");\n        final TrieEntry<K, V> entry = getEntry(key);\n        if (entry != null) {\n            final TrieEntry<K, V> prevEntry = previousEntry(entry);\n            return prevEntry != null ? prevEntry.getKey() : null;\n        }\n        return null;\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        Objects.requireNonNull(key, \"key\");\n\n        final int lengthInBits = lengthInBits(key);\n\n        // The only place to store a key with a length\n        // of zero bits is the root node\n        if (lengthInBits == 0) {\n            if (root.isEmpty()) {\n                incrementSize();\n            } else {\n                incrementModCount();\n            }\n            return root.setKeyValue(key, value);\n        }\n\n        final TrieEntry<K, V> found = getNearestEntryForKey(key, lengthInBits);\n        if (compareKeys(key, found.key)) {\n            if (found.isEmpty()) { // <- must be the root\n                incrementSize();\n            } else {\n                incrementModCount();\n            }\n            return found.setKeyValue(key, value);\n        }\n\n        final int bitIndex = bitIndex(key, found.key);\n        if (!KeyAnalyzer.isOutOfBoundsIndex(bitIndex)) {\n            if (KeyAnalyzer.isValidBitIndex(bitIndex)) { // in 99.999...9% the case\n                /* NEW KEY+VALUE TUPLE */\n                final TrieEntry<K, V> t = new TrieEntry<>(key, value, bitIndex);\n                addEntry(t, lengthInBits);\n                incrementSize();\n                return null;\n            }\n            if (KeyAnalyzer.isNullBitKey(bitIndex)) {\n                // A bits of the Key are zero. The only place to\n                // store such a Key is the root Node!\n\n                /* NULL BIT KEY */\n                if (root.isEmpty()) {\n                    incrementSize();\n                } else {\n                    incrementModCount();\n                }\n                return root.setKeyValue(key, value);\n\n            }\n            if (KeyAnalyzer.isEqualBitKey(bitIndex) && found != root) { // NOPMD\n                incrementModCount();\n                return found.setKeyValue(key, value);\n            }\n        }\n\n        throw new IllegalArgumentException(\"Failed to put: \" + key + \" -> \" + value + \", \" + bitIndex);\n    }\n\n    /**\n     * Deserializes an instance from an ObjectInputStream.\n     *\n     * @param in The source ObjectInputStream.\n     * @throws IOException            Any of the usual Input/Output related exceptions.\n     * @throws ClassNotFoundException A class of a serialized object cannot be found.\n     */\n    @SuppressWarnings(\"unchecked\") // This will fail at runtime if the stream is incorrect\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        root = new TrieEntry<>(null, null, -1);\n        final int size = in.readInt();\n        for (int i = 0; i < size; i++) {\n            final K k = (K) in.readObject();\n            final V v = (V) in.readObject();\n            put(k, v);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws ClassCastException if provided key is of an incompatible type\n     */\n    @Override\n    public V remove(final Object k) {\n        if (k == null) {\n            return null;\n        }\n\n        final K key = castKey(k);\n        final int lengthInBits = lengthInBits(key);\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while (true) {\n            if (current.bitIndex <= path.bitIndex) {\n                if (!current.isEmpty() && compareKeys(key, current.key)) {\n                    return removeEntry(current);\n                }\n                return null;\n            }\n\n            path = current;\n\n            if (!isBitSet(key, current.bitIndex, lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n    }\n\n    /**\n     * Removes a single entry from the {@link org.apache.commons.collections4.Trie}.\n     *\n     * If we found a Key (Entry h) then figure out if it's\n     * an internal (hard to remove) or external Entry (easy\n     * to remove)\n     */\n    V removeEntry(final TrieEntry<K, V> h) {\n        if (h != root) {\n            if (h.isInternalNode()) {\n                removeInternalEntry(h);\n            } else {\n                removeExternalEntry(h);\n            }\n        }\n\n        decrementSize();\n        return h.setKeyValue(null, null);\n    }\n\n    /**\n     * Removes an external entry from the {@link org.apache.commons.collections4.Trie}.\n     *\n     * If it's an external Entry then just remove it.\n     * This is very easy and straight forward.\n     */\n    private void removeExternalEntry(final TrieEntry<K, V> h) {\n        if (h == root) {\n            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n        }\n        if (!h.isExternalNode()) {\n            throw new IllegalArgumentException(h + \" is not an external Entry!\");\n        }\n\n        final TrieEntry<K, V> parent = h.parent;\n        final TrieEntry<K, V> child = h.left == h ? h.right : h.left;\n\n        if (parent.left == h) {\n            parent.left = child;\n        } else {\n            parent.right = child;\n        }\n\n        // either the parent is changing, or the predecessor is changing.\n        if (child.bitIndex > parent.bitIndex) {\n            child.parent = parent;\n        } else {\n            child.predecessor = parent;\n        }\n\n    }\n\n    /**\n     * Removes an internal entry from the {@link org.apache.commons.collections4.Trie}.\n     *\n     * If it's an internal Entry then \"good luck\" with understanding\n     * this code. The Idea is essentially that Entry p takes Entry h's\n     * place in the trie which requires some re-wiring.\n     */\n    private void removeInternalEntry(final TrieEntry<K, V> h) {\n        if (h == root) {\n            throw new IllegalArgumentException(\"Cannot delete root Entry!\");\n        }\n        if (!h.isInternalNode()) {\n            throw new IllegalArgumentException(h + \" is not an internal Entry!\");\n        }\n\n        final TrieEntry<K, V> p = h.predecessor;\n\n        // Set P's bitIndex\n        p.bitIndex = h.bitIndex;\n\n        // Fix P's parent, predecessor and child Nodes\n        {\n            final TrieEntry<K, V> parent = p.parent;\n            final TrieEntry<K, V> child = p.left == h ? p.right : p.left;\n\n            // if it was looping to itself previously,\n            // it will now be pointed from its parent\n            // (if we aren't removing its parent --\n            //  in that case, it remains looping to itself).\n            // otherwise, it will continue to have the same\n            // predecessor.\n            if (p.predecessor == p && p.parent != h) {\n                p.predecessor = p.parent;\n            }\n\n            if (parent.left == p) {\n                parent.left = child;\n            } else {\n                parent.right = child;\n            }\n\n            if (child.bitIndex > parent.bitIndex) {\n                child.parent = parent;\n            }\n        }\n\n        // Fix H's parent and child Nodes\n        {\n            // If H is a parent of its left and right child\n            // then change them to P\n            if (h.left.parent == h) {\n                h.left.parent = p;\n            }\n\n            if (h.right.parent == h) {\n                h.right.parent = p;\n            }\n\n            // Change H's parent\n            if (h.parent.left == h) {\n                h.parent.left = p;\n            } else {\n                h.parent.right = p;\n            }\n        }\n\n        // Copy the remaining fields from H to P\n        //p.bitIndex = h.bitIndex;\n        p.parent = h.parent;\n        p.left = h.left;\n        p.right = h.right;\n\n        // Make sure that if h was pointing to any uplinks,\n        // p now points to them.\n        if (isValidUplink(p.left, p)) {\n            p.left.predecessor = p;\n        }\n\n        if (isValidUplink(p.right, p)) {\n            p.right.predecessor = p;\n        }\n    }\n\n    /**\n     * Returns the {@link java.util.Map.Entry} whose key is closest in a bitwise XOR\n     * metric to the given key. This is NOT lexicographic closeness.\n     * For example, given the keys:\n     *\n     * <ol>\n     * <li>D = 1000100\n     * <li>H = 1001000\n     * <li>L = 1001100\n     * </ol>\n     *\n     * If the {@link org.apache.commons.collections4.Trie} contained 'H' and 'L', a lookup of 'D' would\n     * return 'L', because the XOR distance between D &amp; L is smaller\n     * than the XOR distance between D &amp; H.\n     *\n     * @param key  the key to use in the search\n     * @return the {@link java.util.Map.Entry} whose key is closest in a bitwise XOR metric\n     *   to the provided key\n     */\n    public Map.Entry<K, V> select(final K key) {\n        final int lengthInBits = lengthInBits(key);\n        final Reference<Map.Entry<K, V>> reference = new Reference<>();\n        if (!selectR(root.left, -1, key, lengthInBits, reference)) {\n            return reference.get();\n        }\n        return null;\n    }\n\n    /**\n     * Returns the key that is closest in a bitwise XOR metric to the\n     * provided key. This is NOT lexicographic closeness!\n     *\n     * For example, given the keys:\n     *\n     * <ol>\n     * <li>D = 1000100\n     * <li>H = 1001000\n     * <li>L = 1001100\n     * </ol>\n     *\n     * If the {@link org.apache.commons.collections4.Trie} contained 'H' and 'L', a lookup of 'D' would\n     * return 'L', because the XOR distance between D &amp; L is smaller\n     * than the XOR distance between D &amp; H.\n     *\n     * @param key  the key to use in the search\n     * @return the key that is closest in a bitwise XOR metric to the provided key\n     */\n    public K selectKey(final K key) {\n        final Map.Entry<K, V> entry = select(key);\n        if (entry == null) {\n            return null;\n        }\n        return entry.getKey();\n    }\n\n    private boolean selectR(final TrieEntry<K, V> h, final int bitIndex,\n                            final K key, final int lengthInBits,\n                            final Reference<Map.Entry<K, V>> reference) {\n\n        if (h.bitIndex <= bitIndex) {\n            // If we hit the root Node and it is empty\n            // we have to look for an alternative best\n            // matching node.\n            if (!h.isEmpty()) {\n                reference.set(h);\n                return false;\n            }\n            return true;\n        }\n\n        if (!isBitSet(key, h.bitIndex, lengthInBits)) {\n            if (selectR(h.left, h.bitIndex, key, lengthInBits, reference)) {\n                return selectR(h.right, h.bitIndex, key, lengthInBits, reference);\n            }\n        } else if (selectR(h.right, h.bitIndex, key, lengthInBits, reference)) {\n            return selectR(h.left, h.bitIndex, key, lengthInBits, reference);\n        }\n        return false;\n    }\n\n    /**\n     * Returns the value whose key is closest in a bitwise XOR metric to\n     * the provided key. This is NOT lexicographic closeness!\n     *\n     * For example, given the keys:\n     *\n     * <ol>\n     * <li>D = 1000100\n     * <li>H = 1001000\n     * <li>L = 1001100\n     * </ol>\n     *\n     * If the {@link org.apache.commons.collections4.Trie} contained 'H' and 'L', a lookup of 'D' would\n     * return 'L', because the XOR distance between D &amp; L is smaller\n     * than the XOR distance between D &amp; H.\n     *\n     * @param key  the key to use in the search\n     * @return the value whose key is closest in a bitwise XOR metric\n     * to the provided key\n     */\n    public V selectValue(final K key) {\n        final Map.Entry<K, V> entry = select(key);\n        if (entry == null) {\n            return null;\n        }\n        return entry.getValue();\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        return new RangeEntryMap(fromKey, toKey);\n    }\n\n    /**\n     * Finds the subtree that contains the prefix.\n     *\n     * This is very similar to getR but with the difference that\n     * we stop the lookup if h.bitIndex > lengthInBits.\n     */\n    TrieEntry<K, V> subtree(final K prefix, final int offsetInBits, final int lengthInBits) {\n        TrieEntry<K, V> current = root.left;\n        TrieEntry<K, V> path = root;\n        while (true) {\n            if (current.bitIndex <= path.bitIndex || lengthInBits <= current.bitIndex) {\n                break;\n            }\n\n            path = current;\n            if (!isBitSet(prefix, offsetInBits + current.bitIndex, offsetInBits + lengthInBits)) {\n                current = current.left;\n            } else {\n                current = current.right;\n            }\n        }\n\n        // Make sure the entry is valid for a subtree.\n        final TrieEntry<K, V> entry = current.isEmpty() ? path : current;\n\n        // If entry is root, it can't be empty.\n        if (entry.isEmpty()) {\n            return null;\n        }\n\n        final int endIndexInBits = offsetInBits + lengthInBits;\n\n        // if root && length of root is less than length of lookup,\n        // there's nothing.\n        // (this prevents returning the whole subtree if root has an empty\n        //  string and we want to lookup things with \"\\0\")\n        if (entry == root && lengthInBits(entry.getKey()) < endIndexInBits) {\n            return null;\n        }\n\n        // Found key's length-th bit differs from our key\n        // which means it cannot be the prefix...\n        if (isBitSet(prefix, endIndexInBits - 1, endIndexInBits)\n                != isBitSet(entry.key, lengthInBits - 1, lengthInBits(entry.key))) {\n            return null;\n        }\n\n        // ... or there are less than 'length' equal bits\n        final int bitIndex = getKeyAnalyzer().bitIndex(prefix, offsetInBits, lengthInBits,\n                                                       entry.key, 0, lengthInBits(entry.getKey()));\n\n        if (bitIndex >= 0 && bitIndex < lengthInBits) {\n            return null;\n        }\n\n        return entry;\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        return new RangeEntryMap(fromKey, null);\n    }\n\n    @Override\n    public Collection<V> values() {\n        if (values == null) {\n            values = new Values();\n        }\n        return values;\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeInt(this.size());\n        for (final Entry<K, V> entry : entrySet()) {\n            out.writeObject(entry.getKey());\n            out.writeObject(entry.getValue());\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 5155253417231339498L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 5155253417231339498L", "syntax_pass": true}, {"attribute_expression": "private transient TrieEntry<K, V> root = new TrieEntry<>(null, null, -1);", "docstring": " The root node of the {@link org.apache.commons.collections4.Trie}.", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "TrieEntry<K, V>", "name": "root = new TrieEntry<>(null, null, -1)", "syntax_pass": true}, {"attribute_expression": "private transient volatile Set<K> keySet;", "docstring": "\nEach of these fields are initialized to contain an instance of the\nappropriate view the first time this view is requested. The views are\nstateless, so there's no reason to create more than one of each.\n", "modifiers": "private transient volatile", "marker_annotations": [], "non_marker_annotations": ["private", "transient", "volatile"], "comments": [], "type": "Set<K>", "name": "keySet", "syntax_pass": true}, {"attribute_expression": "private transient volatile Collection<V> values;", "docstring": "", "modifiers": "private transient volatile", "marker_annotations": [], "non_marker_annotations": ["private", "transient", "volatile"], "comments": [], "type": "Collection<V>", "name": "values", "syntax_pass": true}, {"attribute_expression": "private transient volatile Set<Map.Entry<K, V>> entrySet;", "docstring": "", "modifiers": "private transient volatile", "marker_annotations": [], "non_marker_annotations": ["private", "transient", "volatile"], "comments": [], "type": "Set<Map.Entry<K, V>>", "name": "entrySet", "syntax_pass": true}, {"attribute_expression": "private transient int size;", "docstring": " The current size of the {@link org.apache.commons.collections4.Trie}.", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}, {"attribute_expression": "protected transient int modCount;", "docstring": "\nThe number of times this {@link org.apache.commons.collections4.Trie} has been modified.\nIt's used to detect concurrent modifications and fail-fast the {@link Iterator}s.\n", "modifiers": "protected transient", "marker_annotations": [], "non_marker_annotations": ["protected", "transient"], "comments": [], "type": "int", "name": "modCount", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java.AbstractBitwiseTrie", "name": "AbstractBitwiseTrie", "file_path": "src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java", "superclasses": "", "methods": ["[boolean]compare(Object,Object)", "[]AbstractBitwiseTrie(KeyAnalyzer<? super K>)", "[int]bitIndex(K,K)", "[int]bitsPerElement()", "[K]castKey(Object)", "[boolean]compareKeys(K,K)", "[KeyAnalyzer<? super K>]getKeyAnalyzer()", "[boolean]isBitSet(K,int,int)", "[int]lengthInBits(K)", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java.AbstractBitwiseTrie.[boolean]compare(Object,Object)", "src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java.AbstractBitwiseTrie.[]AbstractBitwiseTrie(KeyAnalyzer<? super K>)", "src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java.AbstractBitwiseTrie.[int]bitIndex(K,K)", "src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java.AbstractBitwiseTrie.[int]bitsPerElement()", "src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java.AbstractBitwiseTrie.[K]castKey(Object)", "src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java.AbstractBitwiseTrie.[boolean]compareKeys(K,K)", "src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java.AbstractBitwiseTrie.[KeyAnalyzer<? super K>]getKeyAnalyzer()", "src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java.AbstractBitwiseTrie.[boolean]isBitSet(K,int,int)", "src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java.AbstractBitwiseTrie.[int]lengthInBits(K)", "src/main/java/org/apache/commons/collections4/trie/AbstractBitwiseTrie.java.AbstractBitwiseTrie.[String]toString()"], "overrides": null, "attributes": [{"original_string": "    abstract static class BasicEntry<K, V> implements Map.Entry<K, V>, Serializable {\n\n        private static final long serialVersionUID = -944364551314110330L;\n\n        /**\n         * The entry's key.\n         */\n        protected K key;\n\n        /**\n         * The entry's value.\n         */\n        protected V value;\n\n        BasicEntry(final K key) {\n            this.key = key;\n        }\n\n        BasicEntry(final K key, final V value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        @Override\n        public boolean equals(final Object o) {\n            if (o == this) {\n                return true;\n            }\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) o;\n            if (compare(key, other.getKey())\n                    && compare(value, other.getValue())) {\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public K getKey() {\n            return key;\n        }\n\n        @Override\n        public V getValue() {\n            return value;\n        }\n\n        @Override\n        public int hashCode() {\n            return (getKey() == null ? 0 : getKey().hashCode()) ^\n                   (getValue() == null ? 0 : getValue().hashCode());\n        }\n\n        /**\n         * Replaces the current key and value with the provided key &amp; value.\n         *\n         * @param key The new key.\n         * @param value The new value.\n         * @return The previous value.\n         */\n        public V setKeyValue(final K key, final V value) {\n            this.key = key;\n            return setValue(value);\n        }\n\n        @Override\n        public V setValue(final V value) {\n            final V previous = this.value;\n            this.value = value;\n            return previous;\n        }\n\n        @Override\n        public String toString() {\n            return key + \"=\" + value;\n        }\n    }", "definition": "    abstract static class BasicEntry<K, V> implements Map.Entry<K, V>, Serializable", "class_docstring": "\nA basic implementation of {@link Entry}.\n", "name": "BasicEntry", "super_interfaces": ["Map.Entry<K, V>", "Serializable"], "superclasses": "", "attributes": {"modifiers": "abstract static", "marker_annotations": [], "non_marker_annotations": ["abstract", "static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -944364551314110330L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -944364551314110330L", "syntax_pass": true}, {"attribute_expression": "protected K key;", "docstring": "\nThe entry's key.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "K", "name": "key", "syntax_pass": true}, {"attribute_expression": "protected V value;", "docstring": "\nThe entry's value.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "V", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        BasicEntry(final K key) {\n            this.key = key;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "BasicEntry", "params": [{"name": "key", "type": "K"}], "body": "                                {\n            this.key = key;\n        }", "signature": "BasicEntry(final K key)"}, {"syntax_pass": true, "original_string": "        BasicEntry(final K key, final V value) {\n            this.key = key;\n            this.value = value;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "BasicEntry", "params": [{"name": "key", "type": "K"}, {"name": "value", "type": "V"}], "body": "                                               {\n            this.key = key;\n            this.value = value;\n        }", "signature": "BasicEntry(final K key, final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object o) {\n            if (o == this) {\n                return true;\n            }\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) o;\n            if (compare(key, other.getKey())\n                    && compare(value, other.getValue())) {\n                return true;\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                              {\n            if (o == this) {\n                return true;\n            }\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) o;\n            if (compare(key, other.getKey())\n                    && compare(value, other.getValue())) {\n                return true;\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean equals(final Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            return key;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            return key;\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            return value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            return value;\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return (getKey() == null ? 0 : getKey().hashCode()) ^\n                   (getValue() == null ? 0 : getValue().hashCode());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return (getKey() == null ? 0 : getKey().hashCode()) ^\n                   (getValue() == null ? 0 : getValue().hashCode());\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        public V setKeyValue(final K key, final V value) {\n            this.key = key;\n            return setValue(value);\n        }", "docstring": "\nReplaces the current key and value with the provided key &amp; value.\n\n@param key The new key.\n@param value The new value.\n@return The previous value.\n", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setKeyValue", "params": [{"name": "key", "type": "K"}, {"name": "value", "type": "V"}], "body": "                                                         {\n            this.key = key;\n            return setValue(value);\n        }", "signature": "public V setKeyValue(final K key, final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            final V previous = this.value;\n            this.value = value;\n            return previous;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            final V previous = this.value;\n            this.value = value;\n            return previous;\n        }", "signature": "@Override\n        public V setValue(final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return key + \"=\" + value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return key + \"=\" + value;\n        }", "signature": "@Override\n        public String toString()"}]}], "class_docstring": "\nThis class provides some basic {@link Trie} functionality and\nutility methods for actual bitwise {@link Trie} implementations.\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.0\n", "original_string": "public abstract class AbstractBitwiseTrie<K, V> extends AbstractMap<K, V>\n        implements Trie<K, V>, Serializable {\n\n    /**\n     * A basic implementation of {@link Entry}.\n     */\n    abstract static class BasicEntry<K, V> implements Map.Entry<K, V>, Serializable {\n\n        private static final long serialVersionUID = -944364551314110330L;\n\n        /**\n         * The entry's key.\n         */\n        protected K key;\n\n        /**\n         * The entry's value.\n         */\n        protected V value;\n\n        BasicEntry(final K key) {\n            this.key = key;\n        }\n\n        BasicEntry(final K key, final V value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        @Override\n        public boolean equals(final Object o) {\n            if (o == this) {\n                return true;\n            }\n            if (!(o instanceof Map.Entry)) {\n                return false;\n            }\n\n            final Map.Entry<?, ?> other = (Map.Entry<?, ?>) o;\n            if (compare(key, other.getKey())\n                    && compare(value, other.getValue())) {\n                return true;\n            }\n            return false;\n        }\n\n        @Override\n        public K getKey() {\n            return key;\n        }\n\n        @Override\n        public V getValue() {\n            return value;\n        }\n\n        @Override\n        public int hashCode() {\n            return (getKey() == null ? 0 : getKey().hashCode()) ^\n                   (getValue() == null ? 0 : getValue().hashCode());\n        }\n\n        /**\n         * Replaces the current key and value with the provided key &amp; value.\n         *\n         * @param key The new key.\n         * @param value The new value.\n         * @return The previous value.\n         */\n        public V setKeyValue(final K key, final V value) {\n            this.key = key;\n            return setValue(value);\n        }\n\n        @Override\n        public V setValue(final V value) {\n            final V previous = this.value;\n            this.value = value;\n            return previous;\n        }\n\n        @Override\n        public String toString() {\n            return key + \"=\" + value;\n        }\n    }\n\n    private static final long serialVersionUID = 5826987063535505652L;\n\n    /**\n     * Delegates to {@link Objects#equals(Object, Object)}.\n     */\n    static boolean compare(final Object a, final Object b) {\n        return Objects.equals(a, b);\n    }\n\n    /**\n     * The {@link KeyAnalyzer} that's being used to build the PATRICIA {@link Trie}.\n     */\n    private final KeyAnalyzer<? super K> keyAnalyzer;\n\n    /**\n     * Constructs a new {@link Trie} using the given {@link KeyAnalyzer}.\n     *\n     * @param keyAnalyzer  the {@link KeyAnalyzer} to use\n     */\n    protected AbstractBitwiseTrie(final KeyAnalyzer<? super K> keyAnalyzer) {\n        this.keyAnalyzer = Objects.requireNonNull(keyAnalyzer, \"keyAnalyzer\");\n    }\n\n    /**\n     * Utility method for calling {@link KeyAnalyzer#bitIndex(Object, int, int, Object, int, int)}.\n     */\n    final int bitIndex(final K key, final K foundKey) {\n        return keyAnalyzer.bitIndex(key, 0, lengthInBits(key), foundKey, 0, lengthInBits(foundKey));\n    }\n\n    /**\n     * Returns the number of bits per element in the key\n     *\n     * @see KeyAnalyzer#bitsPerElement()\n     */\n    final int bitsPerElement() {\n        return keyAnalyzer.bitsPerElement();\n    }\n\n    /**\n     * A utility method to cast keys. It actually doesn't cast anything. It's just fooling the compiler!\n     */\n    @SuppressWarnings(\"unchecked\")\n    final K castKey(final Object key) {\n        return (K) key;\n    }\n\n    /**\n     * A utility method for calling {@link KeyAnalyzer#compare(Object, Object)}\n     */\n    final boolean compareKeys(final K key, final K other) {\n        if (key == null) {\n            return other == null;\n        }\n        if (other == null) {\n            return false;\n        }\n\n        return keyAnalyzer.compare(key, other) == 0;\n    }\n\n    /**\n     * Returns the {@link KeyAnalyzer} that constructed the {@link Trie}.\n     * @return the {@link KeyAnalyzer} used by this {@link Trie}\n     */\n    protected KeyAnalyzer<? super K> getKeyAnalyzer() {\n        return keyAnalyzer;\n    }\n\n    /**\n     * Returns whether or not the given bit on the key is set or false if the key is null.\n     *\n     * @see KeyAnalyzer#isBitSet(Object, int, int)\n     */\n    final boolean isBitSet(final K key, final int bitIndex, final int lengthInBits) {\n        if (key == null) { // root's might be null!\n            return false;\n        }\n        return keyAnalyzer.isBitSet(key, bitIndex, lengthInBits);\n    }\n\n    /**\n     * Returns the length of the given key in bits\n     *\n     * @see KeyAnalyzer#lengthInBits(Object)\n     */\n    final int lengthInBits(final K key) {\n        if (key == null) {\n            return 0;\n        }\n\n        return keyAnalyzer.lengthInBits(key);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder buffer = new StringBuilder();\n        buffer.append(\"Trie[\").append(size()).append(\"]={\\n\");\n        for (final Map.Entry<K, V> entry : entrySet()) {\n            buffer.append(\"  \").append(entry).append(\"\\n\");\n        }\n        buffer.append(\"}\\n\");\n        return buffer.toString();\n    }\n}", "super_interfaces": ["Trie<K, V>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 5826987063535505652L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 5826987063535505652L", "syntax_pass": true}, {"attribute_expression": "private final KeyAnalyzer<? super K> keyAnalyzer;", "docstring": "\nThe {@link KeyAnalyzer} that's being used to build the PATRICIA {@link Trie}.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "KeyAnalyzer<? super K>", "name": "keyAnalyzer", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/AbstractUntypedIteratorDecorator.java.AbstractUntypedIteratorDecorator", "name": "AbstractUntypedIteratorDecorator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/AbstractUntypedIteratorDecorator.java", "superclasses": "", "methods": ["[]AbstractUntypedIteratorDecorator(Iterator<I>)", "[Iterator<I>]getIterator()", "[boolean]hasNext()", "[void]remove()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/AbstractUntypedIteratorDecorator.java.AbstractUntypedIteratorDecorator.[]AbstractUntypedIteratorDecorator(Iterator<I>)", "src/main/java/org/apache/commons/collections4/iterators/AbstractUntypedIteratorDecorator.java.AbstractUntypedIteratorDecorator.[Iterator<I>]getIterator()", "src/main/java/org/apache/commons/collections4/iterators/AbstractUntypedIteratorDecorator.java.AbstractUntypedIteratorDecorator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/AbstractUntypedIteratorDecorator.java.AbstractUntypedIteratorDecorator.[void]remove()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides basic behavior for decorating an iterator with extra functionality without committing the generic type of the Iterator implementation.\n<p>\nAll methods are forwarded to the decorated iterator.\n</p>\n\n@param <I> the type of the iterator being decorated.\n@param <O> the type of elements returned by this iterator.\n\n@since 4.0\n", "original_string": "public abstract class AbstractUntypedIteratorDecorator<I, O> implements Iterator<O> {\n\n    /** The iterator being decorated */\n    private final Iterator<I> iterator;\n\n    /**\n     * Create a new AbstractUntypedIteratorDecorator.\n     *\n     * @param iterator  the iterator to decorate\n     * @throws NullPointerException if the iterator is null\n     */\n    protected AbstractUntypedIteratorDecorator(final Iterator<I> iterator) {\n        this.iterator = Objects.requireNonNull(iterator, \"iterator\");\n    }\n\n    /**\n     * Gets the iterator being decorated.\n     *\n     * @return the decorated iterator\n     */\n    protected Iterator<I> getIterator() {\n        return iterator;\n    }\n\n    @Override\n    public boolean hasNext() {\n        return iterator.hasNext();\n    }\n\n    @Override\n    public void remove() {\n        iterator.remove();\n    }\n\n}", "super_interfaces": ["Iterator<O>"], "fields": [{"attribute_expression": "private final Iterator<I> iterator;", "docstring": " The iterator being decorated", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<I>", "name": "iterator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyMapIterator.java.AbstractEmptyMapIterator", "name": "AbstractEmptyMapIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyMapIterator.java", "superclasses": "", "methods": ["[]AbstractEmptyMapIterator()", "[K]getKey()", "[V]getValue()", "[V]setValue(V)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyMapIterator.java.AbstractEmptyMapIterator.[]AbstractEmptyMapIterator()", "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyMapIterator.java.AbstractEmptyMapIterator.[K]getKey()", "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyMapIterator.java.AbstractEmptyMapIterator.[V]getValue()", "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyMapIterator.java.AbstractEmptyMapIterator.[V]setValue(V)"], "overrides": null, "attributes": [], "class_docstring": "\nProvides an implementation of an empty map iterator.\n\n@param <K> the type of keys\n@param <V> the type of mapped values\n@since 4.0\n", "original_string": "public abstract class AbstractEmptyMapIterator<K, V> extends AbstractEmptyIterator<K> {\n\n    /**\n     * Create a new AbstractEmptyMapIterator.\n     */\n    public AbstractEmptyMapIterator() {\n    }\n\n    /**\n     * Always throws IllegalStateException.\n     *\n     * @return Always throws IllegalStateException.\n     * @throws IllegalStateException Always thrown.\n     */\n    public K getKey() {\n        throw new IllegalStateException(\"Iterator contains no elements\");\n    }\n\n    /**\n     * Always throws IllegalStateException.\n     *\n     * @return Always throws IllegalStateException.\n     * @throws IllegalStateException Always thrown.\n     */\n    public V getValue() {\n        throw new IllegalStateException(\"Iterator contains no elements\");\n    }\n\n    /**\n     * Always throws IllegalStateException.\n     *\n     * @param ignored ignored.\n     * @return Always throws IllegalStateException.\n     * @throws IllegalStateException Always thrown.\n     */\n    public V setValue(final V ignored) {\n        throw new IllegalStateException(\"Iterator contains no elements\");\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyIterator.java.AbstractEmptyIterator", "name": "AbstractEmptyIterator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyIterator.java", "superclasses": "", "methods": ["[]AbstractEmptyIterator()", "[void]add(E)", "[boolean]hasNext()", "[boolean]hasPrevious()", "[E]next()", "[int]nextIndex()", "[E]previous()", "[int]previousIndex()", "[void]remove()", "[void]reset()", "[void]set(E)"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyIterator.java.AbstractEmptyIterator.[]AbstractEmptyIterator()", "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyIterator.java.AbstractEmptyIterator.[void]add(E)", "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyIterator.java.AbstractEmptyIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyIterator.java.AbstractEmptyIterator.[boolean]hasPrevious()", "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyIterator.java.AbstractEmptyIterator.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyIterator.java.AbstractEmptyIterator.[int]nextIndex()", "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyIterator.java.AbstractEmptyIterator.[E]previous()", "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyIterator.java.AbstractEmptyIterator.[int]previousIndex()", "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyIterator.java.AbstractEmptyIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyIterator.java.AbstractEmptyIterator.[void]reset()", "src/main/java/org/apache/commons/collections4/iterators/AbstractEmptyIterator.java.AbstractEmptyIterator.[void]set(E)"], "overrides": null, "attributes": [], "class_docstring": "\nProvides an abstract implementation of an empty iterator.\n\n@since 3.1\n", "original_string": "abstract class AbstractEmptyIterator<E> implements ResettableIterator<E> {\n\n    /**\n     * Constructs a new instance.\n     */\n    protected AbstractEmptyIterator() {\n    }\n\n    /**\n     * Always throws UnsupportedOperationException.\n     *\n     * @param ignored ignore.\n     * @throws UnsupportedOperationException Always thrown.\n     * @deprecated Will be removed in 5.0 without replacement.\n     */\n    @Deprecated\n    public void add(final E ignored) {\n        throw new UnsupportedOperationException(\"add() not supported for empty Iterator\");\n    }\n\n    /**\n     * Always returns false, this iterator contains no elements.\n     *\n     * @return Always false.\n     */\n    @Override\n    public boolean hasNext() {\n        return false;\n    }\n\n    /**\n     * Always returns false, this iterator contains no elements.\n     *\n     * @return Always false.\n     */\n    public boolean hasPrevious() {\n        return false;\n    }\n\n    /**\n     * Always throws IllegalStateException, this iterator contains no elements.\n     *\n     * @return Always throws IllegalStateException.\n     * @throws IllegalStateException Always thrown.\n     */\n    @Override\n    public E next() {\n        throw new NoSuchElementException(\"Iterator contains no elements\");\n    }\n\n    /**\n     * Always returns 0, this iterator contains no elements.\n     *\n     * @return Always returns 0.\n     */\n    public int nextIndex() {\n        return 0;\n    }\n\n    /**\n     * Always throws IllegalStateException, this iterator contains no elements.\n     *\n     * @return Always throws IllegalStateException.\n     * @throws IllegalStateException Always thrown.\n     */\n    public E previous() {\n        throw new NoSuchElementException(\"Iterator contains no elements\");\n    }\n\n    /**\n     * Always returns -1, this iterator contains no elements.\n     *\n     * @return Always returns -1.\n     */\n    public int previousIndex() {\n        return -1;\n    }\n\n    /**\n     * Always throws IllegalStateException, this iterator contains no elements.\n     *\n     * @throws IllegalStateException Always thrown.\n     */\n    @Override\n    public void remove() {\n        throw new IllegalStateException(\"Iterator contains no elements\");\n    }\n\n    @Override\n    public void reset() {\n        // do nothing\n    }\n\n    /**\n     * Always throws IllegalStateException, this iterator contains no elements.\n     *\n     * @param ignored ignored.\n     * @throws IllegalStateException Always thrown.\n     */\n    public void set(final E ignored) {\n        throw new IllegalStateException(\"Iterator contains no elements\");\n    }\n\n}", "super_interfaces": ["ResettableIterator<E>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/AbstractIteratorDecorator.java.AbstractIteratorDecorator", "name": "AbstractIteratorDecorator", "file_path": "src/main/java/org/apache/commons/collections4/iterators/AbstractIteratorDecorator.java", "superclasses": "", "methods": ["[]AbstractIteratorDecorator(Iterator<E>)", "[E]next()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/AbstractIteratorDecorator.java.AbstractIteratorDecorator.[]AbstractIteratorDecorator(Iterator<E>)", "src/main/java/org/apache/commons/collections4/iterators/AbstractIteratorDecorator.java.AbstractIteratorDecorator.[E]next()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides basic behavior for decorating an iterator with extra functionality.\n<p>\nAll methods are forwarded to the decorated iterator.\n</p>\n\n@param <E> the type of the iterator being decorated.\n@since 3.0\n", "original_string": "public abstract class AbstractIteratorDecorator<E> extends AbstractUntypedIteratorDecorator<E, E> {\n\n    /**\n     * Constructor that decorates the specified iterator.\n     *\n     * @param iterator  the iterator to decorate, must not be null\n     * @throws NullPointerException if the iterator is null\n     */\n    protected AbstractIteratorDecorator(final Iterator<E> iterator) {\n        super(iterator);\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public E next() {\n        return getIterator().next();\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/iterators/LazyIteratorChain.java.LazyIteratorChain", "name": "LazyIteratorChain", "file_path": "src/main/java/org/apache/commons/collections4/iterators/LazyIteratorChain.java", "superclasses": "", "methods": ["[boolean]hasNext()", "[E]next()", "[Iterator<? extends E>]nextIterator(int)", "[void]remove()", "[void]updateCurrentIterator()"], "method_uris": ["src/main/java/org/apache/commons/collections4/iterators/LazyIteratorChain.java.LazyIteratorChain.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/iterators/LazyIteratorChain.java.LazyIteratorChain.[E]next()", "src/main/java/org/apache/commons/collections4/iterators/LazyIteratorChain.java.LazyIteratorChain.[Iterator<? extends E>]nextIterator(int)", "src/main/java/org/apache/commons/collections4/iterators/LazyIteratorChain.java.LazyIteratorChain.[void]remove()", "src/main/java/org/apache/commons/collections4/iterators/LazyIteratorChain.java.LazyIteratorChain.[void]updateCurrentIterator()"], "overrides": null, "attributes": [], "class_docstring": "\nAn LazyIteratorChain is an Iterator that wraps a number of Iterators in a lazy manner.\n<p>\nThis class makes multiple iterators look like one to the caller. When any\nmethod from the Iterator interface is called, the LazyIteratorChain will delegate\nto a single underlying Iterator. The LazyIteratorChain will invoke the Iterators\nin sequence until all Iterators are exhausted.\n<p>\nThe Iterators are provided by {@link #nextIterator(int)} which has to be overridden by\nsubclasses and allows to lazily create the Iterators as they are accessed:\n<pre>\nreturn new LazyIteratorChain&lt;String&gt;() {\n    protected Iterator&lt;String&gt; nextIterator(int count) {\n        return count == 1 ? Arrays.asList(\"foo\", \"bar\").iterator() : null;\n    }\n};\n</pre>\n<p>\nOnce the inner Iterator's {@link Iterator#hasNext()} method returns false,\n{@link #nextIterator(int)} will be called to obtain another iterator, and so on\nuntil {@link #nextIterator(int)} returns null, indicating that the chain is exhausted.\n<p>\nNOTE: The LazyIteratorChain may contain no iterators. In this case the class will\nfunction as an empty iterator.\n\n@param <E> the type of elements in this iterator.\n@since 4.0\n", "original_string": "public abstract class LazyIteratorChain<E> implements Iterator<E> {\n\n    /** The number of times {@link #next()} was already called. */\n    private int callCounter;\n\n    /** Indicates that the Iterator chain has been exhausted. */\n    private boolean chainExhausted;\n\n    /** The current iterator. */\n    private Iterator<? extends E> currentIterator;\n\n    /**\n     * The \"last used\" Iterator is the Iterator upon which next() or hasNext()\n     * was most recently called used for the remove() operation only.\n     */\n    private Iterator<? extends E> lastUsedIterator;\n\n    /**\n     * Return true if any Iterator in the chain has a remaining element.\n     *\n     * @return true if elements remain\n     */\n    @Override\n    public boolean hasNext() {\n        updateCurrentIterator();\n        lastUsedIterator = currentIterator;\n\n        return currentIterator.hasNext();\n    }\n\n    /**\n     * Returns the next element of the current Iterator\n     *\n     * @return element from the current Iterator\n     * @throws java.util.NoSuchElementException if all the Iterators are exhausted\n     */\n    @Override\n    public E next() {\n        updateCurrentIterator();\n        lastUsedIterator = currentIterator;\n\n        return currentIterator.next();\n    }\n\n    /**\n     * Gets the next iterator after the previous one has been exhausted.\n     * <p>\n     * This method <b>MUST</b> return null when there are no more iterators.\n     *\n     * @param count the number of time this method has been called (starts with 1)\n     * @return the next iterator, or null if there are no more.\n     */\n    protected abstract Iterator<? extends E> nextIterator(int count);\n\n    /**\n     * Removes from the underlying collection the last element returned by the Iterator.\n     * <p>\n     * As with next() and hasNext(), this method calls remove() on the underlying Iterator.\n     * Therefore, this method may throw an UnsupportedOperationException if the underlying\n     * Iterator does not support this method.\n     *\n     * @throws UnsupportedOperationException if the remove operator is not\n     *   supported by the underlying Iterator\n     * @throws IllegalStateException if the next method has not yet been called,\n     *   or the remove method has already been called after the last call to the next method.\n     */\n    @Override\n    public void remove() {\n        if (currentIterator == null) {\n            updateCurrentIterator();\n        }\n        lastUsedIterator.remove();\n    }\n\n    /**\n     * Updates the current iterator field to ensure that the current Iterator\n     * is not exhausted.\n     */\n    private void updateCurrentIterator() {\n        if (callCounter == 0) {\n            currentIterator = nextIterator(++callCounter);\n            if (currentIterator == null) {\n                currentIterator = EmptyIterator.<E>emptyIterator();\n                chainExhausted = true;\n            }\n            // set last used iterator here, in case the user calls remove\n            // before calling hasNext() or next() (although they shouldn't)\n            lastUsedIterator = currentIterator;\n        }\n\n        while (!currentIterator.hasNext() && !chainExhausted) {\n            final Iterator<? extends E> nextIterator = nextIterator(++callCounter);\n            if (nextIterator != null) {\n                currentIterator = nextIterator;\n            } else {\n                chainExhausted = true;\n            }\n        }\n    }\n\n}", "super_interfaces": ["Iterator<E>"], "fields": [{"attribute_expression": "private int callCounter;", "docstring": " The number of times {@link #next()} was already called.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "callCounter", "syntax_pass": true}, {"attribute_expression": "private boolean chainExhausted;", "docstring": " Indicates that the Iterator chain has been exhausted.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "chainExhausted", "syntax_pass": true}, {"attribute_expression": "private Iterator<? extends E> currentIterator;", "docstring": " The current iterator.", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<? extends E>", "name": "currentIterator", "syntax_pass": true}, {"attribute_expression": "private Iterator<? extends E> lastUsedIterator;", "docstring": "\nThe \"last used\" Iterator is the Iterator upon which next() or hasNext()\nwas most recently called used for the remove() operation only.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Iterator<? extends E>", "name": "lastUsedIterator", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java.AbstractPropertiesFactory", "name": "AbstractPropertiesFactory", "file_path": "src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java", "superclasses": "", "methods": ["[]AbstractPropertiesFactory()", "[T]createProperties()", "[T]load(ClassLoader,String)", "[T]load(File)", "[T]load(InputStream)", "[T]load(InputStream,PropertyFormat)", "[T]load(Path)", "[T]load(Reader)", "[T]load(String)", "[T]load(URI)", "[T]load(URL)"], "method_uris": ["src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java.AbstractPropertiesFactory.[]AbstractPropertiesFactory()", "src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java.AbstractPropertiesFactory.[T]createProperties()", "src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java.AbstractPropertiesFactory.[T]load(ClassLoader,String)", "src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java.AbstractPropertiesFactory.[T]load(File)", "src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java.AbstractPropertiesFactory.[T]load(InputStream)", "src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java.AbstractPropertiesFactory.[T]load(InputStream,PropertyFormat)", "src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java.AbstractPropertiesFactory.[T]load(Path)", "src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java.AbstractPropertiesFactory.[T]load(Reader)", "src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java.AbstractPropertiesFactory.[T]load(String)", "src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java.AbstractPropertiesFactory.[T]load(URI)", "src/main/java/org/apache/commons/collections4/properties/AbstractPropertiesFactory.java.AbstractPropertiesFactory.[T]load(URL)"], "overrides": null, "attributes": [], "class_docstring": "\nSubclasses create and load {@link Properties} and subclasses of {@link Properties} like {@link SortedProperties}.\n\n@param <T> {@link Properties} or a subclass like {@link SortedProperties}.\n@see Properties\n@since 4.4\n", "original_string": "public abstract class AbstractPropertiesFactory<T extends Properties> {\n\n    /**\n     * Enumerates property formats.\n     *\n     * @since 4.5.0\n     */\n    public enum PropertyFormat {\n\n        /** Properties file format. */\n        PROPERTIES,\n\n        /** XML file format. */\n        XML;\n\n        static PropertyFormat toPropertyFormat(final String fileName) {\n            return Objects.requireNonNull(fileName, \"fileName\").endsWith(\".xml\") ? XML : PROPERTIES;\n        }\n    }\n\n    /**\n     * Constructs an instance.\n     */\n    protected AbstractPropertiesFactory() {\n        // no init.\n    }\n\n    /**\n     * Subclasses override to provide customized properties instances.\n     *\n     * @return a new Properties instance.\n     */\n    protected abstract T createProperties();\n\n    /**\n     * Creates and loads properties from the given file.\n     *\n     * @param classLoader the class loader to use to get the named resource.\n     * @param name        the location of the properties file.\n     * @return a new properties object.\n     * @throws IOException              Thrown if an error occurred reading the input stream.\n     * @throws IllegalArgumentException Thrown if the input contains a malformed Unicode escape sequence.\n     */\n    public T load(final ClassLoader classLoader, final String name) throws IOException {\n        try (InputStream inputStream = classLoader.getResourceAsStream(name)) {\n            return load(inputStream, PropertyFormat.toPropertyFormat(name));\n        }\n    }\n\n    /**\n     * Creates and loads properties from the given file.\n     *\n     * @param file the location of the properties file.\n     * @return a new properties object.\n     * @throws IOException              Thrown if an error occurred reading the input stream.\n     * @throws IllegalArgumentException Thrown if the input contains a malformed Unicode escape sequence.\n     * @throws FileNotFoundException    Thrown if the file does not exist, is a directory, or cannot be opened for\n     *                                  reading.\n     * @throws SecurityException        Thrown if a security manager's {@code checkRead} method denies read access to\n     *                                  the file.\n     */\n    public T load(final File file) throws FileNotFoundException, IOException {\n        try (FileInputStream inputStream = new FileInputStream(file)) {\n            return load(inputStream, PropertyFormat.toPropertyFormat(file.getName()));\n        }\n    }\n\n    /**\n     * Creates and loads properties from the given input stream.\n     *\n     * @param inputStream the location of the properties file.\n     * @return a new properties object.\n     * @throws IOException              Thrown if an error occurred reading the input stream.\n     * @throws IllegalArgumentException Thrown if the input contains a malformed Unicode escape sequence.\n     */\n    public T load(final InputStream inputStream) throws IOException {\n        if (inputStream == null) {\n            return null;\n        }\n        final T properties = createProperties();\n        properties.load(inputStream);\n        return properties;\n    }\n\n    /**\n     * Creates and loads properties from the given input stream.\n     *\n     * @param inputStream the location of the properties file.\n     * @param propertyFormat The format of the given file.\n     * @return a new properties object.\n     * @throws IOException              Thrown if an error occurred reading the input stream.\n     * @throws IllegalArgumentException Thrown if the input contains a malformed Unicode escape sequence.\n     * @since 4.5.0\n     */\n    public T load(final InputStream inputStream, final PropertyFormat propertyFormat) throws IOException {\n        if (inputStream == null) {\n            return null;\n        }\n        final T properties = createProperties();\n        if (propertyFormat == PropertyFormat.XML) {\n            properties.loadFromXML(inputStream);\n        } else {\n            properties.load(inputStream);\n        }\n        return properties;\n    }\n\n    /**\n     * Creates and loads properties from the given path.\n     *\n     * @param path the location of the properties file.\n     * @return a new properties object.\n     * @throws IOException              Thrown if an error occurred reading the input stream.\n     * @throws IllegalArgumentException Thrown if the input contains a malformed Unicode escape sequence.\n     */\n    public T load(final Path path) throws IOException {\n        try (InputStream inputStream = Files.newInputStream(path)) {\n            return load(inputStream, PropertyFormat.toPropertyFormat(Objects.toString(path.getFileName(), null)));\n        }\n    }\n\n    /**\n     * Creates and loads properties from the given reader.\n     *\n     * @param reader the location of the properties file.\n     * @return a new properties object.\n     * @throws IOException              Thrown if an error occurred reading the input stream.\n     * @throws IllegalArgumentException Thrown if the input contains a malformed Unicode escape sequence.\n     */\n    public T load(final Reader reader) throws IOException {\n        final T properties = createProperties();\n        properties.load(reader);\n        return properties;\n    }\n\n    /**\n     * Creates and loads properties from the given file name.\n     *\n     * @param name the location of the properties file.\n     * @return a new properties object.\n     * @throws IOException              Thrown if an error occurred reading the input stream.\n     * @throws IllegalArgumentException Thrown if the input contains a malformed Unicode escape sequence.\n     */\n    public T load(final String name) throws IOException {\n        try (FileInputStream inputStream = new FileInputStream(name)) {\n            return load(inputStream, PropertyFormat.toPropertyFormat(name));\n        }\n    }\n\n    /**\n     * Creates and loads properties from the given URI.\n     *\n     * @param uri the location of the properties file.\n     * @return a new properties object.\n     * @throws IOException              Thrown if an error occurred reading the input stream.\n     * @throws IllegalArgumentException Thrown if the input contains a malformed Unicode escape sequence.\n     */\n    public T load(final URI uri) throws IOException {\n        return load(Paths.get(uri));\n    }\n\n    /**\n     * Creates and loads properties from the given URL.\n     *\n     * @param url the location of the properties file.\n     * @return a new properties object.\n     * @throws IOException              Thrown if an error occurred reading the input stream.\n     * @throws IllegalArgumentException Thrown if the input contains a malformed Unicode escape sequence.\n     */\n    public T load(final URL url) throws IOException {\n        try (InputStream inputStream = url.openStream()) {\n            return load(inputStream, PropertyFormat.toPropertyFormat(url.getFile()));\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java.AbstractOrderedBidiMapDecorator", "name": "AbstractOrderedBidiMapDecorator", "file_path": "src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java", "superclasses": "", "methods": ["[]AbstractOrderedBidiMapDecorator(OrderedBidiMap<K, V>)", "[OrderedBidiMap<K, V>]decorated()", "[K]firstKey()", "[OrderedBidiMap<V, K>]inverseBidiMap()", "[K]lastKey()", "[OrderedMapIterator<K, V>]mapIterator()", "[K]nextKey(K)", "[K]previousKey(K)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java.AbstractOrderedBidiMapDecorator.[]AbstractOrderedBidiMapDecorator(OrderedBidiMap<K, V>)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java.AbstractOrderedBidiMapDecorator.[OrderedBidiMap<K, V>]decorated()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java.AbstractOrderedBidiMapDecorator.[K]firstKey()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java.AbstractOrderedBidiMapDecorator.[OrderedBidiMap<V, K>]inverseBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java.AbstractOrderedBidiMapDecorator.[K]lastKey()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java.AbstractOrderedBidiMapDecorator.[OrderedMapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java.AbstractOrderedBidiMapDecorator.[K]nextKey(K)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractOrderedBidiMapDecorator.java.AbstractOrderedBidiMapDecorator.[K]previousKey(K)"], "overrides": null, "attributes": [], "class_docstring": "\nProvides a base decorator that enables additional functionality to be added\nto an OrderedBidiMap via decoration.\n<p>\nMethods are forwarded directly to the decorated map.\n</p>\n<p>\nThis implementation does not perform any special processing with the map views.\nInstead it simply returns the inverse from the wrapped map. This may be\nundesirable, for example if you are trying to write a validating implementation\nit would provide a loophole around the validation.\nBut, you might want that loophole, so this class is kept simple.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public abstract class AbstractOrderedBidiMapDecorator<K, V>\n        extends AbstractBidiMapDecorator<K, V>\n        implements OrderedBidiMap<K, V> {\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if the collection is null\n     */\n    protected AbstractOrderedBidiMapDecorator(final OrderedBidiMap<K, V> map) {\n        super(map);\n    }\n\n    /**\n     * Gets the map being decorated.\n     *\n     * @return the decorated map\n     */\n    @Override\n    protected OrderedBidiMap<K, V> decorated() {\n        return (OrderedBidiMap<K, V>) super.decorated();\n    }\n\n    @Override\n    public K firstKey() {\n        return decorated().firstKey();\n    }\n\n    @Override\n    public OrderedBidiMap<V, K> inverseBidiMap() {\n        return decorated().inverseBidiMap();\n    }\n\n    @Override\n    public K lastKey() {\n        return decorated().lastKey();\n    }\n\n    @Override\n    public OrderedMapIterator<K, V> mapIterator() {\n        return decorated().mapIterator();\n    }\n\n    @Override\n    public K nextKey(final K key) {\n        return decorated().nextKey(key);\n    }\n\n    @Override\n    public K previousKey(final K key) {\n        return decorated().previousKey(key);\n    }\n\n}", "super_interfaces": ["OrderedBidiMap<K, V>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java.AbstractBidiMapDecorator", "name": "AbstractBidiMapDecorator", "file_path": "src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java", "superclasses": "", "methods": ["[]AbstractBidiMapDecorator(BidiMap<K, V>)", "[BidiMap<K, V>]decorated()", "[K]getKey(Object)", "[BidiMap<V, K>]inverseBidiMap()", "[MapIterator<K, V>]mapIterator()", "[K]removeValue(Object)", "[Set<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java.AbstractBidiMapDecorator.[]AbstractBidiMapDecorator(BidiMap<K, V>)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java.AbstractBidiMapDecorator.[BidiMap<K, V>]decorated()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java.AbstractBidiMapDecorator.[K]getKey(Object)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java.AbstractBidiMapDecorator.[BidiMap<V, K>]inverseBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java.AbstractBidiMapDecorator.[MapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java.AbstractBidiMapDecorator.[K]removeValue(Object)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractBidiMapDecorator.java.AbstractBidiMapDecorator.[Set<V>]values()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides a base decorator that enables additional functionality to be added\nto a BidiMap via decoration.\n<p>\nMethods are forwarded directly to the decorated map.\n</p>\n<p>\nThis implementation does not perform any special processing with the map views.\nInstead it simply returns the set/collection from the wrapped map. This may be\nundesirable, for example if you are trying to write a validating implementation\nit would provide a loophole around the validation.\nBut, you might want that loophole, so this class is kept simple.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public abstract class AbstractBidiMapDecorator<K, V>\n        extends AbstractMapDecorator<K, V> implements BidiMap<K, V> {\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if the collection is null\n     */\n    protected AbstractBidiMapDecorator(final BidiMap<K, V> map) {\n        super(map);\n    }\n\n    /**\n     * Gets the map being decorated.\n     *\n     * @return the decorated map\n     */\n    @Override\n    protected BidiMap<K, V> decorated() {\n        return (BidiMap<K, V>) super.decorated();\n    }\n\n    @Override\n    public K getKey(final Object value) {\n        return decorated().getKey(value);\n    }\n\n    @Override\n    public BidiMap<V, K> inverseBidiMap() {\n        return decorated().inverseBidiMap();\n    }\n\n    @Override\n    public MapIterator<K, V> mapIterator() {\n        return decorated().mapIterator();\n    }\n\n    @Override\n    public K removeValue(final Object value) {\n        return decorated().removeValue(value);\n    }\n\n    @Override\n    public Set<V> values() {\n        return decorated().values();\n    }\n\n}", "super_interfaces": ["BidiMap<K, V>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java.AbstractSortedBidiMapDecorator", "name": "AbstractSortedBidiMapDecorator", "file_path": "src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java", "superclasses": "", "methods": ["[]AbstractSortedBidiMapDecorator(SortedBidiMap<K, V>)", "[Comparator<? super K>]comparator()", "[SortedBidiMap<K, V>]decorated()", "[SortedMap<K, V>]headMap(K)", "[SortedBidiMap<V, K>]inverseBidiMap()", "[SortedMap<K, V>]subMap(K,K)", "[SortedMap<K, V>]tailMap(K)", "[Comparator<? super V>]valueComparator()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java.AbstractSortedBidiMapDecorator.[]AbstractSortedBidiMapDecorator(SortedBidiMap<K, V>)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java.AbstractSortedBidiMapDecorator.[Comparator<? super K>]comparator()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java.AbstractSortedBidiMapDecorator.[SortedBidiMap<K, V>]decorated()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java.AbstractSortedBidiMapDecorator.[SortedMap<K, V>]headMap(K)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java.AbstractSortedBidiMapDecorator.[SortedBidiMap<V, K>]inverseBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java.AbstractSortedBidiMapDecorator.[SortedMap<K, V>]subMap(K,K)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java.AbstractSortedBidiMapDecorator.[SortedMap<K, V>]tailMap(K)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractSortedBidiMapDecorator.java.AbstractSortedBidiMapDecorator.[Comparator<? super V>]valueComparator()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides a base decorator that enables additional functionality to be added\nto a SortedBidiMap via decoration.\n<p>\nMethods are forwarded directly to the decorated map.\n</p>\n<p>\nThis implementation does not perform any special processing with the map views.\nInstead it simply returns the inverse from the wrapped map. This may be\nundesirable, for example if you are trying to write a validating implementation\nit would provide a loophole around the validation.\nBut, you might want that loophole, so this class is kept simple.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public abstract class AbstractSortedBidiMapDecorator<K, V>\n        extends AbstractOrderedBidiMapDecorator<K, V> implements SortedBidiMap<K, V> {\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if the collection is null\n     */\n    public AbstractSortedBidiMapDecorator(final SortedBidiMap<K, V> map) {\n        super(map);\n    }\n\n    @Override\n    public Comparator<? super K> comparator() {\n        return decorated().comparator();\n    }\n\n    /**\n     * Gets the map being decorated.\n     *\n     * @return the decorated map\n     */\n    @Override\n    protected SortedBidiMap<K, V> decorated() {\n        return (SortedBidiMap<K, V>) super.decorated();\n    }\n\n    @Override\n    public SortedMap<K, V> headMap(final K toKey) {\n        return decorated().headMap(toKey);\n    }\n\n    @Override\n    public SortedBidiMap<V, K> inverseBidiMap() {\n        return decorated().inverseBidiMap();\n    }\n\n    @Override\n    public SortedMap<K, V> subMap(final K fromKey, final K toKey) {\n        return decorated().subMap(fromKey, toKey);\n    }\n\n    @Override\n    public SortedMap<K, V> tailMap(final K fromKey) {\n        return decorated().tailMap(fromKey);\n    }\n\n    @Override\n    public Comparator<? super V> valueComparator() {\n        return decorated().valueComparator();\n    }\n\n}", "super_interfaces": ["SortedBidiMap<K, V>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap", "name": "AbstractDualBidiMap", "file_path": "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java", "superclasses": "", "methods": ["[]AbstractDualBidiMap()", "[]AbstractDualBidiMap(Map<K, V>,Map<V, K>)", "[]AbstractDualBidiMap(Map<K, V>,Map<V, K>,BidiMap<V, K>)", "[void]clear()", "[boolean]containsKey(Object)", "[boolean]containsValue(Object)", "[BidiMap<V, K>]createBidiMap(Map<V, K>,Map<K, V>,BidiMap<K, V>)", "[Iterator<Map.Entry<K, V>>]createEntrySetIterator(Iterator<Map.Entry<K, V>>)", "[Iterator<K>]createKeySetIterator(Iterator<K>)", "[Iterator<V>]createValuesIterator(Iterator<V>)", "[Set<Map.Entry<K, V>>]entrySet()", "[boolean]equals(Object)", "[V]get(Object)", "[K]getKey(Object)", "[int]hashCode()", "[BidiMap<V, K>]inverseBidiMap()", "[boolean]isEmpty()", "[Set<K>]keySet()", "[MapIterator<K, V>]mapIterator()", "[V]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)", "[V]remove(Object)", "[K]removeValue(Object)", "[int]size()", "[String]toString()", "[Set<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[]AbstractDualBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[]AbstractDualBidiMap(Map<K, V>,Map<V, K>)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[]AbstractDualBidiMap(Map<K, V>,Map<V, K>,BidiMap<V, K>)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[void]clear()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[BidiMap<V, K>]createBidiMap(Map<V, K>,Map<K, V>,BidiMap<K, V>)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[Iterator<Map.Entry<K, V>>]createEntrySetIterator(Iterator<Map.Entry<K, V>>)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[Iterator<K>]createKeySetIterator(Iterator<K>)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[Iterator<V>]createValuesIterator(Iterator<V>)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[Set<Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[V]get(Object)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[K]getKey(Object)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[int]hashCode()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[BidiMap<V, K>]inverseBidiMap()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[MapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[void]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[K]removeValue(Object)", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[int]size()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[String]toString()", "src/main/java/org/apache/commons/collections4/bidimap/AbstractDualBidiMap.java.AbstractDualBidiMap.[Set<V>]values()"], "overrides": null, "attributes": [{"original_string": "    protected static class BidiMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n\n        /** The parent map */\n        protected final AbstractDualBidiMap<K, V> parent;\n\n        /** The iterator being wrapped */\n        protected Iterator<Map.Entry<K, V>> iterator;\n\n        /** The last returned entry */\n        protected Map.Entry<K, V> last;\n\n        /** Whether remove is allowed at present */\n        protected boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         * @param parent  the parent map\n         */\n        protected BidiMapIterator(final AbstractDualBidiMap<K, V> parent) {\n            this.parent = parent;\n            this.iterator = parent.normalMap.entrySet().iterator();\n        }\n\n        @Override\n        public K getKey() {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return last.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return last.getValue();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public K next() {\n            last = iterator.next();\n            canRemove = true;\n            return last.getKey();\n        }\n\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            // store value as remove may change the entry in the decorator (e.g. TreeMap)\n            final V value = last.getValue();\n            iterator.remove();\n            parent.reverseMap.remove(value);\n            last = null;\n            canRemove = false;\n        }\n\n        @Override\n        public void reset() {\n            iterator = parent.normalMap.entrySet().iterator();\n            last = null;\n            canRemove = false;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator setValue() can only be called after next() and before remove()\");\n            }\n            if (parent.reverseMap.containsKey(value) &&\n                parent.reverseMap.get(value) != last.getKey()) {\n                throw new IllegalArgumentException(\n                        \"Cannot use setValue() when the object being set is already in the map\");\n            }\n            return parent.put(last.getKey(), value);\n        }\n\n        @Override\n        public String toString() {\n            if (last != null) {\n                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"MapIterator[]\";\n        }\n    }", "definition": "    protected static class BidiMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K>", "class_docstring": "\nInner class MapIterator.\n\n@param <K> the type of the keys.\n@param <V> the type of the values.\n", "name": "BidiMapIterator", "super_interfaces": ["MapIterator<K, V>", "ResettableIterator<K>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected final AbstractDualBidiMap<K, V> parent;", "docstring": " The parent map", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "AbstractDualBidiMap<K, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "protected Iterator<Map.Entry<K, V>> iterator;", "docstring": " The iterator being wrapped", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Iterator<Map.Entry<K, V>>", "name": "iterator", "syntax_pass": true}, {"attribute_expression": "protected Map.Entry<K, V> last;", "docstring": " The last returned entry", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Map.Entry<K, V>", "name": "last", "syntax_pass": true}, {"attribute_expression": "protected boolean canRemove;", "docstring": " Whether remove is allowed at present", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "canRemove", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected BidiMapIterator(final AbstractDualBidiMap<K, V> parent) {\n            this.parent = parent;\n            this.iterator = parent.normalMap.entrySet().iterator();\n        }", "docstring": "\nConstructs a new instance.\n@param parent  the parent map\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "BidiMapIterator", "params": [{"name": "parent", "type": "AbstractDualBidiMap<K, V>"}], "body": "                                                                          {\n            this.parent = parent;\n            this.iterator = parent.normalMap.entrySet().iterator();\n        }", "signature": "protected BidiMapIterator(final AbstractDualBidiMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return last.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return last.getKey();\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return last.getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return last.getValue();\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return iterator.hasNext();\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            last = iterator.next();\n            canRemove = true;\n            return last.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            last = iterator.next();\n            canRemove = true;\n            return last.getKey();\n        }", "signature": "@Override\n        public K next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            // store value as remove may change the entry in the decorator (e.g. TreeMap)\n            final V value = last.getValue();\n            iterator.remove();\n            parent.reverseMap.remove(value);\n            last = null;\n            canRemove = false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            // store value as remove may change the entry in the decorator (e.g. TreeMap)\n            final V value = last.getValue();\n            iterator.remove();\n            parent.reverseMap.remove(value);\n            last = null;\n            canRemove = false;\n        }", "signature": "@Override\n        public void remove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void reset() {\n            iterator = parent.normalMap.entrySet().iterator();\n            last = null;\n            canRemove = false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "reset", "params": [], "body": "                            {\n            iterator = parent.normalMap.entrySet().iterator();\n            last = null;\n            canRemove = false;\n        }", "signature": "@Override\n        public void reset()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator setValue() can only be called after next() and before remove()\");\n            }\n            if (parent.reverseMap.containsKey(value) &&\n                parent.reverseMap.get(value) != last.getKey()) {\n                throw new IllegalArgumentException(\n                        \"Cannot use setValue() when the object being set is already in the map\");\n            }\n            return parent.put(last.getKey(), value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator setValue() can only be called after next() and before remove()\");\n            }\n            if (parent.reverseMap.containsKey(value) &&\n                parent.reverseMap.get(value) != last.getKey()) {\n                throw new IllegalArgumentException(\n                        \"Cannot use setValue() when the object being set is already in the map\");\n            }\n            return parent.put(last.getKey(), value);\n        }", "signature": "@Override\n        public V setValue(final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            if (last != null) {\n                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"MapIterator[]\";\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            if (last != null) {\n                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"MapIterator[]\";\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    protected static class EntrySet<K, V> extends View<K, V, Map.Entry<K, V>> implements Set<Map.Entry<K, V>> {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 4040410962603292348L;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent  the parent BidiMap\n         */\n        protected EntrySet(final AbstractDualBidiMap<K, V> parent) {\n            super(parent.normalMap.entrySet(), parent);\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return parent.createEntrySetIterator(super.iterator());\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object key = entry.getKey();\n            if (parent.containsKey(key)) {\n                final V value = parent.normalMap.get(key);\n                if (value == null ? entry.getValue() == null : value.equals(entry.getValue())) {\n                    parent.normalMap.remove(key);\n                    parent.reverseMap.remove(value);\n                    return true;\n                }\n            }\n            return false;\n        }\n    }", "definition": "    protected static class EntrySet<K, V> extends View<K, V, Map.Entry<K, V>> implements Set<Map.Entry<K, V>>", "class_docstring": "\nInner class EntrySet.\n\n@param <K> the type of the keys.\n@param <V> the type of the values.\n", "name": "EntrySet", "super_interfaces": ["Set<Map.Entry<K, V>>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 4040410962603292348L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 4040410962603292348L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected EntrySet(final AbstractDualBidiMap<K, V> parent) {\n            super(parent.normalMap.entrySet(), parent);\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent  the parent BidiMap\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "EntrySet", "params": [{"name": "parent", "type": "AbstractDualBidiMap<K, V>"}], "body": "                                                                   {\n            super(parent.normalMap.entrySet(), parent);\n        }", "signature": "protected EntrySet(final AbstractDualBidiMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return parent.createEntrySetIterator(super.iterator());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Map.Entry<K, V>>", "classes": []}, "name": "iterator", "params": [], "body": "                                                    {\n            return parent.createEntrySetIterator(super.iterator());\n        }", "signature": "@Override\n        public Iterator<Map.Entry<K, V>> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object key = entry.getKey();\n            if (parent.containsKey(key)) {\n                final V value = parent.normalMap.get(key);\n                if (value == null ? entry.getValue() == null : value.equals(entry.getValue())) {\n                    parent.normalMap.remove(key);\n                    parent.reverseMap.remove(value);\n                    return true;\n                }\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object key = entry.getKey();\n            if (parent.containsKey(key)) {\n                final V value = parent.normalMap.get(key);\n                if (value == null ? entry.getValue() == null : value.equals(entry.getValue())) {\n                    parent.normalMap.remove(key);\n                    parent.reverseMap.remove(value);\n                    return true;\n                }\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean remove(final Object obj)"}]}, {"original_string": "    protected static class EntrySetIterator<K, V> extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n\n        /** The parent map */\n        protected final AbstractDualBidiMap<K, V> parent;\n\n        /** The last returned entry */\n        protected Map.Entry<K, V> last;\n\n        /** Whether remove is allowed at present */\n        protected boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         * @param iterator  the iterator to decorate\n         * @param parent  the parent map\n         */\n        protected EntrySetIterator(final Iterator<Map.Entry<K, V>> iterator, final AbstractDualBidiMap<K, V> parent) {\n            super(iterator);\n            this.parent = parent;\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            last = new MapEntry<>(super.next(), parent);\n            canRemove = true;\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            // store value as remove may change the entry in the decorator (e.g. TreeMap)\n            final Object value = last.getValue();\n            super.remove();\n            parent.reverseMap.remove(value);\n            last = null;\n            canRemove = false;\n        }\n    }", "definition": "    protected static class EntrySetIterator<K, V> extends AbstractIteratorDecorator<Map.Entry<K, V>>", "class_docstring": "\nInner class EntrySetIterator.\n\n@param <K> the type of the keys.\n@param <V> the type of the values.\n", "name": "EntrySetIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected final AbstractDualBidiMap<K, V> parent;", "docstring": " The parent map", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "AbstractDualBidiMap<K, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "protected Map.Entry<K, V> last;", "docstring": " The last returned entry", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Map.Entry<K, V>", "name": "last", "syntax_pass": true}, {"attribute_expression": "protected boolean canRemove;", "docstring": " Whether remove is allowed at present", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "canRemove", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected EntrySetIterator(final Iterator<Map.Entry<K, V>> iterator, final AbstractDualBidiMap<K, V> parent) {\n            super(iterator);\n            this.parent = parent;\n        }", "docstring": "\nConstructs a new instance.\n@param iterator  the iterator to decorate\n@param parent  the parent map\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "EntrySetIterator", "params": [{"name": "iterator", "type": "Iterator<Map.Entry<K, V>>"}, {"name": "parent", "type": "AbstractDualBidiMap<K, V>"}], "body": "                                                                                                                     {\n            super(iterator);\n            this.parent = parent;\n        }", "signature": "protected EntrySetIterator(final Iterator<Map.Entry<K, V>> iterator, final AbstractDualBidiMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Map.Entry<K, V> next() {\n            last = new MapEntry<>(super.next(), parent);\n            canRemove = true;\n            return last;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, V>", "classes": []}, "name": "next", "params": [], "body": "                                      {\n            last = new MapEntry<>(super.next(), parent);\n            canRemove = true;\n            return last;\n        }", "signature": "@Override\n        public Map.Entry<K, V> next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            // store value as remove may change the entry in the decorator (e.g. TreeMap)\n            final Object value = last.getValue();\n            super.remove();\n            parent.reverseMap.remove(value);\n            last = null;\n            canRemove = false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            // store value as remove may change the entry in the decorator (e.g. TreeMap)\n            final Object value = last.getValue();\n            super.remove();\n            parent.reverseMap.remove(value);\n            last = null;\n            canRemove = false;\n        }", "signature": "@Override\n        public void remove()"}]}, {"original_string": "    protected static class KeySet<K> extends View<K, Object, K> implements Set<K> {\n\n        /** Serialization version */\n        private static final long serialVersionUID = -7107935777385040694L;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent  the parent BidiMap\n         */\n        @SuppressWarnings(\"unchecked\")\n        protected KeySet(final AbstractDualBidiMap<K, ?> parent) {\n            super(parent.normalMap.keySet(), (AbstractDualBidiMap<K, Object>) parent);\n        }\n\n        @Override\n        public boolean contains(final Object key) {\n            return parent.normalMap.containsKey(key);\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return parent.createKeySetIterator(super.iterator());\n        }\n\n        @Override\n        public boolean remove(final Object key) {\n            if (parent.normalMap.containsKey(key)) {\n                final Object value = parent.normalMap.remove(key);\n                parent.reverseMap.remove(value);\n                return true;\n            }\n            return false;\n        }\n    }", "definition": "    protected static class KeySet<K> extends View<K, Object, K> implements Set<K>", "class_docstring": "\nInner class KeySet.\n\n@param <K> the type of elements maintained by this set\n", "name": "KeySet", "super_interfaces": ["Set<K>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -7107935777385040694L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -7107935777385040694L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        protected KeySet(final AbstractDualBidiMap<K, ?> parent) {\n            super(parent.normalMap.keySet(), (AbstractDualBidiMap<K, Object>) parent);\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent  the parent BidiMap\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        protected", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "protected"], "comments": [], "return_type": "", "classes": []}, "name": "KeySet", "params": [{"name": "parent", "type": "AbstractDualBidiMap<K, ?>"}], "body": "                                                                 {\n            super(parent.normalMap.keySet(), (AbstractDualBidiMap<K, Object>) parent);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        protected KeySet(final AbstractDualBidiMap<K, ?> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object key) {\n            return parent.normalMap.containsKey(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "key", "type": "Object"}], "body": "                                                  {\n            return parent.normalMap.containsKey(key);\n        }", "signature": "@Override\n        public boolean contains(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<K> iterator() {\n            return parent.createKeySetIterator(super.iterator());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<K>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return parent.createKeySetIterator(super.iterator());\n        }", "signature": "@Override\n        public Iterator<K> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object key) {\n            if (parent.normalMap.containsKey(key)) {\n                final Object value = parent.normalMap.remove(key);\n                parent.reverseMap.remove(value);\n                return true;\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "key", "type": "Object"}], "body": "                                                {\n            if (parent.normalMap.containsKey(key)) {\n                final Object value = parent.normalMap.remove(key);\n                parent.reverseMap.remove(value);\n                return true;\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean remove(final Object key)"}]}, {"original_string": "    protected static class KeySetIterator<K> extends AbstractIteratorDecorator<K> {\n\n        /** The parent map */\n        protected final AbstractDualBidiMap<K, ?> parent;\n\n        /** The last returned key */\n        protected K lastKey;\n\n        /** Whether remove is allowed at present */\n        protected boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         * @param iterator  the iterator to decorate\n         * @param parent  the parent map\n         */\n        protected KeySetIterator(final Iterator<K> iterator, final AbstractDualBidiMap<K, ?> parent) {\n            super(iterator);\n            this.parent = parent;\n        }\n\n        @Override\n        public K next() {\n            lastKey = super.next();\n            canRemove = true;\n            return lastKey;\n        }\n\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            final Object value = parent.normalMap.get(lastKey);\n            super.remove();\n            parent.reverseMap.remove(value);\n            lastKey = null;\n            canRemove = false;\n        }\n    }", "definition": "    protected static class KeySetIterator<K> extends AbstractIteratorDecorator<K>", "class_docstring": "\nInner class KeySetIterator.\n\n@param <K> the key type.\n", "name": "KeySetIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected final AbstractDualBidiMap<K, ?> parent;", "docstring": " The parent map", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "AbstractDualBidiMap<K, ?>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "protected K lastKey;", "docstring": " The last returned key", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "K", "name": "lastKey", "syntax_pass": true}, {"attribute_expression": "protected boolean canRemove;", "docstring": " Whether remove is allowed at present", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "canRemove", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected KeySetIterator(final Iterator<K> iterator, final AbstractDualBidiMap<K, ?> parent) {\n            super(iterator);\n            this.parent = parent;\n        }", "docstring": "\nConstructs a new instance.\n@param iterator  the iterator to decorate\n@param parent  the parent map\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "KeySetIterator", "params": [{"name": "iterator", "type": "Iterator<K>"}, {"name": "parent", "type": "AbstractDualBidiMap<K, ?>"}], "body": "                                                                                                     {\n            super(iterator);\n            this.parent = parent;\n        }", "signature": "protected KeySetIterator(final Iterator<K> iterator, final AbstractDualBidiMap<K, ?> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            lastKey = super.next();\n            canRemove = true;\n            return lastKey;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            lastKey = super.next();\n            canRemove = true;\n            return lastKey;\n        }", "signature": "@Override\n        public K next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            final Object value = parent.normalMap.get(lastKey);\n            super.remove();\n            parent.reverseMap.remove(value);\n            lastKey = null;\n            canRemove = false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            final Object value = parent.normalMap.get(lastKey);\n            super.remove();\n            parent.reverseMap.remove(value);\n            lastKey = null;\n            canRemove = false;\n        }", "signature": "@Override\n        public void remove()"}]}, {"original_string": "    protected static class MapEntry<K, V> extends AbstractMapEntryDecorator<K, V> {\n\n        /** The parent map */\n        protected final AbstractDualBidiMap<K, V> parent;\n\n        /**\n         * Constructs a new instance.\n         * @param entry  the entry to decorate\n         * @param parent  the parent map\n         */\n        protected MapEntry(final Map.Entry<K, V> entry, final AbstractDualBidiMap<K, V> parent) {\n            super(entry);\n            this.parent = parent;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            final K key = getKey();\n            if (parent.reverseMap.containsKey(value) &&\n                parent.reverseMap.get(value) != key) {\n                throw new IllegalArgumentException(\n                        \"Cannot use setValue() when the object being set is already in the map\");\n            }\n            parent.put(key, value);\n            return super.setValue(value);\n        }\n    }", "definition": "    protected static class MapEntry<K, V> extends AbstractMapEntryDecorator<K, V>", "class_docstring": "\nInner class MapEntry.\n\n@param <K> the type of the keys.\n@param <V> the type of the values.\n", "name": "MapEntry", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected final AbstractDualBidiMap<K, V> parent;", "docstring": " The parent map", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "AbstractDualBidiMap<K, V>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected MapEntry(final Map.Entry<K, V> entry, final AbstractDualBidiMap<K, V> parent) {\n            super(entry);\n            this.parent = parent;\n        }", "docstring": "\nConstructs a new instance.\n@param entry  the entry to decorate\n@param parent  the parent map\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "MapEntry", "params": [{"name": "entry", "type": "Map.Entry<K, V>"}, {"name": "parent", "type": "AbstractDualBidiMap<K, V>"}], "body": "                                                                                                {\n            super(entry);\n            this.parent = parent;\n        }", "signature": "protected MapEntry(final Map.Entry<K, V> entry, final AbstractDualBidiMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            final K key = getKey();\n            if (parent.reverseMap.containsKey(value) &&\n                parent.reverseMap.get(value) != key) {\n                throw new IllegalArgumentException(\n                        \"Cannot use setValue() when the object being set is already in the map\");\n            }\n            parent.put(key, value);\n            return super.setValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            final K key = getKey();\n            if (parent.reverseMap.containsKey(value) &&\n                parent.reverseMap.get(value) != key) {\n                throw new IllegalArgumentException(\n                        \"Cannot use setValue() when the object being set is already in the map\");\n            }\n            parent.put(key, value);\n            return super.setValue(value);\n        }", "signature": "@Override\n        public V setValue(final V value)"}]}, {"original_string": "    protected static class Values<V> extends View<Object, V, V> implements Set<V> {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 4023777119829639864L;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent  the parent BidiMap\n         */\n        @SuppressWarnings(\"unchecked\")\n        protected Values(final AbstractDualBidiMap<?, V> parent) {\n            super(parent.normalMap.values(), (AbstractDualBidiMap<Object, V>) parent);\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return parent.reverseMap.containsKey(value);\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return parent.createValuesIterator(super.iterator());\n        }\n\n        @Override\n        public boolean remove(final Object value) {\n            if (parent.reverseMap.containsKey(value)) {\n                final Object key = parent.reverseMap.remove(value);\n                parent.normalMap.remove(key);\n                return true;\n            }\n            return false;\n        }\n    }", "definition": "    protected static class Values<V> extends View<Object, V, V> implements Set<V>", "class_docstring": "\nInner class Values.\n\n@param <V> the type of the values.\n", "name": "Values", "super_interfaces": ["Set<V>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 4023777119829639864L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 4023777119829639864L", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        protected Values(final AbstractDualBidiMap<?, V> parent) {\n            super(parent.normalMap.values(), (AbstractDualBidiMap<Object, V>) parent);\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent  the parent BidiMap\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        protected", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "protected"], "comments": [], "return_type": "", "classes": []}, "name": "Values", "params": [{"name": "parent", "type": "AbstractDualBidiMap<?, V>"}], "body": "                                                                 {\n            super(parent.normalMap.values(), (AbstractDualBidiMap<Object, V>) parent);\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        protected Values(final AbstractDualBidiMap<?, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object value) {\n            return parent.reverseMap.containsKey(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "value", "type": "Object"}], "body": "                                                    {\n            return parent.reverseMap.containsKey(value);\n        }", "signature": "@Override\n        public boolean contains(final Object value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<V> iterator() {\n            return parent.createValuesIterator(super.iterator());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<V>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return parent.createValuesIterator(super.iterator());\n        }", "signature": "@Override\n        public Iterator<V> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object value) {\n            if (parent.reverseMap.containsKey(value)) {\n                final Object key = parent.reverseMap.remove(value);\n                parent.normalMap.remove(key);\n                return true;\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "value", "type": "Object"}], "body": "                                                  {\n            if (parent.reverseMap.containsKey(value)) {\n                final Object key = parent.reverseMap.remove(value);\n                parent.normalMap.remove(key);\n                return true;\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean remove(final Object value)"}]}, {"original_string": "    protected static class ValuesIterator<V> extends AbstractIteratorDecorator<V> {\n\n        /** The parent map */\n        protected final AbstractDualBidiMap<Object, V> parent;\n\n        /** The last returned value */\n        protected V lastValue;\n\n        /** Whether remove is allowed at present */\n        protected boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         * @param iterator  the iterator to decorate\n         * @param parent  the parent map\n         */\n        @SuppressWarnings(\"unchecked\")\n        protected ValuesIterator(final Iterator<V> iterator, final AbstractDualBidiMap<?, V> parent) {\n            super(iterator);\n            this.parent = (AbstractDualBidiMap<Object, V>) parent;\n        }\n\n        @Override\n        public V next() {\n            lastValue = super.next();\n            canRemove = true;\n            return lastValue;\n        }\n\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            super.remove(); // removes from maps[0]\n            parent.reverseMap.remove(lastValue);\n            lastValue = null;\n            canRemove = false;\n        }\n    }", "definition": "    protected static class ValuesIterator<V> extends AbstractIteratorDecorator<V>", "class_docstring": "\nInner class ValuesIterator.\n\n@param <V> the value type.\n", "name": "ValuesIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected final AbstractDualBidiMap<Object, V> parent;", "docstring": " The parent map", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "AbstractDualBidiMap<Object, V>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "protected V lastValue;", "docstring": " The last returned value", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "V", "name": "lastValue", "syntax_pass": true}, {"attribute_expression": "protected boolean canRemove;", "docstring": " Whether remove is allowed at present", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "canRemove", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unchecked\")\n        protected ValuesIterator(final Iterator<V> iterator, final AbstractDualBidiMap<?, V> parent) {\n            super(iterator);\n            this.parent = (AbstractDualBidiMap<Object, V>) parent;\n        }", "docstring": "\nConstructs a new instance.\n@param iterator  the iterator to decorate\n@param parent  the parent map\n", "attributes": {"modifiers": "@SuppressWarnings(\"unchecked\")\n        protected", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "protected"], "comments": [], "return_type": "", "classes": []}, "name": "ValuesIterator", "params": [{"name": "iterator", "type": "Iterator<V>"}, {"name": "parent", "type": "AbstractDualBidiMap<?, V>"}], "body": "                                                                                                     {\n            super(iterator);\n            this.parent = (AbstractDualBidiMap<Object, V>) parent;\n        }", "signature": "@SuppressWarnings(\"unchecked\")\n        protected ValuesIterator(final Iterator<V> iterator, final AbstractDualBidiMap<?, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V next() {\n            lastValue = super.next();\n            canRemove = true;\n            return lastValue;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "next", "params": [], "body": "                        {\n            lastValue = super.next();\n            canRemove = true;\n            return lastValue;\n        }", "signature": "@Override\n        public V next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            super.remove(); // removes from maps[0]\n            parent.reverseMap.remove(lastValue);\n            lastValue = null;\n            canRemove = false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            super.remove(); // removes from maps[0]\n            parent.reverseMap.remove(lastValue);\n            lastValue = null;\n            canRemove = false;\n        }", "signature": "@Override\n        public void remove()"}]}, {"original_string": "    protected abstract static class View<K, V, E> extends AbstractCollectionDecorator<E> {\n\n        /** Generated serial version ID. */\n        private static final long serialVersionUID = 4621510560119690639L;\n\n        /** The parent map */\n        protected final AbstractDualBidiMap<K, V> parent;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param coll  the collection view being decorated\n         * @param parent  the parent BidiMap\n         */\n        protected View(final Collection<E> coll, final AbstractDualBidiMap<K, V> parent) {\n            super(coll);\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean equals(final Object object) {\n            return object == this || decorated().equals(object);\n        }\n\n        @Override\n        public int hashCode() {\n            return decorated().hashCode();\n        }\n\n        @Override\n        public boolean removeAll(final Collection<?> coll) {\n            if (parent.isEmpty() || coll.isEmpty()) {\n                return false;\n            }\n            boolean modified = false;\n            for (final Object current : coll) {\n                modified |= remove(current);\n            }\n            return modified;\n        }\n\n        /**\n         * @since 4.4\n         */\n        @Override\n        public boolean removeIf(final Predicate<? super E> filter) {\n            if (parent.isEmpty() || Objects.isNull(filter)) {\n                return false;\n            }\n            boolean modified = false;\n            final Iterator<?> it = iterator();\n            while (it.hasNext()) {\n                @SuppressWarnings(\"unchecked\")\n                final E e = (E) it.next();\n                if (filter.test(e)) {\n                    it.remove();\n                    modified = true;\n                }\n            }\n            return modified;\n        }\n\n        /**\n         * {@inheritDoc}\n         * <p>\n         * This implementation iterates over the elements of this bidi map, checking each element in\n         * turn to see if it's contained in {@code coll}. If it's not contained, it's removed\n         * from this bidi map. As a consequence, it is advised to use a collection type for\n         * {@code coll} that provides a fast (e.g. O(1)) implementation of\n         * {@link Collection#contains(Object)}.\n         */\n        @Override\n        public boolean retainAll(final Collection<?> coll) {\n            if (parent.isEmpty()) {\n                return false;\n            }\n            if (coll.isEmpty()) {\n                parent.clear();\n                return true;\n            }\n            boolean modified = false;\n            final Iterator<E> it = iterator();\n            while (it.hasNext()) {\n                if (!coll.contains(it.next())) {\n                    it.remove();\n                    modified = true;\n                }\n            }\n            return modified;\n        }\n    }", "definition": "    protected abstract static class View<K, V, E> extends AbstractCollectionDecorator<E>", "class_docstring": "\nInner class View.\n\n@param <K> the type of the keys in the map.\n@param <V> the type of the values in the map.\n@param <E> the type of the elements in the collection.\n", "name": "View", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected abstract static", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract", "static"], "comments": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 4621510560119690639L;", "docstring": " Generated serial version ID.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 4621510560119690639L", "syntax_pass": true}, {"attribute_expression": "protected final AbstractDualBidiMap<K, V> parent;", "docstring": " The parent map", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "AbstractDualBidiMap<K, V>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected View(final Collection<E> coll, final AbstractDualBidiMap<K, V> parent) {\n            super(coll);\n            this.parent = parent;\n        }", "docstring": "\nConstructs a new instance.\n\n@param coll  the collection view being decorated\n@param parent  the parent BidiMap\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "View", "params": [{"name": "coll", "type": "Collection<E>"}, {"name": "parent", "type": "AbstractDualBidiMap<K, V>"}], "body": "                                                                                         {\n            super(coll);\n            this.parent = parent;\n        }", "signature": "protected View(final Collection<E> coll, final AbstractDualBidiMap<K, V> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            parent.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            parent.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object object) {\n            return object == this || decorated().equals(object);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "object", "type": "Object"}], "body": "                                                   {\n            return object == this || decorated().equals(object);\n        }", "signature": "@Override\n        public boolean equals(final Object object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return decorated().hashCode();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return decorated().hashCode();\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean removeAll(final Collection<?> coll) {\n            if (parent.isEmpty() || coll.isEmpty()) {\n                return false;\n            }\n            boolean modified = false;\n            for (final Object current : coll) {\n                modified |= remove(current);\n            }\n            return modified;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "removeAll", "params": [{"name": "coll", "type": "Collection<?>"}], "body": "                                                           {\n            if (parent.isEmpty() || coll.isEmpty()) {\n                return false;\n            }\n            boolean modified = false;\n            for (final Object current : coll) {\n                modified |= remove(current);\n            }\n            return modified;\n        }", "signature": "@Override\n        public boolean removeAll(final Collection<?> coll)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean removeIf(final Predicate<? super E> filter) {\n            if (parent.isEmpty() || Objects.isNull(filter)) {\n                return false;\n            }\n            boolean modified = false;\n            final Iterator<?> it = iterator();\n            while (it.hasNext()) {\n                @SuppressWarnings(\"unchecked\")\n                final E e = (E) it.next();\n                if (filter.test(e)) {\n                    it.remove();\n                    modified = true;\n                }\n            }\n            return modified;\n        }", "docstring": "\n@since 4.4\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "removeIf", "params": [{"name": "filter", "type": "Predicate<? super E>"}], "body": "                                                                   {\n            if (parent.isEmpty() || Objects.isNull(filter)) {\n                return false;\n            }\n            boolean modified = false;\n            final Iterator<?> it = iterator();\n            while (it.hasNext()) {\n                @SuppressWarnings(\"unchecked\")\n                final E e = (E) it.next();\n                if (filter.test(e)) {\n                    it.remove();\n                    modified = true;\n                }\n            }\n            return modified;\n        }", "signature": "@Override\n        public boolean removeIf(final Predicate<? super E> filter)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean retainAll(final Collection<?> coll) {\n            if (parent.isEmpty()) {\n                return false;\n            }\n            if (coll.isEmpty()) {\n                parent.clear();\n                return true;\n            }\n            boolean modified = false;\n            final Iterator<E> it = iterator();\n            while (it.hasNext()) {\n                if (!coll.contains(it.next())) {\n                    it.remove();\n                    modified = true;\n                }\n            }\n            return modified;\n        }", "docstring": "\n{@inheritDoc}\n<p>\nThis implementation iterates over the elements of this bidi map, checking each element in\nturn to see if it's contained in {@code coll}. If it's not contained, it's removed\nfrom this bidi map. As a consequence, it is advised to use a collection type for\n{@code coll} that provides a fast (e.g. O(1)) implementation of\n{@link Collection#contains(Object)}.\n", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "retainAll", "params": [{"name": "coll", "type": "Collection<?>"}], "body": "                                                           {\n            if (parent.isEmpty()) {\n                return false;\n            }\n            if (coll.isEmpty()) {\n                parent.clear();\n                return true;\n            }\n            boolean modified = false;\n            final Iterator<E> it = iterator();\n            while (it.hasNext()) {\n                if (!coll.contains(it.next())) {\n                    it.remove();\n                    modified = true;\n                }\n            }\n            return modified;\n        }", "signature": "@Override\n        public boolean retainAll(final Collection<?> coll)"}]}], "class_docstring": "\nAbstract {@link BidiMap} implemented using two maps.\n<p>\nAn implementation can be written simply by implementing the\n{@link #createBidiMap(Map, Map, BidiMap)} method.\n</p>\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n\n@see DualHashBidiMap\n@see DualTreeBidiMap\n@since 3.0\n", "original_string": "public abstract class AbstractDualBidiMap<K, V> implements BidiMap<K, V> {\n\n    /**\n     * Inner class MapIterator.\n     *\n     * @param <K> the type of the keys.\n     * @param <V> the type of the values.\n     */\n    protected static class BidiMapIterator<K, V> implements MapIterator<K, V>, ResettableIterator<K> {\n\n        /** The parent map */\n        protected final AbstractDualBidiMap<K, V> parent;\n\n        /** The iterator being wrapped */\n        protected Iterator<Map.Entry<K, V>> iterator;\n\n        /** The last returned entry */\n        protected Map.Entry<K, V> last;\n\n        /** Whether remove is allowed at present */\n        protected boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         * @param parent  the parent map\n         */\n        protected BidiMapIterator(final AbstractDualBidiMap<K, V> parent) {\n            this.parent = parent;\n            this.iterator = parent.normalMap.entrySet().iterator();\n        }\n\n        @Override\n        public K getKey() {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getKey() can only be called after next() and before remove()\");\n            }\n            return last.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator getValue() can only be called after next() and before remove()\");\n            }\n            return last.getValue();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public K next() {\n            last = iterator.next();\n            canRemove = true;\n            return last.getKey();\n        }\n\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            // store value as remove may change the entry in the decorator (e.g. TreeMap)\n            final V value = last.getValue();\n            iterator.remove();\n            parent.reverseMap.remove(value);\n            last = null;\n            canRemove = false;\n        }\n\n        @Override\n        public void reset() {\n            iterator = parent.normalMap.entrySet().iterator();\n            last = null;\n            canRemove = false;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (last == null) {\n                throw new IllegalStateException(\n                        \"Iterator setValue() can only be called after next() and before remove()\");\n            }\n            if (parent.reverseMap.containsKey(value) &&\n                parent.reverseMap.get(value) != last.getKey()) {\n                throw new IllegalArgumentException(\n                        \"Cannot use setValue() when the object being set is already in the map\");\n            }\n            return parent.put(last.getKey(), value);\n        }\n\n        @Override\n        public String toString() {\n            if (last != null) {\n                return \"MapIterator[\" + getKey() + \"=\" + getValue() + \"]\";\n            }\n            return \"MapIterator[]\";\n        }\n    }\n\n    /**\n     * Inner class EntrySet.\n     *\n     * @param <K> the type of the keys.\n     * @param <V> the type of the values.\n     */\n    protected static class EntrySet<K, V> extends View<K, V, Map.Entry<K, V>> implements Set<Map.Entry<K, V>> {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 4040410962603292348L;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent  the parent BidiMap\n         */\n        protected EntrySet(final AbstractDualBidiMap<K, V> parent) {\n            super(parent.normalMap.entrySet(), parent);\n        }\n\n        @Override\n        public Iterator<Map.Entry<K, V>> iterator() {\n            return parent.createEntrySetIterator(super.iterator());\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Map.Entry)) {\n                return false;\n            }\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) obj;\n            final Object key = entry.getKey();\n            if (parent.containsKey(key)) {\n                final V value = parent.normalMap.get(key);\n                if (value == null ? entry.getValue() == null : value.equals(entry.getValue())) {\n                    parent.normalMap.remove(key);\n                    parent.reverseMap.remove(value);\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Inner class EntrySetIterator.\n     *\n     * @param <K> the type of the keys.\n     * @param <V> the type of the values.\n     */\n    protected static class EntrySetIterator<K, V> extends AbstractIteratorDecorator<Map.Entry<K, V>> {\n\n        /** The parent map */\n        protected final AbstractDualBidiMap<K, V> parent;\n\n        /** The last returned entry */\n        protected Map.Entry<K, V> last;\n\n        /** Whether remove is allowed at present */\n        protected boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         * @param iterator  the iterator to decorate\n         * @param parent  the parent map\n         */\n        protected EntrySetIterator(final Iterator<Map.Entry<K, V>> iterator, final AbstractDualBidiMap<K, V> parent) {\n            super(iterator);\n            this.parent = parent;\n        }\n\n        @Override\n        public Map.Entry<K, V> next() {\n            last = new MapEntry<>(super.next(), parent);\n            canRemove = true;\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            // store value as remove may change the entry in the decorator (e.g. TreeMap)\n            final Object value = last.getValue();\n            super.remove();\n            parent.reverseMap.remove(value);\n            last = null;\n            canRemove = false;\n        }\n    }\n\n    /**\n     * Inner class KeySet.\n     *\n     * @param <K> the type of elements maintained by this set\n     */\n    protected static class KeySet<K> extends View<K, Object, K> implements Set<K> {\n\n        /** Serialization version */\n        private static final long serialVersionUID = -7107935777385040694L;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent  the parent BidiMap\n         */\n        @SuppressWarnings(\"unchecked\")\n        protected KeySet(final AbstractDualBidiMap<K, ?> parent) {\n            super(parent.normalMap.keySet(), (AbstractDualBidiMap<K, Object>) parent);\n        }\n\n        @Override\n        public boolean contains(final Object key) {\n            return parent.normalMap.containsKey(key);\n        }\n\n        @Override\n        public Iterator<K> iterator() {\n            return parent.createKeySetIterator(super.iterator());\n        }\n\n        @Override\n        public boolean remove(final Object key) {\n            if (parent.normalMap.containsKey(key)) {\n                final Object value = parent.normalMap.remove(key);\n                parent.reverseMap.remove(value);\n                return true;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Inner class KeySetIterator.\n     *\n     * @param <K> the key type.\n     */\n    protected static class KeySetIterator<K> extends AbstractIteratorDecorator<K> {\n\n        /** The parent map */\n        protected final AbstractDualBidiMap<K, ?> parent;\n\n        /** The last returned key */\n        protected K lastKey;\n\n        /** Whether remove is allowed at present */\n        protected boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         * @param iterator  the iterator to decorate\n         * @param parent  the parent map\n         */\n        protected KeySetIterator(final Iterator<K> iterator, final AbstractDualBidiMap<K, ?> parent) {\n            super(iterator);\n            this.parent = parent;\n        }\n\n        @Override\n        public K next() {\n            lastKey = super.next();\n            canRemove = true;\n            return lastKey;\n        }\n\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            final Object value = parent.normalMap.get(lastKey);\n            super.remove();\n            parent.reverseMap.remove(value);\n            lastKey = null;\n            canRemove = false;\n        }\n    }\n\n    /**\n     * Inner class MapEntry.\n     *\n     * @param <K> the type of the keys.\n     * @param <V> the type of the values.\n     */\n    protected static class MapEntry<K, V> extends AbstractMapEntryDecorator<K, V> {\n\n        /** The parent map */\n        protected final AbstractDualBidiMap<K, V> parent;\n\n        /**\n         * Constructs a new instance.\n         * @param entry  the entry to decorate\n         * @param parent  the parent map\n         */\n        protected MapEntry(final Map.Entry<K, V> entry, final AbstractDualBidiMap<K, V> parent) {\n            super(entry);\n            this.parent = parent;\n        }\n\n        @Override\n        public V setValue(final V value) {\n            final K key = getKey();\n            if (parent.reverseMap.containsKey(value) &&\n                parent.reverseMap.get(value) != key) {\n                throw new IllegalArgumentException(\n                        \"Cannot use setValue() when the object being set is already in the map\");\n            }\n            parent.put(key, value);\n            return super.setValue(value);\n        }\n    }\n\n    /**\n     * Inner class Values.\n     *\n     * @param <V> the type of the values.\n     */\n    protected static class Values<V> extends View<Object, V, V> implements Set<V> {\n\n        /** Serialization version */\n        private static final long serialVersionUID = 4023777119829639864L;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent  the parent BidiMap\n         */\n        @SuppressWarnings(\"unchecked\")\n        protected Values(final AbstractDualBidiMap<?, V> parent) {\n            super(parent.normalMap.values(), (AbstractDualBidiMap<Object, V>) parent);\n        }\n\n        @Override\n        public boolean contains(final Object value) {\n            return parent.reverseMap.containsKey(value);\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            return parent.createValuesIterator(super.iterator());\n        }\n\n        @Override\n        public boolean remove(final Object value) {\n            if (parent.reverseMap.containsKey(value)) {\n                final Object key = parent.reverseMap.remove(value);\n                parent.normalMap.remove(key);\n                return true;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Inner class ValuesIterator.\n     *\n     * @param <V> the value type.\n     */\n    protected static class ValuesIterator<V> extends AbstractIteratorDecorator<V> {\n\n        /** The parent map */\n        protected final AbstractDualBidiMap<Object, V> parent;\n\n        /** The last returned value */\n        protected V lastValue;\n\n        /** Whether remove is allowed at present */\n        protected boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         * @param iterator  the iterator to decorate\n         * @param parent  the parent map\n         */\n        @SuppressWarnings(\"unchecked\")\n        protected ValuesIterator(final Iterator<V> iterator, final AbstractDualBidiMap<?, V> parent) {\n            super(iterator);\n            this.parent = (AbstractDualBidiMap<Object, V>) parent;\n        }\n\n        @Override\n        public V next() {\n            lastValue = super.next();\n            canRemove = true;\n            return lastValue;\n        }\n\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            super.remove(); // removes from maps[0]\n            parent.reverseMap.remove(lastValue);\n            lastValue = null;\n            canRemove = false;\n        }\n    }\n\n    /**\n     * Inner class View.\n     *\n     * @param <K> the type of the keys in the map.\n     * @param <V> the type of the values in the map.\n     * @param <E> the type of the elements in the collection.\n     */\n    protected abstract static class View<K, V, E> extends AbstractCollectionDecorator<E> {\n\n        /** Generated serial version ID. */\n        private static final long serialVersionUID = 4621510560119690639L;\n\n        /** The parent map */\n        protected final AbstractDualBidiMap<K, V> parent;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param coll  the collection view being decorated\n         * @param parent  the parent BidiMap\n         */\n        protected View(final Collection<E> coll, final AbstractDualBidiMap<K, V> parent) {\n            super(coll);\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean equals(final Object object) {\n            return object == this || decorated().equals(object);\n        }\n\n        @Override\n        public int hashCode() {\n            return decorated().hashCode();\n        }\n\n        @Override\n        public boolean removeAll(final Collection<?> coll) {\n            if (parent.isEmpty() || coll.isEmpty()) {\n                return false;\n            }\n            boolean modified = false;\n            for (final Object current : coll) {\n                modified |= remove(current);\n            }\n            return modified;\n        }\n\n        /**\n         * @since 4.4\n         */\n        @Override\n        public boolean removeIf(final Predicate<? super E> filter) {\n            if (parent.isEmpty() || Objects.isNull(filter)) {\n                return false;\n            }\n            boolean modified = false;\n            final Iterator<?> it = iterator();\n            while (it.hasNext()) {\n                @SuppressWarnings(\"unchecked\")\n                final E e = (E) it.next();\n                if (filter.test(e)) {\n                    it.remove();\n                    modified = true;\n                }\n            }\n            return modified;\n        }\n\n        /**\n         * {@inheritDoc}\n         * <p>\n         * This implementation iterates over the elements of this bidi map, checking each element in\n         * turn to see if it's contained in {@code coll}. If it's not contained, it's removed\n         * from this bidi map. As a consequence, it is advised to use a collection type for\n         * {@code coll} that provides a fast (e.g. O(1)) implementation of\n         * {@link Collection#contains(Object)}.\n         */\n        @Override\n        public boolean retainAll(final Collection<?> coll) {\n            if (parent.isEmpty()) {\n                return false;\n            }\n            if (coll.isEmpty()) {\n                parent.clear();\n                return true;\n            }\n            boolean modified = false;\n            final Iterator<E> it = iterator();\n            while (it.hasNext()) {\n                if (!coll.contains(it.next())) {\n                    it.remove();\n                    modified = true;\n                }\n            }\n            return modified;\n        }\n    }\n\n    /**\n     * Normal delegate map.\n     */\n    transient Map<K, V> normalMap;\n\n    // Map delegation\n\n    /**\n     * Reverse delegate map.\n     */\n    transient Map<V, K> reverseMap;\n\n    /**\n     * Inverse view of this map.\n     */\n    transient BidiMap<V, K> inverseBidiMap;\n\n    /**\n     * View of the keys.\n     */\n    transient Set<K> keySet;\n\n    /**\n     * View of the values.\n     */\n    transient Set<V> values;\n\n    /**\n     * View of the entries.\n     */\n    transient Set<Map.Entry<K, V>> entrySet;\n\n    /**\n     * Creates an empty map, initialized by {@code createMap}.\n     * <p>\n     * This constructor remains in place for deserialization.\n     * All other usage is deprecated in favor of\n     * {@link #AbstractDualBidiMap(Map, Map)}.\n     */\n    protected AbstractDualBidiMap() {\n    }\n\n    /**\n     * Creates an empty map using the two maps specified as storage.\n     * <p>\n     * The two maps must be a matching pair, normal and reverse.\n     * They will typically both be empty.\n     * <p>\n     * Neither map is validated, so nulls may be passed in.\n     * If you choose to do this then the subclass constructor must populate\n     * the {@code maps[]} instance variable itself.\n     *\n     * @param normalMap  the normal direction map\n     * @param reverseMap  the reverse direction map\n     * @since 3.1\n     */\n    protected AbstractDualBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap) {\n        this.normalMap = normalMap;\n        this.reverseMap = reverseMap;\n    }\n\n    // BidiMap changes\n\n    /**\n     * Constructs a map that decorates the specified maps,\n     * used by the subclass {@code createBidiMap} implementation.\n     *\n     * @param normalMap  the normal direction map\n     * @param reverseMap  the reverse direction map\n     * @param inverseBidiMap  the inverse BidiMap\n     */\n    protected AbstractDualBidiMap(final Map<K, V> normalMap, final Map<V, K> reverseMap,\n                                  final BidiMap<V, K> inverseBidiMap) {\n        this.normalMap = normalMap;\n        this.reverseMap = reverseMap;\n        this.inverseBidiMap = inverseBidiMap;\n    }\n\n    @Override\n    public void clear() {\n        normalMap.clear();\n        reverseMap.clear();\n    }\n\n    @Override\n    public boolean containsKey(final Object key) {\n        return normalMap.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(final Object value) {\n        return reverseMap.containsKey(value);\n    }\n\n    /**\n     * Creates a new instance of the subclass.\n     *\n     * @param normalMap  the normal direction map\n     * @param reverseMap  the reverse direction map\n     * @param inverseMap  this map, which is the inverse in the new map\n     * @return the bidi map\n     */\n    protected abstract BidiMap<V, K> createBidiMap(Map<V, K> normalMap, Map<K, V> reverseMap, BidiMap<K, V> inverseMap);\n\n    /**\n     * Creates an entry set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @param iterator  the iterator to decorate\n     * @return the entrySet iterator\n     */\n    protected Iterator<Map.Entry<K, V>> createEntrySetIterator(final Iterator<Map.Entry<K, V>> iterator) {\n        return new EntrySetIterator<>(iterator, this);\n    }\n\n    /**\n     * Creates a key set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @param iterator  the iterator to decorate\n     * @return the keySet iterator\n     */\n    protected Iterator<K> createKeySetIterator(final Iterator<K> iterator) {\n        return new KeySetIterator<>(iterator, this);\n    }\n\n    /**\n     * Creates a values iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @param iterator  the iterator to decorate\n     * @return the values iterator\n     */\n    protected Iterator<V> createValuesIterator(final Iterator<V> iterator) {\n        return new ValuesIterator<>(iterator, this);\n    }\n\n    /**\n     * Gets an entrySet view of the map.\n     * Changes made on the set are reflected in the map.\n     * The set supports remove and clear but not add.\n     * <p>\n     * The Map Entry setValue() method only allow a new value to be set.\n     * If the value being set is already in the map, an IllegalArgumentException\n     * is thrown (as setValue cannot change the size of the map).\n     * </p>\n     *\n     * @return the entrySet view\n     */\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        if (entrySet == null) {\n            entrySet = new EntrySet<>(this);\n        }\n        return entrySet;\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        return normalMap.equals(obj);\n    }\n\n    @Override\n    public V get(final Object key) {\n        return normalMap.get(key);\n    }\n\n    @Override\n    public K getKey(final Object value) {\n        return reverseMap.get(value);\n    }\n\n    @Override\n    public int hashCode() {\n        return normalMap.hashCode();\n    }\n\n    @Override\n    public BidiMap<V, K> inverseBidiMap() {\n        if (inverseBidiMap == null) {\n            inverseBidiMap = createBidiMap(reverseMap, normalMap, this);\n        }\n        return inverseBidiMap;\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return normalMap.isEmpty();\n    }\n\n    // Map views\n    /**\n     * Gets a keySet view of the map.\n     * Changes made on the view are reflected in the map.\n     * The set supports remove and clear but not add.\n     *\n     * @return the keySet view\n     */\n    @Override\n    public Set<K> keySet() {\n        if (keySet == null) {\n            keySet = new KeySet<>(this);\n        }\n        return keySet;\n    }\n\n    // BidiMap\n    /**\n     * Obtains a {@code MapIterator} over the map.\n     * The iterator implements {@link BidiMapIterator}.\n     * This implementation relies on the entrySet iterator.\n     *\n     * @return a map iterator\n     */\n    @Override\n    public MapIterator<K, V> mapIterator() {\n        return new BidiMapIterator<>(this);\n    }\n\n    @Override\n    public V put(final K key, final V value) {\n        if (normalMap.containsKey(key)) {\n            reverseMap.remove(normalMap.get(key));\n        }\n        if (reverseMap.containsKey(value)) {\n            normalMap.remove(reverseMap.get(value));\n        }\n        final V obj = normalMap.put(key, value);\n        reverseMap.put(value, key);\n        return obj;\n    }\n\n    @Override\n    public void putAll(final Map<? extends K, ? extends V> map) {\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            put(entry.getKey(), entry.getValue());\n        }\n    }\n\n    @Override\n    public V remove(final Object key) {\n        V value = null;\n        if (normalMap.containsKey(key)) {\n            value = normalMap.remove(key);\n            reverseMap.remove(value);\n        }\n        return value;\n    }\n\n    @Override\n    public K removeValue(final Object value) {\n        K key = null;\n        if (reverseMap.containsKey(value)) {\n            key = reverseMap.remove(value);\n            normalMap.remove(key);\n        }\n        return key;\n    }\n\n    @Override\n    public int size() {\n        return normalMap.size();\n    }\n\n    @Override\n    public String toString() {\n        return normalMap.toString();\n    }\n\n    /**\n     * Gets a values view of the map.\n     * Changes made on the view are reflected in the map.\n     * The set supports remove and clear but not add.\n     *\n     * @return the values view\n     */\n    @Override\n    public Set<V> values() {\n        if (values == null) {\n            values = new Values<>(this);\n        }\n        return values;\n    }\n\n}", "super_interfaces": ["BidiMap<K, V>"], "fields": [{"attribute_expression": "transient Map<K, V> normalMap;", "docstring": "\nNormal delegate map.\n", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "Map<K, V>", "name": "normalMap", "syntax_pass": true}, {"attribute_expression": "transient Map<V, K> reverseMap;", "docstring": "\nReverse delegate map.\n", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "Map<V, K>", "name": "reverseMap", "syntax_pass": true}, {"attribute_expression": "transient BidiMap<V, K> inverseBidiMap;", "docstring": "\nInverse view of this map.\n", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "BidiMap<V, K>", "name": "inverseBidiMap", "syntax_pass": true}, {"attribute_expression": "transient Set<K> keySet;", "docstring": "\nView of the keys.\n", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "Set<K>", "name": "keySet", "syntax_pass": true}, {"attribute_expression": "transient Set<V> values;", "docstring": "\nView of the values.\n", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "Set<V>", "name": "values", "syntax_pass": true}, {"attribute_expression": "transient Set<Map.Entry<K, V>> entrySet;", "docstring": "\nView of the entries.\n", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "Set<Map.Entry<K, V>>", "name": "entrySet", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java.AbstractNavigableSetDecorator", "name": "AbstractNavigableSetDecorator", "file_path": "src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java", "superclasses": "", "methods": ["[]AbstractNavigableSetDecorator()", "[]AbstractNavigableSetDecorator(NavigableSet<E>)", "[E]ceiling(E)", "[NavigableSet<E>]decorated()", "[Iterator<E>]descendingIterator()", "[NavigableSet<E>]descendingSet()", "[E]floor(E)", "[NavigableSet<E>]headSet(E,boolean)", "[E]higher(E)", "[E]lower(E)", "[E]pollFirst()", "[E]pollLast()", "[NavigableSet<E>]subSet(E,boolean,E,boolean)", "[NavigableSet<E>]tailSet(E,boolean)"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java.AbstractNavigableSetDecorator.[]AbstractNavigableSetDecorator()", "src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java.AbstractNavigableSetDecorator.[]AbstractNavigableSetDecorator(NavigableSet<E>)", "src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java.AbstractNavigableSetDecorator.[E]ceiling(E)", "src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java.AbstractNavigableSetDecorator.[NavigableSet<E>]decorated()", "src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java.AbstractNavigableSetDecorator.[Iterator<E>]descendingIterator()", "src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java.AbstractNavigableSetDecorator.[NavigableSet<E>]descendingSet()", "src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java.AbstractNavigableSetDecorator.[E]floor(E)", "src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java.AbstractNavigableSetDecorator.[NavigableSet<E>]headSet(E,boolean)", "src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java.AbstractNavigableSetDecorator.[E]higher(E)", "src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java.AbstractNavigableSetDecorator.[E]lower(E)", "src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java.AbstractNavigableSetDecorator.[E]pollFirst()", "src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java.AbstractNavigableSetDecorator.[E]pollLast()", "src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java.AbstractNavigableSetDecorator.[NavigableSet<E>]subSet(E,boolean,E,boolean)", "src/main/java/org/apache/commons/collections4/set/AbstractNavigableSetDecorator.java.AbstractNavigableSetDecorator.[NavigableSet<E>]tailSet(E,boolean)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code NavigableSet} to provide additional behavior.\n<p>\nMethods are forwarded directly to the decorated set.\n</p>\n\n@param <E> the type of the elements in the navigable set\n@since 4.1\n", "original_string": "public abstract class AbstractNavigableSetDecorator<E>\n        extends AbstractSortedSetDecorator<E>\n        implements NavigableSet<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 20150528L;\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     */\n    protected AbstractNavigableSetDecorator() {\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param set  the set to decorate, must not be null\n     * @throws NullPointerException if set is null\n     */\n    protected AbstractNavigableSetDecorator(final NavigableSet<E> set) {\n        super(set);\n    }\n\n    @Override\n    public E ceiling(final E e) {\n        return decorated().ceiling(e);\n    }\n\n    /**\n     * Gets the set being decorated.\n     *\n     * @return the decorated set\n     */\n    @Override\n    protected NavigableSet<E> decorated() {\n        return (NavigableSet<E>) super.decorated();\n    }\n\n    @Override\n    public Iterator<E> descendingIterator() {\n        return decorated().descendingIterator();\n    }\n\n    @Override\n    public NavigableSet<E> descendingSet() {\n        return decorated().descendingSet();\n    }\n\n    @Override\n    public E floor(final E e) {\n        return decorated().floor(e);\n    }\n\n    @Override\n    public NavigableSet<E> headSet(final E toElement, final boolean inclusive) {\n        return decorated().headSet(toElement, inclusive);\n    }\n\n    @Override\n    public E higher(final E e) {\n        return decorated().higher(e);\n    }\n\n    @Override\n    public E lower(final E e) {\n        return decorated().lower(e);\n    }\n\n    @Override\n    public E pollFirst() {\n        return decorated().pollFirst();\n    }\n\n    @Override\n    public E pollLast() {\n        return decorated().pollLast();\n    }\n\n    @Override\n    public NavigableSet<E> subSet(final E fromElement, final boolean fromInclusive, final E toElement,\n            final boolean toInclusive) {\n        return decorated().subSet(fromElement, fromInclusive, toElement, toInclusive);\n    }\n\n    @Override\n    public NavigableSet<E> tailSet(final E fromElement, final boolean inclusive) {\n        return decorated().tailSet(fromElement, inclusive);\n    }\n\n}", "super_interfaces": ["NavigableSet<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 20150528L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 20150528L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java.AbstractSortedSetDecorator", "name": "AbstractSortedSetDecorator", "file_path": "src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java", "superclasses": "", "methods": ["[]AbstractSortedSetDecorator()", "[]AbstractSortedSetDecorator(Set<E>)", "[Comparator<? super E>]comparator()", "[SortedSet<E>]decorated()", "[E]first()", "[SortedSet<E>]headSet(E)", "[E]last()", "[SortedSet<E>]subSet(E,E)", "[SortedSet<E>]tailSet(E)"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java.AbstractSortedSetDecorator.[]AbstractSortedSetDecorator()", "src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java.AbstractSortedSetDecorator.[]AbstractSortedSetDecorator(Set<E>)", "src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java.AbstractSortedSetDecorator.[Comparator<? super E>]comparator()", "src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java.AbstractSortedSetDecorator.[SortedSet<E>]decorated()", "src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java.AbstractSortedSetDecorator.[E]first()", "src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java.AbstractSortedSetDecorator.[SortedSet<E>]headSet(E)", "src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java.AbstractSortedSetDecorator.[E]last()", "src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java.AbstractSortedSetDecorator.[SortedSet<E>]subSet(E,E)", "src/main/java/org/apache/commons/collections4/set/AbstractSortedSetDecorator.java.AbstractSortedSetDecorator.[SortedSet<E>]tailSet(E)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code SortedSet} to provide additional behavior.\n<p>\nMethods are forwarded directly to the decorated set.\n</p>\n\n@param <E> the type of the elements in the sorted set\n@since 3.0\n", "original_string": "public abstract class AbstractSortedSetDecorator<E>\n        extends AbstractSetDecorator<E>\n        implements SortedSet<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -3462240946294214398L;\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     * @since 3.1\n     */\n    protected AbstractSortedSetDecorator() {\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param set  the set to decorate, must not be null\n     * @throws NullPointerException if set is null\n     */\n    protected AbstractSortedSetDecorator(final Set<E> set) {\n        super(set);\n    }\n\n    @Override\n    public Comparator<? super E> comparator() {\n        return decorated().comparator();\n    }\n\n    /**\n     * Gets the set being decorated.\n     *\n     * @return the decorated set\n     */\n    @Override\n    protected SortedSet<E> decorated() {\n        return (SortedSet<E>) super.decorated();\n    }\n\n    @Override\n    public E first() {\n        return decorated().first();\n    }\n\n    @Override\n    public SortedSet<E> headSet(final E toElement) {\n        return decorated().headSet(toElement);\n    }\n\n    @Override\n    public E last() {\n        return decorated().last();\n    }\n\n    @Override\n    public SortedSet<E> subSet(final E fromElement, final E toElement) {\n        return decorated().subSet(fromElement, toElement);\n    }\n\n    @Override\n    public SortedSet<E> tailSet(final E fromElement) {\n        return decorated().tailSet(fromElement);\n    }\n\n}", "super_interfaces": ["SortedSet<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -3462240946294214398L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -3462240946294214398L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java.AbstractSetDecorator", "name": "AbstractSetDecorator", "file_path": "src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java", "superclasses": "", "methods": ["[]AbstractSetDecorator()", "[]AbstractSetDecorator(Set<E>)", "[Set<E>]decorated()", "[boolean]equals(Object)", "[int]hashCode()"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java.AbstractSetDecorator.[]AbstractSetDecorator()", "src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java.AbstractSetDecorator.[]AbstractSetDecorator(Set<E>)", "src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java.AbstractSetDecorator.[Set<E>]decorated()", "src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java.AbstractSetDecorator.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/set/AbstractSetDecorator.java.AbstractSetDecorator.[int]hashCode()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code Set} to provide additional behavior.\n<p>\nMethods are forwarded directly to the decorated set.\n</p>\n\n@param <E> the type of the elements in this set\n@since 3.0\n", "original_string": "public abstract class AbstractSetDecorator<E> extends AbstractCollectionDecorator<E> implements\n        Set<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -4678668309576958546L;\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     * @since 3.1\n     */\n    protected AbstractSetDecorator() {\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param set  the set to decorate, must not be null\n     * @throws NullPointerException if set is null\n     */\n    protected AbstractSetDecorator(final Set<E> set) {\n        super(set);\n    }\n\n    /**\n     * Gets the set being decorated.\n     *\n     * @return the decorated set\n     */\n    @Override\n    protected Set<E> decorated() {\n        return (Set<E>) super.decorated();\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        return object == this || decorated().equals(object);\n    }\n\n    @Override\n    public int hashCode() {\n        return decorated().hashCode();\n    }\n\n}", "super_interfaces": ["Set<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -4678668309576958546L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -4678668309576958546L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/set/AbstractSerializableSetDecorator.java.AbstractSerializableSetDecorator", "name": "AbstractSerializableSetDecorator", "file_path": "src/main/java/org/apache/commons/collections4/set/AbstractSerializableSetDecorator.java", "superclasses": "", "methods": ["[]AbstractSerializableSetDecorator(Set<E>)", "[void]readObject(ObjectInputStream)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/set/AbstractSerializableSetDecorator.java.AbstractSerializableSetDecorator.[]AbstractSerializableSetDecorator(Set<E>)", "src/main/java/org/apache/commons/collections4/set/AbstractSerializableSetDecorator.java.AbstractSerializableSetDecorator.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/set/AbstractSerializableSetDecorator.java.AbstractSerializableSetDecorator.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nSerializable subclass of AbstractSetDecorator.\n\n@param <E> the type of the elements in this set\n@since 3.1\n", "original_string": "public abstract class AbstractSerializableSetDecorator<E>\n        extends AbstractSetDecorator<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 1229469966212206107L;\n\n    /**\n     * Constructs a new instance.\n     *\n     * @param set  the list to decorate, must not be null\n     * @throws NullPointerException if set is null\n     */\n    protected AbstractSerializableSetDecorator(final Set<E> set) {\n        super(set);\n    }\n\n    /**\n     * Deserializes the set in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        setCollection((Collection<E>) in.readObject());\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(decorated());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 1229469966212206107L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 1229469966212206107L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/list/AbstractSerializableListDecorator.java.AbstractSerializableListDecorator", "name": "AbstractSerializableListDecorator", "file_path": "src/main/java/org/apache/commons/collections4/list/AbstractSerializableListDecorator.java", "superclasses": "", "methods": ["[]AbstractSerializableListDecorator(List<E>)", "[void]readObject(ObjectInputStream)", "[void]writeObject(ObjectOutputStream)"], "method_uris": ["src/main/java/org/apache/commons/collections4/list/AbstractSerializableListDecorator.java.AbstractSerializableListDecorator.[]AbstractSerializableListDecorator(List<E>)", "src/main/java/org/apache/commons/collections4/list/AbstractSerializableListDecorator.java.AbstractSerializableListDecorator.[void]readObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/list/AbstractSerializableListDecorator.java.AbstractSerializableListDecorator.[void]writeObject(ObjectOutputStream)"], "overrides": null, "attributes": [], "class_docstring": "\nSerializable subclass of AbstractListDecorator.\n\n@param <E> the type of the elements in the list.\n@since 3.1\n", "original_string": "public abstract class AbstractSerializableListDecorator<E> extends AbstractListDecorator<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 2684959196747496299L;\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param list  the list to decorate, must not be null\n     * @throws NullPointerException if list is null\n     */\n    protected AbstractSerializableListDecorator(final List<E> list) {\n        super(list);\n    }\n\n    /**\n     * Deserializes the list in using a custom routine.\n     *\n     * @param in  the input stream\n     * @throws IOException if an error occurs while reading from the stream\n     * @throws ClassNotFoundException if an object read from the stream can not be loaded\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        setCollection((Collection<E>) in.readObject());\n    }\n\n    /**\n     * Serializes this object to an ObjectOutputStream.\n     *\n     * @param out the target ObjectOutputStream.\n     * @throws IOException thrown when an I/O errors occur writing to the target stream.\n     */\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeObject(decorated());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = 2684959196747496299L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 2684959196747496299L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator", "name": "AbstractListDecorator", "file_path": "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java", "superclasses": "", "methods": ["[]AbstractListDecorator()", "[]AbstractListDecorator(List<E>)", "[void]add(int,E)", "[boolean]addAll(int,Collection<? extends E>)", "[List<E>]decorated()", "[boolean]equals(Object)", "[E]get(int)", "[int]hashCode()", "[int]indexOf(Object)", "[int]lastIndexOf(Object)", "[ListIterator<E>]listIterator()", "[ListIterator<E>]listIterator(int)", "[E]remove(int)", "[E]set(int,E)", "[List<E>]subList(int,int)"], "method_uris": ["src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator.[]AbstractListDecorator()", "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator.[]AbstractListDecorator(List<E>)", "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator.[void]add(int,E)", "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator.[boolean]addAll(int,Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator.[List<E>]decorated()", "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator.[E]get(int)", "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator.[int]hashCode()", "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator.[int]indexOf(Object)", "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator.[int]lastIndexOf(Object)", "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator.[ListIterator<E>]listIterator()", "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator.[ListIterator<E>]listIterator(int)", "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator.[E]remove(int)", "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator.[E]set(int,E)", "src/main/java/org/apache/commons/collections4/list/AbstractListDecorator.java.AbstractListDecorator.[List<E>]subList(int,int)"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@link List} to provide additional behavior.\n<p>\nMethods are forwarded directly to the decorated list.\n</p>\n\n@param <E> the type of the elements in the list.\n@since 3.0\n", "original_string": "public abstract class AbstractListDecorator<E> extends AbstractCollectionDecorator<E> implements List<E> {\n\n    /** Serialization version--necessary in an abstract class? */\n    private static final long serialVersionUID = 4500739654952315623L;\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     * @since 3.1\n     */\n    protected AbstractListDecorator() {\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param list  the list to decorate, must not be null\n     * @throws NullPointerException if list is null\n     */\n    protected AbstractListDecorator(final List<E> list) {\n        super(list);\n    }\n\n    @Override\n    public void add(final int index, final E object) {\n        decorated().add(index, object);\n    }\n\n    @Override\n    public boolean addAll(final int index, final Collection<? extends E> coll) {\n        return decorated().addAll(index, coll);\n    }\n\n    /**\n     * Gets the list being decorated.\n     *\n     * @return the decorated list\n     */\n    @Override\n    protected List<E> decorated() {\n        return (List<E>) super.decorated();\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        return object == this || decorated().equals(object);\n    }\n\n    @Override\n    public E get(final int index) {\n        return decorated().get(index);\n    }\n\n    @Override\n    public int hashCode() {\n        return decorated().hashCode();\n    }\n\n    @Override\n    public int indexOf(final Object object) {\n        return decorated().indexOf(object);\n    }\n\n    @Override\n    public int lastIndexOf(final Object object) {\n        return decorated().lastIndexOf(object);\n    }\n\n    @Override\n    public ListIterator<E> listIterator() {\n        return decorated().listIterator();\n    }\n\n    @Override\n    public ListIterator<E> listIterator(final int index) {\n        return decorated().listIterator(index);\n    }\n\n    @Override\n    public E remove(final int index) {\n        return decorated().remove(index);\n    }\n\n    @Override\n    public E set(final int index, final E object) {\n        return decorated().set(index, object);\n    }\n\n    @Override\n    public List<E> subList(final int fromIndex, final int toIndex) {\n        return decorated().subList(fromIndex, toIndex);\n    }\n\n}", "super_interfaces": ["List<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 4500739654952315623L;", "docstring": " Serialization version--necessary in an abstract class?", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 4500739654952315623L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList", "name": "AbstractLinkedList", "file_path": "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java", "superclasses": "", "methods": ["[]AbstractLinkedList()", "[]AbstractLinkedList(Collection<? extends E>)", "[boolean]add(E)", "[void]add(int,E)", "[boolean]addAll(Collection<? extends E>)", "[boolean]addAll(int,Collection<? extends E>)", "[boolean]addFirst(E)", "[boolean]addLast(E)", "[void]addNode(Node<E>,Node<E>)", "[void]addNodeAfter(Node<E>,E)", "[void]addNodeBefore(Node<E>,E)", "[void]clear()", "[boolean]contains(Object)", "[boolean]containsAll(Collection<?>)", "[Node<E>]createHeaderNode()", "[Node<E>]createNode(E)", "[Iterator<E>]createSubListIterator(LinkedSubList<E>)", "[ListIterator<E>]createSubListListIterator(LinkedSubList<E>,int)", "[void]doReadObject(ObjectInputStream)", "[void]doWriteObject(ObjectOutputStream)", "[boolean]equals(Object)", "[E]get(int)", "[E]getFirst()", "[E]getLast()", "[Node<E>]getNode(int,boolean)", "[int]hashCode()", "[int]indexOf(Object)", "[void]init()", "[boolean]isEmpty()", "[boolean]isEqualValue(Object,Object)", "[Iterator<E>]iterator()", "[int]lastIndexOf(Object)", "[ListIterator<E>]listIterator()", "[ListIterator<E>]listIterator(int)", "[E]remove(int)", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[void]removeAllNodes()", "[E]removeFirst()", "[E]removeLast()", "[void]removeNode(Node<E>)", "[boolean]retainAll(Collection<?>)", "[E]set(int,E)", "[int]size()", "[List<E>]subList(int,int)", "[Object[]]toArray()", "[T[]]toArray(T[])", "[String]toString()", "[void]updateNode(Node<E>,E)"], "method_uris": ["src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[]AbstractLinkedList()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[]AbstractLinkedList(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[void]add(int,E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[boolean]addAll(int,Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[boolean]addFirst(E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[boolean]addLast(E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[void]addNode(Node<E>,Node<E>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[void]addNodeAfter(Node<E>,E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[void]addNodeBefore(Node<E>,E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[void]clear()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[boolean]contains(Object)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[boolean]containsAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[Node<E>]createHeaderNode()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[Node<E>]createNode(E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[Iterator<E>]createSubListIterator(LinkedSubList<E>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[ListIterator<E>]createSubListListIterator(LinkedSubList<E>,int)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[void]doReadObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[void]doWriteObject(ObjectOutputStream)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[E]get(int)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[E]getFirst()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[E]getLast()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[Node<E>]getNode(int,boolean)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[int]hashCode()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[int]indexOf(Object)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[void]init()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[boolean]isEqualValue(Object,Object)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[int]lastIndexOf(Object)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[ListIterator<E>]listIterator()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[ListIterator<E>]listIterator(int)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[E]remove(int)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[void]removeAllNodes()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[E]removeFirst()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[E]removeLast()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[void]removeNode(Node<E>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[E]set(int,E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[int]size()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[List<E>]subList(int,int)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[Object[]]toArray()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[T[]]toArray(T[])", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[String]toString()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedList.java.AbstractLinkedList.[void]updateNode(Node<E>,E)"], "overrides": null, "attributes": [{"original_string": "    protected static class LinkedListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n\n        /** The parent list */\n        protected final AbstractLinkedList<E> parent;\n\n        /**\n         * The node that will be returned by {@link #next()}. If this is equal\n         * to {@link AbstractLinkedList#header} then there are no more values to return.\n         */\n        protected Node<E> next;\n\n        /**\n         * The index of {@link #next}.\n         */\n        protected int nextIndex;\n\n        /**\n         * The last node that was returned by {@link #next()} or {@link\n         * #previous()}. Set to {@code null} if {@link #next()} or {@link\n         * #previous()} haven't been called, or if the node has been removed\n         * with {@link #remove()} or a new node added with {@link #add(Object)}.\n         * Should be accessed through {@link #getLastNodeReturned()} to enforce\n         * this behavior.\n         */\n        protected Node<E> current;\n\n        /**\n         * The modification count that the list is expected to have. If the list\n         * doesn't have this count, then a\n         * {@link java.util.ConcurrentModificationException} may be thrown by\n         * the operations.\n         */\n        protected int expectedModCount;\n\n        /**\n         * Create a ListIterator for a list.\n         *\n         * @param parent  the parent list.\n         * @param fromIndex  The starting index.\n         * @throws IndexOutOfBoundsException if fromIndex is less than 0 or greater than the size of the list.\n         */\n        protected LinkedListIterator(final AbstractLinkedList<E> parent, final int fromIndex)\n                throws IndexOutOfBoundsException {\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.getNode(fromIndex, true);\n            this.nextIndex = fromIndex;\n        }\n\n        @Override\n        public void add(final E obj) {\n            checkModCount();\n            parent.addNodeBefore(next, obj);\n            current = null;\n            nextIndex++;\n            expectedModCount++;\n        }\n\n        /**\n         * Checks the modification count of the list is the value that this\n         * object expects.\n         *\n         * @throws ConcurrentModificationException If the list's modification\n         * count isn't the value that was expected.\n         */\n        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        /**\n         * Gets the last node returned.\n         *\n         * @return the last node returned\n         * @throws IllegalStateException If {@link #next()} or {@link #previous()} haven't been called,\n         * or if the node has been removed with {@link #remove()} or a new node added with {@link #add(Object)}.\n         */\n        protected Node<E> getLastNodeReturned() throws IllegalStateException {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return next != parent.header;\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return next.previous != parent.header;\n        }\n\n        @Override\n        public E next() {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            final E value = next.getValue();\n            current = next;\n            next = next.next;\n            nextIndex++;\n            return value;\n        }\n\n        @Override\n        public int nextIndex() {\n            return nextIndex;\n        }\n\n        @Override\n        public E previous() {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            next = next.previous;\n            final E value = next.getValue();\n            current = next;\n            nextIndex--;\n            return value;\n        }\n\n        @Override\n        public int previousIndex() {\n            // not normally overridden, as relative to nextIndex()\n            return nextIndex() - 1;\n        }\n\n        @Override\n        public void remove() {\n            checkModCount();\n            if (current == next) {\n                // remove() following previous()\n                next = next.next;\n                parent.removeNode(getLastNodeReturned());\n            } else {\n                // remove() following next()\n                parent.removeNode(getLastNodeReturned());\n                nextIndex--;\n            }\n            current = null;\n            expectedModCount++;\n        }\n\n        @Override\n        public void set(final E value) {\n            checkModCount();\n            getLastNodeReturned().setValue(value);\n        }\n\n    }", "definition": "    protected static class LinkedListIterator<E> implements ListIterator<E>, OrderedIterator<E>", "class_docstring": "\nA list iterator over the linked list.\n\n@param <E> the type of elements in this iterator.\n", "name": "LinkedListIterator", "super_interfaces": ["ListIterator<E>", "OrderedIterator<E>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected final AbstractLinkedList<E> parent;", "docstring": " The parent list", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "AbstractLinkedList<E>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "protected Node<E> next;", "docstring": "\nThe node that will be returned by {@link #next()}. If this is equal\nto {@link AbstractLinkedList#header} then there are no more values to return.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Node<E>", "name": "next", "syntax_pass": true}, {"attribute_expression": "protected int nextIndex;", "docstring": "\nThe index of {@link #next}.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "nextIndex", "syntax_pass": true}, {"attribute_expression": "protected Node<E> current;", "docstring": "\nThe last node that was returned by {@link #next()} or {@link\n#previous()}. Set to {@code null} if {@link #next()} or {@link\n#previous()} haven't been called, or if the node has been removed\nwith {@link #remove()} or a new node added with {@link #add(Object)}.\nShould be accessed through {@link #getLastNodeReturned()} to enforce\nthis behavior.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Node<E>", "name": "current", "syntax_pass": true}, {"attribute_expression": "protected int expectedModCount;", "docstring": "\nThe modification count that the list is expected to have. If the list\ndoesn't have this count, then a\n{@link java.util.ConcurrentModificationException} may be thrown by\nthe operations.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "expectedModCount", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected LinkedListIterator(final AbstractLinkedList<E> parent, final int fromIndex)\n                throws IndexOutOfBoundsException {\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.getNode(fromIndex, true);\n            this.nextIndex = fromIndex;\n        }", "docstring": "\nCreate a ListIterator for a list.\n\n@param parent  the parent list.\n@param fromIndex  The starting index.\n@throws IndexOutOfBoundsException if fromIndex is less than 0 or greater than the size of the list.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "LinkedListIterator", "params": [{"name": "parent", "type": "AbstractLinkedList<E>"}, {"name": "fromIndex", "type": "int"}], "body": "                                                 {\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.getNode(fromIndex, true);\n            this.nextIndex = fromIndex;\n        }", "signature": "protected LinkedListIterator(final AbstractLinkedList<E> parent, final int fromIndex)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void add(final E obj) {\n            checkModCount();\n            parent.addNodeBefore(next, obj);\n            current = null;\n            nextIndex++;\n            expectedModCount++;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "obj", "type": "E"}], "body": "                                     {\n            checkModCount();\n            parent.addNodeBefore(next, obj);\n            current = null;\n            nextIndex++;\n            expectedModCount++;\n        }", "signature": "@Override\n        public void add(final E obj)"}, {"syntax_pass": true, "original_string": "        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }", "docstring": "\nChecks the modification count of the list is the value that this\nobject expects.\n\n@throws ConcurrentModificationException If the list's modification\ncount isn't the value that was expected.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "checkModCount", "params": [], "body": "                                       {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }", "signature": "protected void checkModCount()"}, {"syntax_pass": true, "original_string": "        protected Node<E> getLastNodeReturned() throws IllegalStateException {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current;\n        }", "docstring": "\nGets the last node returned.\n\n@return the last node returned\n@throws IllegalStateException If {@link #next()} or {@link #previous()} haven't been called,\nor if the node has been removed with {@link #remove()} or a new node added with {@link #add(Object)}.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Node<E>", "classes": []}, "name": "getLastNodeReturned", "params": [], "body": "                                                                             {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current;\n        }", "signature": "protected Node<E> getLastNodeReturned()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return next != parent.header;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return next != parent.header;\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasPrevious() {\n            return next.previous != parent.header;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasPrevious", "params": [], "body": "                                     {\n            return next.previous != parent.header;\n        }", "signature": "@Override\n        public boolean hasPrevious()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E next() {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            final E value = next.getValue();\n            current = next;\n            next = next.next;\n            nextIndex++;\n            return value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "next", "params": [], "body": "                        {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            final E value = next.getValue();\n            current = next;\n            next = next.next;\n            nextIndex++;\n            return value;\n        }", "signature": "@Override\n        public E next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int nextIndex() {\n            return nextIndex;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "nextIndex", "params": [], "body": "                               {\n            return nextIndex;\n        }", "signature": "@Override\n        public int nextIndex()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E previous() {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            next = next.previous;\n            final E value = next.getValue();\n            current = next;\n            nextIndex--;\n            return value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            next = next.previous;\n            final E value = next.getValue();\n            current = next;\n            nextIndex--;\n            return value;\n        }", "signature": "@Override\n        public E previous()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int previousIndex() {\n            // not normally overridden, as relative to nextIndex()\n            return nextIndex() - 1;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "previousIndex", "params": [], "body": "                                   {\n            // not normally overridden, as relative to nextIndex()\n            return nextIndex() - 1;\n        }", "signature": "@Override\n        public int previousIndex()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            checkModCount();\n            if (current == next) {\n                // remove() following previous()\n                next = next.next;\n                parent.removeNode(getLastNodeReturned());\n            } else {\n                // remove() following next()\n                parent.removeNode(getLastNodeReturned());\n                nextIndex--;\n            }\n            current = null;\n            expectedModCount++;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            checkModCount();\n            if (current == next) {\n                // remove() following previous()\n                next = next.next;\n                parent.removeNode(getLastNodeReturned());\n            } else {\n                // remove() following next()\n                parent.removeNode(getLastNodeReturned());\n                nextIndex--;\n            }\n            current = null;\n            expectedModCount++;\n        }", "signature": "@Override\n        public void remove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void set(final E value) {\n            checkModCount();\n            getLastNodeReturned().setValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "set", "params": [{"name": "value", "type": "E"}], "body": "                                       {\n            checkModCount();\n            getLastNodeReturned().setValue(value);\n        }", "signature": "@Override\n        public void set(final E value)"}]}, {"original_string": "    protected static class LinkedSubList<E> extends AbstractList<E> {\n\n        /** The main list */\n        AbstractLinkedList<E> parent;\n\n        /** Offset from the main list */\n        int offset;\n\n        /** Sublist size */\n        int size;\n\n        /** Sublist modCount */\n        int expectedModCount;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractLinkedList.\n         * @param fromIndex An index greater or equal to 0 and less than {@code toIndex}.\n         * @param toIndex An index greater than {@code fromIndex}.\n         */\n        protected LinkedSubList(final AbstractLinkedList<E> parent, final int fromIndex, final int toIndex) {\n            if (fromIndex < 0) {\n                throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n            }\n            if (toIndex > parent.size()) {\n                throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex);\n            }\n            if (fromIndex > toIndex) {\n                throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n            }\n            this.parent = parent;\n            this.offset = fromIndex;\n            this.size = toIndex - fromIndex;\n            this.expectedModCount = parent.modCount;\n        }\n\n        @Override\n        public void add(final int index, final E obj) {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            parent.add(index + offset, obj);\n            expectedModCount = parent.modCount;\n            size++;\n            modCount++;\n        }\n\n        @Override\n        public boolean addAll(final Collection<? extends E> coll) {\n            return addAll(size, coll);\n        }\n\n        @Override\n        public boolean addAll(final int index, final Collection<? extends E> coll) {\n            rangeCheck(index, size + 1);\n            final int cSize = coll.size();\n            if (cSize == 0) {\n                return false;\n            }\n\n            checkModCount();\n            parent.addAll(offset + index, coll);\n            expectedModCount = parent.modCount;\n            size += cSize;\n            modCount++;\n            return true;\n        }\n\n        /**\n         * Throws a {@link ConcurrentModificationException} if this instance fails its concurrency check.\n         */\n        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        @Override\n        public void clear() {\n            checkModCount();\n            final Iterator<E> it = iterator();\n            while (it.hasNext()) {\n                it.next();\n                it.remove();\n            }\n        }\n\n        @Override\n        public E get(final int index) {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.get(index + offset);\n        }\n\n        @Override\n        public Iterator<E> iterator() {\n            checkModCount();\n            return parent.createSubListIterator(this);\n        }\n\n        @Override\n        public ListIterator<E> listIterator(final int index) {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            return parent.createSubListListIterator(this, index);\n        }\n\n        /**\n         * Throws an {@link IndexOutOfBoundsException} if the given indices are out of bounds.\n         *\n         * @param index lower index.\n         * @param beyond upper index.\n         */\n        protected void rangeCheck(final int index, final int beyond) {\n            if (index < 0 || index >= beyond) {\n                throw new IndexOutOfBoundsException(\"Index '\" + index + \"' out of bounds for size '\" + size + \"'\");\n            }\n        }\n\n        @Override\n        public E remove(final int index) {\n            rangeCheck(index, size);\n            checkModCount();\n            final E result = parent.remove(index + offset);\n            expectedModCount = parent.modCount;\n            size--;\n            modCount++;\n            return result;\n        }\n\n        @Override\n        public E set(final int index, final E obj) {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.set(index + offset, obj);\n        }\n\n        @Override\n        public int size() {\n            checkModCount();\n            return size;\n        }\n\n        @Override\n        public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n            return new LinkedSubList<>(parent, fromIndexInclusive + offset, toIndexExclusive + offset);\n        }\n    }", "definition": "    protected static class LinkedSubList<E> extends AbstractList<E>", "class_docstring": "\nThe sublist implementation for AbstractLinkedList.\n\n@param <E> the type of elements in this list.\n", "name": "LinkedSubList", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "AbstractLinkedList<E> parent;", "docstring": " The main list", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "AbstractLinkedList<E>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "int offset;", "docstring": " Offset from the main list", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "offset", "syntax_pass": true}, {"attribute_expression": "int size;", "docstring": " Sublist size", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "size", "syntax_pass": true}, {"attribute_expression": "int expectedModCount;", "docstring": " Sublist modCount", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "expectedModCount", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected LinkedSubList(final AbstractLinkedList<E> parent, final int fromIndex, final int toIndex) {\n            if (fromIndex < 0) {\n                throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n            }\n            if (toIndex > parent.size()) {\n                throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex);\n            }\n            if (fromIndex > toIndex) {\n                throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n            }\n            this.parent = parent;\n            this.offset = fromIndex;\n            this.size = toIndex - fromIndex;\n            this.expectedModCount = parent.modCount;\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent The parent AbstractLinkedList.\n@param fromIndex An index greater or equal to 0 and less than {@code toIndex}.\n@param toIndex An index greater than {@code fromIndex}.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "LinkedSubList", "params": [{"name": "parent", "type": "AbstractLinkedList<E>"}, {"name": "fromIndex", "type": "int"}, {"name": "toIndex", "type": "int"}], "body": "                                                                                                            {\n            if (fromIndex < 0) {\n                throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n            }\n            if (toIndex > parent.size()) {\n                throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex);\n            }\n            if (fromIndex > toIndex) {\n                throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n            }\n            this.parent = parent;\n            this.offset = fromIndex;\n            this.size = toIndex - fromIndex;\n            this.expectedModCount = parent.modCount;\n        }", "signature": "protected LinkedSubList(final AbstractLinkedList<E> parent, final int fromIndex, final int toIndex)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void add(final int index, final E obj) {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            parent.add(index + offset, obj);\n            expectedModCount = parent.modCount;\n            size++;\n            modCount++;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "index", "type": "int"}, {"name": "obj", "type": "E"}], "body": "                                                      {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            parent.add(index + offset, obj);\n            expectedModCount = parent.modCount;\n            size++;\n            modCount++;\n        }", "signature": "@Override\n        public void add(final int index, final E obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean addAll(final Collection<? extends E> coll) {\n            return addAll(size, coll);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "addAll", "params": [{"name": "coll", "type": "Collection<? extends E>"}], "body": "                                                                  {\n            return addAll(size, coll);\n        }", "signature": "@Override\n        public boolean addAll(final Collection<? extends E> coll)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean addAll(final int index, final Collection<? extends E> coll) {\n            rangeCheck(index, size + 1);\n            final int cSize = coll.size();\n            if (cSize == 0) {\n                return false;\n            }\n\n            checkModCount();\n            parent.addAll(offset + index, coll);\n            expectedModCount = parent.modCount;\n            size += cSize;\n            modCount++;\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "addAll", "params": [{"name": "index", "type": "int"}, {"name": "coll", "type": "Collection<? extends E>"}], "body": "                                                                                   {\n            rangeCheck(index, size + 1);\n            final int cSize = coll.size();\n            if (cSize == 0) {\n                return false;\n            }\n\n            checkModCount();\n            parent.addAll(offset + index, coll);\n            expectedModCount = parent.modCount;\n            size += cSize;\n            modCount++;\n            return true;\n        }", "signature": "@Override\n        public boolean addAll(final int index, final Collection<? extends E> coll)"}, {"syntax_pass": true, "original_string": "        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }", "docstring": "\nThrows a {@link ConcurrentModificationException} if this instance fails its concurrency check.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "checkModCount", "params": [], "body": "                                       {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }", "signature": "protected void checkModCount()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            checkModCount();\n            final Iterator<E> it = iterator();\n            while (it.hasNext()) {\n                it.next();\n                it.remove();\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            checkModCount();\n            final Iterator<E> it = iterator();\n            while (it.hasNext()) {\n                it.next();\n                it.remove();\n            }\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E get(final int index) {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.get(index + offset);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                      {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.get(index + offset);\n        }", "signature": "@Override\n        public E get(final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<E> iterator() {\n            checkModCount();\n            return parent.createSubListIterator(this);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<E>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            checkModCount();\n            return parent.createSubListIterator(this);\n        }", "signature": "@Override\n        public Iterator<E> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public ListIterator<E> listIterator(final int index) {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            return parent.createSubListListIterator(this, index);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListIterator<E>", "classes": []}, "name": "listIterator", "params": [{"name": "index", "type": "int"}], "body": "                                                             {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            return parent.createSubListListIterator(this, index);\n        }", "signature": "@Override\n        public ListIterator<E> listIterator(final int index)"}, {"syntax_pass": true, "original_string": "        protected void rangeCheck(final int index, final int beyond) {\n            if (index < 0 || index >= beyond) {\n                throw new IndexOutOfBoundsException(\"Index '\" + index + \"' out of bounds for size '\" + size + \"'\");\n            }\n        }", "docstring": "\nThrows an {@link IndexOutOfBoundsException} if the given indices are out of bounds.\n\n@param index lower index.\n@param beyond upper index.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "rangeCheck", "params": [{"name": "index", "type": "int"}, {"name": "beyond", "type": "int"}], "body": "                                                                     {\n            if (index < 0 || index >= beyond) {\n                throw new IndexOutOfBoundsException(\"Index '\" + index + \"' out of bounds for size '\" + size + \"'\");\n            }\n        }", "signature": "protected void rangeCheck(final int index, final int beyond)"}, {"syntax_pass": true, "original_string": "        @Override\n        public E remove(final int index) {\n            rangeCheck(index, size);\n            checkModCount();\n            final E result = parent.remove(index + offset);\n            expectedModCount = parent.modCount;\n            size--;\n            modCount++;\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "remove", "params": [{"name": "index", "type": "int"}], "body": "                                         {\n            rangeCheck(index, size);\n            checkModCount();\n            final E result = parent.remove(index + offset);\n            expectedModCount = parent.modCount;\n            size--;\n            modCount++;\n            return result;\n        }", "signature": "@Override\n        public E remove(final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public E set(final int index, final E obj) {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.set(index + offset, obj);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "set", "params": [{"name": "index", "type": "int"}, {"name": "obj", "type": "E"}], "body": "                                                   {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.set(index + offset, obj);\n        }", "signature": "@Override\n        public E set(final int index, final E obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            checkModCount();\n            return size;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            checkModCount();\n            return size;\n        }", "signature": "@Override\n        public int size()"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n            return new LinkedSubList<>(parent, fromIndexInclusive + offset, toIndexExclusive + offset);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<E>", "classes": []}, "name": "subList", "params": [{"name": "fromIndexInclusive", "type": "int"}, {"name": "toIndexExclusive", "type": "int"}], "body": "                                                                                         {\n            return new LinkedSubList<>(parent, fromIndexInclusive + offset, toIndexExclusive + offset);\n        }", "signature": "@Override\n        public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive)"}]}, {"original_string": "    protected static class LinkedSubListIterator<E> extends LinkedListIterator<E> {\n\n        /** The sub list. */\n        protected final LinkedSubList<E> sub;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param sub The sub-list.\n         * @param startIndex The starting index.\n         */\n        protected LinkedSubListIterator(final LinkedSubList<E> sub, final int startIndex) {\n            super(sub.parent, startIndex + sub.offset);\n            this.sub = sub;\n        }\n\n        @Override\n        public void add(final E obj) {\n            super.add(obj);\n            sub.expectedModCount = parent.modCount;\n            sub.size++;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return nextIndex() < sub.size;\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return previousIndex() >= 0;\n        }\n\n        @Override\n        public int nextIndex() {\n            return super.nextIndex() - sub.offset;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            sub.expectedModCount = parent.modCount;\n            sub.size--;\n        }\n    }", "definition": "    protected static class LinkedSubListIterator<E> extends LinkedListIterator<E>", "class_docstring": "\nA list iterator over the linked sub list.\n\n@param <E> the type of elements in this iterator.\n", "name": "LinkedSubListIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected final LinkedSubList<E> sub;", "docstring": " The sub list.", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "LinkedSubList<E>", "name": "sub", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected LinkedSubListIterator(final LinkedSubList<E> sub, final int startIndex) {\n            super(sub.parent, startIndex + sub.offset);\n            this.sub = sub;\n        }", "docstring": "\nConstructs a new instance.\n\n@param sub The sub-list.\n@param startIndex The starting index.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "LinkedSubListIterator", "params": [{"name": "sub", "type": "LinkedSubList<E>"}, {"name": "startIndex", "type": "int"}], "body": "                                                                                          {\n            super(sub.parent, startIndex + sub.offset);\n            this.sub = sub;\n        }", "signature": "protected LinkedSubListIterator(final LinkedSubList<E> sub, final int startIndex)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void add(final E obj) {\n            super.add(obj);\n            sub.expectedModCount = parent.modCount;\n            sub.size++;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "obj", "type": "E"}], "body": "                                     {\n            super.add(obj);\n            sub.expectedModCount = parent.modCount;\n            sub.size++;\n        }", "signature": "@Override\n        public void add(final E obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return nextIndex() < sub.size;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return nextIndex() < sub.size;\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasPrevious() {\n            return previousIndex() >= 0;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasPrevious", "params": [], "body": "                                     {\n            return previousIndex() >= 0;\n        }", "signature": "@Override\n        public boolean hasPrevious()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int nextIndex() {\n            return super.nextIndex() - sub.offset;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "nextIndex", "params": [], "body": "                               {\n            return super.nextIndex() - sub.offset;\n        }", "signature": "@Override\n        public int nextIndex()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            super.remove();\n            sub.expectedModCount = parent.modCount;\n            sub.size--;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            super.remove();\n            sub.expectedModCount = parent.modCount;\n            sub.size--;\n        }", "signature": "@Override\n        public void remove()"}]}, {"original_string": "    protected static class Node<E> {\n\n        /** A pointer to the node before this node */\n        protected Node<E> previous;\n        /** A pointer to the node after this node */\n        protected Node<E> next;\n        /** The object contained within this node */\n        protected E value;\n\n        /**\n         * Constructs a new header node.\n         */\n        protected Node() {\n            previous = this;\n            next = this;\n        }\n\n        /**\n         * Constructs a new node.\n         *\n         * @param value  the value to store\n         */\n        protected Node(final E value) {\n            this.value = value;\n        }\n\n        /**\n         * Constructs a new node.\n         *\n         * @param previous  the previous node in the list\n         * @param next  the next node in the list\n         * @param value  the value to store\n         */\n        protected Node(final Node<E> previous, final Node<E> next, final E value) {\n            this.previous = previous;\n            this.next = next;\n            this.value = value;\n        }\n\n        /**\n         * Gets the next node.\n         *\n         * @return the next node\n         * @since 3.1\n         */\n        protected Node<E> getNextNode() {\n            return next;\n        }\n\n        /**\n         * Gets the previous node.\n         *\n         * @return the previous node\n         * @since 3.1\n         */\n        protected Node<E> getPreviousNode() {\n            return previous;\n        }\n\n        /**\n         * Gets the value of the node.\n         *\n         * @return the value\n         * @since 3.1\n         */\n        protected E getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the next node.\n         *\n         * @param next  the next node\n         * @since 3.1\n         */\n        protected void setNextNode(final Node<E> next) {\n            this.next = next;\n        }\n\n        /**\n         * Sets the previous node.\n         *\n         * @param previous  the previous node\n         * @since 3.1\n         */\n        protected void setPreviousNode(final Node<E> previous) {\n            this.previous = previous;\n        }\n\n        /**\n         * Sets the value of the node.\n         *\n         * @param value  the value\n         * @since 3.1\n         */\n        protected void setValue(final E value) {\n            this.value = value;\n        }\n    }", "definition": "    protected static class Node<E>", "class_docstring": "\nA node within the linked list.\n<p>\nFrom Commons Collections 3.1, all access to the {@code value} property\nis via the methods on this class.\n</p>\n\n@param <E> The node value type.\n", "name": "Node", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected Node<E> previous;", "docstring": " A pointer to the node before this node", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Node<E>", "name": "previous", "syntax_pass": true}, {"attribute_expression": "protected Node<E> next;", "docstring": " A pointer to the node after this node", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Node<E>", "name": "next", "syntax_pass": true}, {"attribute_expression": "protected E value;", "docstring": " The object contained within this node", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "E", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected Node() {\n            previous = this;\n            next = this;\n        }", "docstring": "\nConstructs a new header node.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "Node", "params": [], "body": "                         {\n            previous = this;\n            next = this;\n        }", "signature": "protected Node()"}, {"syntax_pass": true, "original_string": "        protected Node(final E value) {\n            this.value = value;\n        }", "docstring": "\nConstructs a new node.\n\n@param value  the value to store\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "Node", "params": [{"name": "value", "type": "E"}], "body": "                                      {\n            this.value = value;\n        }", "signature": "protected Node(final E value)"}, {"syntax_pass": true, "original_string": "        protected Node(final Node<E> previous, final Node<E> next, final E value) {\n            this.previous = previous;\n            this.next = next;\n            this.value = value;\n        }", "docstring": "\nConstructs a new node.\n\n@param previous  the previous node in the list\n@param next  the next node in the list\n@param value  the value to store\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "Node", "params": [{"name": "previous", "type": "Node<E>"}, {"name": "next", "type": "Node<E>"}, {"name": "value", "type": "E"}], "body": "                                                                                  {\n            this.previous = previous;\n            this.next = next;\n            this.value = value;\n        }", "signature": "protected Node(final Node<E> previous, final Node<E> next, final E value)"}, {"syntax_pass": true, "original_string": "        protected Node<E> getNextNode() {\n            return next;\n        }", "docstring": "\nGets the next node.\n\n@return the next node\n@since 3.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Node<E>", "classes": []}, "name": "getNextNode", "params": [], "body": "                                        {\n            return next;\n        }", "signature": "protected Node<E> getNextNode()"}, {"syntax_pass": true, "original_string": "        protected Node<E> getPreviousNode() {\n            return previous;\n        }", "docstring": "\nGets the previous node.\n\n@return the previous node\n@since 3.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Node<E>", "classes": []}, "name": "getPreviousNode", "params": [], "body": "                                            {\n            return previous;\n        }", "signature": "protected Node<E> getPreviousNode()"}, {"syntax_pass": true, "original_string": "        protected E getValue() {\n            return value;\n        }", "docstring": "\nGets the value of the node.\n\n@return the value\n@since 3.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "E", "classes": []}, "name": "getValue", "params": [], "body": "                               {\n            return value;\n        }", "signature": "protected E getValue()"}, {"syntax_pass": true, "original_string": "        protected void setNextNode(final Node<E> next) {\n            this.next = next;\n        }", "docstring": "\nSets the next node.\n\n@param next  the next node\n@since 3.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "setNextNode", "params": [{"name": "next", "type": "Node<E>"}], "body": "                                                       {\n            this.next = next;\n        }", "signature": "protected void setNextNode(final Node<E> next)"}, {"syntax_pass": true, "original_string": "        protected void setPreviousNode(final Node<E> previous) {\n            this.previous = previous;\n        }", "docstring": "\nSets the previous node.\n\n@param previous  the previous node\n@since 3.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "setPreviousNode", "params": [{"name": "previous", "type": "Node<E>"}], "body": "                                                               {\n            this.previous = previous;\n        }", "signature": "protected void setPreviousNode(final Node<E> previous)"}, {"syntax_pass": true, "original_string": "        protected void setValue(final E value) {\n            this.value = value;\n        }", "docstring": "\nSets the value of the node.\n\n@param value  the value\n@since 3.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "E"}], "body": "                                               {\n            this.value = value;\n        }", "signature": "protected void setValue(final E value)"}]}], "class_docstring": "\nAn abstract implementation of a linked list which provides numerous points for\nsubclasses to override.\n<p>\nOverridable methods are provided to change the storage node and to change how\nnodes are added to and removed. Hopefully, all you need for unusual subclasses\nis here.\n</p>\n\n@param <E> the type of elements in this list\n@since 3.0\n@deprecated use {@link AbstractLinkedListForJava21} instead\n", "original_string": "@Deprecated\npublic abstract class AbstractLinkedList<E> implements List<E> {\n\n    /*\n     * Implementation notes:\n     * - a standard circular doubly-linked list\n     * - a marker node is stored to mark the start and the end of the list\n     * - node creation and removal always occurs through createNode() and\n     *   removeNode().\n     * - a modification count is kept, with the same semantics as\n     * {@link java.util.LinkedList}.\n     * - respects {@link AbstractList#modCount}\n     */\n\n    /**\n     * A list iterator over the linked list.\n     *\n     * @param <E> the type of elements in this iterator.\n     */\n    protected static class LinkedListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n\n        /** The parent list */\n        protected final AbstractLinkedList<E> parent;\n\n        /**\n         * The node that will be returned by {@link #next()}. If this is equal\n         * to {@link AbstractLinkedList#header} then there are no more values to return.\n         */\n        protected Node<E> next;\n\n        /**\n         * The index of {@link #next}.\n         */\n        protected int nextIndex;\n\n        /**\n         * The last node that was returned by {@link #next()} or {@link\n         * #previous()}. Set to {@code null} if {@link #next()} or {@link\n         * #previous()} haven't been called, or if the node has been removed\n         * with {@link #remove()} or a new node added with {@link #add(Object)}.\n         * Should be accessed through {@link #getLastNodeReturned()} to enforce\n         * this behavior.\n         */\n        protected Node<E> current;\n\n        /**\n         * The modification count that the list is expected to have. If the list\n         * doesn't have this count, then a\n         * {@link java.util.ConcurrentModificationException} may be thrown by\n         * the operations.\n         */\n        protected int expectedModCount;\n\n        /**\n         * Create a ListIterator for a list.\n         *\n         * @param parent  the parent list.\n         * @param fromIndex  The starting index.\n         * @throws IndexOutOfBoundsException if fromIndex is less than 0 or greater than the size of the list.\n         */\n        protected LinkedListIterator(final AbstractLinkedList<E> parent, final int fromIndex)\n                throws IndexOutOfBoundsException {\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.getNode(fromIndex, true);\n            this.nextIndex = fromIndex;\n        }\n\n        @Override\n        public void add(final E obj) {\n            checkModCount();\n            parent.addNodeBefore(next, obj);\n            current = null;\n            nextIndex++;\n            expectedModCount++;\n        }\n\n        /**\n         * Checks the modification count of the list is the value that this\n         * object expects.\n         *\n         * @throws ConcurrentModificationException If the list's modification\n         * count isn't the value that was expected.\n         */\n        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        /**\n         * Gets the last node returned.\n         *\n         * @return the last node returned\n         * @throws IllegalStateException If {@link #next()} or {@link #previous()} haven't been called,\n         * or if the node has been removed with {@link #remove()} or a new node added with {@link #add(Object)}.\n         */\n        protected Node<E> getLastNodeReturned() throws IllegalStateException {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return next != parent.header;\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return next.previous != parent.header;\n        }\n\n        @Override\n        public E next() {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            final E value = next.getValue();\n            current = next;\n            next = next.next;\n            nextIndex++;\n            return value;\n        }\n\n        @Override\n        public int nextIndex() {\n            return nextIndex;\n        }\n\n        @Override\n        public E previous() {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            next = next.previous;\n            final E value = next.getValue();\n            current = next;\n            nextIndex--;\n            return value;\n        }\n\n        @Override\n        public int previousIndex() {\n            // not normally overridden, as relative to nextIndex()\n            return nextIndex() - 1;\n        }\n\n        @Override\n        public void remove() {\n            checkModCount();\n            if (current == next) {\n                // remove() following previous()\n                next = next.next;\n                parent.removeNode(getLastNodeReturned());\n            } else {\n                // remove() following next()\n                parent.removeNode(getLastNodeReturned());\n                nextIndex--;\n            }\n            current = null;\n            expectedModCount++;\n        }\n\n        @Override\n        public void set(final E value) {\n            checkModCount();\n            getLastNodeReturned().setValue(value);\n        }\n\n    }\n\n    /**\n     * The sublist implementation for AbstractLinkedList.\n     *\n     * @param <E> the type of elements in this list.\n     */\n    protected static class LinkedSubList<E> extends AbstractList<E> {\n\n        /** The main list */\n        AbstractLinkedList<E> parent;\n\n        /** Offset from the main list */\n        int offset;\n\n        /** Sublist size */\n        int size;\n\n        /** Sublist modCount */\n        int expectedModCount;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent The parent AbstractLinkedList.\n         * @param fromIndex An index greater or equal to 0 and less than {@code toIndex}.\n         * @param toIndex An index greater than {@code fromIndex}.\n         */\n        protected LinkedSubList(final AbstractLinkedList<E> parent, final int fromIndex, final int toIndex) {\n            if (fromIndex < 0) {\n                throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n            }\n            if (toIndex > parent.size()) {\n                throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex);\n            }\n            if (fromIndex > toIndex) {\n                throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n            }\n            this.parent = parent;\n            this.offset = fromIndex;\n            this.size = toIndex - fromIndex;\n            this.expectedModCount = parent.modCount;\n        }\n\n        @Override\n        public void add(final int index, final E obj) {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            parent.add(index + offset, obj);\n            expectedModCount = parent.modCount;\n            size++;\n            modCount++;\n        }\n\n        @Override\n        public boolean addAll(final Collection<? extends E> coll) {\n            return addAll(size, coll);\n        }\n\n        @Override\n        public boolean addAll(final int index, final Collection<? extends E> coll) {\n            rangeCheck(index, size + 1);\n            final int cSize = coll.size();\n            if (cSize == 0) {\n                return false;\n            }\n\n            checkModCount();\n            parent.addAll(offset + index, coll);\n            expectedModCount = parent.modCount;\n            size += cSize;\n            modCount++;\n            return true;\n        }\n\n        /**\n         * Throws a {@link ConcurrentModificationException} if this instance fails its concurrency check.\n         */\n        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        @Override\n        public void clear() {\n            checkModCount();\n            final Iterator<E> it = iterator();\n            while (it.hasNext()) {\n                it.next();\n                it.remove();\n            }\n        }\n\n        @Override\n        public E get(final int index) {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.get(index + offset);\n        }\n\n        @Override\n        public Iterator<E> iterator() {\n            checkModCount();\n            return parent.createSubListIterator(this);\n        }\n\n        @Override\n        public ListIterator<E> listIterator(final int index) {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            return parent.createSubListListIterator(this, index);\n        }\n\n        /**\n         * Throws an {@link IndexOutOfBoundsException} if the given indices are out of bounds.\n         *\n         * @param index lower index.\n         * @param beyond upper index.\n         */\n        protected void rangeCheck(final int index, final int beyond) {\n            if (index < 0 || index >= beyond) {\n                throw new IndexOutOfBoundsException(\"Index '\" + index + \"' out of bounds for size '\" + size + \"'\");\n            }\n        }\n\n        @Override\n        public E remove(final int index) {\n            rangeCheck(index, size);\n            checkModCount();\n            final E result = parent.remove(index + offset);\n            expectedModCount = parent.modCount;\n            size--;\n            modCount++;\n            return result;\n        }\n\n        @Override\n        public E set(final int index, final E obj) {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.set(index + offset, obj);\n        }\n\n        @Override\n        public int size() {\n            checkModCount();\n            return size;\n        }\n\n        @Override\n        public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n            return new LinkedSubList<>(parent, fromIndexInclusive + offset, toIndexExclusive + offset);\n        }\n    }\n\n    /**\n     * A list iterator over the linked sub list.\n     *\n     * @param <E> the type of elements in this iterator.\n     */\n    protected static class LinkedSubListIterator<E> extends LinkedListIterator<E> {\n\n        /** The sub list. */\n        protected final LinkedSubList<E> sub;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param sub The sub-list.\n         * @param startIndex The starting index.\n         */\n        protected LinkedSubListIterator(final LinkedSubList<E> sub, final int startIndex) {\n            super(sub.parent, startIndex + sub.offset);\n            this.sub = sub;\n        }\n\n        @Override\n        public void add(final E obj) {\n            super.add(obj);\n            sub.expectedModCount = parent.modCount;\n            sub.size++;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return nextIndex() < sub.size;\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return previousIndex() >= 0;\n        }\n\n        @Override\n        public int nextIndex() {\n            return super.nextIndex() - sub.offset;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            sub.expectedModCount = parent.modCount;\n            sub.size--;\n        }\n    }\n\n    /**\n     * A node within the linked list.\n     * <p>\n     * From Commons Collections 3.1, all access to the {@code value} property\n     * is via the methods on this class.\n     * </p>\n     *\n     * @param <E> The node value type.\n     */\n    protected static class Node<E> {\n\n        /** A pointer to the node before this node */\n        protected Node<E> previous;\n        /** A pointer to the node after this node */\n        protected Node<E> next;\n        /** The object contained within this node */\n        protected E value;\n\n        /**\n         * Constructs a new header node.\n         */\n        protected Node() {\n            previous = this;\n            next = this;\n        }\n\n        /**\n         * Constructs a new node.\n         *\n         * @param value  the value to store\n         */\n        protected Node(final E value) {\n            this.value = value;\n        }\n\n        /**\n         * Constructs a new node.\n         *\n         * @param previous  the previous node in the list\n         * @param next  the next node in the list\n         * @param value  the value to store\n         */\n        protected Node(final Node<E> previous, final Node<E> next, final E value) {\n            this.previous = previous;\n            this.next = next;\n            this.value = value;\n        }\n\n        /**\n         * Gets the next node.\n         *\n         * @return the next node\n         * @since 3.1\n         */\n        protected Node<E> getNextNode() {\n            return next;\n        }\n\n        /**\n         * Gets the previous node.\n         *\n         * @return the previous node\n         * @since 3.1\n         */\n        protected Node<E> getPreviousNode() {\n            return previous;\n        }\n\n        /**\n         * Gets the value of the node.\n         *\n         * @return the value\n         * @since 3.1\n         */\n        protected E getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the next node.\n         *\n         * @param next  the next node\n         * @since 3.1\n         */\n        protected void setNextNode(final Node<E> next) {\n            this.next = next;\n        }\n\n        /**\n         * Sets the previous node.\n         *\n         * @param previous  the previous node\n         * @since 3.1\n         */\n        protected void setPreviousNode(final Node<E> previous) {\n            this.previous = previous;\n        }\n\n        /**\n         * Sets the value of the node.\n         *\n         * @param value  the value\n         * @since 3.1\n         */\n        protected void setValue(final E value) {\n            this.value = value;\n        }\n    }\n\n    /**\n     * A {@link Node} which indicates the start and end of the list and does not\n     * hold a value. The value of {@code next} is the first item in the\n     * list. The value of {@code previous} is the last item in the list.\n     */\n    transient Node<E> header;\n\n    /** The size of the list */\n    transient int size;\n\n    /** Modification count for iterators */\n    transient int modCount;\n\n    /**\n     * Constructor that does nothing (intended for deserialization).\n     * <p>\n     * If this constructor is used by a serializable subclass then the init()\n     * method must be called.\n     */\n    protected AbstractLinkedList() {\n    }\n\n    /**\n     * Constructs a list copying data from the specified collection.\n     *\n     * @param coll  the collection to copy\n     */\n    protected AbstractLinkedList(final Collection<? extends E> coll) {\n        init();\n        addAll(coll);\n    }\n\n    @Override\n    public boolean add(final E value) {\n        addLast(value);\n        return true;\n    }\n\n    @Override\n    public void add(final int index, final E value) {\n        final Node<E> node = getNode(index, true);\n        addNodeBefore(node, value);\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        return addAll(size, coll);\n    }\n\n    @Override\n    public boolean addAll(final int index, final Collection<? extends E> coll) {\n        final Node<E> node = getNode(index, true);\n        for (final E e : coll) {\n            addNodeBefore(node, e);\n        }\n        return true;\n    }\n\n    /**\n     * Adds an element at the beginning.\n     *\n     * @param e the element to beginning.\n     * @return true.\n     */\n    public boolean addFirst(final E e) {\n        addNodeAfter(header, e);\n        return true;\n    }\n\n    /**\n     * Adds an element at the end.\n     *\n     * @param e the element to add.\n     * @return true.\n     */\n    public boolean addLast(final E e) {\n        addNodeBefore(header, e);\n        return true;\n    }\n\n    /**\n     * Inserts a new node into the list.\n     *\n     * @param nodeToInsert  new node to insert\n     * @param insertBeforeNode  node to insert before\n     * @throws NullPointerException if either node is null\n     */\n    protected void addNode(final Node<E> nodeToInsert, final Node<E> insertBeforeNode) {\n        Objects.requireNonNull(nodeToInsert, \"nodeToInsert\");\n        Objects.requireNonNull(insertBeforeNode, \"insertBeforeNode\");\n        nodeToInsert.next = insertBeforeNode;\n        nodeToInsert.previous = insertBeforeNode.previous;\n        insertBeforeNode.previous.next = nodeToInsert;\n        insertBeforeNode.previous = nodeToInsert;\n        size++;\n        modCount++;\n    }\n\n    /**\n     * Creates a new node with the specified object as its\n     * {@code value} and inserts it after {@code node}.\n     * <p>\n     * This implementation uses {@link #createNode(Object)} and\n     * {@link #addNode(AbstractLinkedList.Node,AbstractLinkedList.Node)}.\n     *\n     * @param node  node to insert after\n     * @param value  value of the newly added node\n     * @throws NullPointerException if {@code node} is null\n     */\n    protected void addNodeAfter(final Node<E> node, final E value) {\n        final Node<E> newNode = createNode(value);\n        addNode(newNode, node.next);\n    }\n\n    /**\n     * Creates a new node with the specified object as its\n     * {@code value} and inserts it before {@code node}.\n     * <p>\n     * This implementation uses {@link #createNode(Object)} and\n     * {@link #addNode(AbstractLinkedList.Node,AbstractLinkedList.Node)}.\n     *\n     * @param node  node to insert before\n     * @param value  value of the newly added node\n     * @throws NullPointerException if {@code node} is null\n     */\n    protected void addNodeBefore(final Node<E> node, final E value) {\n        final Node<E> newNode = createNode(value);\n        addNode(newNode, node);\n    }\n\n    @Override\n    public void clear() {\n        removeAllNodes();\n    }\n\n    @Override\n    public boolean contains(final Object value) {\n        return indexOf(value) != -1;\n    }\n\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        for (final Object o : coll) {\n            if (!contains(o)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Creates a new node with previous, next and element all set to null.\n     * This implementation creates a new empty Node.\n     * Subclasses can override this to create a different class.\n     *\n     * @return  newly created node\n     */\n    protected Node<E> createHeaderNode() {\n        return new Node<>();\n    }\n\n    /**\n     * Creates a new node with the specified properties.\n     * This implementation creates a new Node with data.\n     * Subclasses can override this to create a different class.\n     *\n     * @param value  value of the new node\n     * @return a new node containing the value\n     */\n    protected Node<E> createNode(final E value) {\n        return new Node<>(value);\n    }\n\n    /**\n     * Creates an iterator for the sublist.\n     *\n     * @param subList  the sublist to get an iterator for\n     * @return a new iterator on the given sublist\n     */\n    protected Iterator<E> createSubListIterator(final LinkedSubList<E> subList) {\n        return createSubListListIterator(subList, 0);\n    }\n\n    /**\n     * Creates a list iterator for the sublist.\n     *\n     * @param subList  the sublist to get an iterator for\n     * @param fromIndex  the index to start from, relative to the sublist\n     * @return a new list iterator on the given sublist\n     */\n    protected ListIterator<E> createSubListListIterator(final LinkedSubList<E> subList, final int fromIndex) {\n        return new LinkedSubListIterator<>(subList, fromIndex);\n    }\n\n    /**\n     * Deserializes the data held in this object to the stream specified.\n     * <p>\n     * The first serializable subclass must call this method from\n     * {@code readObject}.\n     *\n     * @param inputStream  the stream to read the object from\n     * @throws IOException  if any error occurs while reading from the stream\n     * @throws ClassNotFoundException  if a class read from the stream can not be loaded\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected void doReadObject(final ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\n        init();\n        final int size = inputStream.readInt();\n        for (int i = 0; i < size; i++) {\n            add((E) inputStream.readObject());\n        }\n    }\n\n    /**\n     * Serializes the data held in this object to the stream specified.\n     * <p>\n     * The first serializable subclass must call this method from\n     * {@code writeObject}.\n     *\n     * @param outputStream  the stream to write the object to\n     * @throws IOException  if anything goes wrong\n     */\n    protected void doWriteObject(final ObjectOutputStream outputStream) throws IOException {\n        // Write the size so we know how many nodes to read back\n        outputStream.writeInt(size());\n        for (final E e : this) {\n            outputStream.writeObject(e);\n        }\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof List)) {\n            return false;\n        }\n        final List<?> other = (List<?>) obj;\n        if (other.size() != size()) {\n            return false;\n        }\n        final ListIterator<?> it1 = listIterator();\n        final ListIterator<?> it2 = other.listIterator();\n        while (it1.hasNext() && it2.hasNext()) {\n            if (!Objects.equals(it1.next(), it2.next())) {\n                return false;\n            }\n        }\n        return !(it1.hasNext() || it2.hasNext());\n    }\n\n    @Override\n    public E get(final int index) {\n        final Node<E> node = getNode(index, false);\n        return node.getValue();\n    }\n\n    /**\n     * Gets the first element.\n     *\n     * @return the first element.\n     */\n    public E getFirst() {\n        final Node<E> node = header.next;\n        if (node == header) {\n            throw new NoSuchElementException();\n        }\n        return node.getValue();\n    }\n\n    /**\n     * Gets the last element.\n     *\n     * @return the last element.\n     */\n    public E getLast() {\n        final Node<E> node = header.previous;\n        if (node == header) {\n            throw new NoSuchElementException();\n        }\n        return node.getValue();\n    }\n\n    /**\n     * Gets the node at a particular index.\n     *\n     * @param index  the index, starting from 0\n     * @param endMarkerAllowed  whether or not the end marker can be returned if\n     * startIndex is set to the list's size\n     * @return the node at the given index\n     * @throws IndexOutOfBoundsException if the index is less than 0; equal to\n     * the size of the list and endMakerAllowed is false; or greater than the\n     * size of the list\n     */\n    protected Node<E> getNode(final int index, final boolean endMarkerAllowed) throws IndexOutOfBoundsException {\n        // Check the index is within the bounds\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n                    \"index (\" + index + \") less than zero.\");\n        }\n        if (!endMarkerAllowed && index == size) {\n            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n                    \"index (\" + index + \") is the size of the list.\");\n        }\n        if (index > size) {\n            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n                    \"index (\" + index + \") greater than the size of the \" +\n                    \"list (\" + size + \").\");\n        }\n        // Search the list and get the node\n        Node<E> node;\n        if (index < size / 2) {\n            // Search forwards\n            node = header.next;\n            for (int currentIndex = 0; currentIndex < index; currentIndex++) {\n                node = node.next;\n            }\n        } else {\n            // Search backwards\n            node = header;\n            for (int currentIndex = size; currentIndex > index; currentIndex--) {\n                node = node.previous;\n            }\n        }\n        return node;\n    }\n\n    @Override\n    public int hashCode() {\n        int hashCode = 1;\n        for (final E e : this) {\n            hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());\n        }\n        return hashCode;\n    }\n\n    @Override\n    public int indexOf(final Object value) {\n        int i = 0;\n        for (Node<E> node = header.next; node != header; node = node.next) {\n            if (isEqualValue(node.getValue(), value)) {\n                return i;\n            }\n            i++;\n        }\n        return CollectionUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * The equivalent of a default constructor, broken out so it can be called\n     * by any constructor and by {@code readObject}.\n     * Subclasses which override this method should make sure they call super,\n     * so the list is initialized properly.\n     */\n    protected void init() {\n        header = createHeaderNode();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    /**\n     * Compares two values for equals.\n     * This implementation uses the equals method.\n     * Subclasses can override this to match differently.\n     *\n     * @param value1  the first value to compare, may be null\n     * @param value2  the second value to compare, may be null\n     * @return true if equal\n     */\n    protected boolean isEqualValue(final Object value1, final Object value2) {\n        return Objects.equals(value1, value2);\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return listIterator();\n    }\n\n    @Override\n    public int lastIndexOf(final Object value) {\n        int i = size - 1;\n        for (Node<E> node = header.previous; node != header; node = node.previous) {\n            if (isEqualValue(node.getValue(), value)) {\n                return i;\n            }\n            i--;\n        }\n        return CollectionUtils.INDEX_NOT_FOUND;\n    }\n\n    @Override\n    public ListIterator<E> listIterator() {\n        return new LinkedListIterator<>(this, 0);\n    }\n\n    @Override\n    public ListIterator<E> listIterator(final int fromIndex) {\n        return new LinkedListIterator<>(this, fromIndex);\n    }\n\n    @Override\n    public E remove(final int index) {\n        final Node<E> node = getNode(index, false);\n        final E oldValue = node.getValue();\n        removeNode(node);\n        return oldValue;\n    }\n\n    @Override\n    public boolean remove(final Object value) {\n        for (Node<E> node = header.next; node != header; node = node.next) {\n            if (isEqualValue(node.getValue(), value)) {\n                removeNode(node);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * This implementation iterates over the elements of this list, checking each element in\n     * turn to see if it's contained in {@code coll}. If it's contained, it's removed\n     * from this list. As a consequence, it is advised to use a collection type for\n     * {@code coll} that provides a fast (e.g. O(1)) implementation of\n     * {@link Collection#contains(Object)}.\n     */\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        boolean modified = false;\n        final Iterator<E> it = iterator();\n        while (it.hasNext()) {\n            if (coll.contains(it.next())) {\n                it.remove();\n                modified = true;\n            }\n        }\n        return modified;\n    }\n\n    /**\n     * Removes all nodes by resetting the circular list marker.\n     */\n    protected void removeAllNodes() {\n        header.next = header;\n        header.previous = header;\n        size = 0;\n        modCount++;\n    }\n\n    /**\n     * Removes the first element.\n     *\n     * @return The value removed.\n     */\n    public E removeFirst() {\n        final Node<E> node = header.next;\n        if (node == header) {\n            throw new NoSuchElementException();\n        }\n        final E oldValue = node.getValue();\n        removeNode(node);\n        return oldValue;\n    }\n\n    /**\n     * Removes the last element.\n     *\n     * @return The value removed.\n     */\n    public E removeLast() {\n        final Node<E> node = header.previous;\n        if (node == header) {\n            throw new NoSuchElementException();\n        }\n        final E oldValue = node.getValue();\n        removeNode(node);\n        return oldValue;\n    }\n\n    /**\n     * Removes the specified node from the list.\n     *\n     * @param node  the node to remove\n     * @throws NullPointerException if {@code node} is null\n     */\n    protected void removeNode(final Node<E> node) {\n        Objects.requireNonNull(node, \"node\");\n        node.previous.next = node.next;\n        node.next.previous = node.previous;\n        size--;\n        modCount++;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * This implementation iterates over the elements of this list, checking each element in\n     * turn to see if it's contained in {@code coll}. If it's not contained, it's removed\n     * from this list. As a consequence, it is advised to use a collection type for\n     * {@code coll} that provides a fast (e.g. O(1)) implementation of\n     * {@link Collection#contains(Object)}.\n     */\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        boolean modified = false;\n        final Iterator<E> it = iterator();\n        while (it.hasNext()) {\n            if (!coll.contains(it.next())) {\n                it.remove();\n                modified = true;\n            }\n        }\n        return modified;\n    }\n\n    @Override\n    public E set(final int index, final E value) {\n        final Node<E> node = getNode(index, false);\n        final E oldValue = node.getValue();\n        updateNode(node, value);\n        return oldValue;\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Gets a sublist of the main list.\n     *\n     * @param fromIndexInclusive  the index to start from\n     * @param toIndexExclusive  the index to end at\n     * @return the new sublist\n     */\n    @Override\n    public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n        return new LinkedSubList<>(this, fromIndexInclusive, toIndexExclusive);\n    }\n\n    @Override\n    public Object[] toArray() {\n        return toArray(new Object[size]);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T[] toArray(T[] array) {\n        // Extend the array if needed\n        if (array.length < size) {\n            final Class<?> componentType = array.getClass().getComponentType();\n            array = (T[]) Array.newInstance(componentType, size);\n        }\n        // Copy the values into the array\n        int i = 0;\n        for (Node<E> node = header.next; node != header; node = node.next, i++) {\n            array[i] = (T) node.getValue();\n        }\n        // Set the value after the last value to null\n        if (array.length > size) {\n            array[size] = null;\n        }\n        return array;\n    }\n\n    @Override\n    public String toString() {\n        if (isEmpty()) {\n            return \"[]\";\n        }\n        final StringBuilder buf = new StringBuilder(16 * size());\n        buf.append(CollectionUtils.DEFAULT_TOSTRING_PREFIX);\n\n        final Iterator<E> it = iterator();\n        boolean hasNext = it.hasNext();\n        while (hasNext) {\n            final Object value = it.next();\n            buf.append(value == this ? \"(this Collection)\" : value);\n            hasNext = it.hasNext();\n            if (hasNext) {\n                buf.append(\", \");\n            }\n        }\n        buf.append(CollectionUtils.DEFAULT_TOSTRING_SUFFIX);\n        return buf.toString();\n    }\n\n    /**\n     * Updates the node with a new value.\n     * This implementation sets the value on the node.\n     * Subclasses can override this to record the change.\n     *\n     * @param node  node to update\n     * @param value  new value of the node\n     */\n    protected void updateNode(final Node<E> node, final E value) {\n        node.setValue(value);\n    }\n\n}", "super_interfaces": ["List<E>"], "fields": [{"attribute_expression": "transient Node<E> header;", "docstring": "\nA {@link Node} which indicates the start and end of the list and does not\nhold a value. The value of {@code next} is the first item in the\nlist. The value of {@code previous} is the last item in the list.\n", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "Node<E>", "name": "header", "syntax_pass": true}, {"attribute_expression": "transient int size;", "docstring": " The size of the list", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}, {"attribute_expression": "transient int modCount;", "docstring": " Modification count for iterators", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "int", "name": "modCount", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21", "name": "AbstractLinkedListForJava21", "file_path": "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java", "superclasses": "", "methods": ["[]AbstractLinkedListForJava21()", "[]AbstractLinkedListForJava21(Collection<? extends E>)", "[boolean]add(E)", "[void]add(int,E)", "[boolean]addAll(Collection<? extends E>)", "[boolean]addAll(int,Collection<? extends E>)", "[void]addFirst(E)", "[void]addLast(E)", "[void]addNode(Node<E>,Node<E>)", "[void]addNodeAfter(Node<E>,E)", "[void]addNodeBefore(Node<E>,E)", "[void]clear()", "[boolean]contains(Object)", "[boolean]containsAll(Collection<?>)", "[Node<E>]createHeaderNode()", "[Node<E>]createNode(E)", "[Iterator<E>]createSubListIterator(LinkedSubList<E>)", "[ListIterator<E>]createSubListListIterator(LinkedSubList<E>,int)", "[void]doReadObject(ObjectInputStream)", "[void]doWriteObject(ObjectOutputStream)", "[boolean]equals(Object)", "[E]get(int)", "[E]getFirst()", "[E]getLast()", "[Node<E>]getNode(int,boolean)", "[int]hashCode()", "[int]indexOf(Object)", "[void]init()", "[boolean]isEmpty()", "[boolean]isEqualValue(Object,Object)", "[Iterator<E>]iterator()", "[int]lastIndexOf(Object)", "[ListIterator<E>]listIterator()", "[ListIterator<E>]listIterator(int)", "[E]remove(int)", "[boolean]remove(Object)", "[boolean]removeAll(Collection<?>)", "[void]removeAllNodes()", "[E]removeFirst()", "[E]removeLast()", "[void]removeNode(Node<E>)", "[boolean]retainAll(Collection<?>)", "[E]set(int,E)", "[int]size()", "[List<E>]subList(int,int)", "[Object[]]toArray()", "[T[]]toArray(T[])", "[String]toString()", "[void]updateNode(Node<E>,E)"], "method_uris": ["src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[]AbstractLinkedListForJava21()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[]AbstractLinkedListForJava21(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[void]add(int,E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[boolean]addAll(Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[boolean]addAll(int,Collection<? extends E>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[void]addFirst(E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[void]addLast(E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[void]addNode(Node<E>,Node<E>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[void]addNodeAfter(Node<E>,E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[void]addNodeBefore(Node<E>,E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[void]clear()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[boolean]contains(Object)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[boolean]containsAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[Node<E>]createHeaderNode()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[Node<E>]createNode(E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[Iterator<E>]createSubListIterator(LinkedSubList<E>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[ListIterator<E>]createSubListListIterator(LinkedSubList<E>,int)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[void]doReadObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[void]doWriteObject(ObjectOutputStream)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[E]get(int)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[E]getFirst()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[E]getLast()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[Node<E>]getNode(int,boolean)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[int]hashCode()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[int]indexOf(Object)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[void]init()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[boolean]isEqualValue(Object,Object)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[int]lastIndexOf(Object)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[ListIterator<E>]listIterator()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[ListIterator<E>]listIterator(int)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[E]remove(int)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[void]removeAllNodes()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[E]removeFirst()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[E]removeLast()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[void]removeNode(Node<E>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[E]set(int,E)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[int]size()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[List<E>]subList(int,int)", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[Object[]]toArray()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[T[]]toArray(T[])", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[String]toString()", "src/main/java/org/apache/commons/collections4/list/AbstractLinkedListForJava21.java.AbstractLinkedListForJava21.[void]updateNode(Node<E>,E)"], "overrides": null, "attributes": [{"original_string": "    protected static class LinkedListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n\n        /** The parent list */\n        protected final AbstractLinkedListForJava21<E> parent;\n\n        /**\n         * The node that will be returned by {@link #next()}. If this is equal\n         * to {@link AbstractLinkedListForJava21#header} then there are no more values to return.\n         */\n        protected Node<E> next;\n\n        /**\n         * The index of {@link #next}.\n         */\n        protected int nextIndex;\n\n        /**\n         * The last node that was returned by {@link #next()} or {@link\n         * #previous()}. Set to {@code null} if {@link #next()} or {@link\n         * #previous()} haven't been called, or if the node has been removed\n         * with {@link #remove()} or a new node added with {@link #add(Object)}.\n         * Should be accessed through {@link #getLastNodeReturned()} to enforce\n         * this behavior.\n         */\n        protected Node<E> current;\n\n        /**\n         * The modification count that the list is expected to have. If the list\n         * doesn't have this count, then a\n         * {@link java.util.ConcurrentModificationException} may be thrown by\n         * the operations.\n         */\n        protected int expectedModCount;\n\n        /**\n         * Create a ListIterator for a list.\n         *\n         * @param parent  the parent list\n         * @param fromIndex  the index to start at\n         * @throws IndexOutOfBoundsException if fromIndex is less than 0 or greater than the size of the list\n         */\n        protected LinkedListIterator(final AbstractLinkedListForJava21<E> parent, final int fromIndex)\n                throws IndexOutOfBoundsException {\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.getNode(fromIndex, true);\n            this.nextIndex = fromIndex;\n        }\n\n        @Override\n        public void add(final E obj) {\n            checkModCount();\n            parent.addNodeBefore(next, obj);\n            current = null;\n            nextIndex++;\n            expectedModCount++;\n        }\n\n        /**\n         * Checks the modification count of the list is the value that this\n         * object expects.\n         *\n         * @throws ConcurrentModificationException If the list's modification\n         * count isn't the value that was expected.\n         */\n        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        /**\n         * Gets the last node returned.\n         *\n         * @return the last node returned\n         * @throws IllegalStateException If {@link #next()} or {@link #previous()} haven't been called,\n         * or if the node has been removed with {@link #remove()} or a new node added with {@link #add(Object)}.\n         */\n        protected Node<E> getLastNodeReturned() throws IllegalStateException {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return next != parent.header;\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return next.previous != parent.header;\n        }\n\n        @Override\n        public E next() {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            final E value = next.getValue();\n            current = next;\n            next = next.next;\n            nextIndex++;\n            return value;\n        }\n\n        @Override\n        public int nextIndex() {\n            return nextIndex;\n        }\n\n        @Override\n        public E previous() {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            next = next.previous;\n            final E value = next.getValue();\n            current = next;\n            nextIndex--;\n            return value;\n        }\n\n        @Override\n        public int previousIndex() {\n            // not normally overridden, as relative to nextIndex()\n            return nextIndex() - 1;\n        }\n\n        @Override\n        public void remove() {\n            checkModCount();\n            if (current == next) {\n                // remove() following previous()\n                next = next.next;\n                parent.removeNode(getLastNodeReturned());\n            } else {\n                // remove() following next()\n                parent.removeNode(getLastNodeReturned());\n                nextIndex--;\n            }\n            current = null;\n            expectedModCount++;\n        }\n\n        @Override\n        public void set(final E obj) {\n            checkModCount();\n            getLastNodeReturned().setValue(obj);\n        }\n\n    }", "definition": "    protected static class LinkedListIterator<E> implements ListIterator<E>, OrderedIterator<E>", "class_docstring": "\nA list iterator over the linked list.\n\n@param <E> the type of elements in this iterator.\n", "name": "LinkedListIterator", "super_interfaces": ["ListIterator<E>", "OrderedIterator<E>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected final AbstractLinkedListForJava21<E> parent;", "docstring": " The parent list", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "AbstractLinkedListForJava21<E>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "protected Node<E> next;", "docstring": "\nThe node that will be returned by {@link #next()}. If this is equal\nto {@link AbstractLinkedListForJava21#header} then there are no more values to return.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Node<E>", "name": "next", "syntax_pass": true}, {"attribute_expression": "protected int nextIndex;", "docstring": "\nThe index of {@link #next}.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "nextIndex", "syntax_pass": true}, {"attribute_expression": "protected Node<E> current;", "docstring": "\nThe last node that was returned by {@link #next()} or {@link\n#previous()}. Set to {@code null} if {@link #next()} or {@link\n#previous()} haven't been called, or if the node has been removed\nwith {@link #remove()} or a new node added with {@link #add(Object)}.\nShould be accessed through {@link #getLastNodeReturned()} to enforce\nthis behavior.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Node<E>", "name": "current", "syntax_pass": true}, {"attribute_expression": "protected int expectedModCount;", "docstring": "\nThe modification count that the list is expected to have. If the list\ndoesn't have this count, then a\n{@link java.util.ConcurrentModificationException} may be thrown by\nthe operations.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "expectedModCount", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected LinkedListIterator(final AbstractLinkedListForJava21<E> parent, final int fromIndex)\n                throws IndexOutOfBoundsException {\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.getNode(fromIndex, true);\n            this.nextIndex = fromIndex;\n        }", "docstring": "\nCreate a ListIterator for a list.\n\n@param parent  the parent list\n@param fromIndex  the index to start at\n@throws IndexOutOfBoundsException if fromIndex is less than 0 or greater than the size of the list\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "LinkedListIterator", "params": [{"name": "parent", "type": "AbstractLinkedListForJava21<E>"}, {"name": "fromIndex", "type": "int"}], "body": "                                                 {\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.getNode(fromIndex, true);\n            this.nextIndex = fromIndex;\n        }", "signature": "protected LinkedListIterator(final AbstractLinkedListForJava21<E> parent, final int fromIndex)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void add(final E obj) {\n            checkModCount();\n            parent.addNodeBefore(next, obj);\n            current = null;\n            nextIndex++;\n            expectedModCount++;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "obj", "type": "E"}], "body": "                                     {\n            checkModCount();\n            parent.addNodeBefore(next, obj);\n            current = null;\n            nextIndex++;\n            expectedModCount++;\n        }", "signature": "@Override\n        public void add(final E obj)"}, {"syntax_pass": true, "original_string": "        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }", "docstring": "\nChecks the modification count of the list is the value that this\nobject expects.\n\n@throws ConcurrentModificationException If the list's modification\ncount isn't the value that was expected.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "checkModCount", "params": [], "body": "                                       {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }", "signature": "protected void checkModCount()"}, {"syntax_pass": true, "original_string": "        protected Node<E> getLastNodeReturned() throws IllegalStateException {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current;\n        }", "docstring": "\nGets the last node returned.\n\n@return the last node returned\n@throws IllegalStateException If {@link #next()} or {@link #previous()} haven't been called,\nor if the node has been removed with {@link #remove()} or a new node added with {@link #add(Object)}.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Node<E>", "classes": []}, "name": "getLastNodeReturned", "params": [], "body": "                                                                             {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current;\n        }", "signature": "protected Node<E> getLastNodeReturned()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return next != parent.header;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return next != parent.header;\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasPrevious() {\n            return next.previous != parent.header;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasPrevious", "params": [], "body": "                                     {\n            return next.previous != parent.header;\n        }", "signature": "@Override\n        public boolean hasPrevious()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E next() {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            final E value = next.getValue();\n            current = next;\n            next = next.next;\n            nextIndex++;\n            return value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "next", "params": [], "body": "                        {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            final E value = next.getValue();\n            current = next;\n            next = next.next;\n            nextIndex++;\n            return value;\n        }", "signature": "@Override\n        public E next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int nextIndex() {\n            return nextIndex;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "nextIndex", "params": [], "body": "                               {\n            return nextIndex;\n        }", "signature": "@Override\n        public int nextIndex()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E previous() {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            next = next.previous;\n            final E value = next.getValue();\n            current = next;\n            nextIndex--;\n            return value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            next = next.previous;\n            final E value = next.getValue();\n            current = next;\n            nextIndex--;\n            return value;\n        }", "signature": "@Override\n        public E previous()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int previousIndex() {\n            // not normally overridden, as relative to nextIndex()\n            return nextIndex() - 1;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "previousIndex", "params": [], "body": "                                   {\n            // not normally overridden, as relative to nextIndex()\n            return nextIndex() - 1;\n        }", "signature": "@Override\n        public int previousIndex()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            checkModCount();\n            if (current == next) {\n                // remove() following previous()\n                next = next.next;\n                parent.removeNode(getLastNodeReturned());\n            } else {\n                // remove() following next()\n                parent.removeNode(getLastNodeReturned());\n                nextIndex--;\n            }\n            current = null;\n            expectedModCount++;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            checkModCount();\n            if (current == next) {\n                // remove() following previous()\n                next = next.next;\n                parent.removeNode(getLastNodeReturned());\n            } else {\n                // remove() following next()\n                parent.removeNode(getLastNodeReturned());\n                nextIndex--;\n            }\n            current = null;\n            expectedModCount++;\n        }", "signature": "@Override\n        public void remove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void set(final E obj) {\n            checkModCount();\n            getLastNodeReturned().setValue(obj);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "set", "params": [{"name": "obj", "type": "E"}], "body": "                                     {\n            checkModCount();\n            getLastNodeReturned().setValue(obj);\n        }", "signature": "@Override\n        public void set(final E obj)"}]}, {"original_string": "    protected static class LinkedSubList<E> extends AbstractList<E> {\n        /** The main list */\n        AbstractLinkedListForJava21<E> parent;\n        /** Offset from the main list */\n        int offset;\n        /** Sublist size */\n        int size;\n        /** Sublist modCount */\n        int expectedModCount;\n\n        protected LinkedSubList(final AbstractLinkedListForJava21<E> parent, final int fromIndex, final int toIndex) {\n            if (fromIndex < 0) {\n                throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n            }\n            if (toIndex > parent.size()) {\n                throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex);\n            }\n            if (fromIndex > toIndex) {\n                throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n            }\n            this.parent = parent;\n            this.offset = fromIndex;\n            this.size = toIndex - fromIndex;\n            this.expectedModCount = parent.modCount;\n        }\n\n        @Override\n        public void add(final int index, final E obj) {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            parent.add(index + offset, obj);\n            expectedModCount = parent.modCount;\n            size++;\n            modCount++;\n        }\n\n        @Override\n        public boolean addAll(final Collection<? extends E> coll) {\n            return addAll(size, coll);\n        }\n\n        @Override\n        public boolean addAll(final int index, final Collection<? extends E> coll) {\n            rangeCheck(index, size + 1);\n            final int cSize = coll.size();\n            if (cSize == 0) {\n                return false;\n            }\n\n            checkModCount();\n            parent.addAll(offset + index, coll);\n            expectedModCount = parent.modCount;\n            size += cSize;\n            modCount++;\n            return true;\n        }\n\n        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        @Override\n        public void clear() {\n            checkModCount();\n            final Iterator<E> it = iterator();\n            while (it.hasNext()) {\n                it.next();\n                it.remove();\n            }\n        }\n\n        @Override\n        public E get(final int index) {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.get(index + offset);\n        }\n\n        @Override\n        public Iterator<E> iterator() {\n            checkModCount();\n            return parent.createSubListIterator(this);\n        }\n\n        @Override\n        public ListIterator<E> listIterator(final int index) {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            return parent.createSubListListIterator(this, index);\n        }\n\n        protected void rangeCheck(final int index, final int beyond) {\n            if (index < 0 || index >= beyond) {\n                throw new IndexOutOfBoundsException(\"Index '\" + index + \"' out of bounds for size '\" + size + \"'\");\n            }\n        }\n\n        @Override\n        public E remove(final int index) {\n            rangeCheck(index, size);\n            checkModCount();\n            final E result = parent.remove(index + offset);\n            expectedModCount = parent.modCount;\n            size--;\n            modCount++;\n            return result;\n        }\n\n        @Override\n        public E set(final int index, final E obj) {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.set(index + offset, obj);\n        }\n\n        @Override\n        public int size() {\n            checkModCount();\n            return size;\n        }\n\n        @Override\n        public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n            return new LinkedSubList<>(parent, fromIndexInclusive + offset, toIndexExclusive + offset);\n        }\n    }", "definition": "    protected static class LinkedSubList<E> extends AbstractList<E>", "class_docstring": "\nThe sublist implementation for AbstractLinkedListForJava21.\n\n@param <E> the type of elements in this list.\n", "name": "LinkedSubList", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "AbstractLinkedListForJava21<E> parent;", "docstring": " The main list", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "AbstractLinkedListForJava21<E>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "int offset;", "docstring": " Offset from the main list", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "offset", "syntax_pass": true}, {"attribute_expression": "int size;", "docstring": " Sublist size", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "size", "syntax_pass": true}, {"attribute_expression": "int expectedModCount;", "docstring": " Sublist modCount", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int", "name": "expectedModCount", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected LinkedSubList(final AbstractLinkedListForJava21<E> parent, final int fromIndex, final int toIndex) {\n            if (fromIndex < 0) {\n                throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n            }\n            if (toIndex > parent.size()) {\n                throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex);\n            }\n            if (fromIndex > toIndex) {\n                throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n            }\n            this.parent = parent;\n            this.offset = fromIndex;\n            this.size = toIndex - fromIndex;\n            this.expectedModCount = parent.modCount;\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "LinkedSubList", "params": [{"name": "parent", "type": "AbstractLinkedListForJava21<E>"}, {"name": "fromIndex", "type": "int"}, {"name": "toIndex", "type": "int"}], "body": "                                                                                                                     {\n            if (fromIndex < 0) {\n                throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n            }\n            if (toIndex > parent.size()) {\n                throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex);\n            }\n            if (fromIndex > toIndex) {\n                throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n            }\n            this.parent = parent;\n            this.offset = fromIndex;\n            this.size = toIndex - fromIndex;\n            this.expectedModCount = parent.modCount;\n        }", "signature": "protected LinkedSubList(final AbstractLinkedListForJava21<E> parent, final int fromIndex, final int toIndex)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void add(final int index, final E obj) {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            parent.add(index + offset, obj);\n            expectedModCount = parent.modCount;\n            size++;\n            modCount++;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "index", "type": "int"}, {"name": "obj", "type": "E"}], "body": "                                                      {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            parent.add(index + offset, obj);\n            expectedModCount = parent.modCount;\n            size++;\n            modCount++;\n        }", "signature": "@Override\n        public void add(final int index, final E obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean addAll(final Collection<? extends E> coll) {\n            return addAll(size, coll);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "addAll", "params": [{"name": "coll", "type": "Collection<? extends E>"}], "body": "                                                                  {\n            return addAll(size, coll);\n        }", "signature": "@Override\n        public boolean addAll(final Collection<? extends E> coll)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean addAll(final int index, final Collection<? extends E> coll) {\n            rangeCheck(index, size + 1);\n            final int cSize = coll.size();\n            if (cSize == 0) {\n                return false;\n            }\n\n            checkModCount();\n            parent.addAll(offset + index, coll);\n            expectedModCount = parent.modCount;\n            size += cSize;\n            modCount++;\n            return true;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "addAll", "params": [{"name": "index", "type": "int"}, {"name": "coll", "type": "Collection<? extends E>"}], "body": "                                                                                   {\n            rangeCheck(index, size + 1);\n            final int cSize = coll.size();\n            if (cSize == 0) {\n                return false;\n            }\n\n            checkModCount();\n            parent.addAll(offset + index, coll);\n            expectedModCount = parent.modCount;\n            size += cSize;\n            modCount++;\n            return true;\n        }", "signature": "@Override\n        public boolean addAll(final int index, final Collection<? extends E> coll)"}, {"syntax_pass": true, "original_string": "        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "checkModCount", "params": [], "body": "                                       {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }", "signature": "protected void checkModCount()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            checkModCount();\n            final Iterator<E> it = iterator();\n            while (it.hasNext()) {\n                it.next();\n                it.remove();\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            checkModCount();\n            final Iterator<E> it = iterator();\n            while (it.hasNext()) {\n                it.next();\n                it.remove();\n            }\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E get(final int index) {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.get(index + offset);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                      {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.get(index + offset);\n        }", "signature": "@Override\n        public E get(final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<E> iterator() {\n            checkModCount();\n            return parent.createSubListIterator(this);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<E>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            checkModCount();\n            return parent.createSubListIterator(this);\n        }", "signature": "@Override\n        public Iterator<E> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public ListIterator<E> listIterator(final int index) {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            return parent.createSubListListIterator(this, index);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListIterator<E>", "classes": []}, "name": "listIterator", "params": [{"name": "index", "type": "int"}], "body": "                                                             {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            return parent.createSubListListIterator(this, index);\n        }", "signature": "@Override\n        public ListIterator<E> listIterator(final int index)"}, {"syntax_pass": true, "original_string": "        protected void rangeCheck(final int index, final int beyond) {\n            if (index < 0 || index >= beyond) {\n                throw new IndexOutOfBoundsException(\"Index '\" + index + \"' out of bounds for size '\" + size + \"'\");\n            }\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "rangeCheck", "params": [{"name": "index", "type": "int"}, {"name": "beyond", "type": "int"}], "body": "                                                                     {\n            if (index < 0 || index >= beyond) {\n                throw new IndexOutOfBoundsException(\"Index '\" + index + \"' out of bounds for size '\" + size + \"'\");\n            }\n        }", "signature": "protected void rangeCheck(final int index, final int beyond)"}, {"syntax_pass": true, "original_string": "        @Override\n        public E remove(final int index) {\n            rangeCheck(index, size);\n            checkModCount();\n            final E result = parent.remove(index + offset);\n            expectedModCount = parent.modCount;\n            size--;\n            modCount++;\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "remove", "params": [{"name": "index", "type": "int"}], "body": "                                         {\n            rangeCheck(index, size);\n            checkModCount();\n            final E result = parent.remove(index + offset);\n            expectedModCount = parent.modCount;\n            size--;\n            modCount++;\n            return result;\n        }", "signature": "@Override\n        public E remove(final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public E set(final int index, final E obj) {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.set(index + offset, obj);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "set", "params": [{"name": "index", "type": "int"}, {"name": "obj", "type": "E"}], "body": "                                                   {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.set(index + offset, obj);\n        }", "signature": "@Override\n        public E set(final int index, final E obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            checkModCount();\n            return size;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            checkModCount();\n            return size;\n        }", "signature": "@Override\n        public int size()"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n            return new LinkedSubList<>(parent, fromIndexInclusive + offset, toIndexExclusive + offset);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<E>", "classes": []}, "name": "subList", "params": [{"name": "fromIndexInclusive", "type": "int"}, {"name": "toIndexExclusive", "type": "int"}], "body": "                                                                                         {\n            return new LinkedSubList<>(parent, fromIndexInclusive + offset, toIndexExclusive + offset);\n        }", "signature": "@Override\n        public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive)"}]}, {"original_string": "    protected static class LinkedSubListIterator<E> extends LinkedListIterator<E> {\n\n        /** The sub list */\n        protected final LinkedSubList<E> sub;\n\n        protected LinkedSubListIterator(final LinkedSubList<E> sub, final int startIndex) {\n            super(sub.parent, startIndex + sub.offset);\n            this.sub = sub;\n        }\n\n        @Override\n        public void add(final E obj) {\n            super.add(obj);\n            sub.expectedModCount = parent.modCount;\n            sub.size++;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return nextIndex() < sub.size;\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return previousIndex() >= 0;\n        }\n\n        @Override\n        public int nextIndex() {\n            return super.nextIndex() - sub.offset;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            sub.expectedModCount = parent.modCount;\n            sub.size--;\n        }\n    }", "definition": "    protected static class LinkedSubListIterator<E> extends LinkedListIterator<E>", "class_docstring": "\nA list iterator over the linked sub list.\n\n@param <E> the type of elements in this iterator.\n", "name": "LinkedSubListIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected final LinkedSubList<E> sub;", "docstring": " The sub list", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "LinkedSubList<E>", "name": "sub", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected LinkedSubListIterator(final LinkedSubList<E> sub, final int startIndex) {\n            super(sub.parent, startIndex + sub.offset);\n            this.sub = sub;\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "LinkedSubListIterator", "params": [{"name": "sub", "type": "LinkedSubList<E>"}, {"name": "startIndex", "type": "int"}], "body": "                                                                                          {\n            super(sub.parent, startIndex + sub.offset);\n            this.sub = sub;\n        }", "signature": "protected LinkedSubListIterator(final LinkedSubList<E> sub, final int startIndex)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void add(final E obj) {\n            super.add(obj);\n            sub.expectedModCount = parent.modCount;\n            sub.size++;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "obj", "type": "E"}], "body": "                                     {\n            super.add(obj);\n            sub.expectedModCount = parent.modCount;\n            sub.size++;\n        }", "signature": "@Override\n        public void add(final E obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return nextIndex() < sub.size;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return nextIndex() < sub.size;\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasPrevious() {\n            return previousIndex() >= 0;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasPrevious", "params": [], "body": "                                     {\n            return previousIndex() >= 0;\n        }", "signature": "@Override\n        public boolean hasPrevious()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int nextIndex() {\n            return super.nextIndex() - sub.offset;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "nextIndex", "params": [], "body": "                               {\n            return super.nextIndex() - sub.offset;\n        }", "signature": "@Override\n        public int nextIndex()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            super.remove();\n            sub.expectedModCount = parent.modCount;\n            sub.size--;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            super.remove();\n            sub.expectedModCount = parent.modCount;\n            sub.size--;\n        }", "signature": "@Override\n        public void remove()"}]}, {"original_string": "    protected static class Node<E> {\n\n        /** A pointer to the node before this node */\n        protected Node<E> previous;\n        /** A pointer to the node after this node */\n        protected Node<E> next;\n        /** The object contained within this node */\n        protected E value;\n\n        /**\n         * Constructs a new header node.\n         */\n        protected Node() {\n            previous = this;\n            next = this;\n        }\n\n        /**\n         * Constructs a new node.\n         *\n         * @param value  the value to store\n         */\n        protected Node(final E value) {\n            this.value = value;\n        }\n\n        /**\n         * Constructs a new node.\n         *\n         * @param previous  the previous node in the list\n         * @param next  the next node in the list\n         * @param value  the value to store\n         */\n        protected Node(final Node<E> previous, final Node<E> next, final E value) {\n            this.previous = previous;\n            this.next = next;\n            this.value = value;\n        }\n\n        /**\n         * Gets the next node.\n         *\n         * @return the next node\n         * @since 3.1\n         */\n        protected Node<E> getNextNode() {\n            return next;\n        }\n\n        /**\n         * Gets the previous node.\n         *\n         * @return the previous node\n         * @since 3.1\n         */\n        protected Node<E> getPreviousNode() {\n            return previous;\n        }\n\n        /**\n         * Gets the value of the node.\n         *\n         * @return the value\n         * @since 3.1\n         */\n        protected E getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the next node.\n         *\n         * @param next  the next node\n         * @since 3.1\n         */\n        protected void setNextNode(final Node<E> next) {\n            this.next = next;\n        }\n\n        /**\n         * Sets the previous node.\n         *\n         * @param previous  the previous node\n         * @since 3.1\n         */\n        protected void setPreviousNode(final Node<E> previous) {\n            this.previous = previous;\n        }\n\n        /**\n         * Sets the value of the node.\n         *\n         * @param value  the value\n         * @since 3.1\n         */\n        protected void setValue(final E value) {\n            this.value = value;\n        }\n    }", "definition": "    protected static class Node<E>", "class_docstring": "\nA node within the linked list.\n<p>\nFrom Commons Collections 3.1, all access to the {@code value} property\nis via the methods on this class.\n</p>\n\n@param <E> the type of the node value.\n", "name": "Node", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected Node<E> previous;", "docstring": " A pointer to the node before this node", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Node<E>", "name": "previous", "syntax_pass": true}, {"attribute_expression": "protected Node<E> next;", "docstring": " A pointer to the node after this node", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Node<E>", "name": "next", "syntax_pass": true}, {"attribute_expression": "protected E value;", "docstring": " The object contained within this node", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "E", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected Node() {\n            previous = this;\n            next = this;\n        }", "docstring": "\nConstructs a new header node.\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "Node", "params": [], "body": "                         {\n            previous = this;\n            next = this;\n        }", "signature": "protected Node()"}, {"syntax_pass": true, "original_string": "        protected Node(final E value) {\n            this.value = value;\n        }", "docstring": "\nConstructs a new node.\n\n@param value  the value to store\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "Node", "params": [{"name": "value", "type": "E"}], "body": "                                      {\n            this.value = value;\n        }", "signature": "protected Node(final E value)"}, {"syntax_pass": true, "original_string": "        protected Node(final Node<E> previous, final Node<E> next, final E value) {\n            this.previous = previous;\n            this.next = next;\n            this.value = value;\n        }", "docstring": "\nConstructs a new node.\n\n@param previous  the previous node in the list\n@param next  the next node in the list\n@param value  the value to store\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "Node", "params": [{"name": "previous", "type": "Node<E>"}, {"name": "next", "type": "Node<E>"}, {"name": "value", "type": "E"}], "body": "                                                                                  {\n            this.previous = previous;\n            this.next = next;\n            this.value = value;\n        }", "signature": "protected Node(final Node<E> previous, final Node<E> next, final E value)"}, {"syntax_pass": true, "original_string": "        protected Node<E> getNextNode() {\n            return next;\n        }", "docstring": "\nGets the next node.\n\n@return the next node\n@since 3.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Node<E>", "classes": []}, "name": "getNextNode", "params": [], "body": "                                        {\n            return next;\n        }", "signature": "protected Node<E> getNextNode()"}, {"syntax_pass": true, "original_string": "        protected Node<E> getPreviousNode() {\n            return previous;\n        }", "docstring": "\nGets the previous node.\n\n@return the previous node\n@since 3.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Node<E>", "classes": []}, "name": "getPreviousNode", "params": [], "body": "                                            {\n            return previous;\n        }", "signature": "protected Node<E> getPreviousNode()"}, {"syntax_pass": true, "original_string": "        protected E getValue() {\n            return value;\n        }", "docstring": "\nGets the value of the node.\n\n@return the value\n@since 3.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "E", "classes": []}, "name": "getValue", "params": [], "body": "                               {\n            return value;\n        }", "signature": "protected E getValue()"}, {"syntax_pass": true, "original_string": "        protected void setNextNode(final Node<E> next) {\n            this.next = next;\n        }", "docstring": "\nSets the next node.\n\n@param next  the next node\n@since 3.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "setNextNode", "params": [{"name": "next", "type": "Node<E>"}], "body": "                                                       {\n            this.next = next;\n        }", "signature": "protected void setNextNode(final Node<E> next)"}, {"syntax_pass": true, "original_string": "        protected void setPreviousNode(final Node<E> previous) {\n            this.previous = previous;\n        }", "docstring": "\nSets the previous node.\n\n@param previous  the previous node\n@since 3.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "setPreviousNode", "params": [{"name": "previous", "type": "Node<E>"}], "body": "                                                               {\n            this.previous = previous;\n        }", "signature": "protected void setPreviousNode(final Node<E> previous)"}, {"syntax_pass": true, "original_string": "        protected void setValue(final E value) {\n            this.value = value;\n        }", "docstring": "\nSets the value of the node.\n\n@param value  the value\n@since 3.1\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "void", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "E"}], "body": "                                               {\n            this.value = value;\n        }", "signature": "protected void setValue(final E value)"}]}], "class_docstring": "\nAn abstract implementation of a linked list which provides numerous points for\nsubclasses to override.\n<p>\nOverridable methods are provided to change the storage node and to change how\nnodes are added to and removed. Hopefully, all you need for unusual subclasses\nis here.\n<p>\nThis is a copy of AbstractLinkedList, modified to be compatible with Java 21\n(see COLLECTIONS-842 for details).\n\n@param <E> the type of elements in this list\n@since 4.5.0-M2\n", "original_string": "public abstract class AbstractLinkedListForJava21<E> implements List<E> {\n\n    /*\n     * Implementation notes:\n     * - a standard circular doubly-linked list\n     * - a marker node is stored to mark the start and the end of the list\n     * - node creation and removal always occurs through createNode() and\n     *   removeNode().\n     * - a modification count is kept, with the same semantics as\n     * {@link java.util.LinkedList}.\n     * - respects {@link AbstractList#modCount}\n     */\n\n    /**\n     * A list iterator over the linked list.\n     *\n     * @param <E> the type of elements in this iterator.\n     */\n    protected static class LinkedListIterator<E> implements ListIterator<E>, OrderedIterator<E> {\n\n        /** The parent list */\n        protected final AbstractLinkedListForJava21<E> parent;\n\n        /**\n         * The node that will be returned by {@link #next()}. If this is equal\n         * to {@link AbstractLinkedListForJava21#header} then there are no more values to return.\n         */\n        protected Node<E> next;\n\n        /**\n         * The index of {@link #next}.\n         */\n        protected int nextIndex;\n\n        /**\n         * The last node that was returned by {@link #next()} or {@link\n         * #previous()}. Set to {@code null} if {@link #next()} or {@link\n         * #previous()} haven't been called, or if the node has been removed\n         * with {@link #remove()} or a new node added with {@link #add(Object)}.\n         * Should be accessed through {@link #getLastNodeReturned()} to enforce\n         * this behavior.\n         */\n        protected Node<E> current;\n\n        /**\n         * The modification count that the list is expected to have. If the list\n         * doesn't have this count, then a\n         * {@link java.util.ConcurrentModificationException} may be thrown by\n         * the operations.\n         */\n        protected int expectedModCount;\n\n        /**\n         * Create a ListIterator for a list.\n         *\n         * @param parent  the parent list\n         * @param fromIndex  the index to start at\n         * @throws IndexOutOfBoundsException if fromIndex is less than 0 or greater than the size of the list\n         */\n        protected LinkedListIterator(final AbstractLinkedListForJava21<E> parent, final int fromIndex)\n                throws IndexOutOfBoundsException {\n            this.parent = parent;\n            this.expectedModCount = parent.modCount;\n            this.next = parent.getNode(fromIndex, true);\n            this.nextIndex = fromIndex;\n        }\n\n        @Override\n        public void add(final E obj) {\n            checkModCount();\n            parent.addNodeBefore(next, obj);\n            current = null;\n            nextIndex++;\n            expectedModCount++;\n        }\n\n        /**\n         * Checks the modification count of the list is the value that this\n         * object expects.\n         *\n         * @throws ConcurrentModificationException If the list's modification\n         * count isn't the value that was expected.\n         */\n        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        /**\n         * Gets the last node returned.\n         *\n         * @return the last node returned\n         * @throws IllegalStateException If {@link #next()} or {@link #previous()} haven't been called,\n         * or if the node has been removed with {@link #remove()} or a new node added with {@link #add(Object)}.\n         */\n        protected Node<E> getLastNodeReturned() throws IllegalStateException {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return next != parent.header;\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return next.previous != parent.header;\n        }\n\n        @Override\n        public E next() {\n            checkModCount();\n            if (!hasNext()) {\n                throw new NoSuchElementException(\"No element at index \" + nextIndex + \".\");\n            }\n            final E value = next.getValue();\n            current = next;\n            next = next.next;\n            nextIndex++;\n            return value;\n        }\n\n        @Override\n        public int nextIndex() {\n            return nextIndex;\n        }\n\n        @Override\n        public E previous() {\n            checkModCount();\n            if (!hasPrevious()) {\n                throw new NoSuchElementException(\"Already at start of list.\");\n            }\n            next = next.previous;\n            final E value = next.getValue();\n            current = next;\n            nextIndex--;\n            return value;\n        }\n\n        @Override\n        public int previousIndex() {\n            // not normally overridden, as relative to nextIndex()\n            return nextIndex() - 1;\n        }\n\n        @Override\n        public void remove() {\n            checkModCount();\n            if (current == next) {\n                // remove() following previous()\n                next = next.next;\n                parent.removeNode(getLastNodeReturned());\n            } else {\n                // remove() following next()\n                parent.removeNode(getLastNodeReturned());\n                nextIndex--;\n            }\n            current = null;\n            expectedModCount++;\n        }\n\n        @Override\n        public void set(final E obj) {\n            checkModCount();\n            getLastNodeReturned().setValue(obj);\n        }\n\n    }\n\n    /**\n     * The sublist implementation for AbstractLinkedListForJava21.\n     *\n     * @param <E> the type of elements in this list.\n     */\n    protected static class LinkedSubList<E> extends AbstractList<E> {\n        /** The main list */\n        AbstractLinkedListForJava21<E> parent;\n        /** Offset from the main list */\n        int offset;\n        /** Sublist size */\n        int size;\n        /** Sublist modCount */\n        int expectedModCount;\n\n        protected LinkedSubList(final AbstractLinkedListForJava21<E> parent, final int fromIndex, final int toIndex) {\n            if (fromIndex < 0) {\n                throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n            }\n            if (toIndex > parent.size()) {\n                throw new IndexOutOfBoundsException(\"toIndex = \" + toIndex);\n            }\n            if (fromIndex > toIndex) {\n                throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n            }\n            this.parent = parent;\n            this.offset = fromIndex;\n            this.size = toIndex - fromIndex;\n            this.expectedModCount = parent.modCount;\n        }\n\n        @Override\n        public void add(final int index, final E obj) {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            parent.add(index + offset, obj);\n            expectedModCount = parent.modCount;\n            size++;\n            modCount++;\n        }\n\n        @Override\n        public boolean addAll(final Collection<? extends E> coll) {\n            return addAll(size, coll);\n        }\n\n        @Override\n        public boolean addAll(final int index, final Collection<? extends E> coll) {\n            rangeCheck(index, size + 1);\n            final int cSize = coll.size();\n            if (cSize == 0) {\n                return false;\n            }\n\n            checkModCount();\n            parent.addAll(offset + index, coll);\n            expectedModCount = parent.modCount;\n            size += cSize;\n            modCount++;\n            return true;\n        }\n\n        protected void checkModCount() {\n            if (parent.modCount != expectedModCount) {\n                throw new ConcurrentModificationException();\n            }\n        }\n\n        @Override\n        public void clear() {\n            checkModCount();\n            final Iterator<E> it = iterator();\n            while (it.hasNext()) {\n                it.next();\n                it.remove();\n            }\n        }\n\n        @Override\n        public E get(final int index) {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.get(index + offset);\n        }\n\n        @Override\n        public Iterator<E> iterator() {\n            checkModCount();\n            return parent.createSubListIterator(this);\n        }\n\n        @Override\n        public ListIterator<E> listIterator(final int index) {\n            rangeCheck(index, size + 1);\n            checkModCount();\n            return parent.createSubListListIterator(this, index);\n        }\n\n        protected void rangeCheck(final int index, final int beyond) {\n            if (index < 0 || index >= beyond) {\n                throw new IndexOutOfBoundsException(\"Index '\" + index + \"' out of bounds for size '\" + size + \"'\");\n            }\n        }\n\n        @Override\n        public E remove(final int index) {\n            rangeCheck(index, size);\n            checkModCount();\n            final E result = parent.remove(index + offset);\n            expectedModCount = parent.modCount;\n            size--;\n            modCount++;\n            return result;\n        }\n\n        @Override\n        public E set(final int index, final E obj) {\n            rangeCheck(index, size);\n            checkModCount();\n            return parent.set(index + offset, obj);\n        }\n\n        @Override\n        public int size() {\n            checkModCount();\n            return size;\n        }\n\n        @Override\n        public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n            return new LinkedSubList<>(parent, fromIndexInclusive + offset, toIndexExclusive + offset);\n        }\n    }\n\n    /**\n     * A list iterator over the linked sub list.\n     *\n     * @param <E> the type of elements in this iterator.\n     */\n    protected static class LinkedSubListIterator<E> extends LinkedListIterator<E> {\n\n        /** The sub list */\n        protected final LinkedSubList<E> sub;\n\n        protected LinkedSubListIterator(final LinkedSubList<E> sub, final int startIndex) {\n            super(sub.parent, startIndex + sub.offset);\n            this.sub = sub;\n        }\n\n        @Override\n        public void add(final E obj) {\n            super.add(obj);\n            sub.expectedModCount = parent.modCount;\n            sub.size++;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return nextIndex() < sub.size;\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return previousIndex() >= 0;\n        }\n\n        @Override\n        public int nextIndex() {\n            return super.nextIndex() - sub.offset;\n        }\n\n        @Override\n        public void remove() {\n            super.remove();\n            sub.expectedModCount = parent.modCount;\n            sub.size--;\n        }\n    }\n\n    /**\n     * A node within the linked list.\n     * <p>\n     * From Commons Collections 3.1, all access to the {@code value} property\n     * is via the methods on this class.\n     * </p>\n     *\n     * @param <E> the type of the node value.\n     */\n    protected static class Node<E> {\n\n        /** A pointer to the node before this node */\n        protected Node<E> previous;\n        /** A pointer to the node after this node */\n        protected Node<E> next;\n        /** The object contained within this node */\n        protected E value;\n\n        /**\n         * Constructs a new header node.\n         */\n        protected Node() {\n            previous = this;\n            next = this;\n        }\n\n        /**\n         * Constructs a new node.\n         *\n         * @param value  the value to store\n         */\n        protected Node(final E value) {\n            this.value = value;\n        }\n\n        /**\n         * Constructs a new node.\n         *\n         * @param previous  the previous node in the list\n         * @param next  the next node in the list\n         * @param value  the value to store\n         */\n        protected Node(final Node<E> previous, final Node<E> next, final E value) {\n            this.previous = previous;\n            this.next = next;\n            this.value = value;\n        }\n\n        /**\n         * Gets the next node.\n         *\n         * @return the next node\n         * @since 3.1\n         */\n        protected Node<E> getNextNode() {\n            return next;\n        }\n\n        /**\n         * Gets the previous node.\n         *\n         * @return the previous node\n         * @since 3.1\n         */\n        protected Node<E> getPreviousNode() {\n            return previous;\n        }\n\n        /**\n         * Gets the value of the node.\n         *\n         * @return the value\n         * @since 3.1\n         */\n        protected E getValue() {\n            return value;\n        }\n\n        /**\n         * Sets the next node.\n         *\n         * @param next  the next node\n         * @since 3.1\n         */\n        protected void setNextNode(final Node<E> next) {\n            this.next = next;\n        }\n\n        /**\n         * Sets the previous node.\n         *\n         * @param previous  the previous node\n         * @since 3.1\n         */\n        protected void setPreviousNode(final Node<E> previous) {\n            this.previous = previous;\n        }\n\n        /**\n         * Sets the value of the node.\n         *\n         * @param value  the value\n         * @since 3.1\n         */\n        protected void setValue(final E value) {\n            this.value = value;\n        }\n    }\n\n    /**\n     * A {@link Node} which indicates the start and end of the list and does not\n     * hold a value. The value of {@code next} is the first item in the\n     * list. The value of {@code previous} is the last item in the list.\n     */\n    transient Node<E> header;\n\n    /** The size of the list */\n    transient int size;\n\n    /** Modification count for iterators */\n    transient int modCount;\n\n    /**\n     * Constructor that does nothing (intended for deserialization).\n     * <p>\n     * If this constructor is used by a serializable subclass then the init()\n     * method must be called.\n     */\n    protected AbstractLinkedListForJava21() {\n    }\n\n    /**\n     * Constructs a list copying data from the specified collection.\n     *\n     * @param coll  the collection to copy\n     */\n    protected AbstractLinkedListForJava21(final Collection<? extends E> coll) {\n        init();\n        addAll(coll);\n    }\n\n    @Override\n    public boolean add(final E value) {\n        addLast(value);\n        return true;\n    }\n\n    @Override\n    public void add(final int index, final E value) {\n        final Node<E> node = getNode(index, true);\n        addNodeBefore(node, value);\n    }\n\n    @Override\n    public boolean addAll(final Collection<? extends E> coll) {\n        return addAll(size, coll);\n    }\n\n    @Override\n    public boolean addAll(final int index, final Collection<? extends E> coll) {\n        final Node<E> node = getNode(index, true);\n        for (final E e : coll) {\n            addNodeBefore(node, e);\n        }\n        return true;\n    }\n\n    public void addFirst(final E o) {\n        addNodeAfter(header, o);\n    }\n\n    public void addLast(final E o) {\n        addNodeBefore(header, o);\n    }\n\n    /**\n     * Inserts a new node into the list.\n     *\n     * @param nodeToInsert  new node to insert\n     * @param insertBeforeNode  node to insert before\n     * @throws NullPointerException if either node is null\n     */\n    protected void addNode(final Node<E> nodeToInsert, final Node<E> insertBeforeNode) {\n        Objects.requireNonNull(nodeToInsert, \"nodeToInsert\");\n        Objects.requireNonNull(insertBeforeNode, \"insertBeforeNode\");\n        nodeToInsert.next = insertBeforeNode;\n        nodeToInsert.previous = insertBeforeNode.previous;\n        insertBeforeNode.previous.next = nodeToInsert;\n        insertBeforeNode.previous = nodeToInsert;\n        size++;\n        modCount++;\n    }\n\n    /**\n     * Creates a new node with the specified object as its\n     * {@code value} and inserts it after {@code node}.\n     * <p>\n     * This implementation uses {@link #createNode(Object)} and\n     * {@link #addNode(AbstractLinkedListForJava21.Node,AbstractLinkedListForJava21.Node)}.\n     *\n     * @param node  node to insert after\n     * @param value  value of the newly added node\n     * @throws NullPointerException if {@code node} is null\n     */\n    protected void addNodeAfter(final Node<E> node, final E value) {\n        final Node<E> newNode = createNode(value);\n        addNode(newNode, node.next);\n    }\n\n    /**\n     * Creates a new node with the specified object as its\n     * {@code value} and inserts it before {@code node}.\n     * <p>\n     * This implementation uses {@link #createNode(Object)} and\n     * {@link #addNode(AbstractLinkedListForJava21.Node,AbstractLinkedListForJava21.Node)}.\n     *\n     * @param node  node to insert before\n     * @param value  value of the newly added node\n     * @throws NullPointerException if {@code node} is null\n     */\n    protected void addNodeBefore(final Node<E> node, final E value) {\n        final Node<E> newNode = createNode(value);\n        addNode(newNode, node);\n    }\n\n    @Override\n    public void clear() {\n        removeAllNodes();\n    }\n\n    @Override\n    public boolean contains(final Object value) {\n        return indexOf(value) != -1;\n    }\n\n    @Override\n    public boolean containsAll(final Collection<?> coll) {\n        for (final Object o : coll) {\n            if (!contains(o)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Creates a new node with previous, next and element all set to null.\n     * This implementation creates a new empty Node.\n     * Subclasses can override this to create a different class.\n     *\n     * @return  newly created node\n     */\n    protected Node<E> createHeaderNode() {\n        return new Node<>();\n    }\n\n    /**\n     * Creates a new node with the specified properties.\n     * This implementation creates a new Node with data.\n     * Subclasses can override this to create a different class.\n     *\n     * @param value  value of the new node\n     * @return a new node containing the value\n     */\n    protected Node<E> createNode(final E value) {\n        return new Node<>(value);\n    }\n\n    /**\n     * Creates an iterator for the sublist.\n     *\n     * @param subList  the sublist to get an iterator for\n     * @return a new iterator on the given sublist\n     */\n    protected Iterator<E> createSubListIterator(final LinkedSubList<E> subList) {\n        return createSubListListIterator(subList, 0);\n    }\n\n    /**\n     * Creates a list iterator for the sublist.\n     *\n     * @param subList  the sublist to get an iterator for\n     * @param fromIndex  the index to start from, relative to the sublist\n     * @return a new list iterator on the given sublist\n     */\n    protected ListIterator<E> createSubListListIterator(final LinkedSubList<E> subList, final int fromIndex) {\n        return new LinkedSubListIterator<>(subList, fromIndex);\n    }\n\n    /**\n     * Deserializes the data held in this object to the stream specified.\n     * <p>\n     * The first serializable subclass must call this method from\n     * {@code readObject}.\n     *\n     * @param inputStream  the stream to read the object from\n     * @throws IOException  if any error occurs while reading from the stream\n     * @throws ClassNotFoundException  if a class read from the stream can not be loaded\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected void doReadObject(final ObjectInputStream inputStream) throws IOException, ClassNotFoundException {\n        init();\n        final int size = inputStream.readInt();\n        for (int i = 0; i < size; i++) {\n            add((E) inputStream.readObject());\n        }\n    }\n\n    /**\n     * Serializes the data held in this object to the stream specified.\n     * <p>\n     * The first serializable subclass must call this method from\n     * {@code writeObject}.\n     *\n     * @param outputStream  the stream to write the object to\n     * @throws IOException  if anything goes wrong\n     */\n    protected void doWriteObject(final ObjectOutputStream outputStream) throws IOException {\n        // Write the size so we know how many nodes to read back\n        outputStream.writeInt(size());\n        for (final E e : this) {\n            outputStream.writeObject(e);\n        }\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof List)) {\n            return false;\n        }\n        final List<?> other = (List<?>) obj;\n        if (other.size() != size()) {\n            return false;\n        }\n        final ListIterator<?> it1 = listIterator();\n        final ListIterator<?> it2 = other.listIterator();\n        while (it1.hasNext() && it2.hasNext()) {\n            if (!Objects.equals(it1.next(), it2.next())) {\n                return false;\n            }\n        }\n        return !(it1.hasNext() || it2.hasNext());\n    }\n\n    @Override\n    public E get(final int index) {\n        final Node<E> node = getNode(index, false);\n        return node.getValue();\n    }\n\n    public E getFirst() {\n        final Node<E> node = header.next;\n        if (node == header) {\n            throw new NoSuchElementException();\n        }\n        return node.getValue();\n    }\n\n    public E getLast() {\n        final Node<E> node = header.previous;\n        if (node == header) {\n            throw new NoSuchElementException();\n        }\n        return node.getValue();\n    }\n\n    /**\n     * Gets the node at a particular index.\n     *\n     * @param index  the index, starting from 0\n     * @param endMarkerAllowed  whether or not the end marker can be returned if\n     * startIndex is set to the list's size\n     * @return the node at the given index\n     * @throws IndexOutOfBoundsException if the index is less than 0; equal to\n     * the size of the list and endMakerAllowed is false; or greater than the\n     * size of the list\n     */\n    protected Node<E> getNode(final int index, final boolean endMarkerAllowed) throws IndexOutOfBoundsException {\n        // Check the index is within the bounds\n        if (index < 0) {\n            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n                    \"index (\" + index + \") less than zero.\");\n        }\n        if (!endMarkerAllowed && index == size) {\n            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n                    \"index (\" + index + \") is the size of the list.\");\n        }\n        if (index > size) {\n            throw new IndexOutOfBoundsException(\"Couldn't get the node: \" +\n                    \"index (\" + index + \") greater than the size of the \" +\n                    \"list (\" + size + \").\");\n        }\n        // Search the list and get the node\n        Node<E> node;\n        if (index < size / 2) {\n            // Search forwards\n            node = header.next;\n            for (int currentIndex = 0; currentIndex < index; currentIndex++) {\n                node = node.next;\n            }\n        } else {\n            // Search backwards\n            node = header;\n            for (int currentIndex = size; currentIndex > index; currentIndex--) {\n                node = node.previous;\n            }\n        }\n        return node;\n    }\n\n    @Override\n    public int hashCode() {\n        int hashCode = 1;\n        for (final E e : this) {\n            hashCode = 31 * hashCode + (e == null ? 0 : e.hashCode());\n        }\n        return hashCode;\n    }\n\n    @Override\n    public int indexOf(final Object value) {\n        int i = 0;\n        for (Node<E> node = header.next; node != header; node = node.next) {\n            if (isEqualValue(node.getValue(), value)) {\n                return i;\n            }\n            i++;\n        }\n        return CollectionUtils.INDEX_NOT_FOUND;\n    }\n\n    /**\n     * The equivalent of a default constructor, broken out so it can be called\n     * by any constructor and by {@code readObject}.\n     * Subclasses which override this method should make sure they call super,\n     * so the list is initialized properly.\n     */\n    protected void init() {\n        header = createHeaderNode();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    /**\n     * Compares two values for equals.\n     * This implementation uses the equals method.\n     * Subclasses can override this to match differently.\n     *\n     * @param value1  the first value to compare, may be null\n     * @param value2  the second value to compare, may be null\n     * @return true if equal\n     */\n    protected boolean isEqualValue(final Object value1, final Object value2) {\n        return Objects.equals(value1, value2);\n    }\n\n    @Override\n    public Iterator<E> iterator() {\n        return listIterator();\n    }\n\n    @Override\n    public int lastIndexOf(final Object value) {\n        int i = size - 1;\n        for (Node<E> node = header.previous; node != header; node = node.previous) {\n            if (isEqualValue(node.getValue(), value)) {\n                return i;\n            }\n            i--;\n        }\n        return CollectionUtils.INDEX_NOT_FOUND;\n    }\n\n    @Override\n    public ListIterator<E> listIterator() {\n        return new LinkedListIterator<>(this, 0);\n    }\n\n    @Override\n    public ListIterator<E> listIterator(final int fromIndex) {\n        return new LinkedListIterator<>(this, fromIndex);\n    }\n\n    @Override\n    public E remove(final int index) {\n        final Node<E> node = getNode(index, false);\n        final E oldValue = node.getValue();\n        removeNode(node);\n        return oldValue;\n    }\n\n    @Override\n    public boolean remove(final Object value) {\n        for (Node<E> node = header.next; node != header; node = node.next) {\n            if (isEqualValue(node.getValue(), value)) {\n                removeNode(node);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * This implementation iterates over the elements of this list, checking each element in\n     * turn to see if it's contained in {@code coll}. If it's contained, it's removed\n     * from this list. As a consequence, it is advised to use a collection type for\n     * {@code coll} that provides a fast (e.g. O(1)) implementation of\n     * {@link Collection#contains(Object)}.\n     */\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        boolean modified = false;\n        final Iterator<E> it = iterator();\n        while (it.hasNext()) {\n            if (coll.contains(it.next())) {\n                it.remove();\n                modified = true;\n            }\n        }\n        return modified;\n    }\n\n    /**\n     * Removes all nodes by resetting the circular list marker.\n     */\n    protected void removeAllNodes() {\n        header.next = header;\n        header.previous = header;\n        size = 0;\n        modCount++;\n    }\n\n    public E removeFirst() {\n        final Node<E> node = header.next;\n        if (node == header) {\n            throw new NoSuchElementException();\n        }\n        final E oldValue = node.getValue();\n        removeNode(node);\n        return oldValue;\n    }\n\n    public E removeLast() {\n        final Node<E> node = header.previous;\n        if (node == header) {\n            throw new NoSuchElementException();\n        }\n        final E oldValue = node.getValue();\n        removeNode(node);\n        return oldValue;\n    }\n\n    /**\n     * Removes the specified node from the list.\n     *\n     * @param node  the node to remove\n     * @throws NullPointerException if {@code node} is null\n     */\n    protected void removeNode(final Node<E> node) {\n        Objects.requireNonNull(node, \"node\");\n        node.previous.next = node.next;\n        node.next.previous = node.previous;\n        size--;\n        modCount++;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * This implementation iterates over the elements of this list, checking each element in\n     * turn to see if it's contained in {@code coll}. If it's not contained, it's removed\n     * from this list. As a consequence, it is advised to use a collection type for\n     * {@code coll} that provides a fast (e.g. O(1)) implementation of\n     * {@link Collection#contains(Object)}.\n     */\n    @Override\n    public boolean retainAll(final Collection<?> coll) {\n        boolean modified = false;\n        final Iterator<E> it = iterator();\n        while (it.hasNext()) {\n            if (!coll.contains(it.next())) {\n                it.remove();\n                modified = true;\n            }\n        }\n        return modified;\n    }\n\n    @Override\n    public E set(final int index, final E value) {\n        final Node<E> node = getNode(index, false);\n        final E oldValue = node.getValue();\n        updateNode(node, value);\n        return oldValue;\n    }\n\n    @Override\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Gets a sublist of the main list.\n     *\n     * @param fromIndexInclusive  the index to start from\n     * @param toIndexExclusive  the index to end at\n     * @return the new sublist\n     */\n    @Override\n    public List<E> subList(final int fromIndexInclusive, final int toIndexExclusive) {\n        return new LinkedSubList<>(this, fromIndexInclusive, toIndexExclusive);\n    }\n\n    @Override\n    public Object[] toArray() {\n        return toArray(new Object[size]);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> T[] toArray(T[] array) {\n        // Extend the array if needed\n        if (array.length < size) {\n            final Class<?> componentType = array.getClass().getComponentType();\n            array = (T[]) Array.newInstance(componentType, size);\n        }\n        // Copy the values into the array\n        int i = 0;\n        for (Node<E> node = header.next; node != header; node = node.next, i++) {\n            array[i] = (T) node.getValue();\n        }\n        // Set the value after the last value to null\n        if (array.length > size) {\n            array[size] = null;\n        }\n        return array;\n    }\n\n    @Override\n    public String toString() {\n        if (isEmpty()) {\n            return \"[]\";\n        }\n        final StringBuilder buf = new StringBuilder(16 * size());\n        buf.append(CollectionUtils.DEFAULT_TOSTRING_PREFIX);\n\n        final Iterator<E> it = iterator();\n        boolean hasNext = it.hasNext();\n        while (hasNext) {\n            final Object value = it.next();\n            buf.append(value == this ? \"(this Collection)\" : value);\n            hasNext = it.hasNext();\n            if (hasNext) {\n                buf.append(\", \");\n            }\n        }\n        buf.append(CollectionUtils.DEFAULT_TOSTRING_SUFFIX);\n        return buf.toString();\n    }\n\n    /**\n     * Updates the node with a new value.\n     * This implementation sets the value on the node.\n     * Subclasses can override this to record the change.\n     *\n     * @param node  node to update\n     * @param value  new value of the node\n     */\n    protected void updateNode(final Node<E> node, final E value) {\n        node.setValue(value);\n    }\n\n}", "super_interfaces": ["List<E>"], "fields": [{"attribute_expression": "transient Node<E> header;", "docstring": "\nA {@link Node} which indicates the start and end of the list and does not\nhold a value. The value of {@code next} is the first item in the\nlist. The value of {@code previous} is the last item in the list.\n", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "Node<E>", "name": "header", "syntax_pass": true}, {"attribute_expression": "transient int size;", "docstring": " The size of the list", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}, {"attribute_expression": "transient int modCount;", "docstring": " Modification count for iterators", "modifiers": "transient", "marker_annotations": [], "non_marker_annotations": ["transient"], "comments": [], "type": "int", "name": "modCount", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter", "name": "WrappedBloomFilter", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java", "superclasses": "", "methods": ["[]WrappedBloomFilter(BloomFilter)", "[long[]]asBitMapArray()", "[int[]]asIndexArray()", "[int]cardinality()", "[int]characteristics()", "[void]clear()", "[boolean]contains(BitMapExtractor)", "[boolean]contains(BloomFilter)", "[boolean]contains(Hasher)", "[boolean]contains(IndexExtractor)", "[int]estimateIntersection(BloomFilter)", "[int]estimateN()", "[int]estimateUnion(BloomFilter)", "[Shape]getShape()", "[BloomFilter]getWrapped()", "[boolean]isFull()", "[boolean]merge(BitMapExtractor)", "[boolean]merge(BloomFilter)", "[boolean]merge(Hasher)", "[boolean]merge(IndexExtractor)", "[boolean]processBitMapPairs(BitMapExtractor,LongBiPredicate)", "[boolean]processBitMaps(LongPredicate)", "[boolean]processIndices(IntPredicate)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[]WrappedBloomFilter(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[long[]]asBitMapArray()", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[int[]]asIndexArray()", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[int]cardinality()", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[int]characteristics()", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[void]clear()", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[boolean]contains(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[boolean]contains(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[boolean]contains(Hasher)", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[boolean]contains(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[int]estimateIntersection(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[int]estimateN()", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[int]estimateUnion(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[Shape]getShape()", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[BloomFilter]getWrapped()", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[boolean]isFull()", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[boolean]merge(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[boolean]merge(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[boolean]merge(Hasher)", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[boolean]merge(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[boolean]processBitMapPairs(BitMapExtractor,LongBiPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[boolean]processBitMaps(LongPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/WrappedBloomFilter.java.WrappedBloomFilter.[boolean]processIndices(IntPredicate)"], "overrides": null, "attributes": [], "class_docstring": "\nAn abstract class to assist in implementing Bloom filter decorators.\n\n@since 4.5.0\n", "original_string": "public abstract class WrappedBloomFilter implements BloomFilter {\n    private final BloomFilter wrapped;\n\n    /**\n     * Wraps a Bloom filter.  The wrapped filter is maintained as a reference\n     * not a copy.  Changes in one will be reflected in the other.\n     * @param wrapped The Bloom filter.\n     */\n    public WrappedBloomFilter(final BloomFilter wrapped) {\n        this.wrapped = wrapped;\n    }\n\n    @Override\n    public long[] asBitMapArray() {\n        return wrapped.asBitMapArray();\n    }\n\n    @Override\n    public int[] asIndexArray() {\n        return wrapped.asIndexArray();\n    }\n\n    @Override\n    public int cardinality() {\n        return wrapped.cardinality();\n    }\n\n    @Override\n    public int characteristics() {\n        return wrapped.characteristics();\n    }\n\n    @Override\n    public void clear() {\n        wrapped.clear();\n    }\n\n    @Override\n    public boolean contains(final BitMapExtractor bitMapExtractor) {\n        return wrapped.contains(bitMapExtractor);\n    }\n\n    @Override\n    public boolean contains(final BloomFilter other) {\n        return wrapped.contains(other);\n    }\n\n    @Override\n    public boolean contains(final Hasher hasher) {\n        return wrapped.contains(hasher);\n    }\n\n    @Override\n    public boolean contains(final IndexExtractor indexExtractor) {\n        return wrapped.contains(indexExtractor);\n    }\n\n    @Override\n    public int estimateIntersection(final BloomFilter other) {\n        return wrapped.estimateIntersection(other);\n    }\n\n    @Override\n    public int estimateN() {\n        return wrapped.estimateN();\n    }\n\n    @Override\n    public int estimateUnion(final BloomFilter other) {\n        return wrapped.estimateUnion(other);\n    }\n\n    @Override\n    public Shape getShape() {\n        return wrapped.getShape();\n    }\n\n    /**\n     * Gets the wrapped BloomFilter.\n     *\n     * @return the wrapped BloomFilter.\n     */\n    protected BloomFilter getWrapped() {\n        return wrapped;\n    }\n\n    @Override\n    public boolean isFull() {\n        return wrapped.isFull();\n    }\n\n    @Override\n    public boolean merge(final BitMapExtractor bitMapExtractor) {\n        return wrapped.merge(bitMapExtractor);\n    }\n\n    @Override\n    public boolean merge(final BloomFilter other) {\n        return wrapped.merge(other);\n    }\n\n    @Override\n    public boolean merge(final Hasher hasher) {\n        return wrapped.merge(hasher);\n    }\n\n    @Override\n    public boolean merge(final IndexExtractor indexExtractor) {\n        return wrapped.merge(indexExtractor);\n    }\n\n    @Override\n    public boolean processBitMapPairs(final BitMapExtractor other, final LongBiPredicate func) {\n        return wrapped.processBitMapPairs(other, func);\n    }\n\n    @Override\n    public boolean processBitMaps(final LongPredicate predicate) {\n        return wrapped.processBitMaps(predicate);\n    }\n\n    @Override\n    public boolean processIndices(final IntPredicate predicate) {\n        return wrapped.processIndices(predicate);\n    }\n}", "super_interfaces": ["BloomFilter"], "fields": [{"attribute_expression": "private final BloomFilter wrapped;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BloomFilter", "name": "wrapped", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java.AbstractSetValuedMap", "name": "AbstractSetValuedMap", "file_path": "src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java", "superclasses": "", "methods": ["[]AbstractSetValuedMap()", "[]AbstractSetValuedMap(Map<K, ? extends Set<V>>)", "[Set<V>]createCollection()", "[Set<V>]get(K)", "[Map<K, Set<V>>]getMap()", "[Set<V>]remove(Object)", "[Set<V>]wrappedCollection(K)"], "method_uris": ["src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java.AbstractSetValuedMap.[]AbstractSetValuedMap()", "src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java.AbstractSetValuedMap.[]AbstractSetValuedMap(Map<K, ? extends Set<V>>)", "src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java.AbstractSetValuedMap.[Set<V>]createCollection()", "src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java.AbstractSetValuedMap.[Set<V>]get(K)", "src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java.AbstractSetValuedMap.[Map<K, Set<V>>]getMap()", "src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java.AbstractSetValuedMap.[Set<V>]remove(Object)", "src/main/java/org/apache/commons/collections4/multimap/AbstractSetValuedMap.java.AbstractSetValuedMap.[Set<V>]wrappedCollection(K)"], "overrides": null, "attributes": [{"original_string": "    private final class WrappedSet extends WrappedCollection implements Set<V> {\n\n        WrappedSet(final K key) {\n            super(key);\n        }\n\n        @Override\n        public boolean equals(final Object other) {\n            final Set<V> set = (Set<V>) getMapping();\n            if (set == null) {\n                return Collections.emptySet().equals(other);\n            }\n            if (!(other instanceof Set)) {\n                return false;\n            }\n            final Set<?> otherSet = (Set<?>) other;\n            return SetUtils.isEqualSet(set, otherSet);\n        }\n\n        @Override\n        public int hashCode() {\n            final Set<V> set = (Set<V>) getMapping();\n            return SetUtils.hashCodeForSet(set);\n        }\n\n    }", "definition": "    private final class WrappedSet extends WrappedCollection implements Set<V>", "class_docstring": "\nWrapped set to handle add and remove on the collection returned by\n{@code get(Object)}.\n", "name": "WrappedSet", "super_interfaces": ["Set<V>"], "superclasses": "WrappedCollection", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        WrappedSet(final K key) {\n            super(key);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "WrappedSet", "params": [{"name": "key", "type": "K"}], "body": "                                {\n            super(key);\n        }", "signature": "WrappedSet(final K key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object other) {\n            final Set<V> set = (Set<V>) getMapping();\n            if (set == null) {\n                return Collections.emptySet().equals(other);\n            }\n            if (!(other instanceof Set)) {\n                return false;\n            }\n            final Set<?> otherSet = (Set<?>) other;\n            return SetUtils.isEqualSet(set, otherSet);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "other", "type": "Object"}], "body": "                                                  {\n            final Set<V> set = (Set<V>) getMapping();\n            if (set == null) {\n                return Collections.emptySet().equals(other);\n            }\n            if (!(other instanceof Set)) {\n                return false;\n            }\n            final Set<?> otherSet = (Set<?>) other;\n            return SetUtils.isEqualSet(set, otherSet);\n        }", "signature": "@Override\n        public boolean equals(final Object other)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            final Set<V> set = (Set<V>) getMapping();\n            return SetUtils.hashCodeForSet(set);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            final Set<V> set = (Set<V>) getMapping();\n            return SetUtils.hashCodeForSet(set);\n        }", "signature": "@Override\n        public int hashCode()"}]}], "class_docstring": "\nAbstract implementation of the {@link SetValuedMap} interface to simplify the\ncreation of subclass implementations.\n<p>\nSubclasses specify a Map implementation to use as the internal storage and\nthe Set implementation to use as values.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.1\n", "original_string": "public abstract class AbstractSetValuedMap<K, V> extends AbstractMultiValuedMap<K, V>\n    implements SetValuedMap<K, V> {\n\n    /**\n     * Wrapped set to handle add and remove on the collection returned by\n     * {@code get(Object)}.\n     */\n    private final class WrappedSet extends WrappedCollection implements Set<V> {\n\n        WrappedSet(final K key) {\n            super(key);\n        }\n\n        @Override\n        public boolean equals(final Object other) {\n            final Set<V> set = (Set<V>) getMapping();\n            if (set == null) {\n                return Collections.emptySet().equals(other);\n            }\n            if (!(other instanceof Set)) {\n                return false;\n            }\n            final Set<?> otherSet = (Set<?>) other;\n            return SetUtils.isEqualSet(set, otherSet);\n        }\n\n        @Override\n        public int hashCode() {\n            final Set<V> set = (Set<V>) getMapping();\n            return SetUtils.hashCodeForSet(set);\n        }\n\n    }\n\n    /**\n     * Constructor needed for subclass serialisation.\n     */\n    protected AbstractSetValuedMap() {\n    }\n\n    /**\n     * A constructor that wraps, not copies\n     *\n     * @param map  the map to wrap, must not be null\n     * @throws NullPointerException if the map is null\n     */\n    protected AbstractSetValuedMap(final Map<K, ? extends Set<V>> map) {\n        super(map);\n    }\n\n    /**\n     * Creates a new value collection using the provided factory.\n     * @return a new set\n     */\n    @Override\n    protected abstract Set<V> createCollection();\n\n    /**\n     * Gets the set of values associated with the specified key. This would\n     * return an empty set in case the mapping is not present\n     *\n     * @param key  the key to retrieve\n     * @return the {@code Set} of values, will return an empty\n     *   {@code Set} for no mapping\n     */\n    @Override\n    public Set<V> get(final K key) {\n        return wrappedCollection(key);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected Map<K, Set<V>> getMap() {\n        return (Map<K, Set<V>>) super.getMap();\n    }\n\n    /**\n     * Removes all values associated with the specified key.\n     * <p>\n     * A subsequent {@code get(Object)} would return an empty set.\n     *\n     * @param key the key to remove values from\n     * @return the {@code Set} of values removed, will return an empty,\n     *   unmodifiable set for no mapping found.\n     */\n    @Override\n    public Set<V> remove(final Object key) {\n        return SetUtils.emptyIfNull(getMap().remove(key));\n    }\n\n    @Override\n    Set<V> wrappedCollection(final K key) {\n        return new WrappedSet(key);\n    }\n}", "super_interfaces": ["SetValuedMap<K, V>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator", "name": "AbstractMultiValuedMapDecorator", "file_path": "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java", "superclasses": "", "methods": ["[]AbstractMultiValuedMapDecorator(MultiValuedMap<K, V>)", "[Map<K, Collection<V>>]asMap()", "[void]clear()", "[boolean]containsKey(Object)", "[boolean]containsMapping(Object,Object)", "[boolean]containsValue(Object)", "[MultiValuedMap<K, V>]decorated()", "[Collection<Entry<K, V>>]entries()", "[boolean]equals(Object)", "[Collection<V>]get(K)", "[int]hashCode()", "[boolean]isEmpty()", "[MultiSet<K>]keys()", "[Set<K>]keySet()", "[MapIterator<K, V>]mapIterator()", "[boolean]put(K,V)", "[boolean]putAll(K,Iterable<? extends V>)", "[boolean]putAll(Map<? extends K, ? extends V>)", "[boolean]putAll(MultiValuedMap<? extends K, ? extends V>)", "[Collection<V>]remove(Object)", "[boolean]removeMapping(Object,Object)", "[int]size()", "[String]toString()", "[Collection<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[]AbstractMultiValuedMapDecorator(MultiValuedMap<K, V>)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[Map<K, Collection<V>>]asMap()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[void]clear()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[boolean]containsMapping(Object,Object)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[MultiValuedMap<K, V>]decorated()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[Collection<Entry<K, V>>]entries()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[Collection<V>]get(K)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[int]hashCode()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[MultiSet<K>]keys()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[MapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[boolean]put(K,V)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[boolean]putAll(K,Iterable<? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[boolean]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[boolean]putAll(MultiValuedMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[Collection<V>]remove(Object)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[boolean]removeMapping(Object,Object)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[int]size()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[String]toString()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMapDecorator.java.AbstractMultiValuedMapDecorator.[Collection<V>]values()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code MultiValuedMap} to provide additional behavior.\n<p>\nEach method call made on this {@code MultiValuedMap} is forwarded to the\ndecorated {@code MultiValuedMap}. This class is used as a framework to build\nto extensions such as synchronized and unmodifiable behavior.\n</p>\n\n@param <K> the type of key elements\n@param <V> the type of value elements\n\n@since 4.1\n", "original_string": "public abstract class AbstractMultiValuedMapDecorator<K, V>\n        implements MultiValuedMap<K, V>, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 20150612L;\n\n    /** MultiValuedMap to decorate */\n    private final MultiValuedMap<K, V> map;\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to decorate, must not be null\n     * @throws NullPointerException if the map is null\n     */\n    protected AbstractMultiValuedMapDecorator(final MultiValuedMap<K, V> map) {\n        this.map = Objects.requireNonNull(map, \"map\");\n    }\n\n    @Override\n    public Map<K, Collection<V>> asMap() {\n        return decorated().asMap();\n    }\n\n    @Override\n    public void clear() {\n        decorated().clear();\n    }\n\n    @Override\n    public boolean containsKey(final Object key) {\n        return decorated().containsKey(key);\n    }\n\n    @Override\n    public boolean containsMapping(final Object key, final Object value) {\n        return decorated().containsMapping(key, value);\n    }\n\n    @Override\n    public boolean containsValue(final Object value) {\n        return decorated().containsValue(value);\n    }\n\n    /**\n     * The decorated multivalued map.\n     *\n     * @return the map to decorate\n     */\n    protected MultiValuedMap<K, V> decorated() {\n        return map;\n    }\n\n    @Override\n    public Collection<Entry<K, V>> entries() {\n        return decorated().entries();\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        if (object == this) {\n            return true;\n        }\n        return decorated().equals(object);\n    }\n\n    @Override\n    public Collection<V> get(final K key) {\n        return decorated().get(key);\n    }\n\n    @Override\n    public int hashCode() {\n        return decorated().hashCode();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return decorated().isEmpty();\n    }\n\n    @Override\n    public MultiSet<K> keys() {\n        return decorated().keys();\n    }\n\n    @Override\n    public Set<K> keySet() {\n        return decorated().keySet();\n    }\n\n    @Override\n    public MapIterator<K, V> mapIterator() {\n        return decorated().mapIterator();\n    }\n\n    @Override\n    public boolean put(final K key, final V value) {\n        return decorated().put(key, value);\n    }\n\n    @Override\n    public boolean putAll(final K key, final Iterable<? extends V> values) {\n        return decorated().putAll(key, values);\n    }\n\n    @Override\n    public boolean putAll(final Map<? extends K, ? extends V> map) {\n        return decorated().putAll(map);\n    }\n\n    @Override\n    public boolean putAll(final MultiValuedMap<? extends K, ? extends V> map) {\n        return decorated().putAll(map);\n    }\n\n    @Override\n    public Collection<V> remove(final Object key) {\n        return decorated().remove(key);\n    }\n\n    @Override\n    public boolean removeMapping(final Object key, final Object item) {\n        return decorated().removeMapping(key, item);\n    }\n\n    @Override\n    public int size() {\n        return decorated().size();\n    }\n\n    @Override\n    public String toString() {\n        return decorated().toString();\n    }\n\n    @Override\n    public Collection<V> values() {\n        return decorated().values();\n    }\n\n}", "super_interfaces": ["MultiValuedMap<K, V>", "Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 20150612L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 20150612L", "syntax_pass": true}, {"attribute_expression": "private final MultiValuedMap<K, V> map;", "docstring": " MultiValuedMap to decorate", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "MultiValuedMap<K, V>", "name": "map", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java.AbstractListValuedMap", "name": "AbstractListValuedMap", "file_path": "src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java", "superclasses": "", "methods": ["[]AbstractListValuedMap()", "[]AbstractListValuedMap(Map<K, ? extends List<V>>)", "[List<V>]createCollection()", "[List<V>]get(K)", "[Map<K, List<V>>]getMap()", "[List<V>]remove(Object)", "[List<V>]wrappedCollection(K)"], "method_uris": ["src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java.AbstractListValuedMap.[]AbstractListValuedMap()", "src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java.AbstractListValuedMap.[]AbstractListValuedMap(Map<K, ? extends List<V>>)", "src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java.AbstractListValuedMap.[List<V>]createCollection()", "src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java.AbstractListValuedMap.[List<V>]get(K)", "src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java.AbstractListValuedMap.[Map<K, List<V>>]getMap()", "src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java.AbstractListValuedMap.[List<V>]remove(Object)", "src/main/java/org/apache/commons/collections4/multimap/AbstractListValuedMap.java.AbstractListValuedMap.[List<V>]wrappedCollection(K)"], "overrides": null, "attributes": [{"original_string": "    private final class ValuesListIterator implements ListIterator<V> {\n\n        private final K key;\n        private List<V> values;\n        private ListIterator<V> iterator;\n\n        ValuesListIterator(final K key) {\n            this.key = key;\n            this.values = ListUtils.emptyIfNull(getMap().get(key));\n            this.iterator = values.listIterator();\n        }\n\n        ValuesListIterator(final K key, final int index) {\n            this.key = key;\n            this.values = ListUtils.emptyIfNull(getMap().get(key));\n            this.iterator = values.listIterator(index);\n        }\n\n        @Override\n        public void add(final V value) {\n            if (getMap().get(key) == null) {\n                final List<V> list = createCollection();\n                getMap().put(key, list);\n                values = list;\n                iterator = list.listIterator();\n            }\n            iterator.add(value);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return iterator.hasPrevious();\n        }\n\n        @Override\n        public V next() {\n            return iterator.next();\n        }\n\n        @Override\n        public int nextIndex() {\n            return iterator.nextIndex();\n        }\n\n        @Override\n        public V previous() {\n            return iterator.previous();\n        }\n\n        @Override\n        public int previousIndex() {\n            return iterator.previousIndex();\n        }\n\n        @Override\n        public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                getMap().remove(key);\n            }\n        }\n\n        @Override\n        public void set(final V value) {\n            iterator.set(value);\n        }\n\n    }", "definition": "    private final class ValuesListIterator implements ListIterator<V>", "class_docstring": " Values ListIterator", "name": "ValuesListIterator", "super_interfaces": ["ListIterator<V>"], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private final K key;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "K", "name": "key", "syntax_pass": true}, {"attribute_expression": "private List<V> values;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List<V>", "name": "values", "syntax_pass": true}, {"attribute_expression": "private ListIterator<V> iterator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ListIterator<V>", "name": "iterator", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        ValuesListIterator(final K key) {\n            this.key = key;\n            this.values = ListUtils.emptyIfNull(getMap().get(key));\n            this.iterator = values.listIterator();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ValuesListIterator", "params": [{"name": "key", "type": "K"}], "body": "                                        {\n            this.key = key;\n            this.values = ListUtils.emptyIfNull(getMap().get(key));\n            this.iterator = values.listIterator();\n        }", "signature": "ValuesListIterator(final K key)"}, {"syntax_pass": true, "original_string": "        ValuesListIterator(final K key, final int index) {\n            this.key = key;\n            this.values = ListUtils.emptyIfNull(getMap().get(key));\n            this.iterator = values.listIterator(index);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ValuesListIterator", "params": [{"name": "key", "type": "K"}, {"name": "index", "type": "int"}], "body": "                                                         {\n            this.key = key;\n            this.values = ListUtils.emptyIfNull(getMap().get(key));\n            this.iterator = values.listIterator(index);\n        }", "signature": "ValuesListIterator(final K key, final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void add(final V value) {\n            if (getMap().get(key) == null) {\n                final List<V> list = createCollection();\n                getMap().put(key, list);\n                values = list;\n                iterator = list.listIterator();\n            }\n            iterator.add(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "value", "type": "V"}], "body": "                                       {\n            if (getMap().get(key) == null) {\n                final List<V> list = createCollection();\n                getMap().put(key, list);\n                values = list;\n                iterator = list.listIterator();\n            }\n            iterator.add(value);\n        }", "signature": "@Override\n        public void add(final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return iterator.hasNext();\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasPrevious() {\n            return iterator.hasPrevious();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasPrevious", "params": [], "body": "                                     {\n            return iterator.hasPrevious();\n        }", "signature": "@Override\n        public boolean hasPrevious()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V next() {\n            return iterator.next();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return iterator.next();\n        }", "signature": "@Override\n        public V next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int nextIndex() {\n            return iterator.nextIndex();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "nextIndex", "params": [], "body": "                               {\n            return iterator.nextIndex();\n        }", "signature": "@Override\n        public int nextIndex()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V previous() {\n            return iterator.previous();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "previous", "params": [], "body": "                            {\n            return iterator.previous();\n        }", "signature": "@Override\n        public V previous()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int previousIndex() {\n            return iterator.previousIndex();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "previousIndex", "params": [], "body": "                                   {\n            return iterator.previousIndex();\n        }", "signature": "@Override\n        public int previousIndex()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                getMap().remove(key);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            iterator.remove();\n            if (values.isEmpty()) {\n                getMap().remove(key);\n            }\n        }", "signature": "@Override\n        public void remove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void set(final V value) {\n            iterator.set(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "set", "params": [{"name": "value", "type": "V"}], "body": "                                       {\n            iterator.set(value);\n        }", "signature": "@Override\n        public void set(final V value)"}]}, {"original_string": "    private final class WrappedList extends WrappedCollection implements List<V> {\n\n        WrappedList(final K key) {\n            super(key);\n        }\n\n        @Override\n        public void add(final int index, final V value) {\n            List<V> list = getMapping();\n            if (list == null) {\n                list = createCollection();\n                getMap().put(key, list);\n            }\n            list.add(index, value);\n        }\n\n        @Override\n        public boolean addAll(final int index, final Collection<? extends V> c) {\n            List<V> list = getMapping();\n            if (list == null) {\n                list = createCollection();\n                final boolean changed = list.addAll(index, c);\n                if (changed) {\n                    getMap().put(key, list);\n                }\n                return changed;\n            }\n            return list.addAll(index, c);\n        }\n\n        @Override\n        public boolean equals(final Object other) {\n            final List<V> list = getMapping();\n            if (list == null) {\n                return Collections.emptyList().equals(other);\n            }\n            if (!(other instanceof List)) {\n                return false;\n            }\n            final List<?> otherList = (List<?>) other;\n            return ListUtils.isEqualList(list, otherList);\n        }\n\n        @Override\n        public V get(final int index) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.get(index);\n        }\n\n        @Override\n        protected List<V> getMapping() {\n            return getMap().get(key);\n        }\n\n        @Override\n        public int hashCode() {\n            final List<V> list = getMapping();\n            return ListUtils.hashCodeForList(list);\n        }\n\n        @Override\n        public int indexOf(final Object o) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.indexOf(o);\n        }\n\n        @Override\n        public int lastIndexOf(final Object o) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.lastIndexOf(o);\n        }\n\n        @Override\n        public ListIterator<V> listIterator() {\n            return new ValuesListIterator(key);\n        }\n\n        @Override\n        public ListIterator<V> listIterator(final int index) {\n            return new ValuesListIterator(key, index);\n        }\n\n        @Override\n        public V remove(final int index) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            final V value = list.remove(index);\n            if (list.isEmpty()) {\n                AbstractListValuedMap.this.remove(key);\n            }\n            return value;\n        }\n\n        @Override\n        public V set(final int index, final V value) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.set(index, value);\n        }\n\n        @Override\n        public List<V> subList(final int fromIndex, final int toIndex) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.subList(fromIndex, toIndex);\n        }\n\n    }", "definition": "    private final class WrappedList extends WrappedCollection implements List<V>", "class_docstring": "\nWrapped list to handle add and remove on the list returned by get(object)\n", "name": "WrappedList", "super_interfaces": ["List<V>"], "superclasses": "WrappedCollection", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        WrappedList(final K key) {\n            super(key);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "WrappedList", "params": [{"name": "key", "type": "K"}], "body": "                                 {\n            super(key);\n        }", "signature": "WrappedList(final K key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void add(final int index, final V value) {\n            List<V> list = getMapping();\n            if (list == null) {\n                list = createCollection();\n                getMap().put(key, list);\n            }\n            list.add(index, value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "add", "params": [{"name": "index", "type": "int"}, {"name": "value", "type": "V"}], "body": "                                                        {\n            List<V> list = getMapping();\n            if (list == null) {\n                list = createCollection();\n                getMap().put(key, list);\n            }\n            list.add(index, value);\n        }", "signature": "@Override\n        public void add(final int index, final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean addAll(final int index, final Collection<? extends V> c) {\n            List<V> list = getMapping();\n            if (list == null) {\n                list = createCollection();\n                final boolean changed = list.addAll(index, c);\n                if (changed) {\n                    getMap().put(key, list);\n                }\n                return changed;\n            }\n            return list.addAll(index, c);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "addAll", "params": [{"name": "index", "type": "int"}, {"name": "c", "type": "Collection<? extends V>"}], "body": "                                                                                {\n            List<V> list = getMapping();\n            if (list == null) {\n                list = createCollection();\n                final boolean changed = list.addAll(index, c);\n                if (changed) {\n                    getMap().put(key, list);\n                }\n                return changed;\n            }\n            return list.addAll(index, c);\n        }", "signature": "@Override\n        public boolean addAll(final int index, final Collection<? extends V> c)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object other) {\n            final List<V> list = getMapping();\n            if (list == null) {\n                return Collections.emptyList().equals(other);\n            }\n            if (!(other instanceof List)) {\n                return false;\n            }\n            final List<?> otherList = (List<?>) other;\n            return ListUtils.isEqualList(list, otherList);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "other", "type": "Object"}], "body": "                                                  {\n            final List<V> list = getMapping();\n            if (list == null) {\n                return Collections.emptyList().equals(other);\n            }\n            if (!(other instanceof List)) {\n                return false;\n            }\n            final List<?> otherList = (List<?>) other;\n            return ListUtils.isEqualList(list, otherList);\n        }", "signature": "@Override\n        public boolean equals(final Object other)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V get(final int index) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.get(index);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "get", "params": [{"name": "index", "type": "int"}], "body": "                                      {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.get(index);\n        }", "signature": "@Override\n        public V get(final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected List<V> getMapping() {\n            return getMap().get(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "List<V>", "classes": []}, "name": "getMapping", "params": [], "body": "                                       {\n            return getMap().get(key);\n        }", "signature": "@Override\n        protected List<V> getMapping()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            final List<V> list = getMapping();\n            return ListUtils.hashCodeForList(list);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            final List<V> list = getMapping();\n            return ListUtils.hashCodeForList(list);\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int indexOf(final Object o) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.indexOf(o);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "indexOf", "params": [{"name": "o", "type": "Object"}], "body": "                                           {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.indexOf(o);\n        }", "signature": "@Override\n        public int indexOf(final Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int lastIndexOf(final Object o) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.lastIndexOf(o);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "lastIndexOf", "params": [{"name": "o", "type": "Object"}], "body": "                                               {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.lastIndexOf(o);\n        }", "signature": "@Override\n        public int lastIndexOf(final Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public ListIterator<V> listIterator() {\n            return new ValuesListIterator(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListIterator<V>", "classes": []}, "name": "listIterator", "params": [], "body": "                                              {\n            return new ValuesListIterator(key);\n        }", "signature": "@Override\n        public ListIterator<V> listIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public ListIterator<V> listIterator(final int index) {\n            return new ValuesListIterator(key, index);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "ListIterator<V>", "classes": []}, "name": "listIterator", "params": [{"name": "index", "type": "int"}], "body": "                                                             {\n            return new ValuesListIterator(key, index);\n        }", "signature": "@Override\n        public ListIterator<V> listIterator(final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V remove(final int index) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            final V value = list.remove(index);\n            if (list.isEmpty()) {\n                AbstractListValuedMap.this.remove(key);\n            }\n            return value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "remove", "params": [{"name": "index", "type": "int"}], "body": "                                         {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            final V value = list.remove(index);\n            if (list.isEmpty()) {\n                AbstractListValuedMap.this.remove(key);\n            }\n            return value;\n        }", "signature": "@Override\n        public V remove(final int index)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V set(final int index, final V value) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.set(index, value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "set", "params": [{"name": "index", "type": "int"}, {"name": "value", "type": "V"}], "body": "                                                     {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.set(index, value);\n        }", "signature": "@Override\n        public V set(final int index, final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public List<V> subList(final int fromIndex, final int toIndex) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.subList(fromIndex, toIndex);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "List<V>", "classes": []}, "name": "subList", "params": [{"name": "fromIndex", "type": "int"}, {"name": "toIndex", "type": "int"}], "body": "                                                                       {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.subList(fromIndex, toIndex);\n        }", "signature": "@Override\n        public List<V> subList(final int fromIndex, final int toIndex)"}]}], "class_docstring": "\nAbstract implementation of the {@link ListValuedMap} interface to simplify\nthe creation of subclass implementations.\n<p>\nSubclasses specify a Map implementation to use as the internal storage and\nthe List implementation to use as values.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.1\n", "original_string": "public abstract class AbstractListValuedMap<K, V> extends AbstractMultiValuedMap<K, V>\n        implements ListValuedMap<K, V> {\n\n    /** Values ListIterator */\n    private final class ValuesListIterator implements ListIterator<V> {\n\n        private final K key;\n        private List<V> values;\n        private ListIterator<V> iterator;\n\n        ValuesListIterator(final K key) {\n            this.key = key;\n            this.values = ListUtils.emptyIfNull(getMap().get(key));\n            this.iterator = values.listIterator();\n        }\n\n        ValuesListIterator(final K key, final int index) {\n            this.key = key;\n            this.values = ListUtils.emptyIfNull(getMap().get(key));\n            this.iterator = values.listIterator(index);\n        }\n\n        @Override\n        public void add(final V value) {\n            if (getMap().get(key) == null) {\n                final List<V> list = createCollection();\n                getMap().put(key, list);\n                values = list;\n                iterator = list.listIterator();\n            }\n            iterator.add(value);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public boolean hasPrevious() {\n            return iterator.hasPrevious();\n        }\n\n        @Override\n        public V next() {\n            return iterator.next();\n        }\n\n        @Override\n        public int nextIndex() {\n            return iterator.nextIndex();\n        }\n\n        @Override\n        public V previous() {\n            return iterator.previous();\n        }\n\n        @Override\n        public int previousIndex() {\n            return iterator.previousIndex();\n        }\n\n        @Override\n        public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                getMap().remove(key);\n            }\n        }\n\n        @Override\n        public void set(final V value) {\n            iterator.set(value);\n        }\n\n    }\n\n    /**\n     * Wrapped list to handle add and remove on the list returned by get(object)\n     */\n    private final class WrappedList extends WrappedCollection implements List<V> {\n\n        WrappedList(final K key) {\n            super(key);\n        }\n\n        @Override\n        public void add(final int index, final V value) {\n            List<V> list = getMapping();\n            if (list == null) {\n                list = createCollection();\n                getMap().put(key, list);\n            }\n            list.add(index, value);\n        }\n\n        @Override\n        public boolean addAll(final int index, final Collection<? extends V> c) {\n            List<V> list = getMapping();\n            if (list == null) {\n                list = createCollection();\n                final boolean changed = list.addAll(index, c);\n                if (changed) {\n                    getMap().put(key, list);\n                }\n                return changed;\n            }\n            return list.addAll(index, c);\n        }\n\n        @Override\n        public boolean equals(final Object other) {\n            final List<V> list = getMapping();\n            if (list == null) {\n                return Collections.emptyList().equals(other);\n            }\n            if (!(other instanceof List)) {\n                return false;\n            }\n            final List<?> otherList = (List<?>) other;\n            return ListUtils.isEqualList(list, otherList);\n        }\n\n        @Override\n        public V get(final int index) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.get(index);\n        }\n\n        @Override\n        protected List<V> getMapping() {\n            return getMap().get(key);\n        }\n\n        @Override\n        public int hashCode() {\n            final List<V> list = getMapping();\n            return ListUtils.hashCodeForList(list);\n        }\n\n        @Override\n        public int indexOf(final Object o) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.indexOf(o);\n        }\n\n        @Override\n        public int lastIndexOf(final Object o) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.lastIndexOf(o);\n        }\n\n        @Override\n        public ListIterator<V> listIterator() {\n            return new ValuesListIterator(key);\n        }\n\n        @Override\n        public ListIterator<V> listIterator(final int index) {\n            return new ValuesListIterator(key, index);\n        }\n\n        @Override\n        public V remove(final int index) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            final V value = list.remove(index);\n            if (list.isEmpty()) {\n                AbstractListValuedMap.this.remove(key);\n            }\n            return value;\n        }\n\n        @Override\n        public V set(final int index, final V value) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.set(index, value);\n        }\n\n        @Override\n        public List<V> subList(final int fromIndex, final int toIndex) {\n            final List<V> list = ListUtils.emptyIfNull(getMapping());\n            return list.subList(fromIndex, toIndex);\n        }\n\n    }\n\n    /**\n     * Constructor needed for subclass serialisation.\n     */\n    protected AbstractListValuedMap() {\n    }\n\n    /**\n     * A constructor that wraps, not copies\n     *\n     * @param map  the map to wrap, must not be null\n     * @throws NullPointerException if the map is null\n     */\n    protected AbstractListValuedMap(final Map<K, ? extends List<V>> map) {\n        super(map);\n    }\n\n    /**\n     * Creates a new value collection using the provided factory.\n     * @return a new list\n     */\n    @Override\n    protected abstract List<V> createCollection();\n\n    /**\n     * Gets the list of values associated with the specified key. This would\n     * return an empty list in case the mapping is not present\n     *\n     * @param key  the key to retrieve\n     * @return the {@code List} of values, will return an empty {@link List} for no mapping\n     */\n    @Override\n    public List<V> get(final K key) {\n        return wrappedCollection(key);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected Map<K, List<V>> getMap() {\n        return (Map<K, List<V>>) super.getMap();\n    }\n\n    /**\n     * Removes all values associated with the specified key.\n     * <p>\n     * A subsequent {@code get(Object)} would return an empty list.\n     *\n     * @param key  the key to remove values from\n     * @return the {@code List} of values removed, will return an empty,\n     *   unmodifiable list for no mapping found.\n     */\n    @Override\n    public List<V> remove(final Object key) {\n        return ListUtils.emptyIfNull(getMap().remove(key));\n    }\n\n    @Override\n    List<V> wrappedCollection(final K key) {\n        return new WrappedList(key);\n    }\n\n}", "super_interfaces": ["ListValuedMap<K, V>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap", "name": "AbstractMultiValuedMap", "file_path": "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java", "superclasses": "", "methods": ["[]AbstractMultiValuedMap()", "[]AbstractMultiValuedMap(Map<K, ? extends Collection<V>>)", "[Map<K, Collection<V>>]asMap()", "[void]clear()", "[boolean]containsKey(Object)", "[boolean]containsMapping(Object,Object)", "[boolean]containsValue(Object)", "[Collection<V>]createCollection()", "[void]doReadObject(ObjectInputStream)", "[void]doWriteObject(ObjectOutputStream)", "[Collection<Entry<K, V>>]entries()", "[boolean]equals(Object)", "[Collection<V>]get(K)", "[Map<K, ? extends Collection<V>>]getMap()", "[int]hashCode()", "[boolean]isEmpty()", "[MultiSet<K>]keys()", "[Set<K>]keySet()", "[MapIterator<K, V>]mapIterator()", "[boolean]put(K,V)", "[boolean]putAll(K,Iterable<? extends V>)", "[boolean]putAll(Map<? extends K, ? extends V>)", "[boolean]putAll(MultiValuedMap<? extends K, ? extends V>)", "[Collection<V>]remove(Object)", "[boolean]removeMapping(Object,Object)", "[void]setMap(Map<K, ? extends Collection<V>>)", "[int]size()", "[String]toString()", "[Collection<V>]values()", "[Collection<V>]wrappedCollection(K)"], "method_uris": ["src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[]AbstractMultiValuedMap()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[]AbstractMultiValuedMap(Map<K, ? extends Collection<V>>)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[Map<K, Collection<V>>]asMap()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[void]clear()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[boolean]containsMapping(Object,Object)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[Collection<V>]createCollection()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[void]doReadObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[void]doWriteObject(ObjectOutputStream)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[Collection<Entry<K, V>>]entries()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[Collection<V>]get(K)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[Map<K, ? extends Collection<V>>]getMap()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[int]hashCode()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[MultiSet<K>]keys()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[MapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[boolean]put(K,V)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[boolean]putAll(K,Iterable<? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[boolean]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[boolean]putAll(MultiValuedMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[Collection<V>]remove(Object)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[boolean]removeMapping(Object,Object)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[void]setMap(Map<K, ? extends Collection<V>>)", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[int]size()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[String]toString()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[Collection<V>]values()", "src/main/java/org/apache/commons/collections4/multimap/AbstractMultiValuedMap.java.AbstractMultiValuedMap.[Collection<V>]wrappedCollection(K)"], "overrides": null, "attributes": [{"original_string": "    private final class AsMap extends AbstractMap<K, Collection<V>> {\n        final class AsMapEntrySet extends AbstractSet<Map.Entry<K, Collection<V>>> {\n\n            @Override\n            public void clear() {\n                AsMap.this.clear();\n            }\n\n            @Override\n            public boolean contains(final Object o) {\n                return map.entrySet().contains(o);\n            }\n\n            @Override\n            public Iterator<Map.Entry<K, Collection<V>>> iterator() {\n                return new AsMapEntrySetIterator(map.entrySet().iterator());\n            }\n\n            @Override\n            public boolean remove(final Object o) {\n                if (!contains(o)) {\n                    return false;\n                }\n                final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;\n                AbstractMultiValuedMap.this.remove(entry.getKey());\n                return true;\n            }\n\n            @Override\n            public int size() {\n                return AsMap.this.size();\n            }\n        }\n\n        /**\n         * EntrySet iterator for the asMap view.\n         */\n        final class AsMapEntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, Collection<V>>> {\n\n            AsMapEntrySetIterator(final Iterator<Map.Entry<K, Collection<V>>> iterator) {\n                super(iterator);\n            }\n\n            @Override\n            public Map.Entry<K, Collection<V>> next() {\n                final Map.Entry<K, Collection<V>> entry = super.next();\n                final K key = entry.getKey();\n                return new UnmodifiableMapEntry<>(key, wrappedCollection(key));\n            }\n        }\n\n        final transient Map<K, Collection<V>> map;\n\n        AsMap(final Map<K, Collection<V>> map) {\n            this.map = map;\n        }\n\n        @Override\n        public void clear() {\n            AbstractMultiValuedMap.this.clear();\n        }\n\n        @Override\n        public boolean containsKey(final Object key) {\n            return map.containsKey(key);\n        }\n\n        @Override\n        public Set<Map.Entry<K, Collection<V>>> entrySet() {\n            return new AsMapEntrySet();\n        }\n\n        @Override\n        public boolean equals(final Object object) {\n            return this == object || map.equals(object);\n        }\n\n        @Override\n        public Collection<V> get(final Object key) {\n            final Collection<V> collection = map.get(key);\n            if (collection == null) {\n                return null;\n            }\n            @SuppressWarnings(\"unchecked\")\n            final K k = (K) key;\n            return wrappedCollection(k);\n        }\n\n        @Override\n        public int hashCode() {\n            return map.hashCode();\n        }\n\n        @Override\n        public Set<K> keySet() {\n            return AbstractMultiValuedMap.this.keySet();\n        }\n\n        @Override\n        public Collection<V> remove(final Object key) {\n            final Collection<V> collection = map.remove(key);\n            if (collection == null) {\n                return null;\n            }\n\n            final Collection<V> output = createCollection();\n            output.addAll(collection);\n            collection.clear();\n            return output;\n        }\n\n        @Override\n        public int size() {\n            return map.size();\n        }\n\n        @Override\n        public String toString() {\n            return map.toString();\n        }\n    }", "definition": "    private final class AsMap extends AbstractMap<K, Collection<V>>", "class_docstring": "\nInner class that provides the AsMap view.\n", "name": "AsMap", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "final transient Map<K, Collection<V>> map;", "docstring": "", "modifiers": "final transient", "marker_annotations": [], "non_marker_annotations": ["final", "transient"], "comments": [], "type": "Map<K, Collection<V>>", "name": "map", "syntax_pass": true}], "classes": [{"original_string": "        final class AsMapEntrySet extends AbstractSet<Map.Entry<K, Collection<V>>> {\n\n            @Override\n            public void clear() {\n                AsMap.this.clear();\n            }\n\n            @Override\n            public boolean contains(final Object o) {\n                return map.entrySet().contains(o);\n            }\n\n            @Override\n            public Iterator<Map.Entry<K, Collection<V>>> iterator() {\n                return new AsMapEntrySetIterator(map.entrySet().iterator());\n            }\n\n            @Override\n            public boolean remove(final Object o) {\n                if (!contains(o)) {\n                    return false;\n                }\n                final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;\n                AbstractMultiValuedMap.this.remove(entry.getKey());\n                return true;\n            }\n\n            @Override\n            public int size() {\n                return AsMap.this.size();\n            }\n        }", "definition": "        final class AsMapEntrySet extends AbstractSet<Map.Entry<K, Collection<V>>>", "class_docstring": "", "name": "AsMapEntrySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "            @Override\n            public void clear() {\n                AsMap.this.clear();\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                                {\n                AsMap.this.clear();\n            }", "signature": "@Override\n            public void clear()"}, {"syntax_pass": true, "original_string": "            @Override\n            public boolean contains(final Object o) {\n                return map.entrySet().contains(o);\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "o", "type": "Object"}], "body": "                                                    {\n                return map.entrySet().contains(o);\n            }", "signature": "@Override\n            public boolean contains(final Object o)"}, {"syntax_pass": true, "original_string": "            @Override\n            public Iterator<Map.Entry<K, Collection<V>>> iterator() {\n                return new AsMapEntrySetIterator(map.entrySet().iterator());\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Map.Entry<K, Collection<V>>>", "classes": []}, "name": "iterator", "params": [], "body": "                                                                    {\n                return new AsMapEntrySetIterator(map.entrySet().iterator());\n            }", "signature": "@Override\n            public Iterator<Map.Entry<K, Collection<V>>> iterator()"}, {"syntax_pass": true, "original_string": "            @Override\n            public boolean remove(final Object o) {\n                if (!contains(o)) {\n                    return false;\n                }\n                final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;\n                AbstractMultiValuedMap.this.remove(entry.getKey());\n                return true;\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "o", "type": "Object"}], "body": "                                                  {\n                if (!contains(o)) {\n                    return false;\n                }\n                final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;\n                AbstractMultiValuedMap.this.remove(entry.getKey());\n                return true;\n            }", "signature": "@Override\n            public boolean remove(final Object o)"}, {"syntax_pass": true, "original_string": "            @Override\n            public int size() {\n                return AsMap.this.size();\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                              {\n                return AsMap.this.size();\n            }", "signature": "@Override\n            public int size()"}]}, {"original_string": "        final class AsMapEntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, Collection<V>>> {\n\n            AsMapEntrySetIterator(final Iterator<Map.Entry<K, Collection<V>>> iterator) {\n                super(iterator);\n            }\n\n            @Override\n            public Map.Entry<K, Collection<V>> next() {\n                final Map.Entry<K, Collection<V>> entry = super.next();\n                final K key = entry.getKey();\n                return new UnmodifiableMapEntry<>(key, wrappedCollection(key));\n            }\n        }", "definition": "        final class AsMapEntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, Collection<V>>>", "class_docstring": "\nEntrySet iterator for the asMap view.\n", "name": "AsMapEntrySetIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "            AsMapEntrySetIterator(final Iterator<Map.Entry<K, Collection<V>>> iterator) {\n                super(iterator);\n            }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AsMapEntrySetIterator", "params": [{"name": "iterator", "type": "Iterator<Map.Entry<K, Collection<V>>>"}], "body": "                                                                                        {\n                super(iterator);\n            }", "signature": "AsMapEntrySetIterator(final Iterator<Map.Entry<K, Collection<V>>> iterator)"}, {"syntax_pass": true, "original_string": "            @Override\n            public Map.Entry<K, Collection<V>> next() {\n                final Map.Entry<K, Collection<V>> entry = super.next();\n                final K key = entry.getKey();\n                return new UnmodifiableMapEntry<>(key, wrappedCollection(key));\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Map.Entry<K, Collection<V>>", "classes": []}, "name": "next", "params": [], "body": "                                                      {\n                final Map.Entry<K, Collection<V>> entry = super.next();\n                final K key = entry.getKey();\n                return new UnmodifiableMapEntry<>(key, wrappedCollection(key));\n            }", "signature": "@Override\n            public Map.Entry<K, Collection<V>> next()"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        AsMap(final Map<K, Collection<V>> map) {\n            this.map = map;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "AsMap", "params": [{"name": "map", "type": "Map<K, Collection<V>>"}], "body": "                                               {\n            this.map = map;\n        }", "signature": "AsMap(final Map<K, Collection<V>> map)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            AbstractMultiValuedMap.this.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            AbstractMultiValuedMap.this.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsKey(final Object key) {\n            return map.containsKey(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsKey", "params": [{"name": "key", "type": "Object"}], "body": "                                                     {\n            return map.containsKey(key);\n        }", "signature": "@Override\n        public boolean containsKey(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<Map.Entry<K, Collection<V>>> entrySet() {\n            return new AsMapEntrySet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<Map.Entry<K, Collection<V>>>", "classes": []}, "name": "entrySet", "params": [], "body": "                                                           {\n            return new AsMapEntrySet();\n        }", "signature": "@Override\n        public Set<Map.Entry<K, Collection<V>>> entrySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object object) {\n            return this == object || map.equals(object);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "object", "type": "Object"}], "body": "                                                   {\n            return this == object || map.equals(object);\n        }", "signature": "@Override\n        public boolean equals(final Object object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<V> get(final Object key) {\n            final Collection<V> collection = map.get(key);\n            if (collection == null) {\n                return null;\n            }\n            @SuppressWarnings(\"unchecked\")\n            final K k = (K) key;\n            return wrappedCollection(k);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<V>", "classes": []}, "name": "get", "params": [{"name": "key", "type": "Object"}], "body": "                                                   {\n            final Collection<V> collection = map.get(key);\n            if (collection == null) {\n                return null;\n            }\n            @SuppressWarnings(\"unchecked\")\n            final K k = (K) key;\n            return wrappedCollection(k);\n        }", "signature": "@Override\n        public Collection<V> get(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return map.hashCode();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return map.hashCode();\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Set<K> keySet() {\n            return AbstractMultiValuedMap.this.keySet();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Set<K>", "classes": []}, "name": "keySet", "params": [], "body": "                               {\n            return AbstractMultiValuedMap.this.keySet();\n        }", "signature": "@Override\n        public Set<K> keySet()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Collection<V> remove(final Object key) {\n            final Collection<V> collection = map.remove(key);\n            if (collection == null) {\n                return null;\n            }\n\n            final Collection<V> output = createCollection();\n            output.addAll(collection);\n            collection.clear();\n            return output;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<V>", "classes": []}, "name": "remove", "params": [{"name": "key", "type": "Object"}], "body": "                                                      {\n            final Collection<V> collection = map.remove(key);\n            if (collection == null) {\n                return null;\n            }\n\n            final Collection<V> output = createCollection();\n            output.addAll(collection);\n            collection.clear();\n            return output;\n        }", "signature": "@Override\n        public Collection<V> remove(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return map.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return map.size();\n        }", "signature": "@Override\n        public int size()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return map.toString();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return map.toString();\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    private final class EntryValues extends AbstractCollection<Entry<K, V>> {\n\n        @Override\n        public Iterator<Entry<K, V>> iterator() {\n            return new LazyIteratorChain<Entry<K, V>>() {\n\n                final Collection<K> keysCol = new ArrayList<>(getMap().keySet());\n                final Iterator<K> keyIterator = keysCol.iterator();\n\n                @Override\n                protected Iterator<? extends Entry<K, V>> nextIterator(final int count) {\n                    if (!keyIterator.hasNext()) {\n                        return null;\n                    }\n                    final K key = keyIterator.next();\n                    final Transformer<V, Entry<K, V>> entryTransformer = input -> new MultiValuedMapEntry(key, input);\n                    return new TransformIterator<>(new ValuesIterator(key), entryTransformer);\n                }\n            };\n        }\n\n        @Override\n        public int size() {\n            return AbstractMultiValuedMap.this.size();\n        }\n\n    }", "definition": "    private final class EntryValues extends AbstractCollection<Entry<K, V>>", "class_docstring": "\nInner class that provides the Entry<K, V> view\n", "name": "EntryValues", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public Iterator<Entry<K, V>> iterator() {\n            return new LazyIteratorChain<Entry<K, V>>() {\n\n                final Collection<K> keysCol = new ArrayList<>(getMap().keySet());\n                final Iterator<K> keyIterator = keysCol.iterator();\n\n                @Override\n                protected Iterator<? extends Entry<K, V>> nextIterator(final int count) {\n                    if (!keyIterator.hasNext()) {\n                        return null;\n                    }\n                    final K key = keyIterator.next();\n                    final Transformer<V, Entry<K, V>> entryTransformer = input -> new MultiValuedMapEntry(key, input);\n                    return new TransformIterator<>(new ValuesIterator(key), entryTransformer);\n                }\n            };\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Entry<K, V>>", "classes": []}, "name": "iterator", "params": [], "body": "                                                {\n            return new LazyIteratorChain<Entry<K, V>>() {\n\n                final Collection<K> keysCol = new ArrayList<>(getMap().keySet());\n                final Iterator<K> keyIterator = keysCol.iterator();\n\n                @Override\n                protected Iterator<? extends Entry<K, V>> nextIterator(final int count) {\n                    if (!keyIterator.hasNext()) {\n                        return null;\n                    }\n                    final K key = keyIterator.next();\n                    final Transformer<V, Entry<K, V>> entryTransformer = input -> new MultiValuedMapEntry(key, input);\n                    return new TransformIterator<>(new ValuesIterator(key), entryTransformer);\n                }\n            };\n        }", "signature": "@Override\n        public Iterator<Entry<K, V>> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return AbstractMultiValuedMap.this.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return AbstractMultiValuedMap.this.size();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    private final class KeysMultiSet extends AbstractMultiSet<K> {\n\n        private final class MapEntryTransformer implements Transformer<Map.Entry<K, Collection<V>>, MultiSet.Entry<K>> {\n\n            @Override\n            public MultiSet.Entry<K> transform(final Map.Entry<K, Collection<V>> mapEntry) {\n                return new AbstractMultiSet.AbstractEntry<K>() {\n\n                    @Override\n                    public int getCount() {\n                        return mapEntry.getValue().size();\n                    }\n\n                    @Override\n                    public K getElement() {\n                        return mapEntry.getKey();\n                    }\n                };\n            }\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            return getMap().containsKey(o);\n        }\n\n        @Override\n        protected Iterator<MultiSet.Entry<K>> createEntrySetIterator() {\n            final MapEntryTransformer transformer = new MapEntryTransformer();\n            return IteratorUtils.transformedIterator(map.entrySet().iterator(), transformer);\n        }\n\n        @Override\n        public int getCount(final Object object) {\n            int count = 0;\n            final Collection<V> col = AbstractMultiValuedMap.this.getMap().get(object);\n            if (col != null) {\n                count = col.size();\n            }\n            return count;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return getMap().isEmpty();\n        }\n\n        @Override\n        public int size() {\n            return AbstractMultiValuedMap.this.size();\n        }\n\n        @Override\n        protected int uniqueElements() {\n            return getMap().size();\n        }\n    }", "definition": "    private final class KeysMultiSet extends AbstractMultiSet<K>", "class_docstring": "\nInner class that provides a MultiSet<K> keys view.\n", "name": "KeysMultiSet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": [{"original_string": "        private final class MapEntryTransformer implements Transformer<Map.Entry<K, Collection<V>>, MultiSet.Entry<K>> {\n\n            @Override\n            public MultiSet.Entry<K> transform(final Map.Entry<K, Collection<V>> mapEntry) {\n                return new AbstractMultiSet.AbstractEntry<K>() {\n\n                    @Override\n                    public int getCount() {\n                        return mapEntry.getValue().size();\n                    }\n\n                    @Override\n                    public K getElement() {\n                        return mapEntry.getKey();\n                    }\n                };\n            }\n        }", "definition": "        private final class MapEntryTransformer implements Transformer<Map.Entry<K, Collection<V>>, MultiSet.Entry<K>>", "class_docstring": "", "name": "MapEntryTransformer", "super_interfaces": ["Transformer<Map.Entry<K, Collection<V>>, MultiSet.Entry<K>>"], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "            @Override\n            public MultiSet.Entry<K> transform(final Map.Entry<K, Collection<V>> mapEntry) {\n                return new AbstractMultiSet.AbstractEntry<K>() {\n\n                    @Override\n                    public int getCount() {\n                        return mapEntry.getValue().size();\n                    }\n\n                    @Override\n                    public K getElement() {\n                        return mapEntry.getKey();\n                    }\n                };\n            }", "docstring": "", "attributes": {"modifiers": "@Override\n            public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "MultiSet.Entry<K>", "classes": []}, "name": "transform", "params": [{"name": "mapEntry", "type": "Map.Entry<K, Collection<V>>"}], "body": "                                                                                           {\n                return new AbstractMultiSet.AbstractEntry<K>() {\n\n                    @Override\n                    public int getCount() {\n                        return mapEntry.getValue().size();\n                    }\n\n                    @Override\n                    public K getElement() {\n                        return mapEntry.getKey();\n                    }\n                };\n            }", "signature": "@Override\n            public MultiSet.Entry<K> transform(final Map.Entry<K, Collection<V>> mapEntry)"}]}]}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object o) {\n            return getMap().containsKey(o);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "o", "type": "Object"}], "body": "                                                {\n            return getMap().containsKey(o);\n        }", "signature": "@Override\n        public boolean contains(final Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        protected Iterator<MultiSet.Entry<K>> createEntrySetIterator() {\n            final MapEntryTransformer transformer = new MapEntryTransformer();\n            return IteratorUtils.transformedIterator(map.entrySet().iterator(), transformer);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Iterator<MultiSet.Entry<K>>", "classes": []}, "name": "createEntrySetIterator", "params": [], "body": "                                                                       {\n            final MapEntryTransformer transformer = new MapEntryTransformer();\n            return IteratorUtils.transformedIterator(map.entrySet().iterator(), transformer);\n        }", "signature": "@Override\n        protected Iterator<MultiSet.Entry<K>> createEntrySetIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int getCount(final Object object) {\n            int count = 0;\n            final Collection<V> col = AbstractMultiValuedMap.this.getMap().get(object);\n            if (col != null) {\n                count = col.size();\n            }\n            return count;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getCount", "params": [{"name": "object", "type": "Object"}], "body": "                                                 {\n            int count = 0;\n            final Collection<V> col = AbstractMultiValuedMap.this.getMap().get(object);\n            if (col != null) {\n                count = col.size();\n            }\n            return count;\n        }", "signature": "@Override\n        public int getCount(final Object object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isEmpty() {\n            return getMap().isEmpty();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [], "body": "                                 {\n            return getMap().isEmpty();\n        }", "signature": "@Override\n        public boolean isEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return AbstractMultiValuedMap.this.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return AbstractMultiValuedMap.this.size();\n        }", "signature": "@Override\n        public int size()"}, {"syntax_pass": true, "original_string": "        @Override\n        protected int uniqueElements() {\n            return getMap().size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        protected", "marker_annotations": ["@Override"], "non_marker_annotations": ["protected"], "comments": [], "return_type": "int", "classes": []}, "name": "uniqueElements", "params": [], "body": "                                       {\n            return getMap().size();\n        }", "signature": "@Override\n        protected int uniqueElements()"}]}, {"original_string": "    private final class MultiValuedMapEntry extends AbstractMapEntry<K, V> {\n\n        MultiValuedMapEntry(final K key, final V value) {\n            super(key, value);\n        }\n\n        @Override\n        public V setValue(final V value) {\n            throw new UnsupportedOperationException();\n        }\n\n    }", "definition": "    private final class MultiValuedMapEntry extends AbstractMapEntry<K, V>", "class_docstring": "\nInner class for MultiValuedMap Entries.\n", "name": "MultiValuedMapEntry", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        MultiValuedMapEntry(final K key, final V value) {\n            super(key, value);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MultiValuedMapEntry", "params": [{"name": "key", "type": "K"}, {"name": "value", "type": "V"}], "body": "                                                        {\n            super(key, value);\n        }", "signature": "MultiValuedMapEntry(final K key, final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            throw new UnsupportedOperationException();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            throw new UnsupportedOperationException();\n        }", "signature": "@Override\n        public V setValue(final V value)"}]}, {"original_string": "    private final class MultiValuedMapIterator implements MapIterator<K, V> {\n\n        private final Iterator<Entry<K, V>> it;\n\n        private Entry<K, V> current;\n\n        MultiValuedMapIterator() {\n            this.it = AbstractMultiValuedMap.this.entries().iterator();\n        }\n\n        @Override\n        public K getKey() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getValue();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return it.hasNext();\n        }\n\n        @Override\n        public K next() {\n            current = it.next();\n            return current.getKey();\n        }\n\n        @Override\n        public void remove() {\n            it.remove();\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.setValue(value);\n        }\n\n    }", "definition": "    private final class MultiValuedMapIterator implements MapIterator<K, V>", "class_docstring": "\nInner class for MapIterator.\n", "name": "MultiValuedMapIterator", "super_interfaces": ["MapIterator<K, V>"], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private final Iterator<Entry<K, V>> it;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<Entry<K, V>>", "name": "it", "syntax_pass": true}, {"attribute_expression": "private Entry<K, V> current;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Entry<K, V>", "name": "current", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        MultiValuedMapIterator() {\n            this.it = AbstractMultiValuedMap.this.entries().iterator();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MultiValuedMapIterator", "params": [], "body": "                                 {\n            this.it = AbstractMultiValuedMap.this.entries().iterator();\n        }", "signature": "MultiValuedMapIterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K getKey() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "getKey", "params": [], "body": "                          {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getKey();\n        }", "signature": "@Override\n        public K getKey()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V getValue() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getValue();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "getValue", "params": [], "body": "                            {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getValue();\n        }", "signature": "@Override\n        public V getValue()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return it.hasNext();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return it.hasNext();\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public K next() {\n            current = it.next();\n            return current.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "K", "classes": []}, "name": "next", "params": [], "body": "                        {\n            current = it.next();\n            return current.getKey();\n        }", "signature": "@Override\n        public K next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            it.remove();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            it.remove();\n        }", "signature": "@Override\n        public void remove()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V setValue(final V value) {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.setValue(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "setValue", "params": [{"name": "value", "type": "V"}], "body": "                                         {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.setValue(value);\n        }", "signature": "@Override\n        public V setValue(final V value)"}]}, {"original_string": "    private final class Values extends AbstractCollection<V> {\n        @Override\n        public void clear() {\n            AbstractMultiValuedMap.this.clear();\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            final IteratorChain<V> chain = new IteratorChain<>();\n            for (final K k : keySet()) {\n                chain.addIterator(new ValuesIterator(k));\n            }\n            return chain;\n        }\n\n        @Override\n        public int size() {\n            return AbstractMultiValuedMap.this.size();\n        }\n    }", "definition": "    private final class Values extends AbstractCollection<V>", "class_docstring": "\nInner class that provides the values view.\n", "name": "Values", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            AbstractMultiValuedMap.this.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            AbstractMultiValuedMap.this.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<V> iterator() {\n            final IteratorChain<V> chain = new IteratorChain<>();\n            for (final K k : keySet()) {\n                chain.addIterator(new ValuesIterator(k));\n            }\n            return chain;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<V>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            final IteratorChain<V> chain = new IteratorChain<>();\n            for (final K k : keySet()) {\n                chain.addIterator(new ValuesIterator(k));\n            }\n            return chain;\n        }", "signature": "@Override\n        public Iterator<V> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return AbstractMultiValuedMap.this.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return AbstractMultiValuedMap.this.size();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    private final class ValuesIterator implements Iterator<V> {\n        private final Object key;\n        private final Collection<V> values;\n        private final Iterator<V> iterator;\n\n        ValuesIterator(final Object key) {\n            this.key = key;\n            this.values = getMap().get(key);\n            this.iterator = values.iterator();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public V next() {\n            return iterator.next();\n        }\n\n        @Override\n        public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n        }\n    }", "definition": "    private final class ValuesIterator implements Iterator<V>", "class_docstring": "\nInner class that provides the values iterator.\n", "name": "ValuesIterator", "super_interfaces": ["Iterator<V>"], "superclasses": "", "attributes": {"modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "fields": [{"attribute_expression": "private final Object key;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "key", "syntax_pass": true}, {"attribute_expression": "private final Collection<V> values;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Collection<V>", "name": "values", "syntax_pass": true}, {"attribute_expression": "private final Iterator<V> iterator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<V>", "name": "iterator", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        ValuesIterator(final Object key) {\n            this.key = key;\n            this.values = getMap().get(key);\n            this.iterator = values.iterator();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "ValuesIterator", "params": [{"name": "key", "type": "Object"}], "body": "                                         {\n            this.key = key;\n            this.values = getMap().get(key);\n            this.iterator = values.iterator();\n        }", "signature": "ValuesIterator(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return iterator.hasNext();\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public V next() {\n            return iterator.next();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "V", "classes": []}, "name": "next", "params": [], "body": "                        {\n            return iterator.next();\n        }", "signature": "@Override\n        public V next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            iterator.remove();\n            if (values.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n        }", "signature": "@Override\n        public void remove()"}]}, {"original_string": "    class WrappedCollection implements Collection<V> {\n\n        protected final K key;\n\n        WrappedCollection(final K key) {\n            this.key = key;\n        }\n\n        @Override\n        public boolean add(final V value) {\n            Collection<V> coll = getMapping();\n            if (coll == null) {\n                coll = createCollection();\n                AbstractMultiValuedMap.this.map.put(key, coll);\n            }\n            return coll.add(value);\n        }\n\n        @Override\n        public boolean addAll(final Collection<? extends V> other) {\n            Collection<V> coll = getMapping();\n            if (coll == null) {\n                coll = createCollection();\n                AbstractMultiValuedMap.this.map.put(key, coll);\n            }\n            return coll.addAll(other);\n        }\n\n        @Override\n        public void clear() {\n            final Collection<V> coll = getMapping();\n            if (coll != null) {\n                coll.clear();\n                AbstractMultiValuedMap.this.remove(key);\n            }\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            final Collection<V> coll = getMapping();\n            return coll != null && coll.contains(obj);\n        }\n\n        @Override\n        public boolean containsAll(final Collection<?> other) {\n            final Collection<V> coll = getMapping();\n            return coll != null && coll.containsAll(other);\n        }\n\n        protected Collection<V> getMapping() {\n            return getMap().get(key);\n        }\n\n        @Override\n        public boolean isEmpty() {\n            final Collection<V> coll = getMapping();\n            return coll == null || coll.isEmpty();\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return IteratorUtils.EMPTY_ITERATOR;\n            }\n            return new ValuesIterator(key);\n        }\n\n        @Override\n        public boolean remove(final Object item) {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return false;\n            }\n\n            final boolean result = coll.remove(item);\n            if (coll.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n            return result;\n        }\n\n        @Override\n        public boolean removeAll(final Collection<?> c) {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return false;\n            }\n\n            final boolean result = coll.removeAll(c);\n            if (coll.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n            return result;\n        }\n\n        @Override\n        public boolean retainAll(final Collection<?> c) {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return false;\n            }\n\n            final boolean result = coll.retainAll(c);\n            if (coll.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n            return result;\n        }\n\n        @Override\n        public int size() {\n            final Collection<V> coll = getMapping();\n            return coll == null ? 0 : coll.size();\n        }\n\n        @Override\n        public Object[] toArray() {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return CollectionUtils.EMPTY_COLLECTION.toArray();\n            }\n            return coll.toArray();\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T[] toArray(final T[] a) {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return (T[]) CollectionUtils.EMPTY_COLLECTION.toArray(a);\n            }\n            return coll.toArray(a);\n        }\n\n        @Override\n        public String toString() {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return CollectionUtils.EMPTY_COLLECTION.toString();\n            }\n            return coll.toString();\n        }\n\n    }", "definition": "    class WrappedCollection implements Collection<V>", "class_docstring": "\nWrapped collection to handle add and remove on the collection returned\nby get(object).\n<p>\nCurrently, the wrapped collection is not cached and has to be retrieved\nfrom the underlying map. This is safe, but not very efficient and\nshould be improved in subsequent releases. For this purpose, the\nscope of this collection is set to package private to simplify later\nrefactoring.\n", "name": "WrappedCollection", "super_interfaces": ["Collection<V>"], "superclasses": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "fields": [{"attribute_expression": "protected final K key;", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "K", "name": "key", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        WrappedCollection(final K key) {\n            this.key = key;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "WrappedCollection", "params": [{"name": "key", "type": "K"}], "body": "                                       {\n            this.key = key;\n        }", "signature": "WrappedCollection(final K key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean add(final V value) {\n            Collection<V> coll = getMapping();\n            if (coll == null) {\n                coll = createCollection();\n                AbstractMultiValuedMap.this.map.put(key, coll);\n            }\n            return coll.add(value);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "add", "params": [{"name": "value", "type": "V"}], "body": "                                          {\n            Collection<V> coll = getMapping();\n            if (coll == null) {\n                coll = createCollection();\n                AbstractMultiValuedMap.this.map.put(key, coll);\n            }\n            return coll.add(value);\n        }", "signature": "@Override\n        public boolean add(final V value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean addAll(final Collection<? extends V> other) {\n            Collection<V> coll = getMapping();\n            if (coll == null) {\n                coll = createCollection();\n                AbstractMultiValuedMap.this.map.put(key, coll);\n            }\n            return coll.addAll(other);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "addAll", "params": [{"name": "other", "type": "Collection<? extends V>"}], "body": "                                                                   {\n            Collection<V> coll = getMapping();\n            if (coll == null) {\n                coll = createCollection();\n                AbstractMultiValuedMap.this.map.put(key, coll);\n            }\n            return coll.addAll(other);\n        }", "signature": "@Override\n        public boolean addAll(final Collection<? extends V> other)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            final Collection<V> coll = getMapping();\n            if (coll != null) {\n                coll.clear();\n                AbstractMultiValuedMap.this.remove(key);\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            final Collection<V> coll = getMapping();\n            if (coll != null) {\n                coll.clear();\n                AbstractMultiValuedMap.this.remove(key);\n            }\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object obj) {\n            final Collection<V> coll = getMapping();\n            return coll != null && coll.contains(obj);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "obj", "type": "Object"}], "body": "                                                  {\n            final Collection<V> coll = getMapping();\n            return coll != null && coll.contains(obj);\n        }", "signature": "@Override\n        public boolean contains(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsAll(final Collection<?> other) {\n            final Collection<V> coll = getMapping();\n            return coll != null && coll.containsAll(other);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsAll", "params": [{"name": "other", "type": "Collection<?>"}], "body": "                                                              {\n            final Collection<V> coll = getMapping();\n            return coll != null && coll.containsAll(other);\n        }", "signature": "@Override\n        public boolean containsAll(final Collection<?> other)"}, {"syntax_pass": true, "original_string": "        protected Collection<V> getMapping() {\n            return getMap().get(key);\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "Collection<V>", "classes": []}, "name": "getMapping", "params": [], "body": "                                             {\n            return getMap().get(key);\n        }", "signature": "protected Collection<V> getMapping()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean isEmpty() {\n            final Collection<V> coll = getMapping();\n            return coll == null || coll.isEmpty();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEmpty", "params": [], "body": "                                 {\n            final Collection<V> coll = getMapping();\n            return coll == null || coll.isEmpty();\n        }", "signature": "@Override\n        public boolean isEmpty()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<V> iterator() {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return IteratorUtils.EMPTY_ITERATOR;\n            }\n            return new ValuesIterator(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<V>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return IteratorUtils.EMPTY_ITERATOR;\n            }\n            return new ValuesIterator(key);\n        }", "signature": "@Override\n        public Iterator<V> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object item) {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return false;\n            }\n\n            final boolean result = coll.remove(item);\n            if (coll.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "item", "type": "Object"}], "body": "                                                 {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return false;\n            }\n\n            final boolean result = coll.remove(item);\n            if (coll.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n            return result;\n        }", "signature": "@Override\n        public boolean remove(final Object item)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean removeAll(final Collection<?> c) {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return false;\n            }\n\n            final boolean result = coll.removeAll(c);\n            if (coll.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "removeAll", "params": [{"name": "c", "type": "Collection<?>"}], "body": "                                                        {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return false;\n            }\n\n            final boolean result = coll.removeAll(c);\n            if (coll.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n            return result;\n        }", "signature": "@Override\n        public boolean removeAll(final Collection<?> c)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean retainAll(final Collection<?> c) {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return false;\n            }\n\n            final boolean result = coll.retainAll(c);\n            if (coll.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n            return result;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "retainAll", "params": [{"name": "c", "type": "Collection<?>"}], "body": "                                                        {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return false;\n            }\n\n            final boolean result = coll.retainAll(c);\n            if (coll.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n            return result;\n        }", "signature": "@Override\n        public boolean retainAll(final Collection<?> c)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            final Collection<V> coll = getMapping();\n            return coll == null ? 0 : coll.size();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            final Collection<V> coll = getMapping();\n            return coll == null ? 0 : coll.size();\n        }", "signature": "@Override\n        public int size()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Object[] toArray() {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return CollectionUtils.EMPTY_COLLECTION.toArray();\n            }\n            return coll.toArray();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Object[]", "classes": []}, "name": "toArray", "params": [], "body": "                                  {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return CollectionUtils.EMPTY_COLLECTION.toArray();\n            }\n            return coll.toArray();\n        }", "signature": "@Override\n        public Object[] toArray()"}, {"syntax_pass": true, "original_string": "        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T[] toArray(final T[] a) {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return (T[]) CollectionUtils.EMPTY_COLLECTION.toArray(a);\n            }\n            return coll.toArray(a);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["@SuppressWarnings(\"unchecked\")", "public"], "comments": [], "return_type": "T[]", "classes": []}, "name": "toArray", "params": [{"name": "a", "type": "T[]"}], "body": "                                            {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return (T[]) CollectionUtils.EMPTY_COLLECTION.toArray(a);\n            }\n            return coll.toArray(a);\n        }", "signature": "@Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T[] toArray(final T[] a)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return CollectionUtils.EMPTY_COLLECTION.toString();\n            }\n            return coll.toString();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return CollectionUtils.EMPTY_COLLECTION.toString();\n            }\n            return coll.toString();\n        }", "signature": "@Override\n        public String toString()"}]}], "class_docstring": "\nAbstract implementation of the {@link MultiValuedMap} interface to simplify\nthe creation of subclass implementations.\n<p>\nSubclasses specify a Map implementation to use as the internal storage.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.1\n", "original_string": "public abstract class AbstractMultiValuedMap<K, V> implements MultiValuedMap<K, V> {\n\n    /**\n     * Inner class that provides the AsMap view.\n     */\n    private final class AsMap extends AbstractMap<K, Collection<V>> {\n        final class AsMapEntrySet extends AbstractSet<Map.Entry<K, Collection<V>>> {\n\n            @Override\n            public void clear() {\n                AsMap.this.clear();\n            }\n\n            @Override\n            public boolean contains(final Object o) {\n                return map.entrySet().contains(o);\n            }\n\n            @Override\n            public Iterator<Map.Entry<K, Collection<V>>> iterator() {\n                return new AsMapEntrySetIterator(map.entrySet().iterator());\n            }\n\n            @Override\n            public boolean remove(final Object o) {\n                if (!contains(o)) {\n                    return false;\n                }\n                final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) o;\n                AbstractMultiValuedMap.this.remove(entry.getKey());\n                return true;\n            }\n\n            @Override\n            public int size() {\n                return AsMap.this.size();\n            }\n        }\n\n        /**\n         * EntrySet iterator for the asMap view.\n         */\n        final class AsMapEntrySetIterator extends AbstractIteratorDecorator<Map.Entry<K, Collection<V>>> {\n\n            AsMapEntrySetIterator(final Iterator<Map.Entry<K, Collection<V>>> iterator) {\n                super(iterator);\n            }\n\n            @Override\n            public Map.Entry<K, Collection<V>> next() {\n                final Map.Entry<K, Collection<V>> entry = super.next();\n                final K key = entry.getKey();\n                return new UnmodifiableMapEntry<>(key, wrappedCollection(key));\n            }\n        }\n\n        final transient Map<K, Collection<V>> map;\n\n        AsMap(final Map<K, Collection<V>> map) {\n            this.map = map;\n        }\n\n        @Override\n        public void clear() {\n            AbstractMultiValuedMap.this.clear();\n        }\n\n        @Override\n        public boolean containsKey(final Object key) {\n            return map.containsKey(key);\n        }\n\n        @Override\n        public Set<Map.Entry<K, Collection<V>>> entrySet() {\n            return new AsMapEntrySet();\n        }\n\n        @Override\n        public boolean equals(final Object object) {\n            return this == object || map.equals(object);\n        }\n\n        @Override\n        public Collection<V> get(final Object key) {\n            final Collection<V> collection = map.get(key);\n            if (collection == null) {\n                return null;\n            }\n            @SuppressWarnings(\"unchecked\")\n            final K k = (K) key;\n            return wrappedCollection(k);\n        }\n\n        @Override\n        public int hashCode() {\n            return map.hashCode();\n        }\n\n        @Override\n        public Set<K> keySet() {\n            return AbstractMultiValuedMap.this.keySet();\n        }\n\n        @Override\n        public Collection<V> remove(final Object key) {\n            final Collection<V> collection = map.remove(key);\n            if (collection == null) {\n                return null;\n            }\n\n            final Collection<V> output = createCollection();\n            output.addAll(collection);\n            collection.clear();\n            return output;\n        }\n\n        @Override\n        public int size() {\n            return map.size();\n        }\n\n        @Override\n        public String toString() {\n            return map.toString();\n        }\n    }\n\n    /**\n     * Inner class that provides the Entry<K, V> view\n     */\n    private final class EntryValues extends AbstractCollection<Entry<K, V>> {\n\n        @Override\n        public Iterator<Entry<K, V>> iterator() {\n            return new LazyIteratorChain<Entry<K, V>>() {\n\n                final Collection<K> keysCol = new ArrayList<>(getMap().keySet());\n                final Iterator<K> keyIterator = keysCol.iterator();\n\n                @Override\n                protected Iterator<? extends Entry<K, V>> nextIterator(final int count) {\n                    if (!keyIterator.hasNext()) {\n                        return null;\n                    }\n                    final K key = keyIterator.next();\n                    final Transformer<V, Entry<K, V>> entryTransformer = input -> new MultiValuedMapEntry(key, input);\n                    return new TransformIterator<>(new ValuesIterator(key), entryTransformer);\n                }\n            };\n        }\n\n        @Override\n        public int size() {\n            return AbstractMultiValuedMap.this.size();\n        }\n\n    }\n\n    /**\n     * Inner class that provides a MultiSet<K> keys view.\n     */\n    private final class KeysMultiSet extends AbstractMultiSet<K> {\n\n        private final class MapEntryTransformer implements Transformer<Map.Entry<K, Collection<V>>, MultiSet.Entry<K>> {\n\n            @Override\n            public MultiSet.Entry<K> transform(final Map.Entry<K, Collection<V>> mapEntry) {\n                return new AbstractMultiSet.AbstractEntry<K>() {\n\n                    @Override\n                    public int getCount() {\n                        return mapEntry.getValue().size();\n                    }\n\n                    @Override\n                    public K getElement() {\n                        return mapEntry.getKey();\n                    }\n                };\n            }\n        }\n\n        @Override\n        public boolean contains(final Object o) {\n            return getMap().containsKey(o);\n        }\n\n        @Override\n        protected Iterator<MultiSet.Entry<K>> createEntrySetIterator() {\n            final MapEntryTransformer transformer = new MapEntryTransformer();\n            return IteratorUtils.transformedIterator(map.entrySet().iterator(), transformer);\n        }\n\n        @Override\n        public int getCount(final Object object) {\n            int count = 0;\n            final Collection<V> col = AbstractMultiValuedMap.this.getMap().get(object);\n            if (col != null) {\n                count = col.size();\n            }\n            return count;\n        }\n\n        @Override\n        public boolean isEmpty() {\n            return getMap().isEmpty();\n        }\n\n        @Override\n        public int size() {\n            return AbstractMultiValuedMap.this.size();\n        }\n\n        @Override\n        protected int uniqueElements() {\n            return getMap().size();\n        }\n    }\n\n    /**\n     * Inner class for MultiValuedMap Entries.\n     */\n    private final class MultiValuedMapEntry extends AbstractMapEntry<K, V> {\n\n        MultiValuedMapEntry(final K key, final V value) {\n            super(key, value);\n        }\n\n        @Override\n        public V setValue(final V value) {\n            throw new UnsupportedOperationException();\n        }\n\n    }\n\n    /**\n     * Inner class for MapIterator.\n     */\n    private final class MultiValuedMapIterator implements MapIterator<K, V> {\n\n        private final Iterator<Entry<K, V>> it;\n\n        private Entry<K, V> current;\n\n        MultiValuedMapIterator() {\n            this.it = AbstractMultiValuedMap.this.entries().iterator();\n        }\n\n        @Override\n        public K getKey() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getKey();\n        }\n\n        @Override\n        public V getValue() {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.getValue();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return it.hasNext();\n        }\n\n        @Override\n        public K next() {\n            current = it.next();\n            return current.getKey();\n        }\n\n        @Override\n        public void remove() {\n            it.remove();\n        }\n\n        @Override\n        public V setValue(final V value) {\n            if (current == null) {\n                throw new IllegalStateException();\n            }\n            return current.setValue(value);\n        }\n\n    }\n\n    /**\n     * Inner class that provides the values view.\n     */\n    private final class Values extends AbstractCollection<V> {\n        @Override\n        public void clear() {\n            AbstractMultiValuedMap.this.clear();\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            final IteratorChain<V> chain = new IteratorChain<>();\n            for (final K k : keySet()) {\n                chain.addIterator(new ValuesIterator(k));\n            }\n            return chain;\n        }\n\n        @Override\n        public int size() {\n            return AbstractMultiValuedMap.this.size();\n        }\n    }\n\n    /**\n     * Inner class that provides the values iterator.\n     */\n    private final class ValuesIterator implements Iterator<V> {\n        private final Object key;\n        private final Collection<V> values;\n        private final Iterator<V> iterator;\n\n        ValuesIterator(final Object key) {\n            this.key = key;\n            this.values = getMap().get(key);\n            this.iterator = values.iterator();\n        }\n\n        @Override\n        public boolean hasNext() {\n            return iterator.hasNext();\n        }\n\n        @Override\n        public V next() {\n            return iterator.next();\n        }\n\n        @Override\n        public void remove() {\n            iterator.remove();\n            if (values.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n        }\n    }\n\n    /**\n     * Wrapped collection to handle add and remove on the collection returned\n     * by get(object).\n     * <p>\n     * Currently, the wrapped collection is not cached and has to be retrieved\n     * from the underlying map. This is safe, but not very efficient and\n     * should be improved in subsequent releases. For this purpose, the\n     * scope of this collection is set to package private to simplify later\n     * refactoring.\n     */\n    class WrappedCollection implements Collection<V> {\n\n        protected final K key;\n\n        WrappedCollection(final K key) {\n            this.key = key;\n        }\n\n        @Override\n        public boolean add(final V value) {\n            Collection<V> coll = getMapping();\n            if (coll == null) {\n                coll = createCollection();\n                AbstractMultiValuedMap.this.map.put(key, coll);\n            }\n            return coll.add(value);\n        }\n\n        @Override\n        public boolean addAll(final Collection<? extends V> other) {\n            Collection<V> coll = getMapping();\n            if (coll == null) {\n                coll = createCollection();\n                AbstractMultiValuedMap.this.map.put(key, coll);\n            }\n            return coll.addAll(other);\n        }\n\n        @Override\n        public void clear() {\n            final Collection<V> coll = getMapping();\n            if (coll != null) {\n                coll.clear();\n                AbstractMultiValuedMap.this.remove(key);\n            }\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            final Collection<V> coll = getMapping();\n            return coll != null && coll.contains(obj);\n        }\n\n        @Override\n        public boolean containsAll(final Collection<?> other) {\n            final Collection<V> coll = getMapping();\n            return coll != null && coll.containsAll(other);\n        }\n\n        protected Collection<V> getMapping() {\n            return getMap().get(key);\n        }\n\n        @Override\n        public boolean isEmpty() {\n            final Collection<V> coll = getMapping();\n            return coll == null || coll.isEmpty();\n        }\n\n        @Override\n        public Iterator<V> iterator() {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return IteratorUtils.EMPTY_ITERATOR;\n            }\n            return new ValuesIterator(key);\n        }\n\n        @Override\n        public boolean remove(final Object item) {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return false;\n            }\n\n            final boolean result = coll.remove(item);\n            if (coll.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n            return result;\n        }\n\n        @Override\n        public boolean removeAll(final Collection<?> c) {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return false;\n            }\n\n            final boolean result = coll.removeAll(c);\n            if (coll.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n            return result;\n        }\n\n        @Override\n        public boolean retainAll(final Collection<?> c) {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return false;\n            }\n\n            final boolean result = coll.retainAll(c);\n            if (coll.isEmpty()) {\n                AbstractMultiValuedMap.this.remove(key);\n            }\n            return result;\n        }\n\n        @Override\n        public int size() {\n            final Collection<V> coll = getMapping();\n            return coll == null ? 0 : coll.size();\n        }\n\n        @Override\n        public Object[] toArray() {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return CollectionUtils.EMPTY_COLLECTION.toArray();\n            }\n            return coll.toArray();\n        }\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T[] toArray(final T[] a) {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return (T[]) CollectionUtils.EMPTY_COLLECTION.toArray(a);\n            }\n            return coll.toArray(a);\n        }\n\n        @Override\n        public String toString() {\n            final Collection<V> coll = getMapping();\n            if (coll == null) {\n                return CollectionUtils.EMPTY_COLLECTION.toString();\n            }\n            return coll.toString();\n        }\n\n    }\n\n    /** The values view */\n    private transient Collection<V> valuesView;\n\n    /** The EntryValues view */\n    private transient EntryValues entryValuesView;\n\n    /** The KeyMultiSet view */\n    private transient MultiSet<K> keysMultiSetView;\n\n    /** The AsMap view */\n    private transient AsMap asMapView;\n\n    /** The map used to store the data */\n    private transient Map<K, Collection<V>> map;\n\n    /**\n     * Constructor needed for subclass serialisation.\n     */\n    protected AbstractMultiValuedMap() {\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param map  the map to wrap, must not be null\n     * @throws NullPointerException if the map is null\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected AbstractMultiValuedMap(final Map<K, ? extends Collection<V>> map) {\n        this.map = (Map<K, Collection<V>>) Objects.requireNonNull(map, \"map\");\n    }\n\n    @Override\n    public Map<K, Collection<V>> asMap() {\n        return asMapView != null ? asMapView : (asMapView = new AsMap(map));\n    }\n\n    @Override\n    public void clear() {\n        getMap().clear();\n    }\n\n    @Override\n    public boolean containsKey(final Object key) {\n        return getMap().containsKey(key);\n    }\n\n    @Override\n    public boolean containsMapping(final Object key, final Object value) {\n        final Collection<V> coll = getMap().get(key);\n        return coll != null && coll.contains(value);\n    }\n\n    @Override\n    public boolean containsValue(final Object value) {\n        return values().contains(value);\n    }\n\n    /**\n     * Creates a new Collection typed for a given subclass.\n     *\n     * @return a new Collection typed for a given subclass.\n     */\n    protected abstract Collection<V> createCollection();\n\n    /**\n     * Read the map in using a custom routine.\n     * @param in the input stream\n     * @throws IOException any of the usual I/O related exceptions\n     * @throws ClassNotFoundException if the stream contains an object which class can not be loaded\n     * @throws ClassCastException if the stream does not contain the correct objects\n     */\n    protected void doReadObject(final ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n        final int entrySize = in.readInt();\n        for (int i = 0; i < entrySize; i++) {\n            @SuppressWarnings(\"unchecked\") // This will fail at runtime if the stream is incorrect\n            final K key = (K) in.readObject();\n            final Collection<V> values = get(key);\n            final int valueSize = in.readInt();\n            for (int j = 0; j < valueSize; j++) {\n                @SuppressWarnings(\"unchecked\") // see above\n                final V value = (V) in.readObject();\n                values.add(value);\n            }\n        }\n    }\n\n    /**\n     * Write the map out using a custom routine.\n     * @param out the output stream\n     * @throws IOException any of the usual I/O related exceptions\n     */\n    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n        out.writeInt(map.size());\n        for (final Map.Entry<K, Collection<V>> entry : map.entrySet()) {\n            out.writeObject(entry.getKey());\n            out.writeInt(entry.getValue().size());\n            for (final V value : entry.getValue()) {\n                out.writeObject(value);\n            }\n        }\n    }\n\n    @Override\n    public Collection<Entry<K, V>> entries() {\n        return entryValuesView != null ? entryValuesView : (entryValuesView = new EntryValues());\n    }\n\n    @Override\n    public boolean equals(final Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof MultiValuedMap) {\n            return asMap().equals(((MultiValuedMap<?, ?>) obj).asMap());\n        }\n        return false;\n    }\n\n    /**\n     * Gets the collection of values associated with the specified key. This\n     * would return an empty collection in case the mapping is not present\n     *\n     * @param key the key to retrieve\n     * @return the {@code Collection} of values, will return an empty {@code Collection} for no mapping\n     */\n    @Override\n    public Collection<V> get(final K key) {\n        return wrappedCollection(key);\n    }\n\n    /**\n     * Gets the map being wrapped.\n     *\n     * @return the wrapped map\n     */\n    protected Map<K, ? extends Collection<V>> getMap() {\n        return map;\n    }\n\n    @Override\n    public int hashCode() {\n        return getMap().hashCode();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return getMap().isEmpty();\n    }\n\n    /**\n     * Returns a {@link MultiSet} view of the key mapping contained in this map.\n     * <p>\n     * Returns a MultiSet of keys with its values count as the count of the MultiSet.\n     * This multiset is backed by the map, so any changes in the map is reflected here.\n     * Any method which modifies this multiset like {@code add}, {@code remove},\n     * {@link Iterator#remove()} etc throws {@code UnsupportedOperationException}.\n     *\n     * @return a bag view of the key mapping contained in this map\n     */\n    @Override\n    public MultiSet<K> keys() {\n        if (keysMultiSetView == null) {\n            keysMultiSetView = UnmodifiableMultiSet.unmodifiableMultiSet(new KeysMultiSet());\n        }\n        return keysMultiSetView;\n    }\n\n    @Override\n    public Set<K> keySet() {\n        return getMap().keySet();\n    }\n\n    @Override\n    public MapIterator<K, V> mapIterator() {\n        if (isEmpty()) {\n            return EmptyMapIterator.emptyMapIterator();\n        }\n        return new MultiValuedMapIterator();\n    }\n\n    /**\n     * Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal {@code Map} the previous value is not replaced.\n     * Instead the new value is added to the collection stored against the key.\n     *\n     * @param key the key to store against\n     * @param value the value to add to the collection at the key\n     * @return the value added if the map changed and null if the map did not change\n     */\n    @Override\n    public boolean put(final K key, final V value) {\n        Collection<V> coll = getMap().get(key);\n        if (coll == null) {\n            coll = createCollection();\n            if (coll.add(value)) {\n                map.put(key, coll);\n                return true;\n            }\n            return false;\n        }\n        return coll.add(value);\n    }\n\n    /**\n     * Adds Iterable values to the collection associated with the specified key.\n     *\n     * @param key the key to store against\n     * @param values the values to add to the collection at the key, may not be null\n     * @return true if this map changed\n     * @throws NullPointerException if values is null\n     */\n    @Override\n    public boolean putAll(final K key, final Iterable<? extends V> values) {\n        Objects.requireNonNull(values, \"values\");\n\n        if (values instanceof Collection<?>) {\n            final Collection<? extends V> valueCollection = (Collection<? extends V>) values;\n            return !valueCollection.isEmpty() && get(key).addAll(valueCollection);\n        }\n        final Iterator<? extends V> it = values.iterator();\n        return it.hasNext() && CollectionUtils.addAll(get(key), it);\n    }\n\n    /**\n     * Copies all of the mappings from the specified map to this map. The effect\n     * of this call is equivalent to that of calling {@link #put(Object,Object)\n     * put(k, v)} on this map once for each mapping from key {@code k} to value\n     * {@code v} in the specified map. The behavior of this operation is\n     * undefined if the specified map is modified while the operation is in\n     * progress.\n     *\n     * @param map mappings to be stored in this map, may not be null\n     * @return true if the map changed as a result of this operation\n     * @throws NullPointerException if map is null\n     */\n    @Override\n    public boolean putAll(final Map<? extends K, ? extends V> map) {\n        Objects.requireNonNull(map, \"map\");\n        boolean changed = false;\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entrySet()) {\n            changed |= put(entry.getKey(), entry.getValue());\n        }\n        return changed;\n    }\n\n    /**\n     * Copies all of the mappings from the specified MultiValuedMap to this map.\n     * The effect of this call is equivalent to that of calling\n     * {@link #put(Object,Object) put(k, v)} on this map once for each mapping\n     * from key {@code k} to value {@code v} in the specified map. The\n     * behavior of this operation is undefined if the specified map is modified\n     * while the operation is in progress.\n     *\n     * @param map mappings to be stored in this map, may not be null\n     * @return true if the map changed as a result of this operation\n     * @throws NullPointerException if map is null\n     */\n    @Override\n    public boolean putAll(final MultiValuedMap<? extends K, ? extends V> map) {\n        Objects.requireNonNull(map, \"map\");\n        boolean changed = false;\n        for (final Map.Entry<? extends K, ? extends V> entry : map.entries()) {\n            changed |= put(entry.getKey(), entry.getValue());\n        }\n        return changed;\n    }\n\n    /**\n     * Removes all values associated with the specified key.\n     * <p>\n     * A subsequent {@code get(Object)} would return an empty collection.\n     *\n     * @param key  the key to remove values from\n     * @return the {@code Collection} of values removed, will return an\n     *   empty, unmodifiable collection for no mapping found\n     */\n    @Override\n    public Collection<V> remove(final Object key) {\n        return CollectionUtils.emptyIfNull(getMap().remove(key));\n    }\n\n    /**\n     * Removes a specific key/value mapping from the multivalued map.\n     * <p>\n     * The value is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, an empty collection would be\n     * returned from a subsequent {@link #get(Object)}.\n     *\n     * @param key the key to remove from\n     * @param value the value to remove\n     * @return true if the mapping was removed, false otherwise\n     */\n    @Override\n    public boolean removeMapping(final Object key, final Object value) {\n        final Collection<V> coll = getMap().get(key);\n        if (coll == null) {\n            return false;\n        }\n        final boolean changed = coll.remove(value);\n        if (coll.isEmpty()) {\n            getMap().remove(key);\n        }\n        return changed;\n    }\n\n    /**\n     * Sets the map being wrapped.\n     * <p>\n     * <b>NOTE:</b> this method should only be used during deserialization\n     *\n     * @param map the map to wrap\n     */\n    @SuppressWarnings(\"unchecked\")\n    protected void setMap(final Map<K, ? extends Collection<V>> map) {\n        this.map = (Map<K, Collection<V>>) map;\n    }\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * This implementation does <b>not</b> cache the total size\n     * of the multivalued map, but rather calculates it by iterating\n     * over the entries of the underlying map.\n     */\n    @Override\n    public int size() {\n        // the total size should be cached to improve performance\n        // but this requires that all modifications of the multimap\n        // (including the wrapped collections and entry/value\n        // collections) are tracked.\n        int size = 0;\n        for (final Collection<V> col : getMap().values()) {\n            size += col.size();\n        }\n        return size;\n    }\n\n    @Override\n    public String toString() {\n        return getMap().toString();\n    }\n\n    /**\n     * Gets a collection containing all the values in the map.\n     * <p>\n     * Returns a collection containing all the values from all keys.\n     *\n     * @return a collection view of the values contained in this map\n     */\n    @Override\n    public Collection<V> values() {\n        final Collection<V> vs = valuesView;\n        return vs != null ? vs : (valuesView = new Values());\n    }\n\n    Collection<V> wrappedCollection(final K key) {\n        return new WrappedCollection(key);\n    }\n\n}", "super_interfaces": ["MultiValuedMap<K, V>"], "fields": [{"attribute_expression": "private transient Collection<V> valuesView;", "docstring": " The values view", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Collection<V>", "name": "valuesView", "syntax_pass": true}, {"attribute_expression": "private transient EntryValues entryValuesView;", "docstring": " The EntryValues view", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "EntryValues", "name": "entryValuesView", "syntax_pass": true}, {"attribute_expression": "private transient MultiSet<K> keysMultiSetView;", "docstring": " The KeyMultiSet view", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "MultiSet<K>", "name": "keysMultiSetView", "syntax_pass": true}, {"attribute_expression": "private transient AsMap asMapView;", "docstring": " The AsMap view", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "AsMap", "name": "asMapView", "syntax_pass": true}, {"attribute_expression": "private transient Map<K, Collection<V>> map;", "docstring": " The map used to store the data", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Map<K, Collection<V>>", "name": "map", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet", "name": "AbstractMultiSet", "file_path": "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java", "superclasses": "", "methods": ["[]AbstractMultiSet()", "[boolean]add(E)", "[int]add(E,int)", "[void]clear()", "[boolean]contains(Object)", "[Set<Entry<E>>]createEntrySet()", "[Iterator<Entry<E>>]createEntrySetIterator()", "[Set<E>]createUniqueSet()", "[Iterator<E>]createUniqueSetIterator()", "[void]doReadObject(ObjectInputStream)", "[void]doWriteObject(ObjectOutputStream)", "[Set<Entry<E>>]entrySet()", "[boolean]equals(Object)", "[int]getCount(Object)", "[int]hashCode()", "[Iterator<E>]iterator()", "[boolean]remove(Object)", "[int]remove(Object,int)", "[boolean]removeAll(Collection<?>)", "[int]setCount(E,int)", "[int]size()", "[String]toString()", "[int]uniqueElements()", "[Set<E>]uniqueSet()"], "method_uris": ["src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[]AbstractMultiSet()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[int]add(E,int)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[void]clear()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[boolean]contains(Object)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[Set<Entry<E>>]createEntrySet()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[Iterator<Entry<E>>]createEntrySetIterator()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[Set<E>]createUniqueSet()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[Iterator<E>]createUniqueSetIterator()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[void]doReadObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[void]doWriteObject(ObjectOutputStream)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[Set<Entry<E>>]entrySet()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[int]getCount(Object)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[int]hashCode()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[int]remove(Object,int)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[int]setCount(E,int)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[int]size()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[String]toString()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[int]uniqueElements()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSet.java.AbstractMultiSet.[Set<E>]uniqueSet()"], "overrides": null, "attributes": [{"original_string": "    protected abstract static class AbstractEntry<E> implements Entry<E> {\n\n        @Override\n        public boolean equals(final Object object) {\n            if (object instanceof Entry) {\n                final Entry<?> other = (Entry<?>) object;\n                final E element = getElement();\n                final Object otherElement = other.getElement();\n\n                return this.getCount() == other.getCount() &&\n                       Objects.equals(element, otherElement);\n            }\n            return false;\n        }\n\n        @Override\n        public int hashCode() {\n            final E element = getElement();\n            return (element == null ? 0 : element.hashCode()) ^ getCount();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s:%d\", getElement(), getCount());\n        }\n    }", "definition": "    protected abstract static class AbstractEntry<E> implements Entry<E>", "class_docstring": "\nInner class AbstractEntry.\n\n@param <E> the element type.\n", "name": "AbstractEntry", "super_interfaces": ["Entry<E>"], "superclasses": "", "attributes": {"modifiers": "protected abstract static", "marker_annotations": [], "non_marker_annotations": ["protected", "abstract", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object object) {\n            if (object instanceof Entry) {\n                final Entry<?> other = (Entry<?>) object;\n                final E element = getElement();\n                final Object otherElement = other.getElement();\n\n                return this.getCount() == other.getCount() &&\n                       Objects.equals(element, otherElement);\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "object", "type": "Object"}], "body": "                                                   {\n            if (object instanceof Entry) {\n                final Entry<?> other = (Entry<?>) object;\n                final E element = getElement();\n                final Object otherElement = other.getElement();\n\n                return this.getCount() == other.getCount() &&\n                       Objects.equals(element, otherElement);\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean equals(final Object object)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            final E element = getElement();\n            return (element == null ? 0 : element.hashCode()) ^ getCount();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            final E element = getElement();\n            return (element == null ? 0 : element.hashCode()) ^ getCount();\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return String.format(\"%s:%d\", getElement(), getCount());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return String.format(\"%s:%d\", getElement(), getCount());\n        }", "signature": "@Override\n        public String toString()"}]}, {"original_string": "    protected static class EntrySet<E> extends AbstractSet<Entry<E>> {\n\n        private final AbstractMultiSet<E> parent;\n\n        /**\n         * Constructs a new view of the MultiSet.\n         *\n         * @param parent  the parent MultiSet\n         */\n        protected EntrySet(final AbstractMultiSet<E> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            if (!(obj instanceof Entry<?>)) {\n                return false;\n            }\n            final Entry<?> entry = (Entry<?>) obj;\n            final Object element = entry.getElement();\n            return parent.getCount(element) == entry.getCount();\n        }\n\n        @Override\n        public Iterator<Entry<E>> iterator() {\n            return parent.createEntrySetIterator();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Entry<?>)) {\n                return false;\n            }\n            final Entry<?> entry = (Entry<?>) obj;\n            final Object element = entry.getElement();\n            if (parent.contains(element)) {\n                final int count = parent.getCount(element);\n                if (entry.getCount() == count) {\n                    parent.remove(element, count);\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public int size() {\n            return parent.uniqueElements();\n        }\n    }", "definition": "    protected static class EntrySet<E> extends AbstractSet<Entry<E>>", "class_docstring": "\nInner class EntrySet.\n\n@param <E> the element type.\n", "name": "EntrySet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "private final AbstractMultiSet<E> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractMultiSet<E>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected EntrySet(final AbstractMultiSet<E> parent) {\n            this.parent = parent;\n        }", "docstring": "\nConstructs a new view of the MultiSet.\n\n@param parent  the parent MultiSet\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "EntrySet", "params": [{"name": "parent", "type": "AbstractMultiSet<E>"}], "body": "                                                             {\n            this.parent = parent;\n        }", "signature": "protected EntrySet(final AbstractMultiSet<E> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object obj) {\n            if (!(obj instanceof Entry<?>)) {\n                return false;\n            }\n            final Entry<?> entry = (Entry<?>) obj;\n            final Object element = entry.getElement();\n            return parent.getCount(element) == entry.getCount();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "obj", "type": "Object"}], "body": "                                                  {\n            if (!(obj instanceof Entry<?>)) {\n                return false;\n            }\n            final Entry<?> entry = (Entry<?>) obj;\n            final Object element = entry.getElement();\n            return parent.getCount(element) == entry.getCount();\n        }", "signature": "@Override\n        public boolean contains(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<Entry<E>> iterator() {\n            return parent.createEntrySetIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<Entry<E>>", "classes": []}, "name": "iterator", "params": [], "body": "                                             {\n            return parent.createEntrySetIterator();\n        }", "signature": "@Override\n        public Iterator<Entry<E>> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Entry<?>)) {\n                return false;\n            }\n            final Entry<?> entry = (Entry<?>) obj;\n            final Object element = entry.getElement();\n            if (parent.contains(element)) {\n                final int count = parent.getCount(element);\n                if (entry.getCount() == count) {\n                    parent.remove(element, count);\n                    return true;\n                }\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (!(obj instanceof Entry<?>)) {\n                return false;\n            }\n            final Entry<?> entry = (Entry<?>) obj;\n            final Object element = entry.getElement();\n            if (parent.contains(element)) {\n                final int count = parent.getCount(element);\n                if (entry.getCount() == count) {\n                    parent.remove(element, count);\n                    return true;\n                }\n            }\n            return false;\n        }", "signature": "@Override\n        public boolean remove(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return parent.uniqueElements();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return parent.uniqueElements();\n        }", "signature": "@Override\n        public int size()"}]}, {"original_string": "    private static final class MultiSetIterator<E> implements Iterator<E> {\n        private final AbstractMultiSet<E> parent;\n        private final Iterator<Entry<E>> entryIterator;\n        private Entry<E> current;\n        private int itemCount;\n        private boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent the parent multiset\n         */\n        MultiSetIterator(final AbstractMultiSet<E> parent) {\n            this.parent = parent;\n            this.entryIterator = parent.entrySet().iterator();\n            this.current = null;\n            this.canRemove = false;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean hasNext() {\n            return itemCount > 0 || entryIterator.hasNext();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public E next() {\n            if (itemCount == 0) {\n                current = entryIterator.next();\n                itemCount = current.getCount();\n            }\n            canRemove = true;\n            itemCount--;\n            return current.getElement();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException();\n            }\n            final int count = current.getCount();\n            if (count > 1) {\n                parent.remove(current.getElement());\n            } else {\n                entryIterator.remove();\n            }\n            canRemove = false;\n        }\n    }", "definition": "    private static final class MultiSetIterator<E> implements Iterator<E>", "class_docstring": "\nInner class iterator for the MultiSet.\n", "name": "MultiSetIterator", "super_interfaces": ["Iterator<E>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final AbstractMultiSet<E> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractMultiSet<E>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private final Iterator<Entry<E>> entryIterator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<Entry<E>>", "name": "entryIterator", "syntax_pass": true}, {"attribute_expression": "private Entry<E> current;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Entry<E>", "name": "current", "syntax_pass": true}, {"attribute_expression": "private int itemCount;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "itemCount", "syntax_pass": true}, {"attribute_expression": "private boolean canRemove;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "canRemove", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        MultiSetIterator(final AbstractMultiSet<E> parent) {\n            this.parent = parent;\n            this.entryIterator = parent.entrySet().iterator();\n            this.current = null;\n            this.canRemove = false;\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent the parent multiset\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MultiSetIterator", "params": [{"name": "parent", "type": "AbstractMultiSet<E>"}], "body": "                                                           {\n            this.parent = parent;\n            this.entryIterator = parent.entrySet().iterator();\n            this.current = null;\n            this.canRemove = false;\n        }", "signature": "MultiSetIterator(final AbstractMultiSet<E> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return itemCount > 0 || entryIterator.hasNext();\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return itemCount > 0 || entryIterator.hasNext();\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E next() {\n            if (itemCount == 0) {\n                current = entryIterator.next();\n                itemCount = current.getCount();\n            }\n            canRemove = true;\n            itemCount--;\n            return current.getElement();\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "next", "params": [], "body": "                        {\n            if (itemCount == 0) {\n                current = entryIterator.next();\n                itemCount = current.getCount();\n            }\n            canRemove = true;\n            itemCount--;\n            return current.getElement();\n        }", "signature": "@Override\n        public E next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException();\n            }\n            final int count = current.getCount();\n            if (count > 1) {\n                parent.remove(current.getElement());\n            } else {\n                entryIterator.remove();\n            }\n            canRemove = false;\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (!canRemove) {\n                throw new IllegalStateException();\n            }\n            final int count = current.getCount();\n            if (count > 1) {\n                parent.remove(current.getElement());\n            } else {\n                entryIterator.remove();\n            }\n            canRemove = false;\n        }", "signature": "@Override\n        public void remove()"}]}, {"original_string": "    protected static class UniqueSet<E> extends AbstractSet<E> {\n\n        /** The parent multiset */\n        protected final AbstractMultiSet<E> parent;\n\n        /**\n         * Constructs a new unique element view of the MultiSet.\n         *\n         * @param parent  the parent MultiSet\n         */\n        protected UniqueSet(final AbstractMultiSet<E> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object key) {\n            return parent.contains(key);\n        }\n\n        @Override\n        public boolean containsAll(final Collection<?> coll) {\n            return parent.containsAll(coll);\n        }\n\n        @Override\n        public Iterator<E> iterator() {\n            return parent.createUniqueSetIterator();\n        }\n\n        @Override\n        public boolean remove(final Object key) {\n            return parent.remove(key, parent.getCount(key)) != 0;\n        }\n\n        @Override\n        public int size() {\n            return parent.uniqueElements();\n        }\n    }", "definition": "    protected static class UniqueSet<E> extends AbstractSet<E>", "class_docstring": "\nInner class UniqueSet.\n\n@param <E> the element type.\n", "name": "UniqueSet", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected final AbstractMultiSet<E> parent;", "docstring": " The parent multiset", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "AbstractMultiSet<E>", "name": "parent", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected UniqueSet(final AbstractMultiSet<E> parent) {\n            this.parent = parent;\n        }", "docstring": "\nConstructs a new unique element view of the MultiSet.\n\n@param parent  the parent MultiSet\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "UniqueSet", "params": [{"name": "parent", "type": "AbstractMultiSet<E>"}], "body": "                                                              {\n            this.parent = parent;\n        }", "signature": "protected UniqueSet(final AbstractMultiSet<E> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void clear() {\n            parent.clear();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "clear", "params": [], "body": "                            {\n            parent.clear();\n        }", "signature": "@Override\n        public void clear()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean contains(final Object key) {\n            return parent.contains(key);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "contains", "params": [{"name": "key", "type": "Object"}], "body": "                                                  {\n            return parent.contains(key);\n        }", "signature": "@Override\n        public boolean contains(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean containsAll(final Collection<?> coll) {\n            return parent.containsAll(coll);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "containsAll", "params": [{"name": "coll", "type": "Collection<?>"}], "body": "                                                             {\n            return parent.containsAll(coll);\n        }", "signature": "@Override\n        public boolean containsAll(final Collection<?> coll)"}, {"syntax_pass": true, "original_string": "        @Override\n        public Iterator<E> iterator() {\n            return parent.createUniqueSetIterator();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Iterator<E>", "classes": []}, "name": "iterator", "params": [], "body": "                                      {\n            return parent.createUniqueSetIterator();\n        }", "signature": "@Override\n        public Iterator<E> iterator()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean remove(final Object key) {\n            return parent.remove(key, parent.getCount(key)) != 0;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "remove", "params": [{"name": "key", "type": "Object"}], "body": "                                                {\n            return parent.remove(key, parent.getCount(key)) != 0;\n        }", "signature": "@Override\n        public boolean remove(final Object key)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int size() {\n            return parent.uniqueElements();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "size", "params": [], "body": "                          {\n            return parent.uniqueElements();\n        }", "signature": "@Override\n        public int size()"}]}], "class_docstring": "\nAbstract implementation of the {@link MultiSet} interface to simplify the\ncreation of subclass implementations.\n\n@param <E> the type held in the multiset\n@since 4.1\n", "original_string": "public abstract class AbstractMultiSet<E> extends AbstractCollection<E> implements MultiSet<E> {\n\n    /**\n     * Inner class AbstractEntry.\n     *\n     * @param <E> the element type.\n     */\n    protected abstract static class AbstractEntry<E> implements Entry<E> {\n\n        @Override\n        public boolean equals(final Object object) {\n            if (object instanceof Entry) {\n                final Entry<?> other = (Entry<?>) object;\n                final E element = getElement();\n                final Object otherElement = other.getElement();\n\n                return this.getCount() == other.getCount() &&\n                       Objects.equals(element, otherElement);\n            }\n            return false;\n        }\n\n        @Override\n        public int hashCode() {\n            final E element = getElement();\n            return (element == null ? 0 : element.hashCode()) ^ getCount();\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s:%d\", getElement(), getCount());\n        }\n    }\n\n    /**\n     * Inner class EntrySet.\n     *\n     * @param <E> the element type.\n     */\n    protected static class EntrySet<E> extends AbstractSet<Entry<E>> {\n\n        private final AbstractMultiSet<E> parent;\n\n        /**\n         * Constructs a new view of the MultiSet.\n         *\n         * @param parent  the parent MultiSet\n         */\n        protected EntrySet(final AbstractMultiSet<E> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public boolean contains(final Object obj) {\n            if (!(obj instanceof Entry<?>)) {\n                return false;\n            }\n            final Entry<?> entry = (Entry<?>) obj;\n            final Object element = entry.getElement();\n            return parent.getCount(element) == entry.getCount();\n        }\n\n        @Override\n        public Iterator<Entry<E>> iterator() {\n            return parent.createEntrySetIterator();\n        }\n\n        @Override\n        public boolean remove(final Object obj) {\n            if (!(obj instanceof Entry<?>)) {\n                return false;\n            }\n            final Entry<?> entry = (Entry<?>) obj;\n            final Object element = entry.getElement();\n            if (parent.contains(element)) {\n                final int count = parent.getCount(element);\n                if (entry.getCount() == count) {\n                    parent.remove(element, count);\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        @Override\n        public int size() {\n            return parent.uniqueElements();\n        }\n    }\n\n    /**\n     * Inner class iterator for the MultiSet.\n     */\n    private static final class MultiSetIterator<E> implements Iterator<E> {\n        private final AbstractMultiSet<E> parent;\n        private final Iterator<Entry<E>> entryIterator;\n        private Entry<E> current;\n        private int itemCount;\n        private boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent the parent multiset\n         */\n        MultiSetIterator(final AbstractMultiSet<E> parent) {\n            this.parent = parent;\n            this.entryIterator = parent.entrySet().iterator();\n            this.current = null;\n            this.canRemove = false;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean hasNext() {\n            return itemCount > 0 || entryIterator.hasNext();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public E next() {\n            if (itemCount == 0) {\n                current = entryIterator.next();\n                itemCount = current.getCount();\n            }\n            canRemove = true;\n            itemCount--;\n            return current.getElement();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException();\n            }\n            final int count = current.getCount();\n            if (count > 1) {\n                parent.remove(current.getElement());\n            } else {\n                entryIterator.remove();\n            }\n            canRemove = false;\n        }\n    }\n\n    /**\n     * Inner class UniqueSet.\n     *\n     * @param <E> the element type.\n     */\n    protected static class UniqueSet<E> extends AbstractSet<E> {\n\n        /** The parent multiset */\n        protected final AbstractMultiSet<E> parent;\n\n        /**\n         * Constructs a new unique element view of the MultiSet.\n         *\n         * @param parent  the parent MultiSet\n         */\n        protected UniqueSet(final AbstractMultiSet<E> parent) {\n            this.parent = parent;\n        }\n\n        @Override\n        public void clear() {\n            parent.clear();\n        }\n\n        @Override\n        public boolean contains(final Object key) {\n            return parent.contains(key);\n        }\n\n        @Override\n        public boolean containsAll(final Collection<?> coll) {\n            return parent.containsAll(coll);\n        }\n\n        @Override\n        public Iterator<E> iterator() {\n            return parent.createUniqueSetIterator();\n        }\n\n        @Override\n        public boolean remove(final Object key) {\n            return parent.remove(key, parent.getCount(key)) != 0;\n        }\n\n        @Override\n        public int size() {\n            return parent.uniqueElements();\n        }\n    }\n\n    /** View of the elements */\n    private transient Set<E> uniqueSet;\n\n    /** View of the entries */\n    private transient Set<Entry<E>> entrySet;\n\n    /**\n     * Constructor needed for subclass serialisation.\n     */\n    protected AbstractMultiSet() {\n    }\n\n    @Override\n    public boolean add(final E object) {\n        add(object, 1);\n        return true;\n    }\n\n    @Override\n    public int add(final E object, final int occurrences) {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Clears the multiset removing all elements from the entrySet.\n     */\n    @Override\n    public void clear() {\n        final Iterator<Entry<E>> it = entrySet().iterator();\n        while (it.hasNext()) {\n            it.next();\n            it.remove();\n        }\n    }\n\n    /**\n     * Determines if the multiset contains the given element.\n     *\n     * @param object the object to search for\n     * @return true if the multiset contains the given element\n     */\n    @Override\n    public boolean contains(final Object object) {\n        return getCount(object) > 0;\n    }\n\n    /**\n     * Create a new view for the set of entries in this multiset.\n     *\n     * @return a view of the set of entries\n     */\n    protected Set<Entry<E>> createEntrySet() {\n        return new EntrySet<>(this);\n    }\n\n    /**\n     * Creates an entry set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the entrySet iterator\n     */\n    protected abstract Iterator<Entry<E>> createEntrySetIterator();\n\n    /**\n     * Create a new view for the set of unique elements in this multiset.\n     *\n     * @return a view of the set of unique elements\n     */\n    protected Set<E> createUniqueSet() {\n        return new UniqueSet<>(this);\n    }\n\n    /**\n     * Creates a unique set iterator.\n     * Subclasses can override this to return iterators with different properties.\n     *\n     * @return the uniqueSet iterator\n     */\n    protected Iterator<E> createUniqueSetIterator() {\n        final Transformer<Entry<E>, E> transformer = Entry::getElement;\n        return IteratorUtils.transformedIterator(entrySet().iterator(), transformer);\n    }\n\n    /**\n     * Read the multiset in using a custom routine.\n     * @param in the input stream\n     * @throws IOException any of the usual I/O related exceptions\n     * @throws ClassNotFoundException if the stream contains an object which class can not be loaded\n     * @throws ClassCastException if the stream does not contain the correct objects\n     */\n    protected void doReadObject(final ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n        final int entrySize = in.readInt();\n        for (int i = 0; i < entrySize; i++) {\n            @SuppressWarnings(\"unchecked\") // This will fail at runtime if the stream is incorrect\n            final E obj = (E) in.readObject();\n            final int count = in.readInt();\n            setCount(obj, count);\n        }\n    }\n\n    /**\n     * Write the multiset out using a custom routine.\n     * @param out the output stream\n     * @throws IOException any of the usual I/O related exceptions\n     */\n    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n        out.writeInt(entrySet().size());\n        for (final Entry<E> entry : entrySet()) {\n            out.writeObject(entry.getElement());\n            out.writeInt(entry.getCount());\n        }\n    }\n\n    /**\n     * Returns an unmodifiable view of the entries of this multiset.\n     *\n     * @return the set of entries in this multiset\n     */\n    @Override\n    public Set<Entry<E>> entrySet() {\n        if (entrySet == null) {\n            entrySet = createEntrySet();\n        }\n        return entrySet;\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof MultiSet)) {\n            return false;\n        }\n        final MultiSet<?> other = (MultiSet<?>) object;\n        if (other.size() != size()) {\n            return false;\n        }\n        for (final Entry<E> entry : entrySet()) {\n            if (other.getCount(entry.getElement()) != getCount(entry.getElement())) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the number of occurrence of the given element in this multiset by\n     * iterating over its entrySet.\n     *\n     * @param object the object to search for\n     * @return the number of occurrences of the object, zero if not found\n     */\n    @Override\n    public int getCount(final Object object) {\n        for (final Entry<E> entry : entrySet()) {\n            final E element = entry.getElement();\n            if (Objects.equals(element, object)) {\n                return entry.getCount();\n            }\n        }\n        return 0;\n    }\n\n    @Override\n    public int hashCode() {\n        return entrySet().hashCode();\n    }\n\n    /**\n     * Gets an iterator over the multiset elements. Elements present in the\n     * MultiSet more than once will be returned repeatedly.\n     *\n     * @return the iterator\n     */\n    @Override\n    public Iterator<E> iterator() {\n        return new MultiSetIterator<>(this);\n    }\n\n    @Override\n    public boolean remove(final Object object) {\n        return remove(object, 1) != 0;\n    }\n\n    @Override\n    public int remove(final Object object, final int occurrences) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean removeAll(final Collection<?> coll) {\n        boolean result = false;\n        for (final Object obj : coll) {\n            final boolean changed = remove(obj, getCount(obj)) != 0;\n            result = result || changed;\n        }\n        return result;\n    }\n\n    @Override\n    public int setCount(final E object, final int count) {\n        if (count < 0) {\n            throw new IllegalArgumentException(\"Count must not be negative.\");\n        }\n\n        final int oldCount = getCount(object);\n        if (oldCount < count) {\n            add(object, count - oldCount);\n        } else {\n            remove(object, oldCount - count);\n        }\n        return oldCount;\n    }\n\n    /**\n     * Returns the number of elements in this multiset.\n     *\n     * @return current size of the multiset\n     */\n    @Override\n    public int size() {\n        int totalSize = 0;\n        for (final Entry<E> entry : entrySet()) {\n            totalSize += entry.getCount();\n        }\n        return totalSize;\n    }\n\n    /**\n     * Implement a toString() method suitable for debugging.\n     *\n     * @return a debugging toString\n     */\n    @Override\n    public String toString() {\n        return entrySet().toString();\n    }\n\n    /**\n     * Returns the number of unique elements in this multiset.\n     *\n     * @return the number of unique elements\n     */\n    protected abstract int uniqueElements();\n\n    /**\n     * Returns a view of the unique elements of this multiset.\n     *\n     * @return the set of unique elements in this multiset\n     */\n    @Override\n    public Set<E> uniqueSet() {\n        if (uniqueSet == null) {\n            uniqueSet = createUniqueSet();\n        }\n        return uniqueSet;\n    }\n\n}", "super_interfaces": ["MultiSet<E>"], "fields": [{"attribute_expression": "private transient Set<E> uniqueSet;", "docstring": " View of the elements", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Set<E>", "name": "uniqueSet", "syntax_pass": true}, {"attribute_expression": "private transient Set<Entry<E>> entrySet;", "docstring": " View of the entries", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Set<Entry<E>>", "name": "entrySet", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet", "name": "AbstractMapMultiSet", "file_path": "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java", "superclasses": "", "methods": ["[]AbstractMapMultiSet()", "[]AbstractMapMultiSet(Map<E, MutableInteger>)", "[int]add(E,int)", "[void]clear()", "[boolean]contains(Object)", "[Iterator<Entry<E>>]createEntrySetIterator()", "[Iterator<E>]createUniqueSetIterator()", "[void]doReadObject(ObjectInputStream)", "[void]doWriteObject(ObjectOutputStream)", "[boolean]equals(Object)", "[int]getCount(Object)", "[Map<E, MutableInteger>]getMap()", "[int]hashCode()", "[boolean]isEmpty()", "[Iterator<E>]iterator()", "[int]remove(Object,int)", "[void]setMap(Map<E, MutableInteger>)", "[int]size()", "[Object[]]toArray()", "[T[]]toArray(T[])", "[int]uniqueElements()"], "method_uris": ["src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[]AbstractMapMultiSet()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[]AbstractMapMultiSet(Map<E, MutableInteger>)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[int]add(E,int)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[void]clear()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[boolean]contains(Object)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[Iterator<Entry<E>>]createEntrySetIterator()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[Iterator<E>]createUniqueSetIterator()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[void]doReadObject(ObjectInputStream)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[void]doWriteObject(ObjectOutputStream)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[int]getCount(Object)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[Map<E, MutableInteger>]getMap()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[int]hashCode()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[int]remove(Object,int)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[void]setMap(Map<E, MutableInteger>)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[int]size()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[Object[]]toArray()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[T[]]toArray(T[])", "src/main/java/org/apache/commons/collections4/multiset/AbstractMapMultiSet.java.AbstractMapMultiSet.[int]uniqueElements()"], "overrides": null, "attributes": [{"original_string": "    protected static class EntrySetIterator<E> implements Iterator<Entry<E>> {\n\n        /** The parent map */\n        protected final AbstractMapMultiSet<E> parent;\n\n        /**\n         * The source Iterator.\n         */\n        protected final Iterator<Map.Entry<E, MutableInteger>> decorated;\n\n        /** The last returned entry */\n        protected Entry<E> last;\n\n        /** Whether remove is allowed at present */\n        protected boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         * @param decorated  the iterator to decorate\n         * @param parent  the parent multiset\n         */\n        protected EntrySetIterator(final Iterator<Map.Entry<E, MutableInteger>> decorated,\n                                   final AbstractMapMultiSet<E> parent) {\n            this.decorated = decorated;\n            this.parent = parent;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return decorated.hasNext();\n        }\n\n        @Override\n        public Entry<E> next() {\n            last = new MultiSetEntry<>(decorated.next());\n            canRemove = true;\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            decorated.remove();\n            last = null;\n            canRemove = false;\n        }\n    }", "definition": "    protected static class EntrySetIterator<E> implements Iterator<Entry<E>>", "class_docstring": "\nInner class EntrySetIterator.\n\n@param <E> the element type.\n", "name": "EntrySetIterator", "super_interfaces": ["Iterator<Entry<E>>"], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected final AbstractMapMultiSet<E> parent;", "docstring": " The parent map", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "AbstractMapMultiSet<E>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "protected final Iterator<Map.Entry<E, MutableInteger>> decorated;", "docstring": "\nThe source Iterator.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Iterator<Map.Entry<E, MutableInteger>>", "name": "decorated", "syntax_pass": true}, {"attribute_expression": "protected Entry<E> last;", "docstring": " The last returned entry", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Entry<E>", "name": "last", "syntax_pass": true}, {"attribute_expression": "protected boolean canRemove;", "docstring": " Whether remove is allowed at present", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "canRemove", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected EntrySetIterator(final Iterator<Map.Entry<E, MutableInteger>> decorated,\n                                   final AbstractMapMultiSet<E> parent) {\n            this.decorated = decorated;\n            this.parent = parent;\n        }", "docstring": "\nConstructs a new instance.\n@param decorated  the iterator to decorate\n@param parent  the parent multiset\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "EntrySetIterator", "params": [{"name": "decorated", "type": "Iterator<Map.Entry<E, MutableInteger>>"}, {"name": "parent", "type": "AbstractMapMultiSet<E>"}], "body": "                                                                        {\n            this.decorated = decorated;\n            this.parent = parent;\n        }", "signature": "protected EntrySetIterator(final Iterator<Map.Entry<E, MutableInteger>> decorated,\n                                   final AbstractMapMultiSet<E> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return decorated.hasNext();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return decorated.hasNext();\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Entry<E> next() {\n            last = new MultiSetEntry<>(decorated.next());\n            canRemove = true;\n            return last;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Entry<E>", "classes": []}, "name": "next", "params": [], "body": "                               {\n            last = new MultiSetEntry<>(decorated.next());\n            canRemove = true;\n            return last;\n        }", "signature": "@Override\n        public Entry<E> next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            decorated.remove();\n            last = null;\n            canRemove = false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            decorated.remove();\n            last = null;\n            canRemove = false;\n        }", "signature": "@Override\n        public void remove()"}]}, {"original_string": "    private static final class MapBasedMultiSetIterator<E> implements Iterator<E> {\n        private final AbstractMapMultiSet<E> parent;\n        private final Iterator<Map.Entry<E, MutableInteger>> entryIterator;\n        private Map.Entry<E, MutableInteger> current;\n        private int itemCount;\n        private final int mods;\n        private boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent the parent multiset\n         */\n        MapBasedMultiSetIterator(final AbstractMapMultiSet<E> parent) {\n            this.parent = parent;\n            this.entryIterator = parent.map.entrySet().iterator();\n            this.current = null;\n            this.mods = parent.modCount;\n            this.canRemove = false;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean hasNext() {\n            return itemCount > 0 || entryIterator.hasNext();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public E next() {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (itemCount == 0) {\n                current = entryIterator.next();\n                itemCount = current.getValue().value;\n            }\n            canRemove = true;\n            itemCount--;\n            return current.getKey();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void remove() {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (!canRemove) {\n                throw new IllegalStateException();\n            }\n            final MutableInteger mut = current.getValue();\n            if (mut.value > 1) {\n                mut.value--;\n            } else {\n                entryIterator.remove();\n            }\n            parent.size--;\n            canRemove = false;\n        }\n    }", "definition": "    private static final class MapBasedMultiSetIterator<E> implements Iterator<E>", "class_docstring": "\nInner class iterator for the MultiSet.\n", "name": "MapBasedMultiSetIterator", "super_interfaces": ["Iterator<E>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final AbstractMapMultiSet<E> parent;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AbstractMapMultiSet<E>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "private final Iterator<Map.Entry<E, MutableInteger>> entryIterator;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Iterator<Map.Entry<E, MutableInteger>>", "name": "entryIterator", "syntax_pass": true}, {"attribute_expression": "private Map.Entry<E, MutableInteger> current;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Map.Entry<E, MutableInteger>", "name": "current", "syntax_pass": true}, {"attribute_expression": "private int itemCount;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "itemCount", "syntax_pass": true}, {"attribute_expression": "private final int mods;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "mods", "syntax_pass": true}, {"attribute_expression": "private boolean canRemove;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "canRemove", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        MapBasedMultiSetIterator(final AbstractMapMultiSet<E> parent) {\n            this.parent = parent;\n            this.entryIterator = parent.map.entrySet().iterator();\n            this.current = null;\n            this.mods = parent.modCount;\n            this.canRemove = false;\n        }", "docstring": "\nConstructs a new instance.\n\n@param parent the parent multiset\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MapBasedMultiSetIterator", "params": [{"name": "parent", "type": "AbstractMapMultiSet<E>"}], "body": "                                                                      {\n            this.parent = parent;\n            this.entryIterator = parent.map.entrySet().iterator();\n            this.current = null;\n            this.mods = parent.modCount;\n            this.canRemove = false;\n        }", "signature": "MapBasedMultiSetIterator(final AbstractMapMultiSet<E> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return itemCount > 0 || entryIterator.hasNext();\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return itemCount > 0 || entryIterator.hasNext();\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E next() {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (itemCount == 0) {\n                current = entryIterator.next();\n                itemCount = current.getValue().value;\n            }\n            canRemove = true;\n            itemCount--;\n            return current.getKey();\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "next", "params": [], "body": "                        {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (itemCount == 0) {\n                current = entryIterator.next();\n                itemCount = current.getValue().value;\n            }\n            canRemove = true;\n            itemCount--;\n            return current.getKey();\n        }", "signature": "@Override\n        public E next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (!canRemove) {\n                throw new IllegalStateException();\n            }\n            final MutableInteger mut = current.getValue();\n            if (mut.value > 1) {\n                mut.value--;\n            } else {\n                entryIterator.remove();\n            }\n            parent.size--;\n            canRemove = false;\n        }", "docstring": " {@inheritDoc}", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (!canRemove) {\n                throw new IllegalStateException();\n            }\n            final MutableInteger mut = current.getValue();\n            if (mut.value > 1) {\n                mut.value--;\n            } else {\n                entryIterator.remove();\n            }\n            parent.size--;\n            canRemove = false;\n        }", "signature": "@Override\n        public void remove()"}]}, {"original_string": "    protected static class MultiSetEntry<E> extends AbstractEntry<E> {\n\n        /**\n         * The parent entry.\n         */\n        protected final Map.Entry<E, MutableInteger> parentEntry;\n\n        /**\n         * Constructs a new instance.\n         * @param parentEntry  the entry to decorate\n         */\n        protected MultiSetEntry(final Map.Entry<E, MutableInteger> parentEntry) {\n            this.parentEntry = parentEntry;\n        }\n\n        @Override\n        public int getCount() {\n            return parentEntry.getValue().value;\n        }\n\n        @Override\n        public E getElement() {\n            return parentEntry.getKey();\n        }\n    }", "definition": "    protected static class MultiSetEntry<E> extends AbstractEntry<E>", "class_docstring": "\nInner class MultiSetEntry.\n\n@param <E> the key type.\n", "name": "MultiSetEntry", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected final Map.Entry<E, MutableInteger> parentEntry;", "docstring": "\nThe parent entry.\n", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "Map.Entry<E, MutableInteger>", "name": "parentEntry", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected MultiSetEntry(final Map.Entry<E, MutableInteger> parentEntry) {\n            this.parentEntry = parentEntry;\n        }", "docstring": "\nConstructs a new instance.\n@param parentEntry  the entry to decorate\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "MultiSetEntry", "params": [{"name": "parentEntry", "type": "Map.Entry<E, MutableInteger>"}], "body": "                                                                                {\n            this.parentEntry = parentEntry;\n        }", "signature": "protected MultiSetEntry(final Map.Entry<E, MutableInteger> parentEntry)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int getCount() {\n            return parentEntry.getValue().value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "getCount", "params": [], "body": "                              {\n            return parentEntry.getValue().value;\n        }", "signature": "@Override\n        public int getCount()"}, {"syntax_pass": true, "original_string": "        @Override\n        public E getElement() {\n            return parentEntry.getKey();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "getElement", "params": [], "body": "                              {\n            return parentEntry.getKey();\n        }", "signature": "@Override\n        public E getElement()"}]}, {"original_string": "    protected static class MutableInteger {\n        /** The value of this mutable. */\n        protected int value;\n\n        /**\n         * Constructs a new instance.\n         * @param value the initial value\n         */\n        MutableInteger(final int value) {\n            this.value = value;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (!(obj instanceof MutableInteger)) {\n                return false;\n            }\n            return ((MutableInteger) obj).value == value;\n        }\n\n        @Override\n        public int hashCode() {\n            return value;\n        }\n    }", "definition": "    protected static class MutableInteger", "class_docstring": "\nMutable integer class for storing the data.\n", "name": "MutableInteger", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected int value;", "docstring": " The value of this mutable.", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        MutableInteger(final int value) {\n            this.value = value;\n        }", "docstring": "\nConstructs a new instance.\n@param value the initial value\n", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "MutableInteger", "params": [{"name": "value", "type": "int"}], "body": "                                        {\n            this.value = value;\n        }", "signature": "MutableInteger(final int value)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(final Object obj) {\n            if (!(obj instanceof MutableInteger)) {\n                return false;\n            }\n            return ((MutableInteger) obj).value == value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "obj", "type": "Object"}], "body": "                                                {\n            if (!(obj instanceof MutableInteger)) {\n                return false;\n            }\n            return ((MutableInteger) obj).value == value;\n        }", "signature": "@Override\n        public boolean equals(final Object obj)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return value;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return value;\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    protected static class UniqueSetIterator<E> extends AbstractIteratorDecorator<E> {\n\n        /** The parent multiset */\n        protected final AbstractMapMultiSet<E> parent;\n\n        /** The last returned element */\n        protected E lastElement;\n\n        /** Whether remove is allowed at present */\n        protected boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         * @param iterator  the iterator to decorate\n         * @param parent  the parent multiset\n         */\n        protected UniqueSetIterator(final Iterator<E> iterator, final AbstractMapMultiSet<E> parent) {\n            super(iterator);\n            this.parent = parent;\n        }\n\n        @Override\n        public E next() {\n            lastElement = super.next();\n            canRemove = true;\n            return lastElement;\n        }\n\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            final int count = parent.getCount(lastElement);\n            super.remove();\n            parent.remove(lastElement, count);\n            lastElement = null;\n            canRemove = false;\n        }\n    }", "definition": "    protected static class UniqueSetIterator<E> extends AbstractIteratorDecorator<E>", "class_docstring": "\nInner class UniqueSetIterator.\n\n@param <E> the element type.\n", "name": "UniqueSetIterator", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "protected final AbstractMapMultiSet<E> parent;", "docstring": " The parent multiset", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "AbstractMapMultiSet<E>", "name": "parent", "syntax_pass": true}, {"attribute_expression": "protected E lastElement;", "docstring": " The last returned element", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "E", "name": "lastElement", "syntax_pass": true}, {"attribute_expression": "protected boolean canRemove;", "docstring": " Whether remove is allowed at present", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "boolean", "name": "canRemove", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected UniqueSetIterator(final Iterator<E> iterator, final AbstractMapMultiSet<E> parent) {\n            super(iterator);\n            this.parent = parent;\n        }", "docstring": "\nConstructs a new instance.\n@param iterator  the iterator to decorate\n@param parent  the parent multiset\n", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "UniqueSetIterator", "params": [{"name": "iterator", "type": "Iterator<E>"}, {"name": "parent", "type": "AbstractMapMultiSet<E>"}], "body": "                                                                                                     {\n            super(iterator);\n            this.parent = parent;\n        }", "signature": "protected UniqueSetIterator(final Iterator<E> iterator, final AbstractMapMultiSet<E> parent)"}, {"syntax_pass": true, "original_string": "        @Override\n        public E next() {\n            lastElement = super.next();\n            canRemove = true;\n            return lastElement;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "E", "classes": []}, "name": "next", "params": [], "body": "                        {\n            lastElement = super.next();\n            canRemove = true;\n            return lastElement;\n        }", "signature": "@Override\n        public E next()"}, {"syntax_pass": true, "original_string": "        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            final int count = parent.getCount(lastElement);\n            super.remove();\n            parent.remove(lastElement, count);\n            lastElement = null;\n            canRemove = false;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "remove", "params": [], "body": "                             {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            final int count = parent.getCount(lastElement);\n            super.remove();\n            parent.remove(lastElement, count);\n            lastElement = null;\n            canRemove = false;\n        }", "signature": "@Override\n        public void remove()"}]}], "class_docstring": "\nAbstract implementation of the {@link MultiSet} interface to simplify the\ncreation of subclass implementations.\n<p>\nSubclasses specify a Map implementation to use as the internal storage. The\nmap will be used to map multiset elements to a number; the number represents the\nnumber of occurrences of that element in the multiset.\n</p>\n\n@param <E> the type held in the multiset.\n@since 4.1\n", "original_string": "public abstract class AbstractMapMultiSet<E> extends AbstractMultiSet<E> {\n\n    /**\n     * Inner class EntrySetIterator.\n     *\n     * @param <E> the element type.\n     */\n    protected static class EntrySetIterator<E> implements Iterator<Entry<E>> {\n\n        /** The parent map */\n        protected final AbstractMapMultiSet<E> parent;\n\n        /**\n         * The source Iterator.\n         */\n        protected final Iterator<Map.Entry<E, MutableInteger>> decorated;\n\n        /** The last returned entry */\n        protected Entry<E> last;\n\n        /** Whether remove is allowed at present */\n        protected boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         * @param decorated  the iterator to decorate\n         * @param parent  the parent multiset\n         */\n        protected EntrySetIterator(final Iterator<Map.Entry<E, MutableInteger>> decorated,\n                                   final AbstractMapMultiSet<E> parent) {\n            this.decorated = decorated;\n            this.parent = parent;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return decorated.hasNext();\n        }\n\n        @Override\n        public Entry<E> next() {\n            last = new MultiSetEntry<>(decorated.next());\n            canRemove = true;\n            return last;\n        }\n\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            decorated.remove();\n            last = null;\n            canRemove = false;\n        }\n    }\n    /**\n     * Inner class iterator for the MultiSet.\n     */\n    private static final class MapBasedMultiSetIterator<E> implements Iterator<E> {\n        private final AbstractMapMultiSet<E> parent;\n        private final Iterator<Map.Entry<E, MutableInteger>> entryIterator;\n        private Map.Entry<E, MutableInteger> current;\n        private int itemCount;\n        private final int mods;\n        private boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         *\n         * @param parent the parent multiset\n         */\n        MapBasedMultiSetIterator(final AbstractMapMultiSet<E> parent) {\n            this.parent = parent;\n            this.entryIterator = parent.map.entrySet().iterator();\n            this.current = null;\n            this.mods = parent.modCount;\n            this.canRemove = false;\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean hasNext() {\n            return itemCount > 0 || entryIterator.hasNext();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public E next() {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (itemCount == 0) {\n                current = entryIterator.next();\n                itemCount = current.getValue().value;\n            }\n            canRemove = true;\n            itemCount--;\n            return current.getKey();\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public void remove() {\n            if (parent.modCount != mods) {\n                throw new ConcurrentModificationException();\n            }\n            if (!canRemove) {\n                throw new IllegalStateException();\n            }\n            final MutableInteger mut = current.getValue();\n            if (mut.value > 1) {\n                mut.value--;\n            } else {\n                entryIterator.remove();\n            }\n            parent.size--;\n            canRemove = false;\n        }\n    }\n\n    /**\n     * Inner class MultiSetEntry.\n     *\n     * @param <E> the key type.\n     */\n    protected static class MultiSetEntry<E> extends AbstractEntry<E> {\n\n        /**\n         * The parent entry.\n         */\n        protected final Map.Entry<E, MutableInteger> parentEntry;\n\n        /**\n         * Constructs a new instance.\n         * @param parentEntry  the entry to decorate\n         */\n        protected MultiSetEntry(final Map.Entry<E, MutableInteger> parentEntry) {\n            this.parentEntry = parentEntry;\n        }\n\n        @Override\n        public int getCount() {\n            return parentEntry.getValue().value;\n        }\n\n        @Override\n        public E getElement() {\n            return parentEntry.getKey();\n        }\n    }\n\n    /**\n     * Mutable integer class for storing the data.\n     */\n    protected static class MutableInteger {\n        /** The value of this mutable. */\n        protected int value;\n\n        /**\n         * Constructs a new instance.\n         * @param value the initial value\n         */\n        MutableInteger(final int value) {\n            this.value = value;\n        }\n\n        @Override\n        public boolean equals(final Object obj) {\n            if (!(obj instanceof MutableInteger)) {\n                return false;\n            }\n            return ((MutableInteger) obj).value == value;\n        }\n\n        @Override\n        public int hashCode() {\n            return value;\n        }\n    }\n\n    /**\n     * Inner class UniqueSetIterator.\n     *\n     * @param <E> the element type.\n     */\n    protected static class UniqueSetIterator<E> extends AbstractIteratorDecorator<E> {\n\n        /** The parent multiset */\n        protected final AbstractMapMultiSet<E> parent;\n\n        /** The last returned element */\n        protected E lastElement;\n\n        /** Whether remove is allowed at present */\n        protected boolean canRemove;\n\n        /**\n         * Constructs a new instance.\n         * @param iterator  the iterator to decorate\n         * @param parent  the parent multiset\n         */\n        protected UniqueSetIterator(final Iterator<E> iterator, final AbstractMapMultiSet<E> parent) {\n            super(iterator);\n            this.parent = parent;\n        }\n\n        @Override\n        public E next() {\n            lastElement = super.next();\n            canRemove = true;\n            return lastElement;\n        }\n\n        @Override\n        public void remove() {\n            if (!canRemove) {\n                throw new IllegalStateException(\"Iterator remove() can only be called once after next()\");\n            }\n            final int count = parent.getCount(lastElement);\n            super.remove();\n            parent.remove(lastElement, count);\n            lastElement = null;\n            canRemove = false;\n        }\n    }\n\n    /** The map to use to store the data */\n    private transient Map<E, MutableInteger> map;\n\n    /** The current total size of the multiset */\n    private transient int size;\n\n    /** The modification count for fail fast iterators */\n    private transient int modCount;\n\n    /**\n     * Constructor needed for subclass serialisation.\n     */\n    protected AbstractMapMultiSet() {\n    }\n\n    /**\n     * Constructor that assigns the specified Map as the backing store. The map\n     * must be empty and non-null.\n     *\n     * @param map the map to assign\n     */\n    protected AbstractMapMultiSet(final Map<E, MutableInteger> map) {\n        this.map = map;\n    }\n\n    @Override\n    public int add(final E object, final int occurrences) {\n        if (occurrences < 0) {\n            throw new IllegalArgumentException(\"Occurrences must not be negative.\");\n        }\n\n        final MutableInteger mut = map.get(object);\n        final int oldCount = mut != null ? mut.value : 0;\n\n        if (occurrences > 0) {\n            modCount++;\n            size += occurrences;\n            if (mut == null) {\n                map.put(object, new MutableInteger(occurrences));\n            } else {\n                mut.value += occurrences;\n            }\n        }\n        return oldCount;\n    }\n\n    /**\n     * Clears the multiset by clearing the underlying map.\n     */\n    @Override\n    public void clear() {\n        modCount++;\n        map.clear();\n        size = 0;\n    }\n\n    /**\n     * Determines if the multiset contains the given element by checking if the\n     * underlying map contains the element as a key.\n     *\n     * @param object the object to search for\n     * @return true if the multiset contains the given element\n     */\n    @Override\n    public boolean contains(final Object object) {\n        return map.containsKey(object);\n    }\n\n    @Override\n    protected Iterator<Entry<E>> createEntrySetIterator() {\n        return new EntrySetIterator<>(map.entrySet().iterator(), this);\n    }\n\n    @Override\n    protected Iterator<E> createUniqueSetIterator() {\n        return new UniqueSetIterator<>(getMap().keySet().iterator(), this);\n    }\n\n    /**\n     * Read the multiset in using a custom routine.\n     * @param in the input stream\n     * @throws IOException any of the usual I/O related exceptions\n     * @throws ClassNotFoundException if the stream contains an object which class can not be loaded\n     * @throws ClassCastException if the stream does not contain the correct objects\n     */\n    @Override\n    protected void doReadObject(final ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n        final int entrySize = in.readInt();\n        for (int i = 0; i < entrySize; i++) {\n            @SuppressWarnings(\"unchecked\") // This will fail at runtime if the stream is incorrect\n            final E obj = (E) in.readObject();\n            final int count = in.readInt();\n            map.put(obj, new MutableInteger(count));\n            size += count;\n        }\n    }\n\n    /**\n     * Write the multiset out using a custom routine.\n     * @param out the output stream\n     * @throws IOException any of the usual I/O related exceptions\n     */\n    @Override\n    protected void doWriteObject(final ObjectOutputStream out) throws IOException {\n        out.writeInt(map.size());\n        for (final Map.Entry<E, MutableInteger> entry : map.entrySet()) {\n            out.writeObject(entry.getKey());\n            out.writeInt(entry.getValue().value);\n        }\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof MultiSet)) {\n            return false;\n        }\n        final MultiSet<?> other = (MultiSet<?>) object;\n        if (other.size() != size()) {\n            return false;\n        }\n        for (final E element : map.keySet()) {\n            if (other.getCount(element) != getCount(element)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns the number of occurrence of the given element in this multiset by\n     * looking up its count in the underlying map.\n     *\n     * @param object the object to search for\n     * @return the number of occurrences of the object, zero if not found\n     */\n    @Override\n    public int getCount(final Object object) {\n        final MutableInteger count = map.get(object);\n        if (count != null) {\n            return count.value;\n        }\n        return 0;\n    }\n\n    /**\n     * Utility method for implementations to access the map that backs this multiset.\n     * Not intended for interactive use outside of subclasses.\n     *\n     * @return the map being used by the MultiSet\n     */\n    protected Map<E, MutableInteger> getMap() {\n        return map;\n    }\n\n    @Override\n    public int hashCode() {\n        int total = 0;\n        for (final Map.Entry<E, MutableInteger> entry : map.entrySet()) {\n            final E element = entry.getKey();\n            final MutableInteger count = entry.getValue();\n            total += (element == null ? 0 : element.hashCode()) ^ count.value;\n        }\n        return total;\n    }\n\n    /**\n     * Returns true if the underlying map is empty.\n     *\n     * @return true if multiset is empty\n     */\n    @Override\n    public boolean isEmpty() {\n        return map.isEmpty();\n    }\n\n    /**\n     * Gets an iterator over the multiset elements. Elements present in the\n     * MultiSet more than once will be returned repeatedly.\n     *\n     * @return the iterator\n     */\n    @Override\n    public Iterator<E> iterator() {\n        return new MapBasedMultiSetIterator<>(this);\n    }\n\n    @Override\n    public int remove(final Object object, final int occurrences) {\n        if (occurrences < 0) {\n            throw new IllegalArgumentException(\"Occurrences must not be negative.\");\n        }\n\n        final MutableInteger mut = map.get(object);\n        if (mut == null) {\n            return 0;\n        }\n        final int oldCount = mut.value;\n        if (occurrences > 0) {\n            modCount++;\n            if (occurrences < mut.value) {\n                mut.value -= occurrences;\n                size -= occurrences;\n            } else {\n                map.remove(object);\n                size -= mut.value;\n                mut.value = 0;\n            }\n        }\n        return oldCount;\n    }\n\n    /**\n     * Sets the map being wrapped.\n     * <p>\n     * <b>NOTE:</b> this method should only be used during deserialization\n     *\n     * @param map the map to wrap\n     */\n    protected void setMap(final Map<E, MutableInteger> map) {\n        this.map = map;\n    }\n\n    /**\n     * Returns the number of elements in this multiset.\n     *\n     * @return current size of the multiset\n     */\n    @Override\n    public int size() {\n        return size;\n    }\n\n    /**\n     * Returns an array of all of this multiset's elements.\n     *\n     * @return an array of all of this multiset's elements\n     */\n    @Override\n    public Object[] toArray() {\n        final Object[] result = new Object[size()];\n        int i = 0;\n        for (final Map.Entry<E, MutableInteger> entry : map.entrySet()) {\n            final E current = entry.getKey();\n            final MutableInteger count = entry.getValue();\n            for (int index = count.value; index > 0; index--) {\n                result[i++] = current;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Returns an array of all of this multiset's elements.\n     * If the input array has more elements than are in the multiset,\n     * trailing elements will be set to null.\n     *\n     * @param <T> the type of the array elements\n     * @param array the array to populate\n     * @return an array of all of this multiset's elements\n     * @throws ArrayStoreException if the runtime type of the specified array is not\n     *   a supertype of the runtime type of the elements in this list\n     * @throws NullPointerException if the specified array is null\n     */\n    @Override\n    public <T> T[] toArray(T[] array) {\n        final int size = size();\n        if (array.length < size) {\n            @SuppressWarnings(\"unchecked\") // safe as both are of type T\n            final T[] unchecked = (T[]) Array.newInstance(array.getClass().getComponentType(), size);\n            array = unchecked;\n        }\n\n        int i = 0;\n        for (final Map.Entry<E, MutableInteger> entry : map.entrySet()) {\n            final E current = entry.getKey();\n            final MutableInteger count = entry.getValue();\n            for (int index = count.value; index > 0; index--) {\n                // unsafe, will throw ArrayStoreException if types are not compatible, see Javadoc\n                @SuppressWarnings(\"unchecked\")\n                final T unchecked = (T) current;\n                array[i++] = unchecked;\n            }\n        }\n        while (i < array.length) {\n            array[i++] = null;\n        }\n        return array;\n    }\n\n    @Override\n    protected int uniqueElements() {\n        return map.size();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private transient Map<E, MutableInteger> map;", "docstring": " The map to use to store the data", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "Map<E, MutableInteger>", "name": "map", "syntax_pass": true}, {"attribute_expression": "private transient int size;", "docstring": " The current total size of the multiset", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "size", "syntax_pass": true}, {"attribute_expression": "private transient int modCount;", "docstring": " The modification count for fail fast iterators", "modifiers": "private transient", "marker_annotations": [], "non_marker_annotations": ["private", "transient"], "comments": [], "type": "int", "name": "modCount", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java.AbstractMultiSetDecorator", "name": "AbstractMultiSetDecorator", "file_path": "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java", "superclasses": "", "methods": ["[]AbstractMultiSetDecorator()", "[]AbstractMultiSetDecorator(MultiSet<E>)", "[int]add(E,int)", "[MultiSet<E>]decorated()", "[Set<Entry<E>>]entrySet()", "[boolean]equals(Object)", "[int]getCount(Object)", "[int]hashCode()", "[int]remove(Object,int)", "[int]setCount(E,int)", "[Set<E>]uniqueSet()"], "method_uris": ["src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java.AbstractMultiSetDecorator.[]AbstractMultiSetDecorator()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java.AbstractMultiSetDecorator.[]AbstractMultiSetDecorator(MultiSet<E>)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java.AbstractMultiSetDecorator.[int]add(E,int)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java.AbstractMultiSetDecorator.[MultiSet<E>]decorated()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java.AbstractMultiSetDecorator.[Set<Entry<E>>]entrySet()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java.AbstractMultiSetDecorator.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java.AbstractMultiSetDecorator.[int]getCount(Object)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java.AbstractMultiSetDecorator.[int]hashCode()", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java.AbstractMultiSetDecorator.[int]remove(Object,int)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java.AbstractMultiSetDecorator.[int]setCount(E,int)", "src/main/java/org/apache/commons/collections4/multiset/AbstractMultiSetDecorator.java.AbstractMultiSetDecorator.[Set<E>]uniqueSet()"], "overrides": null, "attributes": [], "class_docstring": "\nDecorates another {@code MultiSet} to provide additional behavior.\n<p>\nMethods are forwarded directly to the decorated multiset.\n</p>\n\n@param <E> the type held in the multiset\n@since 4.1\n", "original_string": "public abstract class AbstractMultiSetDecorator<E>\n        extends AbstractCollectionDecorator<E> implements MultiSet<E> {\n\n    /** Serialization version */\n    private static final long serialVersionUID = 20150610L;\n\n    /**\n     * Constructor only used in deserialization, do not use otherwise.\n     */\n    protected AbstractMultiSetDecorator() {\n    }\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param multiset  the multiset to decorate, must not be null\n     * @throws NullPointerException if multiset is null\n     */\n    protected AbstractMultiSetDecorator(final MultiSet<E> multiset) {\n        super(multiset);\n    }\n\n    @Override\n    public int add(final E object, final int count) {\n        return decorated().add(object, count);\n    }\n\n    /**\n     * Gets the multiset being decorated.\n     *\n     * @return the decorated multiset\n     */\n    @Override\n    protected MultiSet<E> decorated() {\n        return (MultiSet<E>) super.decorated();\n    }\n\n    @Override\n    public Set<Entry<E>> entrySet() {\n        return decorated().entrySet();\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        return object == this || decorated().equals(object);\n    }\n\n    @Override\n    public int getCount(final Object object) {\n        return decorated().getCount(object);\n    }\n\n    @Override\n    public int hashCode() {\n        return decorated().hashCode();\n    }\n\n    @Override\n    public int remove(final Object object, final int count) {\n        return decorated().remove(object, count);\n    }\n\n    @Override\n    public int setCount(final E object, final int count) {\n        return decorated().setCount(object, count);\n    }\n\n    @Override\n    public Set<E> uniqueSet() {\n        return decorated().uniqueSet();\n    }\n\n}", "super_interfaces": ["MultiSet<E>"], "fields": [{"attribute_expression": "private static final long serialVersionUID = 20150610L;", "docstring": " Serialization version", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 20150610L", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java.AbstractMapEntryDecorator", "name": "AbstractMapEntryDecorator", "file_path": "src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java", "superclasses": "", "methods": ["[]AbstractMapEntryDecorator(Map.Entry<K, V>)", "[boolean]equals(Object)", "[K]getKey()", "[Map.Entry<K, V>]getMapEntry()", "[V]getValue()", "[int]hashCode()", "[V]setValue(V)", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java.AbstractMapEntryDecorator.[]AbstractMapEntryDecorator(Map.Entry<K, V>)", "src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java.AbstractMapEntryDecorator.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java.AbstractMapEntryDecorator.[K]getKey()", "src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java.AbstractMapEntryDecorator.[Map.Entry<K, V>]getMapEntry()", "src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java.AbstractMapEntryDecorator.[V]getValue()", "src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java.AbstractMapEntryDecorator.[int]hashCode()", "src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java.AbstractMapEntryDecorator.[V]setValue(V)", "src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntryDecorator.java.AbstractMapEntryDecorator.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nProvides a base decorator that allows additional functionality to be\nadded to a {@link java.util.Map.Entry Map.Entry}.\n\n@param <K> the type of keys\n@param <V> the type of mapped values\n@since 3.0\n", "original_string": "public abstract class AbstractMapEntryDecorator<K, V> implements Map.Entry<K, V>, KeyValue<K, V> {\n\n    /** The {@code Map.Entry} to decorate */\n    private final Map.Entry<K, V> entry;\n\n    /**\n     * Constructor that wraps (not copies).\n     *\n     * @param entry  the {@code Map.Entry} to decorate, must not be null\n     * @throws NullPointerException if the collection is null\n     */\n    public AbstractMapEntryDecorator(final Map.Entry<K, V> entry) {\n        this.entry = Objects.requireNonNull(entry, \"entry\");\n    }\n\n    @Override\n    public boolean equals(final Object object) {\n        if (object == this) {\n            return true;\n        }\n        return entry.equals(object);\n    }\n\n    @Override\n    public K getKey() {\n        return entry.getKey();\n    }\n\n    /**\n     * Gets the map being decorated.\n     *\n     * @return the decorated map\n     */\n    protected Map.Entry<K, V> getMapEntry() {\n        return entry;\n    }\n\n    @Override\n    public V getValue() {\n        return entry.getValue();\n    }\n\n    @Override\n    public int hashCode() {\n        return entry.hashCode();\n    }\n\n    @Override\n    public V setValue(final V value) {\n        return entry.setValue(value);\n    }\n\n    @Override\n    public String toString() {\n        return entry.toString();\n    }\n\n}", "super_interfaces": ["Map.Entry<K, V>", "KeyValue<K, V>"], "fields": [{"attribute_expression": "private final Map.Entry<K, V> entry;", "docstring": " The {@code Map.Entry} to decorate", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map.Entry<K, V>", "name": "entry", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntry.java.AbstractMapEntry", "name": "AbstractMapEntry", "file_path": "src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntry.java", "superclasses": "", "methods": ["[]AbstractMapEntry(K,V)", "[boolean]equals(Object)", "[int]hashCode()", "[V]setValue(V)"], "method_uris": ["src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntry.java.AbstractMapEntry.[]AbstractMapEntry(K,V)", "src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntry.java.AbstractMapEntry.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntry.java.AbstractMapEntry.[int]hashCode()", "src/main/java/org/apache/commons/collections4/keyvalue/AbstractMapEntry.java.AbstractMapEntry.[V]setValue(V)"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract Pair class to assist with creating correct\n{@link java.util.Map.Entry Map.Entry} implementations.\n\n@param <K> the type of keys\n@param <V> the type of mapped values\n@since 3.0\n", "original_string": "public abstract class AbstractMapEntry<K, V> extends AbstractKeyValue<K, V> implements Map.Entry<K, V> {\n\n    /**\n     * Constructs a new entry with the given key and given value.\n     *\n     * @param key  the key for the entry, may be null\n     * @param value  the value for the entry, may be null\n     */\n    protected AbstractMapEntry(final K key, final V value) {\n        super(key, value);\n    }\n\n    /**\n     * Compares this {@code Map.Entry} with another {@code Map.Entry}.\n     * <p>\n     * Implemented per API documentation of {@link java.util.Map.Entry#equals(Object)}\n     *\n     * @param obj  the object to compare to\n     * @return true if equal key and value\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Map.Entry)) {\n            return false;\n        }\n        final Map.Entry<?, ?> other = (Map.Entry<?, ?>) obj;\n        return\n            (getKey() == null ? other.getKey() == null : getKey().equals(other.getKey())) &&\n            (getValue() == null ? other.getValue() == null : getValue().equals(other.getValue()));\n    }\n\n    /**\n     * Gets a hashCode compatible with the equals method.\n     * <p>\n     * Implemented per API documentation of {@link java.util.Map.Entry#hashCode()}\n     *\n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return (getKey() == null ? 0 : getKey().hashCode()) ^\n               (getValue() == null ? 0 : getValue().hashCode());\n    }\n\n    /**\n     * Sets the value stored in this {@code Map.Entry}.\n     * <p>\n     * This {@code Map.Entry} is not connected to a Map, so only the\n     * local data is changed.\n     *\n     * @param value  the new value\n     * @return the previous value\n     */\n    @Override\n    public V setValue(final V value) { // NOPMD\n        return super.setValue(value);\n    }\n\n}", "super_interfaces": ["Map.Entry<K, V>"], "fields": []}, {"uris": "src/main/java/org/apache/commons/collections4/keyvalue/AbstractKeyValue.java.AbstractKeyValue", "name": "AbstractKeyValue", "file_path": "src/main/java/org/apache/commons/collections4/keyvalue/AbstractKeyValue.java", "superclasses": "", "methods": ["[]AbstractKeyValue(K,V)", "[K]getKey()", "[V]getValue()", "[K]setKey(K)", "[V]setValue(V)", "[String]toString()"], "method_uris": ["src/main/java/org/apache/commons/collections4/keyvalue/AbstractKeyValue.java.AbstractKeyValue.[]AbstractKeyValue(K,V)", "src/main/java/org/apache/commons/collections4/keyvalue/AbstractKeyValue.java.AbstractKeyValue.[K]getKey()", "src/main/java/org/apache/commons/collections4/keyvalue/AbstractKeyValue.java.AbstractKeyValue.[V]getValue()", "src/main/java/org/apache/commons/collections4/keyvalue/AbstractKeyValue.java.AbstractKeyValue.[K]setKey(K)", "src/main/java/org/apache/commons/collections4/keyvalue/AbstractKeyValue.java.AbstractKeyValue.[V]setValue(V)", "src/main/java/org/apache/commons/collections4/keyvalue/AbstractKeyValue.java.AbstractKeyValue.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract pair class to assist with creating {@code KeyValue}\nand {@link java.util.Map.Entry Map.Entry} implementations.\n\n@param <K> the type of keys\n@param <V> the type of values\n@since 3.0\n", "original_string": "public abstract class AbstractKeyValue<K, V> implements KeyValue<K, V> {\n\n    /** The key */\n    private K key;\n    /** The value */\n    private V value;\n\n    /**\n     * Constructs a new pair with the specified key and given value.\n     *\n     * @param key  the key for the entry, may be null\n     * @param value  the value for the entry, may be null\n     */\n    protected AbstractKeyValue(final K key, final V value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    /**\n     * Gets the key from the pair.\n     *\n     * @return the key\n     */\n    @Override\n    public K getKey() {\n        return key;\n    }\n\n    /**\n     * Gets the value from the pair.\n     *\n     * @return the value\n     */\n    @Override\n    public V getValue() {\n        return value;\n    }\n\n    /**\n     * Sets the key.\n     *\n     * @param key The key.\n     * @return The previous key.\n     */\n    protected K setKey(final K key) {\n        final K old = this.key;\n        this.key = key;\n        return old;\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @param value The value.\n     * @return The previous value.\n     */\n    protected V setValue(final V value) {\n        final V old = this.value;\n        this.value = value;\n        return old;\n    }\n\n    /**\n     * Gets a debugging String view of the pair.\n     *\n     * @return a String view of the entry\n     */\n    @Override\n    public String toString() {\n        return new StringBuilder()\n            .append(getKey())\n            .append('=')\n            .append(getValue())\n            .toString();\n    }\n\n}", "super_interfaces": ["KeyValue<K, V>"], "fields": [{"attribute_expression": "private K key;", "docstring": " The key", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "K", "name": "key", "syntax_pass": true}, {"attribute_expression": "private V value;", "docstring": " The value", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "V", "name": "value", "syntax_pass": true}]}]