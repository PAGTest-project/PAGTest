[{"uris": "src/main/java/org/apache/commons/collections4/Closure.java.Closure", "name": "Closure", "file_path": "src/main/java/org/apache/commons/collections4/Closure.java", "superclasses": ["Consumer<T>"], "methods": ["[void]accept(T)", "[void]execute(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/Closure.java.Closure.[void]accept(T)", "src/main/java/org/apache/commons/collections4/Closure.java.Closure.[void]execute(T)"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a functor interface implemented by classes that do something.\n<p>\nA {@code Closure} represents a block of code which is executed from\ninside some block, function or iteration. It operates an input object.\n</p>\n<p>\nStandard implementations of common closures are provided by\n{@link ClosureUtils}. These include method invocation and for/while loops.\n</p>\n\n@param <T> the type of the input to the operation.\n@since 1.0\n@deprecated Use {@link Consumer}.\n", "original_string": "@Deprecated\npublic interface Closure<T> extends Consumer<T> {\n\n    @Override\n    default void accept(final T input) {\n        execute(input);\n    }\n\n    /**\n     * Performs an action on the specified input object.\n     *\n     * @param input  the input to execute on\n     * @throws ClassCastException (runtime) if the input is the wrong class\n     * @throws IllegalArgumentException (runtime) if the input is invalid\n     * @throws FunctorException (runtime) if any other error occurs\n     */\n    void execute(T input);\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/KeyValue.java.KeyValue", "name": "KeyValue", "file_path": "src/main/java/org/apache/commons/collections4/KeyValue.java", "superclasses": [], "methods": ["[K]getKey()", "[V]getValue()"], "method_uris": ["src/main/java/org/apache/commons/collections4/KeyValue.java.KeyValue.[K]getKey()", "src/main/java/org/apache/commons/collections4/KeyValue.java.KeyValue.[V]getValue()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a simple key value pair.\n<p>\nA Map Entry has considerable additional semantics over and above a simple\nkey-value pair. This interface defines the minimum key value, with just the\ntwo get methods.\n</p>\n\n@param <K> the type of the key\n@param <V> the type of the value\n@since 3.0\n", "original_string": "public interface KeyValue<K, V> {\n\n    /**\n     * Gets the key from the pair.\n     *\n     * @return the key\n     */\n    K getKey();\n\n    /**\n     * Gets the value from the pair.\n     *\n     * @return the value\n     */\n    V getValue();\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/IterableSortedMap.java.IterableSortedMap", "name": "IterableSortedMap", "file_path": "src/main/java/org/apache/commons/collections4/IterableSortedMap.java", "superclasses": ["SortedMap<K, V>", "OrderedMap<K, V>"], "methods": [], "method_uris": [], "overrides": null, "attributes": null, "class_docstring": "\n{@link SortedMap} + {@link OrderedMap}.\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n\n@since 4.0\n", "original_string": "public interface IterableSortedMap<K, V> extends SortedMap<K, V>, OrderedMap<K, V> {\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/SetValuedMap.java.SetValuedMap", "name": "SetValuedMap", "file_path": "src/main/java/org/apache/commons/collections4/SetValuedMap.java", "superclasses": ["MultiValuedMap<K, V>"], "methods": ["[Set<V>]get(K)", "[Set<V>]remove(Object)"], "method_uris": ["src/main/java/org/apache/commons/collections4/SetValuedMap.java.SetValuedMap.[Set<V>]get(K)", "src/main/java/org/apache/commons/collections4/SetValuedMap.java.SetValuedMap.[Set<V>]remove(Object)"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a map that holds a set of values against each key.\n<p>\nA {@code SetValuedMap} is a Map with slightly different semantics:\n</p>\n<ul>\n  <li>Putting a value into the map will add the value to a {@link Set} at that key.</li>\n  <li>Getting a value will return a {@link Set}, holding all the values put to that key.</li>\n</ul>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.1\n", "original_string": "public interface SetValuedMap<K, V> extends MultiValuedMap<K, V> {\n\n    /**\n     * Gets the set of values associated with the specified key.\n     * <p>\n     * Implementations typically return an empty {@code Set} if no values\n     * have been mapped to the key.\n     * </p>\n     *\n     * @param key  the key to retrieve\n     * @return the {@code Set} of values, implementations should return an\n     *   empty {@code Set} for no mapping\n     * @throws NullPointerException if the key is null and null keys are invalid\n     */\n    @Override\n    Set<V> get(K key);\n\n    /**\n     * Removes all values associated with the specified key.\n     * <p>\n     * The returned set <em>may</em> be modifiable, but updates will not be\n     * propagated to this set-valued map. In case no mapping was stored for the\n     * specified key, an empty, unmodifiable set will be returned.\n     * </p>\n     *\n     * @param key  the key to remove values from\n     * @return the {@code Set} of values removed, implementations should\n     *   return null for no mapping found, but may return an empty collection\n     * @throws UnsupportedOperationException if the map is unmodifiable\n     * @throws NullPointerException if the key is null and null keys are invalid\n     */\n    @Override\n    Set<V> remove(Object key);\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/Equator.java.Equator", "name": "Equator", "file_path": "src/main/java/org/apache/commons/collections4/Equator.java", "superclasses": [], "methods": ["[boolean]equate(T,T)", "[int]hash(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/Equator.java.Equator.[boolean]equate(T,T)", "src/main/java/org/apache/commons/collections4/Equator.java.Equator.[int]hash(T)"], "overrides": null, "attributes": null, "class_docstring": "\nAn equation function, which determines equality between objects of type T.\n<p>\nIt is the functional sibling of {@link java.util.Comparator}; {@link Equator} is to\n{@link Object} as {@link java.util.Comparator} is to {@link Comparable}.\n</p>\n\n@param <T> the types of object this {@link Equator} can evaluate.\n@since 4.0\n", "original_string": "public interface Equator<T> {\n    /**\n     * Evaluates the two arguments for their equality.\n     *\n     * @param o1 the first object to be equated.\n     * @param o2 the second object to be equated.\n     * @return whether the two objects are equal.\n     */\n    boolean equate(T o1, T o2);\n\n    /**\n     * Calculates the hash for the object, based on the method of equality used in the equate\n     * method. This is used for classes that delegate their {@link Object#equals(Object) equals(Object)} method to an\n     * Equator (and so must also delegate their {@link Object#hashCode() hashCode()} method), or for implementations\n     * of {@link org.apache.commons.collections4.map.HashedMap} that use an Equator for the key objects.\n     *\n     * @param o the object to calculate the hash for.\n     * @return the hash of the object.\n     */\n    int hash(T o);\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/Get.java.Get", "name": "Get", "file_path": "src/main/java/org/apache/commons/collections4/Get.java", "superclasses": [], "methods": ["[boolean]containsKey(Object)", "[boolean]containsValue(Object)", "[Set<java.util.Map.Entry<K, V>>]entrySet()", "[V]get(Object)", "[boolean]isEmpty()", "[Set<K>]keySet()", "[V]remove(Object)", "[int]size()", "[Collection<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/Get.java.Get.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/Get.java.Get.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/Get.java.Get.[Set<java.util.Map.Entry<K, V>>]entrySet()", "src/main/java/org/apache/commons/collections4/Get.java.Get.[V]get(Object)", "src/main/java/org/apache/commons/collections4/Get.java.Get.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/Get.java.Get.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/Get.java.Get.[V]remove(Object)", "src/main/java/org/apache/commons/collections4/Get.java.Get.[int]size()", "src/main/java/org/apache/commons/collections4/Get.java.Get.[Collection<V>]values()"], "overrides": null, "attributes": null, "class_docstring": "\nThe \"read\" subset of the {@link java.util.Map} interface.\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n\n@since 4.0\n@see Put\n", "original_string": "public interface Get<K, V> {\n\n    /**\n     * @param key key whose presence in this map is to be tested\n     * @return {@code true} if this map contains a mapping for the specified\n     *         key\n     * @see java.util.Map#containsKey(Object)\n     */\n    boolean containsKey(Object key);\n\n    /**\n     * @param value value whose presence in this map is to be tested\n     * @return {@code true} if this map maps one or more keys to the\n     *         specified value\n     * @see java.util.Map#containsValue(Object)\n     */\n    boolean containsValue(Object value);\n\n    /**\n     * @return a set view of the mappings contained in this map\n     * @see java.util.Map#entrySet()\n     */\n    Set<java.util.Map.Entry<K, V>> entrySet();\n\n    /**\n     * @param key the key whose associated value is to be returned\n     * @return the value to which the specified key is mapped, or\n     *         {@code null} if this map contains no mapping for the key\n     * @see java.util.Map#get(Object)\n     */\n    V get(Object key);\n\n    /**\n     * @return {@code true} if this map contains no key-value mappings\n     * @see java.util.Map#isEmpty()\n     */\n    boolean isEmpty();\n\n    /**\n     * @return a set view of the keys contained in this map\n     * @see java.util.Map#keySet()\n     */\n    Set<K> keySet();\n\n    /**\n     * @param key key whose mapping is to be removed from the map\n     * @return the previous value associated with {@code key}, or\n     *         {@code null} if there was no mapping for {@code key}.\n     * @see java.util.Map#remove(Object)\n     */\n    V remove(Object key);\n\n    /**\n     * @return the number of key-value mappings in this map\n     * @see java.util.Map#size()\n     */\n    int size();\n\n    /**\n     * @return a collection view of the values contained in this map\n     * @see java.util.Map#values()\n     */\n    Collection<V> values();\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/IterableMap.java.IterableMap", "name": "IterableMap", "file_path": "src/main/java/org/apache/commons/collections4/IterableMap.java", "superclasses": ["Map<K, V>", "Put<K, V>", "IterableGet<K, V>"], "methods": [], "method_uris": [], "overrides": null, "attributes": null, "class_docstring": "\nDefines a map that can be iterated directly without needing to create an entry set.\n<p>\nA map iterator is an efficient way of iterating over maps.\nThere is no need to access the entry set or use Map Entry objects.\n</p>\n<pre>\nIterableMap&lt;String,Integer&gt; map = new HashedMap&lt;String,Integer&gt;();\nMapIterator&lt;String,Integer&gt; it = map.mapIterator();\nwhile (it.hasNext()) {\n  String key = it.next();\n  Integer value = it.getValue();\n  it.setValue(value + 1);\n}\n</pre>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n\n@since 3.0\n", "original_string": "public interface IterableMap<K, V> extends Map<K, V>, Put<K, V>, IterableGet<K, V> {\n    // empty\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/ListValuedMap.java.ListValuedMap", "name": "ListValuedMap", "file_path": "src/main/java/org/apache/commons/collections4/ListValuedMap.java", "superclasses": ["MultiValuedMap<K, V>"], "methods": ["[List<V>]get(K)", "[List<V>]remove(Object)"], "method_uris": ["src/main/java/org/apache/commons/collections4/ListValuedMap.java.ListValuedMap.[List<V>]get(K)", "src/main/java/org/apache/commons/collections4/ListValuedMap.java.ListValuedMap.[List<V>]remove(Object)"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a map that holds a list of values against each key.\n<p>\nA {@code ListValuedMap} is a Map with slightly different semantics:\n</p>\n<ul>\n  <li>Putting a value into the map will add the value to a {@link List} at that key.</li>\n  <li>Getting a value will return a {@link List}, holding all the values put to that key.</li>\n</ul>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.1\n", "original_string": "public interface ListValuedMap<K, V> extends MultiValuedMap<K, V> {\n\n    /**\n     * Gets the list of values associated with the specified key.\n     * <p>\n     * This method will return an <b>empty</b> list if\n     * {@link #containsKey(Object)} returns {@code false}. Changes to the\n     * returned list will update the underlying {@code ListValuedMap} and\n     * vice-versa.\n     *\n     * @param key  the key to retrieve\n     * @return the {@code List} of values, implementations should return an\n     *   empty {@code List} for no mapping\n     * @throws NullPointerException if the key is null and null keys are invalid\n     */\n    @Override\n    List<V> get(K key);\n\n    /**\n     * Removes all values associated with the specified key.\n     * <p>\n     * The returned list <em>may</em> be modifiable, but updates will not be\n     * propagated to this list-valued map. In case no mapping was stored for the\n     * specified key, an empty, unmodifiable list will be returned.\n     *\n     * @param key  the key to remove values from\n     * @return the {@code List} of values removed, implementations\n     *   typically return an empty, unmodifiable {@code List} for no mapping found\n     * @throws UnsupportedOperationException if the map is unmodifiable\n     * @throws NullPointerException if the key is null and null keys are invalid\n     */\n    @Override\n    List<V> remove(Object key);\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/Transformer.java.Transformer", "name": "Transformer", "file_path": "src/main/java/org/apache/commons/collections4/Transformer.java", "superclasses": ["Function<T, R>"], "methods": ["[R]apply(T)", "[R]transform(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/Transformer.java.Transformer.[R]apply(T)", "src/main/java/org/apache/commons/collections4/Transformer.java.Transformer.[R]transform(T)"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a functor interface implemented by classes that transform one\nobject into another.\n<p>\nA {@code Transformer} converts the input object to the output object.\nThe input object SHOULD be left unchanged.\nTransformers are typically used for type conversions, or extracting data\nfrom an object.\n</p>\n<p>\nStandard implementations of common transformers are provided by\n{@link TransformerUtils}. These include method invocation, returning a constant,\ncloning and returning the string value.\n</p>\n\n@param <T> the type of the input to the function.\n@param <R> the type of the result of the function.\n\n@since 1.0\n@deprecated Use {@link Function}.\n", "original_string": "@Deprecated\n@FunctionalInterface\npublic interface Transformer<T, R> extends Function<T, R> {\n\n    @Override\n    default R apply(final T t) {\n        return transform(t);\n    }\n\n    /**\n     * Transforms the input object into some output object.\n     * <p>\n     * The input object SHOULD be left unchanged.\n     * </p>\n     *\n     * @param input  the object to be transformed, should be left unchanged\n     * @return a transformed object\n     * @throws ClassCastException (runtime) if the input is the wrong class\n     * @throws IllegalArgumentException (runtime) if the input is invalid\n     * @throws FunctorException (runtime) if the transform cannot be completed\n     */\n    R transform(T input);\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/SortedBag.java.SortedBag", "name": "SortedBag", "file_path": "src/main/java/org/apache/commons/collections4/SortedBag.java", "superclasses": ["Bag<E>"], "methods": ["[Comparator<? super E>]comparator()", "[E]first()", "[E]last()"], "method_uris": ["src/main/java/org/apache/commons/collections4/SortedBag.java.SortedBag.[Comparator<? super E>]comparator()", "src/main/java/org/apache/commons/collections4/SortedBag.java.SortedBag.[E]first()", "src/main/java/org/apache/commons/collections4/SortedBag.java.SortedBag.[E]last()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a type of {@code Bag} that maintains a sorted order among\nits unique representative members.\n\n@param <E> the type of elements in this bag\n@since 2.0\n", "original_string": "public interface SortedBag<E> extends Bag<E> {\n\n    /**\n     * Returns the comparator associated with this sorted set, or null\n     * if it uses its elements' natural ordering.\n     *\n     * @return the comparator in use, or null if natural ordering\n     */\n    Comparator<? super E> comparator();\n\n    /**\n     * Returns the first (lowest) member.\n     *\n     * @return the first element in the sorted bag\n     */\n    E first();\n\n    /**\n     * Returns the last (highest) member.\n     *\n     * @return the last element in the sorted bag\n     */\n    E last();\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/SortedBidiMap.java.SortedBidiMap", "name": "SortedBidiMap", "file_path": "src/main/java/org/apache/commons/collections4/SortedBidiMap.java", "superclasses": ["OrderedBidiMap<K, V>", "SortedMap<K, V>"], "methods": ["[SortedBidiMap<V, K>]inverseBidiMap()", "[Comparator<? super V>]valueComparator()"], "method_uris": ["src/main/java/org/apache/commons/collections4/SortedBidiMap.java.SortedBidiMap.[SortedBidiMap<V, K>]inverseBidiMap()", "src/main/java/org/apache/commons/collections4/SortedBidiMap.java.SortedBidiMap.[Comparator<? super V>]valueComparator()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a map that allows bidirectional lookup between key and values\nand retains both keys and values in sorted order.\n<p>\nImplementations should allow a value to be looked up from a key and\na key to be looked up from a value with equal performance.\n</p>\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n@since 3.0\n", "original_string": "public interface SortedBidiMap<K, V> extends OrderedBidiMap<K, V>, SortedMap<K, V> {\n\n    /**\n     * Gets a view of this map where the keys and values are reversed.\n     * <p>\n     * Changes to one map will be visible in the other and vice versa.\n     * This enables both directions of the map to be accessed equally.\n     * <p>\n     * Implementations should seek to avoid creating a new object every time this\n     * method is called. See {@code AbstractMap.values()} etc. Calling this\n     * method on the inverse map should return the original.\n     * <p>\n     * Implementations must return a {@code SortedBidiMap} instance,\n     * usually by forwarding to {@code inverseSortedBidiMap()}.\n     *\n     * @return an inverted bidirectional map\n     */\n    @Override\n    SortedBidiMap<V, K> inverseBidiMap();\n\n    /**\n     * Gets the comparator used for the values in the value-to-key map aspect.\n     * @return Comparator&lt;? super V&gt;\n     */\n    Comparator<? super V> valueComparator();\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/OrderedBidiMap.java.OrderedBidiMap", "name": "OrderedBidiMap", "file_path": "src/main/java/org/apache/commons/collections4/OrderedBidiMap.java", "superclasses": ["BidiMap<K, V>", "OrderedMap<K, V>"], "methods": ["[OrderedBidiMap<V, K>]inverseBidiMap()"], "method_uris": ["src/main/java/org/apache/commons/collections4/OrderedBidiMap.java.OrderedBidiMap.[OrderedBidiMap<V, K>]inverseBidiMap()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a map that allows bidirectional lookup between key and values\nand retains and provides access to an ordering.\n<p>\nImplementations should allow a value to be looked up from a key and\na key to be looked up from a value with equal performance.\n</p>\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n\n@since 3.0\n", "original_string": "public interface OrderedBidiMap<K, V> extends BidiMap<K, V>, OrderedMap<K, V> {\n\n    /**\n     * Gets a view of this map where the keys and values are reversed.\n     * <p>\n     * Changes to one map will be visible in the other and vice versa.\n     * This enables both directions of the map to be accessed equally.\n     * <p>\n     * Implementations should seek to avoid creating a new object every time this\n     * method is called. See {@code AbstractMap.values()} etc. Calling this\n     * method on the inverse map should return the original.\n     * <p>\n     * Implementations must return an {@code OrderedBidiMap} instance,\n     * usually by forwarding to {@code inverseOrderedBidiMap()}.\n     *\n     * @return an inverted bidirectional map\n     */\n    @Override\n    OrderedBidiMap<V, K> inverseBidiMap();\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap", "name": "MultiValuedMap", "file_path": "src/main/java/org/apache/commons/collections4/MultiValuedMap.java", "superclasses": [], "methods": ["[Map<K, Collection<V>>]asMap()", "[void]clear()", "[boolean]containsKey(Object)", "[boolean]containsMapping(Object,Object)", "[boolean]containsValue(Object)", "[Collection<Entry<K, V>>]entries()", "[Collection<V>]get(K)", "[boolean]isEmpty()", "[MultiSet<K>]keys()", "[Set<K>]keySet()", "[MapIterator<K, V>]mapIterator()", "[boolean]put(K,V)", "[boolean]putAll(K,Iterable<? extends V>)", "[boolean]putAll(Map<? extends K, ? extends V>)", "[boolean]putAll(MultiValuedMap<? extends K, ? extends V>)", "[Collection<V>]remove(Object)", "[boolean]removeMapping(Object,Object)", "[int]size()", "[Collection<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[Map<K, Collection<V>>]asMap()", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[void]clear()", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[boolean]containsKey(Object)", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[boolean]containsMapping(Object,Object)", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[Collection<Entry<K, V>>]entries()", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[Collection<V>]get(K)", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[MultiSet<K>]keys()", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[Set<K>]keySet()", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[MapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[boolean]put(K,V)", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[boolean]putAll(K,Iterable<? extends V>)", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[boolean]putAll(Map<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[boolean]putAll(MultiValuedMap<? extends K, ? extends V>)", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[Collection<V>]remove(Object)", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[boolean]removeMapping(Object,Object)", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[int]size()", "src/main/java/org/apache/commons/collections4/MultiValuedMap.java.MultiValuedMap.[Collection<V>]values()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a map that holds a collection of values against each key.\n<p>\nA {@code MultiValuedMap} is a Map with slightly different semantics:\n</p>\n<ul>\n  <li>Putting a value into the map will add the value to a {@link Collection} at that key.</li>\n  <li>Getting a value will return a {@link Collection}, holding all the values put to that key.</li>\n</ul>\n<p>\nFor example:\n</p>\n<pre>{@code\nMultiValuedMap<Integer, String> map = new ArrayListValuedHashMap<>();\nmap.put(1, \"A\");\nmap.put(1, \"B\");\nmap.put(1, \"C\");\nCollection<String> coll = map.get(1);\n}</pre>\n<p>\n{@code coll} will be a collection containing \"A\", \"B\", \"C\".\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.1\n", "original_string": "public interface MultiValuedMap<K, V> {\n    // Query operations\n\n    /**\n     * Returns a view of this multivalued map as a {@code Map} from each distinct\n     * key to the non-empty collection of that key's associated values.\n     * <p>\n     * Note that {@code this.asMap().get(k)} is equivalent to {@code this.get(k)}\n     * only when {@code k} is a key contained in the multivalued map; otherwise it\n     * returns {@code null} as opposed to an empty collection.\n     * </p>\n     * <p>\n     * Changes to the returned map or the collections that serve as its values\n     * will update the underlying multivalued map, and vice versa. The map does\n     * not support {@code put} or {@code putAll}, nor do its entries support\n     * {@link java.util.Map.Entry#setValue(Object) setValue}.\n     * </p>\n     *\n     * @return a map view of the mappings in this multivalued map\n     */\n    Map<K, Collection<V>> asMap();\n\n    /**\n     * Removes all of the mappings from this map (optional operation).\n     * <p>\n     * The map will be empty after this call returns.\n     * </p>\n     *\n     * @throws UnsupportedOperationException if the map is unmodifiable\n     */\n    void clear();\n\n    /**\n     * Returns {@code true} if this map contains a mapping for the specified\n     * key. More formally, returns {@code true} if and only if this map contains\n     * a mapping for a key {@code k} such that {@code (key==null ? k==null : key.equals(k))}.\n     * (There can be at most one such mapping.)\n     *\n     * @param key  key whose presence in this map is to be tested\n     * @return true if this map contains a mapping for the specified key\n     * @throws NullPointerException if the specified key is null and this map\n     *   does not permit null keys (optional)\n     */\n    boolean containsKey(Object key);\n\n    /**\n     * Checks whether the map contains a mapping for the specified key and value.\n     *\n     * @param key  the key to search for\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     */\n    boolean containsMapping(Object key, Object value);\n\n    /**\n     * Checks whether the map contains at least one mapping for the specified value.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     * @throws NullPointerException if the value is null and null values are not supported\n     *   by the used collection types (optional)\n     */\n    boolean containsValue(Object value);\n\n    /**\n     * Returns a {@link Collection} view of the mappings contained in this multivalued map.\n     * <p>\n     * The collection is backed by the map, so changes to the map are reflected\n     * in the collection, and vice-versa.\n     * </p>\n     *\n     * @return a set view of the mappings contained in this map\n     */\n    Collection<Entry<K, V>> entries();\n\n    // Modification operations\n\n    /**\n     * Returns a view collection of the values associated with the specified key.\n     * <p>\n     * This method will return an <b>empty</b> collection if {@link #containsKey(Object)}\n     * returns {@code false}. Changes to the returned collection will update the underlying\n     * {@code MultiValuedMap} and vice-versa.\n     * </p>\n     *\n     * @param key  the key to retrieve\n     * @return the {@code Collection} of values, implementations should\n     *   return an empty collection for no mapping\n     * @throws NullPointerException if the key is null and null keys are invalid (optional)\n     */\n    Collection<V> get(K key);\n\n    /**\n     * Returns {@code true} if this map contains no key-value mappings.\n     *\n     * @return {@code true} if this map contains no key-value mappings\n     */\n    boolean isEmpty();\n\n    /**\n     * Returns a {@link MultiSet} view of the keys contained in this multivalued map.\n     * <p>\n     * The {@link MultiSet#getCount(Object)} method of the returned multiset will give\n     * the same result a calling {@code get(Object).size()} for the same key.\n     * </p>\n     * <p>\n     * This multiset is backed by the map, so any changes in the map are reflected in\n     * the multiset.\n     * </p>\n     *\n     * @return a multiset view of the keys contained in this map\n     */\n    MultiSet<K> keys();\n\n    /**\n     * Returns a {@link Set} view of the keys contained in this multivalued map.\n     * <p>\n     * The set is backed by the map, so changes to the map are reflected\n     * in the set, and vice-versa.\n     * </p>\n     * <p>\n     * If the map is modified while an iteration over the set is in\n     * progress (except through the iterator's own {@code remove} operation),\n     * the result of the iteration is undefined. The set supports element\n     * removal, which removes the corresponding mapping from the map, via the\n     * {@code Iterator.remove}, {@code Set.remove}, {@code removeAll},\n     * {@code retainAll}, and {@code clear} operations. It does not support\n     * the {@code add} or {@code addAll} operations.\n     * </p>\n     *\n     * @return a set view of the keys contained in this map\n     */\n    Set<K> keySet();\n\n    /**\n     * Obtains a {@code MapIterator} over this multivalued map.\n     * <p>\n     * A map iterator is an efficient way of iterating over maps. There is no\n     * need to access the entries collection or use {@code Map.Entry} objects.\n     * </p>\n     *\n     * @return a map iterator\n     */\n    MapIterator<K, V> mapIterator();\n\n    /**\n     * Adds a key-value mapping to this multivalued map.\n     * <p>\n     * Unlike a normal {@code Map} the previous value is not replaced.\n     * Instead, the new value is added to the collection stored against the key.\n     * Depending on the collection type used, duplicate key-value mappings may\n     * be allowed.\n     * </p>\n     * <p>\n     * The method will return {@code true} if the size of the multivalued map\n     * has been increased because of this operation.\n     * </p>\n     *\n     * @param key  the key to store against\n     * @param value  the value to add to the collection at the key\n     * @return true if the map changed as a result of this put operation, or false\n     *   if the map already contained the key-value mapping and the collection\n     *   type does not allow duplicate values, e.g. when using a Set\n     * @throws UnsupportedOperationException if the put operation is not supported by\n     *   this multivalued map, e.g. if it is unmodifiable\n     * @throws NullPointerException if the key or value is null and null is invalid (optional)\n     * @throws IllegalArgumentException if some aspect of the specified key or value prevents\n     *   it from being stored in this multivalued map\n     */\n    boolean put(K key, V value);\n\n    /**\n     * Adds a mapping to the specified key for all values contained in the given Iterable.\n     *\n     * @param key  the key to store against\n     * @param values  the values to add to the collection at the key, may not be null\n     * @return true if the map changed as a result of this operation\n     * @throws NullPointerException if the specified iterable is null, or if this map\n     *   does not permit null keys or values, and the specified key or values contain\n     *   null (optional)\n     */\n    boolean putAll(K key, Iterable<? extends V> values);\n\n    // Views\n\n    /**\n     * Copies all mappings from the specified map to this multivalued map\n     * (optional operation).\n     * <p>\n     * The effect of this call is equivalent to that of calling\n     * {@link #put(Object,Object) put(k, v)} on this map once for each mapping\n     * from key {@code k} to value {@code v} in the specified map.\n     * </p>\n     * <p>\n     * The behavior of this operation is undefined if the specified map is modified\n     * while the operation is in progress.\n     * </p>\n     *\n     * @param map  mappings to be stored in this map, may not be null\n     * @return true if the map changed as a result of this operation\n     * @throws UnsupportedOperationException if the {@code putAll} operation is\n     *   not supported by this map\n     * @throws NullPointerException if the specified map is null, or if this map\n     *   does not permit null keys or values, and the specified map\n     *   contains null keys or values (optional)\n     * @throws IllegalArgumentException if some property of a key or value in\n     *   the specified map prevents it from being stored in this map\n     */\n    boolean putAll(Map<? extends K, ? extends V> map);\n\n    /**\n     * Copies all mappings from the specified map to this multivalued map\n     * (optional operation).\n     * <p>\n     * The effect of this call is equivalent to that of calling\n     * {@link #put(Object,Object) put(k, v)} on this map once for each\n     * mapping from key {@code k} to value {@code v} in the specified map.\n     * </p>\n     * <p>\n     * The behavior of this operation is undefined if the specified map is modified\n     * while the operation is in progress.\n     * </p>\n     *\n     * @param map  mappings to be stored in this map, may not be null\n     * @return true if the map changed as a result of this operation\n     * @throws UnsupportedOperationException if the {@code putAll} operation is\n     *   not supported by this map\n     * @throws NullPointerException if the specified map is null, or if this map\n     *   does not permit null keys or values, and the specified map\n     *   contains null keys or values (optional)\n     * @throws IllegalArgumentException if some property of a key or value in\n     *   the specified map prevents it from being stored in this map\n     */\n    boolean putAll(MultiValuedMap<? extends K, ? extends V> map);\n\n    /**\n     * Removes all values associated with the specified key.\n     * <p>\n     * The returned collection <em>may</em> be modifiable, but updates will not be propagated\n     * to this multivalued map. In case no mapping was stored for the specified\n     * key, an empty, unmodifiable collection will be returned.\n     * </p>\n     *\n     * @param key  the key to remove values from\n     * @return the values that were removed\n     * @throws UnsupportedOperationException if the map is unmodifiable\n     * @throws NullPointerException if the key is null and null keys are invalid (optional)\n     */\n    Collection<V> remove(Object key);\n\n    /**\n     * Removes a key-value mapping from the map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * </p>\n     * <p>\n     * If the last value for a key is removed, implementations typically return\n     * an empty collection from a subsequent {@code get(Object)}.\n     * </p>\n     *\n     * @param key  the key to remove from\n     * @param item  the item to remove\n     * @return true if the mapping was removed, false otherwise\n     * @throws UnsupportedOperationException if the map is unmodifiable\n     * @throws NullPointerException if the key or value is null and null is invalid (optional)\n     */\n    boolean removeMapping(Object key, Object item);\n\n    /**\n     * Gets the total size of the map.\n     * <p>\n     * Implementations would return the total size of the map which is the count\n     * of the values from all keys.\n     * </p>\n     *\n     * @return the total size of the map\n     */\n    int size();\n\n    /**\n     * Gets a {@link Collection} view of all values contained in this multivalued map.\n     * <p>\n     * Implementations typically return a collection containing the combination\n     * of values from all keys.\n     * </p>\n     *\n     * @return a collection view of the values contained in this multivalued map\n     */\n    Collection<V> values();\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/OrderedIterator.java.OrderedIterator", "name": "OrderedIterator", "file_path": "src/main/java/org/apache/commons/collections4/OrderedIterator.java", "superclasses": ["Iterator<E>"], "methods": ["[boolean]hasPrevious()", "[E]previous()"], "method_uris": ["src/main/java/org/apache/commons/collections4/OrderedIterator.java.OrderedIterator.[boolean]hasPrevious()", "src/main/java/org/apache/commons/collections4/OrderedIterator.java.OrderedIterator.[E]previous()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines an iterator that operates over an ordered container. Subset of {@link java.util.ListIterator}.\n<p>\nThis iterator allows both forward and reverse iteration through the container.\n</p>\n\n@param <E> the type of elements returned by this iterator.\n@since 3.0\n", "original_string": "public interface OrderedIterator<E> extends Iterator<E> {\n\n    /**\n     * Checks to see if there is a previous element that can be iterated to.\n     *\n     * @return {@code true} if the iterator has a previous element\n     */\n    boolean hasPrevious();\n\n    /**\n     * Gets the previous element from the container.\n     *\n     * @return the previous element in the iteration\n     * @throws java.util.NoSuchElementException if the iteration is finished\n     */\n    E previous();\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/BoundedMap.java.BoundedMap", "name": "BoundedMap", "file_path": "src/main/java/org/apache/commons/collections4/BoundedMap.java", "superclasses": ["IterableMap<K, V>"], "methods": ["[boolean]isFull()", "[int]maxSize()"], "method_uris": ["src/main/java/org/apache/commons/collections4/BoundedMap.java.BoundedMap.[boolean]isFull()", "src/main/java/org/apache/commons/collections4/BoundedMap.java.BoundedMap.[int]maxSize()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a map that is bounded in size.\n<p>\nThe size of the map can vary, but it can never exceed a preset\nmaximum number of elements. This interface allows the querying of details\nassociated with the maximum number of elements.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 3.0\n", "original_string": "public interface BoundedMap<K, V> extends IterableMap<K, V> {\n\n    /**\n     * Returns true if this map is full and no new elements can be added.\n     *\n     * @return {@code true} if the map is full\n     */\n    boolean isFull();\n\n    /**\n     * Gets the maximum size of the map (the bound).\n     *\n     * @return the maximum number of elements the map can hold\n     */\n    int maxSize();\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet", "name": "MultiSet", "file_path": "src/main/java/org/apache/commons/collections4/MultiSet.java", "superclasses": ["Collection<E>"], "methods": ["[boolean]add(E)", "[int]add(E,int)", "[boolean]containsAll(Collection<?>)", "[Set<Entry<E>>]entrySet()", "[boolean]equals(Object)", "[int]getCount(Object)", "[int]hashCode()", "[Iterator<E>]iterator()", "[boolean]remove(Object)", "[int]remove(Object,int)", "[boolean]removeAll(Collection<?>)", "[boolean]retainAll(Collection<?>)", "[int]setCount(E,int)", "[int]size()", "[Set<E>]uniqueSet()"], "method_uris": ["src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet.[int]add(E,int)", "src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet.[boolean]containsAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet.[Set<Entry<E>>]entrySet()", "src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet.[boolean]equals(Object)", "src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet.[int]getCount(Object)", "src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet.[int]hashCode()", "src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet.[int]remove(Object,int)", "src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet.[int]setCount(E,int)", "src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet.[int]size()", "src/main/java/org/apache/commons/collections4/MultiSet.java.MultiSet.[Set<E>]uniqueSet()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a collection that counts the number of times an object appears in\nthe collection.\n<p>\nSuppose you have a MultiSet that contains {@code {a, a, b, c}}.\nCalling {@link #getCount(Object)} on {@code a} would return 2, while\ncalling {@link #uniqueSet()} would return {@code {a, b, c}}.\n</p>\n\n@param <E> the type held in the multiset\n@since 4.1\n", "original_string": "public interface MultiSet<E> extends Collection<E> {\n\n    /**\n     * An unmodifiable entry for an element and its occurrence as contained in a MultiSet.\n     * <p>\n     * The {@link MultiSet#entrySet()} method returns a view of the multiset whose elements\n     * implement this interface.\n     *\n     * @param <E>  the element type\n     */\n    interface Entry<E> {\n\n        /**\n         * Compares the specified object with this entry for equality.\n         * Returns true if the given object is also a multiset entry\n         * and the two entries represent the same element with the same\n         * number of occurrences.\n         * <p>\n         * More formally, two entries {@code e1} and {@code e2} represent\n         * the same mapping if\n         * <pre>\n         *     (e1.getElement()==null ? e2.getElement()==null\n         *                            : e1.getElement().equals(e2.getElement())) &amp;&amp;\n         *     (e1.getCount()==e2.getCount())\n         * </pre>\n         *\n         * @param o object to be compared for equality with this multiset entry\n         * @return true if the specified object is equal to this multiset entry\n         */\n        @Override\n        boolean equals(Object o);\n\n        /**\n         * Returns the number of occurrences for the element of this entry.\n         *\n         * @return the number of occurrences of the element\n         */\n        int getCount();\n\n        /**\n         * Returns the element corresponding to this entry.\n         *\n         * @return the element corresponding to this entry\n         */\n        E getElement();\n\n        /**\n         * Returns the hash code value for this multiset entry.\n         * <p>\n         * The hash code of a multiset entry {@code e} is defined to be:\n         * <pre>\n         *      (e==null ? 0 : e.hashCode()) ^ noOccurrences)\n         * </pre>\n         *\n         * @return the hash code value for this multiset entry\n         */\n        @Override\n        int hashCode();\n    }\n\n    /**\n     * Adds one copy of the specified object to the MultiSet.\n     * <p>\n     * If the object is already in the {@link #uniqueSet()} then increment its\n     * count as reported by {@link #getCount(Object)}. Otherwise, add it to the\n     * {@link #uniqueSet()} and report its count as 1.\n     *\n     * @param object  the object to add\n     * @return {@code true} always, as the size of the MultiSet is increased\n     *   in any case\n     */\n    @Override\n    boolean add(E object);\n\n    /**\n     * Adds a number of occurrences of the specified object to the MultiSet.\n     * <p>\n     * If the object is already in the {@link #uniqueSet()} then increment its\n     * count as reported by {@link #getCount(Object)}. Otherwise, add it to the\n     * {@link #uniqueSet()} and report its count as {@code occurrences}.\n     *\n     * @param object  the object to add\n     * @param occurrences  the number of occurrences to add, may be zero,\n     *   in which case no change is made to the multiset\n     * @return the number of occurrences of the object in the multiset before\n     *   this operation; possibly zero\n     * @throws IllegalArgumentException if occurrences is negative\n     */\n    int add(E object, int occurrences);\n\n    /**\n     * Returns {@code true} if the MultiSet contains at least one\n     * occurrence for each element contained in the given collection.\n     *\n     * @param coll  the collection to check against\n     * @return {@code true} if the MultiSet contains all the collection\n     */\n    @Override\n    boolean containsAll(Collection<?> coll);\n\n    /**\n     * Returns a {@link Set} of all entries contained in the MultiSet.\n     * <p>\n     * The returned set is backed by this multiset, so any change to either\n     * is immediately reflected in the other.\n     *\n     * @return the Set of MultiSet entries\n     */\n    Set<Entry<E>> entrySet();\n\n    /**\n     * Compares this MultiSet to another object.\n     * <p>\n     * This MultiSet equals another object if it is also a MultiSet\n     * that contains the same number of occurrences of the same elements.\n     *\n     * @param obj  the object to compare to\n     * @return true if equal\n     */\n    @Override\n    boolean equals(Object obj);\n\n    /**\n     * Returns the number of occurrences of the given object currently\n     * in the MultiSet. If the object does not exist in the multiset,\n     * return 0.\n     *\n     * @param object  the object to search for\n     * @return the number of occurrences of the object, zero if not found\n     */\n    int getCount(Object object);\n\n    /**\n     * Gets a hash code for the MultiSet compatible with the definition of equals.\n     * The hash code is defined as the sum total of a hash code for each element.\n     * The per element hash code is defined as\n     * {@code (e==null ? 0 : e.hashCode()) ^ noOccurrences)}.\n     *\n     * @return the hash code of the MultiSet\n     */\n    @Override\n    int hashCode();\n\n    /**\n     * Returns an {@link Iterator} over the entire set of members,\n     * including copies due to cardinality. This iterator is fail-fast\n     * and will not tolerate concurrent modifications.\n     *\n     * @return iterator over all elements in the MultiSet\n     */\n    @Override\n    Iterator<E> iterator();\n\n    /**\n     * Removes one occurrence of the given object from the MultiSet.\n     * <p>\n     * If the number of occurrences after this operation is reduced\n     * to zero, the object will be removed from the {@link #uniqueSet()}.\n     *\n     * @param object  the object to remove\n     * @return {@code true} if this call changed the collection\n     */\n    @Override\n    boolean remove(Object object);\n\n    /**\n     * Removes a number of occurrences of the specified object from the MultiSet.\n     * <p>\n     * If the number of occurrences to remove is greater than the actual number of\n     * occurrences in the multiset, the object will be removed from the multiset.\n     *\n     * @param object  the object to remove\n     * @param occurrences  the number of occurrences to remove, may be zero,\n     *   in which case no change is made to the multiset\n     * @return the number of occurrences of the object in the multiset\n     *   before the operation; possibly zero\n     * @throws IllegalArgumentException if occurrences is negative\n     */\n    int remove(Object object, int occurrences);\n\n    /**\n     * Remove all occurrences of all elements from this MultiSet represented\n     * in the given collection.\n     *\n     * @param coll  the collection of elements to remove\n     * @return {@code true} if this call changed the multiset\n     */\n    @Override\n    boolean removeAll(Collection<?> coll);\n\n    /**\n     * Remove any elements of this MultiSet that are not contained in the\n     * given collection.\n     *\n     * @param coll  the collection of elements to retain\n     * @return {@code true} if this call changed the multiset\n     */\n    @Override\n    boolean retainAll(Collection<?> coll);\n\n    /**\n     * Sets the number of occurrences of the specified object in the MultiSet\n     * to the given count.\n     * <p>\n     * If the provided count is zero, the object will be removed from the\n     * {@link #uniqueSet()}.\n     *\n     * @param object  the object to update\n     * @param count  the number of occurrences of the object\n     * @return the number of occurrences of the object before this operation, zero\n     *   if the object was not contained in the multiset\n     * @throws IllegalArgumentException if count is negative\n     */\n    int setCount(E object, int count);\n\n    /**\n     * Returns the total number of items in the MultiSet.\n     *\n     * @return the total size of the multiset\n     */\n    @Override\n    int size();\n\n    /**\n     * Returns a {@link Set} of unique elements in the MultiSet.\n     * <p>\n     * Uniqueness constraints are the same as those in {@link java.util.Set}.\n     * <p>\n     * The returned set is backed by this multiset, so any change to either\n     * is immediately reflected in the other. Only removal operations are\n     * supported, in which case all occurrences of the element are removed\n     * from the backing multiset.\n     *\n     * @return the Set of unique MultiSet elements\n     */\n    Set<E> uniqueSet();\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/MultiMap.java.MultiMap", "name": "MultiMap", "file_path": "src/main/java/org/apache/commons/collections4/MultiMap.java", "superclasses": ["IterableMap<K, Object>"], "methods": ["[boolean]containsValue(Object)", "[Object]get(Object)", "[Object]put(K,Object)", "[Object]remove(Object)", "[boolean]removeMapping(K,V)", "[int]size()", "[Collection<Object>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/MultiMap.java.MultiMap.[boolean]containsValue(Object)", "src/main/java/org/apache/commons/collections4/MultiMap.java.MultiMap.[Object]get(Object)", "src/main/java/org/apache/commons/collections4/MultiMap.java.MultiMap.[Object]put(K,Object)", "src/main/java/org/apache/commons/collections4/MultiMap.java.MultiMap.[Object]remove(Object)", "src/main/java/org/apache/commons/collections4/MultiMap.java.MultiMap.[boolean]removeMapping(K,V)", "src/main/java/org/apache/commons/collections4/MultiMap.java.MultiMap.[int]size()", "src/main/java/org/apache/commons/collections4/MultiMap.java.MultiMap.[Collection<Object>]values()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a map that holds a collection of values against each key.\n<p>\nA {@code MultiMap} is a Map with slightly different semantics.\nPutting a value into the map will add the value to a Collection at that key.\nGetting a value will return a Collection, holding all the values put to that key.\n</p>\n<p>\nFor example:\n</p>\n<pre>\nMultiMap mhm = new MultiValueMap();\nmhm.put(key, \"A\");\nmhm.put(key, \"B\");\nmhm.put(key, \"C\");\nCollection coll = (Collection) mhm.get(key);</pre>\n<p>\n{@code coll} will be a collection containing \"A\", \"B\", \"C\".\n</p>\n<p>\nNOTE: Additional methods were added to this interface in Commons Collections 3.1.\nThese were added solely for documentation purposes and do not change the interface\nas they were defined in the superinterface {@code Map} anyway.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n\n@since 2.0\n@deprecated since 4.1, use {@link MultiValuedMap} instead\n", "original_string": "@Deprecated\npublic interface MultiMap<K, V> extends IterableMap<K, Object> {\n\n    /**\n     * Checks whether the map contains the value specified.\n     * <p>\n     * Implementations typically check all collections against all keys for the value.\n     * This cannot be mandated due to backwards compatibility of this interface.\n     *\n     * @param value  the value to search for\n     * @return true if the map contains the value\n     * @throws ClassCastException if the value is of an invalid type\n     * @throws NullPointerException if the value is null and null value are invalid\n     */\n    @Override\n    boolean containsValue(Object value);\n\n    /**\n     * Gets the collection of values associated with the specified key.\n     * <p>\n     * The returned value will implement {@code Collection}. Implementations\n     * are free to declare that they return {@code Collection} subclasses\n     * such as {@code List} or {@code Set}.\n     * <p>\n     * Implementations typically return {@code null} if no values have\n     * been mapped to the key, however the implementation may choose to\n     * return an empty collection.\n     * <p>\n     * Implementations may choose to return a clone of the internal collection.\n     *\n     * @param key  the key to retrieve\n     * @return the {@code Collection} of values, implementations should\n     *  return {@code null} for no mapping, but may return an empty collection\n     * @throws ClassCastException if the key is of an invalid type\n     * @throws NullPointerException if the key is null and null keys are invalid\n     */\n    @Override\n    Object get(Object key); // Cannot use get(K key) as that does not properly implement Map#get\n\n    /**\n     * Adds the value to the collection associated with the specified key.\n     * <p>\n     * Unlike a normal {@code Map} the previous value is not replaced.\n     * Instead, the new value is added to the collection stored against the key.\n     * The collection may be a {@code List}, {@code Set} or other\n     * collection dependent on implementation.\n     *\n     * @param key  the key to store against\n     * @param value  the value to add to the collection at the key\n     * @return typically the value added if the map changed and null if the map did not change\n     * @throws UnsupportedOperationException if the map is unmodifiable\n     * @throws ClassCastException if the key or value is of an invalid type\n     * @throws NullPointerException if the key or value is null and null is invalid\n     * @throws IllegalArgumentException if the key or value is invalid\n     */\n    @Override\n    Object put(K key, Object value);\n\n    /**\n     * Removes all values associated with the specified key.\n     * <p>\n     * Implementations typically return {@code null} from a subsequent\n     * {@code get(Object)}, however they may choose to return an empty collection.\n     *\n     * @param key  the key to remove values from\n     * @return the {@code Collection} of values removed, implementations should\n     *  return {@code null} for no mapping found, but may return an empty collection\n     * @throws UnsupportedOperationException if the map is unmodifiable\n     * @throws ClassCastException if the key is of an invalid type\n     * @throws NullPointerException if the key is null and null keys are invalid\n     */\n    @Override\n    Object remove(Object key); // Cannot use remove(K key) as that does not properly implement Map#remove\n\n    /**\n     * Removes a specific value from map.\n     * <p>\n     * The item is removed from the collection mapped to the specified key.\n     * Other values attached to that key are unaffected.\n     * <p>\n     * If the last value for a key is removed, implementations typically\n     * return {@code null} from a subsequent {@code get(Object)}, however\n     * they may choose to return an empty collection.\n     *\n     * @param key  the key to remove from\n     * @param item  the item to remove\n     * @return {@code true} if the mapping was removed, {@code false} otherwise\n     * @throws UnsupportedOperationException if the map is unmodifiable\n     * @throws ClassCastException if the key or value is of an invalid type\n     * @throws NullPointerException if the key or value is null and null is invalid\n     * @since 4.0 (signature in previous releases: V remove(K, V))\n     */\n    boolean removeMapping(K key, V item);\n\n    /**\n     * Gets the number of keys in this map.\n     * <p>\n     * Implementations typically return only the count of keys in the map\n     * This cannot be mandated due to backwards compatibility of this interface.\n     *\n     * @return the number of key-collection mappings in this map\n     */\n    @Override\n    int size();\n\n    /**\n     * Gets a collection containing all the values in the map.\n     * <p>\n     * Implementations typically return a collection containing the combination\n     * of values from all keys.\n     * This cannot be mandated due to backwards compatibility of this interface.\n     *\n     * @return a collection view of the values contained in this map\n     */\n    @Override\n    Collection<Object> values();\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/Trie.java.Trie", "name": "Trie", "file_path": "src/main/java/org/apache/commons/collections4/Trie.java", "superclasses": ["IterableSortedMap<K, V>"], "methods": ["[SortedMap<K, V>]prefixMap(K)"], "method_uris": ["src/main/java/org/apache/commons/collections4/Trie.java.Trie.[SortedMap<K, V>]prefixMap(K)"], "overrides": null, "attributes": null, "class_docstring": "\nDefines the interface for a prefix tree, an ordered tree data structure. For\nmore information, see <a href=\"https://en.wikipedia.org/wiki/Trie\">Tries</a>.\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n@since 4.0\n", "original_string": "public interface Trie<K, V> extends IterableSortedMap<K, V> {\n\n    /**\n     * Returns a view of this {@link Trie} of all elements that are prefixed\n     * by the given key.\n     * <p>\n     * In a {@link Trie} with fixed size keys, this is essentially a\n     * {@link #get(Object)} operation.\n     * <p>\n     * For example, if the {@link Trie} contains 'Anna', 'Anael',\n     * 'Analu', 'Andreas', 'Andrea', 'Andres', and 'Anatole', then\n     * a lookup of 'And' would return 'Andreas', 'Andrea', and 'Andres'.\n     *\n     * @param key  the key used in the search\n     * @return a {@link SortedMap} view of this {@link Trie} with all elements whose\n     *   key is prefixed by the search key\n     */\n    SortedMap<K, V> prefixMap(K key);\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/BoundedCollection.java.BoundedCollection", "name": "BoundedCollection", "file_path": "src/main/java/org/apache/commons/collections4/BoundedCollection.java", "superclasses": ["Collection<E>"], "methods": ["[boolean]isFull()", "[int]maxSize()"], "method_uris": ["src/main/java/org/apache/commons/collections4/BoundedCollection.java.BoundedCollection.[boolean]isFull()", "src/main/java/org/apache/commons/collections4/BoundedCollection.java.BoundedCollection.[int]maxSize()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a collection that is bounded in size.\n<p>\nThe size of the collection can vary, but it can never exceed a preset\nmaximum number of elements. This interface allows the querying of details\nassociated with the maximum number of elements.\n</p>\n\n@see CollectionUtils#isFull\n@see CollectionUtils#maxSize\n\n@param <E> the type of elements in this collection\n@since 3.0\n", "original_string": "public interface BoundedCollection<E> extends Collection<E> {\n\n    /**\n     * Returns true if this collection is full and no new elements can be added.\n     *\n     * @return {@code true} if the collection is full.\n     */\n    boolean isFull();\n\n    /**\n     * Gets the maximum size of the collection (the bound).\n     *\n     * @return the maximum number of elements the collection can hold.\n     */\n    int maxSize();\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/ResettableIterator.java.ResettableIterator", "name": "ResettableIterator", "file_path": "src/main/java/org/apache/commons/collections4/ResettableIterator.java", "superclasses": ["Iterator<E>"], "methods": ["[void]reset()"], "method_uris": ["src/main/java/org/apache/commons/collections4/ResettableIterator.java.ResettableIterator.[void]reset()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines an iterator that can be reset back to an initial state.\n<p>\nThis interface allows an iterator to be repeatedly reused.\n</p>\n\n@param <E> the type of elements returned by this iterator.\n@since 3.0\n", "original_string": "public interface ResettableIterator<E> extends Iterator<E> {\n\n    /**\n     * Resets the iterator back to the position at which the iterator\n     * was created.\n     */\n    void reset();\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/IterableGet.java.IterableGet", "name": "IterableGet", "file_path": "src/main/java/org/apache/commons/collections4/IterableGet.java", "superclasses": ["Get<K, V>"], "methods": ["[MapIterator<K, V>]mapIterator()"], "method_uris": ["src/main/java/org/apache/commons/collections4/IterableGet.java.IterableGet.[MapIterator<K, V>]mapIterator()"], "overrides": null, "attributes": null, "class_docstring": "\nThe \"read\" subset of the {@link java.util.Map} interface.\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n\n@since 4.0\n@see Put\n", "original_string": "public interface IterableGet<K, V> extends Get<K, V> {\n    /**\n     * Obtains a {@code MapIterator} over the map.\n     * <p>\n     * A map iterator is an efficient way of iterating over maps.\n     * There is no need to access the entry set or use Map Entry objects.\n     * <pre>\n     * IterableMap&lt;String,Integer&gt; map = new HashedMap&lt;String,Integer&gt;();\n     * MapIterator&lt;String,Integer&gt; it = map.mapIterator();\n     * while (it.hasNext()) {\n     *   String key = it.next();\n     *   Integer value = it.getValue();\n     *   it.setValue(value + 1);\n     * }\n     * </pre>\n     *\n     * @return a map iterator\n     */\n    MapIterator<K, V> mapIterator();\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/Put.java.Put", "name": "Put", "file_path": "src/main/java/org/apache/commons/collections4/Put.java", "superclasses": [], "methods": ["[void]clear()", "[Object]put(K,V)", "[void]putAll(Map<? extends K, ? extends V>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/Put.java.Put.[void]clear()", "src/main/java/org/apache/commons/collections4/Put.java.Put.[Object]put(K,V)", "src/main/java/org/apache/commons/collections4/Put.java.Put.[void]putAll(Map<? extends K, ? extends V>)"], "overrides": null, "attributes": null, "class_docstring": "\nThe \"write\" subset of the {@link Map} interface.\n<p>\nNOTE: in the original {@link Map} interface, {@link Map#put(Object, Object)} is known\nto have the same return type as {@link Map#get(Object)}, namely {@code V}. {@link Put}\nmakes no assumptions in this regard (there is no association with, nor even knowledge\nof, a \"reading\" interface) and thus defines {@link #put(Object, Object)} as returning\n{@link Object}.\n</p>\n\n@param <K> the type of the keys in this map\n@param <V> the type of the values in this map\n\n@since 4.0\n@see Get\n", "original_string": "public interface Put<K, V> {\n\n    /**\n     * @see Map#clear()\n     */\n    void clear();\n\n    /**\n     * Note that the return type is Object, rather than V as in the Map interface.\n     * See the class Javadoc for further info.\n     *\n     * @param key key with which the specified value is to be associated\n     * @param value value to be associated with the specified key\n     * @return the previous value associated with {@code key}, or\n     *         {@code null} if there was no mapping for {@code key}.\n     *         (A {@code null} return can also indicate that the map\n     *         previously associated {@code null} with {@code key},\n     *         if the implementation supports {@code null} values.)\n     * @see Map#put(Object, Object)\n     */\n    Object put(K key, V value);\n\n    /**\n     * @param t mappings to be stored in this map\n     * @see Map#putAll(Map)\n     */\n    void putAll(Map<? extends K, ? extends V> t);\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/Unmodifiable.java.Unmodifiable", "name": "Unmodifiable", "file_path": "src/main/java/org/apache/commons/collections4/Unmodifiable.java", "superclasses": [], "methods": [], "method_uris": [], "overrides": null, "attributes": null, "class_docstring": "\nMarker interface for collections, maps and iterators that are unmodifiable.\n<p>\nThis interface enables testing such as:\n</p>\n<pre>\nif (coll instanceof Unmodifiable) {\n  coll = new ArrayList(coll);\n}\n// now we know coll is modifiable\n</pre>\nOf course all this only works if you use the Unmodifiable classes defined\nin this library. If you use the JDK unmodifiable class via {@code java.util Collections}\nthen the interface won't be there.\n\n@since 3.0\n", "original_string": "public interface Unmodifiable {\n    // marker interface - no methods to implement\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/OrderedMapIterator.java.OrderedMapIterator", "name": "OrderedMapIterator", "file_path": "src/main/java/org/apache/commons/collections4/OrderedMapIterator.java", "superclasses": ["MapIterator<K, V>", "OrderedIterator<K>"], "methods": ["[boolean]hasPrevious()", "[K]previous()"], "method_uris": ["src/main/java/org/apache/commons/collections4/OrderedMapIterator.java.OrderedMapIterator.[boolean]hasPrevious()", "src/main/java/org/apache/commons/collections4/OrderedMapIterator.java.OrderedMapIterator.[K]previous()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines an iterator that operates over an ordered {@code Map}.\n<p>\nThis iterator allows both forward and reverse iteration through the map.\n</p>\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n@since 3.0\n", "original_string": "public interface OrderedMapIterator<K, V> extends MapIterator<K, V>, OrderedIterator<K> {\n\n    /**\n     * Checks to see if there is a previous entry that can be iterated to.\n     *\n     * @return {@code true} if the iterator has a previous element\n     */\n    @Override\n    boolean hasPrevious();\n\n    /**\n     * Gets the previous <em>key</em> from the {@code Map}.\n     *\n     * @return the previous key in the iteration\n     * @throws java.util.NoSuchElementException if the iteration is finished\n     */\n    @Override\n    K previous();\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/Bag.java.Bag", "name": "Bag", "file_path": "src/main/java/org/apache/commons/collections4/Bag.java", "superclasses": ["Collection<E>"], "methods": ["[boolean]add(E)", "[boolean]add(E,int)", "[boolean]containsAll(Collection<?>)", "[int]getCount(Object)", "[Iterator<E>]iterator()", "[boolean]remove(Object)", "[boolean]remove(Object,int)", "[boolean]removeAll(Collection<?>)", "[boolean]retainAll(Collection<?>)", "[int]size()", "[Set<E>]uniqueSet()"], "method_uris": ["src/main/java/org/apache/commons/collections4/Bag.java.Bag.[boolean]add(E)", "src/main/java/org/apache/commons/collections4/Bag.java.Bag.[boolean]add(E,int)", "src/main/java/org/apache/commons/collections4/Bag.java.Bag.[boolean]containsAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/Bag.java.Bag.[int]getCount(Object)", "src/main/java/org/apache/commons/collections4/Bag.java.Bag.[Iterator<E>]iterator()", "src/main/java/org/apache/commons/collections4/Bag.java.Bag.[boolean]remove(Object)", "src/main/java/org/apache/commons/collections4/Bag.java.Bag.[boolean]remove(Object,int)", "src/main/java/org/apache/commons/collections4/Bag.java.Bag.[boolean]removeAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/Bag.java.Bag.[boolean]retainAll(Collection<?>)", "src/main/java/org/apache/commons/collections4/Bag.java.Bag.[int]size()", "src/main/java/org/apache/commons/collections4/Bag.java.Bag.[Set<E>]uniqueSet()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a collection that counts the number of times an object appears in\nthe collection.\n<p>\nSuppose you have a Bag that contains {@code {a, a, b, c}}.\nCalling {@link #getCount(Object)} on {@code a} would return 2, while\ncalling {@link #uniqueSet()} would return {@code {a, b, c}}.\n</p>\n<p>\n<em>NOTE: This interface violates the {@link Collection} contract.</em>\nThe behavior specified in many of these methods is <em>not</em> the same\nas the behavior specified by {@code Collection}.\nThe non-compliant methods are clearly marked with \"(Violation)\".\nExercise caution when using a bag as a {@code Collection}.\n</p>\n<p>\nThis violation resulted from the original specification of this interface.\nIn an ideal world, the interface would be changed to fix the problems, however\nit has been decided to maintain backwards compatibility instead.\n</p>\n\n@param <E> the type of elements in this bag\n@since 2.0\n", "original_string": "public interface Bag<E> extends Collection<E> {\n\n    /**\n     * <em>(Violation)</em>\n     * Adds one copy of the specified object to the Bag.\n     * <p>\n     * If the object is already in the {@link #uniqueSet()} then increment its\n     * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n     * {@link #uniqueSet()} and report its count as 1.\n     * </p>\n     * <p>\n     * Since this method always increases the size of the bag,\n     * according to the {@link Collection#add(Object)} contract, it\n     * should always return {@code true}.  Since it sometimes returns\n     * {@code false}, this method violates the contract.\n     * </p>\n     *\n     * @param object  the object to add\n     * @return {@code true} if the object was not already in the {@code uniqueSet}\n     */\n    @Override\n    boolean add(E object);\n\n    /**\n     * Adds {@code nCopies} copies of the specified object to the Bag.\n     * <p>\n     * If the object is already in the {@link #uniqueSet()} then increment its\n     * count as reported by {@link #getCount(Object)}. Otherwise add it to the\n     * {@link #uniqueSet()} and report its count as {@code nCopies}.\n     * </p>\n     *\n     * @param object  the object to add\n     * @param nCopies  the number of copies to add\n     * @return {@code true} if the object was not already in the {@code uniqueSet}\n     */\n    boolean add(E object, int nCopies);\n\n    /**\n     * <em>(Violation)</em>\n     * Returns {@code true} if the bag contains all elements in\n     * the given collection, respecting cardinality.  That is, if the\n     * given collection {@code coll} contains {@code n} copies\n     * of a given object, calling {@link #getCount(Object)} on that object must\n     * be {@code &gt;= n} for all {@code n} in {@code coll}.\n     *\n     * <p>\n     * The {@link Collection#containsAll(Collection)} method specifies\n     * that cardinality should <em>not</em> be respected; this method should\n     * return true if the bag contains at least one of every object contained\n     * in the given collection.\n     * </p>\n     *\n     * @param coll  the collection to check against\n     * @return {@code true} if the Bag contains all the collection\n     */\n    @Override\n    boolean containsAll(Collection<?> coll);\n\n    /**\n     * Returns the number of occurrences (cardinality) of the given\n     * object currently in the bag. If the object does not exist in the\n     * bag, return 0.\n     *\n     * @param object  the object to search for\n     * @return the number of occurrences of the object, zero if not found\n     */\n    int getCount(Object object);\n\n    /**\n     * Returns an {@link Iterator} over the entire set of members,\n     * including copies due to cardinality. This iterator is fail-fast\n     * and will not tolerate concurrent modifications.\n     *\n     * @return iterator over all elements in the Bag\n     */\n    @Override\n    Iterator<E> iterator();\n\n    /**\n     * <em>(Violation)</em>\n     * Removes all occurrences of the given object from the bag.\n     * <p>\n     * This will also remove the object from the {@link #uniqueSet()}.\n     * </p>\n     * <p>\n     * According to the {@link Collection#remove(Object)} method,\n     * this method should only remove the <em>first</em> occurrence of the\n     * given object, not <em>all</em> occurrences.\n     * </p>\n     *\n     * @param object  the object to remove\n     * @return {@code true} if this call changed the collection\n     */\n    @Override\n    boolean remove(Object object);\n\n    /**\n     * Removes {@code nCopies} copies of the specified object from the Bag.\n     * <p>\n     * If the number of copies to remove is greater than the actual number of\n     * copies in the Bag, no error is thrown.\n     * </p>\n     *\n     * @param object  the object to remove\n     * @param nCopies  the number of copies to remove\n     * @return {@code true} if this call changed the collection\n     */\n    boolean remove(Object object, int nCopies);\n\n    /**\n     * <em>(Violation)</em>\n     * Remove all elements represented in the given collection,\n     * respecting cardinality.  That is, if the given collection\n     * {@code coll} contains {@code n} copies of a given object,\n     * the bag will have {@code n} fewer copies, assuming the bag\n     * had at least {@code n} copies to begin with.\n     *\n     * <p>\n     * The {@link Collection#removeAll(Collection)} method specifies\n     * that cardinality should <em>not</em> be respected; this method should\n     * remove <em>all</em> occurrences of every object contained in the\n     * given collection.\n     * </p>\n     *\n     * @param coll  the collection to remove\n     * @return {@code true} if this call changed the collection\n     */\n    @Override\n    boolean removeAll(Collection<?> coll);\n\n    /**\n     * <em>(Violation)</em>\n     * Remove any members of the bag that are not in the given\n     * collection, respecting cardinality.  That is, if the given\n     * collection {@code coll} contains {@code n} copies of a\n     * given object and the bag has {@code m &gt; n} copies, then\n     * delete {@code m - n} copies from the bag.  In addition, if\n     * {@code e} is an object in the bag but\n     * {@code !coll.contains(e)}, then remove {@code e} and any\n     * of its copies.\n     *\n     * <p>\n     * The {@link Collection#retainAll(Collection)} method specifies\n     * that cardinality should <em>not</em> be respected; this method should\n     * keep <em>all</em> occurrences of every object contained in the\n     * given collection.\n     * </p>\n     *\n     * @param coll  the collection to retain\n     * @return {@code true} if this call changed the collection\n     */\n    @Override\n    boolean retainAll(Collection<?> coll);\n\n    /**\n     * Returns the total number of items in the bag across all types.\n     *\n     * @return the total size of the Bag\n     */\n    @Override\n    int size();\n\n    /**\n     * Returns a {@link Set} of unique elements in the Bag.\n     * <p>\n     * Uniqueness constraints are the same as those in {@link java.util.Set}.\n     * </p>\n     *\n     * @return the Set of unique Bag elements\n     */\n    Set<E> uniqueSet();\n\n    // The following is not part of the formal Bag interface, however where possible\n    // Bag implementations should follow these comments.\n//    /**\n//     * Compares this Bag to another.\n//     * This Bag equals another Bag if it contains the same number of occurrences of\n//     * the same elements.\n//     * This equals definition is compatible with the Set interface.\n//     *\n//     * @param obj  the Bag to compare to\n//     * @return true if equal\n//     */\n//    boolean equals(Object obj);\n//\n//    /**\n//     * Gets a hash code for the Bag compatible with the definition of equals.\n//     * The hash code is defined as the sum total of a hash code for each element.\n//     * The per element hash code is defined as\n//     * {@code (e==null ? 0 : e.hashCode()) ^ noOccurrences)}.\n//     * This hash code definition is compatible with the Set interface.\n//     *\n//     * @return the hash code of the Bag\n//     */\n//    int hashCode();\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/MapIterator.java.MapIterator", "name": "MapIterator", "file_path": "src/main/java/org/apache/commons/collections4/MapIterator.java", "superclasses": ["Iterator<K>"], "methods": ["[K]getKey()", "[V]getValue()", "[boolean]hasNext()", "[K]next()", "[void]remove()", "[V]setValue(V)"], "method_uris": ["src/main/java/org/apache/commons/collections4/MapIterator.java.MapIterator.[K]getKey()", "src/main/java/org/apache/commons/collections4/MapIterator.java.MapIterator.[V]getValue()", "src/main/java/org/apache/commons/collections4/MapIterator.java.MapIterator.[boolean]hasNext()", "src/main/java/org/apache/commons/collections4/MapIterator.java.MapIterator.[K]next()", "src/main/java/org/apache/commons/collections4/MapIterator.java.MapIterator.[void]remove()", "src/main/java/org/apache/commons/collections4/MapIterator.java.MapIterator.[V]setValue(V)"], "overrides": null, "attributes": null, "class_docstring": "\nDefines an iterator that operates over a {@code Map}.\n<p>\nThis iterator is a special version designed for maps. It can be more\nefficient to use this rather than an entry set iterator where the option\nis available, and it is certainly more convenient.\n</p>\n<p>\nA map that provides this interface may not hold the data internally using\nMap Entry objects, thus this interface can avoid lots of object creation.\n</p>\n<p>\nIn use, this iterator iterates through the keys in the map. After each call\nto {@code next()}, the {@code getValue()} method provides direct\naccess to the value. The value can also be set using {@code setValue()}.\n</p>\n<pre>{@code\nMapIterator<String,Integer> it = map.mapIterator();\nwhile (it.hasNext()) {\n  String key = it.next();\n  Integer value = it.getValue();\n  it.setValue(value + 1);\n}\n}</pre>\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n@since 3.0\n", "original_string": "public interface MapIterator<K, V> extends Iterator<K> {\n\n    /**\n     * Gets the current key, which is the key returned by the last call\n     * to {@code next()}.\n     *\n     * @return the current key\n     * @throws IllegalStateException if {@code next()} has not yet been called\n     */\n    K getKey();\n\n    /**\n     * Gets the current value, which is the value associated with the last key\n     * returned by {@code next()}.\n     *\n     * @return the current value\n     * @throws IllegalStateException if {@code next()} has not yet been called\n     */\n    V getValue();\n\n    /**\n     * Checks to see if there are more entries still to be iterated.\n     *\n     * @return {@code true} if the iterator has more elements\n     */\n    @Override\n    boolean hasNext();\n\n    /**\n     * Gets the next <em>key</em> from the {@code Map}.\n     *\n     * @return the next key in the iteration\n     * @throws java.util.NoSuchElementException if the iteration is finished\n     */\n    @Override\n    K next();\n\n    /**\n     * Removes the last returned key from the underlying {@code Map} (optional operation).\n     * <p>\n     * This method can be called once per call to {@code next()}.\n     *\n     * @throws UnsupportedOperationException if remove is not supported by the map\n     * @throws IllegalStateException if {@code next()} has not yet been called\n     * @throws IllegalStateException if {@code remove()} has already been called\n     *  since the last call to {@code next()}\n     */\n    @Override\n    void remove();\n\n    /**\n     * Sets the value associated with the current key (optional operation).\n     *\n     * @param value  the new value\n     * @return the previous value\n     * @throws UnsupportedOperationException if setValue is not supported by the map\n     * @throws IllegalStateException if {@code next()} has not yet been called\n     * @throws IllegalStateException if {@code remove()} has been called since the\n     *  last call to {@code next()}\n     */\n    V setValue(V value);\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/Factory.java.Factory", "name": "Factory", "file_path": "src/main/java/org/apache/commons/collections4/Factory.java", "superclasses": ["Supplier<T>"], "methods": ["[T]create()", "[T]get()"], "method_uris": ["src/main/java/org/apache/commons/collections4/Factory.java.Factory.[T]create()", "src/main/java/org/apache/commons/collections4/Factory.java.Factory.[T]get()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a functor interface implemented by classes that create objects.\n<p>\nA {@code Factory} creates an object without using an input parameter.\nIf an input parameter is required, then {@link Transformer} is more appropriate.\n</p>\n<p>\nStandard implementations of common factories are provided by\n{@link FactoryUtils}. These include factories that return a constant,\na copy of a prototype or a new instance.\n</p>\n\n@param <T> the type of results supplied by this supplier.\n@since 2.1\n@deprecated Use {@link Supplier}.\n", "original_string": "@Deprecated\npublic interface Factory<T> extends Supplier<T> {\n\n    /**\n     * Create a new object.\n     *\n     * @return a new object\n     * @throws FunctorException (runtime) if the factory cannot create an object\n     */\n    T create();\n\n    @Override\n    default T get() {\n        return create();\n    }\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/Predicate.java.Predicate", "name": "Predicate", "file_path": "src/main/java/org/apache/commons/collections4/Predicate.java", "superclasses": ["java.util.function.Predicate<T>"], "methods": ["[boolean]evaluate(T)", "[boolean]test(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/Predicate.java.Predicate.[boolean]evaluate(T)", "src/main/java/org/apache/commons/collections4/Predicate.java.Predicate.[boolean]test(T)"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a functor interface implemented by classes that perform a predicate\ntest on an object.\n<p>\nA {@code Predicate} is the object equivalent of an {@code if} statement.\nIt uses the input object to return a true or false value, and is often used in\nvalidation or filtering.\n</p>\n<p>\nStandard implementations of common predicates are provided by\n{@link PredicateUtils}. These include true, false, instanceof, equals, and,\nor, not, method invocation and null testing.\n</p>\n\n@param <T> the type of the input to the predicate.\n@since 1.0\n@deprecated Use {@link java.util.function.Predicate}.\n", "original_string": "@Deprecated\npublic interface Predicate<T> extends java.util.function.Predicate<T> {\n\n    /**\n     * Use the specified parameter to perform a test that returns true or false.\n     *\n     * @param object  the object to evaluate, should not be changed\n     * @return true or false\n     * @throws ClassCastException (runtime) if the input is the wrong class\n     * @throws IllegalArgumentException (runtime) if the input is invalid\n     * @throws FunctorException (runtime) if the predicate encounters a problem\n     */\n    boolean evaluate(T object);\n\n    @Override\n    default boolean test(final T t) {\n        return evaluate(t);\n    }\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/ResettableListIterator.java.ResettableListIterator", "name": "ResettableListIterator", "file_path": "src/main/java/org/apache/commons/collections4/ResettableListIterator.java", "superclasses": ["ListIterator<E>", "ResettableIterator<E>", "OrderedIterator<E>"], "methods": [], "method_uris": [], "overrides": null, "attributes": null, "class_docstring": "\nDefines a list iterator that can be reset back to an initial state.\n<p>\nThis interface allows an iterator to be repeatedly reused.\n</p>\n\n@param <E> the type of elements returned by this iterator.\n@since 3.0\n", "original_string": "public interface ResettableListIterator<E> extends ListIterator<E>, ResettableIterator<E>, OrderedIterator<E> {\n    // empty\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/BidiMap.java.BidiMap", "name": "BidiMap", "file_path": "src/main/java/org/apache/commons/collections4/BidiMap.java", "superclasses": ["IterableMap<K, V>"], "methods": ["[K]getKey(Object)", "[BidiMap<V, K>]inverseBidiMap()", "[V]put(K,V)", "[K]removeValue(Object)", "[Set<V>]values()"], "method_uris": ["src/main/java/org/apache/commons/collections4/BidiMap.java.BidiMap.[K]getKey(Object)", "src/main/java/org/apache/commons/collections4/BidiMap.java.BidiMap.[BidiMap<V, K>]inverseBidiMap()", "src/main/java/org/apache/commons/collections4/BidiMap.java.BidiMap.[V]put(K,V)", "src/main/java/org/apache/commons/collections4/BidiMap.java.BidiMap.[K]removeValue(Object)", "src/main/java/org/apache/commons/collections4/BidiMap.java.BidiMap.[Set<V>]values()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a map that allows bidirectional lookup between key and values.\n<p>\nThis extended {@code Map} represents a mapping where a key may\nlookup a value and a value may lookup a key with equal ease.\nThis interface extends {@code Map} and so may be used anywhere a map\nis required. The interface provides an inverse map view, enabling\nfull access to both directions of the {@code BidiMap}.\n</p>\n<p>\nImplementations should allow a value to be looked up from a key and\na key to be looked up from a value with equal performance.\n</p>\n<p>\nThis map enforces the restriction that there is a 1:1 relation between\nkeys and values, meaning that multiple keys cannot map to the same value.\nThis is required so that \"inverting\" the map results in a map without\nduplicate keys. See the {@link #put} method description for more information.\n</p>\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n\n@since 3.0\n", "original_string": "public interface BidiMap<K, V> extends IterableMap<K, V> {\n\n    /**\n     * Gets the key that is currently mapped to the specified value.\n     * <p>\n     * If the value is not contained in the map, {@code null} is returned.\n     * </p>\n     * <p>\n     * Implementations should seek to make this method perform equally as well\n     * as {@code get(Object)}.\n     * </p>\n     *\n     * @param value  the value to find the key for\n     * @return the mapped key, or {@code null} if not found\n     *\n     * @throws ClassCastException (optional) if the map limits the type of the\n     *  value and the specified value is inappropriate\n     * @throws NullPointerException (optional) if the map limits the values to\n     *  non-null and null was specified\n     */\n    K getKey(Object value);\n\n    /**\n     * Gets a view of this map where the keys and values are reversed.\n     * <p>\n     * Changes to one map will be visible in the other and vice versa.\n     * This enables both directions of the map to be accessed as a {@code Map}.\n     * </p>\n     * <p>\n     * Implementations should seek to avoid creating a new object every time this\n     * method is called. See {@code AbstractMap.values()} etc. Calling this\n     * method on the inverse map should return the original.\n     * </p>\n     *\n     * @return an inverted bidirectional map\n     */\n    BidiMap<V, K> inverseBidiMap();\n\n    /**\n     * Puts the key-value pair into the map, replacing any previous pair.\n     * <p>\n     * When adding a key-value pair, the value may already exist in the map\n     * against a different key. That mapping is removed, to ensure that the\n     * value only occurs once in the inverse map.\n     * </p>\n     * <pre>\n     *  BidiMap map1 = new DualHashBidiMap();\n     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n     *  map.put(\"A\",\"C\");  // contains A mapped to C, as per Map\n     *\n     *  BidiMap map2 = new DualHashBidiMap();\n     *  map.put(\"A\",\"B\");  // contains A mapped to B, as per Map\n     *  map.put(\"C\",\"B\");  // contains C mapped to B, key A is removed\n     * </pre>\n     *\n     * @param key  the key to store\n     * @param value  the value to store\n     * @return the previous value mapped to this key\n     *\n     * @throws UnsupportedOperationException if the {@code put} method is not supported\n     * @throws ClassCastException (optional) if the map limits the type of the\n     *  value and the specified value is inappropriate\n     * @throws IllegalArgumentException (optional) if the map limits the values\n     *  in some way and the value was invalid\n     * @throws NullPointerException (optional) if the map limits the values to\n     *  non-null and null was specified\n     */\n    @Override\n    V put(K key, V value);\n\n    /**\n     * Removes the key-value pair that is currently mapped to the specified\n     * value (optional operation).\n     * <p>\n     * If the value is not contained in the map, {@code null} is returned.\n     * </p>\n     * <p>\n     * Implementations should seek to make this method perform equally as well\n     * as {@code remove(Object)}.\n     * </p>\n     *\n     * @param value  the value to find the key-value pair for\n     * @return the key that was removed, {@code null} if nothing removed\n     *\n     * @throws ClassCastException (optional) if the map limits the type of the\n     *  value and the specified value is inappropriate\n     * @throws NullPointerException (optional) if the map limits the values to\n     *  non-null and null was specified\n     * @throws UnsupportedOperationException if this method is not supported\n     *  by the implementation\n     */\n    K removeValue(Object value);\n\n    /**\n     * Returns a {@link Set} view of the values contained in this map.\n     * The set is backed by the map, so changes to the map are reflected\n     * in the set, and vice-versa.  If the map is modified while an iteration\n     * over the set is in progress (except through the iterator's own\n     * {@code remove} operation), the results of the iteration are undefined.\n     * The set supports element removal, which removes the corresponding\n     * mapping from the map, via the {@code Iterator.remove},\n     * {@code Collection.remove}, {@code removeAll},\n     * {@code retainAll} and {@code clear} operations.  It does not\n     * support the {@code add} or {@code addAll} operations.\n     *\n     * @return a set view of the values contained in this map\n     */\n    @Override\n    Set<V> values();\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/OrderedMap.java.OrderedMap", "name": "OrderedMap", "file_path": "src/main/java/org/apache/commons/collections4/OrderedMap.java", "superclasses": ["IterableMap<K, V>"], "methods": ["[K]firstKey()", "[K]lastKey()", "[OrderedMapIterator<K, V>]mapIterator()", "[K]nextKey(K)", "[K]previousKey(K)"], "method_uris": ["src/main/java/org/apache/commons/collections4/OrderedMap.java.OrderedMap.[K]firstKey()", "src/main/java/org/apache/commons/collections4/OrderedMap.java.OrderedMap.[K]lastKey()", "src/main/java/org/apache/commons/collections4/OrderedMap.java.OrderedMap.[OrderedMapIterator<K, V>]mapIterator()", "src/main/java/org/apache/commons/collections4/OrderedMap.java.OrderedMap.[K]nextKey(K)", "src/main/java/org/apache/commons/collections4/OrderedMap.java.OrderedMap.[K]previousKey(K)"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a map that maintains order and allows both forward and backward\niteration through that order.\n\n@param <K> the type of the keys in the map\n@param <V> the type of the values in the map\n\n@since 3.0\n", "original_string": "public interface OrderedMap<K, V> extends IterableMap<K, V> {\n\n    /**\n     * Gets the first key currently in this map.\n     *\n     * @return the first key currently in this map\n     * @throws java.util.NoSuchElementException if this map is empty\n     */\n    K firstKey();\n\n    /**\n     * Gets the last key currently in this map.\n     *\n     * @return the last key currently in this map\n     * @throws java.util.NoSuchElementException if this map is empty\n     */\n    K lastKey();\n\n    /**\n     * Obtains an {@code OrderedMapIterator} over the map.\n     * <p>\n     * An ordered map iterator is an efficient way of iterating over maps\n     * in both directions.\n     *\n     * @return a map iterator\n     */\n    @Override\n    OrderedMapIterator<K, V> mapIterator();\n\n    /**\n     * Gets the next key after the one specified.\n     *\n     * @param key  the key to search for next from\n     * @return the next key, null if no match or at end\n     */\n    K nextKey(K key);\n\n    /**\n     * Gets the previous key before the one specified.\n     *\n     * @param key  the key to search for previous from\n     * @return the previous key, null if no match or at start\n     */\n    K previousKey(K key);\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/sequence/ReplacementsHandler.java.ReplacementsHandler", "name": "ReplacementsHandler", "file_path": "src/main/java/org/apache/commons/collections4/sequence/ReplacementsHandler.java", "superclasses": [], "methods": ["[void]handleReplacement(int,List<T>,List<T>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/sequence/ReplacementsHandler.java.ReplacementsHandler.[void]handleReplacement(int,List<T>,List<T>)"], "overrides": null, "attributes": null, "class_docstring": "\nThis interface is devoted to handle synchronized replacement sequences.\n\n@param <T> the type of elements in the lists.\n@see ReplacementsFinder\n@since 4.0\n", "original_string": "@FunctionalInterface\npublic interface ReplacementsHandler<T> {\n\n    /**\n     * Handles two synchronized sequences.\n     * <p>\n     * This method is called by a {@link ReplacementsFinder ReplacementsFinder}\n     * instance when it has synchronized two sub-sequences of object arrays\n     * being compared, and at least one of the sequences is non-empty. Since the\n     * sequences are synchronized, the objects before the two sub-sequences are\n     * equals (if they exist). This property also holds for the objects after\n     * the two sub-sequences.\n     * </p>\n     * <p>\n     * The replacement is defined as replacing the {@code from}\n     * sub-sequence into the {@code to} sub-sequence.\n     * </p>\n     *\n     * @param skipped  number of tokens skipped since the last call (i.e. number of\n     *   tokens that were in both sequences), this number should be strictly positive\n     *   except on the very first call where it can be zero (if the first object of\n     *   the two sequences are different)\n     * @param from  sub-sequence of objects coming from the first sequence\n     * @param to  sub-sequence of objects coming from the second sequence\n     */\n    void handleReplacement(int skipped, List<T> from, List<T> to);\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/sequence/CommandVisitor.java.CommandVisitor", "name": "CommandVisitor", "file_path": "src/main/java/org/apache/commons/collections4/sequence/CommandVisitor.java", "superclasses": [], "methods": ["[void]visitDeleteCommand(T)", "[void]visitInsertCommand(T)", "[void]visitKeepCommand(T)"], "method_uris": ["src/main/java/org/apache/commons/collections4/sequence/CommandVisitor.java.CommandVisitor.[void]visitDeleteCommand(T)", "src/main/java/org/apache/commons/collections4/sequence/CommandVisitor.java.CommandVisitor.[void]visitInsertCommand(T)", "src/main/java/org/apache/commons/collections4/sequence/CommandVisitor.java.CommandVisitor.[void]visitKeepCommand(T)"], "overrides": null, "attributes": null, "class_docstring": "\nThis interface should be implemented by user object to walk\nthrough {@link EditScript EditScript} objects.\n<p>\nUsers should implement this interface in order to walk through\nthe {@link EditScript EditScript} object created by the comparison\nof two sequences. This is a direct application of the visitor\ndesign pattern. The {@link EditScript#visit EditScript.visit}\nmethod takes an object implementing this interface as an argument,\nit will perform the loop over all commands in the script and the\nproper methods of the user class will be called as the commands are\nencountered.\n</p>\n<p>\nThe implementation of the user visitor class will depend on the\nneed. Here are two examples.\n</p>\n<p>\nThe first example is a visitor that build the longest common\nsubsequence:\n</p>\n<pre>\nimport org.apache.commons.collections4.comparators.sequence.CommandVisitor;\n\nimport java.util.ArrayList;\n\npublic class LongestCommonSubSequence implements CommandVisitor {\n\n  public LongestCommonSubSequence() {\n    a = new ArrayList();\n  }\n\n  public void visitInsertCommand(Object object) {\n  }\n\n  public void visitKeepCommand(Object object) {\n    a.add(object);\n  }\n\n  public void visitDeleteCommand(Object object) {\n  }\n\n  public Object[] getSubSequence() {\n    return a.toArray();\n  }\n\n  private ArrayList a;\n\n}\n</pre>\n<p>\nThe second example is a visitor that shows the commands and the way\nthey transform the first sequence into the second one:\n</p>\n<pre>\nimport org.apache.commons.collections4.comparators.sequence.CommandVisitor;\n\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\npublic class ShowVisitor implements CommandVisitor {\n\n  public ShowVisitor(Object[] sequence1) {\n    v = new ArrayList();\n    v.addAll(Arrays.asList(sequence1));\n    index = 0;\n  }\n\n  public void visitInsertCommand(Object object) {\n    v.insertElementAt(object, index++);\n    display(\"insert\", object);\n  }\n\n  public void visitKeepCommand(Object object) {\n    ++index;\n    display(\"keep  \", object);\n  }\n\n  public void visitDeleteCommand(Object object) {\n    v.remove(index);\n    display(\"delete\", object);\n  }\n\n  private void display(String commandName, Object object) {\n    System.out.println(commandName + \" \" + object + \" -&gt;\" + this);\n  }\n\n  public String toString() {\n    StringBuilder buffer = new StringBuilder();\n    for (Iterator iter = v.iterator(); iter.hasNext();) {\n      buffer.append(' ').append(iter.next());\n    }\n    return buffer.toString();\n  }\n\n  private ArrayList v;\n  private int index;\n\n}\n</pre>\n\n@param <T> the type of the input to the visit operations.\n@since 4.0\n", "original_string": "public interface CommandVisitor<T> {\n\n    /**\n     * Method called when a delete command is encountered.\n     *\n     * @param object object to delete (this object comes from the first sequence)\n     */\n    void visitDeleteCommand(T object);\n\n    /**\n     * Method called when an insert command is encountered.\n     *\n     * @param object object to insert (this object comes from the second sequence)\n     */\n    void visitInsertCommand(T object);\n\n    /**\n     * Method called when a keep command is encountered.\n     *\n     * @param object object to keep (this object comes from the first sequence)\n     */\n    void visitKeepCommand(T object);\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/functors/PredicateDecorator.java.PredicateDecorator", "name": "PredicateDecorator", "file_path": "src/main/java/org/apache/commons/collections4/functors/PredicateDecorator.java", "superclasses": ["Predicate<T>"], "methods": ["[Predicate<? super T>[]]getPredicates()"], "method_uris": ["src/main/java/org/apache/commons/collections4/functors/PredicateDecorator.java.PredicateDecorator.[Predicate<? super T>[]]getPredicates()"], "overrides": null, "attributes": null, "class_docstring": "\nDefines a predicate that decorates one or more other predicates.\n<p>\nThis interface enables tools to access the decorated predicates.\n</p>\n\n@param <T> the type of the input to the predicate.\n@since 3.1\n", "original_string": "public interface PredicateDecorator<T> extends Predicate<T> {\n\n    /**\n     * Gets the predicates being decorated as an array.\n     * <p>\n     * The array may be the internal data structure of the predicate and thus\n     * should not be altered.\n     *\n     * @return the predicates being decorated\n     */\n    Predicate<? super T>[] getPredicates();\n\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/CellExtractor.java.CellExtractor", "name": "CellExtractor", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/CellExtractor.java", "superclasses": ["IndexExtractor"], "methods": ["[CellExtractor]from(IndexExtractor)", "[boolean]processCells(CellPredicate)", "[boolean]processIndices(IntPredicate)", "[IndexExtractor]uniqueIndices()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/CellExtractor.java.CellExtractor.[CellExtractor]from(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/CellExtractor.java.CellExtractor.[boolean]processCells(CellPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/CellExtractor.java.CellExtractor.[boolean]processIndices(IntPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/CellExtractor.java.CellExtractor.[IndexExtractor]uniqueIndices()"], "overrides": null, "attributes": null, "class_docstring": "\nSome Bloom filter implementations use a count rather than a bit flag. The term {@code Cell} is used to\nrefer to these counts and their associated index.  This class is the equivalent of the index extractor except\nthat it produces cells.\n\n<p>Note that a CellExtractor must not return duplicate indices and must be ordered.</p>\n\n<p>Implementations must guarantee that:</p>\n\n<ul>\n<li>The IndexExtractor implementation returns unique ordered indices.</li>\n<li>The cells are produced in IndexExtractor order.</li>\n<li>For every value produced by the IndexExtractor there will be only one matching\ncell produced by the CellExtractor.</li>\n<li>The CellExtractor will not generate cells with indices that are not output by the IndexExtractor.</li>\n<li>The IndexExtractor will not generate indices that have a zero count for the cell.</li>\n</ul>\n\n@since 4.5.0\n", "original_string": "@FunctionalInterface\npublic interface CellExtractor extends IndexExtractor {\n\n    /**\n     * Represents an operation that accepts an {@code <index, count>} pair.\n     * Returns {@code true} if processing should continue, {@code false} otherwise.\n     *\n     * <p>Note: This is a functional interface as a specialization of\n     * {@link java.util.function.BiPredicate} for {@code int}.</p>\n     */\n    @FunctionalInterface\n    interface CellPredicate {\n        /**\n         * Performs an operation on the given {@code <index, count>} pair.\n         *\n         * @param index the bit index.\n         * @param count the cell value at the specified bit index.\n         * @return {@code true} if processing should continue, {@code false} if processing should stop.\n         */\n        boolean test(int index, int count);\n    }\n\n    /**\n     * Creates a CellExtractor from an IndexExtractor.\n     *\n     * <p>Note the following properties:\n     * <ul>\n     * <li>Each index returned from the IndexExtractor is assumed to have a cell value of 1.</li>\n     * <li>The CellExtractor aggregates duplicate indices from the IndexExtractor.</li>\n     * </ul>\n     *\n     * <p>A CellExtractor that outputs the mapping [(1,2),(2,3),(3,1)] can be created from many combinations\n     * of indices including:\n     * <pre>\n     * [1, 1, 2, 2, 2, 3]\n     * [1, 3, 1, 2, 2, 2]\n     * [3, 2, 1, 2, 1, 2]\n     * ...\n     * </pre>\n     *\n     * @param indexExtractor An index indexExtractor.\n     * @return A CellExtractor with the same indices as the IndexExtractor.\n     */\n    static CellExtractor from(final IndexExtractor indexExtractor) {\n        return new CellExtractor() {\n            /**\n             * Class to track cell values in the TreeMap.\n             */\n            final class CounterCell implements Comparable<CounterCell> {\n                final int idx;\n                int count;\n\n                CounterCell(final int idx, final int count) {\n                    this.idx = idx;\n                    this.count = count;\n                }\n\n                @Override\n                public int compareTo(final CounterCell other) {\n                    return Integer.compare(idx, other.idx);\n                }\n            }\n\n            TreeMap<CounterCell, CounterCell> counterCells = new TreeMap<>();\n\n            @Override\n            public int[] asIndexArray() {\n                populate();\n                return counterCells.keySet().stream().mapToInt(c -> c.idx).toArray();\n            }\n\n            private void populate() {\n                if (counterCells.isEmpty()) {\n                    indexExtractor.processIndices(idx -> {\n                        final CounterCell cell = new CounterCell(idx, 1);\n                        final CounterCell counter = counterCells.get(cell);\n                        if (counter == null) {\n                            counterCells.put(cell, cell);\n                        } else {\n                            counter.count++;\n                        }\n                        return true;\n                    });\n                }\n            }\n\n            @Override\n            public boolean processCells(final CellPredicate consumer) {\n                populate();\n                for (final CounterCell cell : counterCells.values()) {\n                    if (!consumer.test(cell.idx, cell.count)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        };\n    }\n\n    /**\n     * Performs the given action for each {@code cell}  where the cell count is non-zero.\n     *\n     * <p>Some Bloom filter implementations use a count rather than a bit flag.  The term {@code Cell} is used to\n     * refer to these counts.</p>\n     *\n     * <p>Any exceptions thrown by the action are relayed to the caller. The consumer is applied to each\n     * cell. If the consumer returns {@code false} the execution is stopped, {@code false}\n     * is returned, and no further pairs are processed.</p>\n     *\n     * @param consumer the action to be performed for each non-zero cell.\n     * @return {@code true} if all cells return true from consumer, {@code false} otherwise.\n     * @throws NullPointerException if the specified consumer is null\n     */\n    boolean processCells(CellPredicate consumer);\n\n    /**\n     * The default implementation returns distinct and ordered indices for all cells with a non-zero count.\n     */\n    @Override\n    default boolean processIndices(final IntPredicate predicate) {\n        return processCells((i, v) -> predicate.test(i));\n    }\n\n    @Override\n    default IndexExtractor uniqueIndices() {\n        return this;\n    }\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractor.java.BloomFilterExtractor", "name": "BloomFilterExtractor", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractor.java", "superclasses": [], "methods": ["[BloomFilterExtractor]fromBloomFilterArray()", "[BloomFilter[]]asBloomFilterArray()", "[BloomFilter]flatten()", "[boolean]processBloomFilterPair(BloomFilterExtractor,BiPredicate<BloomFilter, BloomFilter>)", "[boolean]processBloomFilters(Predicate<BloomFilter>)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractor.java.BloomFilterExtractor.[BloomFilterExtractor]fromBloomFilterArray()", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractor.java.BloomFilterExtractor.[BloomFilter[]]asBloomFilterArray()", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractor.java.BloomFilterExtractor.[BloomFilter]flatten()", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractor.java.BloomFilterExtractor.[boolean]processBloomFilterPair(BloomFilterExtractor,BiPredicate<BloomFilter, BloomFilter>)", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilterExtractor.java.BloomFilterExtractor.[boolean]processBloomFilters(Predicate<BloomFilter>)"], "overrides": null, "attributes": null, "class_docstring": "\nProduces Bloom filters from a collection (for example, {@link LayeredBloomFilter}).\n\n@since 4.5.0\n", "original_string": "@FunctionalInterface\npublic interface BloomFilterExtractor {\n\n    /**\n     * Creates a BloomFilterExtractor from an array of Bloom filters.\n     *\n     * <ul>\n     * <li>The asBloomFilterArray() method returns a copy of the original array\n     * with references to the original filters.</li>\n     * <li>The forEachBloomFilterPair() method uses references to the original filters.</li>\n     * </ul>\n     * <p><em>All modifications to the Bloom filters are reflected in the original filters</em></p>\n     *\n     * @param filters The filters to be returned by the extractor.\n     * @return THe BloomFilterExtractor containing the filters.\n     */\n    static BloomFilterExtractor fromBloomFilterArray(final BloomFilter... filters) {\n        Objects.requireNonNull(filters, \"filters\");\n        return new BloomFilterExtractor() {\n            /**\n             * This implementation returns a copy the original array, the contained Bloom filters\n             * are references to the originals, any modifications to them are reflected in the original\n             * filters.\n             */\n            @Override\n            public BloomFilter[] asBloomFilterArray() {\n                return filters.clone();\n            }\n\n            /**\n             * This implementation uses references to the original filters.  Any modifications to the\n             * filters are reflected in the originals.\n             */\n            @Override\n            public boolean processBloomFilterPair(final BloomFilterExtractor other,\n                                                  final BiPredicate<BloomFilter, BloomFilter> func) {\n                final CountingPredicate<BloomFilter> p = new CountingPredicate<>(filters, func);\n                return other.processBloomFilters(p) && p.processRemaining();\n            }\n\n            @Override\n            public boolean processBloomFilters(final Predicate<BloomFilter> predicate) {\n                for (final BloomFilter filter : filters) {\n                    if (!predicate.test(filter)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        };\n    }\n\n    /**\n     * Return an array of the Bloom filters in the collection.\n     * <p><em>Implementations should specify if the array contains deep copies, immutable instances,\n     * or references to the filters in the collection.</em></p>\n     * <p>The default method returns a deep copy of the enclosed filters.</p>\n     *\n     * @return An array of Bloom filters.\n     */\n    default BloomFilter[] asBloomFilterArray() {\n        final List<BloomFilter> filters = new ArrayList<>();\n        processBloomFilters(f -> filters.add(f.copy()));\n        return filters.toArray(new BloomFilter[0]);\n    }\n\n    /**\n     * Create a standard (non-layered) Bloom filter by merging all of the layers. If\n     * the filter is empty this method will return an empty Bloom filter.\n     *\n     * @return the merged bloom filter.\n     */\n    default BloomFilter flatten() {\n        final BloomFilter[] bf = {null};\n        processBloomFilters(x -> {\n            if (bf[0] == null) {\n                bf[0] = new SimpleBloomFilter( x.getShape());\n            }\n            return bf[0].merge( x );\n        });\n        return bf[0];\n    }\n\n    /**\n     * Applies the {@code func} to each Bloom filter pair in order. Will apply all\n     * of the Bloom filters from the other BloomFilterExtractor to this extractor. If\n     * either {@code this} extractor or {@code other} extractor has fewer BloomFilters\n     * ths method will provide {@code null} for all excess calls to the {@code func}.\n     *\n     * <p><em>This implementation returns references to the Bloom filter.  Other implementations\n     * should specify if the array contains deep copies, immutable instances,\n     * or references to the filters in the collection.</em></p>\n     *\n     * @param other The other BloomFilterExtractor that provides the y values in the\n     *              (x,y) pair.\n     * @param func  The function to apply.\n     * @return {@code true} if the {@code func} returned {@code true} for every pair,\n     *         {@code false} otherwise.\n     */\n    default boolean processBloomFilterPair(final BloomFilterExtractor other,\n                                           final BiPredicate<BloomFilter, BloomFilter> func) {\n        final CountingPredicate<BloomFilter> p = new CountingPredicate<>(asBloomFilterArray(), func);\n        return other.processBloomFilters(p) && p.processRemaining();\n    }\n\n    /**\n     * Executes a Bloom filter Predicate on each Bloom filter in the collection. The\n     * ordering of the Bloom filters is not specified by this interface.\n     *\n     * @param bloomFilterPredicate the predicate to evaluate each Bloom filter with.\n     * @return {@code false} when the first filter fails the predicate test. Returns\n     *         {@code true} if all filters pass the test.\n     */\n    boolean processBloomFilters(Predicate<BloomFilter> bloomFilterPredicate);\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter", "name": "CountingBloomFilter", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java", "superclasses": ["BloomFilter", "CellExtractor"], "methods": ["[boolean]add(CellExtractor)", "[CountingBloomFilter]copy()", "[int]getMaxCell()", "[int]getMaxInsert(BitMapExtractor)", "[int]getMaxInsert(BloomFilter)", "[int]getMaxInsert(CellExtractor)", "[int]getMaxInsert(Hasher)", "[int]getMaxInsert(IndexExtractor)", "[boolean]isValid()", "[boolean]merge(BitMapExtractor)", "[boolean]merge(BloomFilter)", "[boolean]merge(Hasher)", "[boolean]merge(IndexExtractor)", "[boolean]remove(BitMapExtractor)", "[boolean]remove(BloomFilter)", "[boolean]remove(Hasher)", "[boolean]remove(IndexExtractor)", "[boolean]subtract(CellExtractor)", "[IndexExtractor]uniqueIndices()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[boolean]add(CellExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[CountingBloomFilter]copy()", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[int]getMaxCell()", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[int]getMaxInsert(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[int]getMaxInsert(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[int]getMaxInsert(CellExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[int]getMaxInsert(Hasher)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[int]getMaxInsert(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[boolean]isValid()", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[boolean]merge(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[boolean]merge(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[boolean]merge(Hasher)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[boolean]merge(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[boolean]remove(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[boolean]remove(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[boolean]remove(Hasher)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[boolean]remove(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[boolean]subtract(CellExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/CountingBloomFilter.java.CountingBloomFilter.[IndexExtractor]uniqueIndices()"], "overrides": null, "attributes": null, "class_docstring": "\nThe interface that describes a Bloom filter that associates a count with each\nbit index rather than a bit.  This allows reversal of merge operations with\nremove operations.\n\n<p>A counting Bloom filter is expected to function identically to a standard\nBloom filter that is the merge of all the Bloom filters that have been added\nto and not later subtracted from the counting Bloom filter. The functional\nstate of a CountingBloomFilter at the start and end of a series of merge and\nsubsequent remove operations of the same Bloom filters, irrespective of\nremove order, is expected to be the same.</p>\n\n<p>Removal of a filter that has not previously been merged results in an\ninvalid state where the cells no longer represent a sum of merged Bloom\nfilters. It is impossible to validate merge and remove exactly without\nexplicitly storing all filters. Consequently such an operation may go\nundetected. The CountingBloomFilter maintains a state flag that is used as a\nwarning that an operation was performed that resulted in invalid cells and\nthus an invalid state. For example this may occur if a cell for an index was\nset to negative following a remove operation.</p>\n\n<p>Implementations should document the expected state of the filter after an\noperation that generates invalid cells, and any potential recovery options.\nAn implementation may support a reversal of the operation to restore the\nstate to that prior to the operation. In the event that invalid cells are\nadjusted to a valid range then it should be documented if there has been\nirreversible information loss.</p>\n\n<p>Implementations may choose to throw an exception during an operation that\ngenerates invalid cells. Implementations should document the expected state\nof the filter after such an operation. For example are the cells not updated,\npartially updated or updated entirely before the exception is raised.</p>\n\n@see CellExtractor\n@since 4.5.0\n", "original_string": "public interface CountingBloomFilter extends BloomFilter, CellExtractor {\n\n    // Query Operations\n\n    /**\n     * Adds the specified CellExtractor to this Bloom filter.\n     *\n     * <p>Specifically\n     * all cells for the indexes identified by the {@code other} will be incremented\n     * by their corresponding values in the {@code other}.</p>\n     *\n     * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n     *\n     * @param other the CellExtractor to add.\n     * @return {@code true} if the addition was successful and the state is valid\n     * @see #isValid()\n     * @see #subtract(CellExtractor)\n     */\n    boolean add(CellExtractor other);\n\n    /**\n     * Creates a new instance of the CountingBloomFilter with the same properties as the current one.\n     * @return a copy of this CountingBloomFilter\n     */\n    @Override\n    CountingBloomFilter copy();\n\n    /**\n     * Returns the maximum allowable value for a cell count in this Counting filter.\n     * @return the maximum allowable value for a cell count in this Counting filter.\n     */\n    int getMaxCell();\n\n    /**\n     * Determines the maximum number of times the BitMapExtractor could have been merged into this\n     * counting filter.\n     * @param bitMapExtractor the BitMapExtractor to provide the indices.\n     * @return the maximum number of times the BitMapExtractor could have been inserted.\n     */\n    default int getMaxInsert(final BitMapExtractor bitMapExtractor) {\n        if (!contains(bitMapExtractor)) {\n            return 0;\n        }\n        final long[] bitMaps = bitMapExtractor.asBitMapArray();\n        final int[] max = { Integer.MAX_VALUE };\n        processCells((x, y) -> {\n            if ((bitMaps[BitMaps.getLongIndex(x)] & BitMaps.getLongBit(x)) != 0) {\n                max[0] = max[0] <= y ? max[0] : y;\n            }\n            return true;\n        });\n        return max[0];\n    }\n\n    /**\n     * Determines the maximum number of times the Bloom filter could have been merged\n     * into this counting filter.\n     * @param bloomFilter the Bloom filter the check for.\n     * @return the maximum number of times the Bloom filter could have been inserted.\n     */\n    default int getMaxInsert(final BloomFilter bloomFilter) {\n        return getMaxInsert((BitMapExtractor) bloomFilter);\n    }\n\n    /**\n     * Determines the maximum number of times the Cell Extractor could have been added.\n     * @param cellExtractor the extractor of cells.\n     * @return the maximum number of times the CellExtractor could have been inserted.\n     */\n    int getMaxInsert(CellExtractor cellExtractor);\n\n    /**\n     * Determines the maximum number of times the Hasher could have been merged into this\n     * counting filter.\n     * @param hasher the Hasher to provide the indices.\n     * @return the maximum number of times the hasher could have been inserted.\n     */\n    default int getMaxInsert(final Hasher hasher) {\n        return getMaxInsert(hasher.indices(getShape()));\n    }\n\n    // Modification Operations\n\n    /**\n     * Determines the maximum number of times the IndexExtractor could have been merged\n     * into this counting filter.\n     * <p>To determine how many times an indexExtractor could have been added create a CellExtractor\n     * from the indexExtractor and check that</p>\n     * @param indexExtractor the extractor to drive the count check.\n     * @return the maximum number of times the IndexExtractor could have been inserted.\n     * @see #getMaxInsert(CellExtractor)\n     */\n    default int getMaxInsert(final IndexExtractor indexExtractor) {\n        return getMaxInsert(CellExtractor.from(indexExtractor.uniqueIndices()) );\n    }\n\n    /**\n     * Returns {@code true} if the internal state is valid.\n     *\n     * <p>This flag is a warning that an addition or\n     * subtraction of cells from this filter resulted in an invalid cell for one or more\n     * indexes. For example this may occur if a cell for an index was\n     * set to negative following a subtraction operation, or overflows the value specified by {@code getMaxCell()} following an\n     * addition operation.</p>\n     *\n     * <p>A counting Bloom filter that has an invalid state is no longer ensured to function\n     * identically to a standard Bloom filter instance that is the merge of all the Bloom filters\n     * that have been added to and not later subtracted from this counting Bloom filter.</p>\n     *\n     * <p>Note: The change to an invalid state may or may not be reversible. Implementations\n     * are expected to document their policy on recovery from an addition or removal operation\n     * that generated an invalid state.</p>\n     *\n     * @return {@code true} if the state is valid\n     */\n    boolean isValid();\n\n    /**\n     * Merges the specified BitMap extractor into this Bloom filter.\n     *\n     * <p>Specifically: all cells for the indexes identified by the {@code bitMapExtractor} will be incremented by 1.</p>\n     *\n     * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n     *\n     * @param bitMapExtractor the BitMapExtractor\n     * @return {@code true} if the removal was successful and the state is valid\n     * @see #isValid()\n     * @see #add(CellExtractor)\n     */\n    @Override\n    default boolean merge(final BitMapExtractor bitMapExtractor) {\n        return merge(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n    }\n\n    /**\n     * Merges the specified Bloom filter into this Bloom filter.\n     *\n     * <p>Specifically: all cells for the indexes identified by the {@code other} filter will be incremented by 1.</p>\n     *\n     * <p>Note: If the other filter is a counting Bloom filter the other filter's cells are ignored and it is treated as an\n     * IndexExtractor.</p>\n     *\n     * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n     *\n     * @param other the other Bloom filter\n     * @return {@code true} if the removal was successful and the state is valid\n     * @see #isValid()\n     * @see #add(CellExtractor)\n     */\n    @Override\n    default boolean merge(final BloomFilter other) {\n        Objects.requireNonNull(other, \"other\");\n        return merge((IndexExtractor) other);\n    }\n\n    /**\n     * Merges the specified Hasher into this Bloom filter.\n     *\n     * <p>Specifically: all cells for the unique indexes identified by the {@code hasher} will be incremented by 1.</p>\n     *\n     * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n     *\n     * @param hasher the hasher\n     * @return {@code true} if the removal was successful and the state is valid\n     * @see #isValid()\n     * @see #add(CellExtractor)\n     */\n    @Override\n    default boolean merge(final Hasher hasher) {\n        Objects.requireNonNull(hasher, \"hasher\");\n        return merge(hasher.indices(getShape()));\n    }\n\n    /**\n     * Merges the specified index extractor into this Bloom filter.\n     *\n     * <p>Specifically: all unique cells for the indices identified by the {@code indexExtractor} will be incremented by 1.</p>\n     *\n     * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n     *\n     * <p>Notes:</p>\n     * <ul>\n     * <li>If indices that are returned multiple times should be incremented multiple times convert the IndexExtractor\n     * to a CellExtractor and add that.</li>\n     * <li>Implementations should throw {@code IllegalArgumentException} and no other exception on bad input.</li>\n     * </ul>\n     * @param indexExtractor the IndexExtractor\n     * @return {@code true} if the removal was successful and the state is valid\n     * @see #isValid()\n     * @see #add(CellExtractor)\n     */\n    @Override\n    default boolean merge(final IndexExtractor indexExtractor) {\n        Objects.requireNonNull(indexExtractor, \"indexExtractor\");\n        try {\n            return add(CellExtractor.from(indexExtractor.uniqueIndices()));\n        } catch (final IndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(\n                    String.format(\"Filter only accepts values in the [0,%d) range\", getShape().getNumberOfBits()), e);\n        }\n    }\n\n    /**\n     * Removes the specified BitMapExtractor from this Bloom filter.\n     *\n     * <p>Specifically all cells for the indices produced by the {@code bitMapExtractor} will be\n     * decremented by 1.</p>\n     *\n     * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n     *\n     * @param bitMapExtractor the BitMapExtractor to provide the indexes\n     * @return {@code true} if the removal was successful and the state is valid\n     * @see #isValid()\n     * @see #subtract(CellExtractor)\n     */\n    default boolean remove(final BitMapExtractor bitMapExtractor) {\n        return remove(IndexExtractor.fromBitMapExtractor(bitMapExtractor));\n    }\n\n    /**\n     * Removes the specified Bloom filter from this Bloom filter.\n     *\n     * <p>Specifically: all cells for the indexes identified by the {@code other} filter will be decremented by 1.</p>\n     *\n     * <p>Note: If the other filter is a counting Bloom filter the other filter's cells are ignored and it is treated as an\n     * IndexExtractor.</p>\n     *\n     * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n     *\n     * @param other the other Bloom filter\n     * @return {@code true} if the removal was successful and the state is valid\n     * @see #isValid()\n     * @see #subtract(CellExtractor)\n     */\n    default boolean remove(final BloomFilter other) {\n        return remove((IndexExtractor) other);\n    }\n\n    /**\n     * Removes the unique values from the specified hasher from this Bloom filter.\n     *\n     * <p>Specifically all cells for the unique indices produced by the {@code hasher} will be\n     * decremented by 1.</p>\n     *\n     * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n     *\n     * @param hasher the hasher to provide the indexes\n     * @return {@code true} if the removal was successful and the state is valid\n     * @see #isValid()\n     * @see #subtract(CellExtractor)\n     */\n    default boolean remove(final Hasher hasher) {\n        Objects.requireNonNull(hasher, \"hasher\");\n        return remove(hasher.indices(getShape()));\n    }\n\n    /**\n     * Removes the values from the specified IndexExtractor from the Bloom filter from this Bloom filter.\n     *\n     * <p>Specifically all cells for the unique indices produced by the {@code hasher} will be\n     * decremented by 1.</p>\n     *\n     * <p>This method will return {@code true} if the filter is valid after the operation.</p>\n     *\n     * <p>Note: If indices that are returned multiple times should be decremented multiple times convert the IndexExtractor\n     * to a CellExtractor and subtract that.</p>\n     *\n     * @param indexExtractor the IndexExtractor to provide the indexes\n     * @return {@code true} if the removal was successful and the state is valid\n     * @see #isValid()\n     * @see #subtract(CellExtractor)\n     */\n    default boolean remove(final IndexExtractor indexExtractor) {\n        Objects.requireNonNull(indexExtractor, \"indexExtractor\");\n        try {\n            return subtract(CellExtractor.from(indexExtractor.uniqueIndices()));\n        } catch (final IndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(\n                    String.format(\"Filter only accepts values in the [0,%d) range\", getShape().getNumberOfBits()));\n        }\n    }\n\n\n    /**\n     * Adds the specified CellExtractor to this Bloom filter.\n     *\n     * <p>Specifically\n     * all cells for the indexes identified by the {@code other} will be decremented\n     * by their corresponding values in the {@code other}.</p>\n     *\n     * <p>This method will return true if the filter is valid after the operation.</p>\n     *\n     * @param other the CellExtractor to subtract.\n     * @return {@code true} if the subtraction was successful and the state is valid\n     * @see #isValid()\n     * @see #add(CellExtractor)\n     */\n    boolean subtract(CellExtractor other);\n\n    /**\n     * The default implementation is a no-op since the counting bloom filter returns an unique IndexExtractor by default.\n     * @return this counting Bloom filter.\n     */\n    @Override\n    default IndexExtractor uniqueIndices() {\n        return this;\n    }\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/LongBiPredicate.java.LongBiPredicate", "name": "LongBiPredicate", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/LongBiPredicate.java", "superclasses": [], "methods": ["[boolean]test(long,long)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/LongBiPredicate.java.LongBiPredicate.[boolean]test(long,long)"], "overrides": null, "attributes": null, "class_docstring": "\nRepresents a function that accepts a two long-valued argument and produces a binary result.\nThis is the long-consuming primitive specialization for {@code BiPredicate}.\n\nThis is a functional interface whose functional method is {@code test(long,long)}.\n\n@since 4.5.0\n", "original_string": "@FunctionalInterface\npublic interface LongBiPredicate {\n\n    /**\n     * A function that takes to long arguments and returns a boolean.\n     * @param x the first long argument.\n     * @param y the second long argument.\n     * @return true or false.\n     */\n    boolean test(long x, long y);\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/IndexExtractor.java.IndexExtractor", "name": "IndexExtractor", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/IndexExtractor.java", "superclasses": [], "methods": ["[IndexExtractor]fromBitMapExtractor(BitMapExtractor)", "[IndexExtractor]fromIndexArray()", "[int[]]asIndexArray()", "[boolean]processIndices(IntPredicate)", "[IndexExtractor]uniqueIndices()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/IndexExtractor.java.IndexExtractor.[IndexExtractor]fromBitMapExtractor(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/IndexExtractor.java.IndexExtractor.[IndexExtractor]fromIndexArray()", "src/main/java/org/apache/commons/collections4/bloomfilter/IndexExtractor.java.IndexExtractor.[int[]]asIndexArray()", "src/main/java/org/apache/commons/collections4/bloomfilter/IndexExtractor.java.IndexExtractor.[boolean]processIndices(IntPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/IndexExtractor.java.IndexExtractor.[IndexExtractor]uniqueIndices()"], "overrides": null, "attributes": null, "class_docstring": "\nAn object that produces indices of a Bloom filter.\n<p><em>\nThe default implementation of {@code asIndexArray} is slow. Implementers should reimplement the\nmethod where possible.</em></p>\n\n@since 4.5.0\n", "original_string": "@FunctionalInterface\npublic interface IndexExtractor {\n\n    /**\n     * Creates an IndexExtractor from a {@code BitMapExtractor}.\n     * @param bitMapExtractor the {@code BitMapExtractor}\n     * @return a new {@code IndexExtractor}.\n     */\n    static IndexExtractor fromBitMapExtractor(final BitMapExtractor bitMapExtractor) {\n        Objects.requireNonNull(bitMapExtractor, \"bitMapExtractor\");\n        return consumer -> {\n            final LongPredicate longPredicate = new LongPredicate() {\n                int wordIdx;\n\n                @Override\n                public boolean test(long word) {\n                    int i = wordIdx;\n                    while (word != 0) {\n                        if ((word & 1) == 1 && !consumer.test(i)) {\n                            return false;\n                        }\n                        word >>>= 1;\n                        i++;\n                    }\n                    wordIdx += 64;\n                    return true;\n                }\n            };\n            return bitMapExtractor.processBitMaps(longPredicate::test);\n        };\n    }\n\n    /**\n     * Creates an IndexExtractor from an array of integers.\n     * @param values the index values\n     * @return an IndexExtractor that uses the values.\n     */\n    static IndexExtractor fromIndexArray(final int... values) {\n        return new IndexExtractor() {\n\n            @Override\n            public int[] asIndexArray() {\n                return values.clone();\n            }\n\n            @Override\n            public boolean processIndices(final IntPredicate predicate) {\n                for (final int value : values) {\n                    if (!predicate.test(value)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        };\n    }\n\n    /**\n     * Return a copy of the IndexExtractor data as an int array.\n     *\n     * <p>Indices ordering and uniqueness is not guaranteed.</p>\n     *\n     * <p><em>\n     * The default implementation of this method creates an array and populates\n     * it.  Implementations that have access to an index array should consider\n     * returning a copy of that array if possible.\n     * </em></p>\n     *\n     * @return An int array of the data.\n     */\n    default int[] asIndexArray() {\n        class Indices {\n            private int[] data = new int[32];\n            private int size;\n\n            boolean add(final int index) {\n                data = IndexUtils.ensureCapacityForAdd(data, size);\n                data[size++] = index;\n                return true;\n            }\n\n            int[] toArray() {\n                // Edge case to avoid a large array copy\n                return size == data.length ? data : Arrays.copyOf(data, size);\n            }\n        }\n        final Indices indices = new Indices();\n        processIndices(indices::add);\n        return indices.toArray();\n    }\n\n    /**\n     * Each index is passed to the predicate. The predicate is applied to each\n     * index value, if the predicate returns {@code false} the execution is stopped, {@code false}\n     * is returned, and no further indices are processed.\n     *\n     * <p>Any exceptions thrown by the action are relayed to the caller.</p>\n     *\n     * <p>Indices ordering and uniqueness is not guaranteed.</p>\n     *\n     * @param predicate the action to be performed for each non-zero bit index.\n     * @return {@code true} if all indexes return true from consumer, {@code false} otherwise.\n     * @throws NullPointerException if the specified action is null\n     */\n    boolean processIndices(IntPredicate predicate);\n\n    /**\n     * Creates an IndexExtractor comprising the unique indices for this extractor.\n     *\n     * <p>By default creates a new extractor with some overhead to remove\n     * duplicates.  IndexExtractors that return unique indices by default\n     * should override this to return {@code this}.</p>\n     *\n     * <p>The default implementation will filter the indices from this instance\n     * and return them in ascending order.</p>\n     *\n     * @return the IndexExtractor of unique values.\n     * @throws IndexOutOfBoundsException if any index is less than zero.\n     */\n    default IndexExtractor uniqueIndices() {\n        final BitSet bitSet = new BitSet();\n        processIndices(i -> {\n            bitSet.set(i);\n            return true;\n        });\n\n        return new IndexExtractor() {\n            @Override\n            public boolean processIndices(final IntPredicate predicate) {\n                for (int idx = bitSet.nextSetBit(0); idx >= 0; idx = bitSet.nextSetBit(idx + 1)) {\n                    if (!predicate.test(idx)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            @Override\n            public IndexExtractor uniqueIndices() {\n                return this;\n            }\n        };\n    }\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java.Hasher", "name": "Hasher", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java", "superclasses": [], "methods": ["[IndexExtractor]indices(Shape)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/Hasher.java.Hasher.[IndexExtractor]indices(Shape)"], "overrides": null, "attributes": null, "class_docstring": "\nA Hasher creates {@link IndexExtractor}s based on the hash implementation and the\nprovided {@link Shape}.\n\n@since 4.5.0\n", "original_string": "public interface Hasher {\n\n    /**\n     * Creates an IndexExtractor for this hasher based on the Shape.\n     *\n     * <p>The {@code IndexExtractor} will create indices within the range defined by the number of bits in\n     * the shape. The total number of indices will respect the number of hash functions per item\n     * defined by the shape. However the count of indices may not be a multiple of the number of\n     * hash functions if the implementation has removed duplicates.</p>\n     *\n     * <p>This IndexExtractor must be deterministic in that it must return the same indices for the\n     * same Shape.</p>\n     *\n     * <p>No guarantee is made as to order of indices.</p>\n     * <p>Duplicates indices for a single item may be produced.</p>\n     *\n     * @param shape the shape of the desired Bloom filter.\n     * @return the iterator of integers\n     */\n    IndexExtractor indices(Shape shape);\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter", "name": "BloomFilter", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java", "superclasses": ["IndexExtractor", "BitMapExtractor"], "methods": ["[int]cardinality()", "[int]characteristics()", "[void]clear()", "[boolean]contains(BitMapExtractor)", "[boolean]contains(BloomFilter)", "[boolean]contains(Hasher)", "[boolean]contains(IndexExtractor)", "[T]copy()", "[int]estimateIntersection(BloomFilter)", "[int]estimateN()", "[int]estimateUnion(BloomFilter)", "[Shape]getShape()", "[boolean]isEmpty()", "[boolean]isFull()", "[boolean]merge(BitMapExtractor)", "[boolean]merge(BloomFilter)", "[boolean]merge(Hasher)", "[boolean]merge(IndexExtractor)", "[IndexExtractor]uniqueIndices()"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[int]cardinality()", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[int]characteristics()", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[void]clear()", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[boolean]contains(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[boolean]contains(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[boolean]contains(Hasher)", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[boolean]contains(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[T]copy()", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[int]estimateIntersection(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[int]estimateN()", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[int]estimateUnion(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[Shape]getShape()", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[boolean]isEmpty()", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[boolean]isFull()", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[boolean]merge(BitMapExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[boolean]merge(BloomFilter)", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[boolean]merge(Hasher)", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[boolean]merge(IndexExtractor)", "src/main/java/org/apache/commons/collections4/bloomfilter/BloomFilter.java.BloomFilter.[IndexExtractor]uniqueIndices()"], "overrides": null, "attributes": null, "class_docstring": "\nThe interface that describes a Bloom filter.\n<p>\n<em>See implementation notes for {@link BitMapExtractor} and {@link IndexExtractor}.</em>\n</p>\n@see BitMapExtractor\n@see IndexExtractor\n@since 4.5.0\n", "original_string": "public interface BloomFilter extends IndexExtractor, BitMapExtractor {\n\n    /**\n     * The sparse characteristic used to determine the best method for matching.\n     * <p>For `sparse` implementations\n     * the {@code forEachIndex(IntConsumer consumer)} method is more efficient. For non `sparse` implementations\n     * the {@code forEachBitMap(LongConsumer consumer)} is more efficient. Implementers should determine if it is easier\n     * for the implementation to produce indexes of bit map blocks.</p>\n     */\n    int SPARSE = 0x1;\n\n    /**\n     * Gets the cardinality (number of enabled bits) of this Bloom filter.\n     *\n     * <p>This is also known as the Hamming value or Hamming number.</p>\n     *\n     * @return the cardinality of this filter\n     */\n    int cardinality();\n\n    // Query Operations\n\n    /**\n     * Returns the characteristics of the filter.\n     * <p>\n     * Characteristics are defined as bits within the characteristics integer.\n     * @return the characteristics for this bloom filter.\n     */\n    int characteristics();\n\n    /**\n     * Resets the filter to its initial, unpopulated state.\n     */\n    void clear();\n\n    /**\n     * Returns {@code true} if this filter contains the bits specified in the bit maps produced by the\n     * bitMapExtractor.\n     *\n     * @param bitMapExtractor the {@code BitMapExtractor} to provide the bit maps.\n     * @return {@code true} if this filter is enabled for all bits specified by the bit maps\n     */\n    default boolean contains(final BitMapExtractor bitMapExtractor) {\n        return processBitMapPairs(bitMapExtractor, (x, y) -> (x & y) == y);\n    }\n\n    /**\n     * Returns {@code true} if this filter contains the specified filter.\n     *\n     * <p>Specifically this\n     * returns {@code true} if this filter is enabled for all bits that are enabled in the\n     * {@code other} filter. Using the bit representations this is\n     * effectively {@code (this AND other) == other}.</p>\n     *\n     * @param other the other Bloom filter\n     * @return true if all enabled bits in the other filter are enabled in this filter.\n     */\n    default boolean contains(final BloomFilter other) {\n        Objects.requireNonNull(other, \"other\");\n        return (characteristics() & SPARSE) != 0 ? contains((IndexExtractor) other) : contains((BitMapExtractor) other);\n    }\n\n    /**\n     * Returns {@code true} if this filter contains the bits specified in the hasher.\n     *\n     * <p>Specifically this returns {@code true} if this filter is enabled for all bit indexes\n     * identified by the {@code hasher}. Using the bit map representations this is\n     * effectively {@code (this AND hasher) == hasher}.</p>\n     *\n     * @param hasher the hasher to provide the indexes\n     * @return true if this filter is enabled for all bits specified by the hasher\n     */\n    default boolean contains(final Hasher hasher) {\n        Objects.requireNonNull(hasher, \"Hasher\");\n        final Shape shape = getShape();\n        return contains(hasher.indices(shape));\n    }\n\n    /**\n     * Returns {@code true} if this filter contains the indices specified IndexExtractor.\n     *\n     * <p>Specifically this returns {@code true} if this filter is enabled for all bit indexes\n     * identified by the {@code IndexExtractor}.</p>\n     *\n     * @param indexExtractor the IndexExtractor to provide the indexes\n     * @return {@code true} if this filter is enabled for all bits specified by the IndexExtractor\n     */\n    boolean contains(IndexExtractor indexExtractor);\n\n    /**\n     * Creates a new instance of the BloomFilter with the same properties as the current one.\n     *\n     * @param <T> Type of BloomFilter.\n     * @return a copy of this BloomFilter\n     */\n    <T extends BloomFilter> T copy();\n\n    // update operations\n\n    /**\n     * Estimates the number of items in the intersection of this Bloom filter with the other bloom filter.\n     *\n     * <p>This method produces estimate is roughly equivalent to the number of unique Hashers that have been merged into both\n     * of the filters by rounding the value from the calculation described in the {@link Shape} class Javadoc.</p>\n     *\n     * <p><em>{@code estimateIntersection} should only be called with Bloom filters of the same Shape.  If called on Bloom\n     * filters of differing shape this method is not symmetric. If {@code other} has more bits an {@code IllegalArgumentException}\n     * may be thrown.</em></p>\n     *\n     * @param other The other Bloom filter\n     * @return an estimate of the number of items in the intersection. If the calculated estimate is larger than Integer.MAX_VALUE then MAX_VALUE is returned.\n     * @throws IllegalArgumentException if the estimated N for the union of the filters is infinite.\n     * @see #estimateN()\n     * @see Shape\n     */\n    default int estimateIntersection(final BloomFilter other) {\n        Objects.requireNonNull(other, \"other\");\n        final double eThis = getShape().estimateN(cardinality());\n        final double eOther = getShape().estimateN(other.cardinality());\n        if (Double.isInfinite(eThis) && Double.isInfinite(eOther)) {\n            // if both are infinite the union is infinite and we return Integer.MAX_VALUE\n            return Integer.MAX_VALUE;\n        }\n        long estimate;\n        // if one is infinite the intersection is the other.\n        if (Double.isInfinite(eThis)) {\n            estimate = Math.round(eOther);\n        } else if (Double.isInfinite(eOther)) {\n            estimate = Math.round(eThis);\n        } else {\n            final BloomFilter union = this.copy();\n            union.merge(other);\n            final double eUnion = getShape().estimateN(union.cardinality());\n            if (Double.isInfinite(eUnion)) {\n                throw new IllegalArgumentException(\"The estimated N for the union of the filters is infinite\");\n            }\n            // maximum estimate value using integer values is: 46144189292 thus\n            // eThis + eOther can not overflow the long value.\n            estimate = Math.round(eThis + eOther - eUnion);\n            estimate = estimate < 0 ? 0 : estimate;\n        }\n        return estimate > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) estimate;\n    }\n\n    /**\n     * Estimates the number of items in the Bloom filter.\n     *\n     * <p>By default this is the rounding of the {@code Shape.estimateN(cardinality)} calculation for the\n     * shape and cardinality of this filter.</p>\n     *\n     * <p>This produces an estimate roughly equivalent to the number of Hashers that have been merged into the filter\n     * by rounding the value from the calculation described in the {@link Shape} class Javadoc.</p>\n     *\n     * <p><em>Note:</em></p>\n     * <ul>\n     * <li>if cardinality == numberOfBits, then result is Integer.MAX_VALUE.</li>\n     * <li>if cardinality &gt; numberOfBits, then an IllegalArgumentException is thrown.</li>\n     * </ul>\n     *\n     * @return an estimate of the number of items in the bloom filter.  Will return Integer.MAX_VALUE if the\n     * estimate is larger than Integer.MAX_VALUE.\n     * @throws IllegalArgumentException if the cardinality is &gt; numberOfBits as defined in Shape.\n     * @see Shape#estimateN(int)\n     * @see Shape\n     */\n    default int estimateN() {\n        final double d = getShape().estimateN(cardinality());\n        if (Double.isInfinite(d)) {\n            return Integer.MAX_VALUE;\n        }\n        if (Double.isNaN(d)) {\n            throw new IllegalArgumentException(\"Cardinality too large: \" + cardinality());\n        }\n        final long l = Math.round(d);\n        return l > Integer.MAX_VALUE ? Integer.MAX_VALUE : (int) l;\n    }\n\n    /**\n     * Estimates the number of items in the union of this Bloom filter with the other bloom filter.\n     *\n     * <p>This produces an estimate roughly equivalent to the number of unique Hashers that have been merged into either\n     * of the filters by rounding the value from the calculation described in the {@link Shape} class Javadoc.</p>\n     *\n     * <p><em>{@code estimateUnion} should only be called with Bloom filters of the same Shape.  If called on Bloom\n     * filters of differing shape this method is not symmetric. If {@code other} has more bits an {@code IllegalArgumentException}\n     * may be thrown.</em></p>\n     *\n     * @param other The other Bloom filter\n     * @return an estimate of the number of items in the union.  Will return Integer.MAX_VALUE if the\n     * estimate is larger than Integer.MAX_VALUE.\n     * @see #estimateN()\n     * @see Shape\n     */\n    default int estimateUnion(final BloomFilter other) {\n        Objects.requireNonNull(other, \"other\");\n        final BloomFilter cpy = this.copy();\n        cpy.merge(other);\n        return cpy.estimateN();\n    }\n\n    /**\n     * Gets the shape that was used when the filter was built.\n     * @return The shape the filter was built with.\n     */\n    Shape getShape();\n\n    // Counting Operations\n\n    /**\n     * Determines if all the bits are off. This is equivalent to\n     * {@code cardinality() == 0}.\n     *\n     * <p>\n     * <em>Note: This method is optimised for non-sparse filters.</em> Implementers\n     * are encouraged to implement faster checks if possible.\n     * </p>\n     *\n     * @return {@code true} if no bits are enabled, {@code false} otherwise.\n     */\n    default boolean isEmpty() {\n        return processBitMaps(y -> y == 0);\n    }\n\n    /**\n     * Determines if the bloom filter is \"full\".\n     *\n     * <p>Full is defined as having no unset bits.</p>\n     *\n     * @return {@code true} if the filter is full, {@code false} otherwise.\n     */\n    default boolean isFull() {\n        return cardinality() == getShape().getNumberOfBits();\n    }\n\n    /**\n     * Merges the specified hasher into this Bloom filter. Specifically all\n     * bit indexes that are identified by the {@code bitMapExtractor} will be enabled in this filter.\n     *\n     * <p><em>Note: This method should return {@code true} even if no additional bit indexes were\n     * enabled. A {@code false} result indicates that this filter may or may not contain all the indexes\n     * enabled in the {@code bitMapExtractor}.</em>  This state may occur in complex Bloom filter implementations like\n     * counting Bloom filters.</p>\n     *\n     * @param bitMapExtractor The BitMapExtractor to merge.\n     * @return true if the merge was successful\n     * @throws IllegalArgumentException if bitMapExtractor sends illegal value.\n     */\n    boolean merge(BitMapExtractor bitMapExtractor);\n\n    /**\n     * Merges the specified Bloom filter into this Bloom filter.\n     *\n     * <p>Specifically all\n     * bit indexes that are identified by the {@code other} will be enabled in this filter.</p>\n     *\n     * <p><em>Note: This method should return {@code true} even if no additional bit indexes were\n     * enabled. A {@code false} result indicates that this filter may or may not contain\n     * the {@code other} Bloom filter.</em>  This state may occur in complex Bloom filter implementations like\n     * counting Bloom filters.</p>\n     *\n     * @param other The bloom filter to merge into this one.\n     * @return true if the merge was successful\n     */\n    default boolean merge(final BloomFilter other) {\n        return (characteristics() & SPARSE) != 0 ? merge((IndexExtractor) other) : merge((BitMapExtractor) other);\n    }\n\n    /**\n     * Merges the specified hasher into this Bloom filter. Specifically all\n     * bit indexes that are identified by the {@code hasher} will be enabled in this filter.\n     *\n     * <p><em>Note: This method should return {@code true} even if no additional bit indexes were\n     * enabled. A {@code false} result indicates that this filter may or may not contain\n     * the {@code hasher} values.</em>  This state may occur in complex Bloom filter implementations like\n     * counting Bloom filters.</p>\n     *\n     * @param hasher The hasher to merge.\n     * @return true if the merge was successful\n     * @throws IllegalArgumentException if hasher produces an illegal value.\n     */\n    default boolean merge(final Hasher hasher) {\n        Objects.requireNonNull(hasher, \"hasher\");\n        return merge(hasher.indices(getShape()));\n    }\n\n    /**\n     * Merges the specified IndexExtractor into this Bloom filter. Specifically all\n     * bit indexes that are identified by the {@code indexExtractor} will be enabled in this filter.\n     *\n     * <p><em>Note: This method should return {@code true} even if no additional bit indexes were\n     * enabled. A {@code false} result indicates that this filter may or may not contain all the indexes of\n     * the {@code indexExtractor}.</em>  This state may occur in complex Bloom filter implementations like\n     * counting Bloom filters.</p>\n     *\n     * @param indexExtractor The IndexExtractor to merge.\n     * @return true if the merge was successful\n     * @throws IllegalArgumentException if indexExtractor sends illegal value.\n     */\n    boolean merge(IndexExtractor indexExtractor);\n\n    /**\n     * Most Bloom filters create unique IndexExtractors.\n     */\n    @Override\n    default IndexExtractor uniqueIndices() {\n        return this;\n    }\n}"}, {"uris": "src/main/java/org/apache/commons/collections4/bloomfilter/BitMapExtractor.java.BitMapExtractor", "name": "BitMapExtractor", "file_path": "src/main/java/org/apache/commons/collections4/bloomfilter/BitMapExtractor.java", "superclasses": [], "methods": ["[BitMapExtractor]fromBitMapArray()", "[BitMapExtractor]fromIndexExtractor(IndexExtractor,int)", "[long[]]asBitMapArray()", "[boolean]processBitMapPairs(BitMapExtractor,LongBiPredicate)", "[boolean]processBitMaps(LongPredicate)"], "method_uris": ["src/main/java/org/apache/commons/collections4/bloomfilter/BitMapExtractor.java.BitMapExtractor.[BitMapExtractor]fromBitMapArray()", "src/main/java/org/apache/commons/collections4/bloomfilter/BitMapExtractor.java.BitMapExtractor.[BitMapExtractor]fromIndexExtractor(IndexExtractor,int)", "src/main/java/org/apache/commons/collections4/bloomfilter/BitMapExtractor.java.BitMapExtractor.[long[]]asBitMapArray()", "src/main/java/org/apache/commons/collections4/bloomfilter/BitMapExtractor.java.BitMapExtractor.[boolean]processBitMapPairs(BitMapExtractor,LongBiPredicate)", "src/main/java/org/apache/commons/collections4/bloomfilter/BitMapExtractor.java.BitMapExtractor.[boolean]processBitMaps(LongPredicate)"], "overrides": null, "attributes": null, "class_docstring": "\nProduces bit map longs for a Bloom filter.\n\nEach bit map is a little-endian long value representing a block of bits of in a filter.\n\n<p>The returned array will have length {@code ceil(m / 64)} where {@code m} is the\nnumber of bits in the filter and {@code ceil} is the ceiling function.\nBits 0-63 are in the first long. A value of 1 at a bit position indicates the bit\nindex is enabled.\n</p><p><em>\nThe default implementations of the {@code makePredicate()} and {@code asBitMapArray} methods\nare slow and should be reimplemented in the implementing classes where possible.</em></p>\n\n@since 4.5.0\n", "original_string": "@FunctionalInterface\npublic interface BitMapExtractor {\n\n    /**\n     * Creates a BitMapExtractor from an array of Long.\n     * @param bitMaps the bit maps to return.\n     * @return a BitMapExtractor.\n     */\n    static BitMapExtractor fromBitMapArray(final long... bitMaps) {\n        return new BitMapExtractor() {\n            @Override\n            public long[] asBitMapArray() {\n                return Arrays.copyOf(bitMaps, bitMaps.length);\n            }\n\n            @Override\n            public boolean processBitMapPairs(final BitMapExtractor other, final LongBiPredicate func) {\n                final CountingLongPredicate p = new CountingLongPredicate(bitMaps, func);\n                return other.processBitMaps(p) && p.processRemaining();\n            }\n\n            @Override\n            public boolean processBitMaps(final LongPredicate predicate) {\n                for (final long word : bitMaps) {\n                    if (!predicate.test(word)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        };\n    }\n\n    /**\n     * Creates a BitMapExtractor from an IndexExtractor.\n     * @param extractor the IndexExtractor that specifies the indexes of the bits to enable.\n     * @param numberOfBits the number of bits in the Bloom filter.\n     * @return A BitMapExtractor that produces the bit maps equivalent of the Indices from the extractor.\n     */\n    static BitMapExtractor fromIndexExtractor(final IndexExtractor extractor, final int numberOfBits) {\n        Objects.requireNonNull(extractor, \"extractor\");\n\n        final long[] result = new long[BitMaps.numberOfBitMaps(numberOfBits)];\n        extractor.processIndices(i -> {\n            BitMaps.set(result, i);\n            return true;\n        });\n        return fromBitMapArray(result);\n    }\n\n    /**\n     * Return a copy of the BitMapExtractor data as a bit map array.\n     * <p>\n     * The default implementation of this method is slow. It is recommended\n     * that implementing classes reimplement this method.\n     * </p>\n     * @return An array of bit map data.\n     */\n    default long[] asBitMapArray() {\n        final class Bits {\n            private long[] data = new long[16];\n            private int size;\n\n            boolean add(final long bits) {\n                if (size == data.length) {\n                    // This will throw an out-of-memory error if there are too many bits.\n                    // Since bits are addressed using 32-bit signed integer indices\n                    // the maximum length should be ~2^31 / 2^6 = ~2^25.\n                    // Any more is a broken implementation.\n                    data = Arrays.copyOf(data, size * 2);\n                }\n                data[size++] = bits;\n                return true;\n            }\n\n            long[] toArray() {\n                // Edge case to avoid a large array copy\n                return size == data.length ? data : Arrays.copyOf(data, size);\n            }\n        }\n        final Bits bits = new Bits();\n        processBitMaps(bits::add);\n        return bits.toArray();\n    }\n\n    /**\n     * Applies the {@code func} to each bit map pair in order. Will apply all of the bit maps from the other\n     * BitMapExtractor to this extractor. If this extractor does not have as many bit maps it will provide 0 (zero)\n     * for all excess calls to the LongBiPredicate.\n     * <p>\n     * <em>The default implementation of this method uses {@code asBitMapArray()}. It is recommended that implementations\n     * of BitMapExtractor that have local arrays reimplement this method.</em></p>\n     *\n     * @param other The other BitMapExtractor that provides the y values in the (x,y) pair.\n     * @param func The function to apply.\n     * @return A LongPredicate that tests this BitMapExtractor's bitmap values in order.\n     */\n    default boolean processBitMapPairs(final BitMapExtractor other, final LongBiPredicate func) {\n        final CountingLongPredicate p = new CountingLongPredicate(asBitMapArray(), func);\n        return other.processBitMaps(p) && p.processRemaining();\n    }\n\n    /**\n     * Each bit map is passed to the predicate in order. The predicate is applied to each\n     * bit map value, if the predicate returns {@code false} the execution is stopped, {@code false}\n     * is returned, and no further bit maps are processed.\n     *\n     * <p>If the extractor is empty this method will return true.</p>\n     *\n     * <p>Any exceptions thrown by the action are relayed to the caller.</p>\n     *\n     * @param predicate the function to execute\n     * @return {@code true} if all bit maps returned {@code true}, {@code false} otherwise.\n     * @throws NullPointerException if the specified consumer is null\n     */\n    boolean processBitMaps(LongPredicate predicate);\n}"}]