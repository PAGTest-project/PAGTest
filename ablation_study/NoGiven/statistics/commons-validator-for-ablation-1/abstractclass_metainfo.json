[{"uris": "src/test/java/org/apache/commons/validator/AbstractCommonTest.java.AbstractCommonTest", "name": "AbstractCommonTest", "file_path": "src/test/java/org/apache/commons/validator/AbstractCommonTest.java", "superclasses": "", "methods": ["[void]loadResources(String)"], "method_uris": ["src/test/java/org/apache/commons/validator/AbstractCommonTest.java.AbstractCommonTest.[void]loadResources(String)"], "overrides": null, "attributes": [], "class_docstring": "\nConsolidates reading in XML config file into parent class.\n", "original_string": "abstract public class AbstractCommonTest {\n\n    /**\n     * Resources used for validation tests.\n     */\n    protected ValidatorResources resources;\n    protected String name;\n\n    /**\n     * Load {@code ValidatorResources} from validator-numeric.xml.\n     */\n    protected void loadResources(final String file) throws IOException, SAXException {\n        // Load resources\n        try (InputStream in = this.getClass().getResourceAsStream(file)) {\n            resources = new ValidatorResources(in);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected ValidatorResources resources;", "docstring": "\nResources used for validation tests.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "ValidatorResources", "name": "resources", "syntax_pass": true}, {"attribute_expression": "protected String name;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/AbstractNumberTest.java.AbstractNumberTest", "name": "AbstractNumberTest", "file_path": "src/test/java/org/apache/commons/validator/AbstractNumberTest.java", "superclasses": "AbstractCommonTest", "methods": ["[void]setUp()", "[void]tearDown()", "[void]valueTest(Object,boolean)"], "method_uris": ["src/test/java/org/apache/commons/validator/AbstractNumberTest.java.AbstractNumberTest.[void]setUp()", "src/test/java/org/apache/commons/validator/AbstractNumberTest.java.AbstractNumberTest.[void]tearDown()", "src/test/java/org/apache/commons/validator/AbstractNumberTest.java.AbstractNumberTest.[void]valueTest(Object,boolean)"], "overrides": null, "attributes": [], "class_docstring": "\nAbstracts number unit tests methods.\n", "original_string": "public abstract class AbstractNumberTest extends AbstractCommonTest {\n\n    /**\n     * The key used to retrieve the set of validation rules from the xml file.\n     */\n    protected String formKey;\n\n    /**\n     * The key used to retrieve the validator action.\n     */\n    protected String action;\n\n    /**\n     * Load {@code ValidatorResources} from validator-numeric.xml.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException, SAXException {\n        // Load resources\n        loadResources(\"TestNumber-config.xml\");\n    }\n\n    @AfterEach\n    protected void tearDown() {\n    }\n\n    /**\n     * Tests the number validation.\n     */\n    @Test\n    public void testNumber() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(\"0\");\n        valueTest(info, true);\n    }\n\n    /**\n     * Tests the float validation failure.\n     */\n    @Test\n    public void testNumberFailure() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        valueTest(info, false);\n    }\n\n    /**\n     * Utility class to run a test on a value.\n     *\n     * @param info   Value to run test on.\n     * @param passed Whether or not the test is expected to pass.\n     */\n    protected void valueTest(final Object info, final boolean passed) throws ValidatorException {\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, formKey);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, info);\n\n        // Get results of the validation.\n        // throws ValidatorException,\n        // but we aren't catching for testing\n        // since no validation methods we use\n        // throw this\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult result = results.getValidatorResult(\"value\");\n\n        assertNotNull(result, () -> action + \" value ValidatorResult should not be null.\");\n        assertTrue(result.containsAction(action), () -> action + \" value ValidatorResult should contain the '\" + action + \"' action.\");\n        assertTrue(passed ? result.isValid(action) : !result.isValid(action),\n                () -> action + \" value ValidatorResult for the '\" + action + \"' action should have \" + (passed ? \"passed\" : \"failed\") + \".\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected String formKey;", "docstring": "\nThe key used to retrieve the set of validation rules from the xml file.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "formKey", "syntax_pass": true}, {"attribute_expression": "protected String action;", "docstring": "\nThe key used to retrieve the validator action.\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "action", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/AbstractNumberValidatorTest.java.AbstractNumberValidatorTest", "name": "AbstractNumberValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/AbstractNumberValidatorTest.java", "superclasses": "", "methods": ["[void]setUp()", "[void]tearDown()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/AbstractNumberValidatorTest.java.AbstractNumberValidatorTest.[void]setUp()", "src/test/java/org/apache/commons/validator/routines/AbstractNumberValidatorTest.java.AbstractNumberValidatorTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nBase Number Test Case.\n", "original_string": "public abstract class AbstractNumberValidatorTest {\n\n    protected AbstractNumberValidator validator;\n    protected AbstractNumberValidator strictValidator;\n\n    protected Number max;\n    protected Number maxPlusOne;\n    protected Number min;\n    protected Number minMinusOne;\n    protected String[] invalid;\n    protected String[] valid;\n    protected Number[] validCompare;\n\n    protected String[] invalidStrict;\n    protected String[] validStrict;\n    protected Number[] validStrictCompare;\n\n    protected String testPattern;\n    protected Number testNumber;\n    protected Number testZero;\n    protected String testStringUS;\n    protected String testStringDE;\n\n    protected String localeValue;\n    protected String localePattern;\n    protected Locale testLocale;\n    protected Number localeExpected;\n\n    @BeforeEach\n    protected void setUp() {\n        Locale.setDefault(Locale.US);\n    }\n\n    /**\n     * Tear down\n     */\n    @AfterEach\n    protected void tearDown() {\n        validator = null;\n        strictValidator = null;\n    }\n\n    /**\n     * Test format() methods\n     */\n    @Test\n    public void testFormat() {\n        final Number number = new BigDecimal(\"1234.5\");\n        assertEquals(\"1,234.5\", strictValidator.format(number, Locale.US), \"US Locale, US Format\");\n        assertEquals(\"1.234,5\", strictValidator.format(number, Locale.GERMAN), \"DE Locale, DE Format\");\n        assertEquals(\"12,34.50\", strictValidator.format(number, \"#,#0.00\"), \"Pattern #,#0.00\");\n    }\n\n    /**\n     * Test Format Type\n     */\n    @Test\n    public void testFormatType() {\n        assertEquals(0, validator.getFormatType(), \"Format Type A\");\n        assertEquals(AbstractNumberValidator.STANDARD_FORMAT, validator.getFormatType(), \"Format Type B\");\n    }\n\n    /**\n     * Test Invalid, strict=false\n     */\n    @Test\n    public void testInvalidNotStrict() {\n        for (int i = 0; i < invalid.length; i++) {\n            final String text = \"idx=[\" + i + \"] value=[\" + invalid[i] + \"]\";\n            assertNull(validator.parse(invalid[i], null, Locale.US), () -> \"(A) \" + text);\n            assertFalse(validator.isValid(invalid[i], null, Locale.US), () -> \"(B) \" + text);\n            assertNull(validator.parse(invalid[i], testPattern, null), () -> \"(C) \" + text);\n            assertFalse(validator.isValid(invalid[i], testPattern, null), () -> \"(D) \" + text);\n        }\n    }\n\n    /**\n     * Test Invalid, strict=true\n     */\n    @Test\n    public void testInvalidStrict() {\n        for (int i = 0; i < invalidStrict.length; i++) {\n            final String text = \"idx=[\" + i + \"] value=[\" + invalidStrict[i] + \"]\";\n            assertNull(strictValidator.parse(invalidStrict[i], null, Locale.US), () -> \"(A) \" + text);\n            assertFalse(strictValidator.isValid(invalidStrict[i], null, Locale.US), () -> \"(B) \" + text);\n            assertNull(strictValidator.parse(invalidStrict[i], testPattern, null), () -> \"(C) \" + text);\n            assertFalse(strictValidator.isValid(invalidStrict[i], testPattern, null), () -> \"(D) \" + text);\n        }\n    }\n\n    /**\n     * Test Range/Min/Max\n     */\n    @Test\n    public void testRangeMinMax() {\n        final Number number9 = Integer.valueOf(9);\n        final Number number10 = Integer.valueOf(10);\n        final Number number11 = Integer.valueOf(11);\n        final Number number19 = Integer.valueOf(19);\n        final Number number20 = Integer.valueOf(20);\n        final Number number21 = Integer.valueOf(21);\n\n        // Test isInRange()\n        assertFalse(strictValidator.isInRange(number9, number10, number20), \"isInRange() < min\");\n        assertTrue(strictValidator.isInRange(number10, number10, number20), \"isInRange() = min\");\n        assertTrue(strictValidator.isInRange(number11, number10, number20), \"isInRange() in range\");\n        assertTrue(strictValidator.isInRange(number20, number10, number20), \"isInRange() = max\");\n        assertFalse(strictValidator.isInRange(number21, number10, number20), \"isInRange() > max\");\n\n        // Test minValue()\n        assertFalse(strictValidator.minValue(number9, number10), \"minValue() < min\");\n        assertTrue(strictValidator.minValue(number10, number10), \"minValue() = min\");\n        assertTrue(strictValidator.minValue(number11, number10), \"minValue() > min\");\n\n        // Test minValue()\n        assertTrue(strictValidator.maxValue(number19, number20), \"maxValue() < max\");\n        assertTrue(strictValidator.maxValue(number20, number20), \"maxValue() = max\");\n        assertFalse(strictValidator.maxValue(number21, number20), \"maxValue() > max\");\n    }\n\n    /**\n     * Test validator serialization.\n     */\n    @Test\n    public void testSerialization() {\n        // Serialize the check digit routine\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n            oos.writeObject(validator);\n            oos.flush();\n        } catch (final Exception e) {\n            fail(validator.getClass().getName() + \" error during serialization: \" + e);\n        }\n\n        // Deserialize the test object\n        Object result = null;\n        try (ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray())) {\n            final ObjectInputStream ois = new ObjectInputStream(bais);\n            result = ois.readObject();\n        } catch (final Exception e) {\n            fail(validator.getClass().getName() + \" error during deserialization: \" + e);\n        }\n        assertNotNull(result);\n    }\n\n    /**\n     * Test different Locale\n     */\n    @Test\n    public void testValidateLocale() {\n\n        assertEquals(testNumber, strictValidator.parse(testStringUS, null, Locale.US), \"US Locale, US Format\");\n        assertNull(strictValidator.parse(testStringDE, null, Locale.US), \"US Locale, DE Format\");\n\n        // Default German Locale\n        assertEquals(testNumber, strictValidator.parse(testStringDE, null, Locale.GERMAN), \"DE Locale, DE Format\");\n        assertNull(strictValidator.parse(testStringUS, null, Locale.GERMAN), \"DE Locale, US Format\");\n\n        // Default Locale has been set to Locale.US in setup()\n        assertEquals(testNumber, strictValidator.parse(testStringUS, null, null), \"Default Locale, US Format\");\n        assertNull(strictValidator.parse(testStringDE, null, null), \"Default Locale, DE Format\");\n    }\n\n    /**\n     * Test Min/Max values allowed\n     */\n    @Test\n    public void testValidateMinMax() {\n        final DecimalFormat fmt = new DecimalFormat(\"#\");\n        if (max != null) {\n            assertEquals(max, validator.parse(fmt.format(max), \"#\", null), \"Test Max\");\n            assertNull(validator.parse(fmt.format(maxPlusOne), \"#\", null), \"Test Max + 1\");\n            assertEquals(min, validator.parse(fmt.format(min), \"#\", null), \"Test Min\");\n            assertNull(validator.parse(fmt.format(minMinusOne), \"#\", null), \"Test min - 1\");\n        }\n    }\n\n    /**\n     * Test Valid, strict=false\n     */\n    @Test\n    public void testValidNotStrict() {\n        for (int i = 0; i < valid.length; i++) {\n            final String text = \"idx=[\" + i + \"] value=[\" + validCompare[i] + \"]\";\n            assertEquals(validCompare[i], validator.parse(valid[i], null, Locale.US), \"(A) \" + text);\n            assertTrue(validator.isValid(valid[i], null, Locale.US), \"(B) \" + text);\n            assertEquals(validCompare[i], validator.parse(valid[i], testPattern, null), \"(C) \" + text);\n            assertTrue(validator.isValid(valid[i], testPattern, null), \"(D) \" + text);\n        }\n    }\n\n    /**\n     * Test Valid, strict=true\n     */\n    @Test\n    public void testValidStrict() {\n        for (int i = 0; i < validStrict.length; i++) {\n            final String text = \"idx=[\" + i + \"] value=[\" + validStrictCompare[i] + \"]\";\n            assertEquals(validStrictCompare[i], strictValidator.parse(validStrict[i], null, Locale.US), \"(A) \" + text);\n            assertTrue(strictValidator.isValid(validStrict[i], null, Locale.US), \"(B) \" + text);\n            assertEquals(validStrictCompare[i], strictValidator.parse(validStrict[i], testPattern, null), \"(C) \" + text);\n            assertTrue(strictValidator.isValid(validStrict[i], testPattern, null), \"(D) \" + text);\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected AbstractNumberValidator validator;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "AbstractNumberValidator", "name": "validator", "syntax_pass": true}, {"attribute_expression": "protected AbstractNumberValidator strictValidator;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "AbstractNumberValidator", "name": "strictValidator", "syntax_pass": true}, {"attribute_expression": "protected Number max;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Number", "name": "max", "syntax_pass": true}, {"attribute_expression": "protected Number maxPlusOne;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Number", "name": "maxPlusOne", "syntax_pass": true}, {"attribute_expression": "protected Number min;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Number", "name": "min", "syntax_pass": true}, {"attribute_expression": "protected Number minMinusOne;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Number", "name": "minMinusOne", "syntax_pass": true}, {"attribute_expression": "protected String[] invalid;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "invalid", "syntax_pass": true}, {"attribute_expression": "protected String[] valid;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "valid", "syntax_pass": true}, {"attribute_expression": "protected Number[] validCompare;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Number[]", "name": "validCompare", "syntax_pass": true}, {"attribute_expression": "protected String[] invalidStrict;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "invalidStrict", "syntax_pass": true}, {"attribute_expression": "protected String[] validStrict;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "validStrict", "syntax_pass": true}, {"attribute_expression": "protected Number[] validStrictCompare;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Number[]", "name": "validStrictCompare", "syntax_pass": true}, {"attribute_expression": "protected String testPattern;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "testPattern", "syntax_pass": true}, {"attribute_expression": "protected Number testNumber;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Number", "name": "testNumber", "syntax_pass": true}, {"attribute_expression": "protected Number testZero;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Number", "name": "testZero", "syntax_pass": true}, {"attribute_expression": "protected String testStringUS;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "testStringUS", "syntax_pass": true}, {"attribute_expression": "protected String testStringDE;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "testStringDE", "syntax_pass": true}, {"attribute_expression": "protected String localeValue;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "localeValue", "syntax_pass": true}, {"attribute_expression": "protected String localePattern;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "localePattern", "syntax_pass": true}, {"attribute_expression": "protected Locale testLocale;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Locale", "name": "testLocale", "syntax_pass": true}, {"attribute_expression": "protected Number localeExpected;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Number", "name": "localeExpected", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/AbstractCalendarValidatorTest.java.AbstractCalendarValidatorTest", "name": "AbstractCalendarValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/AbstractCalendarValidatorTest.java", "superclasses": "", "methods": ["[Calendar]createCalendar(TimeZone,int,int)", "[Date]createDate(TimeZone,int,int)", "[void]tearDown()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/AbstractCalendarValidatorTest.java.AbstractCalendarValidatorTest.[Calendar]createCalendar(TimeZone,int,int)", "src/test/java/org/apache/commons/validator/routines/AbstractCalendarValidatorTest.java.AbstractCalendarValidatorTest.[Date]createDate(TimeZone,int,int)", "src/test/java/org/apache/commons/validator/routines/AbstractCalendarValidatorTest.java.AbstractCalendarValidatorTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nBase Calendar Test Case.\n", "original_string": "public abstract class AbstractCalendarValidatorTest {\n\n    protected static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\"); // 0 offset\n\n    protected static final TimeZone EST = TimeZone.getTimeZone(\"EST\"); // - 5 hours\n    protected static final TimeZone EET = TimeZone.getTimeZone(\"EET\"); // + 2 hours\n    protected static final TimeZone UTC = TimeZone.getTimeZone(\"UTC\"); // + 2 hours\n\n    /**\n     * Create a calendar instance for a specified time zone, date and time.\n     *\n     * @param zone The time zone\n     * @param date The date in yyyyMMdd format\n     * @param time the time in HH:mm:ss format\n     * @return the new Calendar instance.\n     */\n    protected static Calendar createCalendar(final TimeZone zone, final int date, final int time) {\n        final Calendar calendar = zone == null ? Calendar.getInstance() : Calendar.getInstance(zone);\n        final int year = date / 10000 * 10000;\n        final int mth = date / 100 * 100 - year;\n        final int day = date - (year + mth);\n        final int hour = time / 10000 * 10000;\n        final int min = time / 100 * 100 - hour;\n        final int sec = time - (hour + min);\n        calendar.set(Calendar.YEAR, year / 10000);\n        calendar.set(Calendar.MONTH, mth / 100 - 1);\n        calendar.set(Calendar.DATE, day);\n        calendar.set(Calendar.HOUR_OF_DAY, hour / 10000);\n        calendar.set(Calendar.MINUTE, min / 100);\n        calendar.set(Calendar.SECOND, sec);\n        calendar.set(Calendar.MILLISECOND, 0);\n        return calendar;\n    }\n\n    /**\n     * Create a date instance for a specified time zone, date and time.\n     *\n     * @param zone The time zone\n     * @param date The date in yyyyMMdd format\n     * @param time the time in HH:mm:ss format\n     * @return the new Date instance.\n     */\n    protected static Date createDate(final TimeZone zone, final int date, final int time) {\n        final Calendar calendar = createCalendar(zone, date, time);\n        return calendar.getTime();\n    }\n\n    protected AbstractCalendarValidator validator;\n    protected String[] patternValid = { \"2005-01-01\", \"2005-12-31\", \"2004-02-29\" // valid leap\n            , \"2005-04-30\", \"05-12-31\", \"2005-1-1\", \"05-1-1\" };\n    protected String[] localeValid = { \"01/01/2005\", \"12/31/2005\", \"02/29/2004\" // valid leap\n            , \"04/30/2005\", \"12/31/05\", \"1/1/2005\", \"1/1/05\" };\n    protected Date[] patternExpect = { createDate(null, 20050101, 0), createDate(null, 20051231, 0), createDate(null, 20040229, 0),\n            createDate(null, 20050430, 0), createDate(null, 20051231, 0), createDate(null, 20050101, 0), createDate(null, 20050101, 0) };\n\n    protected String[] patternInvalid = { \"2005-00-01\" // zero month\n            , \"2005-01-00\" // zero day\n            , \"2005-13-03\" // month invalid\n            , \"2005-04-31\" // invalid day\n            , \"2005-03-32\" // invalid day\n            , \"2005-02-29\" // invalid leap\n            , \"200X-01-01\" // invalid char\n            , \"2005-0X-01\" // invalid char\n            , \"2005-01-0X\" // invalid char\n            , \"01/01/2005\" // invalid pattern\n            , \"2005-01\" // invalid pattern\n            , \"2005--01\" // invalid pattern\n            , \"2005-01-\" }; // invalid pattern\n\n    protected String[] localeInvalid = { \"01/00/2005\" // zero month\n            , \"00/01/2005\" // zero day\n            , \"13/01/2005\" // month invalid\n            , \"04/31/2005\" // invalid day\n            , \"03/32/2005\" // invalid day\n            , \"02/29/2005\" // invalid leap\n            , \"01/01/200X\" // invalid char\n            , \"01/0X/2005\" // invalid char\n            , \"0X/01/2005\" // invalid char\n            , \"01-01-2005\" // invalid pattern\n            , \"01/2005\" // invalid pattern\n            // -------- ,\"/01/2005\" ---- passes on some JDK\n            , \"01//2005\" }; // invalid pattern\n\n    /**\n     * Tear down\n     */\n    @AfterEach\n    protected void tearDown() {\n        validator = null;\n    }\n\n    /**\n     * Test Invalid Dates with \"locale\" validation\n     */\n    @Test\n    public void testFormat() {\n\n        // Create a Date or Calendar\n        final Object test = validator.parse(\"2005-11-28\", \"yyyy-MM-dd\", null, null);\n        assertNotNull(test, \"Test Date\");\n        assertEquals(\"28.11.05\", validator.format(test, \"dd.MM.yy\"), \"Format pattern\");\n        assertEquals(\"11/28/05\", validator.format(test, Locale.US), \"Format locale\");\n    }\n\n    /**\n     * Test Invalid Dates with \"locale\" validation\n     */\n    @Test\n    public void testLocaleInvalid() {\n        for (int i = 0; i < localeInvalid.length; i++) {\n            final String text = i + \" value=[\" + localeInvalid[i] + \"] passed \";\n            final Object date = validator.parse(localeInvalid[i], null, Locale.US, null);\n            assertNull(date, \"validateObj() \" + text + date);\n            assertFalse(validator.isValid(localeInvalid[i], Locale.US), \"isValid() \" + text);\n        }\n    }\n\n    /**\n     * Test Valid Dates with \"locale\" validation\n     */\n    @Test\n    public void testLocaleValid() {\n        for (int i = 0; i < localeValid.length; i++) {\n            final String text = i + \" value=[\" + localeValid[i] + \"] failed \";\n            Object date = validator.parse(localeValid[i], null, Locale.US, null);\n            assertNotNull(date, \"validateObj() \" + text + date);\n            assertTrue(validator.isValid(localeValid[i], Locale.US), \"isValid() \" + text);\n            if (date instanceof Calendar) {\n                date = ((Calendar) date).getTime();\n            }\n            assertEquals(patternExpect[i], date, \"compare \" + text);\n        }\n    }\n\n    /**\n     * Test Invalid Dates with \"pattern\" validation\n     */\n    @Test\n    public void testPatternInvalid() {\n        for (int i = 0; i < patternInvalid.length; i++) {\n            final String text = i + \" value=[\" + patternInvalid[i] + \"] passed \";\n            final Object date = validator.parse(patternInvalid[i], \"yy-MM-dd\", null, null);\n            assertNull(date, \"validateObj() \" + text + date);\n            assertFalse(validator.isValid(patternInvalid[i], \"yy-MM-dd\"), \"isValid() \" + text);\n        }\n    }\n\n    /**\n     * Test Valid Dates with \"pattern\" validation\n     */\n    @Test\n    public void testPatternValid() {\n        for (int i = 0; i < patternValid.length; i++) {\n            final String text = i + \" value=[\" + patternValid[i] + \"] failed \";\n            Object date = validator.parse(patternValid[i], \"yy-MM-dd\", null, null);\n            assertNotNull(date, \"validateObj() \" + text + date);\n            assertTrue(validator.isValid(patternValid[i], \"yy-MM-dd\"), \"isValid() \" + text);\n            if (date instanceof Calendar) {\n                date = ((Calendar) date).getTime();\n            }\n            assertEquals(patternExpect[i], date, \"compare \" + text);\n        }\n    }\n\n    /**\n     * Test validator serialization.\n     */\n    @Test\n    public void testSerialization() {\n        // Serialize the check digit routine\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n            oos.writeObject(validator);\n            oos.flush();\n        } catch (final Exception e) {\n            fail(validator.getClass().getName() + \" error during serialization: \" + e);\n        }\n\n        // Deserialize the test object\n        Object result = null;\n        try (ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray())) {\n            final ObjectInputStream ois = new ObjectInputStream(bais);\n            result = ois.readObject();\n        } catch (final Exception e) {\n            fail(validator.getClass().getName() + \" error during deserialization: \" + e);\n        }\n        assertNotNull(result);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "TimeZone", "name": "GMT = TimeZone.getTimeZone(\"GMT\")", "syntax_pass": true}, {"attribute_expression": "protected static final TimeZone EST = TimeZone.getTimeZone(\"EST\");", "docstring": " 0 offset", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "TimeZone", "name": "EST = TimeZone.getTimeZone(\"EST\")", "syntax_pass": true}, {"attribute_expression": "protected static final TimeZone EET = TimeZone.getTimeZone(\"EET\");", "docstring": " - 5 hours", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "TimeZone", "name": "EET = TimeZone.getTimeZone(\"EET\")", "syntax_pass": true}, {"attribute_expression": "protected static final TimeZone UTC = TimeZone.getTimeZone(\"UTC\");", "docstring": " + 2 hours", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "TimeZone", "name": "UTC = TimeZone.getTimeZone(\"UTC\")", "syntax_pass": true}, {"attribute_expression": "protected AbstractCalendarValidator validator;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "AbstractCalendarValidator", "name": "validator", "syntax_pass": true}, {"attribute_expression": "protected String[] patternValid = { \"2005-01-01\", \"2005-12-31\", \"2004-02-29\" // valid leap\n            , \"2005-04-30\", \"05-12-31\", \"2005-1-1\", \"05-1-1\" };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "patternValid = { \"2005-01-01\", \"2005-12-31\", \"2004-02-29\" // valid leap\n            , \"2005-04-30\", \"05-12-31\", \"2005-1-1\", \"05-1-1\" }", "syntax_pass": true}, {"attribute_expression": "protected String[] localeValid = { \"01/01/2005\", \"12/31/2005\", \"02/29/2004\" // valid leap\n            , \"04/30/2005\", \"12/31/05\", \"1/1/2005\", \"1/1/05\" };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "localeValid = { \"01/01/2005\", \"12/31/2005\", \"02/29/2004\" // valid leap\n            , \"04/30/2005\", \"12/31/05\", \"1/1/2005\", \"1/1/05\" }", "syntax_pass": true}, {"attribute_expression": "protected Date[] patternExpect = { createDate(null, 20050101, 0), createDate(null, 20051231, 0), createDate(null, 20040229, 0),\n            createDate(null, 20050430, 0), createDate(null, 20051231, 0), createDate(null, 20050101, 0), createDate(null, 20050101, 0) };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Date[]", "name": "patternExpect = { createDate(null, 20050101, 0), createDate(null, 20051231, 0), createDate(null, 20040229, 0),\n            createDate(null, 20050430, 0), createDate(null, 20051231, 0), createDate(null, 20050101, 0), createDate(null, 20050101, 0) }", "syntax_pass": true}, {"attribute_expression": "protected String[] patternInvalid = { \"2005-00-01\" // zero month\n            , \"2005-01-00\" // zero day\n            , \"2005-13-03\" // month invalid\n            , \"2005-04-31\" // invalid day\n            , \"2005-03-32\" // invalid day\n            , \"2005-02-29\" // invalid leap\n            , \"200X-01-01\" // invalid char\n            , \"2005-0X-01\" // invalid char\n            , \"2005-01-0X\" // invalid char\n            , \"01/01/2005\" // invalid pattern\n            , \"2005-01\" // invalid pattern\n            , \"2005--01\" // invalid pattern\n            , \"2005-01-\" };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "patternInvalid = { \"2005-00-01\" // zero month\n            , \"2005-01-00\" // zero day\n            , \"2005-13-03\" // month invalid\n            , \"2005-04-31\" // invalid day\n            , \"2005-03-32\" // invalid day\n            , \"2005-02-29\" // invalid leap\n            , \"200X-01-01\" // invalid char\n            , \"2005-0X-01\" // invalid char\n            , \"2005-01-0X\" // invalid char\n            , \"01/01/2005\" // invalid pattern\n            , \"2005-01\" // invalid pattern\n            , \"2005--01\" // invalid pattern\n            , \"2005-01-\" }", "syntax_pass": true}, {"attribute_expression": "protected String[] localeInvalid = { \"01/00/2005\" // zero month\n            , \"00/01/2005\" // zero day\n            , \"13/01/2005\" // month invalid\n            , \"04/31/2005\" // invalid day\n            , \"03/32/2005\" // invalid day\n            , \"02/29/2005\" // invalid leap\n            , \"01/01/200X\" // invalid char\n            , \"01/0X/2005\" // invalid char\n            , \"0X/01/2005\" // invalid char\n            , \"01-01-2005\" // invalid pattern\n            , \"01/2005\" // invalid pattern\n            // -------- ,\"/01/2005\" ---- passes on some JDK\n            , \"01//2005\" };", "docstring": " invalid pattern", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "localeInvalid = { \"01/00/2005\" // zero month\n            , \"00/01/2005\" // zero day\n            , \"13/01/2005\" // month invalid\n            , \"04/31/2005\" // invalid day\n            , \"03/32/2005\" // invalid day\n            , \"02/29/2005\" // invalid leap\n            , \"01/01/200X\" // invalid char\n            , \"01/0X/2005\" // invalid char\n            , \"0X/01/2005\" // invalid char\n            , \"01-01-2005\" // invalid pattern\n            , \"01/2005\" // invalid pattern\n            // -------- ,\"/01/2005\" ---- passes on some JDK\n            , \"01//2005\" }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/checkdigit/AbstractCheckDigitTest.java.AbstractCheckDigitTest", "name": "AbstractCheckDigitTest", "file_path": "src/test/java/org/apache/commons/validator/routines/checkdigit/AbstractCheckDigitTest.java", "superclasses": "", "methods": ["[String]checkDigit(String)", "[String[]]createInvalidCodes(String[])", "[String]removeCheckDigit(String)", "[void]tearDown()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/checkdigit/AbstractCheckDigitTest.java.AbstractCheckDigitTest.[String]checkDigit(String)", "src/test/java/org/apache/commons/validator/routines/checkdigit/AbstractCheckDigitTest.java.AbstractCheckDigitTest.[String[]]createInvalidCodes(String[])", "src/test/java/org/apache/commons/validator/routines/checkdigit/AbstractCheckDigitTest.java.AbstractCheckDigitTest.[String]removeCheckDigit(String)", "src/test/java/org/apache/commons/validator/routines/checkdigit/AbstractCheckDigitTest.java.AbstractCheckDigitTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nCheck Digit Test.\n", "original_string": "public abstract class AbstractCheckDigitTest {\n\n    private static final String POSSIBLE_CHECK_DIGITS = \"0123456789 ABCDEFHIJKLMNOPQRSTUVWXYZ\\tabcdefghijklmnopqrstuvwxyz!@\u00a3$%^&*()_+\";\n\n    /** Logging instance */\n    protected Log log = LogFactory.getLog(getClass());\n\n    /** Check digit routine being tested */\n    protected int checkDigitLth = 1;\n\n    /** Check digit routine being tested */\n    protected CheckDigit routine;\n\n    /**\n     * Array of valid code values These must contain valid strings *including* the check digit.\n     *\n     * They are passed to: CheckDigit.isValid(expects string including checkdigit) which is expected to return true and\n     * AbstractCheckDigitTest.createInvalidCodes() which mangles the last character to check that the result is now invalid. and the truncated string is passed\n     * to CheckDigit.calculate(expects string without checkdigit) the result is compared with the last character\n     */\n    protected String[] valid;\n\n    /**\n     * Array of invalid code values\n     *\n     * These are currently passed to both CheckDigit.calculate(expects a string without checkdigit) which is expected to throw an exception However that only\n     * applies if the string is syntactically incorrect; and CheckDigit.isValid(expects a string including checkdigit) which is expected to return false\n     *\n     * See https://issues.apache.org/jira/browse/VALIDATOR-344 for some dicussion on this\n     */\n    protected String[] invalid = { \"12345678A\" };\n\n    /** Code value which sums to zero */\n    protected String zeroSum = \"0000000000\";\n\n    /** Prefix for error messages */\n    protected String missingMessage = \"Code is missing\";\n\n    /**\n     * Returns the check digit (i.e. last character) for a code.\n     *\n     * @param code The code\n     * @return The check digit\n     */\n    protected String checkDigit(final String code) {\n        if (code == null || code.length() <= checkDigitLth) {\n            return \"\";\n        }\n        final int start = code.length() - checkDigitLth;\n        return code.substring(start);\n    }\n\n    // private static final String POSSIBLE_CHECK_DIGITS = \"0123456789\";\n    /**\n     * Returns an array of codes with invalid check digits.\n     *\n     * @param codes Codes with valid check digits\n     * @return Codes with invalid check digits\n     */\n    protected String[] createInvalidCodes(final String[] codes) {\n        final List<String> list = new ArrayList<>();\n\n        // create invalid check digit values\n        for (final String fullCode : codes) {\n            final String code = removeCheckDigit(fullCode);\n            final String check = checkDigit(fullCode);\n            for (int j = 0; j < POSSIBLE_CHECK_DIGITS.length(); j++) {\n                final String curr = POSSIBLE_CHECK_DIGITS.substring(j, j + 1); // \"\" + Character.forDigit(j, 10);\n                if (!curr.equals(check)) {\n                    list.add(code + curr);\n                }\n            }\n        }\n\n        return list.toArray(new String[0]);\n    }\n\n    /**\n     * Returns a code with the Check Digit (i.e. last character) removed.\n     *\n     * @param code The code\n     * @return The code without the check digit\n     */\n    protected String removeCheckDigit(final String code) {\n        if (code == null || code.length() <= checkDigitLth) {\n            return null;\n        }\n        return code.substring(0, code.length() - checkDigitLth);\n    }\n\n    /**\n     * Tear Down - clears routine and valid codes.\n     */\n    @AfterEach\n    protected void tearDown() {\n        valid = null;\n        routine = null;\n    }\n\n    /**\n     * Test calculate() for invalid values.\n     */\n    @Test\n    public void testCalculateInvalid() {\n\n        if (log.isDebugEnabled()) {\n            log.debug(\"testCalculateInvalid() for \" + routine.getClass().getName());\n        }\n\n        // test invalid code values\n        for (int i = 0; i < invalid.length; i++) {\n            try {\n                final String code = invalid[i];\n                if (log.isDebugEnabled()) {\n                    log.debug(\"   \" + i + \" Testing Invalid Check Digit, Code=[\" + code + \"]\");\n                }\n                final String expected = checkDigit(code);\n                final String codeWithNoCheckDigit = removeCheckDigit(code);\n                if (codeWithNoCheckDigit == null) {\n                    throw new CheckDigitException(\"Invalid Code=[\" + code + \"]\");\n                }\n                final String actual = routine.calculate(codeWithNoCheckDigit);\n                // If exception not thrown, check that the digit is incorrect instead\n                if (expected.equals(actual)) {\n                    fail(\"Expected mismatch for \" + code + \" expected \" + expected + \" actual \" + actual);\n                }\n            } catch (final CheckDigitException e) {\n                // possible failure messages:\n                // Invalid ISBN Length ...\n                // Invalid Character[ ...\n                // Are there any others?\n                assertTrue(e.getMessage().startsWith(\"Invalid \"), \"Invalid Character[\" + i + \"]=\" + e.getMessage());\n// WAS                assertTrue(\"Invalid Character[\" +i +\"]=\" +  e.getMessage(), e.getMessage().startsWith(\"Invalid Character[\"));\n            }\n        }\n    }\n\n    /**\n     * Test calculate() for valid values.\n     */\n    @Test\n    public void testCalculateValid() {\n        if (log.isDebugEnabled()) {\n            log.debug(\"testCalculateValid() for \" + routine.getClass().getName());\n        }\n\n        // test valid values\n        for (int i = 0; i < valid.length; i++) {\n            final String code = removeCheckDigit(valid[i]);\n            final String expected = checkDigit(valid[i]);\n            try {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"   \" + i + \" Testing Valid Check Digit, Code=[\" + code + \"] expected=[\" + expected + \"]\");\n                }\n                assertEquals(expected, routine.calculate(code), \"valid[\" + i + \"]: \" + valid[i]);\n            } catch (final Exception e) {\n                fail(\"valid[\" + i + \"]=\" + valid[i] + \" threw \" + e);\n            }\n        }\n\n    }\n\n    /**\n     * Test isValid() for invalid values.\n     */\n    @Test\n    public void testIsValidFalse() {\n        if (log.isDebugEnabled()) {\n            log.debug(\"testIsValidFalse() for \" + routine.getClass().getName());\n        }\n\n        // test invalid code values\n        for (int i = 0; i < invalid.length; i++) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"   \" + i + \" Testing Invalid Code=[\" + invalid[i] + \"]\");\n            }\n            assertFalse(routine.isValid(invalid[i]), \"invalid[\" + i + \"]: \" + invalid[i]);\n        }\n\n        // test invalid check digit values\n        final String[] invalidCheckDigits = createInvalidCodes(valid);\n        for (int i = 0; i < invalidCheckDigits.length; i++) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"   \" + i + \" Testing Invalid Check Digit, Code=[\" + invalidCheckDigits[i] + \"]\");\n            }\n            assertFalse(routine.isValid(invalidCheckDigits[i]), \"invalid check digit[\" + i + \"]: \" + invalidCheckDigits[i]);\n        }\n    }\n\n    /**\n     * Test isValid() for valid values.\n     */\n    @Test\n    public void testIsValidTrue() {\n        if (log.isDebugEnabled()) {\n            log.debug(\"testIsValidTrue() for \" + routine.getClass().getName());\n        }\n\n        // test valid values\n        for (int i = 0; i < valid.length; i++) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"   \" + i + \" Testing Valid Code=[\" + valid[i] + \"]\");\n            }\n            assertTrue(routine.isValid(valid[i]), \"valid[\" + i + \"]: \" + valid[i]);\n        }\n    }\n\n    /**\n     * Test missing code\n     */\n    @Test\n    public void testMissingCode() {\n\n        // isValid() null\n        assertFalse(routine.isValid(null), \"isValid() Null\");\n\n        // isValid() zero length\n        assertFalse(routine.isValid(\"\"), \"isValid() Zero Length\");\n\n        // isValid() length 1\n        // Don't use 0, because that passes for Verhoef (not sure why yet)\n        assertFalse(routine.isValid(\"9\"), \"isValid() Length 1\");\n\n        // calculate() null\n        try {\n            routine.calculate(null);\n            fail(\"calculate() Null - expected exception\");\n        } catch (final Exception e) {\n            assertEquals(missingMessage, e.getMessage(), \"calculate() Null\");\n        }\n\n        // calculate() zero length\n        try {\n            routine.calculate(\"\");\n            fail(\"calculate() Zero Length - expected exception\");\n        } catch (final Exception e) {\n            assertEquals(missingMessage, e.getMessage(), \"calculate() Zero Length\");\n        }\n    }\n\n    /**\n     * Test check digit serialization.\n     */\n    @Test\n    public void testSerialization() {\n        // Serialize the check digit routine\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try (ObjectOutputStream oos = new ObjectOutputStream(baos)) {\n            oos.writeObject(routine);\n            oos.flush();\n        } catch (final Exception e) {\n            fail(routine.getClass().getName() + \" error during serialization: \" + e);\n        }\n\n        // Deserialize the test object\n        Object result = null;\n        try (ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray())) {\n            final ObjectInputStream ois = new ObjectInputStream(bais);\n            result = ois.readObject();\n        } catch (final Exception e) {\n            fail(routine.getClass().getName() + \" error during deserialization: \" + e);\n        }\n        assertNotNull(result);\n    }\n\n    /**\n     * Test zero sum\n     */\n    @Test\n    public void testZeroSum() {\n        assertFalse(routine.isValid(zeroSum), \"isValid() Zero Sum\");\n        try {\n            routine.calculate(zeroSum);\n            fail(\"Zero Sum - expected exception\");\n        } catch (final Exception e) {\n            assertEquals(\"Invalid code, sum is zero\", e.getMessage(), \"isValid() Zero Sum\");\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String POSSIBLE_CHECK_DIGITS = \"0123456789 ABCDEFHIJKLMNOPQRSTUVWXYZ\\tabcdefghijklmnopqrstuvwxyz!@\u00a3$%^&*()_+\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "POSSIBLE_CHECK_DIGITS = \"0123456789 ABCDEFHIJKLMNOPQRSTUVWXYZ\\tabcdefghijklmnopqrstuvwxyz!@\u00a3$%^&*()_+\"", "syntax_pass": true}, {"attribute_expression": "protected Log log = LogFactory.getLog(getClass());", "docstring": " Logging instance", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Log", "name": "log = LogFactory.getLog(getClass())", "syntax_pass": true}, {"attribute_expression": "protected int checkDigitLth = 1;", "docstring": " Check digit routine being tested", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "int", "name": "checkDigitLth = 1", "syntax_pass": true}, {"attribute_expression": "protected CheckDigit routine;", "docstring": " Check digit routine being tested", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "CheckDigit", "name": "routine", "syntax_pass": true}, {"attribute_expression": "protected String[] valid;", "docstring": "\nArray of valid code values These must contain valid strings *including* the check digit.\n\nThey are passed to: CheckDigit.isValid(expects string including checkdigit) which is expected to return true and\nAbstractCheckDigitTest.createInvalidCodes() which mangles the last character to check that the result is now invalid. and the truncated string is passed\nto CheckDigit.calculate(expects string without checkdigit) the result is compared with the last character\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "valid", "syntax_pass": true}, {"attribute_expression": "protected String[] invalid = { \"12345678A\" };", "docstring": "\nArray of invalid code values\n\nThese are currently passed to both CheckDigit.calculate(expects a string without checkdigit) which is expected to throw an exception However that only\napplies if the string is syntactically incorrect; and CheckDigit.isValid(expects a string including checkdigit) which is expected to return false\n\nSee https://issues.apache.org/jira/browse/VALIDATOR-344 for some dicussion on this\n", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "invalid = { \"12345678A\" }", "syntax_pass": true}, {"attribute_expression": "protected String zeroSum = \"0000000000\";", "docstring": " Code value which sums to zero", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "zeroSum = \"0000000000\"", "syntax_pass": true}, {"attribute_expression": "protected String missingMessage = \"Code is missing\";", "docstring": " Prefix for error messages", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String", "name": "missingMessage = \"Code is missing\"", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java.AbstractFormatValidator", "name": "AbstractFormatValidator", "file_path": "src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java", "superclasses": "", "methods": ["[]AbstractFormatValidator(boolean)", "[String]format(Object)", "[String]format(Object,Format)", "[String]format(Object,Locale)", "[String]format(Object,String)", "[String]format(Object,String,Locale)", "[Format]getFormat(String,Locale)", "[boolean]isStrict()", "[boolean]isValid(String)", "[boolean]isValid(String,Locale)", "[boolean]isValid(String,String)", "[boolean]isValid(String,String,Locale)", "[Object]parse(String,Format)", "[Object]processParsedValue(Object,Format)"], "method_uris": ["src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java.AbstractFormatValidator.[]AbstractFormatValidator(boolean)", "src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java.AbstractFormatValidator.[String]format(Object)", "src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java.AbstractFormatValidator.[String]format(Object,Format)", "src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java.AbstractFormatValidator.[String]format(Object,Locale)", "src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java.AbstractFormatValidator.[String]format(Object,String)", "src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java.AbstractFormatValidator.[String]format(Object,String,Locale)", "src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java.AbstractFormatValidator.[Format]getFormat(String,Locale)", "src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java.AbstractFormatValidator.[boolean]isStrict()", "src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java.AbstractFormatValidator.[boolean]isValid(String)", "src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java.AbstractFormatValidator.[boolean]isValid(String,Locale)", "src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java.AbstractFormatValidator.[boolean]isValid(String,String)", "src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java.AbstractFormatValidator.[boolean]isValid(String,String,Locale)", "src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java.AbstractFormatValidator.[Object]parse(String,Format)", "src/main/java/org/apache/commons/validator/routines/AbstractFormatValidator.java.AbstractFormatValidator.[Object]processParsedValue(Object,Format)"], "overrides": null, "attributes": [], "class_docstring": "\n<p>Abstract class for <em>Format</em> based Validation.</p>\n\n<p>This is a <em>base</em> class for building Date and Number\n   Validators using format parsing.</p>\n\n@since 1.3.0\n", "original_string": "public abstract class AbstractFormatValidator implements Serializable {\n\n    private static final long serialVersionUID = -4690687565200568258L;\n\n    /**\n     * Whether to use strict format.\n     */\n    private final boolean strict;\n\n    /**\n     * Constructs an instance with the specified strict setting.\n     *\n     * @param strict {@code true} if strict\n     *        {@code Format} parsing should be used.\n     */\n    public AbstractFormatValidator(final boolean strict) {\n        this.strict = strict;\n    }\n\n    /**\n     * <p>Format an object into a {@link String} using\n     * the default Locale.</p>\n     *\n     * @param value The value validation is being performed on.\n     * @return The value formatted as a {@link String}.\n     */\n    public String format(final Object value) {\n        return format(value, (String) null, (Locale) null);\n    }\n\n    /**\n     * <p>Format a value with the specified {@code Format}.</p>\n     *\n     * @param value The value to be formatted.\n     * @param formatter The Format to use.\n     * @return The formatted value.\n     */\n    protected String format(final Object value, final Format formatter) {\n        return formatter.format(value);\n    }\n\n    /**\n     * <p>Format an object into a {@link String} using\n     * the specified Locale.</p>\n     *\n     * @param value The value validation is being performed on.\n     * @param locale The locale to use for the Format.\n     * @return The value formatted as a {@link String}.\n     */\n    public String format(final Object value, final Locale locale) {\n        return format(value, (String) null, locale);\n    }\n\n    /**\n     * <p>Format an object into a {@link String} using\n     * the specified pattern.</p>\n     *\n     * @param value The value validation is being performed on.\n     * @param pattern The pattern used to format the value.\n     * @return The value formatted as a {@link String}.\n     */\n    public String format(final Object value, final String pattern) {\n        return format(value, pattern, (Locale) null);\n    }\n\n    /**\n     * <p>Format an object using the specified pattern and/or\n     *    {@link Locale}.\n     *\n     * @param value The value validation is being performed on.\n     * @param pattern The pattern used to format the value.\n     * @param locale The locale to use for the Format.\n     * @return The value formatted as a {@link String}.\n     */\n    public String format(final Object value, final String pattern, final Locale locale) {\n        final Format formatter = getFormat(pattern, locale);\n        return format(value, formatter);\n    }\n\n    /**\n     * <p>Returns a {@code Format} for the specified <em>pattern</em>\n     *    and/or {@link Locale}.</p>\n     *\n     * @param pattern The pattern used to validate the value against or\n     *        {@code null} to use the default for the {@link Locale}.\n     * @param locale The locale to use for the currency format, system default if null.\n     * @return The {@code NumberFormat} to created.\n     */\n    protected abstract Format getFormat(String pattern, Locale locale);\n\n    /**\n     * <p>Indicates whether validated values should adhere\n     *    strictly to the {@code Format} used.</p>\n     *\n     * <p>Typically implementations of {@code Format}\n     *    ignore invalid characters at the end of the value\n     *    and just stop parsing. For example parsing a date\n     *    value of {@code 01/01/20x0} using a pattern\n     *    of {@code dd/MM/yyyy} will result in a year\n     *    of {@code 20} if {@code strict} is set\n     *    to {@code false}, whereas setting {@code strict}\n     *    to {@code true} will cause this value to fail\n     *    validation.</p>\n     *\n     * @return {@code true} if strict {@code Format}\n     *         parsing should be used.\n     */\n    public boolean isStrict() {\n        return strict;\n    }\n\n    /**\n     * <p>Validate using the default {@link Locale}.\n     *\n     * @param value The value validation is being performed on.\n     * @return {@code true} if the value is valid.\n     */\n    public boolean isValid(final String value) {\n        return isValid(value, (String) null, (Locale) null);\n    }\n\n    /**\n     * <p>Validate using the specified {@link Locale}.\n     *\n     * @param value The value validation is being performed on.\n     * @param locale The locale to use for the Format, defaults to the default\n     * @return {@code true} if the value is valid.\n     */\n    public boolean isValid(final String value, final Locale locale) {\n        return isValid(value, (String) null, locale);\n    }\n\n    /**\n     * <p>Validate using the specified <em>pattern</em>.\n     *\n     * @param value The value validation is being performed on.\n     * @param pattern The pattern used to validate the value against.\n     * @return {@code true} if the value is valid.\n     */\n    public boolean isValid(final String value, final String pattern) {\n        return isValid(value, pattern, (Locale) null);\n    }\n\n    /**\n     * <p>Validate using the specified pattern and/or {@link Locale}.\n     *\n     * @param value The value validation is being performed on.\n     * @param pattern The pattern used to format the value.\n     * @param locale The locale to use for the Format, defaults to the default\n     * @return {@code true} if the value is valid.\n     */\n    public abstract boolean isValid(String value, String pattern, Locale locale);\n\n    /**\n     * <p>Parse the value with the specified {@code Format}.</p>\n     *\n     * @param value The value to be parsed.\n     * @param formatter The Format to parse the value with.\n     * @return The parsed value if valid or {@code null} if invalid.\n     */\n    protected Object parse(final String value, final Format formatter) {\n        final ParsePosition pos = new ParsePosition(0);\n        Object parsedValue = formatter.parseObject(value, pos);\n        if (pos.getErrorIndex() > -1) {\n            return null;\n        }\n        if (isStrict() && pos.getIndex() < value.length()) {\n            return null;\n        }\n        if (parsedValue != null) {\n            parsedValue = processParsedValue(parsedValue, formatter);\n        }\n        return parsedValue;\n\n    }\n\n    /**\n     * <p>Process the parsed value, performing any further validation\n     *    and type conversion required.</p>\n     *\n     * @param value The parsed object created.\n     * @param formatter The Format used to parse the value with.\n     * @return The parsed value converted to the appropriate type\n     *         if valid or {@code null} if invalid.\n     */\n    protected abstract Object processParsedValue(Object value, Format formatter);\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "private static final long serialVersionUID = -4690687565200568258L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -4690687565200568258L", "syntax_pass": true}, {"attribute_expression": "private final boolean strict;", "docstring": "\nWhether to use strict format.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "strict", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java.AbstractNumberValidator", "name": "AbstractNumberValidator", "file_path": "src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java", "superclasses": "AbstractFormatValidator", "methods": ["[]AbstractNumberValidator(boolean,int,boolean)", "[int]determineScale(NumberFormat)", "[Format]getFormat(Locale)", "[Format]getFormat(String,Locale)", "[int]getFormatType()", "[boolean]isAllowFractions()", "[boolean]isInRange(Number,Number,Number)", "[boolean]isValid(String,String,Locale)", "[boolean]maxValue(Number,Number)", "[boolean]minValue(Number,Number)", "[Object]parse(String,String,Locale)", "[Object]processParsedValue(Object,Format)"], "method_uris": ["src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java.AbstractNumberValidator.[]AbstractNumberValidator(boolean,int,boolean)", "src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java.AbstractNumberValidator.[int]determineScale(NumberFormat)", "src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java.AbstractNumberValidator.[Format]getFormat(Locale)", "src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java.AbstractNumberValidator.[Format]getFormat(String,Locale)", "src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java.AbstractNumberValidator.[int]getFormatType()", "src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java.AbstractNumberValidator.[boolean]isAllowFractions()", "src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java.AbstractNumberValidator.[boolean]isInRange(Number,Number,Number)", "src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java.AbstractNumberValidator.[boolean]isValid(String,String,Locale)", "src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java.AbstractNumberValidator.[boolean]maxValue(Number,Number)", "src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java.AbstractNumberValidator.[boolean]minValue(Number,Number)", "src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java.AbstractNumberValidator.[Object]parse(String,String,Locale)", "src/main/java/org/apache/commons/validator/routines/AbstractNumberValidator.java.AbstractNumberValidator.[Object]processParsedValue(Object,Format)"], "overrides": null, "attributes": [], "class_docstring": "\n<p>Abstract class for Number Validation.</p>\n\n<p>This is a <em>base</em> class for building Number\n   Validators using format parsing.</p>\n\n@since 1.3.0\n", "original_string": "public abstract class AbstractNumberValidator extends AbstractFormatValidator {\n\n    private static final long serialVersionUID = -3088817875906765463L;\n\n    /** Standard {@code NumberFormat} type */\n    public static final int STANDARD_FORMAT = 0;\n\n    /** Currency {@code NumberFormat} type */\n    public static final int CURRENCY_FORMAT = 1;\n\n    /** Percent {@code NumberFormat} type */\n    public static final int PERCENT_FORMAT = 2;\n\n    /**\n     * {@code true} if fractions are allowed or {@code false} if integers only.\n     */\n    private final boolean allowFractions;\n\n    /**\n     * The {@code NumberFormat} type to create for validation, default is STANDARD_FORMAT.\n     */\n    private final int formatType;\n\n    /**\n     * Constructs an instance with specified <em>strict</em>\n     * and <em>decimal</em> parameters.\n     *\n     * @param strict {@code true} if strict\n     *        {@code Format} parsing should be used.\n     * @param formatType The {@code NumberFormat} type to\n     *        create for validation, default is STANDARD_FORMAT.\n     * @param allowFractions {@code true} if fractions are\n     *        allowed or {@code false} if integers only.\n     */\n    public AbstractNumberValidator(final boolean strict, final int formatType, final boolean allowFractions) {\n        super(strict);\n        this.allowFractions = allowFractions;\n        this.formatType = formatType;\n    }\n\n    /**\n     * <p>Returns the <em>multiplier</em> of the {@code NumberFormat}.</p>\n     *\n     * @param format The {@code NumberFormat} to determine the\n     *        multiplier of.\n     * @return The multiplying factor for the format.\n     */\n    protected int determineScale(final NumberFormat format) {\n        if (!isStrict()) {\n            return -1;\n        }\n        if (!isAllowFractions() || format.isParseIntegerOnly()) {\n            return 0;\n        }\n        final int minimumFraction = format.getMinimumFractionDigits();\n        final int maximumFraction = format.getMaximumFractionDigits();\n        if (minimumFraction != maximumFraction) {\n            return -1;\n        }\n        int scale = minimumFraction;\n        if (format instanceof DecimalFormat) {\n            final int multiplier = ((DecimalFormat) format).getMultiplier();\n            if (multiplier == 100) { // CHECKSTYLE IGNORE MagicNumber\n                scale += 2; // CHECKSTYLE IGNORE MagicNumber\n            } else if (multiplier == 1000) { // CHECKSTYLE IGNORE MagicNumber\n                scale += 3; // CHECKSTYLE IGNORE MagicNumber\n            }\n        } else if (formatType == PERCENT_FORMAT) {\n            scale += 2; // CHECKSTYLE IGNORE MagicNumber\n        }\n        return scale;\n    }\n\n    /**\n     * <p>Returns a {@code NumberFormat} for the specified Locale.</p>\n     *\n     * @param locale The locale a {@code NumberFormat} is required for,\n     *   system default if null.\n     * @return The {@code NumberFormat} to created.\n     */\n    protected Format getFormat(final Locale locale) {\n        NumberFormat formatter;\n        switch (formatType) {\n        case CURRENCY_FORMAT:\n            if (locale == null) {\n                formatter = NumberFormat.getCurrencyInstance();\n            } else {\n                formatter = NumberFormat.getCurrencyInstance(locale);\n            }\n            break;\n        case PERCENT_FORMAT:\n            if (locale == null) {\n                formatter = NumberFormat.getPercentInstance();\n            } else {\n                formatter = NumberFormat.getPercentInstance(locale);\n            }\n            break;\n        default:\n            if (locale == null) {\n                formatter = NumberFormat.getInstance();\n            } else {\n                formatter = NumberFormat.getInstance(locale);\n            }\n            if (!isAllowFractions()) {\n                formatter.setParseIntegerOnly(true);\n            }\n            break;\n        }\n        return formatter;\n    }\n\n    /**\n     * <p>Returns a {@code NumberFormat} for the specified <em>pattern</em>\n     *    and/or {@link Locale}.</p>\n     *\n     * @param pattern The pattern used to validate the value against or\n     *        {@code null} to use the default for the {@link Locale}.\n     * @param locale The locale to use for the currency format, system default if null.\n     * @return The {@code NumberFormat} to created.\n     */\n    @Override\n    protected Format getFormat(final String pattern, final Locale locale) {\n\n        NumberFormat formatter;\n        final boolean usePattern = !GenericValidator.isBlankOrNull(pattern);\n        if (!usePattern) {\n            formatter = (NumberFormat) getFormat(locale);\n        } else if (locale == null) {\n            formatter = new DecimalFormat(pattern);\n        } else {\n            final DecimalFormatSymbols symbols = new DecimalFormatSymbols(locale);\n            formatter = new DecimalFormat(pattern, symbols);\n        }\n\n        if (!isAllowFractions()) {\n            formatter.setParseIntegerOnly(true);\n        }\n        return formatter;\n    }\n\n    /**\n     * <p>Indicates the type of {@code NumberFormat} created\n     *    by this validator instance.</p>\n     *\n     * @return the format type created.\n     */\n    public int getFormatType() {\n        return formatType;\n    }\n\n    /**\n     * <p>Indicates whether the number being validated is\n     *    a decimal or integer.</p>\n     *\n     * @return {@code true} if decimals are allowed\n     *       or {@code false} if the number is an integer.\n     */\n    public boolean isAllowFractions() {\n        return allowFractions;\n    }\n\n    /**\n     * Check if the value is within a specified range.\n     *\n     * @param value The value validation is being performed on.\n     * @param min The minimum value of the range.\n     * @param max The maximum value of the range.\n     * @return {@code true} if the value is within the\n     *         specified range.\n     */\n    public boolean isInRange(final Number value, final Number min, final Number max) {\n        return minValue(value, min) && maxValue(value, max);\n    }\n\n    /**\n     * <p>Validate using the specified {@link Locale}.</p>\n     *\n     * @param value The value validation is being performed on.\n     * @param pattern The pattern used to validate the value against, or the\n     *        default for the {@link Locale} if {@code null}.\n     * @param locale The locale to use for the date format, system default if null.\n     * @return {@code true} if the value is valid.\n     */\n    @Override\n    public boolean isValid(final String value, final String pattern, final Locale locale) {\n        return parse(value, pattern, locale) != null;\n    }\n\n    /**\n     * Check if the value is less than or equal to a maximum.\n     *\n     * @param value The value validation is being performed on.\n     * @param max The maximum value.\n     * @return {@code true} if the value is less than\n     *         or equal to the maximum.\n     */\n    public boolean maxValue(final Number value, final Number max) {\n        if (isAllowFractions()) {\n            return value.doubleValue() <= max.doubleValue();\n        }\n        return value.longValue() <= max.longValue();\n    }\n\n    /**\n     * Check if the value is greater than or equal to a minimum.\n     *\n     * @param value The value validation is being performed on.\n     * @param min The minimum value.\n     * @return {@code true} if the value is greater than\n     *         or equal to the minimum.\n     */\n    public boolean minValue(final Number value, final Number min) {\n        if (isAllowFractions()) {\n            return value.doubleValue() >= min.doubleValue();\n        }\n        return value.longValue() >= min.longValue();\n    }\n\n    /**\n     * <p>Parse the value using the specified pattern.</p>\n     *\n     * @param value The value validation is being performed on.\n     * @param pattern The pattern used to validate the value against, or the\n     *        default for the {@link Locale} if {@code null}.\n     * @param locale The locale to use for the date format, system default if null.\n     * @return The parsed value if valid or {@code null} if invalid.\n     */\n    protected Object parse(String value, final String pattern, final Locale locale) {\n        value = value == null ? null : value.trim();\n        final String value1 = value;\n        if (GenericValidator.isBlankOrNull(value1)) {\n            return null;\n        }\n        final Format formatter = getFormat(pattern, locale);\n        return parse(value, formatter);\n\n    }\n\n    /**\n     * <p>Process the parsed value, performing any further validation\n     *    and type conversion required.</p>\n     *\n     * @param value The parsed object created.\n     * @param formatter The Format used to parse the value with.\n     * @return The parsed value converted to the appropriate type\n     *         if valid or {@code null} if invalid.\n     */\n    @Override\n    protected abstract Object processParsedValue(Object value, Format formatter);\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -3088817875906765463L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -3088817875906765463L", "syntax_pass": true}, {"attribute_expression": "public static final int STANDARD_FORMAT = 0;", "docstring": " Standard {@code NumberFormat} type", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "STANDARD_FORMAT = 0", "syntax_pass": true}, {"attribute_expression": "public static final int CURRENCY_FORMAT = 1;", "docstring": " Currency {@code NumberFormat} type", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "CURRENCY_FORMAT = 1", "syntax_pass": true}, {"attribute_expression": "public static final int PERCENT_FORMAT = 2;", "docstring": " Percent {@code NumberFormat} type", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "PERCENT_FORMAT = 2", "syntax_pass": true}, {"attribute_expression": "private final boolean allowFractions;", "docstring": "\n{@code true} if fractions are allowed or {@code false} if integers only.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "allowFractions", "syntax_pass": true}, {"attribute_expression": "private final int formatType;", "docstring": "\nThe {@code NumberFormat} type to create for validation, default is STANDARD_FORMAT.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "formatType", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator", "name": "AbstractCalendarValidator", "file_path": "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java", "superclasses": "AbstractFormatValidator", "methods": ["[]AbstractCalendarValidator(boolean,int,int)", "[int]calculateCompareResult(Calendar,Calendar,int)", "[int]calculateQuarter(Calendar,int)", "[int]compare(Calendar,Calendar,int)", "[int]compareQuarters(Calendar,Calendar,int)", "[int]compareTime(Calendar,Calendar,int)", "[String]format(Object,Format)", "[String]format(Object,Locale,TimeZone)", "[String]format(Object,String,Locale)", "[String]format(Object,String,Locale,TimeZone)", "[String]format(Object,String,TimeZone)", "[String]format(Object,TimeZone)", "[Format]getFormat(Locale)", "[Format]getFormat(String,Locale)", "[boolean]isValid(String,String,Locale)", "[Object]parse(String,String,Locale,TimeZone)", "[Object]processParsedValue(Object,Format)"], "method_uris": ["src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[]AbstractCalendarValidator(boolean,int,int)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[int]calculateCompareResult(Calendar,Calendar,int)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[int]calculateQuarter(Calendar,int)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[int]compare(Calendar,Calendar,int)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[int]compareQuarters(Calendar,Calendar,int)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[int]compareTime(Calendar,Calendar,int)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[String]format(Object,Format)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[String]format(Object,Locale,TimeZone)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[String]format(Object,String,Locale)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[String]format(Object,String,Locale,TimeZone)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[String]format(Object,String,TimeZone)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[String]format(Object,TimeZone)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[Format]getFormat(Locale)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[Format]getFormat(String,Locale)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[boolean]isValid(String,String,Locale)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[Object]parse(String,String,Locale,TimeZone)", "src/main/java/org/apache/commons/validator/routines/AbstractCalendarValidator.java.AbstractCalendarValidator.[Object]processParsedValue(Object,Format)"], "overrides": null, "attributes": [], "class_docstring": "\n<p>Abstract class for Date/Time/Calendar validation.</p>\n\n<p>This is a <em>base</em> class for building Date / Time\n   Validators using format parsing.</p>\n\n@since 1.3.0\n", "original_string": "public abstract class AbstractCalendarValidator extends AbstractFormatValidator {\n\n    private static final long serialVersionUID = -1410008585975827379L;\n\n    /**\n     * The date style to use for Locale validation.\n     */\n    private final int dateStyle;\n\n    /**\n     * The time style to use for Locale validation.\n     */\n    private final int timeStyle;\n\n    /**\n     * Constructs an instance with the specified <em>strict</em>,\n     * <em>time</em> and <em>date</em> style parameters.\n     *\n     * @param strict {@code true} if strict\n     *        {@code Format} parsing should be used.\n     * @param dateStyle the date style to use for Locale validation.\n     * @param timeStyle the time style to use for Locale validation.\n     */\n    public AbstractCalendarValidator(final boolean strict, final int dateStyle, final int timeStyle) {\n        super(strict);\n        this.dateStyle = dateStyle;\n        this.timeStyle = timeStyle;\n    }\n\n    /**\n     * <p>Compares the field from two calendars indicating whether the field for the\n     *    first calendar is equal to, less than or greater than the field from the\n     *    second calendar.\n     *\n     * @param value The Calendar value.\n     * @param compare The {@link Calendar} to check the value against.\n     * @param field The field to compare for the calendars.\n     * @return Zero if the first calendar's field is equal to the seconds, -1\n     *         if it is less than the seconds or +1 if it is greater than the seconds.\n     */\n    private int calculateCompareResult(final Calendar value, final Calendar compare, final int field) {\n        final int difference = value.get(field) - compare.get(field);\n        if (difference < 0) {\n            return -1;\n        }\n        if (difference > 0) {\n            return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * <p>Calculate the quarter for the specified Calendar.</p>\n     *\n     * @param calendar The Calendar value.\n     * @param monthOfFirstQuarter The  month that the first quarter starts.\n     * @return The calculated quarter.\n     */\n    private int calculateQuarter(final Calendar calendar, final int monthOfFirstQuarter) {\n        // Add Year\n        int year = calendar.get(Calendar.YEAR);\n\n        final int month = calendar.get(Calendar.MONTH) + 1;\n        final int relativeMonth = month >= monthOfFirstQuarter\n                          ? month - monthOfFirstQuarter\n                          : month + 12 - monthOfFirstQuarter; // CHECKSTYLE IGNORE MagicNumber\n        final int quarter = relativeMonth / 3 + 1; // CHECKSTYLE IGNORE MagicNumber\n        // adjust the year if the quarter doesn't start in January\n        if (month < monthOfFirstQuarter) {\n            --year;\n        }\n        return year * 10 + quarter; // CHECKSTYLE IGNORE MagicNumber\n    }\n\n    /**\n     * <p>Compares a calendar value to another, indicating whether it is\n     *    equal, less then or more than at a specified level.</p>\n     *\n     * @param value The Calendar value.\n     * @param compare The {@link Calendar} to check the value against.\n     * @param field The field <em>level</em> to compare to - e.g. specifying\n     *        {@code Calendar.MONTH} will compare the year and month\n     *        portions of the calendar.\n     * @return Zero if the first value is equal to the second, -1\n     *         if it is less than the second or +1 if it is greater than the second.\n     */\n    protected int compare(final Calendar value, final Calendar compare, final int field) {\n\n        int result;\n\n        // Compare Year\n        result = calculateCompareResult(value, compare, Calendar.YEAR);\n        if (result != 0 || field == Calendar.YEAR) {\n            return result;\n        }\n\n        // Compare Week of Year\n        if (field == Calendar.WEEK_OF_YEAR) {\n            return calculateCompareResult(value, compare, Calendar.WEEK_OF_YEAR);\n        }\n\n        // Compare Day of the Year\n        if (field == Calendar.DAY_OF_YEAR) {\n            return calculateCompareResult(value, compare, Calendar.DAY_OF_YEAR);\n        }\n\n        // Compare Month\n        result = calculateCompareResult(value, compare, Calendar.MONTH);\n        if (result != 0 || field == Calendar.MONTH) {\n            return result;\n        }\n\n        // Compare Week of Month\n        if (field == Calendar.WEEK_OF_MONTH) {\n            return calculateCompareResult(value, compare, Calendar.WEEK_OF_MONTH);\n        }\n\n        // Compare Date\n        result = calculateCompareResult(value, compare, Calendar.DATE);\n        if (result != 0 || field == Calendar.DATE ||\n                          field == Calendar.DAY_OF_WEEK ||\n                          field == Calendar.DAY_OF_WEEK_IN_MONTH) {\n            return result;\n        }\n\n        // Compare Time fields\n        return compareTime(value, compare, field);\n\n    }\n\n    /**\n     * <p>Compares a calendar's quarter value to another, indicating whether it is\n     *    equal, less then or more than the specified quarter.</p>\n     *\n     * @param value The Calendar value.\n     * @param compare The {@link Calendar} to check the value against.\n     * @param monthOfFirstQuarter The  month that the first quarter starts.\n     * @return Zero if the first quarter is equal to the second, -1\n     *         if it is less than the second or +1 if it is greater than the second.\n     */\n    protected int compareQuarters(final Calendar value, final Calendar compare, final int monthOfFirstQuarter) {\n        final int valueQuarter = calculateQuarter(value, monthOfFirstQuarter);\n        final int compareQuarter = calculateQuarter(compare, monthOfFirstQuarter);\n        if (valueQuarter < compareQuarter) {\n            return -1;\n        }\n        if (valueQuarter > compareQuarter) {\n            return 1;\n        }\n        return 0;\n    }\n\n    /**\n     * <p>Compares a calendar time value to another, indicating whether it is\n     *    equal, less then or more than at a specified level.</p>\n     *\n     * @param value The Calendar value.\n     * @param compare The {@link Calendar} to check the value against.\n     * @param field The field <em>level</em> to compare to - e.g. specifying\n     *        {@code Calendar.MINUTE} will compare the hours and minutes\n     *        portions of the calendar.\n     * @return Zero if the first value is equal to the second, -1\n     *         if it is less than the second or +1 if it is greater than the second.\n     */\n    protected int compareTime(final Calendar value, final Calendar compare, final int field) {\n\n        int result;\n\n        // Compare Hour\n        result = calculateCompareResult(value, compare, Calendar.HOUR_OF_DAY);\n        if (result != 0 || field == Calendar.HOUR || field == Calendar.HOUR_OF_DAY) {\n            return result;\n        }\n\n        // Compare Minute\n        result = calculateCompareResult(value, compare, Calendar.MINUTE);\n        if (result != 0 || field == Calendar.MINUTE) {\n            return result;\n        }\n\n        // Compare Second\n        result = calculateCompareResult(value, compare, Calendar.SECOND);\n        if (result != 0 || field == Calendar.SECOND) {\n            return result;\n        }\n\n        // Compare Milliseconds\n        if (field == Calendar.MILLISECOND) {\n            return calculateCompareResult(value, compare, Calendar.MILLISECOND);\n        }\n\n        throw new IllegalArgumentException(\"Invalid field: \" + field);\n\n    }\n\n    /**\n     * <p>Format a value with the specified {@code DateFormat}.</p>\n     *\n     * @param value The value to be formatted.\n     * @param formatter The Format to use.\n     * @return The formatted value.\n     */\n    @Override\n    protected String format(Object value, final Format formatter) {\n        if (value == null) {\n            return null;\n        }\n        if (value instanceof Calendar) {\n            value = ((Calendar) value).getTime();\n        }\n        return formatter.format(value);\n    }\n\n    /**\n     * <p>Format an object into a {@link String} using\n     * the specified Locale.</p>\n     *\n     * @param value The value validation is being performed on.\n     * @param locale The locale to use for the Format.\n     * @param timeZone The Time Zone used to format the date,\n     *  system default if null (unless value is a {@link Calendar}.\n     * @return The value formatted as a {@link String}.\n     */\n    public String format(final Object value, final Locale locale, final TimeZone timeZone) {\n        return format(value, (String) null, locale, timeZone);\n    }\n\n    /**\n     * <p>Format an object using the specified pattern and/or\n     *    {@link Locale}.\n     *\n     * @param value The value validation is being performed on.\n     * @param pattern The pattern used to format the value.\n     * @param locale The locale to use for the Format.\n     * @return The value formatted as a {@link String}.\n     */\n    @Override\n    public String format(final Object value, final String pattern, final Locale locale) {\n        return format(value, pattern, locale, (TimeZone) null);\n    }\n\n    /**\n     * <p>Format an object using the specified pattern and/or\n     *    {@link Locale}.\n     *\n     * @param value The value validation is being performed on.\n     * @param pattern The pattern used to format the value.\n     * @param locale The locale to use for the Format.\n     * @param timeZone The Time Zone used to format the date,\n     *  system default if null (unless value is a {@link Calendar}.\n     * @return The value formatted as a {@link String}.\n     */\n    public String format(final Object value, final String pattern, final Locale locale, final TimeZone timeZone) {\n        final DateFormat formatter = (DateFormat) getFormat(pattern, locale);\n        if (timeZone != null) {\n            formatter.setTimeZone(timeZone);\n        } else if (value instanceof Calendar) {\n            formatter.setTimeZone(((Calendar) value).getTimeZone());\n        }\n        return format(value, formatter);\n    }\n\n    /**\n     * <p>Format an object into a {@link String} using\n     * the specified pattern.</p>\n     *\n     * @param value The value validation is being performed on.\n     * @param pattern The pattern used to format the value.\n     * @param timeZone The Time Zone used to format the date,\n     *  system default if null (unless value is a {@link Calendar}.\n     * @return The value formatted as a {@link String}.\n     */\n    public String format(final Object value, final String pattern, final TimeZone timeZone) {\n        return format(value, pattern, (Locale) null, timeZone);\n    }\n\n    /**\n     * <p>Format an object into a {@link String} using\n     * the default Locale.</p>\n     *\n     * @param value The value validation is being performed on.\n     * @param timeZone The Time Zone used to format the date,\n     *  system default if null (unless value is a {@link Calendar}.\n     * @return The value formatted as a {@link String}.\n     */\n    public String format(final Object value, final TimeZone timeZone) {\n        return format(value, (String) null, (Locale) null, timeZone);\n    }\n\n    /**\n     * <p>Returns a {@code DateFormat} for the specified Locale.</p>\n     *\n     * @param locale The locale a {@code DateFormat} is required for,\n     *        system default if null.\n     * @return The {@code DateFormat} to created.\n     */\n    protected Format getFormat(final Locale locale) {\n        DateFormat formatter;\n        if (dateStyle >= 0 && timeStyle >= 0) {\n            if (locale == null) {\n                formatter = DateFormat.getDateTimeInstance(dateStyle, timeStyle);\n            } else {\n                formatter = DateFormat.getDateTimeInstance(dateStyle, timeStyle, locale);\n            }\n        } else if (timeStyle >= 0) {\n            if (locale == null) {\n                formatter = DateFormat.getTimeInstance(timeStyle);\n            } else {\n                formatter = DateFormat.getTimeInstance(timeStyle, locale);\n            }\n        } else {\n            final int useDateStyle = dateStyle >= 0 ? dateStyle : DateFormat.SHORT;\n            if (locale == null) {\n                formatter = DateFormat.getDateInstance(useDateStyle);\n            } else {\n                formatter = DateFormat.getDateInstance(useDateStyle, locale);\n            }\n        }\n        formatter.setLenient(false);\n        return formatter;\n\n    }\n\n    /**\n     * <p>Returns a {@code DateFormat} for the specified <em>pattern</em>\n     *    and/or {@link Locale}.</p>\n     *\n     * @param pattern The pattern used to validate the value against or\n     *        {@code null} to use the default for the {@link Locale}.\n     * @param locale The locale to use for the currency format, system default if null.\n     * @return The {@code DateFormat} to created.\n     */\n    @Override\n    protected Format getFormat(final String pattern, final Locale locale) {\n        DateFormat formatter;\n        final boolean usePattern = !GenericValidator.isBlankOrNull(pattern);\n        if (!usePattern) {\n            formatter = (DateFormat) getFormat(locale);\n        } else if (locale == null) {\n            formatter = new SimpleDateFormat(pattern);\n        } else {\n            final DateFormatSymbols symbols = new DateFormatSymbols(locale);\n            formatter = new SimpleDateFormat(pattern, symbols);\n        }\n        formatter.setLenient(false);\n        return formatter;\n    }\n\n    /**\n     * <p>Validate using the specified {@link Locale}.\n     *\n     * @param value The value validation is being performed on.\n     * @param pattern The pattern used to format the value.\n     * @param locale The locale to use for the Format, defaults to the default\n     * @return {@code true} if the value is valid.\n     */\n    @Override\n    public boolean isValid(final String value, final String pattern, final Locale locale) {\n        return parse(value, pattern, locale, (TimeZone) null) != null;\n    }\n\n    /**\n     * <p>Checks if the value is valid against a specified pattern.</p>\n     *\n     * @param value The value validation is being performed on.\n     * @param pattern The pattern used to validate the value against, or the\n     *        default for the {@link Locale} if {@code null}.\n     * @param locale The locale to use for the date format, system default if null.\n     * @param timeZone The Time Zone used to parse the date, system default if null.\n     * @return The parsed value if valid or {@code null} if invalid.\n     */\n    protected Object parse(String value, final String pattern, final Locale locale, final TimeZone timeZone) {\n        value = value == null ? null : value.trim();\n        final String value1 = value;\n        if (GenericValidator.isBlankOrNull(value1)) {\n            return null;\n        }\n        final DateFormat formatter = (DateFormat) getFormat(pattern, locale);\n        if (timeZone != null) {\n            formatter.setTimeZone(timeZone);\n        }\n        return parse(value, formatter);\n\n    }\n\n    /**\n     * <p>Process the parsed value, performing any further validation\n     *    and type conversion required.</p>\n     *\n     * @param value The parsed object created.\n     * @param formatter The Format used to parse the value with.\n     * @return The parsed value converted to the appropriate type\n     *         if valid or {@code null} if invalid.\n     */\n    @Override\n    protected abstract Object processParsedValue(Object value, Format formatter);\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long serialVersionUID = -1410008585975827379L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = -1410008585975827379L", "syntax_pass": true}, {"attribute_expression": "private final int dateStyle;", "docstring": "\nThe date style to use for Locale validation.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "dateStyle", "syntax_pass": true}, {"attribute_expression": "private final int timeStyle;", "docstring": "\nThe time style to use for Locale validation.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "timeStyle", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/validator/routines/checkdigit/ModulusCheckDigit.java.ModulusCheckDigit", "name": "ModulusCheckDigit", "file_path": "src/main/java/org/apache/commons/validator/routines/checkdigit/ModulusCheckDigit.java", "superclasses": "AbstractCheckDigit", "methods": ["[int]sumDigits(int)", "[]ModulusCheckDigit()", "[]ModulusCheckDigit(int)", "[String]calculate(String)", "[int]calculateModulus(String,boolean)", "[int]getModulus()", "[boolean]isValid(String)", "[String]toCheckDigit(int)", "[int]toInt(char,int,int)", "[int]weightedValue(int,int,int)"], "method_uris": ["src/main/java/org/apache/commons/validator/routines/checkdigit/ModulusCheckDigit.java.ModulusCheckDigit.[int]sumDigits(int)", "src/main/java/org/apache/commons/validator/routines/checkdigit/ModulusCheckDigit.java.ModulusCheckDigit.[]ModulusCheckDigit()", "src/main/java/org/apache/commons/validator/routines/checkdigit/ModulusCheckDigit.java.ModulusCheckDigit.[]ModulusCheckDigit(int)", "src/main/java/org/apache/commons/validator/routines/checkdigit/ModulusCheckDigit.java.ModulusCheckDigit.[String]calculate(String)", "src/main/java/org/apache/commons/validator/routines/checkdigit/ModulusCheckDigit.java.ModulusCheckDigit.[int]calculateModulus(String,boolean)", "src/main/java/org/apache/commons/validator/routines/checkdigit/ModulusCheckDigit.java.ModulusCheckDigit.[int]getModulus()", "src/main/java/org/apache/commons/validator/routines/checkdigit/ModulusCheckDigit.java.ModulusCheckDigit.[boolean]isValid(String)", "src/main/java/org/apache/commons/validator/routines/checkdigit/ModulusCheckDigit.java.ModulusCheckDigit.[String]toCheckDigit(int)", "src/main/java/org/apache/commons/validator/routines/checkdigit/ModulusCheckDigit.java.ModulusCheckDigit.[int]toInt(char,int,int)", "src/main/java/org/apache/commons/validator/routines/checkdigit/ModulusCheckDigit.java.ModulusCheckDigit.[int]weightedValue(int,int,int)"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract <b>Modulus</b> Check digit calculation/validation.\n<p>\nProvides a <em>base</em> class for building <em>modulus</em> Check Digit routines.\n</p>\n<p>\nThis implementation only handles <em>single-digit numeric</em> codes, such as <b>EAN-13</b>. For <em>alphanumeric</em> codes such as <b>EAN-128</b> you will need\nto implement/override the {@code toInt()} and {@code toChar()} methods.\n</p>\n\n@since 1.4\n", "original_string": "public abstract class ModulusCheckDigit extends AbstractCheckDigit implements Serializable {\n\n    static final int MODULUS_10 = 10;\n    static final int MODULUS_11 = 11;\n    private static final long serialVersionUID = 2948962251251528941L;\n\n    /**\n     * Add together the individual digits in a number.\n     *\n     * @param number The number whose digits are to be added\n     * @return The sum of the digits\n     */\n    public static int sumDigits(final int number) {\n        int total = 0;\n        int todo = number;\n        while (todo > 0) {\n            total += todo % 10; // CHECKSTYLE IGNORE MagicNumber\n            todo /= 10; // CHECKSTYLE IGNORE MagicNumber\n        }\n        return total;\n    }\n\n    /**\n     * The modulus can be greater than 10 provided that the implementing class overrides toCheckDigit and toInt (for example as in ISBN10CheckDigit).\n     */\n    private final int modulus;\n\n    /**\n     * Constructs a modulus 10 {@link CheckDigit} routine for a specified modulus.\n     */\n    ModulusCheckDigit() {\n        this(MODULUS_10);\n    }\n\n    /**\n     * Constructs a {@link CheckDigit} routine for a specified modulus.\n     *\n     * @param modulus The modulus value to use for the check digit calculation\n     */\n    public ModulusCheckDigit(final int modulus) {\n        this.modulus = modulus;\n    }\n\n    /**\n     * Calculate a modulus <em>Check Digit</em> for a code which does not yet have one.\n     *\n     * @param code The code for which to calculate the Check Digit;\n     * the check digit should not be included\n     * @return The calculated Check Digit\n     * @throws CheckDigitException if an error occurs calculating the check digit\n     */\n    @Override\n    public String calculate(final String code) throws CheckDigitException {\n        if (GenericValidator.isBlankOrNull(code)) {\n            throw new CheckDigitException(\"Code is missing\");\n        }\n        final int modulusResult = calculateModulus(code, false);\n        final int charValue = (modulus - modulusResult) % modulus;\n        return toCheckDigit(charValue);\n    }\n\n    /**\n     * Calculate the modulus for a code.\n     *\n     * @param code The code to calculate the modulus for.\n     * @param includesCheckDigit Whether the code includes the Check Digit or not.\n     * @return The modulus value\n     * @throws CheckDigitException if an error occurs calculating the modulus\n     * for the specified code\n     */\n    protected int calculateModulus(final String code, final boolean includesCheckDigit) throws CheckDigitException {\n        int total = 0;\n        for (int i = 0; i < code.length(); i++) {\n            final int lth = code.length() + (includesCheckDigit ? 0 : 1);\n            final int leftPos = i + 1;\n            final int rightPos = lth - i;\n            final int charValue = toInt(code.charAt(i), leftPos, rightPos);\n            total += weightedValue(charValue, leftPos, rightPos);\n        }\n        if (total == 0) {\n            throw new CheckDigitException(\"Invalid code, sum is zero\");\n        }\n        return total % modulus;\n    }\n\n    /**\n     * Gets the modulus value this check digit routine is based on.\n     *\n     * @return The modulus value this check digit routine is based on\n     */\n    public int getModulus() {\n        return modulus;\n    }\n\n    /**\n     * Validate a modulus check digit for a code.\n     *\n     * @param code The code to validate\n     * @return {@code true} if the check digit is valid, otherwise\n     * {@code false}\n     */\n    @Override\n    public boolean isValid(final String code) {\n        if (GenericValidator.isBlankOrNull(code)) {\n            return false;\n        }\n        try {\n            final int modulusResult = calculateModulus(code, true);\n            return modulusResult == 0;\n        } catch (final CheckDigitException ex) {\n            return false;\n        }\n    }\n\n    /**\n     * Convert an integer value to a check digit.\n     * <p>\n     * <b>Note:</b> this implementation only handles single-digit numeric values\n     * For non-numeric characters, override this method to provide\n     * integer--&gt;character conversion.\n     *\n     * @param charValue The integer value of the character\n     * @return The converted character\n     * @throws CheckDigitException if integer character value\n     * doesn't represent a numeric character\n     */\n    protected String toCheckDigit(final int charValue) throws CheckDigitException {\n        if (charValue >= 0 && charValue <= 9) { // CHECKSTYLE IGNORE MagicNumber\n            return Integer.toString(charValue);\n        }\n        throw new CheckDigitException(\"Invalid Check Digit Value =\" + +charValue);\n    }\n\n    /**\n     * Convert a character at a specified position to an integer value.\n     * <p>\n     * <b>Note:</b> this implementation only handlers numeric values\n     * For non-numeric characters, override this method to provide\n     * character--&gt;integer conversion.\n     *\n     * @param character The character to convert\n     * @param leftPos The position of the character in the code, counting from left to right (for identifiying the position in the string)\n     * @param rightPos The position of the character in the code, counting from right to left (not used here)\n     * @return The integer value of the character\n     * @throws CheckDigitException if character is non-numeric\n     */\n    protected int toInt(final char character, final int leftPos, final int rightPos) throws CheckDigitException {\n        if (Character.isDigit(character)) {\n            return Character.getNumericValue(character);\n        }\n        throw new CheckDigitException(\"Invalid Character[\" + leftPos + \"] = '\" + character + \"'\");\n    }\n\n    /**\n     * Calculates the <em>weighted</em> value of a character in the\n     * code at a specified position.\n     * <p>\n     * Some modulus routines weight the value of a character\n     * depending on its position in the code (e.g. ISBN-10), while\n     * others use different weighting factors for odd/even positions\n     * (e.g. EAN or Luhn). Implement the appropriate mechanism\n     * required by overriding this method.\n     *\n     * @param charValue The numeric value of the character\n     * @param leftPos The position of the character in the code, counting from left to right\n     * @param rightPos The positionof the character in the code, counting from right to left\n     * @return The weighted value of the character\n     * @throws CheckDigitException if an error occurs calculating\n     * the weighted value\n     */\n    protected abstract int weightedValue(int charValue, int leftPos, int rightPos) throws CheckDigitException;\n\n}", "super_interfaces": ["Serializable"], "fields": [{"attribute_expression": "static final int MODULUS_10 = 10;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "MODULUS_10 = 10", "syntax_pass": true}, {"attribute_expression": "static final int MODULUS_11 = 11;", "docstring": "", "modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "type": "int", "name": "MODULUS_11 = 11", "syntax_pass": true}, {"attribute_expression": "private static final long serialVersionUID = 2948962251251528941L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "serialVersionUID = 2948962251251528941L", "syntax_pass": true}, {"attribute_expression": "private final int modulus;", "docstring": "\nThe modulus can be greater than 10 provided that the implementing class overrides toCheckDigit and toInt (for example as in ISBN10CheckDigit).\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "modulus", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/validator/routines/checkdigit/AbstractCheckDigit.java.AbstractCheckDigit", "name": "AbstractCheckDigit", "file_path": "src/main/java/org/apache/commons/validator/routines/checkdigit/AbstractCheckDigit.java", "superclasses": "", "methods": [], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nAbstracts CheckDigit.\n", "original_string": "abstract class AbstractCheckDigit implements CheckDigit {\n    // Empty\n}", "super_interfaces": ["CheckDigit"], "fields": []}]