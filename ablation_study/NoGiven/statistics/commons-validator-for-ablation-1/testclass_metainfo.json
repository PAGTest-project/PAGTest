[{"uris": "src/test/java/org/apache/commons/validator/GenericTypeValidatorTest.java.GenericTypeValidatorTest", "name": "GenericTypeValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/GenericTypeValidatorTest.java", "superclasses": "AbstractCommonTest", "methods": ["[void]testFRLocale()", "[void]testType()", "[void]testUSLocale()"], "method_uris": ["src/test/java/org/apache/commons/validator/GenericTypeValidatorTest.java.GenericTypeValidatorTest.[Map<String, ?>]localeTest(TypeBean,Locale)", "src/test/java/org/apache/commons/validator/GenericTypeValidatorTest.java.GenericTypeValidatorTest.[void]setUp()", "src/test/java/org/apache/commons/validator/GenericTypeValidatorTest.java.GenericTypeValidatorTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test for type validations.\n", "original_string": "public class GenericTypeValidatorTest extends AbstractCommonTest {\n\n    /**\n     * The key used to retrieve the set of validation rules from the xml file.\n     */\n    protected static final String FORM_KEY = \"typeForm\";\n\n    /**\n     * The key used to retrieve the validator action.\n     */\n    protected static final String ACTION = \"byte\";\n\n    /**\n     * Tests the locale.\n     */\n    private Map<String, ?> localeTest(final TypeBean info, final Locale locale) throws ValidatorException {\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, \"typeLocaleForm\");\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, info);\n        validator.setParameter(\"java.util.Locale\", locale);\n\n        // Get results of the validation.\n        // throws ValidatorException,\n        // but we aren't catching for testing\n        // since no validation methods we use\n        // throw this\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final Map<String, ?> hResultValues = results.getResultValueMap();\n\n        assertTrue(hResultValues.get(\"byte\") instanceof Byte, () -> \"Expecting byte result to be an instance of Byte for locale: \" + locale);\n        assertTrue(hResultValues.get(\"short\") instanceof Short, () -> \"Expecting short result to be an instance of Short for locale: \" + locale);\n        assertTrue(hResultValues.get(\"integer\") instanceof Integer, () -> \"Expecting integer result to be an instance of Integer for locale: \" + locale);\n        assertTrue(hResultValues.get(\"long\") instanceof Long, () -> \"Expecting long result to be an instance of Long for locale: \" + locale);\n        assertTrue(hResultValues.get(\"float\") instanceof Float, () -> \"Expecting float result to be an instance of Float for locale: \" + locale);\n        assertTrue(hResultValues.get(\"double\") instanceof Double, () -> \"Expecting double result to be an instance of Double for locale: \" + locale);\n        assertTrue(hResultValues.get(\"date\") instanceof Date, () -> \"Expecting date result to be an instance of Date for locale: \" + locale);\n\n        for (final String key : hResultValues.keySet()) {\n            final Object value = hResultValues.get(key);\n\n            assertNotNull(value, () -> \"value ValidatorResults.getResultValueMap() should not be null for locale: \" + locale);\n        }\n        return hResultValues;\n    }\n\n    /**\n     * Load {@code ValidatorResources} from validator-type.xml.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException, SAXException {\n        // Load resources\n        loadResources(\"GenericTypeValidatorTest-config.xml\");\n    }\n\n    @AfterEach\n    protected void tearDown() {\n    }\n\n    /**\n     * Tests the fr locale.\n     */\n    @Test\n    public void testFRLocale() throws ValidatorException {\n        // Create bean to run test on.\n        final TypeBean info = new TypeBean();\n        info.setByte(\"12\");\n        info.setShort(\"-129\");\n        info.setInteger(\"1443\");\n        info.setLong(\"88000\");\n        info.setFloat(\"12,1555\");\n        info.setDouble(\"129,1551511111\");\n        info.setDate(\"21/12/2010\");\n        final Map<String, ?> map = localeTest(info, Locale.FRENCH);\n        assertEquals(12, ((Float) map.get(\"float\")).intValue(), \"float value not correct\");\n        assertEquals(129, ((Double) map.get(\"double\")).intValue(), \"double value not correct\");\n    }\n\n    /**\n     * Tests the byte validation.\n     */\n    @Test\n    public void testType() throws ValidatorException {\n        // Create bean to run test on.\n        final TypeBean info = new TypeBean();\n        info.setByte(\"12\");\n        info.setShort(\"129\");\n        info.setInteger(\"-144\");\n        info.setLong(\"88000\");\n        info.setFloat(\"12.1555f\");\n        info.setDouble(\"129.1551511111d\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, info);\n\n        // Get results of the validation.\n        // throws ValidatorException,\n        // but we aren't catching for testing\n        // since no validation methods we use\n        // throw this\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final Map<String, ?> hResultValues = results.getResultValueMap();\n\n        assertTrue(hResultValues.get(\"byte\") instanceof Byte, \"Expecting byte result to be an instance of Byte.\");\n        assertTrue(hResultValues.get(\"short\") instanceof Short, \"Expecting short result to be an instance of Short.\");\n        assertTrue(hResultValues.get(\"integer\") instanceof Integer, \"Expecting integer result to be an instance of Integer.\");\n        assertTrue(hResultValues.get(\"long\") instanceof Long, \"Expecting long result to be an instance of Long.\");\n        assertTrue(hResultValues.get(\"float\") instanceof Float, \"Expecting float result to be an instance of Float.\");\n        assertTrue(hResultValues.get(\"double\") instanceof Double, \"Expecting double result to be an instance of Double.\");\n\n        for (final String key : hResultValues.keySet()) {\n            final Object value = hResultValues.get(key);\n\n            assertNotNull(value, \"value ValidatorResults.getResultValueMap() should not be null.\");\n        }\n\n        // ValidatorResult result = results.getValidatorResult(\"value\");\n\n        // assertNotNull(ACTION + \" value ValidatorResult should not be null.\", result);\n        // assertTrue(ACTION + \" value ValidatorResult should contain the '\" + ACTION +\"' action.\", result.containsAction(ACTION));\n        // assertTrue(ACTION + \" value ValidatorResult for the '\" + ACTION +\"' action should have \" + (passed ? \"passed\" : \"failed\") + \".\", (passed ?\n        // result.isValid(ACTION) : !result.isValid(ACTION)));\n\n    }\n\n    /**\n     * Tests the us locale\n     */\n    @Test\n    public void testUSLocale() throws ValidatorException {\n        // Create bean to run test on.\n        final TypeBean info = new TypeBean();\n        info.setByte(\"12\");\n        info.setShort(\"129\");\n        info.setInteger(\"-144\");\n        info.setLong(\"88000\");\n        info.setFloat(\"12.1555\");\n        info.setDouble(\"129.1551511111\");\n        info.setDate(\"12/21/2010\");\n        localeTest(info, Locale.US);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final String FORM_KEY = \"typeForm\";", "docstring": "\nThe key used to retrieve the set of validation rules from the xml file.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "FORM_KEY = \"typeForm\"", "syntax_pass": true}, {"attribute_expression": "protected static final String ACTION = \"byte\";", "docstring": "\nThe key used to retrieve the validator action.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "ACTION = \"byte\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/CreditCardValidatorTest.java.CreditCardValidatorTest", "name": "CreditCardValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/CreditCardValidatorTest.java", "superclasses": "", "methods": ["[void]testAddAllowedCardType()", "[void]testIsValid()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    private static class DinersClub implements CreditCardValidator.CreditCardType {\n        private static final String PREFIX = \"300,301,302,303,304,305,\";\n\n        @Override\n        public boolean matches(final String card) {\n            final String prefix = card.substring(0, 3) + \",\";\n            return PREFIX.contains(prefix) && card.length() == 14;\n        }\n    }", "definition": "    private static class DinersClub implements CreditCardValidator.CreditCardType", "class_docstring": "\nTest a custom implementation of CreditCardType.\n", "name": "DinersClub", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private static final String PREFIX = \"300,301,302,303,304,305,\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PREFIX = \"300,301,302,303,304,305,\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(final String card) {\n            final String prefix = card.substring(0, 3) + \",\";\n            return PREFIX.contains(prefix) && card.length() == 14;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "card", "type": "String"}], "body": "                                                  {\n            final String prefix = card.substring(0, 3) + \",\";\n            return PREFIX.contains(prefix) && card.length() == 14;\n        }", "signature": "@Override\n        public boolean matches(final String card)"}]}], "class_docstring": "\nTest the CreditCardValidator class.\n\n@deprecated this test can be removed when the deprecated class is removed\n", "original_string": "@Deprecated\npublic class CreditCardValidatorTest {\n\n    /**\n     * Test a custom implementation of CreditCardType.\n     */\n    private static class DinersClub implements CreditCardValidator.CreditCardType {\n        private static final String PREFIX = \"300,301,302,303,304,305,\";\n\n        @Override\n        public boolean matches(final String card) {\n            final String prefix = card.substring(0, 3) + \",\";\n            return PREFIX.contains(prefix) && card.length() == 14;\n        }\n    }\n\n    private static final String VALID_VISA = \"4417123456789113\";\n    private static final String VALID_SHORT_VISA = \"4222222222222\";\n    private static final String VALID_AMEX = \"378282246310005\";\n    private static final String VALID_MASTERCARD = \"5105105105105100\";\n    private static final String VALID_DISCOVER = \"6011000990139424\";\n\n    private static final String VALID_DINERS = \"30569309025904\";\n\n    @Test\n    public void testAddAllowedCardType() {\n        final CreditCardValidator ccv = new CreditCardValidator(CreditCardValidator.NONE);\n        // Turned off all cards so even valid numbers should fail\n        assertFalse(ccv.isValid(VALID_VISA));\n        assertFalse(ccv.isValid(VALID_AMEX));\n        assertFalse(ccv.isValid(VALID_MASTERCARD));\n        assertFalse(ccv.isValid(VALID_DISCOVER));\n\n        // test our custom type\n        ccv.addAllowedCardType(new DinersClub());\n        assertTrue(ccv.isValid(VALID_DINERS));\n    }\n\n    @Test\n    public void testIsValid() {\n        CreditCardValidator ccv = new CreditCardValidator();\n\n        assertFalse(ccv.isValid(null));\n        assertFalse(ccv.isValid(\"\"));\n        assertFalse(ccv.isValid(\"123456789012\")); // too short\n        assertFalse(ccv.isValid(\"12345678901234567890\")); // too long\n        assertFalse(ccv.isValid(\"4417123456789112\"));\n        assertFalse(ccv.isValid(\"4417q23456w89113\"));\n        assertTrue(ccv.isValid(VALID_VISA));\n        assertTrue(ccv.isValid(VALID_SHORT_VISA));\n        assertTrue(ccv.isValid(VALID_AMEX));\n        assertTrue(ccv.isValid(VALID_MASTERCARD));\n        assertTrue(ccv.isValid(VALID_DISCOVER));\n\n        // disallow Visa so it should fail even with good number\n        ccv = new CreditCardValidator(CreditCardValidator.AMEX);\n        assertFalse(ccv.isValid(\"4417123456789113\"));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String VALID_VISA = \"4417123456789113\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "VALID_VISA = \"4417123456789113\"", "syntax_pass": true}, {"attribute_expression": "private static final String VALID_SHORT_VISA = \"4222222222222\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "VALID_SHORT_VISA = \"4222222222222\"", "syntax_pass": true}, {"attribute_expression": "private static final String VALID_AMEX = \"378282246310005\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "VALID_AMEX = \"378282246310005\"", "syntax_pass": true}, {"attribute_expression": "private static final String VALID_MASTERCARD = \"5105105105105100\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "VALID_MASTERCARD = \"5105105105105100\"", "syntax_pass": true}, {"attribute_expression": "private static final String VALID_DISCOVER = \"6011000990139424\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "VALID_DISCOVER = \"6011000990139424\"", "syntax_pass": true}, {"attribute_expression": "private static final String VALID_DINERS = \"30569309025904\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "VALID_DINERS = \"30569309025904\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/DateTest.java.DateTest", "name": "DateTest", "file_path": "src/test/java/org/apache/commons/validator/DateTest.java", "superclasses": "AbstractCommonTest", "methods": ["[void]testInvalidDate()", "[void]testValidDate()"], "method_uris": ["src/test/java/org/apache/commons/validator/DateTest.java.DateTest.[void]setUp()", "src/test/java/org/apache/commons/validator/DateTest.java.DateTest.[void]valueTest(Object,boolean)"], "overrides": null, "attributes": [], "class_docstring": "\nAbstracts date unit tests methods.\n", "original_string": "public class DateTest extends AbstractCommonTest {\n\n    /**\n     * The key used to retrieve the set of validation rules from the xml file.\n     */\n    protected static final String FORM_KEY = \"dateForm\";\n\n    /**\n     * The key used to retrieve the validator action.\n     */\n    protected static final String ACTION = \"date\";\n\n    /**\n     * Load {@code ValidatorResources} from validator-numeric.xml.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException, SAXException {\n        // Load resources\n        loadResources(\"DateTest-config.xml\");\n    }\n\n    /**\n     * Tests the date validation.\n     */\n    @Test\n    public void testInvalidDate() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(\"12/01as/2005\");\n        valueTest(info, false);\n    }\n\n    /**\n     * Tests the date validation.\n     */\n    @Test\n    public void testValidDate() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(\"12/01/2005\");\n        valueTest(info, true);\n    }\n\n    /**\n     * Utlity class to run a test on a value.\n     *\n     * @param info   Value to run test on.\n     * @param passed Whether or not the test is expected to pass.\n     */\n    protected void valueTest(final Object info, final boolean passed) throws ValidatorException {\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, info);\n        validator.setParameter(Validator.LOCALE_PARAM, Locale.US);\n\n        // Get results of the validation.\n        // throws ValidatorException,\n        // but we aren't catching for testing\n        // since no validation methods we use\n        // throw this\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult result = results.getValidatorResult(\"value\");\n\n        assertNotNull(result, () -> ACTION + \" value ValidatorResult should not be null.\");\n        assertTrue(result.containsAction(ACTION), () -> ACTION + \" value ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(passed ? result.isValid(ACTION) : !result.isValid(ACTION),\n                () -> ACTION + \" value ValidatorResult for the '\" + ACTION + \"' action should have \" + (passed ? \"passed\" : \"failed\") + \".\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final String FORM_KEY = \"dateForm\";", "docstring": "\nThe key used to retrieve the set of validation rules from the xml file.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "FORM_KEY = \"dateForm\"", "syntax_pass": true}, {"attribute_expression": "protected static final String ACTION = \"date\";", "docstring": "\nThe key used to retrieve the validator action.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "ACTION = \"date\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/ExceptionTest.java.ExceptionTest", "name": "ExceptionTest", "file_path": "src/test/java/org/apache/commons/validator/ExceptionTest.java", "superclasses": "AbstractCommonTest", "methods": ["[void]testValidatorException()"], "method_uris": ["src/test/java/org/apache/commons/validator/ExceptionTest.java.ExceptionTest.[void]setUp()", "src/test/java/org/apache/commons/validator/ExceptionTest.java.ExceptionTest.[void]testCheckedException()", "src/test/java/org/apache/commons/validator/ExceptionTest.java.ExceptionTest.[void]testRuntimeException()"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test for exception handling.\n", "original_string": "public class ExceptionTest extends AbstractCommonTest {\n\n    /**\n     * The key used to retrieve the set of validation rules from the xml file.\n     */\n    protected static final String FORM_KEY = \"exceptionForm\";\n\n    /**\n     * The key used to retrieve the validator action.\n     */\n    protected static final String ACTION = \"raiseException\";\n\n    /**\n     * Load {@code ValidatorResources} from validator-exception.xml.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException, SAXException {\n        loadResources(\"ExceptionTest-config.xml\");\n    }\n\n    /**\n     * Tests handling of checked exceptions - should become ValidatorExceptions.\n     *\n     * N.B. This test has been removed (renamed) as it currently serves no purpose. If/When exception handling is changed in Validator 2.0 it can be\n     * reconsidered then.\n     */\n    @Ignore\n    public void testCheckedException() {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(\"CHECKED\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, info);\n\n        // Get results of the validation which can throw ValidatorException\n\n        // Tests Validator 1.x exception handling\n        try {\n            validator.validate();\n        } catch (final ValidatorException expected) {\n            fail(\"Checked exceptions are not wrapped in ValidatorException in Validator 1.x.\");\n        } catch (final Exception e) {\n            assertTrue(\"CHECKED-EXCEPTION\".equals(e.getMessage()));\n        }\n\n        // This will be true in Validator 2.0\n//        try {\n//            validator.validate();\n//            fail(\"ValidatorException should occur here!\");\n//        } catch (ValidatorException expected) {\n//            assertTrue(\"CHECKED-EXCEPTION\".equals(expected.getMessage()));\n//        }\n    }\n\n    /**\n     * Tests handling of runtime exceptions.\n     *\n     * N.B. This test has been removed (renamed) as it currently serves no purpose. If/When exception handling is changed in Validator 2.0 it can be\n     * reconsidered then.\n     */\n    @Ignore\n    public void testRuntimeException() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(\"RUNTIME\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, info);\n\n        // Get results of the validation which can throw ValidatorException\n        try {\n            validator.validate();\n            // fail(\"RuntimeException should occur here!\");\n        } catch (final RuntimeException expected) {\n            fail(\"RuntimeExceptions should be treated as validation failures in Validator 1.x.\");\n            // This will be true in Validator 2.0\n            // assertTrue(\"RUNTIME-EXCEPTION\".equals(expected.getMessage()));\n        }\n    }\n\n    /**\n     * Tests handling of checked exceptions - should become ValidatorExceptions.\n     */\n    @Test\n    public void testValidatorException() {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(\"VALIDATOR\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, info);\n\n        // Get results of the validation which can throw ValidatorException\n        try {\n            validator.validate();\n            fail(\"ValidatorException should occur here!\");\n        } catch (final ValidatorException expected) {\n            assertTrue(\"VALIDATOR-EXCEPTION\".equals(expected.getMessage()));\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final String FORM_KEY = \"exceptionForm\";", "docstring": "\nThe key used to retrieve the set of validation rules from the xml file.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "FORM_KEY = \"exceptionForm\"", "syntax_pass": true}, {"attribute_expression": "protected static final String ACTION = \"raiseException\";", "docstring": "\nThe key used to retrieve the validator action.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "ACTION = \"raiseException\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/ByteTest.java.ByteTest", "name": "ByteTest", "file_path": "src/test/java/org/apache/commons/validator/ByteTest.java", "superclasses": "AbstractNumberTest", "methods": ["[void]testByte()", "[void]testByteBeyondMax()", "[void]testByteBeyondMin()", "[void]testByteFailure()", "[void]testByteMax()", "[void]testByteMin()"], "method_uris": ["src/test/java/org/apache/commons/validator/ByteTest.java.ByteTest.[]ByteTest()"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test for {@code byte} validations.\n", "original_string": "public class ByteTest extends AbstractNumberTest {\n\n    public ByteTest() {\n        action = \"byte\";\n        formKey = \"byteForm\";\n    }\n\n    /**\n     * Tests the byte validation.\n     */\n    @Test\n    public void testByte() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(\"0\");\n\n        valueTest(info, true);\n    }\n\n    /**\n     * Tests the byte validation failure.\n     */\n    @Test\n    public void testByteBeyondMax() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Byte.MAX_VALUE + \"1\");\n\n        valueTest(info, false);\n    }\n\n    /**\n     * Tests the byte validation failure.\n     */\n    @Test\n    public void testByteBeyondMin() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Byte.MIN_VALUE + \"1\");\n\n        valueTest(info, false);\n    }\n\n    /**\n     * Tests the byte validation failure.\n     */\n    @Test\n    public void testByteFailure() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n\n        valueTest(info, false);\n    }\n\n    /**\n     * Tests the byte validation.\n     */\n    @Test\n    public void testByteMax() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Byte.toString(Byte.MAX_VALUE));\n\n        valueTest(info, true);\n    }\n\n    /**\n     * Tests the byte validation.\n     */\n    @Test\n    public void testByteMin() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Byte.toString(Byte.MIN_VALUE));\n\n        valueTest(info, true);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/ValidatorResources_addConstantTest.java.ValidatorResources_addConstantTest", "name": "ValidatorResources_addConstantTest", "file_path": "src/test/java/org/apache/commons/validator/ValidatorResources_addConstantTest.java", "superclasses": "", "methods": ["[void]testAddConstant()", "[void]testAddConstantWithDebugLogging()"], "method_uris": ["src/test/java/org/apache/commons/validator/ValidatorResources_addConstantTest.java.ValidatorResources_addConstantTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ValidatorResources_addConstantTest {\n\n    private ValidatorResources resources;\n\n    @BeforeEach\n    protected void setUp() throws Exception {\n        try (InputStream in = this.getClass().getResourceAsStream(\"/ValidatorResourcesTest-config.xml\")) {\n            if (in == null) {\n                // Provide a default configuration or mock data if the resource is not found\n                resources = new ValidatorResources();\n            } else {\n                resources = new ValidatorResources(in);\n            }\n        }\n    }\n\n    @Test\n    public void testAddConstant() {\n        // Given\n        String constantName = \"TEST_CONSTANT\";\n        String constantValue = \"testValue\";\n\n        // When\n        resources.addConstant(constantName, constantValue);\n\n        // Then\n        Map<String, String> constants = resources.getConstants();\n        assertNotNull(constants);\n        assertEquals(constantValue, constants.get(constantName));\n    }\n\n    @Test\n    public void testAddConstantWithDebugLogging() {\n        // Given\n        String constantName = \"DEBUG_CONSTANT\";\n        String constantValue = \"debugValue\";\n\n        // When\n        resources.addConstant(constantName, constantValue);\n\n        // Then\n        Map<String, String> constants = resources.getConstants();\n        assertNotNull(constants);\n        assertEquals(constantValue, constants.get(constantName));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ValidatorResources resources;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ValidatorResources", "name": "resources", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/RetrieveFormTest.java.RetrieveFormTest", "name": "RetrieveFormTest", "file_path": "src/test/java/org/apache/commons/validator/RetrieveFormTest.java", "superclasses": "", "methods": ["[void]testDefaultForm()", "[void]testFormNotFound()", "[void]testLanguageCountryForm()", "[void]testLanguageCountryVariantForm()", "[void]testLanguageForm()"], "method_uris": ["src/test/java/org/apache/commons/validator/RetrieveFormTest.java.RetrieveFormTest.[void]checkForm(Locale,String,String)", "src/test/java/org/apache/commons/validator/RetrieveFormTest.java.RetrieveFormTest.[void]checkFormNotFound(Locale,String)", "src/test/java/org/apache/commons/validator/RetrieveFormTest.java.RetrieveFormTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests retrieving forms using different Locales.\n", "original_string": "public class RetrieveFormTest {\n\n    /**\n     * Prefix for the forms.\n     */\n    private static final String FORM_PREFIX = \"testForm_\";\n\n    /**\n     * Prefix for the forms.\n     */\n    private static final Locale CANADA_FRENCH_XXX = new Locale(\"fr\", \"CA\", \"XXX\");\n\n    /**\n     * Resources used for validation tests.\n     */\n    private ValidatorResources resources;\n\n    private void checkForm(final Locale locale, final String formKey, final String expectedVarValue) {\n\n        // Retrieve the Form\n        final Form testForm = resources.getForm(locale, formKey);\n        assertNotNull(testForm, \"Form '\" + formKey + \"' null for locale \" + locale);\n\n        // Validate the expected Form is retrieved by checking the \"localeVar\"\n        // value of the field.\n        final Field testField = testForm.getField(\"testProperty\");\n        assertEquals(expectedVarValue, testField.getVarValue(\"localeVar\"), \"Incorrect Form '\" + formKey + \"' for locale '\" + locale + \"'\");\n    }\n\n    private void checkFormNotFound(final Locale locale, final String formKey) {\n\n        // Retrieve the Form\n        final Form testForm = resources.getForm(locale, formKey);\n        assertNull(testForm, \"Form '\" + formKey + \"' not null for locale \" + locale);\n\n    }\n\n    /**\n     * Load {@code ValidatorResources} from multiple xml files.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException, SAXException {\n        final InputStream[] streams = { this.getClass().getResourceAsStream(\"RetrieveFormTest-config.xml\") };\n\n        resources = new ValidatorResources(streams);\n\n        for (final InputStream stream : streams) {\n            stream.close();\n        }\n    }\n\n    /**\n     * Test a form defined only in the \"default\" formset.\n     */\n    @Test\n    public void testDefaultForm() {\n\n        final String formKey = FORM_PREFIX + \"default\";\n\n        // *** US locale ***\n        checkForm(Locale.US, formKey, \"default\");\n\n        // *** French locale ***\n        checkForm(Locale.FRENCH, formKey, \"default\");\n\n        // *** France locale ***\n        checkForm(Locale.FRANCE, formKey, \"default\");\n\n        // *** Candian (English) locale ***\n        checkForm(Locale.CANADA, formKey, \"default\");\n\n        // *** Candian French locale ***\n        checkForm(Locale.CANADA_FRENCH, formKey, \"default\");\n\n        // *** Candian French Variant locale ***\n        checkForm(CANADA_FRENCH_XXX, formKey, \"default\");\n\n    }\n\n    /**\n     * Test a form not defined\n     */\n    @Test\n    public void testFormNotFound() {\n\n        final String formKey = \"INVALID_NAME\";\n\n        // *** US locale ***\n        checkFormNotFound(Locale.US, formKey);\n\n        // *** French locale ***\n        checkFormNotFound(Locale.FRENCH, formKey);\n\n        // *** France locale ***\n        checkFormNotFound(Locale.FRANCE, formKey);\n\n        // *** Candian (English) locale ***\n        checkFormNotFound(Locale.CANADA, formKey);\n\n        // *** Candian French locale ***\n        checkFormNotFound(Locale.CANADA_FRENCH, formKey);\n\n        // *** Candian French Variant locale ***\n        checkFormNotFound(CANADA_FRENCH_XXX, formKey);\n\n    }\n\n    /**\n     * Test a form defined in the \"default\" formset, formsets where just the \"language\" is specified and formset where the language and country are specified.\n     */\n    @Test\n    public void testLanguageCountryForm() {\n\n        final String formKey = FORM_PREFIX + \"language_country\";\n\n        // *** US locale ***\n        checkForm(Locale.US, formKey, \"default\");\n\n        // *** French locale ***\n        checkForm(Locale.FRENCH, formKey, \"fr\");\n\n        // *** France locale ***\n        checkForm(Locale.FRANCE, formKey, \"fr_FR\");\n\n        // *** Candian (English) locale ***\n        checkForm(Locale.CANADA, formKey, \"default\");\n\n        // *** Candian French locale ***\n        checkForm(Locale.CANADA_FRENCH, formKey, \"fr_CA\");\n\n        // *** Candian French Variant locale ***\n        checkForm(CANADA_FRENCH_XXX, formKey, \"fr_CA\");\n\n    }\n\n    /**\n     * Test a form defined in all the formsets\n     */\n    @Test\n    public void testLanguageCountryVariantForm() {\n\n        final String formKey = FORM_PREFIX + \"language_country_variant\";\n\n        // *** US locale ***\n        checkForm(Locale.US, formKey, \"default\");\n\n        // *** French locale ***\n        checkForm(Locale.FRENCH, formKey, \"fr\");\n\n        // *** France locale ***\n        checkForm(Locale.FRANCE, formKey, \"fr_FR\");\n\n        // *** Candian (English) locale ***\n        checkForm(Locale.CANADA, formKey, \"default\");\n\n        // *** Candian French locale ***\n        checkForm(Locale.CANADA_FRENCH, formKey, \"fr_CA\");\n\n        // *** Candian French Variant locale ***\n        checkForm(CANADA_FRENCH_XXX, formKey, \"fr_CA_XXX\");\n\n    }\n\n    /**\n     * Test a form defined in the \"default\" formset and formsets where just the \"language\" is specified.\n     */\n    @Test\n    public void testLanguageForm() {\n\n        final String formKey = FORM_PREFIX + \"language\";\n\n        // *** US locale ***\n        checkForm(Locale.US, formKey, \"default\");\n\n        // *** French locale ***\n        checkForm(Locale.FRENCH, formKey, \"fr\");\n\n        // *** France locale ***\n        checkForm(Locale.FRANCE, formKey, \"fr\");\n\n        // *** Candian (English) locale ***\n        checkForm(Locale.CANADA, formKey, \"default\");\n\n        // *** Candian French locale ***\n        checkForm(Locale.CANADA_FRENCH, formKey, \"fr\");\n\n        // *** Candian French Variant locale ***\n        checkForm(CANADA_FRENCH_XXX, formKey, \"fr\");\n\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String FORM_PREFIX = \"testForm_\";", "docstring": "\nPrefix for the forms.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "FORM_PREFIX = \"testForm_\"", "syntax_pass": true}, {"attribute_expression": "private static final Locale CANADA_FRENCH_XXX = new Locale(\"fr\", \"CA\", \"XXX\");", "docstring": "\nPrefix for the forms.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Locale", "name": "CANADA_FRENCH_XXX = new Locale(\"fr\", \"CA\", \"XXX\")", "syntax_pass": true}, {"attribute_expression": "private ValidatorResources resources;", "docstring": "\nResources used for validation tests.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ValidatorResources", "name": "resources", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/EntityImportTest.java.EntityImportTest", "name": "EntityImportTest", "file_path": "src/test/java/org/apache/commons/validator/EntityImportTest.java", "superclasses": "AbstractCommonTest", "methods": ["[void]testEntityImport()", "[void]testParseURL()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests entity imports.\n", "original_string": "public class EntityImportTest extends AbstractCommonTest {\n\n    /**\n     * Tests the entity import loading the {@code byteForm} form.\n     */\n    @Test\n    public void testEntityImport() throws Exception {\n        final URL url = getClass().getResource(\"EntityImportTest-config.xml\");\n        final ValidatorResources resources = new ValidatorResources(url.toExternalForm());\n        assertNotNull(resources.getForm(Locale.getDefault(), \"byteForm\"), \"Form should be found\");\n    }\n\n    /**\n     * Tests loading ValidatorResources from a URL\n     */\n    @Test\n    public void testParseURL() throws Exception {\n        final URL url = getClass().getResource(\"EntityImportTest-config.xml\");\n        final ValidatorResources resources = new ValidatorResources(url);\n        assertNotNull(resources.getForm(Locale.getDefault(), \"byteForm\"), \"Form should be found\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/Var_toStringTest.java.Var_toStringTest", "name": "Var_toStringTest", "file_path": "src/test/java/org/apache/commons/validator/Var_toStringTest.java", "superclasses": "", "methods": ["[void]testToStringWithResource()", "[void]testToStringWithoutResource()", "[void]testToStringWithNullValues()", "[void]testToStringWithEmptyValues()"], "method_uris": ["src/test/java/org/apache/commons/validator/Var_toStringTest.java.Var_toStringTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Var_toStringTest {\n\n    private Var var;\n\n    @BeforeEach\n    public void setUp() {\n        var = new Var();\n    }\n\n    @Test\n    public void testToStringWithResource() {\n        var.setName(\"testName\");\n        var.setValue(\"testValue\");\n        var.setResource(true);\n        var.setBundle(\"testBundle\");\n        var.setJsType(\"testJsType\");\n\n        String expected = \"Var: name=testName  value=testValue  resource=true  bundle=testBundle  jsType=testJsType\\n\";\n        assertEquals(expected, var.toString());\n    }\n\n    @Test\n    public void testToStringWithoutResource() {\n        var.setName(\"testName\");\n        var.setValue(\"testValue\");\n        var.setResource(false);\n        var.setJsType(\"testJsType\");\n\n        String expected = \"Var: name=testName  value=testValue  resource=false  jsType=testJsType\\n\";\n        assertEquals(expected, var.toString());\n    }\n\n    @Test\n    public void testToStringWithNullValues() {\n        var.setName(null);\n        var.setValue(null);\n        var.setResource(false);\n        var.setJsType(null);\n\n        String expected = \"Var: name=null  value=null  resource=false  jsType=null\\n\";\n        assertEquals(expected, var.toString());\n    }\n\n    @Test\n    public void testToStringWithEmptyValues() {\n        var.setName(\"\");\n        var.setValue(\"\");\n        var.setResource(false);\n        var.setJsType(\"\");\n\n        String expected = \"Var: name=  value=  resource=false  jsType=\\n\";\n        assertEquals(expected, var.toString());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Var var;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Var", "name": "var", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/GenericValidator_matchRegexpTest.java.GenericValidator_matchRegexpTest", "name": "GenericValidator_matchRegexpTest", "file_path": "src/test/java/org/apache/commons/validator/GenericValidator_matchRegexpTest.java", "superclasses": "", "methods": ["[void]testMatchRegexp_NullRegexp()", "[void]testMatchRegexp_EmptyRegexp()", "[void]testMatchRegexp_ValidMatch()", "[void]testMatchRegexp_InvalidMatch()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class GenericValidator_matchRegexpTest {\n\n    @Test\n    public void testMatchRegexp_NullRegexp() {\n        assertFalse(GenericValidator.matchRegexp(\"test\", null));\n    }\n\n    @Test\n    public void testMatchRegexp_EmptyRegexp() {\n        assertFalse(GenericValidator.matchRegexp(\"test\", \"\"));\n    }\n\n    @Test\n    public void testMatchRegexp_ValidMatch() {\n        assertTrue(GenericValidator.matchRegexp(\"test\", \"test\"));\n    }\n\n    @Test\n    public void testMatchRegexp_InvalidMatch() {\n        assertFalse(GenericValidator.matchRegexp(\"test\", \"nottest\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/ValidatorTest.java.ValidatorTest", "name": "ValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/ValidatorTest.java", "superclasses": "", "methods": ["[void]testManualBoolean()", "[void]testManualBooleanDeprecated()", "[void]testManualObject()", "[void]testOnlyReturnErrors()", "[void]testOnlyValidateField()"], "method_uris": ["src/test/java/org/apache/commons/validator/ValidatorTest.java.ValidatorTest.[Date]formatDate(Object,Field)", "src/test/java/org/apache/commons/validator/ValidatorTest.java.ValidatorTest.[boolean]isCapLetter(Object,Field,List<String>)", "src/test/java/org/apache/commons/validator/ValidatorTest.java.ValidatorTest.[ValidatorResources]setupDateResources(String,String)"], "overrides": null, "attributes": [{"original_string": "    public static class TestBean {\n        private String letter;\n        private String date;\n\n        public String getDate() {\n            return date;\n        }\n\n        public String getLetter() {\n            return letter;\n        }\n\n        public void setDate(final String date) {\n            this.date = date;\n        }\n\n        public void setLetter(final String letter) {\n            this.letter = letter;\n        }\n    }", "definition": "    public static class TestBean", "class_docstring": "", "name": "TestBean", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private String letter;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "letter", "syntax_pass": true}, {"attribute_expression": "private String date;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "date", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public String getDate() {\n            return date;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getDate", "params": [], "body": "                                {\n            return date;\n        }", "signature": "public String getDate()"}, {"syntax_pass": true, "original_string": "        public String getLetter() {\n            return letter;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getLetter", "params": [], "body": "                                  {\n            return letter;\n        }", "signature": "public String getLetter()"}, {"syntax_pass": true, "original_string": "        public void setDate(final String date) {\n            this.date = date;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setDate", "params": [{"name": "date", "type": "String"}], "body": "                                               {\n            this.date = date;\n        }", "signature": "public void setDate(final String date)"}, {"syntax_pass": true, "original_string": "        public void setLetter(final String letter) {\n            this.letter = letter;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setLetter", "params": [{"name": "letter", "type": "String"}], "body": "                                                   {\n            this.letter = letter;\n        }", "signature": "public void setLetter(final String letter)"}]}], "class_docstring": "\nPerforms Validation Test.\n", "original_string": "public class ValidatorTest {\n\n    public static class TestBean {\n        private String letter;\n        private String date;\n\n        public String getDate() {\n            return date;\n        }\n\n        public String getLetter() {\n            return letter;\n        }\n\n        public void setDate(final String date) {\n            this.date = date;\n        }\n\n        public void setLetter(final String letter) {\n            this.letter = letter;\n        }\n    }\n\n    /**\n     * Formats a {@code String} to a {@code Date}. The {@code Validator} will interpret a {@code null} as validation having failed.\n     */\n    public static Date formatDate(final Object bean, final Field field) {\n        final String value = ValidatorUtils.getValueAsString(bean, field.getProperty());\n        Date date = null;\n\n        try {\n            final DateFormat formatter = DateFormat.getDateInstance(DateFormat.SHORT, Locale.US);\n\n            formatter.setLenient(false);\n\n            date = formatter.parse(value);\n        } catch (final ParseException e) {\n            System.out.println(\"ValidatorTest.formatDate() - \" + e.getMessage());\n        }\n\n        return date;\n    }\n\n    /**\n     * Checks if the field is one upper case letter between 'A' and 'Z'.\n     */\n    public static boolean isCapLetter(final Object bean, final Field field, final List<String> l) {\n        final String value = ValidatorUtils.getValueAsString(bean, field.getProperty());\n\n        if (value == null || value.length() != 1) {\n            l.add(\"Error\");\n            return false;\n        }\n        if (value.charAt(0) >= 'A' && value.charAt(0) <= 'Z') {\n            return true;\n        }\n        l.add(\"Error\");\n        return false;\n    }\n\n    private ValidatorResources setupDateResources(final String property, final String action) {\n\n        final ValidatorResources resources = new ValidatorResources();\n\n        final ValidatorAction va = new ValidatorAction();\n        va.setName(action);\n        va.setClassname(\"org.apache.commons.validator.ValidatorTest\");\n        va.setMethod(\"formatDate\");\n        va.setMethodParams(\"java.lang.Object,org.apache.commons.validator.Field\");\n\n        final FormSet fs = new FormSet();\n        final Form form = new Form();\n        form.setName(\"testForm\");\n        final Field field = new Field();\n        field.setProperty(property);\n        field.setDepends(action);\n        form.addField(field);\n        fs.addForm(form);\n\n        resources.addValidatorAction(va);\n        resources.addFormSet(fs);\n        resources.process();\n\n        return resources;\n    }\n\n    /**\n     * Verify that one value generates an error and the other passes. The validation method being tested returns a {@code boolean} value.\n     */\n    @Test\n    public void testManualBoolean() {\n        final ValidatorResources resources = new ValidatorResources();\n\n        final ValidatorAction va = new ValidatorAction();\n        va.setName(\"capLetter\");\n        va.setClassName(\"org.apache.commons.validator.ValidatorTest\");\n        va.setMethod(\"isCapLetter\");\n        va.setMethodParams(\"java.lang.Object,org.apache.commons.validator.Field,java.util.List\");\n\n        final FormSet fs = new FormSet();\n        final Form form = new Form();\n        form.setName(\"testForm\");\n        final Field field = new Field();\n        field.setProperty(\"letter\");\n        field.setDepends(\"capLetter\");\n        form.addField(field);\n        fs.addForm(form);\n\n        resources.addValidatorAction(va);\n        resources.addFormSet(fs);\n        resources.process();\n\n        final List<?> l = new ArrayList<>();\n\n        final TestBean bean = new TestBean();\n        bean.setLetter(\"A\");\n\n        final Validator validator = new Validator(resources, \"testForm\");\n        validator.setParameter(Validator.BEAN_PARAM, bean);\n        validator.setParameter(\"java.util.List\", l);\n\n        try {\n            validator.validate();\n        } catch (final Exception e) {\n            fail(\"An exception was thrown while calling Validator.validate()\");\n        }\n\n        assertEquals(0, l.size(), \"Validation of the letter 'A'.\");\n\n        l.clear();\n        bean.setLetter(\"AA\");\n\n        try {\n            validator.validate();\n        } catch (final Exception e) {\n            fail(\"An exception was thrown while calling Validator.validate()\");\n        }\n\n        assertEquals(1, l.size(), \"Validation of the letter 'AA'.\");\n    }\n\n    /**\n     * Verify that one value generates an error and the other passes. The validation method being tested returns a {@code boolean} value.\n     */\n    @Test\n    public void testManualBooleanDeprecated() {\n        final ValidatorResources resources = new ValidatorResources();\n\n        final ValidatorAction va = new ValidatorAction();\n        va.setName(\"capLetter\");\n        va.setClassname(\"org.apache.commons.validator.ValidatorTest\");\n        va.setMethod(\"isCapLetter\");\n        va.setMethodParams(\"java.lang.Object,org.apache.commons.validator.Field,java.util.List\");\n\n        final FormSet fs = new FormSet();\n        final Form form = new Form();\n        form.setName(\"testForm\");\n        final Field field = new Field();\n        field.setProperty(\"letter\");\n        field.setDepends(\"capLetter\");\n        form.addField(field);\n        fs.addForm(form);\n\n        resources.addValidatorAction(va);\n        resources.addFormSet(fs);\n        resources.process();\n\n        final List<?> l = new ArrayList<>();\n\n        final TestBean bean = new TestBean();\n        bean.setLetter(\"A\");\n\n        final Validator validator = new Validator(resources, \"testForm\");\n        validator.setParameter(Validator.BEAN_PARAM, bean);\n        validator.setParameter(\"java.util.List\", l);\n\n        try {\n            validator.validate();\n        } catch (final Exception e) {\n            fail(\"An exception was thrown while calling Validator.validate()\");\n        }\n\n        assertEquals(0, l.size(), \"Validation of the letter 'A'.\");\n\n        l.clear();\n        bean.setLetter(\"AA\");\n\n        try {\n            validator.validate();\n        } catch (final Exception e) {\n            fail(\"An exception was thrown while calling Validator.validate()\");\n        }\n\n        assertEquals(1, l.size(), \"Validation of the letter 'AA'.\");\n    }\n\n    /**\n     * Verify that one value generates an error and the other passes. The validation method being tested returns an object ({@code null} will be considered\n     * an error).\n     */\n    @Test\n    public void testManualObject() {\n        // property name of the method we are validating\n        final String property = \"date\";\n        // name of ValidatorAction\n        final String action = \"date\";\n        final ValidatorResources resources = setupDateResources(property, action);\n\n        final TestBean bean = new TestBean();\n        bean.setDate(\"2/3/1999\");\n\n        final Validator validator = new Validator(resources, \"testForm\");\n        validator.setParameter(Validator.BEAN_PARAM, bean);\n\n        try {\n            final ValidatorResults results = validator.validate();\n\n            assertNotNull(results, \"Results are null.\");\n\n            final ValidatorResult result = results.getValidatorResult(property);\n\n            assertNotNull(results, \"Results are null.\");\n\n            assertTrue(result.containsAction(action), \"ValidatorResult does not contain '\" + action + \"' validator result.\");\n\n            assertTrue(result.isValid(action), \"Validation of the date formatting has failed.\");\n        } catch (final Exception e) {\n            fail(\"An exception was thrown while calling Validator.validate()\");\n        }\n\n        bean.setDate(\"2/30/1999\");\n\n        try {\n            final ValidatorResults results = validator.validate();\n\n            assertNotNull(results, \"Results are null.\");\n\n            final ValidatorResult result = results.getValidatorResult(property);\n\n            assertNotNull(results, \"Results are null.\");\n\n            assertTrue(result.containsAction(action), \"ValidatorResult does not contain '\" + action + \"' validator result.\");\n\n            assertTrue(!result.isValid(action), \"Validation of the date formatting has passed when it should have failed.\");\n        } catch (final Exception e) {\n            fail(\"An exception was thrown while calling Validator.validate()\");\n        }\n\n    }\n\n    @Test\n    public void testOnlyReturnErrors() throws ValidatorException {\n        // property name of the method we are validating\n        final String property = \"date\";\n        // name of ValidatorAction\n        final String action = \"date\";\n        final ValidatorResources resources = setupDateResources(property, action);\n\n        final TestBean bean = new TestBean();\n        bean.setDate(\"2/3/1999\");\n\n        final Validator validator = new Validator(resources, \"testForm\");\n        validator.setParameter(Validator.BEAN_PARAM, bean);\n\n        ValidatorResults results = validator.validate();\n\n        assertNotNull(results);\n\n        // Field passed and should be in results\n        assertTrue(results.getPropertyNames().contains(property));\n\n        // Field passed but should not be in results\n        validator.setOnlyReturnErrors(true);\n        results = validator.validate();\n        assertFalse(results.getPropertyNames().contains(property));\n    }\n\n    @Test\n    public void testOnlyValidateField() throws ValidatorException {\n        // property name of the method we are validating\n        final String property = \"date\";\n        // name of ValidatorAction\n        final String action = \"date\";\n        final ValidatorResources resources = setupDateResources(property, action);\n\n        final TestBean bean = new TestBean();\n        bean.setDate(\"2/3/1999\");\n\n        final Validator validator = new Validator(resources, \"testForm\", property);\n        validator.setParameter(Validator.BEAN_PARAM, bean);\n\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results);\n\n        // Field passed and should be in results\n        assertTrue(results.getPropertyNames().contains(property));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/ValidatorResults_addTest.java.ValidatorResults_addTest", "name": "ValidatorResults_addTest", "file_path": "src/test/java/org/apache/commons/validator/ValidatorResults_addTest.java", "superclasses": "", "methods": ["[void]testAddNewValidatorResult()", "[void]testAddExistingValidatorResult()", "[void]testClearBeforeAdd()", "[void]testMergeBeforeAdd()", "[void]testIsEmptyAfterAdd()", "[void]testGetPropertyNamesAfterAdd()"], "method_uris": ["src/test/java/org/apache/commons/validator/ValidatorResults_addTest.java.ValidatorResults_addTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ValidatorResults_addTest {\n\n    private ValidatorResults validatorResults;\n    private Field field;\n    private static final String VALIDATOR_NAME = \"required\";\n\n    @BeforeEach\n    public void setUp() {\n        validatorResults = new ValidatorResults();\n        field = new Field();\n        field.setKey(\"testField\");\n    }\n\n    @Test\n    public void testAddNewValidatorResult() {\n        validatorResults.add(field, VALIDATOR_NAME, true, \"validValue\");\n        ValidatorResult result = validatorResults.getValidatorResult(field.getKey());\n        assertNotNull(result);\n        assertTrue(result.containsAction(VALIDATOR_NAME));\n        assertTrue(result.isValid(VALIDATOR_NAME));\n        assertEquals(\"validValue\", result.getResult(VALIDATOR_NAME));\n    }\n\n    @Test\n    public void testAddExistingValidatorResult() {\n        validatorResults.add(field, VALIDATOR_NAME, true, \"validValue\");\n        validatorResults.add(field, \"anotherValidator\", false, \"invalidValue\");\n        ValidatorResult result = validatorResults.getValidatorResult(field.getKey());\n        assertNotNull(result);\n        assertTrue(result.containsAction(VALIDATOR_NAME));\n        assertTrue(result.isValid(VALIDATOR_NAME));\n        assertEquals(\"validValue\", result.getResult(VALIDATOR_NAME));\n        assertTrue(result.containsAction(\"anotherValidator\"));\n        assertFalse(result.isValid(\"anotherValidator\"));\n        assertEquals(\"invalidValue\", result.getResult(\"anotherValidator\"));\n    }\n\n    @Test\n    public void testClearBeforeAdd() {\n        validatorResults.add(field, VALIDATOR_NAME, true, \"validValue\");\n        validatorResults.clear();\n        ValidatorResult result = validatorResults.getValidatorResult(field.getKey());\n        assertNull(result);\n    }\n\n    @Test\n    public void testMergeBeforeAdd() {\n        ValidatorResults otherResults = new ValidatorResults();\n        otherResults.add(field, VALIDATOR_NAME, true, \"validValue\");\n        validatorResults.merge(otherResults);\n        ValidatorResult result = validatorResults.getValidatorResult(field.getKey());\n        assertNotNull(result);\n        assertTrue(result.containsAction(VALIDATOR_NAME));\n        assertTrue(result.isValid(VALIDATOR_NAME));\n        assertEquals(\"validValue\", result.getResult(VALIDATOR_NAME));\n    }\n\n    @Test\n    public void testIsEmptyAfterAdd() {\n        validatorResults.add(field, VALIDATOR_NAME, true, \"validValue\");\n        assertFalse(validatorResults.isEmpty());\n    }\n\n    @Test\n    public void testGetPropertyNamesAfterAdd() {\n        validatorResults.add(field, VALIDATOR_NAME, true, \"validValue\");\n        assertTrue(validatorResults.getPropertyNames().contains(field.getKey()));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ValidatorResults validatorResults;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ValidatorResults", "name": "validatorResults", "syntax_pass": true}, {"attribute_expression": "private Field field;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Field", "name": "field", "syntax_pass": true}, {"attribute_expression": "private static final String VALIDATOR_NAME = \"required\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "VALIDATOR_NAME = \"required\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/MultipleConfigFilesTest.java.MultipleConfigFilesTest", "name": "MultipleConfigFilesTest", "file_path": "src/test/java/org/apache/commons/validator/MultipleConfigFilesTest.java", "superclasses": "", "methods": ["[void]testBothBlank()", "[void]testMergedConfig()", "[void]testRequiredFirstNameBlankLastNameShort()", "[void]testRequiredLastNameLong()", "[void]testRequiredLastNameShort()"], "method_uris": ["src/test/java/org/apache/commons/validator/MultipleConfigFilesTest.java.MultipleConfigFilesTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests that validator rules split between 2 different XML files get merged properly.\n", "original_string": "public class MultipleConfigFilesTest {\n\n    /**\n     * The key used to retrieve the set of validation rules from the xml file.\n     */\n    private static final String FORM_KEY = \"nameForm\";\n\n    /**\n     * The key used to retrieve the validator action.\n     */\n    private static final String ACTION = \"required\";\n\n    /**\n     * Resources used for validation tests.\n     */\n    private ValidatorResources resources;\n\n    /**\n     * Load {@code ValidatorResources} from multiple xml files.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException, SAXException {\n        final InputStream[] streams = { this.getClass().getResourceAsStream(\"MultipleConfigFilesTest-1-config.xml\"),\n                this.getClass().getResourceAsStream(\"MultipleConfigFilesTest-2-config.xml\") };\n\n        resources = new ValidatorResources(streams);\n\n        for (final InputStream stream : streams) {\n            stream.close();\n        }\n    }\n\n    /**\n     * With nothing provided, we should fail both because both are required.\n     */\n    @Test\n    public void testBothBlank() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        // throws ValidatorException,\n        // but we aren't catching for testing\n        // since no validation methods we use\n        // throw this\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult);\n        assertTrue(firstNameResult.containsAction(ACTION));\n        assertTrue(!firstNameResult.isValid(ACTION));\n\n        assertNotNull(lastNameResult);\n        assertTrue(lastNameResult.containsAction(ACTION));\n        assertTrue(!lastNameResult.isValid(ACTION));\n        assertTrue(!lastNameResult.containsAction(\"int\"));\n    }\n\n    /**\n     * Check the forms and constants from different config files have been merged into the same FormSet.\n     */\n    @Test\n    public void testMergedConfig() {\n\n        // *********** Default Locale *******************\n\n        // Check the form from the first config file exists\n        final Form form1 = resources.getForm(\"\", \"\", \"\", \"testForm1\");\n        assertNotNull(form1, \"Form 'testForm1' not found\");\n\n        // Check the form from the second config file exists\n        final Form form2 = resources.getForm(\"\", \"\", \"\", \"testForm2\");\n        assertNotNull(form2, \"Form 'testForm2' not found\");\n\n        // Check the Constants for the form from the first config file\n        final Field field1 = form1.getField(\"testProperty1\");\n        assertEquals(\"testConstValue1\", field1.getVarValue(\"var11\"), \"testProperty1 - const 1\");\n        assertEquals(\"testConstValue2\", field1.getVarValue(\"var12\"), \"testProperty1 - const 2\");\n\n        // Check the Constants for the form from the second config file\n        final Field field2 = form2.getField(\"testProperty2\");\n        assertEquals(\"testConstValue1\", field2.getVarValue(\"var21\"), \"testProperty2 - const 1\");\n        assertEquals(\"testConstValue2\", field2.getVarValue(\"var22\"), \"testProperty2 - const 2\");\n\n        // *********** 'fr' locale *******************\n\n        // Check the form from the first config file exists\n        final Form form1Fr = resources.getForm(\"fr\", \"\", \"\", \"testForm1_fr\");\n        assertNotNull(form1Fr, \"Form 'testForm1_fr' not found\");\n\n        // Check the form from the second config file exists\n        final Form form2Fr = resources.getForm(\"fr\", \"\", \"\", \"testForm2_fr\");\n        assertNotNull(form2Fr, \"Form 'testForm2_fr' not found\");\n\n        // Check the Constants for the form from the first config file\n        final Field field1Fr = form1Fr.getField(\"testProperty1_fr\");\n        assertEquals(\"testConstValue1_fr\", field1Fr.getVarValue(\"var11_fr\"), \"testProperty1_fr - const 1\");\n        assertEquals(\"testConstValue2_fr\", field1Fr.getVarValue(\"var12_fr\"), \"testProperty1_fr - const 2\");\n\n        // Check the Constants for the form from the second config file\n        final Field field2Fr = form2Fr.getField(\"testProperty2_fr\");\n        assertEquals(\"testConstValue1_fr\", field2Fr.getVarValue(\"var21_fr\"), \"testProperty2_fr - const 1\");\n        assertEquals(\"testConstValue2_fr\", field2Fr.getVarValue(\"var22_fr\"), \"testProperty2_fr - const 2\");\n    }\n\n    /**\n     * If the first name fails required, and the second test fails int, we should get two errors.\n     */\n    @Test\n    public void testRequiredFirstNameBlankLastNameShort() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"\");\n        name.setLastName(\"Test\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult);\n        assertTrue(firstNameResult.containsAction(ACTION));\n        assertTrue(!firstNameResult.isValid(ACTION));\n\n        assertNotNull(lastNameResult);\n        assertTrue(lastNameResult.containsAction(\"int\"));\n        assertTrue(!lastNameResult.isValid(\"int\"));\n    }\n\n    /**\n     * If first name is ok and last name is ok and is an int, no errors.\n     */\n    @Test\n    public void testRequiredLastNameLong() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"Joe\");\n        name.setLastName(\"12345678\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult);\n        assertTrue(firstNameResult.containsAction(ACTION));\n        assertTrue(firstNameResult.isValid(ACTION));\n\n        assertNotNull(lastNameResult);\n        assertTrue(lastNameResult.containsAction(\"int\"));\n        assertTrue(lastNameResult.isValid(\"int\"));\n    }\n\n    /**\n     * If the first name is there, and the last name fails int, we should get one error.\n     */\n    @Test\n    public void testRequiredLastNameShort() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"Test\");\n        name.setLastName(\"Test\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult);\n        assertTrue(firstNameResult.containsAction(ACTION));\n        assertTrue(firstNameResult.isValid(ACTION));\n\n        assertNotNull(lastNameResult);\n        assertTrue(lastNameResult.containsAction(\"int\"));\n        assertTrue(!lastNameResult.isValid(\"int\"));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String FORM_KEY = \"nameForm\";", "docstring": "\nThe key used to retrieve the set of validation rules from the xml file.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "FORM_KEY = \"nameForm\"", "syntax_pass": true}, {"attribute_expression": "private static final String ACTION = \"required\";", "docstring": "\nThe key used to retrieve the validator action.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "ACTION = \"required\"", "syntax_pass": true}, {"attribute_expression": "private ValidatorResources resources;", "docstring": "\nResources used for validation tests.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ValidatorResources", "name": "resources", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/Field_getKeyTest.java.Field_getKeyTest", "name": "Field_getKeyTest", "file_path": "src/test/java/org/apache/commons/validator/Field_getKeyTest.java", "superclasses": "", "methods": ["[void]testGetKey_KeyIsNull()", "[void]testGetKey_KeyIsNotNull()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Field_getKeyTest {\n\n    @Test\n    public void testGetKey_KeyIsNull() {\n        Field field = new Field();\n        field.property = \"testProperty\";\n        field.indexedListProperty = \"testIndexedListProperty\";\n        field.indexedProperty = \"testIndexedProperty\";\n\n        String key = field.getKey();\n\n        assertEquals(\"testIndexedListProperty[].testProperty\", key);\n    }\n\n    @Test\n    public void testGetKey_KeyIsNotNull() {\n        Field field = new Field();\n        field.key = \"existingKey\";\n\n        String key = field.getKey();\n\n        assertEquals(\"existingKey\", key);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/ISBNValidatorTest.java.ISBNValidatorTest", "name": "ISBNValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/ISBNValidatorTest.java", "superclasses": "", "methods": ["[void]testIsValid()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests {@link ISBNValidator}.\n\n@deprecated to be removed when the org.apache.commons.validator.ISBNValidator class is removed\n", "original_string": "@Deprecated\npublic class ISBNValidatorTest {\n\n    private static final String VALID_ISBN_RAW = \"1930110995\";\n    private static final String VALID_ISBN_DASHES = \"1-930110-99-5\";\n    private static final String VALID_ISBN_SPACES = \"1 930110 99 5\";\n    private static final String VALID_ISBN_X = \"0-201-63385-X\";\n    private static final String INVALID_ISBN = \"068-556-98-45\";\n\n    @Test\n    public void testIsValid() throws Exception {\n        final ISBNValidator validator = new ISBNValidator();\n        assertFalse(validator.isValid(null));\n        assertFalse(validator.isValid(\"\"));\n        assertFalse(validator.isValid(\"1\"));\n        assertFalse(validator.isValid(\"12345678901234\"));\n        assertFalse(validator.isValid(\"dsasdsadsads\"));\n        assertFalse(validator.isValid(\"535365\"));\n        assertFalse(validator.isValid(\"I love sparrows!\"));\n        assertFalse(validator.isValid(\"--1 930110 99 5\"));\n        assertFalse(validator.isValid(\"1 930110 99 5--\"));\n        assertFalse(validator.isValid(\"1 930110-99 5-\"));\n\n        assertTrue(validator.isValid(VALID_ISBN_RAW));\n        assertTrue(validator.isValid(VALID_ISBN_DASHES));\n        assertTrue(validator.isValid(VALID_ISBN_SPACES));\n        assertTrue(validator.isValid(VALID_ISBN_X));\n        assertFalse(validator.isValid(INVALID_ISBN));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String VALID_ISBN_RAW = \"1930110995\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "VALID_ISBN_RAW = \"1930110995\"", "syntax_pass": true}, {"attribute_expression": "private static final String VALID_ISBN_DASHES = \"1-930110-99-5\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "VALID_ISBN_DASHES = \"1-930110-99-5\"", "syntax_pass": true}, {"attribute_expression": "private static final String VALID_ISBN_SPACES = \"1 930110 99 5\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "VALID_ISBN_SPACES = \"1 930110 99 5\"", "syntax_pass": true}, {"attribute_expression": "private static final String VALID_ISBN_X = \"0-201-63385-X\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "VALID_ISBN_X = \"0-201-63385-X\"", "syntax_pass": true}, {"attribute_expression": "private static final String INVALID_ISBN = \"068-556-98-45\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "INVALID_ISBN = \"068-556-98-45\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/FieldTest.java.FieldTest", "name": "FieldTest", "file_path": "src/test/java/org/apache/commons/validator/FieldTest.java", "superclasses": "", "methods": ["[void]testDefaultOnePosition()", "[void]testDefaultPositionImplied()", "[void]testDefaultSomePositions()", "[void]testDefaultUsingPositions()", "[void]testEmptyArgs()", "[void]testOverridePositionImplied()", "[void]testOverrideSomePosition()", "[void]testOverrideUsingPositionA()", "[void]testOverrideUsingPositionB()"], "method_uris": ["src/test/java/org/apache/commons/validator/FieldTest.java.FieldTest.[Arg]createArg(String)", "src/test/java/org/apache/commons/validator/FieldTest.java.FieldTest.[Arg]createArg(String,int)", "src/test/java/org/apache/commons/validator/FieldTest.java.FieldTest.[Arg]createArg(String,String)", "src/test/java/org/apache/commons/validator/FieldTest.java.FieldTest.[Arg]createArg(String,String,int)", "src/test/java/org/apache/commons/validator/FieldTest.java.FieldTest.[void]setUp()", "src/test/java/org/apache/commons/validator/FieldTest.java.FieldTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nTest {@code Field} objects.\n", "original_string": "public class FieldTest {\n\n    protected Field field;\n\n    /**\n     * Convenience Method - create argument (no name or position specified)\n     */\n    private Arg createArg(final String key) {\n        final Arg arg = new Arg();\n        arg.setKey(key);\n        return arg;\n    }\n\n    /**\n     * Convenience Method - create argument (no name, position specified)\n     */\n    private Arg createArg(final String key, final int position) {\n        final Arg arg = createArg(key);\n        arg.setPosition(position);\n        return arg;\n    }\n\n    /**\n     * Convenience Method - create argument (name specified, no position)\n     */\n    private Arg createArg(final String key, final String name) {\n        final Arg arg = createArg(key);\n        arg.setName(name);\n        return arg;\n    }\n\n    /**\n     * Convenience Method - create argument (name & position specified)\n     */\n    private Arg createArg(final String key, final String name, final int position) {\n        final Arg arg = createArg(key, name);\n        arg.setPosition(position);\n        return arg;\n    }\n\n    /**\n     * Test setup\n     */\n    @BeforeEach\n    public void setUp() {\n        field = new Field();\n    }\n\n    /**\n     * Test clean up\n     */\n    @AfterEach\n    public void tearDown() {\n        field = null;\n    }\n\n    /**\n     * test Field with only 'default' arguments, position specified for one argument\n     */\n    @Test\n    public void testDefaultOnePosition() {\n\n        field.addArg(createArg(\"default-position-0\"));\n        field.addArg(createArg(\"default-position-2\", 2));\n        field.addArg(createArg(\"default-position-3\"));\n\n        assertEquals(4, field.getArgs(\"required\").length, \"testDefaultOnePosition(1) \");\n        assertEquals(\"default-position-0\", field.getArg(\"required\", 0).getKey(), \"testDefaultOnePosition(2) \");\n        assertNull(field.getArg(\"required\", 1), \"testDefaultOnePosition(3) \");\n        assertEquals(\"default-position-2\", field.getArg(\"required\", 2).getKey(), \"testDefaultOnePosition(4) \");\n        assertEquals(\"default-position-3\", field.getArg(\"required\", 3).getKey(), \"testDefaultOnePosition(5) \");\n\n    }\n\n    /**\n     * test Field with only 'default' arguments, no positions specified.\n     */\n    @Test\n    public void testDefaultPositionImplied() {\n\n        field.addArg(createArg(\"default-position-0\"));\n        field.addArg(createArg(\"default-position-1\"));\n        field.addArg(createArg(\"default-position-2\"));\n\n        assertEquals(3, field.getArgs(\"required\").length, \"testDefaultPositionImplied(1) \");\n        assertEquals(\"default-position-0\", field.getArg(\"required\", 0).getKey(), \"testDefaultPositionImplied(2) \");\n        assertEquals(\"default-position-1\", field.getArg(\"required\", 1).getKey(), \"testDefaultPositionImplied(3) \");\n        assertEquals(\"default-position-2\", field.getArg(\"required\", 2).getKey(), \"testDefaultPositionImplied(4) \");\n\n    }\n\n    /**\n     * test Field with only 'default' arguments, some position specified.\n     */\n    @Test\n    public void testDefaultSomePositions() {\n\n        field.addArg(createArg(\"default-position-0\"));\n        field.addArg(createArg(\"default-position-2\", 2));\n        field.addArg(createArg(\"default-position-3\"));\n        field.addArg(createArg(\"default-position-1\", 1));\n\n        assertEquals(4, field.getArgs(\"required\").length, \"testDefaultSomePositions(1) \");\n        assertEquals(\"default-position-0\", field.getArg(\"required\", 0).getKey(), \"testDefaultSomePositions(2) \");\n        assertEquals(\"default-position-1\", field.getArg(\"required\", 1).getKey(), \"testDefaultSomePositions(3) \");\n        assertEquals(\"default-position-2\", field.getArg(\"required\", 2).getKey(), \"testDefaultSomePositions(4) \");\n        assertEquals(\"default-position-3\", field.getArg(\"required\", 3).getKey(), \"testDefaultSomePositions(5) \");\n\n    }\n\n    /**\n     * test Field with only 'default' arguments, positions specified.\n     */\n    @Test\n    public void testDefaultUsingPositions() {\n\n        field.addArg(createArg(\"default-position-1\", 1));\n        field.addArg(createArg(\"default-position-0\", 0));\n        field.addArg(createArg(\"default-position-2\", 2));\n\n        assertEquals(3, field.getArgs(\"required\").length, \"testDefaultUsingPositions(1) \");\n        assertEquals(\"default-position-0\", field.getArg(\"required\", 0).getKey(), \"testDefaultUsingPositions(2) \");\n        assertEquals(\"default-position-1\", field.getArg(\"required\", 1).getKey(), \"testDefaultUsingPositions(3) \");\n        assertEquals(\"default-position-2\", field.getArg(\"required\", 2).getKey(), \"testDefaultUsingPositions(4) \");\n\n    }\n\n    /**\n     * test Field with no arguments\n     */\n    @Test\n    public void testEmptyArgs() {\n\n        assertEquals(0, field.getArgs(\"required\").length, \"Empty Args(1) \");\n\n    }\n\n    /**\n     * test Field with a 'default' argument overriden without positions specified.\n     */\n    @Test\n    public void testOverridePositionImplied() {\n\n        field.addArg(createArg(\"default-position-0\"));\n        field.addArg(createArg(\"required-position-1\", \"required\"));\n        field.addArg(createArg(\"required-position-2\", \"required\"));\n        field.addArg(createArg(\"mask-position-1\", \"mask\"));\n\n        // use 'required' as name\n        assertEquals(3, field.getArgs(\"required\").length, \"testOverridePositionImplied(1) \");\n        assertEquals(\"default-position-0\", field.getArg(\"required\", 0).getKey(), \"testOverridePositionImplied(2) \");\n        assertEquals(\"required-position-1\", field.getArg(\"required\", 1).getKey(), \"testOverridePositionImplied(3) \");\n        assertEquals(\"required-position-2\", field.getArg(\"required\", 2).getKey(), \"testOverridePositionImplied(4) \");\n\n        // use 'mask' as name\n        assertEquals(3, field.getArgs(\"mask\").length, \"testOverridePositionImplied(5) \");\n        assertEquals(\"default-position-0\", field.getArg(\"mask\", 0).getKey(), \"testOverridePositionImplied(6) \");\n        assertEquals(\"mask-position-1\", field.getArg(\"mask\", 1).getKey(), \"testOverridePositionImplied(7) \");\n        assertNull(field.getArg(\"mask\", 2), \"testOverridePositionImplied(8) \");\n\n        // Get Defaults\n        assertEquals(\"default-position-0\", field.getArg(0).getKey(), \"testOverridePositionImplied(9) \");\n        assertNull(field.getArg(1), \"testOverridePositionImplied(10) \");\n        assertNull(field.getArg(2), \"testOverridePositionImplied(11) \");\n\n    }\n\n    /**\n     * test Field with a 'default' argument overriden with some positions specified\n     */\n    @Test\n    public void testOverrideSomePosition() {\n\n        field.addArg(createArg(\"default-position-0\"));\n        field.addArg(createArg(\"default-position-1\"));\n        field.addArg(createArg(\"default-position-2\"));\n        field.addArg(createArg(\"required-position-1\", \"required\", 1));\n        field.addArg(createArg(\"required-position-2\", \"required\"));\n        field.addArg(createArg(\"mask-position-3\", \"mask\"));\n\n        // use 'required' as name\n        assertEquals(4, field.getArgs(\"required\").length, \"testOverrideSomePosition(1) \");\n        assertEquals(\"default-position-0\", field.getArg(\"required\", 0).getKey(), \"testOverrideSomePosition(2) \");\n        assertEquals(\"required-position-1\", field.getArg(\"required\", 1).getKey(), \"testOverrideSomePosition(3) \");\n        assertEquals(\"required-position-2\", field.getArg(\"required\", 2).getKey(), \"testOverrideSomePosition(4) \");\n        assertNull(field.getArg(\"required\", 3), \"testOverrideSomePosition(5) \");\n\n        // use 'mask' as name\n        assertEquals(4, field.getArgs(\"mask\").length, \"testOverrideSomePosition(6) \");\n        assertEquals(\"default-position-0\", field.getArg(\"mask\", 0).getKey(), \"testOverrideSomePosition(7) \");\n        assertEquals(\"default-position-1\", field.getArg(\"mask\", 1).getKey(), \"testOverrideSomePosition(8) \");\n        assertEquals(\"default-position-2\", field.getArg(\"mask\", 2).getKey(), \"testOverrideSomePosition(9) \");\n        assertEquals(\"mask-position-3\", field.getArg(\"mask\", 3).getKey(), \"testOverrideSomePosition(10) \");\n\n        // Get Defaults\n        assertEquals(\"default-position-0\", field.getArg(0).getKey(), \"testOverrideSomePosition(11) \");\n        assertEquals(\"default-position-1\", field.getArg(1).getKey(), \"testOverrideSomePosition(12) \");\n        assertEquals(\"default-position-2\", field.getArg(2).getKey(), \"testOverrideSomePosition(13) \");\n        assertNull(field.getArg(3), \"testOverrideSomePosition(14) \");\n\n    }\n\n    /**\n     * test Field with a 'default' argument overriden using 'position' property\n     */\n    @Test\n    public void testOverrideUsingPositionA() {\n\n        field.addArg(createArg(\"default-position-0\"));\n        field.addArg(createArg(\"default-position-1\"));\n        field.addArg(createArg(\"default-position-2\"));\n        field.addArg(createArg(\"required-position-1\", \"required\", 1));\n\n        // use 'required' as name\n        assertEquals(3, field.getArgs(\"required\").length, \"testOverrideUsingPositionA(1) \");\n        assertEquals(\"required-position-1\", field.getArg(\"required\", 1).getKey(), \"testOverrideUsingPositionA(2) \");\n\n        // use 'mask' as name\n        assertEquals(3, field.getArgs(\"mask\").length, \"testOverrideUsingPositionA(3) \");\n        assertEquals(\"default-position-1\", field.getArg(\"mask\", 1).getKey(), \"testOverrideUsingPositionA(4) \");\n\n        // Get Default\n        assertEquals(\"default-position-1\", field.getArg(1).getKey(), \"testOverrideUsingPositionA(5) \");\n\n    }\n\n    /**\n     * test Field with a 'default' argument overriden using 'position' property\n     */\n    @Test\n    public void testOverrideUsingPositionB() {\n\n        field.addArg(createArg(\"required-position-3\", \"required\", 3));\n        field.addArg(createArg(\"required-position-1\", \"required\", 1));\n        field.addArg(createArg(\"default-position-0\"));\n        field.addArg(createArg(\"default-position-1\"));\n        field.addArg(createArg(\"default-position-2\"));\n\n        // use 'required' as name\n        assertEquals(4, field.getArgs(\"required\").length, \"testOverrideUsingPositionB(1) \");\n        assertEquals(\"default-position-0\", field.getArg(\"required\", 0).getKey(), \"testOverrideUsingPositionB(2) \");\n        assertEquals(\"required-position-1\", field.getArg(\"required\", 1).getKey(), \"testOverrideUsingPositionB(3) \");\n        assertEquals(\"default-position-2\", field.getArg(\"required\", 2).getKey(), \"testOverrideUsingPositionB(4) \");\n        assertEquals(\"required-position-3\", field.getArg(\"required\", 3).getKey(), \"testOverrideUsingPositionB(5) \");\n\n        // use 'mask' as name\n        assertEquals(4, field.getArgs(\"mask\").length, \"testOverrideUsingPositionB(6) \");\n        assertEquals(\"default-position-0\", field.getArg(\"mask\", 0).getKey(), \"testOverrideUsingPositionB(6) \");\n        assertEquals(\"default-position-1\", field.getArg(\"mask\", 1).getKey(), \"testOverrideUsingPositionB(7) \");\n        assertEquals(\"default-position-2\", field.getArg(\"mask\", 2).getKey(), \"testOverrideUsingPositionB(8) \");\n        assertNull(field.getArg(\"mask\", 3), \"testOverrideUsingPositionB(9) \");\n\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected Field field;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Field", "name": "field", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/CustomValidatorResourcesTest.java.CustomValidatorResourcesTest", "name": "CustomValidatorResourcesTest", "file_path": "src/test/java/org/apache/commons/validator/CustomValidatorResourcesTest.java", "superclasses": "", "methods": ["[void]testCustomResources()"], "method_uris": ["src/test/java/org/apache/commons/validator/CustomValidatorResourcesTest.java.CustomValidatorResourcesTest.[void]setUp()", "src/test/java/org/apache/commons/validator/CustomValidatorResourcesTest.java.CustomValidatorResourcesTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nTest custom ValidatorResources.\n", "original_string": "public class CustomValidatorResourcesTest {\n\n    /**\n     * Sets up.\n     */\n    @BeforeEach\n    protected void setUp() {\n    }\n\n    /**\n     * Tear Down\n     */\n    @AfterEach\n    protected void tearDown() {\n    }\n\n    /**\n     * Test creating a custom validator resources.\n     */\n    @Test\n    public void testCustomResources() {\n        // Load resources\n        InputStream in = null;\n        try {\n            in = this.getClass().getResourceAsStream(\"TestNumber-config.xml\");\n        } catch (final Exception e) {\n            fail(\"Error loading resources: \" + e);\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (final Exception ignore) {\n                // ignore\n            }\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/DoubleTest.java.DoubleTest", "name": "DoubleTest", "file_path": "src/test/java/org/apache/commons/validator/DoubleTest.java", "superclasses": "AbstractNumberTest", "methods": ["[void]testDouble()", "[void]testDoubleFailure()", "[void]testDoubleMax()", "[void]testDoubleMin()"], "method_uris": ["src/test/java/org/apache/commons/validator/DoubleTest.java.DoubleTest.[]DoubleTest()"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test for {@code double} validations.\n", "original_string": "public class DoubleTest extends AbstractNumberTest {\n\n    public DoubleTest() {\n        action = \"double\";\n        formKey = \"doubleForm\";\n    }\n\n    /**\n     * Tests the double validation.\n     */\n    @Test\n    public void testDouble() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(\"0\");\n\n        valueTest(info, true);\n    }\n\n    /**\n     * Tests the double validation failure.\n     */\n    @Test\n    public void testDoubleFailure() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n\n        valueTest(info, false);\n    }\n\n    /**\n     * Tests the double validation.\n     */\n    @Test\n    public void testDoubleMax() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Double.toString(Double.MAX_VALUE));\n\n        valueTest(info, true);\n    }\n\n    /**\n     * Tests the double validation.\n     */\n    @Test\n    public void testDoubleMin() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Double.toString(Double.MIN_VALUE));\n\n        valueTest(info, true);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/EmailTest.java.EmailTest", "name": "EmailTest", "file_path": "src/test/java/org/apache/commons/validator/EmailTest.java", "superclasses": "AbstractCommonTest", "methods": ["[void]testEmail()", "[void]testEmailAtTLD()", "[void]testEmailExtension()", "[void]testEmailLocalhost()", "[void]testEmailWithBogusCharacter()", "[void]testEmailWithCommas()", "[void]testEmailWithControlChars()", "[void]testEmailWithDash()", "[void]testEmailWithDotEnd()", "[void]testEmailWithNumericAddress()", "[void]testEmailWithSpaces()"], "method_uris": ["src/test/java/org/apache/commons/validator/EmailTest.java.EmailTest.[void]setUp()", "src/test/java/org/apache/commons/validator/EmailTest.java.EmailTest.[void]testEmailFromPerl()", "src/test/java/org/apache/commons/validator/EmailTest.java.EmailTest.[void]testEmailUserName()", "src/test/java/org/apache/commons/validator/EmailTest.java.EmailTest.[void]valueTest(ValueBean,boolean)"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test for e-mail validations.\n\n\n@deprecated to be removed when target class is removed\n", "original_string": "@Deprecated\npublic class EmailTest extends AbstractCommonTest {\n\n    /**\n     * The key used to retrieve the set of validation rules from the xml file.\n     */\n    protected static final String FORM_KEY = \"emailForm\";\n\n    /**\n     * The key used to retrieve the validator action.\n     */\n    protected static final String ACTION = \"email\";\n\n    /**\n     * These test values derive directly from RFC 822 & Mail::RFC822::Address & RFC::RFC822::Address perl test.pl For traceability don't combine these test\n     * values with other tests.\n     */\n    ResultPair[] testEmailFromPerl = { new ResultPair(\"abigail@example.com\", true), new ResultPair(\"abigail@example.com \", true),\n            new ResultPair(\" abigail@example.com\", true), new ResultPair(\"abigail @example.com \", true), new ResultPair(\"*@example.net\", true),\n            new ResultPair(\"\\\"\\\\\\\"\\\"@foo.bar\", true), new ResultPair(\"fred&barny@example.com\", true), new ResultPair(\"---@example.com\", true),\n            new ResultPair(\"foo-bar@example.net\", true), new ResultPair(\"\\\"127.0.0.1\\\"@[127.0.0.1]\", true),\n            new ResultPair(\"Abigail <abigail@example.com>\", true), new ResultPair(\"Abigail<abigail@example.com>\", true),\n            new ResultPair(\"Abigail<@a,@b,@c:abigail@example.com>\", true), new ResultPair(\"\\\"This is a phrase\\\"<abigail@example.com>\", true),\n            new ResultPair(\"\\\"Abigail \\\"<abigail@example.com>\", true), new ResultPair(\"\\\"Joe & J. Harvey\\\" <example @Org>\", true),\n            new ResultPair(\"Abigail <abigail @ example.com>\", true), new ResultPair(\"Abigail made this <  abigail   @   example  .    com    >\", true),\n            new ResultPair(\"Abigail(the bitch)@example.com\", true), new ResultPair(\"Abigail <abigail @ example . (bar) com >\", true),\n            new ResultPair(\"Abigail < (one)  abigail (two) @(three) example . (bar) com (quz) >\", true),\n            new ResultPair(\"Abigail (foo) (((baz)(nested) (comment)) ! ) < (one)  abigail (two) @(three) example . (bar) com (quz) >\", true),\n            new ResultPair(\"Abigail <abigail(fo\\\\(o)@example.com>\", true), new ResultPair(\"Abigail <abigail(fo\\\\)o)@example.com> \", true),\n            new ResultPair(\"(foo) abigail@example.com\", true), new ResultPair(\"abigail@example.com (foo)\", true),\n            new ResultPair(\"\\\"Abi\\\\\\\"gail\\\" <abigail@example.com>\", true), new ResultPair(\"abigail@[example.com]\", true),\n            new ResultPair(\"abigail@[exa\\\\[ple.com]\", true), new ResultPair(\"abigail@[exa\\\\]ple.com]\", true),\n            new ResultPair(\"\\\":sysmail\\\"@  Some-Group. Some-Org\", true), new ResultPair(\"Muhammed.(I am  the greatest) Ali @(the) Vegas.WBA\", true),\n            new ResultPair(\"mailbox.sub1.sub2@this-domain\", true), new ResultPair(\"sub-net.mailbox@sub-domain.domain\", true), new ResultPair(\"name:;\", true),\n            new ResultPair(\"':;\", true), new ResultPair(\"name:   ;\", true), new ResultPair(\"Alfred Neuman <Neuman@BBN-TENEXA>\", true),\n            new ResultPair(\"Neuman@BBN-TENEXA\", true), new ResultPair(\"\\\"George, Ted\\\" <Shared@Group.Arpanet>\", true),\n            new ResultPair(\"Wilt . (the  Stilt) Chamberlain@NBA.US\", true), new ResultPair(\"Cruisers:  Port@Portugal, Jones@SEA;\", true),\n            new ResultPair(\"$@[]\", true), new ResultPair(\"*()@[]\", true), new ResultPair(\"\\\"quoted ( brackets\\\" ( a comment )@example.com\", true),\n            new ResultPair(\"\\\"Joe & J. Harvey\\\"\\\\x0D\\\\x0A     <ddd\\\\@ Org>\", true), new ResultPair(\"\\\"Joe &\\\\x0D\\\\x0A J. Harvey\\\" <ddd \\\\@ Org>\", true),\n            new ResultPair(\n                    \"Gourmets:  Pompous Person <WhoZiWhatZit\\\\@Cordon-Bleu>,\\\\x0D\\\\x0A\" + \"        Childs\\\\@WGBH.Boston, \\\"Galloping Gourmet\\\"\\\\@\\\\x0D\\\\x0A\"\n                            + \"        ANT.Down-Under (Australian National Television),\\\\x0D\\\\x0A\" + \"        Cheapie\\\\@Discount-Liquors;\",\n                    true),\n            new ResultPair(\"   Just a string\", false), new ResultPair(\"string\", false), new ResultPair(\"(comment)\", false),\n            new ResultPair(\"()@example.com\", false), new ResultPair(\"fred(&)barny@example.com\", false), new ResultPair(\"fred\\\\ barny@example.com\", false),\n            new ResultPair(\"Abigail <abi gail @ example.com>\", false), new ResultPair(\"Abigail <abigail(fo(o)@example.com>\", false),\n            new ResultPair(\"Abigail <abigail(fo) o)@example.com>\", false), new ResultPair(\"\\\"Abi\\\"gail\\\" <abigail@example.com>\", false),\n            new ResultPair(\"abigail@[exa]ple.com]\", false), new ResultPair(\"abigail@[exa[ple.com]\", false), new ResultPair(\"abigail@[exaple].com]\", false),\n            new ResultPair(\"abigail@\", false), new ResultPair(\"@example.com\", false),\n            new ResultPair(\"phrase: abigail@example.com abigail@example.com ;\", false), new ResultPair(\"invalid\ufffdchar@example.com\", false) };\n\n    /**\n     * Load {@code ValidatorResources} from validator-regexp.xml.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException, SAXException {\n        loadResources(\"EmailTest-config.xml\");\n    }\n\n    /**\n     * Tests the e-mail validation.\n     */\n    @Test\n    public void testEmail() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n\n        info.setValue(\"jsmith@apache.org\");\n        valueTest(info, true);\n    }\n\n    /**\n     * Tests the e-mail validation with a user at a TLD\n     */\n    @Test\n    public void testEmailAtTLD() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n\n        info.setValue(\"m@de\");\n        valueTest(info, false);\n\n        final org.apache.commons.validator.routines.EmailValidator validator = org.apache.commons.validator.routines.EmailValidator.getInstance(true, true);\n        final boolean result = validator.isValid(\"m@de\");\n        assertTrue(result, \"Result should have been true\");\n\n    }\n\n    /**\n     * Tests the e-mail validation.\n     */\n    @Test\n    public void testEmailExtension() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n\n        info.setValue(\"jsmith@apache.org\");\n        valueTest(info, true);\n\n        info.setValue(\"jsmith@apache.com\");\n        valueTest(info, true);\n\n        info.setValue(\"jsmith@apache.net\");\n        valueTest(info, true);\n\n        info.setValue(\"jsmith@apache.info\");\n        valueTest(info, true);\n\n        info.setValue(\"jsmith@apache.\");\n        valueTest(info, false);\n\n        info.setValue(\"jsmith@apache.c\");\n        valueTest(info, false);\n\n        info.setValue(\"someone@yahoo.museum\");\n        valueTest(info, true);\n\n        info.setValue(\"someone@yahoo.mu-seum\");\n        valueTest(info, false);\n    }\n\n    /**\n     * Write this test based on perl Mail::RFC822::Address which takes its example email address directly from RFC822\n     *\n     * @throws ValidatorException\n     *\n     *                            FIXME This test fails so disable it with a leading _ for 1.1.4 release. The real solution is to fix the email parsing.\n     */\n    @Ignore\n    public void testEmailFromPerl() throws ValidatorException {\n        final ValueBean info = new ValueBean();\n        for (final ResultPair element : testEmailFromPerl) {\n            info.setValue(element.item);\n            valueTest(info, element.valid);\n        }\n    }\n\n    /**\n     * Test that @localhost and @localhost.localdomain addresses aren't declared valid by default\n     */\n    @Test\n    public void testEmailLocalhost() throws ValidatorException {\n        final ValueBean info = new ValueBean();\n        info.setValue(\"joe@localhost\");\n        valueTest(info, false);\n        info.setValue(\"joe@localhost.localdomain\");\n        valueTest(info, false);\n    }\n\n    /**\n     * Write this test according to parts of RFC, as opposed to the type of character that is being tested.\n     *\n     * <p>\n     * <b>FIXME</b>: This test fails so disable it with a leading _ for 1.1.4 release. The real solution is to fix the email parsing.\n     *\n     * @throws ValidatorException\n     */\n    @Ignore\n    public void testEmailUserName() throws ValidatorException {\n        final ValueBean info = new ValueBean();\n        info.setValue(\"joe1blow@apache.org\");\n        valueTest(info, true);\n        info.setValue(\"joe$blow@apache.org\");\n        valueTest(info, true);\n        info.setValue(\"joe-@apache.org\");\n        valueTest(info, true);\n        info.setValue(\"joe_@apache.org\");\n        valueTest(info, true);\n\n        // UnQuoted Special characters are invalid\n\n        info.setValue(\"joe.@apache.org\");\n        valueTest(info, false);\n        info.setValue(\"joe+@apache.org\");\n        valueTest(info, false);\n        info.setValue(\"joe!@apache.org\");\n        valueTest(info, false);\n        info.setValue(\"joe*@apache.org\");\n        valueTest(info, false);\n        info.setValue(\"joe'@apache.org\");\n        valueTest(info, false);\n        info.setValue(\"joe(@apache.org\");\n        valueTest(info, false);\n        info.setValue(\"joe)@apache.org\");\n        valueTest(info, false);\n        info.setValue(\"joe,@apache.org\");\n        valueTest(info, false);\n        info.setValue(\"joe%45@apache.org\");\n        valueTest(info, false);\n        info.setValue(\"joe;@apache.org\");\n        valueTest(info, false);\n        info.setValue(\"joe?@apache.org\");\n        valueTest(info, false);\n        info.setValue(\"joe&@apache.org\");\n        valueTest(info, false);\n        info.setValue(\"joe=@apache.org\");\n        valueTest(info, false);\n\n        // Quoted Special characters are valid\n        info.setValue(\"\\\"joe.\\\"@apache.org\");\n        valueTest(info, true);\n        info.setValue(\"\\\"joe+\\\"@apache.org\");\n        valueTest(info, true);\n        info.setValue(\"\\\"joe!\\\"@apache.org\");\n        valueTest(info, true);\n        info.setValue(\"\\\"joe*\\\"@apache.org\");\n        valueTest(info, true);\n        info.setValue(\"\\\"joe'\\\"@apache.org\");\n        valueTest(info, true);\n        info.setValue(\"\\\"joe(\\\"@apache.org\");\n        valueTest(info, true);\n        info.setValue(\"\\\"joe)\\\"@apache.org\");\n        valueTest(info, true);\n        info.setValue(\"\\\"joe,\\\"@apache.org\");\n        valueTest(info, true);\n        info.setValue(\"\\\"joe%45\\\"@apache.org\");\n        valueTest(info, true);\n        info.setValue(\"\\\"joe;\\\"@apache.org\");\n        valueTest(info, true);\n        info.setValue(\"\\\"joe?\\\"@apache.org\");\n        valueTest(info, true);\n        info.setValue(\"\\\"joe&\\\"@apache.org\");\n        valueTest(info, true);\n        info.setValue(\"\\\"joe=\\\"@apache.org\");\n        valueTest(info, true);\n\n    }\n\n    /**\n     * Tests the e-mail validation with an RCS-noncompliant character in the address.\n     */\n    @Test\n    public void testEmailWithBogusCharacter() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n\n        info.setValue(\"andy.noble@\\u008fdata-workshop.com\");\n        valueTest(info, false);\n\n        // The ' character is valid in an email username.\n        info.setValue(\"andy.o'reilly@data-workshop.com\");\n        valueTest(info, true);\n\n        // But not in the domain name.\n        info.setValue(\"andy@o'reilly.data-workshop.com\");\n        valueTest(info, false);\n\n        info.setValue(\"foo+bar@i.am.not.in.us.example.com\");\n        valueTest(info, true);\n    }\n\n    /**\n     * Tests the email validation with commas.\n     */\n    @Test\n    public void testEmailWithCommas() throws ValidatorException {\n        final ValueBean info = new ValueBean();\n        info.setValue(\"joeblow@apa,che.org\");\n        valueTest(info, false);\n        info.setValue(\"joeblow@apache.o,rg\");\n        valueTest(info, false);\n        info.setValue(\"joeblow@apache,org\");\n        valueTest(info, false);\n\n    }\n\n    /**\n     * Tests the email validation with ASCII control characters. (i.e. ASCII chars 0 - 31 and 127)\n     */\n    @Test\n    public void testEmailWithControlChars() {\n        final EmailValidator validator = new EmailValidator();\n        for (char c = 0; c < 32; c++) {\n            assertFalse(validator.isValid(\"foo\" + c + \"bar@domain.com\"), \"Test control char \" + (int) c);\n        }\n        assertFalse(validator.isValid(\"foo\" + (char) 127 + \"bar@domain.com\"), \"Test control char 127\");\n    }\n\n    /**\n     * <p>\n     * Tests the e-mail validation with a dash in the address.\n     * </p>\n     */\n    @Test\n    public void testEmailWithDash() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n\n        info.setValue(\"andy.noble@data-workshop.com\");\n        valueTest(info, true);\n\n        info.setValue(\"andy-noble@data-workshop.-com\");\n        valueTest(info, false);\n        info.setValue(\"andy-noble@data-workshop.c-om\");\n        valueTest(info, false);\n        info.setValue(\"andy-noble@data-workshop.co-m\");\n        valueTest(info, false);\n\n    }\n\n    /**\n     * Tests the e-mail validation with a dot at the end of the address.\n     */\n    @Test\n    public void testEmailWithDotEnd() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n\n        info.setValue(\"andy.noble@data-workshop.com.\");\n        valueTest(info, false);\n\n    }\n\n    /**\n     * Tests the email validation with numeric domains.\n     */\n    @Test\n    public void testEmailWithNumericAddress() throws ValidatorException {\n        final ValueBean info = new ValueBean();\n        info.setValue(\"someone@[216.109.118.76]\");\n        valueTest(info, true);\n        info.setValue(\"someone@yahoo.com\");\n        valueTest(info, true);\n    }\n\n    /**\n     * Tests the email validation with spaces.\n     */\n    @Test\n    public void testEmailWithSpaces() throws ValidatorException {\n        final ValueBean info = new ValueBean();\n        info.setValue(\"joeblow @apache.org\");\n        valueTest(info, false);\n        info.setValue(\"joeblow@ apache.org\");\n        valueTest(info, false);\n        info.setValue(\" joeblow@apache.org\");\n        valueTest(info, false);\n        info.setValue(\"joeblow@apache.org \");\n        valueTest(info, false);\n        info.setValue(\"joe blow@apache.org \");\n        valueTest(info, false);\n        info.setValue(\"joeblow@apa che.org \");\n        valueTest(info, false);\n        info.setValue(\"\\\"joe blow\\\"@apache.org\");\n        valueTest(info, true);\n\n    }\n\n    /**\n     * Utlity class to run a test on a value.\n     *\n     * @param info   Value to run test on.\n     * @param passed Whether or not the test is expected to pass.\n     */\n    private void valueTest(final ValueBean info, final boolean passed) throws ValidatorException {\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, info);\n\n        // Get results of the validation.\n        // throws ValidatorException,\n        // but we aren't catching for testing\n        // since no validation methods we use\n        // throw this\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult result = results.getValidatorResult(\"value\");\n\n        assertNotNull(result, () -> ACTION + \" value ValidatorResult should not be null.\");\n        assertTrue(result.containsAction(ACTION), () -> \"Value \" + info.getValue() + \" ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(passed ? result.isValid(ACTION) : !result.isValid(ACTION),\n                () -> \"Value \" + info.getValue() + \"ValidatorResult for the '\" + ACTION + \"' action should have \" + (passed ? \"passed\" : \"failed\") + \".\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final String FORM_KEY = \"emailForm\";", "docstring": "\nThe key used to retrieve the set of validation rules from the xml file.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "FORM_KEY = \"emailForm\"", "syntax_pass": true}, {"attribute_expression": "protected static final String ACTION = \"email\";", "docstring": "\nThe key used to retrieve the validator action.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "ACTION = \"email\"", "syntax_pass": true}, {"attribute_expression": "ResultPair[] testEmailFromPerl = { new ResultPair(\"abigail@example.com\", true), new ResultPair(\"abigail@example.com \", true),\n            new ResultPair(\" abigail@example.com\", true), new ResultPair(\"abigail @example.com \", true), new ResultPair(\"*@example.net\", true),\n            new ResultPair(\"\\\"\\\\\\\"\\\"@foo.bar\", true), new ResultPair(\"fred&barny@example.com\", true), new ResultPair(\"---@example.com\", true),\n            new ResultPair(\"foo-bar@example.net\", true), new ResultPair(\"\\\"127.0.0.1\\\"@[127.0.0.1]\", true),\n            new ResultPair(\"Abigail <abigail@example.com>\", true), new ResultPair(\"Abigail<abigail@example.com>\", true),\n            new ResultPair(\"Abigail<@a,@b,@c:abigail@example.com>\", true), new ResultPair(\"\\\"This is a phrase\\\"<abigail@example.com>\", true),\n            new ResultPair(\"\\\"Abigail \\\"<abigail@example.com>\", true), new ResultPair(\"\\\"Joe & J. Harvey\\\" <example @Org>\", true),\n            new ResultPair(\"Abigail <abigail @ example.com>\", true), new ResultPair(\"Abigail made this <  abigail   @   example  .    com    >\", true),\n            new ResultPair(\"Abigail(the bitch)@example.com\", true), new ResultPair(\"Abigail <abigail @ example . (bar) com >\", true),\n            new ResultPair(\"Abigail < (one)  abigail (two) @(three) example . (bar) com (quz) >\", true),\n            new ResultPair(\"Abigail (foo) (((baz)(nested) (comment)) ! ) < (one)  abigail (two) @(three) example . (bar) com (quz) >\", true),\n            new ResultPair(\"Abigail <abigail(fo\\\\(o)@example.com>\", true), new ResultPair(\"Abigail <abigail(fo\\\\)o)@example.com> \", true),\n            new ResultPair(\"(foo) abigail@example.com\", true), new ResultPair(\"abigail@example.com (foo)\", true),\n            new ResultPair(\"\\\"Abi\\\\\\\"gail\\\" <abigail@example.com>\", true), new ResultPair(\"abigail@[example.com]\", true),\n            new ResultPair(\"abigail@[exa\\\\[ple.com]\", true), new ResultPair(\"abigail@[exa\\\\]ple.com]\", true),\n            new ResultPair(\"\\\":sysmail\\\"@  Some-Group. Some-Org\", true), new ResultPair(\"Muhammed.(I am  the greatest) Ali @(the) Vegas.WBA\", true),\n            new ResultPair(\"mailbox.sub1.sub2@this-domain\", true), new ResultPair(\"sub-net.mailbox@sub-domain.domain\", true), new ResultPair(\"name:;\", true),\n            new ResultPair(\"':;\", true), new ResultPair(\"name:   ;\", true), new ResultPair(\"Alfred Neuman <Neuman@BBN-TENEXA>\", true),\n            new ResultPair(\"Neuman@BBN-TENEXA\", true), new ResultPair(\"\\\"George, Ted\\\" <Shared@Group.Arpanet>\", true),\n            new ResultPair(\"Wilt . (the  Stilt) Chamberlain@NBA.US\", true), new ResultPair(\"Cruisers:  Port@Portugal, Jones@SEA;\", true),\n            new ResultPair(\"$@[]\", true), new ResultPair(\"*()@[]\", true), new ResultPair(\"\\\"quoted ( brackets\\\" ( a comment )@example.com\", true),\n            new ResultPair(\"\\\"Joe & J. Harvey\\\"\\\\x0D\\\\x0A     <ddd\\\\@ Org>\", true), new ResultPair(\"\\\"Joe &\\\\x0D\\\\x0A J. Harvey\\\" <ddd \\\\@ Org>\", true),\n            new ResultPair(\n                    \"Gourmets:  Pompous Person <WhoZiWhatZit\\\\@Cordon-Bleu>,\\\\x0D\\\\x0A\" + \"        Childs\\\\@WGBH.Boston, \\\"Galloping Gourmet\\\"\\\\@\\\\x0D\\\\x0A\"\n                            + \"        ANT.Down-Under (Australian National Television),\\\\x0D\\\\x0A\" + \"        Cheapie\\\\@Discount-Liquors;\",\n                    true),\n            new ResultPair(\"   Just a string\", false), new ResultPair(\"string\", false), new ResultPair(\"(comment)\", false),\n            new ResultPair(\"()@example.com\", false), new ResultPair(\"fred(&)barny@example.com\", false), new ResultPair(\"fred\\\\ barny@example.com\", false),\n            new ResultPair(\"Abigail <abi gail @ example.com>\", false), new ResultPair(\"Abigail <abigail(fo(o)@example.com>\", false),\n            new ResultPair(\"Abigail <abigail(fo) o)@example.com>\", false), new ResultPair(\"\\\"Abi\\\"gail\\\" <abigail@example.com>\", false),\n            new ResultPair(\"abigail@[exa]ple.com]\", false), new ResultPair(\"abigail@[exa[ple.com]\", false), new ResultPair(\"abigail@[exaple].com]\", false),\n            new ResultPair(\"abigail@\", false), new ResultPair(\"@example.com\", false),\n            new ResultPair(\"phrase: abigail@example.com abigail@example.com ;\", false), new ResultPair(\"invalid\ufffdchar@example.com\", false) };", "docstring": "\nThese test values derive directly from RFC 822 & Mail::RFC822::Address & RFC::RFC822::Address perl test.pl For traceability don't combine these test\nvalues with other tests.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ResultPair[]", "name": "testEmailFromPerl = { new ResultPair(\"abigail@example.com\", true), new ResultPair(\"abigail@example.com \", true),\n            new ResultPair(\" abigail@example.com\", true), new ResultPair(\"abigail @example.com \", true), new ResultPair(\"*@example.net\", true),\n            new ResultPair(\"\\\"\\\\\\\"\\\"@foo.bar\", true), new ResultPair(\"fred&barny@example.com\", true), new ResultPair(\"---@example.com\", true),\n            new ResultPair(\"foo-bar@example.net\", true), new ResultPair(\"\\\"127.0.0.1\\\"@[127.0.0.1]\", true),\n            new ResultPair(\"Abigail <abigail@example.com>\", true), new ResultPair(\"Abigail<abigail@example.com>\", true),\n            new ResultPair(\"Abigail<@a,@b,@c:abigail@example.com>\", true), new ResultPair(\"\\\"This is a phrase\\\"<abigail@example.com>\", true),\n            new ResultPair(\"\\\"Abigail \\\"<abigail@example.com>\", true), new ResultPair(\"\\\"Joe & J. Harvey\\\" <example @Org>\", true),\n            new ResultPair(\"Abigail <abigail @ example.com>\", true), new ResultPair(\"Abigail made this <  abigail   @   example  .    com    >\", true),\n            new ResultPair(\"Abigail(the bitch)@example.com\", true), new ResultPair(\"Abigail <abigail @ example . (bar) com >\", true),\n            new ResultPair(\"Abigail < (one)  abigail (two) @(three) example . (bar) com (quz) >\", true),\n            new ResultPair(\"Abigail (foo) (((baz)(nested) (comment)) ! ) < (one)  abigail (two) @(three) example . (bar) com (quz) >\", true),\n            new ResultPair(\"Abigail <abigail(fo\\\\(o)@example.com>\", true), new ResultPair(\"Abigail <abigail(fo\\\\)o)@example.com> \", true),\n            new ResultPair(\"(foo) abigail@example.com\", true), new ResultPair(\"abigail@example.com (foo)\", true),\n            new ResultPair(\"\\\"Abi\\\\\\\"gail\\\" <abigail@example.com>\", true), new ResultPair(\"abigail@[example.com]\", true),\n            new ResultPair(\"abigail@[exa\\\\[ple.com]\", true), new ResultPair(\"abigail@[exa\\\\]ple.com]\", true),\n            new ResultPair(\"\\\":sysmail\\\"@  Some-Group. Some-Org\", true), new ResultPair(\"Muhammed.(I am  the greatest) Ali @(the) Vegas.WBA\", true),\n            new ResultPair(\"mailbox.sub1.sub2@this-domain\", true), new ResultPair(\"sub-net.mailbox@sub-domain.domain\", true), new ResultPair(\"name:;\", true),\n            new ResultPair(\"':;\", true), new ResultPair(\"name:   ;\", true), new ResultPair(\"Alfred Neuman <Neuman@BBN-TENEXA>\", true),\n            new ResultPair(\"Neuman@BBN-TENEXA\", true), new ResultPair(\"\\\"George, Ted\\\" <Shared@Group.Arpanet>\", true),\n            new ResultPair(\"Wilt . (the  Stilt) Chamberlain@NBA.US\", true), new ResultPair(\"Cruisers:  Port@Portugal, Jones@SEA;\", true),\n            new ResultPair(\"$@[]\", true), new ResultPair(\"*()@[]\", true), new ResultPair(\"\\\"quoted ( brackets\\\" ( a comment )@example.com\", true),\n            new ResultPair(\"\\\"Joe & J. Harvey\\\"\\\\x0D\\\\x0A     <ddd\\\\@ Org>\", true), new ResultPair(\"\\\"Joe &\\\\x0D\\\\x0A J. Harvey\\\" <ddd \\\\@ Org>\", true),\n            new ResultPair(\n                    \"Gourmets:  Pompous Person <WhoZiWhatZit\\\\@Cordon-Bleu>,\\\\x0D\\\\x0A\" + \"        Childs\\\\@WGBH.Boston, \\\"Galloping Gourmet\\\"\\\\@\\\\x0D\\\\x0A\"\n                            + \"        ANT.Down-Under (Australian National Television),\\\\x0D\\\\x0A\" + \"        Cheapie\\\\@Discount-Liquors;\",\n                    true),\n            new ResultPair(\"   Just a string\", false), new ResultPair(\"string\", false), new ResultPair(\"(comment)\", false),\n            new ResultPair(\"()@example.com\", false), new ResultPair(\"fred(&)barny@example.com\", false), new ResultPair(\"fred\\\\ barny@example.com\", false),\n            new ResultPair(\"Abigail <abi gail @ example.com>\", false), new ResultPair(\"Abigail <abigail(fo(o)@example.com>\", false),\n            new ResultPair(\"Abigail <abigail(fo) o)@example.com>\", false), new ResultPair(\"\\\"Abi\\\"gail\\\" <abigail@example.com>\", false),\n            new ResultPair(\"abigail@[exa]ple.com]\", false), new ResultPair(\"abigail@[exa[ple.com]\", false), new ResultPair(\"abigail@[exaple].com]\", false),\n            new ResultPair(\"abigail@\", false), new ResultPair(\"@example.com\", false),\n            new ResultPair(\"phrase: abigail@example.com abigail@example.com ;\", false), new ResultPair(\"invalid\ufffdchar@example.com\", false) }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/ShortTest.java.ShortTest", "name": "ShortTest", "file_path": "src/test/java/org/apache/commons/validator/ShortTest.java", "superclasses": "AbstractNumberTest", "methods": ["[void]testShortBeyondMax()", "[void]testShortBeyondMin()", "[void]testShortMax()", "[void]testShortMin()"], "method_uris": ["src/test/java/org/apache/commons/validator/ShortTest.java.ShortTest.[]ShortTest()"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test for {@code short} validations.\n", "original_string": "public class ShortTest extends AbstractNumberTest {\n\n    public ShortTest() {\n        formKey = \"shortForm\";\n        action = \"short\";\n    }\n\n    /**\n     * Tests the short validation failure.\n     */\n    @Test\n    public void testShortBeyondMax() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Short.MAX_VALUE + \"1\");\n\n        valueTest(info, false);\n    }\n\n    /**\n     * Tests the short validation failure.\n     */\n    @Test\n    public void testShortBeyondMin() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Short.MIN_VALUE + \"1\");\n\n        valueTest(info, false);\n    }\n\n    /**\n     * Tests the short validation.\n     */\n    @Test\n    public void testShortMax() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Short.toString(Short.MAX_VALUE));\n\n        valueTest(info, true);\n    }\n\n    /**\n     * Tests the short validation.\n     */\n    @Test\n    public void testShortMin() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Short.toString(Short.MIN_VALUE));\n\n        valueTest(info, true);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/VarTest.java.VarTest", "name": "VarTest", "file_path": "src/test/java/org/apache/commons/validator/VarTest.java", "superclasses": "AbstractCommonTest", "methods": ["[void]testVars()"], "method_uris": ["src/test/java/org/apache/commons/validator/VarTest.java.VarTest.[void]setUp()", "src/test/java/org/apache/commons/validator/VarTest.java.VarTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nTest that the new Var attributes and the digester rule changes work.\n", "original_string": "public class VarTest extends AbstractCommonTest {\n\n    /**\n     * The key used to retrieve the set of validation rules from the xml file.\n     */\n    protected static final String FORM_KEY = \"testForm\";\n\n    /**\n     * The key used to retrieve the validator action.\n     */\n    protected static final String ACTION = \"byte\";\n\n    /**\n     * Load {@code ValidatorResources} from validator-multipletest.xml.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException, SAXException {\n        // Load resources\n        loadResources(\"VarTest-config.xml\");\n    }\n\n    @AfterEach\n    protected void tearDown() {\n    }\n\n    /**\n     * With nothing provided, we should fail both because both are required.\n     */\n    @Test\n    public void testVars() {\n\n        final Form form = resources.getForm(Locale.getDefault(), FORM_KEY);\n\n        // Get field 1\n        final Field field1 = form.getField(\"field-1\");\n        assertNotNull(field1, \"field-1 is null.\");\n        assertEquals(\"field-1\", field1.getProperty(), \"field-1 property is wrong\");\n\n        // Get var-1-1\n        final Var var11 = field1.getVar(\"var-1-1\");\n        assertNotNull(var11, \"var-1-1 is null.\");\n        assertEquals(\"var-1-1\", var11.getName(), \"var-1-1 name is wrong\");\n        assertEquals(\"value-1-1\", var11.getValue(), \"var-1-1 value is wrong\");\n        assertEquals(\"jstype-1-1\", var11.getJsType(), \"var-1-1 jstype is wrong\");\n        assertFalse(var11.isResource(), \"var-1-1 resource is true\");\n        assertNull(var11.getBundle(), \"var-1-1 bundle is not null.\");\n\n        // Get field 2\n        final Field field2 = form.getField(\"field-2\");\n        assertNotNull(field2, \"field-2 is null.\");\n        assertEquals(\"field-2\", field2.getProperty(), \"field-2 property is wrong\");\n\n        // Get var-2-1\n        final Var var21 = field2.getVar(\"var-2-1\");\n        assertNotNull(var21, \"var-2-1 is null.\");\n        assertEquals(\"var-2-1\", var21.getName(), \"var-2-1 name is wrong\");\n        assertEquals(\"value-2-1\", var21.getValue(), \"var-2-1 value is wrong\");\n        assertEquals(\"jstype-2-1\", var21.getJsType(), \"var-2-1 jstype is wrong\");\n        assertTrue(var21.isResource(), \"var-2-1 resource is false\");\n        assertEquals(var21.getBundle(), \"bundle-2-1\", \"var-2-1 bundle is wrong\");\n\n        // Get var-2-2\n        final Var var22 = field2.getVar(\"var-2-2\");\n        assertNotNull(var22, \"var-2-2 is null.\");\n        assertEquals(var22.getName(), \"var-2-2\", \"var-2-2 name is wrong\");\n        assertEquals(var22.getValue(), \"value-2-2\", \"var-2-2 value is wrong\");\n        assertNull(var22.getJsType(), \"var-2-2 jstype is not null\");\n        assertFalse(var22.isResource(), \"var-2-2 resource is true\");\n        assertEquals(var22.getBundle(), \"bundle-2-2\", \"var-2-2 bundle is wrong\");\n\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final String FORM_KEY = \"testForm\";", "docstring": "\nThe key used to retrieve the set of validation rules from the xml file.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "FORM_KEY = \"testForm\"", "syntax_pass": true}, {"attribute_expression": "protected static final String ACTION = \"byte\";", "docstring": "\nThe key used to retrieve the validator action.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "ACTION = \"byte\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/Var_cloneTest.java.Var_cloneTest", "name": "Var_cloneTest", "file_path": "src/test/java/org/apache/commons/validator/Var_cloneTest.java", "superclasses": "", "methods": ["[void]testCloneWithAllFieldsSet()", "[void]testCloneWithDefaultFields()", "[void]testCloneWithPartialFieldsSet()"], "method_uris": ["src/test/java/org/apache/commons/validator/Var_cloneTest.java.Var_cloneTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Var_cloneTest {\n\n    private Var var;\n\n    @BeforeEach\n    public void setUp() {\n        var = new Var();\n    }\n\n    @Test\n    public void testCloneWithAllFieldsSet() {\n        var.setName(\"testName\");\n        var.setValue(\"testValue\");\n        var.setJsType(\"string\");\n        var.setResource(true);\n        var.setBundle(\"testBundle\");\n\n        Var clonedVar = (Var) var.clone();\n\n        assertNotNull(clonedVar);\n        assertEquals(\"testName\", clonedVar.getName());\n        assertEquals(\"testValue\", clonedVar.getValue());\n        assertEquals(\"string\", clonedVar.getJsType());\n        assertTrue(clonedVar.isResource());\n        assertEquals(\"testBundle\", clonedVar.getBundle());\n    }\n\n    @Test\n    public void testCloneWithDefaultFields() {\n        Var clonedVar = (Var) var.clone();\n\n        assertNotNull(clonedVar);\n        assertEquals(null, clonedVar.getName());\n        assertEquals(null, clonedVar.getValue());\n        assertEquals(null, clonedVar.getJsType());\n        assertFalse(clonedVar.isResource());\n        assertEquals(null, clonedVar.getBundle());\n    }\n\n    @Test\n    public void testCloneWithPartialFieldsSet() {\n        var.setName(\"testName\");\n        var.setValue(\"testValue\");\n\n        Var clonedVar = (Var) var.clone();\n\n        assertNotNull(clonedVar);\n        assertEquals(\"testName\", clonedVar.getName());\n        assertEquals(\"testValue\", clonedVar.getValue());\n        assertEquals(null, clonedVar.getJsType());\n        assertFalse(clonedVar.isResource());\n        assertEquals(null, clonedVar.getBundle());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Var var;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Var", "name": "var", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/UrlTest.java.UrlTest", "name": "UrlTest", "file_path": "src/test/java/org/apache/commons/validator/UrlTest.java", "superclasses": "", "methods": ["[void]testIsValid()", "[void]testIsValidScheme()", "[void]testValidateUrl()", "[void]testValidator202()", "[void]testValidator204()"], "method_uris": ["src/test/java/org/apache/commons/validator/UrlTest.java.UrlTest.[boolean]incrementTestPartsIndex(int[],Object[])", "src/test/java/org/apache/commons/validator/UrlTest.java.UrlTest.[void]main(String[])", "src/test/java/org/apache/commons/validator/UrlTest.java.UrlTest.[void]setUp()", "src/test/java/org/apache/commons/validator/UrlTest.java.UrlTest.[void]testIsValid(Object[],int)", "src/test/java/org/apache/commons/validator/UrlTest.java.UrlTest.[String]testPartsIndextoString()"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test for url validations.\n\n@deprecated to be removed when org.apache.commons.validator.UrlValidator is removed\n", "original_string": "@Deprecated\npublic class UrlTest {\n\n    static boolean incrementTestPartsIndex(final int[] testPartsIndex, final Object[] testParts) {\n        boolean carry = true; // add 1 to lowest order part.\n        boolean maxIndex = true;\n        for (int testPartsIndexIndex = testPartsIndex.length - 1; testPartsIndexIndex >= 0; --testPartsIndexIndex) {\n            int index = testPartsIndex[testPartsIndexIndex];\n            final ResultPair[] part = (ResultPair[]) testParts[testPartsIndexIndex];\n            if (carry) {\n                if (index < part.length - 1) {\n                    index++;\n                    testPartsIndex[testPartsIndexIndex] = index;\n                    carry = false;\n                } else {\n                    testPartsIndex[testPartsIndexIndex] = 0;\n                    carry = true;\n                }\n            }\n            maxIndex &= index == part.length - 1;\n        }\n\n        return !maxIndex;\n    }\n\n    /**\n     * Only used to debug the unit tests.\n     *\n     * @param argv\n     */\n    public static void main(final String[] argv) {\n\n        final UrlTest fct = new UrlTest();\n        fct.setUp();\n        fct.testIsValid();\n        fct.testIsValidScheme();\n    }\n\n    private final boolean printStatus = false;\n\n    private final boolean printIndex = false; // print index that indicates current scheme,host,port,path, query test were using.\n\n    /**\n     * The data given below approximates the 4 parts of a URL <scheme>://<authority><path>?<query> except that the port number is broken out of authority to\n     * increase the number of permutations. A complete URL is composed of a scheme+authority+port+path+query, all of which must be individually valid for the\n     * entire URL to be considered valid.\n     */\n    ResultPair[] testUrlScheme = { new ResultPair(\"http://\", true), new ResultPair(\"ftp://\", true), new ResultPair(\"h3t://\", true),\n            new ResultPair(\"3ht://\", false), new ResultPair(\"http:/\", false), new ResultPair(\"http:\", false), new ResultPair(\"http/\", false),\n            new ResultPair(\"://\", false), new ResultPair(\"\", true) };\n\n    ResultPair[] testUrlAuthority = { new ResultPair(\"www.google.com\", true), new ResultPair(\"go.com\", true), new ResultPair(\"go.au\", true),\n            new ResultPair(\"0.0.0.0\", true), new ResultPair(\"255.255.255.255\", true), new ResultPair(\"256.256.256.256\", false), new ResultPair(\"255.com\", true),\n            new ResultPair(\"1.2.3.4.5\", false), new ResultPair(\"1.2.3.4.\", false), new ResultPair(\"1.2.3\", false), new ResultPair(\".1.2.3.4\", false),\n            new ResultPair(\"go.a\", false), new ResultPair(\"go.a1a\", true), new ResultPair(\"go.1aa\", false), new ResultPair(\"aaa.\", false),\n            new ResultPair(\".aaa\", false), new ResultPair(\"aaa\", false), new ResultPair(\"\", false) };\n\n    ResultPair[] testUrlPort = { new ResultPair(\":80\", true), new ResultPair(\":65535\", true), new ResultPair(\":0\", true), new ResultPair(\"\", true),\n            new ResultPair(\":-1\", false), new ResultPair(\":65636\", true), new ResultPair(\":65a\", false) };\n\n    ResultPair[] testPath = { new ResultPair(\"/test1\", true), new ResultPair(\"/t123\", true), new ResultPair(\"/$23\", true), new ResultPair(\"/..\", false),\n            new ResultPair(\"/../\", false), new ResultPair(\"/test1/\", true), new ResultPair(\"\", true), new ResultPair(\"/test1/file\", true),\n            new ResultPair(\"/..//file\", false), new ResultPair(\"/test1//file\", false) };\n\n    // Test allow2slash, noFragment\n    ResultPair[] testUrlPathOptions = { new ResultPair(\"/test1\", true), new ResultPair(\"/t123\", true), new ResultPair(\"/$23\", true),\n            new ResultPair(\"/..\", false), new ResultPair(\"/../\", false), new ResultPair(\"/test1/\", true), new ResultPair(\"/#\", false), new ResultPair(\"\", true),\n            new ResultPair(\"/test1/file\", true), new ResultPair(\"/t123/file\", true), new ResultPair(\"/$23/file\", true), new ResultPair(\"/../file\", false),\n            new ResultPair(\"/..//file\", false), new ResultPair(\"/test1//file\", true), new ResultPair(\"/#/file\", false) };\n\n    ResultPair[] testUrlQuery = { new ResultPair(\"?action=view\", true), new ResultPair(\"?action=edit&mode=up\", true), new ResultPair(\"\", true) };\n\n    Object[] testUrlParts = { testUrlScheme, testUrlAuthority, testUrlPort, testPath, testUrlQuery };\n\n    Object[] testUrlPartsOptions = { testUrlScheme, testUrlAuthority, testUrlPort, testUrlPathOptions, testUrlQuery };\n\n    int[] testPartsIndex = { 0, 0, 0, 0, 0 };\n    // Test data for individual url parts\n    ResultPair[] testScheme = { new ResultPair(\"http\", true), new ResultPair(\"ftp\", false), new ResultPair(\"httpd\", false), new ResultPair(\"telnet\", false) };\n\n    @BeforeEach\n    protected void setUp() {\n        for (int index = 0; index < testPartsIndex.length - 1; index++) {\n            testPartsIndex[index] = 0;\n        }\n    }\n\n    @Test\n    public void testIsValid() {\n        testIsValid(testUrlParts, UrlValidator.ALLOW_ALL_SCHEMES);\n        setUp();\n        final int options = UrlValidator.ALLOW_2_SLASHES + UrlValidator.ALLOW_ALL_SCHEMES + UrlValidator.NO_FRAGMENTS;\n\n        testIsValid(testUrlPartsOptions, options);\n    }\n\n    /**\n     * Create set of tests by taking the testUrlXXX arrays and running through all possible permutations of their combinations.\n     *\n     * @param testObjects Used to create a url.\n     */\n    void testIsValid(final Object[] testObjects, final int options) {\n        final UrlValidator urlVal = new UrlValidator(null, options);\n        assertTrue(urlVal.isValid(\"http://www.google.com\"));\n        assertTrue(urlVal.isValid(\"http://www.google.com/\"));\n        int statusPerLine = 60;\n        int printed = 0;\n        if (printIndex) {\n            statusPerLine = 6;\n        }\n        do {\n            final StringBuilder testBuffer = new StringBuilder();\n            boolean expected = true;\n            for (int testPartsIndexIndex = 0; testPartsIndexIndex < testPartsIndex.length; ++testPartsIndexIndex) {\n                final int index = testPartsIndex[testPartsIndexIndex];\n                final ResultPair[] part = (ResultPair[]) testObjects[testPartsIndexIndex];\n                testBuffer.append(part[index].item);\n                expected &= part[index].valid;\n            }\n            final String url = testBuffer.toString();\n            final boolean result = urlVal.isValid(url);\n            assertEquals(expected, result, url);\n            if (printStatus) {\n                if (printIndex) {\n                    System.out.print(testPartsIndextoString());\n                } else if (result == expected) {\n                    System.out.print('.');\n                } else {\n                    System.out.print('X');\n                }\n                printed++;\n                if (printed == statusPerLine) {\n                    System.out.println();\n                    printed = 0;\n                }\n            }\n        } while (incrementTestPartsIndex(testPartsIndex, testObjects));\n        if (printStatus) {\n            System.out.println();\n        }\n    }\n\n    @Test\n    public void testIsValidScheme() {\n        if (printStatus) {\n            System.out.print(\"\\n testIsValidScheme() \");\n        }\n        final String[] schemes = { \"http\", \"gopher\" };\n        // UrlValidator urlVal = new UrlValidator(schemes,false,false,false);\n        final UrlValidator urlVal = new UrlValidator(schemes, 0);\n        for (final ResultPair testPair : testScheme) {\n            final boolean result = urlVal.isValidScheme(testPair.item);\n            assertEquals(testPair.valid, result, testPair.item);\n            if (printStatus) {\n                if (result == testPair.valid) {\n                    System.out.print('.');\n                } else {\n                    System.out.print('X');\n                }\n            }\n        }\n        if (printStatus) {\n            System.out.println();\n        }\n\n    }\n\n    private String testPartsIndextoString() {\n        final StringBuilder carryMsg = new StringBuilder(\"{\");\n        for (int testPartsIndexIndex = 0; testPartsIndexIndex < testPartsIndex.length; ++testPartsIndexIndex) {\n            carryMsg.append(testPartsIndex[testPartsIndexIndex]);\n            if (testPartsIndexIndex < testPartsIndex.length - 1) {\n                carryMsg.append(',');\n            } else {\n                carryMsg.append('}');\n            }\n        }\n        return carryMsg.toString();\n\n    }\n\n    @Test\n    public void testValidateUrl() {\n        assertTrue(true);\n    }\n\n    @Test\n    public void testValidator202() {\n        final String[] schemes = { \"http\", \"https\" };\n        final UrlValidator urlValidator = new UrlValidator(schemes, UrlValidator.NO_FRAGMENTS);\n        urlValidator.isValid(\n                \"http://www.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.logoworks.comwww.log\");\n    }\n\n    @Test\n    public void testValidator204() {\n        final String[] schemes = { \"http\", \"https\" };\n        final UrlValidator urlValidator = new UrlValidator(schemes);\n        assertTrue(urlValidator.isValid(\"http://tech.yahoo.com/rc/desktops/102;_ylt=Ao8yevQHlZ4On0O3ZJGXLEQFLZA5\"));\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final boolean printStatus = false;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "printStatus = false", "syntax_pass": true}, {"attribute_expression": "private final boolean printIndex = false;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "printIndex = false", "syntax_pass": true}, {"attribute_expression": "ResultPair[] testUrlScheme = { new ResultPair(\"http://\", true), new ResultPair(\"ftp://\", true), new ResultPair(\"h3t://\", true),\n            new ResultPair(\"3ht://\", false), new ResultPair(\"http:/\", false), new ResultPair(\"http:\", false), new ResultPair(\"http/\", false),\n            new ResultPair(\"://\", false), new ResultPair(\"\", true) };", "docstring": "\nThe data given below approximates the 4 parts of a URL <scheme>://<authority><path>?<query> except that the port number is broken out of authority to\nincrease the number of permutations. A complete URL is composed of a scheme+authority+port+path+query, all of which must be individually valid for the\nentire URL to be considered valid.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ResultPair[]", "name": "testUrlScheme = { new ResultPair(\"http://\", true), new ResultPair(\"ftp://\", true), new ResultPair(\"h3t://\", true),\n            new ResultPair(\"3ht://\", false), new ResultPair(\"http:/\", false), new ResultPair(\"http:\", false), new ResultPair(\"http/\", false),\n            new ResultPair(\"://\", false), new ResultPair(\"\", true) }", "syntax_pass": true}, {"attribute_expression": "ResultPair[] testUrlAuthority = { new ResultPair(\"www.google.com\", true), new ResultPair(\"go.com\", true), new ResultPair(\"go.au\", true),\n            new ResultPair(\"0.0.0.0\", true), new ResultPair(\"255.255.255.255\", true), new ResultPair(\"256.256.256.256\", false), new ResultPair(\"255.com\", true),\n            new ResultPair(\"1.2.3.4.5\", false), new ResultPair(\"1.2.3.4.\", false), new ResultPair(\"1.2.3\", false), new ResultPair(\".1.2.3.4\", false),\n            new ResultPair(\"go.a\", false), new ResultPair(\"go.a1a\", true), new ResultPair(\"go.1aa\", false), new ResultPair(\"aaa.\", false),\n            new ResultPair(\".aaa\", false), new ResultPair(\"aaa\", false), new ResultPair(\"\", false) };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ResultPair[]", "name": "testUrlAuthority = { new ResultPair(\"www.google.com\", true), new ResultPair(\"go.com\", true), new ResultPair(\"go.au\", true),\n            new ResultPair(\"0.0.0.0\", true), new ResultPair(\"255.255.255.255\", true), new ResultPair(\"256.256.256.256\", false), new ResultPair(\"255.com\", true),\n            new ResultPair(\"1.2.3.4.5\", false), new ResultPair(\"1.2.3.4.\", false), new ResultPair(\"1.2.3\", false), new ResultPair(\".1.2.3.4\", false),\n            new ResultPair(\"go.a\", false), new ResultPair(\"go.a1a\", true), new ResultPair(\"go.1aa\", false), new ResultPair(\"aaa.\", false),\n            new ResultPair(\".aaa\", false), new ResultPair(\"aaa\", false), new ResultPair(\"\", false) }", "syntax_pass": true}, {"attribute_expression": "ResultPair[] testUrlPort = { new ResultPair(\":80\", true), new ResultPair(\":65535\", true), new ResultPair(\":0\", true), new ResultPair(\"\", true),\n            new ResultPair(\":-1\", false), new ResultPair(\":65636\", true), new ResultPair(\":65a\", false) };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ResultPair[]", "name": "testUrlPort = { new ResultPair(\":80\", true), new ResultPair(\":65535\", true), new ResultPair(\":0\", true), new ResultPair(\"\", true),\n            new ResultPair(\":-1\", false), new ResultPair(\":65636\", true), new ResultPair(\":65a\", false) }", "syntax_pass": true}, {"attribute_expression": "ResultPair[] testPath = { new ResultPair(\"/test1\", true), new ResultPair(\"/t123\", true), new ResultPair(\"/$23\", true), new ResultPair(\"/..\", false),\n            new ResultPair(\"/../\", false), new ResultPair(\"/test1/\", true), new ResultPair(\"\", true), new ResultPair(\"/test1/file\", true),\n            new ResultPair(\"/..//file\", false), new ResultPair(\"/test1//file\", false) };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ResultPair[]", "name": "testPath = { new ResultPair(\"/test1\", true), new ResultPair(\"/t123\", true), new ResultPair(\"/$23\", true), new ResultPair(\"/..\", false),\n            new ResultPair(\"/../\", false), new ResultPair(\"/test1/\", true), new ResultPair(\"\", true), new ResultPair(\"/test1/file\", true),\n            new ResultPair(\"/..//file\", false), new ResultPair(\"/test1//file\", false) }", "syntax_pass": true}, {"attribute_expression": "ResultPair[] testUrlPathOptions = { new ResultPair(\"/test1\", true), new ResultPair(\"/t123\", true), new ResultPair(\"/$23\", true),\n            new ResultPair(\"/..\", false), new ResultPair(\"/../\", false), new ResultPair(\"/test1/\", true), new ResultPair(\"/#\", false), new ResultPair(\"\", true),\n            new ResultPair(\"/test1/file\", true), new ResultPair(\"/t123/file\", true), new ResultPair(\"/$23/file\", true), new ResultPair(\"/../file\", false),\n            new ResultPair(\"/..//file\", false), new ResultPair(\"/test1//file\", true), new ResultPair(\"/#/file\", false) };", "docstring": " Test allow2slash, noFragment", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ResultPair[]", "name": "testUrlPathOptions = { new ResultPair(\"/test1\", true), new ResultPair(\"/t123\", true), new ResultPair(\"/$23\", true),\n            new ResultPair(\"/..\", false), new ResultPair(\"/../\", false), new ResultPair(\"/test1/\", true), new ResultPair(\"/#\", false), new ResultPair(\"\", true),\n            new ResultPair(\"/test1/file\", true), new ResultPair(\"/t123/file\", true), new ResultPair(\"/$23/file\", true), new ResultPair(\"/../file\", false),\n            new ResultPair(\"/..//file\", false), new ResultPair(\"/test1//file\", true), new ResultPair(\"/#/file\", false) }", "syntax_pass": true}, {"attribute_expression": "ResultPair[] testUrlQuery = { new ResultPair(\"?action=view\", true), new ResultPair(\"?action=edit&mode=up\", true), new ResultPair(\"\", true) };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ResultPair[]", "name": "testUrlQuery = { new ResultPair(\"?action=view\", true), new ResultPair(\"?action=edit&mode=up\", true), new ResultPair(\"\", true) }", "syntax_pass": true}, {"attribute_expression": "Object[] testUrlParts = { testUrlScheme, testUrlAuthority, testUrlPort, testPath, testUrlQuery };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Object[]", "name": "testUrlParts = { testUrlScheme, testUrlAuthority, testUrlPort, testPath, testUrlQuery }", "syntax_pass": true}, {"attribute_expression": "Object[] testUrlPartsOptions = { testUrlScheme, testUrlAuthority, testUrlPort, testUrlPathOptions, testUrlQuery };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Object[]", "name": "testUrlPartsOptions = { testUrlScheme, testUrlAuthority, testUrlPort, testUrlPathOptions, testUrlQuery }", "syntax_pass": true}, {"attribute_expression": "int[] testPartsIndex = { 0, 0, 0, 0, 0 };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int[]", "name": "testPartsIndex = { 0, 0, 0, 0, 0 }", "syntax_pass": true}, {"attribute_expression": "ResultPair[] testScheme = { new ResultPair(\"http\", true), new ResultPair(\"ftp\", false), new ResultPair(\"httpd\", false), new ResultPair(\"telnet\", false) };", "docstring": " Test data for individual url parts", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ResultPair[]", "name": "testScheme = { new ResultPair(\"http\", true), new ResultPair(\"ftp\", false), new ResultPair(\"httpd\", false), new ResultPair(\"telnet\", false) }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/IntegerTest.java.IntegerTest", "name": "IntegerTest", "file_path": "src/test/java/org/apache/commons/validator/IntegerTest.java", "superclasses": "AbstractNumberTest", "methods": ["[void]testInt()", "[void]testIntBeyondMax()", "[void]testIntBeyondMin()", "[void]testIntegerMax()", "[void]testIntFailure()", "[void]testIntMin()"], "method_uris": ["src/test/java/org/apache/commons/validator/IntegerTest.java.IntegerTest.[]IntegerTest()"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test for {@code int} validations.\n", "original_string": "public class IntegerTest extends AbstractNumberTest {\n\n    public IntegerTest() {\n        formKey = \"intForm\";\n        action = \"int\";\n    }\n\n    /**\n     * Tests the int validation.\n     */\n    @Test\n    public void testInt() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(\"0\");\n\n        valueTest(info, true);\n    }\n\n    /**\n     * Tests the int validation failure.\n     */\n    @Test\n    public void testIntBeyondMax() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Integer.MAX_VALUE + \"1\");\n\n        valueTest(info, false);\n    }\n\n    /**\n     * Tests the int validation failure.\n     */\n    @Test\n    public void testIntBeyondMin() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Integer.MIN_VALUE + \"1\");\n\n        valueTest(info, false);\n    }\n\n    /**\n     * Tests the int validation.\n     */\n    @Test\n    public void testIntegerMax() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Integer.toString(Integer.MAX_VALUE));\n\n        valueTest(info, true);\n    }\n\n    /**\n     * Tests the int validation failure.\n     */\n    @Test\n    public void testIntFailure() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n\n        valueTest(info, false);\n    }\n\n    /**\n     * Tests the int validation.\n     */\n    @Test\n    public void testIntMin() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Integer.toString(Integer.MIN_VALUE));\n\n        valueTest(info, true);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/Form_toStringTest.java.Form_toStringTest", "name": "Form_toStringTest", "file_path": "src/test/java/org/apache/commons/validator/Form_toStringTest.java", "superclasses": "", "methods": ["[void]testToStringWithFields()", "[void]testToStringWithoutFields()"], "method_uris": ["src/test/java/org/apache/commons/validator/Form_toStringTest.java.Form_toStringTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Form_toStringTest {\n\n    private Form form;\n    private Field field1;\n    private Field field2;\n\n    @BeforeEach\n    public void setUp() {\n        form = new Form();\n        form.setName(\"TestForm\");\n        field1 = new Field();\n        field1.setKey(\"field1\");\n        field2 = new Field();\n        field2.setKey(\"field2\");\n        form.addField(field1);\n        form.addField(field2);\n    }\n\n    @Test\n    public void testToStringWithFields() {\n        String expected = \"Form: TestForm\\n\" +\n                          \"\\tField: \\n\" +\n                          field1.toString() + \"\\n\" +\n                          \"\\tField: \\n\" +\n                          field2.toString() + \"\\n\";\n        assertEquals(expected, form.toString());\n    }\n\n    @Test\n    public void testToStringWithoutFields() {\n        form = new Form();\n        form.setName(\"EmptyForm\");\n        String expected = \"Form: EmptyForm\\n\";\n        assertEquals(expected, form.toString());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Form form;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Form", "name": "form", "syntax_pass": true}, {"attribute_expression": "private Field field1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Field", "name": "field1", "syntax_pass": true}, {"attribute_expression": "private Field field2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Field", "name": "field2", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/RequiredNameTest.java.RequiredNameTest", "name": "RequiredNameTest", "file_path": "src/test/java/org/apache/commons/validator/RequiredNameTest.java", "superclasses": "AbstractCommonTest", "methods": ["[void]testRequired()", "[void]testRequiredFirstName()", "[void]testRequiredFirstNameBlank()", "[void]testRequiredLastName()", "[void]testRequiredLastNameBlank()", "[void]testRequiredName()"], "method_uris": ["src/test/java/org/apache/commons/validator/RequiredNameTest.java.RequiredNameTest.[void]setUp()", "src/test/java/org/apache/commons/validator/RequiredNameTest.java.RequiredNameTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test.\n", "original_string": "public class RequiredNameTest extends AbstractCommonTest {\n\n    /**\n     * The key used to retrieve the set of validation rules from the xml file.\n     */\n    protected static final String FORM_KEY = \"nameForm\";\n\n    /**\n     * The key used to retrieve the validator action.\n     */\n    protected static final String ACTION = \"required\";\n\n    /**\n     * Load {@code ValidatorResources} from validator-name-required.xml.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException, SAXException {\n        // Load resources\n        loadResources(\"RequiredNameTest-config.xml\");\n    }\n\n    @AfterEach\n    protected void tearDown() {\n    }\n\n    /**\n     * Tests the required validation failure.\n     */\n    @Test\n    public void testRequired() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        // throws ValidatorException,\n        // but we aren't catching for testing\n        // since no validation methods we use\n        // throw this\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), () -> \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!firstNameResult.isValid(ACTION), () -> \"First Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n\n        assertNotNull(lastNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!lastNameResult.isValid(ACTION), \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n    }\n\n    /**\n     * Tests the required validation for first name.\n     */\n    @Test\n    public void testRequiredFirstName() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"Joe\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), () -> \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(firstNameResult.isValid(ACTION), () -> \"First Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n\n        assertNotNull(lastNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), () -> \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!lastNameResult.isValid(ACTION), () -> \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n    }\n\n    /**\n     * Tests the required validation for first name if it is blank.\n     */\n    @Test\n    public void testRequiredFirstNameBlank() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), () -> \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!firstNameResult.isValid(ACTION), () -> \"First Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n\n        assertNotNull(lastNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), () -> \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!lastNameResult.isValid(ACTION), () -> \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n    }\n\n    /**\n     * Tests the required validation for last name.\n     */\n    @Test\n    public void testRequiredLastName() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setLastName(\"Smith\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), () -> \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!firstNameResult.isValid(ACTION), () -> \"First Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n\n        assertNotNull(lastNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), () -> \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(lastNameResult.isValid(ACTION), () -> \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n\n    }\n\n    /**\n     * Tests the required validation for last name if it is blank.\n     */\n    @Test\n    public void testRequiredLastNameBlank() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setLastName(\"\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!firstNameResult.isValid(ACTION), \"First Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n\n        assertNotNull(lastNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), () -> \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!lastNameResult.isValid(ACTION), () -> \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n    }\n\n    /**\n     * Tests the required validation for first and last name.\n     */\n    @Test\n    public void testRequiredName() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"Joe\");\n        name.setLastName(\"Smith\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), () -> \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(firstNameResult.isValid(ACTION), () -> \"First Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n\n        assertNotNull(lastNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), () -> \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(lastNameResult.isValid(ACTION), () -> \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final String FORM_KEY = \"nameForm\";", "docstring": "\nThe key used to retrieve the set of validation rules from the xml file.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "FORM_KEY = \"nameForm\"", "syntax_pass": true}, {"attribute_expression": "protected static final String ACTION = \"required\";", "docstring": "\nThe key used to retrieve the validator action.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "ACTION = \"required\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/ExtensionTest.java.ExtensionTest", "name": "ExtensionTest", "file_path": "src/test/java/org/apache/commons/validator/ExtensionTest.java", "superclasses": "", "methods": ["[void]testOrder()", "[void]testOverrideRule()", "[void]testRequired()", "[void]testRequiredFirstName()", "[void]testRequiredFirstNameBlank()", "[void]testRequiredLastName()", "[void]testRequiredLastNameBlank()", "[void]testRequiredName()"], "method_uris": ["src/test/java/org/apache/commons/validator/ExtensionTest.java.ExtensionTest.[void]setUp()", "src/test/java/org/apache/commons/validator/ExtensionTest.java.ExtensionTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\n<p>\nPerforms tests for extension in form definitions. Performs the same tests RequiredNameTest does but with an equivalent validation definition with extension\ndefinitions (validator-extension.xml), plus an extra check on overriding rules and another one checking it mantains correct order when extending.\n</p>\n", "original_string": "public class ExtensionTest {\n\n    /**\n     * The key used to retrieve the set of validation rules from the xml file.\n     */\n    protected static final String FORM_KEY = \"nameForm\";\n\n    /**\n     * The key used to retrieve the set of validation rules from the xml file.\n     */\n    protected static final String FORM_KEY2 = \"nameForm2\";\n\n    /**\n     * The key used to retrieve the set of validation rules from the xml file.\n     */\n    protected static final String CHECK_MSG_KEY = \"nameForm.lastname.displayname\";\n\n    /**\n     * The key used to retrieve the validator action.\n     */\n    protected static final String ACTION = \"required\";\n\n    /**\n     * Resources used for validation tests.\n     */\n    private ValidatorResources resources;\n\n    /**\n     * Load {@code ValidatorResources} from validator-extension.xml.\n     */\n    @BeforeEach\n    protected void setUp() throws Exception {\n        // Load resources\n        try (InputStream in = this.getClass().getResourceAsStream(\"ExtensionTest-config.xml\")) {\n            resources = new ValidatorResources(in);\n        }\n    }\n\n    @AfterEach\n    protected void tearDown() {\n    }\n\n    /**\n     * Tests if the order is mantained when extending a form. Parent form fields should preceed self form fields, except if we override the rules.\n     */\n    @Test\n    public void testOrder() {\n\n        final Form form = resources.getForm(ValidatorResources.defaultLocale, FORM_KEY);\n        final Form form2 = resources.getForm(ValidatorResources.defaultLocale, FORM_KEY2);\n\n        assertNotNull(form, FORM_KEY + \" is null.\");\n        assertEquals(2, form.getFields().size(), \"There should only be 2 fields in \" + FORM_KEY);\n\n        assertNotNull(form2, FORM_KEY2 + \" is null.\");\n        assertEquals(2, form2.getFields().size(), \"There should only be 2 fields in \" + FORM_KEY2);\n\n        // get the first field\n        Field fieldFirstName = form.getFields().get(0);\n        // get the second field\n        Field fieldLastName = form.getFields().get(1);\n        assertTrue(fieldFirstName.getKey().equals(\"firstName\"), \"firstName in \" + FORM_KEY + \" should be the first in the list\");\n        assertTrue(fieldLastName.getKey().equals(\"lastName\"), \"lastName in \" + FORM_KEY + \" should be the first in the list\");\n\n//     get the second field\n        fieldLastName = form2.getFields().get(0);\n        // get the first field\n        fieldFirstName = form2.getFields().get(1);\n        assertTrue(fieldFirstName.getKey().equals(\"firstName\"), \"firstName in \" + FORM_KEY2 + \" should be the first in the list\");\n        assertTrue(fieldLastName.getKey().equals(\"lastName\"), \"lastName in \" + FORM_KEY2 + \" should be the first in the list\");\n\n    }\n\n    /**\n     * Tests if we can override a rule. We \"can\" override a rule if the message shown when the firstName required test fails and the lastName test is null.\n     */\n    @Test\n    public void testOverrideRule() throws ValidatorException {\n\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setLastName(\"Smith\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY2);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.field.getArg(0).getKey().equals(CHECK_MSG_KEY),\n                \"First Name ValidatorResult for the '\" + ACTION + \"' action should have '\" + CHECK_MSG_KEY + \" as a key.\");\n\n        assertNull(lastNameResult, \"Last Name ValidatorResult should be null.\");\n    }\n\n    /**\n     * Tests the required validation failure.\n     */\n    @Test\n    public void testRequired() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        // throws ValidatorException,\n        // but we aren't catching for testing\n        // since no validation methods we use\n        // throw this\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!firstNameResult.isValid(ACTION), \"First Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n\n        assertNotNull(lastNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!lastNameResult.isValid(ACTION), \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n    }\n\n    /**\n     * Tests the required validation for first name.\n     */\n    @Test\n    public void testRequiredFirstName() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"Joe\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(firstNameResult.isValid(ACTION), \"First Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n\n        assertNotNull(lastNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!lastNameResult.isValid(ACTION), \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n    }\n\n    /**\n     * Tests the required validation for first name if it is blank.\n     */\n    @Test\n    public void testRequiredFirstNameBlank() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!firstNameResult.isValid(ACTION), \"First Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n\n        assertNotNull(lastNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!lastNameResult.isValid(ACTION), \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n    }\n\n    /**\n     * Tests the required validation for last name.\n     */\n    @Test\n    public void testRequiredLastName() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setLastName(\"Smith\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!firstNameResult.isValid(ACTION), \"First Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n\n        assertNotNull(lastNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(lastNameResult.isValid(ACTION), \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n\n    }\n\n    /**\n     * Tests the required validation for last name if it is blank.\n     */\n    @Test\n    public void testRequiredLastNameBlank() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setLastName(\"\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!firstNameResult.isValid(ACTION), \"First Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n\n        assertNotNull(lastNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!lastNameResult.isValid(ACTION), \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n    }\n\n    /**\n     * Tests the required validation for first and last name.\n     */\n    @Test\n    public void testRequiredName() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"Joe\");\n        name.setLastName(\"Smith\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(firstNameResult.isValid(ACTION), \"First Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n\n        assertNotNull(lastNameResult, \"Last Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(lastNameResult.isValid(ACTION), \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final String FORM_KEY = \"nameForm\";", "docstring": "\nThe key used to retrieve the set of validation rules from the xml file.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "FORM_KEY = \"nameForm\"", "syntax_pass": true}, {"attribute_expression": "protected static final String FORM_KEY2 = \"nameForm2\";", "docstring": "\nThe key used to retrieve the set of validation rules from the xml file.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "FORM_KEY2 = \"nameForm2\"", "syntax_pass": true}, {"attribute_expression": "protected static final String CHECK_MSG_KEY = \"nameForm.lastname.displayname\";", "docstring": "\nThe key used to retrieve the set of validation rules from the xml file.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "CHECK_MSG_KEY = \"nameForm.lastname.displayname\"", "syntax_pass": true}, {"attribute_expression": "protected static final String ACTION = \"required\";", "docstring": "\nThe key used to retrieve the validator action.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "ACTION = \"required\"", "syntax_pass": true}, {"attribute_expression": "private ValidatorResources resources;", "docstring": "\nResources used for validation tests.\n", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ValidatorResources", "name": "resources", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/LocaleTest.java.LocaleTest", "name": "LocaleTest", "file_path": "src/test/java/org/apache/commons/validator/LocaleTest.java", "superclasses": "AbstractCommonTest", "methods": ["[void]testLocale1()", "[void]testLocale2()", "[void]testLocale3()", "[void]testLocale4()", "[void]testLocale5()"], "method_uris": ["src/test/java/org/apache/commons/validator/LocaleTest.java.LocaleTest.[void]setUp()", "src/test/java/org/apache/commons/validator/LocaleTest.java.LocaleTest.[void]tearDown()", "src/test/java/org/apache/commons/validator/LocaleTest.java.LocaleTest.[void]valueTest(Object,Locale,boolean,boolean,boolean)"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test for locale validations.\n", "original_string": "public class LocaleTest extends AbstractCommonTest {\n\n    /**\n     * The key used to retrieve the set of validation rules from the xml file.\n     */\n    protected static final String FORM_KEY = \"nameForm\";\n\n    /** The key used to retrieve the validator action. */\n    protected static final String ACTION = \"required\";\n\n    /**\n     * Load {@code ValidatorResources} from validator-locale.xml.\n     *\n     * @throws IOException  If something goes wrong\n     * @throws SAXException If something goes wrong\n     */\n    @BeforeEach\n    protected void setUp() throws IOException, SAXException {\n        // Load resources\n        loadResources(\"LocaleTest-config.xml\");\n    }\n\n    /** The teardown method for JUnit */\n    @AfterEach\n    protected void tearDown() {\n    }\n\n    /**\n     * See what happens when we try to validate with a Locale, Country and variant. Also check if the added locale validation field is getting used.\n     *\n     * @throws ValidatorException If something goes wrong\n     */\n    @Test\n    public void testLocale1() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"\");\n        name.setLastName(\"\");\n\n        valueTest(name, new Locale(\"en\", \"US\", \"TEST1\"), false, false, false);\n    }\n\n    /**\n     * See what happens when we try to validate with a Locale, Country and variant\n     *\n     * @throws ValidatorException If something goes wrong\n     */\n    @Test\n    public void testLocale2() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"\");\n        name.setLastName(\"\");\n\n        valueTest(name, new Locale(\"en\", \"US\", \"TEST2\"), true, false, true);\n    }\n\n    /**\n     * See what happens when we try to validate with a Locale, Country and variant\n     *\n     * @throws ValidatorException If something goes wrong\n     */\n    @Test\n    public void testLocale3() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"\");\n        name.setLastName(\"\");\n\n        valueTest(name, new Locale(\"en\", \"UK\"), false, true, true);\n    }\n\n    /**\n     * See if a locale of en_UK_TEST falls back to en_UK instead of default form set. Bug #16920 states that this isn't happening, even though it is passing\n     * this test. see #16920.\n     *\n     * @throws ValidatorException If something goes wrong\n     */\n    @Test\n    public void testLocale4() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"\");\n        name.setLastName(\"\");\n\n        valueTest(name, new Locale(\"en\", \"UK\", \"TEST\"), false, true, true);\n    }\n\n    /**\n     * See if a locale of language=en falls back to default form set.\n     *\n     * @throws ValidatorException If something goes wrong\n     */\n    @Test\n    public void testLocale5() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"\");\n        name.setLastName(\"\");\n\n        valueTest(name, new Locale(\"en\", \"\"), false, false, true);\n    }\n\n    /**\n     * Utlity class to run a test on a value.\n     *\n     * @param name       param\n     * @param loc        param\n     * @param firstGood  param\n     * @param lastGood   param\n     * @param middleGood param\n     * @throws ValidatorException If something goes wrong\n     */\n    private void valueTest(final Object name, final Locale loc, final boolean firstGood, final boolean lastGood, final boolean middleGood)\n            throws ValidatorException {\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n        validator.setParameter(Validator.LOCALE_PARAM, loc);\n        // Get results of the validation.\n        // throws ValidatorException,\n        // but we aren't catching for testing\n        // since no validation methods we use\n        // throw this\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult resultlast = results.getValidatorResult(\"lastName\");\n        final ValidatorResult resultfirst = results.getValidatorResult(\"firstName\");\n        final ValidatorResult resultmiddle = results.getValidatorResult(\"middleName\");\n\n        if (firstGood) {\n            assertNull(resultfirst);\n        } else {\n            assertNotNull(resultfirst);\n        }\n\n        if (middleGood) {\n            assertNull(resultmiddle);\n        } else {\n            assertNotNull(resultmiddle);\n        }\n\n        if (lastGood) {\n            assertNull(resultlast);\n        } else {\n            assertNotNull(resultlast);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final String FORM_KEY = \"nameForm\";", "docstring": "\nThe key used to retrieve the set of validation rules from the xml file.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "FORM_KEY = \"nameForm\"", "syntax_pass": true}, {"attribute_expression": "protected static final String ACTION = \"required\";", "docstring": " The key used to retrieve the validator action.", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "ACTION = \"required\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/GenericValidatorTest.java.GenericValidatorTest", "name": "GenericValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/GenericValidatorTest.java", "superclasses": "", "methods": ["[void]testMaxLength()", "[void]testMinLength()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTest the GenericValidator class.\n", "original_string": "public class GenericValidatorTest {\n\n    @Test\n    public void testMaxLength() {\n\n        // Use 0 for line end length\n        assertFalse(GenericValidator.maxLength(\"12345\\n\\r\", 4, 0), \"Max=4 End=0\");\n        assertTrue(GenericValidator.maxLength(\"12345\\n\\r\", 5, 0), \"Max=5 End=0\");\n        assertTrue(GenericValidator.maxLength(\"12345\\n\\r\", 6, 0), \"Max=6 End=0\");\n        assertTrue(GenericValidator.maxLength(\"12345\\n\\r\", 7, 0), \"Max=7 End=0\");\n\n        // Use 1 for line end length\n        assertFalse(GenericValidator.maxLength(\"12345\\n\\r\", 4, 1), \"Max=4 End=1\");\n        assertFalse(GenericValidator.maxLength(\"12345\\n\\r\", 5, 1), \"Max=5 End=1\");\n        assertTrue(GenericValidator.maxLength(\"12345\\n\\r\", 6, 1), \"Max=6 End=1\");\n        assertTrue(GenericValidator.maxLength(\"12345\\n\\r\", 7, 1), \"Max=7 End=1\");\n\n        // Use 2 for line end length\n        assertFalse(GenericValidator.maxLength(\"12345\\n\\r\", 4, 2), \"Max=4 End=2\");\n        assertFalse(GenericValidator.maxLength(\"12345\\n\\r\", 5, 2), \"Max=5 End=2\");\n        assertFalse(GenericValidator.maxLength(\"12345\\n\\r\", 6, 2), \"Max=6 End=2\");\n        assertTrue(GenericValidator.maxLength(\"12345\\n\\r\", 7, 2), \"Max=7 End=2\");\n    }\n\n    @Test\n    public void testMinLength() {\n\n        // Use 0 for line end length\n        assertTrue(GenericValidator.minLength(\"12345\\n\\r\", 5, 0), \"Min=5 End=0\");\n        assertFalse(GenericValidator.minLength(\"12345\\n\\r\", 6, 0), \"Min=6 End=0\");\n        assertFalse(GenericValidator.minLength(\"12345\\n\\r\", 7, 0), \"Min=7 End=0\");\n        assertFalse(GenericValidator.minLength(\"12345\\n\\r\", 8, 0), \"Min=8 End=0\");\n\n        // Use 1 for line end length\n        assertTrue(GenericValidator.minLength(\"12345\\n\\r\", 5, 1), \"Min=5 End=1\");\n        assertTrue(GenericValidator.minLength(\"12345\\n\\r\", 6, 1), \"Min=6 End=1\");\n        assertFalse(GenericValidator.minLength(\"12345\\n\\r\", 7, 1), \"Min=7 End=1\");\n        assertFalse(GenericValidator.minLength(\"12345\\n\\r\", 8, 1), \"Min=8 End=1\");\n\n        // Use 2 for line end length\n        assertTrue(GenericValidator.minLength(\"12345\\n\\r\", 5, 2), \"Min=5 End=2\");\n        assertTrue(GenericValidator.minLength(\"12345\\n\\r\", 6, 2), \"Min=6 End=2\");\n        assertTrue(GenericValidator.minLength(\"12345\\n\\r\", 7, 2), \"Min=7 End=2\");\n        assertFalse(GenericValidator.minLength(\"12345\\n\\r\", 8, 2), \"Min=8 End=2\");\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/ParameterTest.java.ParameterTest", "name": "ParameterTest", "file_path": "src/test/java/org/apache/commons/validator/ParameterTest.java", "superclasses": "AbstractCommonTest", "methods": ["[void]testAllValid()"], "method_uris": ["src/test/java/org/apache/commons/validator/ParameterTest.java.ParameterTest.[void]assertParameterValue(Validator,String,Class<?>)", "src/test/java/org/apache/commons/validator/ParameterTest.java.ParameterTest.[NameBean]createNameBean()", "src/test/java/org/apache/commons/validator/ParameterTest.java.ParameterTest.[void]setUp()", "src/test/java/org/apache/commons/validator/ParameterTest.java.ParameterTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nThis TestCase is a confirmation of the parameter of the validator's method.\n", "original_string": "public class ParameterTest extends AbstractCommonTest {\n\n    private static final String FORM_KEY = \"nameForm\";\n\n    private String firstName;\n\n    private String middleName;\n\n    private String lastName;\n\n    private void assertParameterValue(final Validator validator, final String name, final Class<?> type) {\n        final Object value = validator.getParameterValue(name);\n        assertNotNull(value, () -> \"Expected '\" + type.getName() + \"' but was null\");\n        assertTrue(type.isInstance(value), () -> \"Expected '\" + type.getName() + \"' but was '\" + value.getClass().getName() + \"'\");\n    }\n\n    /**\n     * Create a NameBean.\n     */\n    private NameBean createNameBean() {\n        final NameBean name = new NameBean();\n        name.setFirstName(firstName);\n        name.setMiddleName(middleName);\n        name.setLastName(lastName);\n        return name;\n    }\n\n    /**\n     * Load {@code ValidatorResources} from ValidatorResultsTest-config.xml.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException, SAXException {\n        // Load resources\n        loadResources(\"ParameterTest-config.xml\");\n\n        // initialize values\n        firstName = \"foo\";\n        middleName = \"123\";\n        lastName = \"456\";\n\n    }\n\n    @AfterEach\n    protected void tearDown() {\n    }\n\n    /**\n     * Test all validations ran and passed.\n     */\n    @Test\n    public void testAllValid() {\n\n        // Create bean to run test on.\n        final NameBean bean = createNameBean();\n\n        final Validator validator = new Validator(resources, FORM_KEY);\n\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, bean);\n        validator.setParameter(Validator.LOCALE_PARAM, Locale.getDefault());\n\n        // Get results of the validation.\n        try {\n            validator.validate();\n        } catch (final Exception e) {\n            fail(\"Validator.validate() threw \" + e);\n        }\n        assertParameterValue(validator, Validator.BEAN_PARAM, Object.class);\n        assertParameterValue(validator, Validator.FIELD_PARAM, Field.class);\n        assertParameterValue(validator, Validator.FORM_PARAM, Form.class);\n        assertParameterValue(validator, Validator.LOCALE_PARAM, Locale.class);\n        assertParameterValue(validator, Validator.VALIDATOR_ACTION_PARAM, ValidatorAction.class);\n        assertParameterValue(validator, Validator.VALIDATOR_PARAM, Validator.class);\n        assertParameterValue(validator, Validator.VALIDATOR_RESULTS_PARAM, ValidatorResults.class);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String FORM_KEY = \"nameForm\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "FORM_KEY = \"nameForm\"", "syntax_pass": true}, {"attribute_expression": "private String firstName;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "firstName", "syntax_pass": true}, {"attribute_expression": "private String middleName;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "middleName", "syntax_pass": true}, {"attribute_expression": "private String lastName;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "lastName", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/Field_getVarValueTest.java.Field_getVarValueTest", "name": "Field_getVarValueTest", "file_path": "src/test/java/org/apache/commons/validator/Field_getVarValueTest.java", "superclasses": "", "methods": ["[void]testGetVarValueExists()", "[void]testGetVarValueNotExists()"], "method_uris": ["src/test/java/org/apache/commons/validator/Field_getVarValueTest.java.Field_getVarValueTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Field_getVarValueTest {\n    private Field field;\n\n    @BeforeEach\n    public void setUp() {\n        field = new Field();\n    }\n\n    @Test\n    public void testGetVarValueExists() {\n        field.addVar(\"var-1-1\", \"value-1-1\", \"jstype-1-1\");\n        assertEquals(\"value-1-1\", field.getVarValue(\"var-1-1\"));\n    }\n\n    @Test\n    public void testGetVarValueNotExists() {\n        assertNull(field.getVarValue(\"non-existent-var\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Field field;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Field", "name": "field", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/ValidatorResults_getResultValueMapTest.java.ValidatorResults_getResultValueMapTest", "name": "ValidatorResults_getResultValueMapTest", "file_path": "src/test/java/org/apache/commons/validator/ValidatorResults_getResultValueMapTest.java", "superclasses": "", "methods": ["[void]testGetResultValueMapWithNonBooleanResult()", "[void]testGetResultValueMapWithBooleanResult()", "[void]testGetResultValueMapWithNullResult()", "[void]testGetResultValueMapWithMultipleResults()", "[void]testGetResultValueMapWithEmptyResults()"], "method_uris": ["src/test/java/org/apache/commons/validator/ValidatorResults_getResultValueMapTest.java.ValidatorResults_getResultValueMapTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ValidatorResults_getResultValueMapTest {\n\n    private ValidatorResults validatorResults;\n\n    @BeforeEach\n    public void setUp() {\n        validatorResults = new ValidatorResults();\n    }\n\n    @Test\n    public void testGetResultValueMapWithNonBooleanResult() {\n        // Arrange\n        Field field = new Field();\n        field.setKey(\"testKey\");\n        validatorResults.add(field, \"testAction\", true, \"testValue\");\n\n        // Act\n        Map<String, Object> resultMap = validatorResults.getResultValueMap();\n\n        // Assert\n        assertEquals(1, resultMap.size());\n        assertTrue(resultMap.containsKey(\"testKey\"));\n        assertEquals(\"testValue\", resultMap.get(\"testKey\"));\n    }\n\n    @Test\n    public void testGetResultValueMapWithBooleanResult() {\n        // Arrange\n        Field field = new Field();\n        field.setKey(\"testKey\");\n        validatorResults.add(field, \"testAction\", true, true);\n\n        // Act\n        Map<String, Object> resultMap = validatorResults.getResultValueMap();\n\n        // Assert\n        assertTrue(resultMap.isEmpty());\n    }\n\n    @Test\n    public void testGetResultValueMapWithNullResult() {\n        // Arrange\n        Field field = new Field();\n        field.setKey(\"testKey\");\n        validatorResults.add(field, \"testAction\", true, null);\n\n        // Act\n        Map<String, Object> resultMap = validatorResults.getResultValueMap();\n\n        // Assert\n        assertTrue(resultMap.isEmpty());\n    }\n\n    @Test\n    public void testGetResultValueMapWithMultipleResults() {\n        // Arrange\n        Field field1 = new Field();\n        field1.setKey(\"key1\");\n        validatorResults.add(field1, \"action1\", true, \"value1\");\n\n        Field field2 = new Field();\n        field2.setKey(\"key2\");\n        validatorResults.add(field2, \"action2\", true, true);\n\n        Field field3 = new Field();\n        field3.setKey(\"key3\");\n        validatorResults.add(field3, \"action3\", true, \"value3\");\n\n        // Act\n        Map<String, Object> resultMap = validatorResults.getResultValueMap();\n\n        // Assert\n        assertEquals(2, resultMap.size());\n        assertTrue(resultMap.containsKey(\"key1\"));\n        assertEquals(\"value1\", resultMap.get(\"key1\"));\n        assertTrue(resultMap.containsKey(\"key3\"));\n        assertEquals(\"value3\", resultMap.get(\"key3\"));\n    }\n\n    @Test\n    public void testGetResultValueMapWithEmptyResults() {\n        // Act\n        Map<String, Object> resultMap = validatorResults.getResultValueMap();\n\n        // Assert\n        assertTrue(resultMap.isEmpty());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ValidatorResults validatorResults;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ValidatorResults", "name": "validatorResults", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/LongTest.java.LongTest", "name": "LongTest", "file_path": "src/test/java/org/apache/commons/validator/LongTest.java", "superclasses": "AbstractNumberTest", "methods": ["[void]testLong()", "[void]testLongBeyondMax()", "[void]testLongBeyondMin()", "[void]testLongFailure()", "[void]testLongMax()", "[void]testLongMin()"], "method_uris": ["src/test/java/org/apache/commons/validator/LongTest.java.LongTest.[]LongTest()"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test for {@code long} validations.\n", "original_string": "public class LongTest extends AbstractNumberTest {\n\n    public LongTest() {\n        formKey = \"longForm\";\n        action = \"long\";\n    }\n\n    /**\n     * Tests the long validation.\n     */\n    @Test\n    public void testLong() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(\"0\");\n\n        valueTest(info, true);\n    }\n\n    /**\n     * Tests the long validation failure.\n     */\n    @Test\n    public void testLongBeyondMax() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Long.MAX_VALUE + \"1\");\n\n        valueTest(info, false);\n    }\n\n    /**\n     * Tests the long validation failure.\n     */\n    @Test\n    public void testLongBeyondMin() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Long.MIN_VALUE + \"1\");\n\n        valueTest(info, false);\n    }\n\n    /**\n     * Tests the long validation failure.\n     */\n    @Test\n    public void testLongFailure() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n\n        valueTest(info, false);\n    }\n\n    /**\n     * Tests the long validation.\n     */\n    @Test\n    public void testLongMax() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Long.toString(Long.MAX_VALUE));\n\n        valueTest(info, true);\n    }\n\n    /**\n     * Tests the long validation.\n     */\n    @Test\n    public void testLongMin() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Long.toString(Long.MIN_VALUE));\n\n        valueTest(info, true);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/Field_generateKeyTest.java.Field_generateKeyTest", "name": "Field_generateKeyTest", "file_path": "src/test/java/org/apache/commons/validator/Field_generateKeyTest.java", "superclasses": "", "methods": ["[void]testGenerateKeyIndexed()", "[void]testGenerateKeyNotIndexed()"], "method_uris": ["src/test/java/org/apache/commons/validator/Field_generateKeyTest.java.Field_generateKeyTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Field_generateKeyTest {\n    private Field field;\n\n    @BeforeEach\n    public void setUp() {\n        field = new Field();\n    }\n\n    @Test\n    public void testGenerateKeyIndexed() {\n        field.setIndexedListProperty(\"indexedListProperty\");\n        field.setProperty(\"property\");\n        field.generateKey();\n        assertEquals(\"indexedListProperty[].\" + \"property\", field.getKey());\n    }\n\n    @Test\n    public void testGenerateKeyNotIndexed() {\n        field.setProperty(\"property\");\n        field.generateKey();\n        assertEquals(\"property\", field.getKey());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Field field;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Field", "name": "field", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/ValidatorResultsTest.java.ValidatorResultsTest", "name": "ValidatorResultsTest", "file_path": "src/test/java/org/apache/commons/validator/ValidatorResultsTest.java", "superclasses": "AbstractCommonTest", "methods": ["[void]testAllValid()", "[void]testErrors()"], "method_uris": ["src/test/java/org/apache/commons/validator/ValidatorResultsTest.java.ValidatorResultsTest.[void]checkNotRun(ValidatorResults,String,String)", "src/test/java/org/apache/commons/validator/ValidatorResultsTest.java.ValidatorResultsTest.[void]checkValidatorResult(ValidatorResults,String,String,boolean)", "src/test/java/org/apache/commons/validator/ValidatorResultsTest.java.ValidatorResultsTest.[NameBean]createNameBean()", "src/test/java/org/apache/commons/validator/ValidatorResultsTest.java.ValidatorResultsTest.[void]setUp()", "src/test/java/org/apache/commons/validator/ValidatorResultsTest.java.ValidatorResultsTest.[void]tearDown()", "src/test/java/org/apache/commons/validator/ValidatorResultsTest.java.ValidatorResultsTest.[ValidatorResults]validate(Object)"], "overrides": null, "attributes": [], "class_docstring": "\nTest ValidatorResults.\n", "original_string": "public class ValidatorResultsTest extends AbstractCommonTest {\n\n    private static final String FORM_KEY = \"nameForm\";\n    private static final String FIRST_NAME_FIELD = \"firstName\";\n    private static final String MIDDLE_NAME_FIELD = \"middleName\";\n    private static final String LAST_NAME_FIELD = \"lastName\";\n\n    private String firstName;\n    private String middleName;\n    private String lastName;\n\n    /**\n     * Check a validator has not been run for a field and the result.\n     */\n    private void checkNotRun(final ValidatorResults results, final String field, final String action) {\n        final ValidatorResult result = results.getValidatorResult(field);\n        assertNotNull(result, () -> field + \" result\");\n        assertFalse(result.containsAction(action), () -> field + \"[\" + action + \"] run\");\n        // System.out.println(field + \"[\" + action + \"] not run\");\n    }\n\n    /**\n     * Check a validator has run for a field and the result.\n     */\n    private void checkValidatorResult(final ValidatorResults results, final String field, final String action, final boolean expected) {\n        final ValidatorResult result = results.getValidatorResult(field);\n        // System.out.println(field + \"[\" + action + \"]=\" + result.isValid(action));\n        assertNotNull(result, () -> field + \" result\");\n        assertTrue(result.containsAction(action), () -> field + \"[\" + action + \"] not run\");\n        assertEquals(expected, result.isValid(action), () -> field + \"[\" + action + \"] result\");\n    }\n\n    /**\n     * Create a NameBean.\n     */\n    private NameBean createNameBean() {\n        final NameBean name = new NameBean();\n        name.setFirstName(firstName);\n        name.setMiddleName(middleName);\n        name.setLastName(lastName);\n        return name;\n    }\n\n    /**\n     * Load {@code ValidatorResources} from ValidatorResultsTest-config.xml.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException, SAXException {\n        // Load resources\n        loadResources(\"ValidatorResultsTest-config.xml\");\n\n        // initialize values\n        firstName = \"foo\";\n        middleName = \"123\";\n        lastName = \"456\";\n\n    }\n\n    @AfterEach\n    protected void tearDown() {\n    }\n\n    /**\n     * Test all validations ran and passed.\n     */\n    @Test\n    public void testAllValid() throws ValidatorException {\n\n        // Create bean to run test on.\n        final NameBean bean = createNameBean();\n\n        // Validate.\n        final ValidatorResults results = validate(bean);\n\n        // Check results\n        checkValidatorResult(results, FIRST_NAME_FIELD, \"required\", true);\n        checkValidatorResult(results, MIDDLE_NAME_FIELD, \"required\", true);\n        checkValidatorResult(results, MIDDLE_NAME_FIELD, \"int\", true);\n        checkValidatorResult(results, MIDDLE_NAME_FIELD, \"positive\", true);\n        checkValidatorResult(results, LAST_NAME_FIELD, \"required\", true);\n        checkValidatorResult(results, LAST_NAME_FIELD, \"int\", true);\n\n    }\n\n    /**\n     * Test some validations failed and some didn't run.\n     */\n    @Test\n    public void testErrors() throws ValidatorException {\n\n        middleName = \"XXX\";\n        lastName = null;\n\n        // Create bean to run test on.\n        final NameBean bean = createNameBean();\n\n        // Validate.\n        final ValidatorResults results = validate(bean);\n\n        // Check results\n        checkValidatorResult(results, FIRST_NAME_FIELD, \"required\", true);\n        checkValidatorResult(results, MIDDLE_NAME_FIELD, \"required\", true);\n        checkValidatorResult(results, MIDDLE_NAME_FIELD, \"int\", false);\n        checkNotRun(results, MIDDLE_NAME_FIELD, \"positive\");\n        checkValidatorResult(results, LAST_NAME_FIELD, \"required\", false);\n        checkNotRun(results, LAST_NAME_FIELD, \"int\");\n\n    }\n\n    /**\n     * Validate results.\n     */\n    private ValidatorResults validate(final Object bean) throws ValidatorException {\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, bean);\n\n        return validator.validate();\n\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String FORM_KEY = \"nameForm\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "FORM_KEY = \"nameForm\"", "syntax_pass": true}, {"attribute_expression": "private static final String FIRST_NAME_FIELD = \"firstName\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "FIRST_NAME_FIELD = \"firstName\"", "syntax_pass": true}, {"attribute_expression": "private static final String MIDDLE_NAME_FIELD = \"middleName\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "MIDDLE_NAME_FIELD = \"middleName\"", "syntax_pass": true}, {"attribute_expression": "private static final String LAST_NAME_FIELD = \"lastName\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "LAST_NAME_FIELD = \"lastName\"", "syntax_pass": true}, {"attribute_expression": "private String firstName;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "firstName", "syntax_pass": true}, {"attribute_expression": "private String middleName;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "middleName", "syntax_pass": true}, {"attribute_expression": "private String lastName;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "lastName", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/MultipleTest.java.MultipleTest", "name": "MultipleTest", "file_path": "src/test/java/org/apache/commons/validator/MultipleTest.java", "superclasses": "AbstractCommonTest", "methods": ["[void]testBothBlank()", "[void]testFailingFirstDependentValidator()", "[void]testFailingNextDependentValidator()", "[void]testPassingDependentsFailingMain()", "[void]testPassingDependentsPassingMain()", "[void]testRequiredFirstNameBlankLastNameShort()", "[void]testRequiredLastNameLong()", "[void]testRequiredLastNameShort()"], "method_uris": ["src/test/java/org/apache/commons/validator/MultipleTest.java.MultipleTest.[void]setUp()", "src/test/java/org/apache/commons/validator/MultipleTest.java.MultipleTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test.\n", "original_string": "public class MultipleTest extends AbstractCommonTest {\n\n    /**\n     * The key used to retrieve the set of validation rules from the xml file.\n     */\n    protected static final String FORM_KEY = \"nameForm\";\n\n    /**\n     * The key used to retrieve the validator action.\n     */\n    protected static final String ACTION = \"required\";\n\n    /**\n     * Load {@code ValidatorResources} from validator-multipletest.xml.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException, SAXException {\n        // Load resources\n        loadResources(\"MultipleTests-config.xml\");\n    }\n\n    @AfterEach\n    protected void tearDown() {\n    }\n\n    /**\n     * With nothing provided, we should fail both because both are required.\n     */\n    @Test\n    public void testBothBlank() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        // throws ValidatorException,\n        // but we aren't catching for testing\n        // since no validation methods we use\n        // throw this\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), () -> \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!firstNameResult.isValid(ACTION), () -> \"First Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n\n        assertNotNull(lastNameResult, \"Last Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), () -> \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!lastNameResult.isValid(ACTION), () -> \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n        assertTrue(!lastNameResult.containsAction(\"int\"), \"Last Name ValidatorResults should not contain the 'int' action.\");\n    }\n\n    /**\n     * If middle name is not there, then the required dependent test should fail. No other tests should run\n     *\n     * @throws ValidatorException\n     */\n    @Test\n    public void testFailingFirstDependentValidator() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult middleNameResult = results.getValidatorResult(\"middleName\");\n\n        assertNotNull(middleNameResult, \"Middle Name ValidatorResult should not be null.\");\n\n        assertTrue(middleNameResult.containsAction(\"required\"), \"Middle Name ValidatorResult should contain the 'required' action.\");\n        assertTrue(!middleNameResult.isValid(\"required\"), \"Middle Name ValidatorResult for the 'required' action should have failed\");\n\n        assertTrue(!middleNameResult.containsAction(\"int\"), \"Middle Name ValidatorResult should not contain the 'int' action.\");\n\n        assertTrue(!middleNameResult.containsAction(\"positive\"), \"Middle Name ValidatorResult should not contain the 'positive' action.\");\n    }\n\n    /**\n     * If middle name is there but not int, then the required dependent test should pass, but the int dependent test should fail. No other tests should run.\n     *\n     * @throws ValidatorException\n     */\n    @Test\n    public void testFailingNextDependentValidator() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setMiddleName(\"TEST\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult middleNameResult = results.getValidatorResult(\"middleName\");\n\n        assertNotNull(middleNameResult, \"Middle Name ValidatorResult should not be null.\");\n\n        assertTrue(middleNameResult.containsAction(\"required\"), \"Middle Name ValidatorResult should contain the 'required' action.\");\n        assertTrue(middleNameResult.isValid(\"required\"), \"Middle Name ValidatorResult for the 'required' action should have passed\");\n\n        assertTrue(middleNameResult.containsAction(\"int\"), \"Middle Name ValidatorResult should contain the 'int' action.\");\n        assertTrue(!middleNameResult.isValid(\"int\"), \"Middle Name ValidatorResult for the 'int' action should have failed\");\n\n        assertTrue(!middleNameResult.containsAction(\"positive\"), \"Middle Name ValidatorResult should not contain the 'positive' action.\");\n    }\n\n    /**\n     * If middle name is there and a negative int, then the required and int dependent tests should pass, but the positive test should fail.\n     *\n     * @throws ValidatorException\n     */\n    @Test\n    public void testPassingDependentsFailingMain() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setMiddleName(\"-2534\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult middleNameResult = results.getValidatorResult(\"middleName\");\n\n        assertNotNull(middleNameResult, \"Middle Name ValidatorResult should not be null.\");\n\n        assertTrue(middleNameResult.containsAction(\"required\"), \"Middle Name ValidatorResult should contain the 'required' action.\");\n        assertTrue(middleNameResult.isValid(\"required\"), \"Middle Name ValidatorResult for the 'required' action should have passed\");\n\n        assertTrue(middleNameResult.containsAction(\"int\"), \"Middle Name ValidatorResult should contain the 'int' action.\");\n        assertTrue(middleNameResult.isValid(\"int\"), \"Middle Name ValidatorResult for the 'int' action should have passed\");\n\n        assertTrue(middleNameResult.containsAction(\"positive\"), \"Middle Name ValidatorResult should contain the 'positive' action.\");\n        assertTrue(!middleNameResult.isValid(\"positive\"), \"Middle Name ValidatorResult for the 'positive' action should have failed\");\n    }\n\n    /**\n     * If middle name is there and a positve int, then the required and int dependent tests should pass, and the positive test should pass.\n     *\n     * @throws ValidatorException\n     */\n    @Test\n    public void testPassingDependentsPassingMain() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setMiddleName(\"2534\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult middleNameResult = results.getValidatorResult(\"middleName\");\n\n        assertNotNull(middleNameResult, \"Middle Name ValidatorResult should not be null.\");\n\n        assertTrue(middleNameResult.containsAction(\"required\"), \"Middle Name ValidatorResult should contain the 'required' action.\");\n        assertTrue(middleNameResult.isValid(\"required\"), \"Middle Name ValidatorResult for the 'required' action should have passed\");\n\n        assertTrue(middleNameResult.containsAction(\"int\"), \"Middle Name ValidatorResult should contain the 'int' action.\");\n        assertTrue(middleNameResult.isValid(\"int\"), \"Middle Name ValidatorResult for the 'int' action should have passed\");\n\n        assertTrue(middleNameResult.containsAction(\"positive\"), \"Middle Name ValidatorResult should contain the 'positive' action.\");\n        assertTrue(middleNameResult.isValid(\"positive\"), \"Middle Name ValidatorResult for the 'positive' action should have passed\");\n    }\n\n    /**\n     * If the first name fails required, and the second test fails int, we should get two errors.\n     */\n    @Test\n    public void testRequiredFirstNameBlankLastNameShort() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"\");\n        name.setLastName(\"Test\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), () -> \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!firstNameResult.isValid(ACTION), () -> \"First Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n\n        assertNotNull(lastNameResult, \"Last Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(\"int\"), \"Last Name ValidatorResult should contain the 'int' action.\");\n        assertTrue(!lastNameResult.isValid(\"int\"), \"Last Name ValidatorResult for the 'int' action should have failed.\");\n    }\n\n    /**\n     * If first name is ok and last name is ok and is an int, no errors.\n     */\n    @Test\n    public void testRequiredLastNameLong() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"Joe\");\n        name.setLastName(\"12345678\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), () -> \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(firstNameResult.isValid(ACTION), () -> \"First Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n\n        assertNotNull(lastNameResult, \"Last Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(\"int\"), \"Last Name ValidatorResult should contain the 'int' action.\");\n        assertTrue(lastNameResult.isValid(\"int\"), \"Last Name ValidatorResult for the 'int' action should have passed.\");\n    }\n\n    /**\n     * If the first name is there, and the last name fails int, we should get one error.\n     */\n    @Test\n    public void testRequiredLastNameShort() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"Test\");\n        name.setLastName(\"Test\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), () -> \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(firstNameResult.isValid(ACTION), () -> \"First Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n\n        assertNotNull(lastNameResult, \"Last Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(\"int\"), \"Last Name ValidatorResult should contain the 'int' action.\");\n        assertTrue(!lastNameResult.isValid(\"int\"), \"Last Name ValidatorResult for the 'int' action should have failed.\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final String FORM_KEY = \"nameForm\";", "docstring": "\nThe key used to retrieve the set of validation rules from the xml file.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "FORM_KEY = \"nameForm\"", "syntax_pass": true}, {"attribute_expression": "protected static final String ACTION = \"required\";", "docstring": "\nThe key used to retrieve the validator action.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "ACTION = \"required\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/Validator_getClassLoaderTest.java.Validator_getClassLoaderTest", "name": "Validator_getClassLoaderTest", "file_path": "src/test/java/org/apache/commons/validator/Validator_getClassLoaderTest.java", "superclasses": "", "methods": ["[void]testGetClassLoaderWithSetClassLoader()", "[void]testGetClassLoaderWithContextClassLoader()", "[void]testGetClassLoaderWithDefaultClassLoader()", "[void]testGetClassLoaderWithNullContextClassLoader()"], "method_uris": ["src/test/java/org/apache/commons/validator/Validator_getClassLoaderTest.java.Validator_getClassLoaderTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Validator_getClassLoaderTest {\n    private Validator validator;\n\n    @BeforeEach\n    public void setUp() {\n        validator = new Validator(new ValidatorResources());\n    }\n\n    @Test\n    public void testGetClassLoaderWithSetClassLoader() {\n        ClassLoader customClassLoader = new ClassLoader() {};\n        validator.setClassLoader(customClassLoader);\n        assertEquals(customClassLoader, validator.getClassLoader());\n    }\n\n    @Test\n    public void testGetClassLoaderWithContextClassLoader() {\n        validator.setUseContextClassLoader(true);\n        ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();\n        assertEquals(contextClassLoader, validator.getClassLoader());\n    }\n\n    @Test\n    public void testGetClassLoaderWithDefaultClassLoader() {\n        assertEquals(Validator.class.getClassLoader(), validator.getClassLoader());\n    }\n\n    @Test\n    public void testGetClassLoaderWithNullContextClassLoader() {\n        validator.setUseContextClassLoader(true);\n        ClassLoader originalContextClassLoader = Thread.currentThread().getContextClassLoader();\n        try {\n            Thread.currentThread().setContextClassLoader(null);\n            assertEquals(Validator.class.getClassLoader(), validator.getClassLoader());\n        } finally {\n            Thread.currentThread().setContextClassLoader(originalContextClassLoader);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Validator validator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Validator", "name": "validator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/ValidatorResourcesTest.java.ValidatorResourcesTest", "name": "ValidatorResourcesTest", "file_path": "src/test/java/org/apache/commons/validator/ValidatorResourcesTest.java", "superclasses": "", "methods": ["[void]testNullInputStream()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTest ValidatorResources.\n", "original_string": "public class ValidatorResourcesTest {\n\n    /**\n     * Test null Input Stream for Validator Resources.\n     */\n    @Test\n    public void testNullInputStream() throws Exception {\n\n        try {\n            new ValidatorResources((InputStream) null);\n            fail(\"Expected IllegalArgumentException\");\n        } catch (final IllegalArgumentException e) {\n            // expected result\n            // System.out.println(\"Exception: \" + e);\n        }\n\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/ValidatorResources_addFormSetTest.java.ValidatorResources_addFormSetTest", "name": "ValidatorResources_addFormSetTest", "file_path": "src/test/java/org/apache/commons/validator/ValidatorResources_addFormSetTest.java", "superclasses": "", "methods": ["[void]testAddFormSetDefault()", "[void]testAddFormSetWithLocale()", "[void]testAddFormSetOverrideDefault()", "[void]testAddFormSetOverrideWithLocale()", "[void]testAddFormSetNoOverride()"], "method_uris": ["src/test/java/org/apache/commons/validator/ValidatorResources_addFormSetTest.java.ValidatorResources_addFormSetTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ValidatorResources_addFormSetTest {\n\n    private ValidatorResources resources;\n\n    @BeforeEach\n    public void setUp() {\n        resources = new ValidatorResources();\n    }\n\n    @Test\n    public void testAddFormSetDefault() {\n        FormSet fs = new FormSet();\n        fs.setLanguage(\"\");\n        fs.setCountry(\"\");\n        fs.setVariant(\"\");\n\n        resources.addFormSet(fs);\n\n        assertEquals(fs, resources.defaultFormSet, \"Default FormSet should be set.\");\n    }\n\n    @Test\n    public void testAddFormSetWithLocale() {\n        FormSet fs = new FormSet();\n        fs.setLanguage(\"en\");\n        fs.setCountry(\"US\");\n        fs.setVariant(\"\");\n\n        resources.addFormSet(fs);\n\n        String key = resources.buildKey(fs);\n        assertEquals(fs, resources.getFormSets().get(key), \"FormSet should be added with locale key.\");\n    }\n\n    @Test\n    public void testAddFormSetOverrideDefault() {\n        FormSet fs1 = new FormSet();\n        fs1.setLanguage(\"\");\n        fs1.setCountry(\"\");\n        fs1.setVariant(\"\");\n\n        FormSet fs2 = new FormSet();\n        fs2.setLanguage(\"\");\n        fs2.setCountry(\"\");\n        fs2.setVariant(\"\");\n\n        resources.addFormSet(fs1);\n        resources.addFormSet(fs2);\n\n        assertEquals(fs2, resources.defaultFormSet, \"Default FormSet should be overridden.\");\n    }\n\n    @Test\n    public void testAddFormSetOverrideWithLocale() {\n        FormSet fs1 = new FormSet();\n        fs1.setLanguage(\"en\");\n        fs1.setCountry(\"US\");\n        fs1.setVariant(\"\");\n\n        FormSet fs2 = new FormSet();\n        fs2.setLanguage(\"en\");\n        fs2.setCountry(\"US\");\n        fs2.setVariant(\"\");\n\n        resources.addFormSet(fs1);\n        resources.addFormSet(fs2);\n\n        String key = resources.buildKey(fs1);\n        assertEquals(fs2, resources.getFormSets().get(key), \"FormSet should be overridden with locale key.\");\n    }\n\n    @Test\n    public void testAddFormSetNoOverride() {\n        FormSet fs1 = new FormSet();\n        fs1.setLanguage(\"en\");\n        fs1.setCountry(\"US\");\n        fs1.setVariant(\"\");\n\n        FormSet fs2 = new FormSet();\n        fs2.setLanguage(\"en\");\n        fs2.setCountry(\"GB\");\n        fs2.setVariant(\"\");\n\n        resources.addFormSet(fs1);\n        resources.addFormSet(fs2);\n\n        String key1 = resources.buildKey(fs1);\n        String key2 = resources.buildKey(fs2);\n        assertEquals(fs1, resources.getFormSets().get(key1), \"FormSet should not be overridden.\");\n        assertEquals(fs2, resources.getFormSets().get(key2), \"FormSet should not be overridden.\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ValidatorResources resources;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ValidatorResources", "name": "resources", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/FloatTest.java.FloatTest", "name": "FloatTest", "file_path": "src/test/java/org/apache/commons/validator/FloatTest.java", "superclasses": "AbstractNumberTest", "methods": ["[void]testFloat()", "[void]testFloatFailure()", "[void]testFloatMax()", "[void]testFloatMin()"], "method_uris": ["src/test/java/org/apache/commons/validator/FloatTest.java.FloatTest.[]FloatTest()"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test for {@code float} validations.\n", "original_string": "public class FloatTest extends AbstractNumberTest {\n\n    public FloatTest() {\n        action = \"float\";\n        formKey = \"floatForm\";\n    }\n\n    /**\n     * Tests the float validation.\n     */\n    @Test\n    public void testFloat() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(\"0\");\n\n        valueTest(info, true);\n    }\n\n    /**\n     * Tests the float validation failure.\n     */\n    @Test\n    public void testFloatFailure() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n\n        valueTest(info, false);\n    }\n\n    /**\n     * Tests the float validation.\n     */\n    @Test\n    public void testFloatMax() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Float.toString(Float.MAX_VALUE));\n\n        valueTest(info, true);\n    }\n\n    /**\n     * Tests the float validation.\n     */\n    @Test\n    public void testFloatMin() throws ValidatorException {\n        // Create bean to run test on.\n        final ValueBean info = new ValueBean();\n        info.setValue(Float.toString(Float.MIN_VALUE));\n\n        valueTest(info, true);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/RequiredIfTest.java.RequiredIfTest", "name": "RequiredIfTest", "file_path": "src/test/java/org/apache/commons/validator/RequiredIfTest.java", "superclasses": "AbstractCommonTest", "methods": ["[void]testRequired()", "[void]testRequiredFirstName()", "[void]testRequiredFirstNameBlank()", "[void]testRequiredLastName()", "[void]testRequiredLastNameBlank()"], "method_uris": ["src/test/java/org/apache/commons/validator/RequiredIfTest.java.RequiredIfTest.[void]setUp()", "src/test/java/org/apache/commons/validator/RequiredIfTest.java.RequiredIfTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test.\n", "original_string": "public class RequiredIfTest extends AbstractCommonTest {\n\n    /**\n     * The key used to retrieve the set of validation rules from the xml file.\n     */\n    protected static final String FORM_KEY = \"nameForm\";\n\n    /**\n     * The key used to retrieve the validator action.\n     */\n    protected static final String ACTION = \"requiredif\";\n\n    /**\n     * Load {@code ValidatorResources} from validator-requiredif.xml.\n     */\n    @BeforeEach\n    protected void setUp() throws IOException, SAXException {\n        // Load resources\n        loadResources(\"RequiredIfTest-config.xml\");\n    }\n\n    @AfterEach\n    protected void tearDown() {\n    }\n\n    /**\n     * With nothing provided, we should pass since the fields only fail on null if the other field is non-blank.\n     */\n    @Test\n    public void testRequired() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        // throws ValidatorException,\n        // but we aren't catching for testing\n        // since no validation methods we use\n        // throw this\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), () -> \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(firstNameResult.isValid(ACTION), () -> \"First Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n\n        assertNotNull(lastNameResult, \"Last Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), () -> \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(lastNameResult.isValid(ACTION), () -> \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n    }\n\n    /**\n     * Tests the required validation for last name.\n     */\n    @Test\n    public void testRequiredFirstName() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"Test\");\n        name.setLastName(\"Test\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), () -> \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(firstNameResult.isValid(ACTION), () -> \"First Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n\n        assertNotNull(lastNameResult, \"Last Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), () -> \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(lastNameResult.isValid(ACTION), () -> \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n    }\n\n    /**\n     * Tests the required validation for first name if it is blank.\n     */\n    @Test\n    public void testRequiredFirstNameBlank() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"\");\n        name.setLastName(\"Test\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), () -> \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!firstNameResult.isValid(ACTION), () -> \"First Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n\n        assertNotNull(lastNameResult, \"Last Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), () -> \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(lastNameResult.isValid(ACTION), () -> \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n    }\n\n    /**\n     * Tests the required validation for last name.\n     */\n    @Test\n    public void testRequiredLastName() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"Joe\");\n        name.setLastName(\"Smith\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(firstNameResult.isValid(ACTION), \"First Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n\n        assertNotNull(lastNameResult, \"Last Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), () -> \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(lastNameResult.isValid(ACTION), () -> \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n\n    }\n\n    /**\n     * Tests the required validation for last name if it is blank.\n     */\n    @Test\n    public void testRequiredLastNameBlank() throws ValidatorException {\n        // Create bean to run test on.\n        final NameBean name = new NameBean();\n        name.setFirstName(\"Joe\");\n        name.setLastName(\"\");\n\n        // Construct validator based on the loaded resources\n        // and the form key\n        final Validator validator = new Validator(resources, FORM_KEY);\n        // add the name bean to the validator as a resource\n        // for the validations to be performed on.\n        validator.setParameter(Validator.BEAN_PARAM, name);\n\n        // Get results of the validation.\n        final ValidatorResults results = validator.validate();\n\n        assertNotNull(results, \"Results are null.\");\n\n        final ValidatorResult firstNameResult = results.getValidatorResult(\"firstName\");\n        final ValidatorResult lastNameResult = results.getValidatorResult(\"lastName\");\n\n        assertNotNull(firstNameResult, \"First Name ValidatorResult should not be null.\");\n        assertTrue(firstNameResult.containsAction(ACTION), () -> \"First Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(firstNameResult.isValid(ACTION), () -> \"First Name ValidatorResult for the '\" + ACTION + \"' action should have passed.\");\n\n        assertNotNull(lastNameResult, \"Last Name ValidatorResult should not be null.\");\n        assertTrue(lastNameResult.containsAction(ACTION), () -> \"Last Name ValidatorResult should contain the '\" + ACTION + \"' action.\");\n        assertTrue(!lastNameResult.isValid(ACTION), () -> \"Last Name ValidatorResult for the '\" + ACTION + \"' action should have failed.\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final String FORM_KEY = \"nameForm\";", "docstring": "\nThe key used to retrieve the set of validation rules from the xml file.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "FORM_KEY = \"nameForm\"", "syntax_pass": true}, {"attribute_expression": "protected static final String ACTION = \"requiredif\";", "docstring": "\nThe key used to retrieve the validator action.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "ACTION = \"requiredif\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/RegexValidator_toStringTest.java.RegexValidator_toStringTest", "name": "RegexValidator_toStringTest", "file_path": "src/test/java/org/apache/commons/validator/routines/RegexValidator_toStringTest.java", "superclasses": "", "methods": ["[void]testToStringWithMultipleRegex()", "[void]testToStringWithSingleRegex()", "[void]testToStringWithEmptyRegex()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/RegexValidator_toStringTest.java.RegexValidator_toStringTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RegexValidator_toStringTest {\n\n    private static final String[] MULTIPLE_REGEX = {\"^[a-z]+$\", \"^[0-9]+$\", \"^[A-Z]+$\"};\n    private RegexValidator regexValidator;\n\n    @BeforeEach\n    public void setUp() {\n        regexValidator = new RegexValidator(MULTIPLE_REGEX);\n    }\n\n    @Test\n    public void testToStringWithMultipleRegex() {\n        String expected = \"RegexValidator{^[a-z]+$,^[0-9]+$,^[A-Z]+$}\";\n        assertEquals(expected, regexValidator.toString());\n    }\n\n    @Test\n    public void testToStringWithSingleRegex() {\n        regexValidator = new RegexValidator(\"^[a-z]+$\");\n        String expected = \"RegexValidator{^[a-z]+$}\";\n        assertEquals(expected, regexValidator.toString());\n    }\n\n    @Test\n    public void testToStringWithEmptyRegex() {\n        regexValidator = new RegexValidator(new String[]{\"^$\"});\n        String expected = \"RegexValidator{^$}\";\n        assertEquals(expected, regexValidator.toString());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String[] MULTIPLE_REGEX = {\"^[a-z]+$\", \"^[0-9]+$\", \"^[A-Z]+$\"};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "MULTIPLE_REGEX = {\"^[a-z]+$\", \"^[0-9]+$\", \"^[A-Z]+$\"}", "syntax_pass": true}, {"attribute_expression": "private RegexValidator regexValidator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RegexValidator", "name": "regexValidator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/ISINValidatorTest.java.ISINValidatorTest", "name": "ISINValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/ISINValidatorTest.java", "superclasses": "", "methods": ["[void]testInvalidFalse()", "[void]testInvalidTrue()", "[void]testIsValidFalse()", "[void]testIsValidTrue()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests {@link ISINValidator}.\n", "original_string": "public class ISINValidatorTest {\n\n    private static final ISINValidator VALIDATOR_TRUE = ISINValidator.getInstance(true);\n\n    private static final ISINValidator VALIDATOR_FALSE = ISINValidator.getInstance(false);\n\n    // @formatter:off\n    private final String[] validFormat = {\n            \"US0378331005\",\n            \"BMG8571G1096\",\n            \"AU0000XVGZA3\",\n            \"GB0002634946\",\n            \"FR0004026250\",\n            \"DK0009763344\",\n            \"GB00B03MLX29\",\n            \"US7562071065\",\n            \"US56845T3059\",\n            \"LU0327357389\",\n            \"US032511BN64\",\n            \"INE112A01023\",\n            \"EZ0000000003\", // Invented; for use in ISINValidator\n            \"EU000A0VUCF1\",\n            \"XA2053913989\",\n            \"XB0000000008\",\n            \"XC0009698371\",\n            \"XD0000000006\",\n            \"XF0000000004\",\n            \"QS0000000008\",\n            \"QT0000000007\",\n            \"QW0000000002\",\n            \"XS0000000009\", };\n\n    private final String[] invalidFormat = { null, \"\", // empty\n            \"   \", // empty\n            \"US037833100O\", // proper check digit is '5', see above\n            \"BMG8571G109D\", // proper check digit is '6', see above\n            \"AU0000XVGZAD\", // proper check digit is '3', see above\n            \"GB000263494I\", // proper check digit is '6', see above\n            \"FR000402625C\", // proper check digit is '0', see above\n            \"DK000976334H\", // proper check digit is '4', see above\n            \"3133EHHF3\", // see VALIDATOR-422 Valid check-digit, but not valid ISIN\n            \"AU0000xvgzA3\", // disallow lower case NSIN\n            \"gb0002634946\", // disallow lower case ISO code\n    };\n\n    // Invalid codes if country checking is enabled\n    private final String[] invalidFormatTrue = { \"AB0000000006\", // Invalid country code\n    };\n\n    @Test\n    public void testInvalidFalse() {\n        for (final String f : invalidFormat) {\n            assertFalse(VALIDATOR_FALSE.isValid(f), f);\n        }\n    }\n\n    @Test\n    public void testInvalidTrue() {\n        for (final String f : invalidFormat) {\n            assertFalse(VALIDATOR_TRUE.isValid(f), f);\n        }\n        for (final String f : invalidFormatTrue) {\n            assertFalse(VALIDATOR_TRUE.isValid(f), f);\n        }\n    }\n\n    @Test\n    public void testIsValidFalse() {\n        for (final String f : validFormat) {\n            assertTrue(VALIDATOR_FALSE.isValid(f), f);\n        }\n    }\n\n    @Test\n    public void testIsValidTrue() {\n        for (final String f : validFormat) {\n            assertTrue(VALIDATOR_TRUE.isValid(f), f);\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final ISINValidator VALIDATOR_TRUE = ISINValidator.getInstance(true);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ISINValidator", "name": "VALIDATOR_TRUE = ISINValidator.getInstance(true)", "syntax_pass": true}, {"attribute_expression": "private static final ISINValidator VALIDATOR_FALSE = ISINValidator.getInstance(false);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ISINValidator", "name": "VALIDATOR_FALSE = ISINValidator.getInstance(false)", "syntax_pass": true}, {"attribute_expression": "private final String[] validFormat = {\n            \"US0378331005\",\n            \"BMG8571G1096\",\n            \"AU0000XVGZA3\",\n            \"GB0002634946\",\n            \"FR0004026250\",\n            \"DK0009763344\",\n            \"GB00B03MLX29\",\n            \"US7562071065\",\n            \"US56845T3059\",\n            \"LU0327357389\",\n            \"US032511BN64\",\n            \"INE112A01023\",\n            \"EZ0000000003\", // Invented; for use in ISINValidator\n            \"EU000A0VUCF1\",\n            \"XA2053913989\",\n            \"XB0000000008\",\n            \"XC0009698371\",\n            \"XD0000000006\",\n            \"XF0000000004\",\n            \"QS0000000008\",\n            \"QT0000000007\",\n            \"QW0000000002\",\n            \"XS0000000009\", };", "docstring": " @formatter:off", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String[]", "name": "validFormat = {\n            \"US0378331005\",\n            \"BMG8571G1096\",\n            \"AU0000XVGZA3\",\n            \"GB0002634946\",\n            \"FR0004026250\",\n            \"DK0009763344\",\n            \"GB00B03MLX29\",\n            \"US7562071065\",\n            \"US56845T3059\",\n            \"LU0327357389\",\n            \"US032511BN64\",\n            \"INE112A01023\",\n            \"EZ0000000003\", // Invented; for use in ISINValidator\n            \"EU000A0VUCF1\",\n            \"XA2053913989\",\n            \"XB0000000008\",\n            \"XC0009698371\",\n            \"XD0000000006\",\n            \"XF0000000004\",\n            \"QS0000000008\",\n            \"QT0000000007\",\n            \"QW0000000002\",\n            \"XS0000000009\", }", "syntax_pass": true}, {"attribute_expression": "private final String[] invalidFormat = { null, \"\", // empty\n            \"   \", // empty\n            \"US037833100O\", // proper check digit is '5', see above\n            \"BMG8571G109D\", // proper check digit is '6', see above\n            \"AU0000XVGZAD\", // proper check digit is '3', see above\n            \"GB000263494I\", // proper check digit is '6', see above\n            \"FR000402625C\", // proper check digit is '0', see above\n            \"DK000976334H\", // proper check digit is '4', see above\n            \"3133EHHF3\", // see VALIDATOR-422 Valid check-digit, but not valid ISIN\n            \"AU0000xvgzA3\", // disallow lower case NSIN\n            \"gb0002634946\", // disallow lower case ISO code\n    };", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String[]", "name": "invalidFormat = { null, \"\", // empty\n            \"   \", // empty\n            \"US037833100O\", // proper check digit is '5', see above\n            \"BMG8571G109D\", // proper check digit is '6', see above\n            \"AU0000XVGZAD\", // proper check digit is '3', see above\n            \"GB000263494I\", // proper check digit is '6', see above\n            \"FR000402625C\", // proper check digit is '0', see above\n            \"DK000976334H\", // proper check digit is '4', see above\n            \"3133EHHF3\", // see VALIDATOR-422 Valid check-digit, but not valid ISIN\n            \"AU0000xvgzA3\", // disallow lower case NSIN\n            \"gb0002634946\", // disallow lower case ISO code\n    }", "syntax_pass": true}, {"attribute_expression": "private final String[] invalidFormatTrue = { \"AB0000000006\", // Invalid country code\n    };", "docstring": " Invalid codes if country checking is enabled", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String[]", "name": "invalidFormatTrue = { \"AB0000000006\", // Invalid country code\n    }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/InetAddressValidatorTest.java.InetAddressValidatorTest", "name": "InetAddressValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/InetAddressValidatorTest.java", "superclasses": "", "methods": ["[void]testBrokenInetAddresses()", "[void]testInetAddressesByClass()", "[void]testInetAddressesFromTheWild()", "[void]testIPv6()", "[void]testReservedInetAddresses()", "[void]testValidator335()", "[void]testValidator419()", "[void]testValidator445()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/InetAddressValidatorTest.java.InetAddressValidatorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTest cases for InetAddressValidator.\n", "original_string": "public class InetAddressValidatorTest {\n\n    private InetAddressValidator validator;\n\n    @BeforeEach\n    protected void setUp() {\n        validator = new InetAddressValidator();\n    }\n\n    /**\n     * Test obviously broken IPs.\n     */\n    @Test\n    public void testBrokenInetAddresses() {\n        assertFalse(validator.isValid(\"124.14.32.abc\"), \"IP with characters should be invalid\");\n        // TODO: there is some debate as to whether leading zeros should be allowed\n        // They are ambiguous: does the leading 0 mean octal?\n        assertFalse(validator.isValid(\"124.14.32.01\"), \"IP with leading zeroes should be invalid\");\n        assertFalse(validator.isValid(\"23.64.12\"), \"IP with three groups should be invalid\");\n        assertFalse(validator.isValid(\"26.34.23.77.234\"), \"IP with five groups should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"\"), \"IP empty string should be invalid\"); // empty string\n    }\n\n    /**\n     * Test valid and invalid IPs from each address class.\n     */\n    @Test\n    public void testInetAddressesByClass() {\n        assertTrue(validator.isValid(\"24.25.231.12\"), \"class A IP should be valid\");\n        assertFalse(validator.isValid(\"2.41.32.324\"), \"illegal class A IP should be invalid\");\n\n        assertTrue(validator.isValid(\"135.14.44.12\"), \"class B IP should be valid\");\n        assertFalse(validator.isValid(\"154.123.441.123\"), \"illegal class B IP should be invalid\");\n\n        assertTrue(validator.isValid(\"213.25.224.32\"), \"class C IP should be valid\");\n        assertFalse(validator.isValid(\"201.543.23.11\"), \"illegal class C IP should be invalid\");\n\n        assertTrue(validator.isValid(\"229.35.159.6\"), \"class D IP should be valid\");\n        assertFalse(validator.isValid(\"231.54.11.987\"), \"illegal class D IP should be invalid\");\n\n        assertTrue(validator.isValid(\"248.85.24.92\"), \"class E IP should be valid\");\n        assertFalse(validator.isValid(\"250.21.323.48\"), \"illegal class E IP should be invalid\");\n    }\n\n    /**\n     * Test IPs that point to real, well-known hosts (without actually looking them up).\n     */\n    @Test\n    public void testInetAddressesFromTheWild() {\n        assertTrue(validator.isValid(\"140.211.11.130\"), \"www.apache.org IP should be valid\");\n        assertTrue(validator.isValid(\"72.14.253.103\"), \"www.l.google.com IP should be valid\");\n        assertTrue(validator.isValid(\"199.232.41.5\"), \"fsf.org IP should be valid\");\n        assertTrue(validator.isValid(\"216.35.123.87\"), \"appscs.ign.com IP should be valid\");\n    }\n\n    /**\n     * Test IPv6 addresses.\n     * <p>\n     * These tests were ported from a <a href=\"https://download.dartware.com/thirdparty/test-ipv6-regex.pl\">Perl script</a>.\n     * </p>\n     */\n    @Test\n    public void testIPv6() {\n        // The original Perl script contained a lot of duplicate tests.\n        // I removed the duplicates I noticed, but there may be more.\n        assertFalse(validator.isValidInet6Address(\"\"), \"IPV6 empty string should be invalid\"); // empty string\n        assertTrue(validator.isValidInet6Address(\"::1\"), \"IPV6 ::1 should be valid\"); // loopback, compressed, non-routable\n        assertTrue(validator.isValidInet6Address(\"::\"), \"IPV6 :: should be valid\"); // unspecified, compressed, non-routable\n        assertTrue(validator.isValidInet6Address(\"0:0:0:0:0:0:0:1\"), \"IPV6 0:0:0:0:0:0:0:1 should be valid\"); // loopback, full\n        assertTrue(validator.isValidInet6Address(\"0:0:0:0:0:0:0:0\"), \"IPV6 0:0:0:0:0:0:0:0 should be valid\"); // unspecified, full\n        assertTrue(validator.isValidInet6Address(\"2001:DB8:0:0:8:800:200C:417A\"), \"IPV6 2001:DB8:0:0:8:800:200C:417A should be valid\"); // unicast, full\n        assertTrue(validator.isValidInet6Address(\"FF01:0:0:0:0:0:0:101\"), \"IPV6 FF01:0:0:0:0:0:0:101 should be valid\"); // multicast, full\n        assertTrue(validator.isValidInet6Address(\"2001:DB8::8:800:200C:417A\"), \"IPV6 2001:DB8::8:800:200C:417A should be valid\"); // unicast, compressed\n        assertTrue(validator.isValidInet6Address(\"FF01::101\"), \"IPV6 FF01::101 should be valid\"); // multicast, compressed\n        assertFalse(validator.isValidInet6Address(\"2001:DB8:0:0:8:800:200C:417A:221\"), \"IPV6 2001:DB8:0:0:8:800:200C:417A:221 should be invalid\"); // unicast,\n                                                                                                                                                   // full\n        assertFalse(validator.isValidInet6Address(\"FF01::101::2\"), \"IPV6 FF01::101::2 should be invalid\"); // multicast, compressed\n        assertTrue(validator.isValidInet6Address(\"fe80::217:f2ff:fe07:ed62\"), \"IPV6 fe80::217:f2ff:fe07:ed62 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"2001:0000:1234:0000:0000:C1C0:ABCD:0876\"), \"IPV6 2001:0000:1234:0000:0000:C1C0:ABCD:0876 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"3ffe:0b00:0000:0000:0001:0000:0000:000a\"), \"IPV6 3ffe:0b00:0000:0000:0001:0000:0000:000a should be valid\");\n        assertTrue(validator.isValidInet6Address(\"FF02:0000:0000:0000:0000:0000:0000:0001\"), \"IPV6 FF02:0000:0000:0000:0000:0000:0000:0001 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"0000:0000:0000:0000:0000:0000:0000:0001\"), \"IPV6 0000:0000:0000:0000:0000:0000:0000:0001 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"0000:0000:0000:0000:0000:0000:0000:0000\"), \"IPV6 0000:0000:0000:0000:0000:0000:0000:0000 should be valid\");\n        assertFalse(validator.isValidInet6Address(\"02001:0000:1234:0000:0000:C1C0:ABCD:0876\"),\n                \"IPV6 02001:0000:1234:0000:0000:C1C0:ABCD:0876 should be invalid\"); // extra 0 not allowed!\n        assertFalse(validator.isValidInet6Address(\"2001:0000:1234:0000:00001:C1C0:ABCD:0876\"),\n                \"IPV6 2001:0000:1234:0000:00001:C1C0:ABCD:0876 should be invalid\"); // extra 0 not allowed!\n        assertFalse(validator.isValidInet6Address(\"2001:0000:1234:0000:0000:C1C0:ABCD:0876 0\"),\n                \"IPV6 2001:0000:1234:0000:0000:C1C0:ABCD:0876 0 should be invalid\"); // junk after valid address\n        assertFalse(validator.isValidInet6Address(\"2001:0000:1234: 0000:0000:C1C0:ABCD:0876\"),\n                \"IPV6 2001:0000:1234: 0000:0000:C1C0:ABCD:0876 should be invalid\"); // internal space\n        assertFalse(validator.isValidInet6Address(\"3ffe:0b00:0000:0001:0000:0000:000a\"), \"IPV6 3ffe:0b00:0000:0001:0000:0000:000a should be invalid\"); // seven\n                                                                                                                                                       // segments\n        assertFalse(validator.isValidInet6Address(\"FF02:0000:0000:0000:0000:0000:0000:0000:0001\"),\n                \"IPV6 FF02:0000:0000:0000:0000:0000:0000:0000:0001 should be invalid\"); // nine segments\n        assertFalse(validator.isValidInet6Address(\"3ffe:b00::1::a\"), \"IPV6 3ffe:b00::1::a should be invalid\"); // double \"::\"\n        assertFalse(validator.isValidInet6Address(\"::1111:2222:3333:4444:5555:6666::\"), \"IPV6 ::1111:2222:3333:4444:5555:6666:: should be invalid\"); // double\n                                                                                                                                                     // \"::\"\n        assertTrue(validator.isValidInet6Address(\"2::10\"), \"IPV6 2::10 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"ff02::1\"), \"IPV6 ff02::1 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"fe80::\"), \"IPV6 fe80:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"2002::\"), \"IPV6 2002:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"2001:db8::\"), \"IPV6 2001:db8:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"2001:0db8:1234::\"), \"IPV6 2001:0db8:1234:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::ffff:0:0\"), \"IPV6 ::ffff:0:0 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3:4:5:6:7:8\"), \"IPV6 1:2:3:4:5:6:7:8 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3:4:5:6::8\"), \"IPV6 1:2:3:4:5:6::8 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3:4:5::8\"), \"IPV6 1:2:3:4:5::8 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3:4::8\"), \"IPV6 1:2:3:4::8 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3::8\"), \"IPV6 1:2:3::8 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2::8\"), \"IPV6 1:2::8 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1::8\"), \"IPV6 1::8 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1::2:3:4:5:6:7\"), \"IPV6 1::2:3:4:5:6:7 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1::2:3:4:5:6\"), \"IPV6 1::2:3:4:5:6 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1::2:3:4:5\"), \"IPV6 1::2:3:4:5 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1::2:3:4\"), \"IPV6 1::2:3:4 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1::2:3\"), \"IPV6 1::2:3 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::2:3:4:5:6:7:8\"), \"IPV6 ::2:3:4:5:6:7:8 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::2:3:4:5:6:7\"), \"IPV6 ::2:3:4:5:6:7 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::2:3:4:5:6\"), \"IPV6 ::2:3:4:5:6 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::2:3:4:5\"), \"IPV6 ::2:3:4:5 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::2:3:4\"), \"IPV6 ::2:3:4 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::2:3\"), \"IPV6 ::2:3 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::8\"), \"IPV6 ::8 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3:4:5:6::\"), \"IPV6 1:2:3:4:5:6:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3:4:5::\"), \"IPV6 1:2:3:4:5:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3:4::\"), \"IPV6 1:2:3:4:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3::\"), \"IPV6 1:2:3:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2::\"), \"IPV6 1:2:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1::\"), \"IPV6 1:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3:4:5::7:8\"), \"IPV6 1:2:3:4:5::7:8 should be valid\");\n        assertFalse(validator.isValidInet6Address(\"1:2:3::4:5::7:8\"), \"IPV6 1:2:3::4:5::7:8 should be invalid\"); // Double \"::\"\n        assertFalse(validator.isValidInet6Address(\"12345::6:7:8\"), \"IPV6 12345::6:7:8 should be invalid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3:4::7:8\"), \"IPV6 1:2:3:4::7:8 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3::7:8\"), \"IPV6 1:2:3::7:8 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2::7:8\"), \"IPV6 1:2::7:8 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1::7:8\"), \"IPV6 1::7:8 should be valid\");\n        // IPv4 addresses as dotted-quads\n        assertTrue(validator.isValidInet6Address(\"1:2:3:4:5:6:1.2.3.4\"), \"IPV6 1:2:3:4:5:6:1.2.3.4 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3:4:5::1.2.3.4\"), \"IPV6 1:2:3:4:5::1.2.3.4 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3:4::1.2.3.4\"), \"IPV6 1:2:3:4::1.2.3.4 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3::1.2.3.4\"), \"IPV6 1:2:3::1.2.3.4 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2::1.2.3.4\"), \"IPV6 1:2::1.2.3.4 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1::1.2.3.4\"), \"IPV6 1::1.2.3.4 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3:4::5:1.2.3.4\"), \"IPV6 1:2:3:4::5:1.2.3.4 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2:3::5:1.2.3.4\"), \"IPV6 1:2:3::5:1.2.3.4 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1:2::5:1.2.3.4\"), \"IPV6 1:2::5:1.2.3.4 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1::5:1.2.3.4\"), \"IPV6 1::5:1.2.3.4 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1::5:11.22.33.44\"), \"IPV6 1::5:11.22.33.44 should be valid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:400.2.3.4\"), \"IPV6 1::5:400.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:260.2.3.4\"), \"IPV6 1::5:260.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:256.2.3.4\"), \"IPV6 1::5:256.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:1.256.3.4\"), \"IPV6 1::5:1.256.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:1.2.256.4\"), \"IPV6 1::5:1.2.256.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:1.2.3.256\"), \"IPV6 1::5:1.2.3.256 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:300.2.3.4\"), \"IPV6 1::5:300.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:1.300.3.4\"), \"IPV6 1::5:1.300.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:1.2.300.4\"), \"IPV6 1::5:1.2.300.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:1.2.3.300\"), \"IPV6 1::5:1.2.3.300 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:900.2.3.4\"), \"IPV6 1::5:900.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:1.900.3.4\"), \"IPV6 1::5:1.900.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:1.2.900.4\"), \"IPV6 1::5:1.2.900.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:1.2.3.900\"), \"IPV6 1::5:1.2.3.900 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:300.300.300.300\"), \"IPV6 1::5:300.300.300.300 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::5:3000.30.30.30\"), \"IPV6 1::5:3000.30.30.30 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::400.2.3.4\"), \"IPV6 1::400.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::260.2.3.4\"), \"IPV6 1::260.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::256.2.3.4\"), \"IPV6 1::256.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::1.256.3.4\"), \"IPV6 1::1.256.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::1.2.256.4\"), \"IPV6 1::1.2.256.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::1.2.3.256\"), \"IPV6 1::1.2.3.256 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::300.2.3.4\"), \"IPV6 1::300.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::1.300.3.4\"), \"IPV6 1::1.300.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::1.2.300.4\"), \"IPV6 1::1.2.300.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::1.2.3.300\"), \"IPV6 1::1.2.3.300 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::900.2.3.4\"), \"IPV6 1::900.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::1.900.3.4\"), \"IPV6 1::1.900.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::1.2.900.4\"), \"IPV6 1::1.2.900.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::1.2.3.900\"), \"IPV6 1::1.2.3.900 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::300.300.300.300\"), \"IPV6 1::300.300.300.300 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::3000.30.30.30\"), \"IPV6 1::3000.30.30.30 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::400.2.3.4\"), \"IPV6 ::400.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::260.2.3.4\"), \"IPV6 ::260.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::256.2.3.4\"), \"IPV6 ::256.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::1.256.3.4\"), \"IPV6 ::1.256.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::1.2.256.4\"), \"IPV6 ::1.2.256.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::1.2.3.256\"), \"IPV6 ::1.2.3.256 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::300.2.3.4\"), \"IPV6 ::300.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::1.300.3.4\"), \"IPV6 ::1.300.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::1.2.300.4\"), \"IPV6 ::1.2.300.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::1.2.3.300\"), \"IPV6 ::1.2.3.300 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::900.2.3.4\"), \"IPV6 ::900.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::1.900.3.4\"), \"IPV6 ::1.900.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::1.2.900.4\"), \"IPV6 ::1.2.900.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::1.2.3.900\"), \"IPV6 ::1.2.3.900 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::300.300.300.300\"), \"IPV6 ::300.300.300.300 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::3000.30.30.30\"), \"IPV6 ::3000.30.30.30 should be invalid\");\n        assertTrue(validator.isValidInet6Address(\"fe80::217:f2ff:254.7.237.98\"), \"IPV6 fe80::217:f2ff:254.7.237.98 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::ffff:192.168.1.26\"), \"IPV6 ::ffff:192.168.1.26 should be valid\");\n        assertFalse(validator.isValidInet6Address(\"2001:1:1:1:1:1:255Z255X255Y255\"), \"IPV6 2001:1:1:1:1:1:255Z255X255Y255 should be invalid\"); // garbage\n                                                                                                                                               // instead of \".\"\n                                                                                                                                               // in IPv4\n        assertFalse(validator.isValidInet6Address(\"::ffff:192x168.1.26\"), \"IPV6 ::ffff:192x168.1.26 should be invalid\"); // ditto\n        assertTrue(validator.isValidInet6Address(\"::ffff:192.168.1.1\"), \"IPV6 ::ffff:192.168.1.1 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"0:0:0:0:0:0:13.1.68.3\"), \"IPV6 0:0:0:0:0:0:13.1.68.3 should be valid\"); // IPv4-compatible IPv6 address, full,\n                                                                                                                          // deprecated\n        assertTrue(validator.isValidInet6Address(\"0:0:0:0:0:FFFF:129.144.52.38\"), \"IPV6 0:0:0:0:0:FFFF:129.144.52.38 should be valid\"); // IPv4-mapped IPv6\n                                                                                                                                        // address, full\n        assertTrue(validator.isValidInet6Address(\"::13.1.68.3\"), \"IPV6 ::13.1.68.3 should be valid\"); // IPv4-compatible IPv6 address, compressed, deprecated\n        assertTrue(validator.isValidInet6Address(\"::FFFF:129.144.52.38\"), \"IPV6 ::FFFF:129.144.52.38 should be valid\"); // IPv4-mapped IPv6 address, compressed\n        assertTrue(validator.isValidInet6Address(\"fe80:0:0:0:204:61ff:254.157.241.86\"), \"IPV6 fe80:0:0:0:204:61ff:254.157.241.86 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"fe80::204:61ff:254.157.241.86\"), \"IPV6 fe80::204:61ff:254.157.241.86 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::ffff:12.34.56.78\"), \"IPV6 ::ffff:12.34.56.78 should be valid\");\n        assertFalse(validator.isValidInet6Address(\"::ffff:2.3.4\"), \"IPV6 ::ffff:2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::ffff:257.1.2.3\"), \"IPV6 ::ffff:257.1.2.3 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1.2.3.4\"), \"IPV6 1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1.2.3.4:1111:2222:3333:4444::5555\"), \"IPV6 1.2.3.4:1111:2222:3333:4444::5555 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1.2.3.4:1111:2222:3333::5555\"), \"IPV6 1.2.3.4:1111:2222:3333::5555 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1.2.3.4:1111:2222::5555\"), \"IPV6 1.2.3.4:1111:2222::5555 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1.2.3.4:1111::5555\"), \"IPV6 1.2.3.4:1111::5555 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1.2.3.4::5555\"), \"IPV6 1.2.3.4::5555 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1.2.3.4::\"), \"IPV6 1.2.3.4:: should be invalid\");\n        // Testing IPv4 addresses represented as dotted-quads\n        // Leading zeroes in IPv4 addresses not allowed: some systems treat the leading \"0\" in \".086\" as the start of an octal number\n        // Update: The BNF in RFC-3986 explicitly defines the dec-octet (for IPv4 addresses) not to have a leading zero\n        assertFalse(validator.isValidInet6Address(\"fe80:0000:0000:0000:0204:61ff:254.157.241.086\"),\n                \"IPV6 fe80:0000:0000:0000:0204:61ff:254.157.241.086 should be invalid\");\n        assertTrue(validator.isValidInet6Address(\"::ffff:192.0.2.128\"), \"IPV6 ::ffff:192.0.2.128 should be valid\"); // but this is OK, since there's a single\n                                                                                                                    // digit\n        assertFalse(validator.isValidInet6Address(\"XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:1.2.3.4\"), \"IPV6 XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:00.00.00.00\"),\n                \"IPV6 1111:2222:3333:4444:5555:6666:00.00.00.00 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:000.000.000.000\"),\n                \"IPV6 1111:2222:3333:4444:5555:6666:000.000.000.000 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:256.256.256.256\"),\n                \"IPV6 1111:2222:3333:4444:5555:6666:256.256.256.256 should be invalid\");\n        assertTrue(validator.isValidInet6Address(\"fe80:0000:0000:0000:0204:61ff:fe9d:f156\"), \"IPV6 fe80:0000:0000:0000:0204:61ff:fe9d:f156 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"fe80:0:0:0:204:61ff:fe9d:f156\"), \"IPV6 fe80:0:0:0:204:61ff:fe9d:f156 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"fe80::204:61ff:fe9d:f156\"), \"IPV6 fe80::204:61ff:fe9d:f156 should be valid\");\n        assertFalse(validator.isValidInet6Address(\":\"), \"IPV6 : should be invalid\");\n        assertTrue(validator.isValidInet6Address(\"::ffff:c000:280\"), \"IPV6 ::ffff:c000:280 should be valid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444::5555:\"), \"IPV6 1111:2222:3333:4444::5555: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333::5555:\"), \"IPV6 1111:2222:3333::5555: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222::5555:\"), \"IPV6 1111:2222::5555: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111::5555:\"), \"IPV6 1111::5555: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::5555:\"), \"IPV6 ::5555: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":::\"), \"IPV6 ::: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:\"), \"IPV6 1111: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444::5555\"), \"IPV6 :1111:2222:3333:4444::5555 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333::5555\"), \"IPV6 :1111:2222:3333::5555 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222::5555\"), \"IPV6 :1111:2222::5555 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111::5555\"), \"IPV6 :1111::5555 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":::5555\"), \"IPV6 :::5555 should be invalid\");\n        assertTrue(validator.isValidInet6Address(\"2001:0db8:85a3:0000:0000:8a2e:0370:7334\"), \"IPV6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"2001:db8:85a3:0:0:8a2e:370:7334\"), \"IPV6 2001:db8:85a3:0:0:8a2e:370:7334 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"2001:db8:85a3::8a2e:370:7334\"), \"IPV6 2001:db8:85a3::8a2e:370:7334 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"2001:0db8:0000:0000:0000:0000:1428:57ab\"), \"IPV6 2001:0db8:0000:0000:0000:0000:1428:57ab should be valid\");\n        assertTrue(validator.isValidInet6Address(\"2001:0db8:0000:0000:0000::1428:57ab\"), \"IPV6 2001:0db8:0000:0000:0000::1428:57ab should be valid\");\n        assertTrue(validator.isValidInet6Address(\"2001:0db8:0:0:0:0:1428:57ab\"), \"IPV6 2001:0db8:0:0:0:0:1428:57ab should be valid\");\n        assertTrue(validator.isValidInet6Address(\"2001:0db8:0:0::1428:57ab\"), \"IPV6 2001:0db8:0:0::1428:57ab should be valid\");\n        assertTrue(validator.isValidInet6Address(\"2001:0db8::1428:57ab\"), \"IPV6 2001:0db8::1428:57ab should be valid\");\n        assertTrue(validator.isValidInet6Address(\"2001:db8::1428:57ab\"), \"IPV6 2001:db8::1428:57ab should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::ffff:0c22:384e\"), \"IPV6 ::ffff:0c22:384e should be valid\");\n        assertTrue(validator.isValidInet6Address(\"2001:0db8:1234:0000:0000:0000:0000:0000\"), \"IPV6 2001:0db8:1234:0000:0000:0000:0000:0000 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"2001:0db8:1234:ffff:ffff:ffff:ffff:ffff\"), \"IPV6 2001:0db8:1234:ffff:ffff:ffff:ffff:ffff should be valid\");\n        assertTrue(validator.isValidInet6Address(\"2001:db8:a::123\"), \"IPV6 2001:db8:a::123 should be valid\");\n        assertFalse(validator.isValidInet6Address(\"123\"), \"IPV6 123 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"ldkfj\"), \"IPV6 ldkfj should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"2001::FFD3::57ab\"), \"IPV6 2001::FFD3::57ab should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"2001:db8:85a3::8a2e:37023:7334\"), \"IPV6 2001:db8:85a3::8a2e:37023:7334 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"2001:db8:85a3::8a2e:370k:7334\"), \"IPV6 2001:db8:85a3::8a2e:370k:7334 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1:2:3:4:5:6:7:8:9\"), \"IPV6 1:2:3:4:5:6:7:8:9 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1::2::3\"), \"IPV6 1::2::3 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1:::3:4:5\"), \"IPV6 1:::3:4:5 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1:2:3::4:5:6:7:8:9\"), \"IPV6 1:2:3::4:5:6:7:8:9 should be invalid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:8888\"), \"IPV6 1111:2222:3333:4444:5555:6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777::\"), \"IPV6 1111:2222:3333:4444:5555:6666:7777:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666::\"), \"IPV6 1111:2222:3333:4444:5555:6666:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333:4444:5555::\"), \"IPV6 1111:2222:3333:4444:5555:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333:4444::\"), \"IPV6 1111:2222:3333:4444:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333::\"), \"IPV6 1111:2222:3333:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222::\"), \"IPV6 1111:2222:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111::\"), \"IPV6 1111:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666::8888\"), \"IPV6 1111:2222:3333:4444:5555:6666::8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333:4444:5555::8888\"), \"IPV6 1111:2222:3333:4444:5555::8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333:4444::8888\"), \"IPV6 1111:2222:3333:4444::8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333::8888\"), \"IPV6 1111:2222:3333::8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222::8888\"), \"IPV6 1111:2222::8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111::8888\"), \"IPV6 1111::8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::8888\"), \"IPV6 ::8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333:4444:5555::7777:8888\"), \"IPV6 1111:2222:3333:4444:5555::7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333:4444::7777:8888\"), \"IPV6 1111:2222:3333:4444::7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333::7777:8888\"), \"IPV6 1111:2222:3333::7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222::7777:8888\"), \"IPV6 1111:2222::7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111::7777:8888\"), \"IPV6 1111::7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::7777:8888\"), \"IPV6 ::7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333:4444::6666:7777:8888\"), \"IPV6 1111:2222:3333:4444::6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333::6666:7777:8888\"), \"IPV6 1111:2222:3333::6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222::6666:7777:8888\"), \"IPV6 1111:2222::6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111::6666:7777:8888\"), \"IPV6 1111::6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::6666:7777:8888\"), \"IPV6 ::6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333::5555:6666:7777:8888\"), \"IPV6 1111:2222:3333::5555:6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222::5555:6666:7777:8888\"), \"IPV6 1111:2222::5555:6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111::5555:6666:7777:8888\"), \"IPV6 1111::5555:6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::5555:6666:7777:8888\"), \"IPV6 ::5555:6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222::4444:5555:6666:7777:8888\"), \"IPV6 1111:2222::4444:5555:6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111::4444:5555:6666:7777:8888\"), \"IPV6 1111::4444:5555:6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::4444:5555:6666:7777:8888\"), \"IPV6 ::4444:5555:6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111::3333:4444:5555:6666:7777:8888\"), \"IPV6 1111::3333:4444:5555:6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::3333:4444:5555:6666:7777:8888\"), \"IPV6 ::3333:4444:5555:6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::2222:3333:4444:5555:6666:7777:8888\"), \"IPV6 ::2222:3333:4444:5555:6666:7777:8888 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:123.123.123.123\"),\n                \"IPV6 1111:2222:3333:4444:5555:6666:123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333:4444:5555::123.123.123.123\"),\n                \"IPV6 1111:2222:3333:4444:5555::123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333:4444::123.123.123.123\"), \"IPV6 1111:2222:3333:4444::123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333::123.123.123.123\"), \"IPV6 1111:2222:3333::123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222::123.123.123.123\"), \"IPV6 1111:2222::123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111::123.123.123.123\"), \"IPV6 1111::123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::123.123.123.123\"), \"IPV6 ::123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333:4444::6666:123.123.123.123\"),\n                \"IPV6 1111:2222:3333:4444::6666:123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333::6666:123.123.123.123\"), \"IPV6 1111:2222:3333::6666:123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222::6666:123.123.123.123\"), \"IPV6 1111:2222::6666:123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111::6666:123.123.123.123\"), \"IPV6 1111::6666:123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::6666:123.123.123.123\"), \"IPV6 ::6666:123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222:3333::5555:6666:123.123.123.123\"),\n                \"IPV6 1111:2222:3333::5555:6666:123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222::5555:6666:123.123.123.123\"), \"IPV6 1111:2222::5555:6666:123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111::5555:6666:123.123.123.123\"), \"IPV6 1111::5555:6666:123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::5555:6666:123.123.123.123\"), \"IPV6 ::5555:6666:123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111:2222::4444:5555:6666:123.123.123.123\"),\n                \"IPV6 1111:2222::4444:5555:6666:123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111::4444:5555:6666:123.123.123.123\"), \"IPV6 1111::4444:5555:6666:123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::4444:5555:6666:123.123.123.123\"), \"IPV6 ::4444:5555:6666:123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"1111::3333:4444:5555:6666:123.123.123.123\"),\n                \"IPV6 1111::3333:4444:5555:6666:123.123.123.123 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::2222:3333:4444:5555:6666:123.123.123.123\"),\n                \"IPV6 ::2222:3333:4444:5555:6666:123.123.123.123 should be valid\");\n        // Trying combinations of \"0\" and \"::\"\n        // These are all syntactically correct, but are bad form\n        // because \"0\" adjacent to \"::\" should be combined into \"::\"\n        assertTrue(validator.isValidInet6Address(\"::0:0:0:0:0:0:0\"), \"IPV6 ::0:0:0:0:0:0:0 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::0:0:0:0:0:0\"), \"IPV6 ::0:0:0:0:0:0 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::0:0:0:0:0\"), \"IPV6 ::0:0:0:0:0 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::0:0:0:0\"), \"IPV6 ::0:0:0:0 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::0:0:0\"), \"IPV6 ::0:0:0 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::0:0\"), \"IPV6 ::0:0 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::0\"), \"IPV6 ::0 should be valid\");\n        assertTrue(validator.isValidInet6Address(\"0:0:0:0:0:0:0::\"), \"IPV6 0:0:0:0:0:0:0:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"0:0:0:0:0:0::\"), \"IPV6 0:0:0:0:0:0:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"0:0:0:0:0::\"), \"IPV6 0:0:0:0:0:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"0:0:0:0::\"), \"IPV6 0:0:0:0:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"0:0:0::\"), \"IPV6 0:0:0:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"0:0::\"), \"IPV6 0:0:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"0::\"), \"IPV6 0:: should be valid\");\n        // Invalid data\n        assertFalse(validator.isValidInet6Address(\"XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX\"), \"IPV6 XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:XXXX should be invalid\");\n        // Too many components\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:8888:9999\"),\n                \"IPV6 1111:2222:3333:4444:5555:6666:7777:8888:9999 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:8888::\"),\n                \"IPV6 1111:2222:3333:4444:5555:6666:7777:8888:: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::2222:3333:4444:5555:6666:7777:8888:9999\"),\n                \"IPV6 ::2222:3333:4444:5555:6666:7777:8888:9999 should be invalid\");\n        // Too few components\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777\"), \"IPV6 1111:2222:3333:4444:5555:6666:7777 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666\"), \"IPV6 1111:2222:3333:4444:5555:6666 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555\"), \"IPV6 1111:2222:3333:4444:5555 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444\"), \"IPV6 1111:2222:3333:4444 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333\"), \"IPV6 1111:2222:3333 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222\"), \"IPV6 1111:2222 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111\"), \"IPV6 1111 should be invalid\");\n        // Missing :\n        assertFalse(validator.isValidInet6Address(\"11112222:3333:4444:5555:6666:7777:8888\"), \"IPV6 11112222:3333:4444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:22223333:4444:5555:6666:7777:8888\"), \"IPV6 1111:22223333:4444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:33334444:5555:6666:7777:8888\"), \"IPV6 1111:2222:33334444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:44445555:6666:7777:8888\"), \"IPV6 1111:2222:3333:44445555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:55556666:7777:8888\"), \"IPV6 1111:2222:3333:4444:55556666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:66667777:8888\"), \"IPV6 1111:2222:3333:4444:5555:66667777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:77778888\"), \"IPV6 1111:2222:3333:4444:5555:6666:77778888 should be invalid\");\n        // Missing : intended for ::\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:8888:\"),\n                \"IPV6 1111:2222:3333:4444:5555:6666:7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:\"), \"IPV6 1111:2222:3333:4444:5555:6666:7777: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:\"), \"IPV6 1111:2222:3333:4444:5555:6666: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:\"), \"IPV6 1111:2222:3333:4444:5555: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:\"), \"IPV6 1111:2222:3333:4444: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:\"), \"IPV6 1111:2222:3333: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:\"), \"IPV6 1111:2222: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":8888\"), \"IPV6 :8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":7777:8888\"), \"IPV6 :7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":6666:7777:8888\"), \"IPV6 :6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":5555:6666:7777:8888\"), \"IPV6 :5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":4444:5555:6666:7777:8888\"), \"IPV6 :4444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":3333:4444:5555:6666:7777:8888\"), \"IPV6 :3333:4444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":2222:3333:4444:5555:6666:7777:8888\"), \"IPV6 :2222:3333:4444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666:7777:8888\"),\n                \"IPV6 :1111:2222:3333:4444:5555:6666:7777:8888 should be invalid\");\n        // :::\n        assertFalse(validator.isValidInet6Address(\":::2222:3333:4444:5555:6666:7777:8888\"), \"IPV6 :::2222:3333:4444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:::3333:4444:5555:6666:7777:8888\"), \"IPV6 1111:::3333:4444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:::4444:5555:6666:7777:8888\"), \"IPV6 1111:2222:::4444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:::5555:6666:7777:8888\"), \"IPV6 1111:2222:3333:::5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:::6666:7777:8888\"), \"IPV6 1111:2222:3333:4444:::6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:::7777:8888\"), \"IPV6 1111:2222:3333:4444:5555:::7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:::8888\"), \"IPV6 1111:2222:3333:4444:5555:6666:::8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:::\"), \"IPV6 1111:2222:3333:4444:5555:6666:7777::: should be invalid\");\n        // Double ::\n        assertFalse(validator.isValidInet6Address(\"::2222::4444:5555:6666:7777:8888\"), \"IPV6 ::2222::4444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::2222:3333::5555:6666:7777:8888\"), \"IPV6 ::2222:3333::5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::2222:3333:4444::6666:7777:8888\"), \"IPV6 ::2222:3333:4444::6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::2222:3333:4444:5555::7777:8888\"), \"IPV6 ::2222:3333:4444:5555::7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::2222:3333:4444:5555:7777::8888\"), \"IPV6 ::2222:3333:4444:5555:7777::8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::2222:3333:4444:5555:7777:8888::\"), \"IPV6 ::2222:3333:4444:5555:7777:8888:: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111::3333::5555:6666:7777:8888\"), \"IPV6 1111::3333::5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111::3333:4444::6666:7777:8888\"), \"IPV6 1111::3333:4444::6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111::3333:4444:5555::7777:8888\"), \"IPV6 1111::3333:4444:5555::7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111::3333:4444:5555:6666::8888\"), \"IPV6 1111::3333:4444:5555:6666::8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111::3333:4444:5555:6666:7777::\"), \"IPV6 1111::3333:4444:5555:6666:7777:: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222::4444::6666:7777:8888\"), \"IPV6 1111:2222::4444::6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222::4444:5555::7777:8888\"), \"IPV6 1111:2222::4444:5555::7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222::4444:5555:6666::8888\"), \"IPV6 1111:2222::4444:5555:6666::8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222::4444:5555:6666:7777::\"), \"IPV6 1111:2222::4444:5555:6666:7777:: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333::5555::7777:8888\"), \"IPV6 1111:2222:3333::5555::7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333::5555:6666::8888\"), \"IPV6 1111:2222:3333::5555:6666::8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333::5555:6666:7777::\"), \"IPV6 1111:2222:3333::5555:6666:7777:: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444::6666::8888\"), \"IPV6 1111:2222:3333:4444::6666::8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444::6666:7777::\"), \"IPV6 1111:2222:3333:4444::6666:7777:: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555::7777::\"), \"IPV6 1111:2222:3333:4444:5555::7777:: should be invalid\");\n        // Too many components\"\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:8888:1.2.3.4\"),\n                \"IPV6 1111:2222:3333:4444:5555:6666:7777:8888:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:1.2.3.4\"),\n                \"IPV6 1111:2222:3333:4444:5555:6666:7777:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666::1.2.3.4\"), \"IPV6 1111:2222:3333:4444:5555:6666::1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::2222:3333:4444:5555:6666:7777:1.2.3.4\"), \"IPV6 ::2222:3333:4444:5555:6666:7777:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:1.2.3.4.5\"), \"IPV6 1111:2222:3333:4444:5555:6666:1.2.3.4.5 should be invalid\");\n        // Too few components\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:1.2.3.4\"), \"IPV6 1111:2222:3333:4444:5555:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:1.2.3.4\"), \"IPV6 1111:2222:3333:4444:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:1.2.3.4\"), \"IPV6 1111:2222:3333:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:1.2.3.4\"), \"IPV6 1111:2222:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:1.2.3.4\"), \"IPV6 1111:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1.2.3.4\"), \"IPV6 1.2.3.4 should be invalid\");\n        // Missing :\n        assertFalse(validator.isValidInet6Address(\"11112222:3333:4444:5555:6666:1.2.3.4\"), \"IPV6 11112222:3333:4444:5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:22223333:4444:5555:6666:1.2.3.4\"), \"IPV6 1111:22223333:4444:5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:33334444:5555:6666:1.2.3.4\"), \"IPV6 1111:2222:33334444:5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:44445555:6666:1.2.3.4\"), \"IPV6 1111:2222:3333:44445555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:55556666:1.2.3.4\"), \"IPV6 1111:2222:3333:4444:55556666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:66661.2.3.4\"), \"IPV6 1111:2222:3333:4444:5555:66661.2.3.4 should be invalid\");\n        // Missing .\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:255255.255.255\"),\n                \"IPV6 1111:2222:3333:4444:5555:6666:255255.255.255 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:255.255255.255\"),\n                \"IPV6 1111:2222:3333:4444:5555:6666:255.255255.255 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:255.255.255255\"),\n                \"IPV6 1111:2222:3333:4444:5555:6666:255.255.255255 should be invalid\");\n        // Missing : intended for ::\n        assertFalse(validator.isValidInet6Address(\":1.2.3.4\"), \"IPV6 :1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":6666:1.2.3.4\"), \"IPV6 :6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":5555:6666:1.2.3.4\"), \"IPV6 :5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":4444:5555:6666:1.2.3.4\"), \"IPV6 :4444:5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":3333:4444:5555:6666:1.2.3.4\"), \"IPV6 :3333:4444:5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":2222:3333:4444:5555:6666:1.2.3.4\"), \"IPV6 :2222:3333:4444:5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666:1.2.3.4\"), \"IPV6 :1111:2222:3333:4444:5555:6666:1.2.3.4 should be invalid\");\n        // :::\n        assertFalse(validator.isValidInet6Address(\":::2222:3333:4444:5555:6666:1.2.3.4\"), \"IPV6 :::2222:3333:4444:5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:::3333:4444:5555:6666:1.2.3.4\"), \"IPV6 1111:::3333:4444:5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:::4444:5555:6666:1.2.3.4\"), \"IPV6 1111:2222:::4444:5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:::5555:6666:1.2.3.4\"), \"IPV6 1111:2222:3333:::5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:::6666:1.2.3.4\"), \"IPV6 1111:2222:3333:4444:::6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:::1.2.3.4\"), \"IPV6 1111:2222:3333:4444:5555:::1.2.3.4 should be invalid\");\n        // Double ::\n        assertFalse(validator.isValidInet6Address(\"::2222::4444:5555:6666:1.2.3.4\"), \"IPV6 ::2222::4444:5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::2222:3333::5555:6666:1.2.3.4\"), \"IPV6 ::2222:3333::5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::2222:3333:4444::6666:1.2.3.4\"), \"IPV6 ::2222:3333:4444::6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::2222:3333:4444:5555::1.2.3.4\"), \"IPV6 ::2222:3333:4444:5555::1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111::3333::5555:6666:1.2.3.4\"), \"IPV6 1111::3333::5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111::3333:4444::6666:1.2.3.4\"), \"IPV6 1111::3333:4444::6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111::3333:4444:5555::1.2.3.4\"), \"IPV6 1111::3333:4444:5555::1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222::4444::6666:1.2.3.4\"), \"IPV6 1111:2222::4444::6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222::4444:5555::1.2.3.4\"), \"IPV6 1111:2222::4444:5555::1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333::5555::1.2.3.4\"), \"IPV6 1111:2222:3333::5555::1.2.3.4 should be invalid\");\n        // Missing parts\n        assertFalse(validator.isValidInet6Address(\"::.\"), \"IPV6 ::. should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::..\"), \"IPV6 ::.. should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::...\"), \"IPV6 ::... should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::1...\"), \"IPV6 ::1... should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::1.2..\"), \"IPV6 ::1.2.. should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::1.2.3.\"), \"IPV6 ::1.2.3. should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::.2..\"), \"IPV6 ::.2.. should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::.2.3.\"), \"IPV6 ::.2.3. should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::.2.3.4\"), \"IPV6 ::.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::..3.\"), \"IPV6 ::..3. should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::..3.4\"), \"IPV6 ::..3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::...4\"), \"IPV6 ::...4 should be invalid\");\n        // Extra : in front\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666:7777::\"), \"IPV6 :1111:2222:3333:4444:5555:6666:7777:: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666::\"), \"IPV6 :1111:2222:3333:4444:5555:6666:: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444:5555::\"), \"IPV6 :1111:2222:3333:4444:5555:: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444::\"), \"IPV6 :1111:2222:3333:4444:: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333::\"), \"IPV6 :1111:2222:3333:: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222::\"), \"IPV6 :1111:2222:: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111::\"), \"IPV6 :1111:: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666::8888\"), \"IPV6 :1111:2222:3333:4444:5555:6666::8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444:5555::8888\"), \"IPV6 :1111:2222:3333:4444:5555::8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444::8888\"), \"IPV6 :1111:2222:3333:4444::8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333::8888\"), \"IPV6 :1111:2222:3333::8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222::8888\"), \"IPV6 :1111:2222::8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111::8888\"), \"IPV6 :1111::8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":::8888\"), \"IPV6 :::8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444:5555::7777:8888\"), \"IPV6 :1111:2222:3333:4444:5555::7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444::7777:8888\"), \"IPV6 :1111:2222:3333:4444::7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333::7777:8888\"), \"IPV6 :1111:2222:3333::7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222::7777:8888\"), \"IPV6 :1111:2222::7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111::7777:8888\"), \"IPV6 :1111::7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":::7777:8888\"), \"IPV6 :::7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444::6666:7777:8888\"), \"IPV6 :1111:2222:3333:4444::6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333::6666:7777:8888\"), \"IPV6 :1111:2222:3333::6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222::6666:7777:8888\"), \"IPV6 :1111:2222::6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111::6666:7777:8888\"), \"IPV6 :1111::6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":::6666:7777:8888\"), \"IPV6 :::6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333::5555:6666:7777:8888\"), \"IPV6 :1111:2222:3333::5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222::5555:6666:7777:8888\"), \"IPV6 :1111:2222::5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111::5555:6666:7777:8888\"), \"IPV6 :1111::5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":::5555:6666:7777:8888\"), \"IPV6 :::5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222::4444:5555:6666:7777:8888\"), \"IPV6 :1111:2222::4444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111::4444:5555:6666:7777:8888\"), \"IPV6 :1111::4444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":::4444:5555:6666:7777:8888\"), \"IPV6 :::4444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111::3333:4444:5555:6666:7777:8888\"), \"IPV6 :1111::3333:4444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":::3333:4444:5555:6666:7777:8888\"), \"IPV6 :::3333:4444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":::2222:3333:4444:5555:6666:7777:8888\"), \"IPV6 :::2222:3333:4444:5555:6666:7777:8888 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444:5555:6666:1.2.3.4\"), \"IPV6 :1111:2222:3333:4444:5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444:5555::1.2.3.4\"), \"IPV6 :1111:2222:3333:4444:5555::1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444::1.2.3.4\"), \"IPV6 :1111:2222:3333:4444::1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333::1.2.3.4\"), \"IPV6 :1111:2222:3333::1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222::1.2.3.4\"), \"IPV6 :1111:2222::1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111::1.2.3.4\"), \"IPV6 :1111::1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":::1.2.3.4\"), \"IPV6 :::1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333:4444::6666:1.2.3.4\"), \"IPV6 :1111:2222:3333:4444::6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333::6666:1.2.3.4\"), \"IPV6 :1111:2222:3333::6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222::6666:1.2.3.4\"), \"IPV6 :1111:2222::6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111::6666:1.2.3.4\"), \"IPV6 :1111::6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":::6666:1.2.3.4\"), \"IPV6 :::6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222:3333::5555:6666:1.2.3.4\"), \"IPV6 :1111:2222:3333::5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222::5555:6666:1.2.3.4\"), \"IPV6 :1111:2222::5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111::5555:6666:1.2.3.4\"), \"IPV6 :1111::5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":::5555:6666:1.2.3.4\"), \"IPV6 :::5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111:2222::4444:5555:6666:1.2.3.4\"), \"IPV6 :1111:2222::4444:5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111::4444:5555:6666:1.2.3.4\"), \"IPV6 :1111::4444:5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":::4444:5555:6666:1.2.3.4\"), \"IPV6 :::4444:5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":1111::3333:4444:5555:6666:1.2.3.4\"), \"IPV6 :1111::3333:4444:5555:6666:1.2.3.4 should be invalid\");\n        assertFalse(validator.isValidInet6Address(\":::2222:3333:4444:5555:6666:1.2.3.4\"), \"IPV6 :::2222:3333:4444:5555:6666:1.2.3.4 should be invalid\");\n        // Extra : at end\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:7777:::\"), \"IPV6 1111:2222:3333:4444:5555:6666:7777::: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666:::\"), \"IPV6 1111:2222:3333:4444:5555:6666::: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:::\"), \"IPV6 1111:2222:3333:4444:5555::: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:::\"), \"IPV6 1111:2222:3333:4444::: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:::\"), \"IPV6 1111:2222:3333::: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:::\"), \"IPV6 1111:2222::: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:::\"), \"IPV6 1111::: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555:6666::8888:\"), \"IPV6 1111:2222:3333:4444:5555:6666::8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555::8888:\"), \"IPV6 1111:2222:3333:4444:5555::8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444::8888:\"), \"IPV6 1111:2222:3333:4444::8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333::8888:\"), \"IPV6 1111:2222:3333::8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222::8888:\"), \"IPV6 1111:2222::8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111::8888:\"), \"IPV6 1111::8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::8888:\"), \"IPV6 ::8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444:5555::7777:8888:\"), \"IPV6 1111:2222:3333:4444:5555::7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444::7777:8888:\"), \"IPV6 1111:2222:3333:4444::7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333::7777:8888:\"), \"IPV6 1111:2222:3333::7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222::7777:8888:\"), \"IPV6 1111:2222::7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111::7777:8888:\"), \"IPV6 1111::7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::7777:8888:\"), \"IPV6 ::7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333:4444::6666:7777:8888:\"), \"IPV6 1111:2222:3333:4444::6666:7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333::6666:7777:8888:\"), \"IPV6 1111:2222:3333::6666:7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222::6666:7777:8888:\"), \"IPV6 1111:2222::6666:7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111::6666:7777:8888:\"), \"IPV6 1111::6666:7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::6666:7777:8888:\"), \"IPV6 ::6666:7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222:3333::5555:6666:7777:8888:\"), \"IPV6 1111:2222:3333::5555:6666:7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222::5555:6666:7777:8888:\"), \"IPV6 1111:2222::5555:6666:7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111::5555:6666:7777:8888:\"), \"IPV6 1111::5555:6666:7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::5555:6666:7777:8888:\"), \"IPV6 ::5555:6666:7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111:2222::4444:5555:6666:7777:8888:\"), \"IPV6 1111:2222::4444:5555:6666:7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111::4444:5555:6666:7777:8888:\"), \"IPV6 1111::4444:5555:6666:7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::4444:5555:6666:7777:8888:\"), \"IPV6 ::4444:5555:6666:7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"1111::3333:4444:5555:6666:7777:8888:\"), \"IPV6 1111::3333:4444:5555:6666:7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::3333:4444:5555:6666:7777:8888:\"), \"IPV6 ::3333:4444:5555:6666:7777:8888: should be invalid\");\n        assertFalse(validator.isValidInet6Address(\"::2222:3333:4444:5555:6666:7777:8888:\"), \"IPV6 ::2222:3333:4444:5555:6666:7777:8888: should be invalid\");\n        assertTrue(validator.isValidInet6Address(\"0:a:b:c:d:e:f::\"), \"IPV6 0:a:b:c:d:e:f:: should be valid\");\n        assertTrue(validator.isValidInet6Address(\"::0:a:b:c:d:e:f\"), \"IPV6 ::0:a:b:c:d:e:f should be valid\"); // syntactically correct, but bad form (::0:...\n                                                                                                              // could be combined)\n        assertTrue(validator.isValidInet6Address(\"a:b:c:d:e:f:0::\"), \"IPV6 a:b:c:d:e:f:0:: should be valid\");\n        assertFalse(validator.isValidInet6Address(\"':10.0.0.1\"), \"IPV6 ':10.0.0.1 should be invalid\");\n    }\n\n    /**\n     * Test reserved IPs.\n     */\n    @Test\n    public void testReservedInetAddresses() {\n        assertTrue(validator.isValid(\"127.0.0.1\"), \"localhost IP should be valid\");\n        assertTrue(validator.isValid(\"255.255.255.255\"), \"broadcast IP should be valid\");\n    }\n\n    @Test\n    public void testValidator335() {\n        assertTrue(validator.isValid(\"2001:0438:FFFE:0000:0000:0000:0000:0A35\"), \"2001:0438:FFFE:0000:0000:0000:0000:0A35 should be valid\");\n    }\n\n    @Test\n    public void testValidator419() {\n        String addr;\n        addr = \"0:0:0:0:0:0:13.1.68.3\";\n        assertTrue(validator.isValid(addr));\n        addr = \"0:0:0:0:0:FFFF:129.144.52.38\";\n        assertTrue(validator.isValid(addr), addr);\n        addr = \"::13.1.68.3\";\n        assertTrue(validator.isValid(addr), addr);\n        addr = \"::FFFF:129.144.52.38\";\n        assertTrue(validator.isValid(addr), addr);\n\n        addr = \"::ffff:192.168.1.1:192.168.1.1\";\n        assertFalse(validator.isValid(addr), addr);\n        addr = \"::192.168.1.1:192.168.1.1\";\n        assertFalse(validator.isValid(addr), addr);\n    }\n\n    /**\n     * Inet6Address may also contain a scope id.\n     */\n    @Test\n    public void testValidator445() {\n        final String[] valid = { \"2001:0000:1234:0000:0000:C1C0:ABCD:0876\", \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/123\",\n                \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/0\", \"2001:0000:1234:0000:0000:C1C0:ABCD:0876%0\", \"2001:0000:1234:0000:0000:C1C0:ABCD:0876%abcdefgh\", };\n        final String[] invalid = { \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/129\", // too big\n                \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/-0\", // sign not allowed\n                \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/+0\", // sign not allowed\n                \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/10O\", // non-digit\n                \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/0%0\", // /bits before %node-id\n                \"2001:0000:1234:0000:0000:C1C0:ABCD:0876%abc defgh\", // space in node id\n                \"2001:0000:1234:0000:0000:C1C0:ABCD:0876%abc%defgh\", // '%' in node id\n        };\n        for (final String item : valid) {\n            assertTrue(validator.isValid(item), () -> String.format(\"%s should be valid\", item));\n        }\n        for (final String item : invalid) {\n            assertFalse(validator.isValid(item), () -> String.format(\"%s should be invalid\", item));\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private InetAddressValidator validator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "InetAddressValidator", "name": "validator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/TimeValidatorTest.java.TimeValidatorTest", "name": "TimeValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/TimeValidatorTest.java", "superclasses": "", "methods": ["[void]testCompare()", "[void]testFormat()", "[void]testLocaleInvalid()", "[void]testLocaleValid()", "[void]testPatternInvalid()", "[void]testPatternValid()", "[void]testTimeZone()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/TimeValidatorTest.java.TimeValidatorTest.[Date]createDate(TimeZone,int,int)", "src/test/java/org/apache/commons/validator/routines/TimeValidatorTest.java.TimeValidatorTest.[Calendar]createTime(TimeZone,int,int)", "src/test/java/org/apache/commons/validator/routines/TimeValidatorTest.java.TimeValidatorTest.[void]setUp()", "src/test/java/org/apache/commons/validator/routines/TimeValidatorTest.java.TimeValidatorTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nTest Case for TimeValidator.\n", "original_string": "public class TimeValidatorTest {\n\n    protected static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\"); // 0 offset\n    protected static final TimeZone EST = TimeZone.getTimeZone(\"EST\"); // - 5 hours\n\n    /**\n     * Create a date instance for a specified time zone, date and time.\n     *\n     * @param zone        The time zone\n     * @param time        the time in HH:mm:ss format\n     * @param millisecond the milliseconds\n     * @return the new Date instance.\n     */\n    protected static Date createDate(final TimeZone zone, final int time, final int millisecond) {\n        final Calendar calendar = createTime(zone, time, millisecond);\n        return calendar.getTime();\n    }\n\n    /**\n     * Create a calendar instance for a specified time zone, date and time.\n     *\n     * @param zone        The time zone\n     * @param time        the time in HH:mm:ss format\n     * @param millisecond the milliseconds\n     * @return the new Calendar instance.\n     */\n    protected static Calendar createTime(final TimeZone zone, final int time, final int millisecond) {\n        final Calendar calendar = zone == null ? Calendar.getInstance() : Calendar.getInstance(zone);\n        final int hour = time / 10000 * 10000;\n        final int min = time / 100 * 100 - hour;\n        final int sec = time - (hour + min);\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DATE, 1);\n        calendar.set(Calendar.HOUR_OF_DAY, hour / 10000);\n        calendar.set(Calendar.MINUTE, min / 100);\n        calendar.set(Calendar.SECOND, sec);\n        calendar.set(Calendar.MILLISECOND, millisecond);\n        return calendar;\n    }\n\n    protected TimeValidator validator;\n    protected String[] patternValid = { \"23-59-59\", \"00-00-00\", \"00-00-01\", \"0-0-0\", \"1-12-1\", \"10-49-18\", \"16-23-46\" };\n    protected Date[] patternExpect = { createDate(null, 235959, 0), createDate(null, 0, 0), createDate(null, 1, 0), createDate(null, 0, 0),\n            createDate(null, 11201, 0), createDate(null, 104918, 0), createDate(null, 162346, 0) };\n    protected String[] localeValid = { \"23:59\", \"00:00\", \"00:01\", \"0:0\", \"1:12\", \"10:49\", \"16:23\" };\n    protected Date[] localeExpect = { createDate(null, 235900, 0), createDate(null, 0, 0), createDate(null, 100, 0), createDate(null, 0, 0),\n            createDate(null, 11200, 0), createDate(null, 104900, 0), createDate(null, 162300, 0) };\n\n    protected String[] patternInvalid = { \"24-00-00\" // midnight\n            , \"24-00-01\" // past midnight\n            , \"25-02-03\" // invalid hour\n            , \"10-61-31\" // invalid minute\n            , \"10-01-61\" // invalid second\n            , \"05:02-29\" // invalid sep\n            , \"0X-01:01\" // invalid sep\n            , \"05-0X-01\" // invalid char\n            , \"10-01-0X\" // invalid char\n            , \"01:01:05\" // invalid pattern\n            , \"10-10\" // invalid pattern\n            , \"10--10\" // invalid pattern\n            , \"10-10-\" }; // invalid pattern\n    protected String[] localeInvalid = { \"24:00\" // midnight\n            , \"24:00\" // past midnight\n            , \"25:02\" // invalid hour\n            , \"10:61\" // invalid minute\n            , \"05-02\" // invalid sep\n            , \"0X:01\" // invalid sep\n            , \"05:0X\" // invalid char\n            , \"01-01\" // invalid pattern\n            , \"10:\" // invalid pattern\n            , \"10::1\" // invalid pattern\n            , \"10:1:\" }; // invalid pattern\n\n    private Locale origDefault;\n\n    private TimeZone defaultZone;\n\n    @BeforeEach\n    protected void setUp() {\n        validator = new TimeValidator();\n        defaultZone = TimeZone.getDefault();\n        origDefault = Locale.getDefault();\n    }\n\n    /**\n     * Tear down\n     */\n    @AfterEach\n    protected void tearDown() {\n        validator = null;\n        Locale.setDefault(origDefault);\n        TimeZone.setDefault(defaultZone);\n    }\n\n    /**\n     * Test compare date methods\n     */\n    @Test\n    public void testCompare() {\n        final int testTime = 154523;\n        final int min = 100;\n        final int hour = 10000;\n\n        final Calendar milliGreater = createTime(GMT, testTime, 500); // > milli sec\n        final Calendar value = createTime(GMT, testTime, 400); // test value\n        final Calendar milliLess = createTime(GMT, testTime, 300); // < milli sec\n\n        final Calendar secGreater = createTime(GMT, testTime + 1, 100); // +1 sec\n        final Calendar secLess = createTime(GMT, testTime - 1, 100); // -1 sec\n\n        final Calendar minGreater = createTime(GMT, testTime + min, 100); // +1 min\n        final Calendar minLess = createTime(GMT, testTime - min, 100); // -1 min\n\n        final Calendar hourGreater = createTime(GMT, testTime + hour, 100); // +1 hour\n        final Calendar hourLess = createTime(GMT, testTime - hour, 100); // -1 hour\n\n        assertEquals(-1, validator.compareTime(value, milliGreater), \"mili LT\"); // > milli\n        assertEquals(0, validator.compareTime(value, value), \"mili EQ\"); // same time\n        assertEquals(1, validator.compareTime(value, milliLess), \"mili GT\"); // < milli\n\n        assertEquals(-1, validator.compareSeconds(value, secGreater), \"secs LT\"); // +1 sec\n        assertEquals(0, validator.compareSeconds(value, milliGreater), \"secs =1\"); // > milli\n        assertEquals(0, validator.compareSeconds(value, value), \"secs =2\"); // same time\n        assertEquals(0, validator.compareSeconds(value, milliLess), \"secs =3\"); // < milli\n        assertEquals(1, validator.compareSeconds(value, secLess), \"secs GT\"); // -1 sec\n\n        assertEquals(-1, validator.compareMinutes(value, minGreater), \"mins LT\"); // +1 min\n        assertEquals(0, validator.compareMinutes(value, secGreater), \"mins =1\"); // +1 sec\n        assertEquals(0, validator.compareMinutes(value, value), \"mins =2\"); // same time\n        assertEquals(0, validator.compareMinutes(value, secLess), \"mins =3\"); // -1 sec\n        assertEquals(1, validator.compareMinutes(value, minLess), \"mins GT\"); // -1 min\n\n        assertEquals(-1, validator.compareHours(value, hourGreater), \"hour LT\"); // +1 hour\n        assertEquals(0, validator.compareHours(value, minGreater), \"hour =1\"); // +1 min\n        assertEquals(0, validator.compareHours(value, value), \"hour =2\"); // same time\n        assertEquals(0, validator.compareHours(value, minLess), \"hour =3\"); // -1 min\n        assertEquals(1, validator.compareHours(value, hourLess), \"hour GT\"); // -1 hour\n\n    }\n\n    /**\n     * Test Invalid Dates with \"locale\" validation\n     */\n    @Test\n    public void testFormat() {\n        // Set the default Locale\n        Locale.setDefault(Locale.UK);\n\n        final Object test = TimeValidator.getInstance().validate(\"16:49:23\", \"HH:mm:ss\");\n        assertNotNull(test, \"Test Date \");\n        assertEquals(\"16-49-23\", validator.format(test, \"HH-mm-ss\"), \"Format pattern\");\n        assertEquals(\"4:49 PM\", validator.format(test, Locale.US), \"Format locale\");\n        assertEquals(\"16:49\", validator.format(test), \"Format default\");\n    }\n\n    /**\n     * Test Invalid Dates with \"locale\" validation\n     */\n    @Test\n    public void testLocaleInvalid() {\n        for (int i = 0; i < localeInvalid.length; i++) {\n            final String text = i + \" value=[\" + localeInvalid[i] + \"] passed \";\n            final Object date = validator.validate(localeInvalid[i], Locale.US);\n            assertNull(date, () -> \"validate() \" + text + date);\n            assertFalse(validator.isValid(localeInvalid[i], Locale.UK), () -> \"isValid() \" + text);\n        }\n    }\n\n    /**\n     * Test Valid Dates with \"locale\" validation\n     */\n    @Test\n    public void testLocaleValid() {\n        for (int i = 0; i < localeValid.length; i++) {\n            final String text = i + \" value=[\" + localeValid[i] + \"] failed \";\n            final Calendar calendar = validator.validate(localeValid[i], Locale.UK);\n            assertNotNull(calendar, () -> \"validate() \" + text);\n            final Date date = calendar.getTime();\n            assertTrue(validator.isValid(localeValid[i], Locale.UK), () -> \"isValid() \" + text);\n            assertEquals(localeExpect[i], date, () -> \"compare \" + text);\n        }\n    }\n\n    /**\n     * Test Invalid Dates with \"pattern\" validation\n     */\n    @Test\n    public void testPatternInvalid() {\n        for (int i = 0; i < patternInvalid.length; i++) {\n            final String text = i + \" value=[\" + patternInvalid[i] + \"] passed \";\n            final Object date = validator.validate(patternInvalid[i], \"HH-mm-ss\");\n            assertNull(date, () -> \"validate() \" + text + date);\n            assertFalse(validator.isValid(patternInvalid[i], \"HH-mm-ss\"), () -> \"isValid() \" + text);\n        }\n    }\n\n    /**\n     * Test Valid Dates with \"pattern\" validation\n     */\n    @Test\n    public void testPatternValid() {\n        for (int i = 0; i < patternValid.length; i++) {\n            final String text = i + \" value=[\" + patternValid[i] + \"] failed \";\n            final Calendar calendar = validator.validate(patternValid[i], \"HH-mm-ss\");\n            assertNotNull(calendar, () -> \"validateObj() \" + text);\n            final Date date = calendar.getTime();\n            assertTrue(validator.isValid(patternValid[i], \"HH-mm-ss\"), () -> \"isValid() \" + text);\n            assertEquals(patternExpect[i], date, () -> \"compare \" + text);\n        }\n    }\n\n    /**\n     * Test time zone methods.\n     */\n    @Test\n    public void testTimeZone() {\n        // Set the default Locale & TimeZone\n        Locale.setDefault(Locale.UK);\n        TimeZone.setDefault(GMT);\n\n        Calendar result;\n\n        // Default Locale, Default TimeZone\n        result = validator.validate(\"18:01\");\n        assertNotNull(result, \"default result\");\n        assertEquals(GMT, result.getTimeZone(), \"default zone\");\n        assertEquals(18, result.get(Calendar.HOUR_OF_DAY), \"default hour\");\n        assertEquals(01, result.get(Calendar.MINUTE), \"default minute\");\n        result = null;\n\n        // Default Locale, diff TimeZone\n        result = validator.validate(\"16:49\", EST);\n        assertNotNull(result, \"zone result\");\n        assertEquals(EST, result.getTimeZone(), \"zone zone\");\n        assertEquals(16, result.get(Calendar.HOUR_OF_DAY), \"zone hour\");\n        assertEquals(49, result.get(Calendar.MINUTE), \"zone minute\");\n        result = null;\n\n        // Pattern, diff TimeZone\n        result = validator.validate(\"14-34\", \"HH-mm\", EST);\n        assertNotNull(result, \"pattern result\");\n        assertEquals(EST, result.getTimeZone(), \"pattern zone\");\n        assertEquals(14, result.get(Calendar.HOUR_OF_DAY), \"pattern hour\");\n        assertEquals(34, result.get(Calendar.MINUTE), \"pattern minute\");\n        result = null;\n\n        // Locale, diff TimeZone\n        result = validator.validate(\"7:18 PM\", Locale.US, EST);\n        assertNotNull(result, \"locale result\");\n        assertEquals(EST, result.getTimeZone(), \"locale zone\");\n        assertEquals(19, result.get(Calendar.HOUR_OF_DAY), \"locale hour\");\n        assertEquals(18, result.get(Calendar.MINUTE), \"locale minute\");\n        result = null;\n\n        // Locale & Pattern, diff TimeZone\n        result = validator.validate(\"31/Dez/05 21-05\", \"dd/MMM/yy HH-mm\", Locale.GERMAN, EST);\n        assertNotNull(result, \"pattern result\");\n        assertEquals(EST, result.getTimeZone(), \"pattern zone\");\n        assertEquals(2005, result.get(Calendar.YEAR), \"pattern day\");\n        assertEquals(11, result.get(Calendar.MONTH), \"pattern day\"); // months are 0-11\n        assertEquals(31, result.get(Calendar.DATE), \"pattern day\");\n        assertEquals(21, result.get(Calendar.HOUR_OF_DAY), \"pattern hour\");\n        assertEquals(05, result.get(Calendar.MINUTE), \"pattern minute\");\n        result = null;\n\n        // Locale & Pattern, default TimeZone\n        result = validator.validate(\"31/Dez/05 21-05\", \"dd/MMM/yy HH-mm\", Locale.GERMAN);\n        assertNotNull(result, \"pattern result\");\n        assertEquals(GMT, result.getTimeZone(), \"pattern zone\");\n        assertEquals(2005, result.get(Calendar.YEAR), \"pattern day\");\n        assertEquals(11, result.get(Calendar.MONTH), \"pattern day\"); // months are 0-11\n        assertEquals(31, result.get(Calendar.DATE), \"pattern day\");\n        assertEquals(21, result.get(Calendar.HOUR_OF_DAY), \"pattern hour\");\n        assertEquals(05, result.get(Calendar.MINUTE), \"pattern minute\");\n        result = null;\n\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");", "docstring": "", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "TimeZone", "name": "GMT = TimeZone.getTimeZone(\"GMT\")", "syntax_pass": true}, {"attribute_expression": "protected static final TimeZone EST = TimeZone.getTimeZone(\"EST\");", "docstring": " 0 offset", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "TimeZone", "name": "EST = TimeZone.getTimeZone(\"EST\")", "syntax_pass": true}, {"attribute_expression": "protected TimeValidator validator;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "TimeValidator", "name": "validator", "syntax_pass": true}, {"attribute_expression": "protected String[] patternValid = { \"23-59-59\", \"00-00-00\", \"00-00-01\", \"0-0-0\", \"1-12-1\", \"10-49-18\", \"16-23-46\" };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "patternValid = { \"23-59-59\", \"00-00-00\", \"00-00-01\", \"0-0-0\", \"1-12-1\", \"10-49-18\", \"16-23-46\" }", "syntax_pass": true}, {"attribute_expression": "protected Date[] patternExpect = { createDate(null, 235959, 0), createDate(null, 0, 0), createDate(null, 1, 0), createDate(null, 0, 0),\n            createDate(null, 11201, 0), createDate(null, 104918, 0), createDate(null, 162346, 0) };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Date[]", "name": "patternExpect = { createDate(null, 235959, 0), createDate(null, 0, 0), createDate(null, 1, 0), createDate(null, 0, 0),\n            createDate(null, 11201, 0), createDate(null, 104918, 0), createDate(null, 162346, 0) }", "syntax_pass": true}, {"attribute_expression": "protected String[] localeValid = { \"23:59\", \"00:00\", \"00:01\", \"0:0\", \"1:12\", \"10:49\", \"16:23\" };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "localeValid = { \"23:59\", \"00:00\", \"00:01\", \"0:0\", \"1:12\", \"10:49\", \"16:23\" }", "syntax_pass": true}, {"attribute_expression": "protected Date[] localeExpect = { createDate(null, 235900, 0), createDate(null, 0, 0), createDate(null, 100, 0), createDate(null, 0, 0),\n            createDate(null, 11200, 0), createDate(null, 104900, 0), createDate(null, 162300, 0) };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Date[]", "name": "localeExpect = { createDate(null, 235900, 0), createDate(null, 0, 0), createDate(null, 100, 0), createDate(null, 0, 0),\n            createDate(null, 11200, 0), createDate(null, 104900, 0), createDate(null, 162300, 0) }", "syntax_pass": true}, {"attribute_expression": "protected String[] patternInvalid = { \"24-00-00\" // midnight\n            , \"24-00-01\" // past midnight\n            , \"25-02-03\" // invalid hour\n            , \"10-61-31\" // invalid minute\n            , \"10-01-61\" // invalid second\n            , \"05:02-29\" // invalid sep\n            , \"0X-01:01\" // invalid sep\n            , \"05-0X-01\" // invalid char\n            , \"10-01-0X\" // invalid char\n            , \"01:01:05\" // invalid pattern\n            , \"10-10\" // invalid pattern\n            , \"10--10\" // invalid pattern\n            , \"10-10-\" };", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "patternInvalid = { \"24-00-00\" // midnight\n            , \"24-00-01\" // past midnight\n            , \"25-02-03\" // invalid hour\n            , \"10-61-31\" // invalid minute\n            , \"10-01-61\" // invalid second\n            , \"05:02-29\" // invalid sep\n            , \"0X-01:01\" // invalid sep\n            , \"05-0X-01\" // invalid char\n            , \"10-01-0X\" // invalid char\n            , \"01:01:05\" // invalid pattern\n            , \"10-10\" // invalid pattern\n            , \"10--10\" // invalid pattern\n            , \"10-10-\" }", "syntax_pass": true}, {"attribute_expression": "protected String[] localeInvalid = { \"24:00\" // midnight\n            , \"24:00\" // past midnight\n            , \"25:02\" // invalid hour\n            , \"10:61\" // invalid minute\n            , \"05-02\" // invalid sep\n            , \"0X:01\" // invalid sep\n            , \"05:0X\" // invalid char\n            , \"01-01\" // invalid pattern\n            , \"10:\" // invalid pattern\n            , \"10::1\" // invalid pattern\n            , \"10:1:\" };", "docstring": " invalid pattern", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "String[]", "name": "localeInvalid = { \"24:00\" // midnight\n            , \"24:00\" // past midnight\n            , \"25:02\" // invalid hour\n            , \"10:61\" // invalid minute\n            , \"05-02\" // invalid sep\n            , \"0X:01\" // invalid sep\n            , \"05:0X\" // invalid char\n            , \"01-01\" // invalid pattern\n            , \"10:\" // invalid pattern\n            , \"10::1\" // invalid pattern\n            , \"10:1:\" }", "syntax_pass": true}, {"attribute_expression": "private Locale origDefault;", "docstring": " invalid pattern", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Locale", "name": "origDefault", "syntax_pass": true}, {"attribute_expression": "private TimeZone defaultZone;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "TimeZone", "name": "defaultZone", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/BigIntegerValidatorTest.java.BigIntegerValidatorTest", "name": "BigIntegerValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/BigIntegerValidatorTest.java", "superclasses": "AbstractNumberValidatorTest", "methods": ["[void]testBigIntegerRangeMinMax()", "[void]testBigIntegerValidatorMethods()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/BigIntegerValidatorTest.java.BigIntegerValidatorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTest Case for BigIntegerValidator.\n", "original_string": "public class BigIntegerValidatorTest extends AbstractNumberValidatorTest {\n\n    @Override\n    @BeforeEach\n    protected void setUp() {\n        super.setUp();\n\n        validator = new BigIntegerValidator(false, 0);\n        strictValidator = new BigIntegerValidator();\n\n        testPattern = \"#,###\";\n\n        // testValidateMinMax()\n        max = null;\n        maxPlusOne = null;\n        min = null;\n        minMinusOne = null;\n\n        // testInvalidStrict()\n        invalidStrict = new String[] { null, \"\", \"X\", \"X12\", \"12X\", \"1X2\", \"1.2\" };\n\n        // testInvalidNotStrict()\n        invalid = new String[] { null, \"\", \"X\", \"X12\" };\n\n        // testValid()\n        testNumber = new BigInteger(\"1234\");\n        testZero = new BigInteger(\"0\");\n        validStrict = new String[] { \"0\", \"1234\", \"1,234\" };\n        validStrictCompare = new Number[] { testZero, testNumber, testNumber };\n        valid = new String[] { \"0\", \"1234\", \"1,234\", \"1,234.5\", \"1234X\" };\n        validCompare = new Number[] { testZero, testNumber, testNumber, testNumber, testNumber };\n\n        testStringUS = \"1,234\";\n        testStringDE = \"1.234\";\n\n        // Localized Pattern test\n        localeValue = testStringDE;\n        localePattern = \"#.###\";\n        testLocale = Locale.GERMANY;\n        localeExpected = testNumber;\n\n    }\n\n    /**\n     * Test BigInteger Range/Min/Max\n     */\n    @Test\n    public void testBigIntegerRangeMinMax() {\n        final BigIntegerValidator validator = (BigIntegerValidator) strictValidator;\n        final BigInteger number9 = validator.validate(\"9\", \"#\");\n        final BigInteger number10 = validator.validate(\"10\", \"#\");\n        final BigInteger number11 = validator.validate(\"11\", \"#\");\n        final BigInteger number19 = validator.validate(\"19\", \"#\");\n        final BigInteger number20 = validator.validate(\"20\", \"#\");\n        final BigInteger number21 = validator.validate(\"21\", \"#\");\n\n        // Test isInRange()\n        assertFalse(validator.isInRange(number9, 10, 20), \"isInRange() < min\");\n        assertTrue(validator.isInRange(number10, 10, 20), \"isInRange() = min\");\n        assertTrue(validator.isInRange(number11, 10, 20), \"isInRange() in range\");\n        assertTrue(validator.isInRange(number20, 10, 20), \"isInRange() = max\");\n        assertFalse(validator.isInRange(number21, 10, 20), \"isInRange() > max\");\n\n        // Test minValue()\n        assertFalse(validator.minValue(number9, 10), \"minValue() < min\");\n        assertTrue(validator.minValue(number10, 10), \"minValue() = min\");\n        assertTrue(validator.minValue(number11, 10), \"minValue() > min\");\n\n        // Test minValue()\n        assertTrue(validator.maxValue(number19, 20), \"maxValue() < max\");\n        assertTrue(validator.maxValue(number20, 20), \"maxValue() = max\");\n        assertFalse(validator.maxValue(number21, 20), \"maxValue() > max\");\n    }\n\n    /**\n     * Test BigIntegerValidator validate Methods\n     */\n    @Test\n    public void testBigIntegerValidatorMethods() {\n        final Locale locale = Locale.GERMAN;\n        final String pattern = \"0,00,00\";\n        final String patternVal = \"1,23,45\";\n        final String germanPatternVal = \"1.23.45\";\n        final String localeVal = \"12.345\";\n        final String defaultVal = \"12,345\";\n        final String xxxx = \"XXXX\";\n        final BigInteger expected = new BigInteger(\"12345\");\n        assertEquals(expected, BigIntegerValidator.getInstance().validate(defaultVal), \"validate(A) default\");\n        assertEquals(expected, BigIntegerValidator.getInstance().validate(localeVal, locale), \"validate(A) locale \");\n        assertEquals(expected, BigIntegerValidator.getInstance().validate(patternVal, pattern), \"validate(A) pattern\");\n        assertEquals(expected, BigIntegerValidator.getInstance().validate(germanPatternVal, pattern, Locale.GERMAN), \"validate(A) both\");\n\n        assertTrue(BigIntegerValidator.getInstance().isValid(defaultVal), \"isValid(A) default\");\n        assertTrue(BigIntegerValidator.getInstance().isValid(localeVal, locale), \"isValid(A) locale \");\n        assertTrue(BigIntegerValidator.getInstance().isValid(patternVal, pattern), \"isValid(A) pattern\");\n        assertTrue(BigIntegerValidator.getInstance().isValid(germanPatternVal, pattern, Locale.GERMAN), \"isValid(A) both\");\n\n        assertNull(BigIntegerValidator.getInstance().validate(xxxx), \"validate(B) default\");\n        assertNull(BigIntegerValidator.getInstance().validate(xxxx, locale), \"validate(B) locale \");\n        assertNull(BigIntegerValidator.getInstance().validate(xxxx, pattern), \"validate(B) pattern\");\n        assertNull(BigIntegerValidator.getInstance().validate(patternVal, pattern, Locale.GERMAN), \"validate(B) both\");\n\n        assertFalse(BigIntegerValidator.getInstance().isValid(xxxx), \"isValid(B) default\");\n        assertFalse(BigIntegerValidator.getInstance().isValid(xxxx, locale), \"isValid(B) locale \");\n        assertFalse(BigIntegerValidator.getInstance().isValid(xxxx, pattern), \"isValid(B) pattern\");\n        assertFalse(BigIntegerValidator.getInstance().isValid(patternVal, pattern, Locale.GERMAN), \"isValid(B) both\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/routines/DateValidator_compareYearsTest.java.DateValidator_compareYearsTest", "name": "DateValidator_compareYearsTest", "file_path": "src/test/java/org/apache/commons/validator/routines/DateValidator_compareYearsTest.java", "superclasses": "", "methods": ["[void]testCompareYears()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/DateValidator_compareYearsTest.java.DateValidator_compareYearsTest.[void]setUp()", "src/test/java/org/apache/commons/validator/routines/DateValidator_compareYearsTest.java.DateValidator_compareYearsTest.[Date]createDate(TimeZone,int,int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DateValidator_compareYearsTest {\n    private DateValidator dateValidator;\n    private static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");\n    private static final TimeZone EST = TimeZone.getTimeZone(\"EST\");\n\n    @BeforeEach\n    protected void setUp() {\n        dateValidator = new DateValidator();\n    }\n\n    @Test\n    public void testCompareYears() {\n        final int sameTime = 124522;\n        final int testDate = 20050823;\n\n        final Date value = createDate(GMT, testDate, sameTime); // test value\n        final Date date20060101 = createDate(GMT, 20060101, sameTime); // +1 year\n        final Date date20050101 = createDate(GMT, 20050101, sameTime); // same year\n        final Date date20041231 = createDate(GMT, 20041231, sameTime); // -1 year\n\n        assertEquals(-1, dateValidator.compareYears(value, date20060101, GMT), \"year LT\"); // +1 year\n        assertEquals(0, dateValidator.compareYears(value, date20050101, GMT), \"year EQ\"); // same year\n        assertEquals(1, dateValidator.compareYears(value, date20041231, GMT), \"year GT\"); // -1 year\n\n        // Compare using alternative TimeZone\n        final Date sameDayTwoAm = createDate(GMT, testDate, 20000);\n        assertEquals(-1, dateValidator.compareYears(value, date20060101, EST), \"year LT\"); // +1 year\n        assertEquals(0, dateValidator.compareYears(value, date20050101, EST), \"year EQ\"); // same year\n        assertEquals(1, dateValidator.compareYears(value, date20041231, EST), \"year GT\"); // -1 year\n    }\n\n    private Date createDate(TimeZone timeZone, int date, int time) {\n        Calendar calendar = Calendar.getInstance(timeZone);\n        calendar.set(Calendar.YEAR, date / 10000);\n        calendar.set(Calendar.MONTH, (date % 10000) / 100 - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, date % 100);\n        calendar.set(Calendar.HOUR_OF_DAY, time / 10000);\n        calendar.set(Calendar.MINUTE, (time % 10000) / 100);\n        calendar.set(Calendar.SECOND, time % 100);\n        calendar.set(Calendar.MILLISECOND, 0);\n        return calendar.getTime();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DateValidator dateValidator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DateValidator", "name": "dateValidator", "syntax_pass": true}, {"attribute_expression": "private static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "TimeZone", "name": "GMT = TimeZone.getTimeZone(\"GMT\")", "syntax_pass": true}, {"attribute_expression": "private static final TimeZone EST = TimeZone.getTimeZone(\"EST\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "TimeZone", "name": "EST = TimeZone.getTimeZone(\"EST\")", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/BigDecimalValidatorTest.java.BigDecimalValidatorTest", "name": "BigDecimalValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/BigDecimalValidatorTest.java", "superclasses": "AbstractNumberValidatorTest", "methods": ["[void]testBigDecimalRangeMinMax()", "[void]testBigDecimalValidatorMethods()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/BigDecimalValidatorTest.java.BigDecimalValidatorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTest Case for BigDecimalValidator.\n", "original_string": "public class BigDecimalValidatorTest extends AbstractNumberValidatorTest {\n\n    @Override\n    @BeforeEach\n    protected void setUp() {\n        super.setUp();\n\n        validator = new BigDecimalValidator(false);\n        strictValidator = new BigDecimalValidator();\n\n        testPattern = \"#,###.###\";\n\n        // testValidateMinMax()\n        max = null;\n        maxPlusOne = null;\n        min = null;\n        minMinusOne = null;\n\n        // testInvalidStrict()\n        invalidStrict = new String[] { null, \"\", \"X\", \"X12\", \"12X\", \"1X2\", \"1.234X\" };\n\n        // testInvalidNotStrict()\n        invalid = new String[] { null, \"\", \"X\", \"X12\" };\n\n        // testValid()\n        testNumber = new BigDecimal(\"1234.5\");\n        final Number testNumber2 = new BigDecimal(\".1\");\n        final Number testNumber3 = new BigDecimal(\"12345.67899\");\n        testZero = new BigDecimal(\"0\");\n        validStrict = new String[] { \"0\", \"1234.5\", \"1,234.5\", \".1\", \"12345.678990\" };\n        validStrictCompare = new Number[] { testZero, testNumber, testNumber, testNumber2, testNumber3 };\n        valid = new String[] { \"0\", \"1234.5\", \"1,234.5\", \"1,234.5\", \"1234.5X\" };\n        validCompare = new Number[] { testZero, testNumber, testNumber, testNumber, testNumber };\n\n        testStringUS = \"1,234.5\";\n        testStringDE = \"1.234,5\";\n\n        // Localized Pattern test\n        localeValue = testStringDE;\n        localePattern = \"#.###,#\";\n        testLocale = Locale.GERMANY;\n        localeExpected = testNumber;\n\n    }\n\n    /**\n     * Test BigDecimal Range/Min/Max\n     */\n    @Test\n    public void testBigDecimalRangeMinMax() {\n        final BigDecimalValidator validator = new BigDecimalValidator(true, AbstractNumberValidator.STANDARD_FORMAT, true);\n        final BigDecimal number9 = new BigDecimal(\"9\");\n        final BigDecimal number10 = new BigDecimal(\"10\");\n        final BigDecimal number11 = new BigDecimal(\"11\");\n        final BigDecimal number19 = new BigDecimal(\"19\");\n        final BigDecimal number20 = new BigDecimal(\"20\");\n        final BigDecimal number21 = new BigDecimal(\"21\");\n\n        final float min = 10;\n        final float max = 20;\n\n        // Test isInRange()\n        assertFalse(validator.isInRange(number9, min, max), \"isInRange(A) < min\");\n        assertTrue(validator.isInRange(number10, min, max), \"isInRange(A) = min\");\n        assertTrue(validator.isInRange(number11, min, max), \"isInRange(A) in range\");\n        assertTrue(validator.isInRange(number20, min, max), \"isInRange(A) = max\");\n        assertFalse(validator.isInRange(number21, min, max), \"isInRange(A) > max\");\n\n        // Test minValue()\n        assertFalse(validator.minValue(number9, min), \"minValue(A) < min\");\n        assertTrue(validator.minValue(number10, min), \"minValue(A) = min\");\n        assertTrue(validator.minValue(number11, min), \"minValue(A) > min\");\n\n        // Test minValue()\n        assertTrue(validator.maxValue(number19, max), \"maxValue(A) < max\");\n        assertTrue(validator.maxValue(number20, max), \"maxValue(A) = max\");\n        assertFalse(validator.maxValue(number21, max), \"maxValue(A) > max\");\n    }\n\n    /**\n     * Test BigDecimalValidator validate Methods\n     */\n    @Test\n    public void testBigDecimalValidatorMethods() {\n        final Locale locale = Locale.GERMAN;\n        final String pattern = \"0,00,00\";\n        final String patternVal = \"1,23,45\";\n        final String germanPatternVal = \"1.23.45\";\n        final String localeVal = \"12.345\";\n        final String defaultVal = \"12,345\";\n        final String xxxx = \"XXXX\";\n        final BigDecimal expected = new BigDecimal(12345);\n        assertEquals(expected, BigDecimalValidator.getInstance().validate(defaultVal), \"validate(A) default\");\n        assertEquals(expected, BigDecimalValidator.getInstance().validate(localeVal, locale), \"validate(A) locale \");\n        assertEquals(expected, BigDecimalValidator.getInstance().validate(patternVal, pattern), \"validate(A) pattern\");\n        assertEquals(expected, BigDecimalValidator.getInstance().validate(germanPatternVal, pattern, Locale.GERMAN), \"validate(A) both\");\n\n        assertTrue(BigDecimalValidator.getInstance().isValid(defaultVal), \"isValid(A) default\");\n        assertTrue(BigDecimalValidator.getInstance().isValid(localeVal, locale), \"isValid(A) locale \");\n        assertTrue(BigDecimalValidator.getInstance().isValid(patternVal, pattern), \"isValid(A) pattern\");\n        assertTrue(BigDecimalValidator.getInstance().isValid(germanPatternVal, pattern, Locale.GERMAN), \"isValid(A) both\");\n\n        assertNull(BigDecimalValidator.getInstance().validate(xxxx), \"validate(B) default\");\n        assertNull(BigDecimalValidator.getInstance().validate(xxxx, locale), \"validate(B) locale\");\n        assertNull(BigDecimalValidator.getInstance().validate(xxxx, pattern), \"validate(B) pattern\");\n        assertNull(BigDecimalValidator.getInstance().validate(patternVal, pattern, Locale.GERMAN), \"validate(B) both\");\n\n        assertFalse(BigDecimalValidator.getInstance().isValid(xxxx), \"isValid(B) default\");\n        assertFalse(BigDecimalValidator.getInstance().isValid(xxxx, locale), \"isValid(B) locale\");\n        assertFalse(BigDecimalValidator.getInstance().isValid(xxxx, pattern), \"isValid(B) pattern\");\n        assertFalse(BigDecimalValidator.getInstance().isValid(patternVal, pattern, Locale.GERMAN), \"isValid(B) both\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/routines/UrlValidatorTest.java.UrlValidatorTest", "name": "UrlValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/UrlValidatorTest.java", "superclasses": "", "methods": ["[void]testFragments()", "[void]testIsValid()", "[void]testIsValidScheme()", "[void]testValidateUrl()", "[void]testValidator202()", "[void]testValidator204()", "[void]testValidator218()", "[void]testValidator235()", "[void]testValidator248()", "[void]testValidator276()", "[void]testValidator283()", "[void]testValidator288()", "[void]testValidator290()", "[void]testValidator309()", "[void]testValidator339()", "[void]testValidator339IDN()", "[void]testValidator342()", "[void]testValidator353()", "[void]testValidator361()", "[void]testValidator363()", "[void]testValidator375()", "[void]testValidator380()", "[void]testValidator382()", "[void]testValidator391FAILS()", "[void]testValidator391OK()", "[void]testValidator411()", "[void]testValidator420()", "[void]testValidator452()", "[void]testValidator464()", "[void]testValidator467()", "[void]testValidator473Part1()", "[void]testValidator473Part2()", "[void]testValidator473Part3()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/UrlValidatorTest.java.UrlValidatorTest.[boolean]incrementTestPartsIndex(int[],Object[])", "src/test/java/org/apache/commons/validator/routines/UrlValidatorTest.java.UrlValidatorTest.[void]main(String[])", "src/test/java/org/apache/commons/validator/routines/UrlValidatorTest.java.UrlValidatorTest.[void]setUp()", "src/test/java/org/apache/commons/validator/routines/UrlValidatorTest.java.UrlValidatorTest.[void]testIsValid(Object[],long)", "src/test/java/org/apache/commons/validator/routines/UrlValidatorTest.java.UrlValidatorTest.[String]testPartsIndextoString()"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test for url validations.\n", "original_string": "public class UrlValidatorTest {\n\n    static boolean incrementTestPartsIndex(final int[] testPartsIndex, final Object[] testParts) {\n        boolean carry = true; // add 1 to lowest order part.\n        boolean maxIndex = true;\n        for (int testPartsIndexIndex = testPartsIndex.length - 1; testPartsIndexIndex >= 0; --testPartsIndexIndex) {\n            int index = testPartsIndex[testPartsIndexIndex];\n            final ResultPair[] part = (ResultPair[]) testParts[testPartsIndexIndex];\n            maxIndex &= index == part.length - 1;\n            if (carry) {\n                if (index < part.length - 1) {\n                    index++;\n                    testPartsIndex[testPartsIndexIndex] = index;\n                    carry = false;\n                } else {\n                    testPartsIndex[testPartsIndexIndex] = 0;\n                    carry = true;\n                }\n            }\n        }\n\n        return !maxIndex;\n    }\n\n    /**\n     * Validator for checking URL parsing\n     *\n     * @param args   URLs to validate\n     */\n    public static void main(final String[] args) {\n        final UrlValidator uv = new UrlValidator();\n        for (final String arg : args) {\n            try {\n                URI uri = new URI(arg);\n                uri = uri.normalize();\n                System.out.println(uri.toString());\n                System.out.printf(\"URI scheme: %s%n\", uri.getScheme());\n                System.out.printf(\"URI scheme specific part: %s%n\", uri.getSchemeSpecificPart());\n                System.out.printf(\"URI raw scheme specific part: %s%n\", uri.getRawSchemeSpecificPart());\n                System.out.printf(\"URI auth: %s%n\", uri.getAuthority());\n                System.out.printf(\"URI raw auth: %s%n\", uri.getRawAuthority());\n                System.out.printf(\"URI userInfo: %s%n\", uri.getUserInfo());\n                System.out.printf(\"URI raw userInfo: %s%n\", uri.getRawUserInfo());\n                System.out.printf(\"URI host: %s%n\", uri.getHost());\n                System.out.printf(\"URI port: %s%n\", uri.getPort());\n                System.out.printf(\"URI path: %s%n\", uri.getPath());\n                System.out.printf(\"URI raw path: %s%n\", uri.getRawPath());\n                System.out.printf(\"URI query: %s%n\", uri.getQuery());\n                System.out.printf(\"URI raw query: %s%n\", uri.getRawQuery());\n                System.out.printf(\"URI fragment: %s%n\", uri.getFragment());\n                System.out.printf(\"URI raw fragment: %s%n\", uri.getRawFragment());\n            } catch (final URISyntaxException e) {\n                System.out.println(e.getMessage());\n            }\n            System.out.printf(\"isValid: %s%n\", uv.isValid(arg));\n        }\n    }\n\n    private final boolean printStatus = false;\n\n    private final boolean printIndex = false; // print index that indicates current scheme,host,port,path, query test were using.\n\n    /**\n     * The data given below approximates the 4 parts of a URL <scheme>://<authority><path>?<query> except that the port number is broken out of authority to\n     * increase the number of permutations. A complete URL is composed of a scheme+authority+port+path+query, all of which must be individually valid for the\n     * entire URL to be considered valid.\n     */\n    ResultPair[] testUrlScheme = { new ResultPair(\"http://\", true), new ResultPair(\"ftp://\", true), new ResultPair(\"h3t://\", true),\n            new ResultPair(\"3ht://\", false), new ResultPair(\"http:/\", false), new ResultPair(\"http:\", false), new ResultPair(\"http/\", false),\n            new ResultPair(\"://\", false) };\n\n    ResultPair[] testUrlAuthority = { new ResultPair(\"www.google.com\", true), new ResultPair(\"www.google.com.\", true), new ResultPair(\"go.com\", true),\n            new ResultPair(\"go.au\", true), new ResultPair(\"0.0.0.0\", true), new ResultPair(\"255.255.255.255\", true), new ResultPair(\"256.256.256.256\", false),\n            new ResultPair(\"255.com\", true), new ResultPair(\"1.2.3.4.5\", false), new ResultPair(\"1.2.3.4.\", false), new ResultPair(\"1.2.3\", false),\n            new ResultPair(\".1.2.3.4\", false), new ResultPair(\"go.a\", false), new ResultPair(\"go.a1a\", false), new ResultPair(\"go.cc\", true),\n            new ResultPair(\"go.1aa\", false), new ResultPair(\"aaa.\", false), new ResultPair(\".aaa\", false), new ResultPair(\"aaa\", false),\n            new ResultPair(\"\", false) };\n\n    ResultPair[] testUrlPort = { new ResultPair(\":80\", true), new ResultPair(\":65535\", true), // max possible\n            new ResultPair(\":65536\", false), // max possible +1\n            new ResultPair(\":0\", true), new ResultPair(\"\", true), new ResultPair(\":-1\", false), new ResultPair(\":65636\", false),\n            new ResultPair(\":999999999999999999\", false), new ResultPair(\":65a\", false) };\n\n    ResultPair[] testPath = { new ResultPair(\"/test1\", true), new ResultPair(\"/t123\", true), new ResultPair(\"/$23\", true), new ResultPair(\"/..\", false),\n            new ResultPair(\"/../\", false), new ResultPair(\"/test1/\", true), new ResultPair(\"\", true), new ResultPair(\"/test1/file\", true),\n            new ResultPair(\"/..//file\", false), new ResultPair(\"/test1//file\", false) };\n\n    // Test allow2slash, noFragment\n    ResultPair[] testUrlPathOptions = { new ResultPair(\"/test1\", true), new ResultPair(\"/t123\", true), new ResultPair(\"/$23\", true),\n            new ResultPair(\"/..\", false), new ResultPair(\"/../\", false), new ResultPair(\"/test1/\", true), new ResultPair(\"/#\", false), new ResultPair(\"\", true),\n            new ResultPair(\"/test1/file\", true), new ResultPair(\"/t123/file\", true), new ResultPair(\"/$23/file\", true), new ResultPair(\"/../file\", false),\n            new ResultPair(\"/..//file\", false), new ResultPair(\"/test1//file\", true), new ResultPair(\"/#/file\", false) };\n\n    ResultPair[] testUrlQuery = { new ResultPair(\"?action=view\", true), new ResultPair(\"?action=edit&mode=up\", true), new ResultPair(\"\", true) };\n\n    Object[] testUrlParts = { testUrlScheme, testUrlAuthority, testUrlPort, testPath, testUrlQuery };\n\n    Object[] testUrlPartsOptions = { testUrlScheme, testUrlAuthority, testUrlPort, testUrlPathOptions, testUrlQuery };\n\n    int[] testPartsIndex = { 0, 0, 0, 0, 0 };\n\n    // Test data for individual url parts\n    private final String[] schemes = { \"http\", \"gopher\", \"g0-To+.\", \"not_valid\" // TODO this will need to be dropped if the ctor validates schemes\n    };\n\n    ResultPair[] testScheme = { new ResultPair(\"http\", true), new ResultPair(\"ftp\", false), new ResultPair(\"httpd\", false), new ResultPair(\"gopher\", true),\n            new ResultPair(\"g0-to+.\", true), new ResultPair(\"not_valid\", false), // underscore not allowed\n            new ResultPair(\"HtTp\", true), new ResultPair(\"telnet\", false) };\n\n    @Before\n    public void setUp() {\n        for (int index = 0; index < testPartsIndex.length - 1; index++) {\n            testPartsIndex[index] = 0;\n        }\n    }\n\n    @Test\n    public void testFragments() {\n        final String[] schemes = { \"http\", \"https\" };\n        UrlValidator urlValidator = new UrlValidator(schemes, UrlValidator.NO_FRAGMENTS);\n        assertFalse(urlValidator.isValid(\"http://apache.org/a/b/c#frag\"));\n        urlValidator = new UrlValidator(schemes);\n        assertTrue(urlValidator.isValid(\"http://apache.org/a/b/c#frag\"));\n    }\n\n    @Test\n    public void testIsValid() {\n        testIsValid(testUrlParts, UrlValidator.ALLOW_ALL_SCHEMES);\n        setUp();\n        final long options = UrlValidator.ALLOW_2_SLASHES + UrlValidator.ALLOW_ALL_SCHEMES + UrlValidator.NO_FRAGMENTS;\n\n        testIsValid(testUrlPartsOptions, options);\n    }\n\n    /**\n     * Create set of tests by taking the testUrlXXX arrays and running through all possible permutations of their combinations.\n     *\n     * @param testObjects Used to create a url.\n     */\n    public void testIsValid(final Object[] testObjects, final long options) {\n        final UrlValidator urlVal = new UrlValidator(null, null, options);\n        assertTrue(urlVal.isValid(\"http://www.google.com\"));\n        assertTrue(urlVal.isValid(\"http://www.google.com/\"));\n        int statusPerLine = 60;\n        int printed = 0;\n        if (printIndex) {\n            statusPerLine = 6;\n        }\n        do {\n            final StringBuilder testBuffer = new StringBuilder();\n            boolean expected = true;\n            for (int testPartsIndexIndex = 0; testPartsIndexIndex < testPartsIndex.length; ++testPartsIndexIndex) {\n                final int index = testPartsIndex[testPartsIndexIndex];\n                final ResultPair[] part = (ResultPair[]) testObjects[testPartsIndexIndex];\n                testBuffer.append(part[index].item);\n                expected &= part[index].valid;\n            }\n            final String url = testBuffer.toString();\n            final boolean result = urlVal.isValid(url);\n            assertEquals(expected, result, url);\n            if (printStatus) {\n                if (printIndex) {\n                    System.out.print(testPartsIndextoString());\n                } else if (result == expected) {\n                    System.out.print('.');\n                } else {\n                    System.out.print('X');\n                }\n                printed++;\n                if (printed == statusPerLine) {\n                    System.out.println();\n                    printed = 0;\n                }\n            }\n        } while (incrementTestPartsIndex(testPartsIndex, testObjects));\n        if (printStatus) {\n            System.out.println();\n        }\n    }\n\n    @Test\n    public void testIsValidScheme() {\n        if (printStatus) {\n            System.out.print(\"\\n testIsValidScheme() \");\n        }\n        // UrlValidator urlVal = new UrlValidator(schemes,false,false,false);\n        final UrlValidator urlVal = new UrlValidator(schemes, 0);\n        for (final ResultPair testPair : testScheme) {\n            final boolean result = urlVal.isValidScheme(testPair.item);\n            assertEquals(testPair.valid, result, testPair.item);\n            if (printStatus) {\n                if (result == testPair.valid) {\n                    System.out.print('.');\n                } else {\n                    System.out.print('X');\n                }\n            }\n        }\n        if (printStatus) {\n            System.out.println();\n        }\n\n    }\n\n    private String testPartsIndextoString() {\n        final StringBuilder carryMsg = new StringBuilder(\"{\");\n        for (int testPartsIndexIndex = 0; testPartsIndexIndex < testPartsIndex.length; ++testPartsIndexIndex) {\n            carryMsg.append(testPartsIndex[testPartsIndexIndex]);\n            if (testPartsIndexIndex < testPartsIndex.length - 1) {\n                carryMsg.append(',');\n            } else {\n                carryMsg.append('}');\n            }\n        }\n        return carryMsg.toString();\n\n    }\n\n    @Test\n    public void testValidateUrl() {\n        assertTrue(true);\n    }\n\n    @Test\n    public void testValidator202() {\n        final String[] schemes = { \"http\", \"https\" };\n        final UrlValidator urlValidator = new UrlValidator(schemes, UrlValidator.NO_FRAGMENTS);\n        assertTrue(urlValidator\n                .isValid(\"http://l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.l.org\"));\n    }\n\n    @Test\n    public void testValidator204() {\n        final String[] schemes = { \"http\", \"https\" };\n        final UrlValidator urlValidator = new UrlValidator(schemes);\n        assertTrue(urlValidator.isValid(\"http://tech.yahoo.com/rc/desktops/102;_ylt=Ao8yevQHlZ4On0O3ZJGXLEQFLZA5\"));\n    }\n\n    @Test\n    public void testValidator218() {\n        final UrlValidator validator = new UrlValidator(UrlValidator.ALLOW_2_SLASHES);\n        assertTrue(validator.isValid(\"http://somewhere.com/pathxyz/file(1).html\"), \"parentheses should be valid in URLs\");\n    }\n\n    @Test\n    public void testValidator235() {\n        final String version = SystemProperties.getJavaVersion();\n        if (version.compareTo(\"1.6\") < 0) {\n            System.out.println(\"Cannot run Unicode IDN tests\");\n            return; // Cannot run the test\n        }\n        final UrlValidator validator = new UrlValidator();\n        assertTrue(validator.isValid(\"http://xn--d1abbgf6aiiy.xn--p1ai\"), \"xn--d1abbgf6aiiy.xn--p1ai should validate\");\n        assertTrue(validator.isValid(\"http://\u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442.\u0440\u0444\"), \"\u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442.\u0440\u0444 should validate\");\n        assertTrue(validator.isValid(\"http://www.b\\u00fccher.ch\"), \"www.b\\u00fccher.ch should validate\");\n        assertFalse(validator.isValid(\"http://www.\\uFFFD.ch\"), \"www.\\uFFFD.ch FFFD should fail\");\n        assertTrue(validator.isValid(\"ftp://www.b\\u00fccher.ch\"), \"www.b\\u00fccher.ch should validate\");\n        assertFalse(validator.isValid(\"ftp://www.\\uFFFD.ch\"), \"www.\\uFFFD.ch FFFD should fail\");\n    }\n\n    @Test\n    public void testValidator248() {\n        final RegexValidator regex = new RegexValidator(\"localhost\", \".*\\\\.my-testing\");\n        UrlValidator validator = new UrlValidator(regex, 0);\n\n        assertTrue(validator.isValid(\"http://localhost/test/index.html\"), \"localhost URL should validate\");\n        assertTrue(validator.isValid(\"http://first.my-testing/test/index.html\"), \"first.my-testing should validate\");\n        assertTrue(validator.isValid(\"http://sup3r.my-testing/test/index.html\"), \"sup3r.my-testing should validate\");\n\n        assertFalse(validator.isValid(\"http://broke.my-test/test/index.html\"), \"broke.my-test should not validate\");\n\n        assertTrue(validator.isValid(\"http://www.apache.org/test/index.html\"), \"www.apache.org should still validate\");\n\n        // Now check using options\n        validator = new UrlValidator(UrlValidator.ALLOW_LOCAL_URLS);\n\n        assertTrue(validator.isValid(\"http://localhost/test/index.html\"), \"localhost URL should validate\");\n\n        assertTrue(validator.isValid(\"http://machinename/test/index.html\"), \"machinename URL should validate\");\n\n        assertTrue(validator.isValid(\"http://www.apache.org/test/index.html\"), \"www.apache.org should still validate\");\n    }\n\n    @Test\n    public void testValidator276() {\n        // file:// isn't allowed by default\n        UrlValidator validator = new UrlValidator();\n\n        assertTrue(validator.isValid(\"http://www.apache.org/test/index.html\"), \"http://apache.org/ should be allowed by default\");\n\n        assertFalse(validator.isValid(\"file:///C:/some.file\"), \"file:///c:/ shouldn't be allowed by default\");\n\n        assertFalse(validator.isValid(\"file:///C:\\\\some.file\"), \"file:///c:\\\\ shouldn't be allowed by default\");\n\n        assertFalse(validator.isValid(\"file:///etc/hosts\"), \"file:///etc/ shouldn't be allowed by default\");\n\n        assertFalse(validator.isValid(\"file://localhost/etc/hosts\"), \"file://localhost/etc/ shouldn't be allowed by default\");\n\n        assertFalse(validator.isValid(\"file://localhost/c:/some.file\"), \"file://localhost/c:/ shouldn't be allowed by default\");\n\n        // Turn it on, and check\n        // Note - we need to enable local urls when working with file:\n        validator = new UrlValidator(new String[] { \"http\", \"file\" }, UrlValidator.ALLOW_LOCAL_URLS);\n\n        assertTrue(validator.isValid(\"http://www.apache.org/test/index.html\"), \"http://apache.org/ should be allowed by default\");\n\n        assertTrue(validator.isValid(\"file:///C:/some.file\"), \"file:///c:/ should now be allowed\");\n\n        // Only allow forward slashes\n        assertFalse(validator.isValid(\"file:///C:\\\\some.file\"), \"file:///c:\\\\ should not be allowed\");\n\n        assertTrue(validator.isValid(\"file:///etc/hosts\"), \"file:///etc/ should now be allowed\");\n\n        assertTrue(validator.isValid(\"file://localhost/etc/hosts\"), \"file://localhost/etc/ should now be allowed\");\n\n        assertTrue(validator.isValid(\"file://localhost/c:/some.file\"), \"file://localhost/c:/ should now be allowed\");\n\n        // These are never valid\n        assertFalse(validator.isValid(\"file://C:/some.file\"), \"file://c:/ shouldn't ever be allowed, needs file:///c:/\");\n\n        assertFalse(validator.isValid(\"file://C:\\\\some.file\"), \"file://c:\\\\ shouldn't ever be allowed, needs file:///c:/\");\n    }\n\n    @Test\n    public void testValidator283() {\n        final UrlValidator validator = new UrlValidator();\n        assertFalse(validator.isValid(\"http://finance.yahoo.com/news/Owners-54B-NY-housing-apf-2493139299.html?x=0&ap=%fr\"));\n        assertTrue(validator.isValid(\"http://finance.yahoo.com/news/Owners-54B-NY-housing-apf-2493139299.html?x=0&ap=%22\"));\n    }\n\n    @Test\n    public void testValidator288() {\n        UrlValidator validator = new UrlValidator(UrlValidator.ALLOW_LOCAL_URLS);\n\n        assertTrue(validator.isValid(\"http://hostname\"), \"hostname should validate\");\n\n        assertTrue(validator.isValid(\"http://hostname/test/index.html\"), \"hostname with path should validate\");\n\n        assertTrue(validator.isValid(\"http://localhost/test/index.html\"), \"localhost URL should validate\");\n\n        assertFalse(validator.isValid(\"http://first.my-testing/test/index.html\"), \"first.my-testing should not validate\");\n\n        assertFalse(validator.isValid(\"http://broke.hostname/test/index.html\"), \"broke.hostname should not validate\");\n\n        assertTrue(validator.isValid(\"http://www.apache.org/test/index.html\"), \"www.apache.org should still validate\");\n\n        // Turn it off, and check\n        validator = new UrlValidator(0);\n\n        assertFalse(validator.isValid(\"http://hostname\"), \"hostname should no longer validate\");\n\n        assertFalse(validator.isValid(\"http://localhost/test/index.html\"), \"localhost URL should no longer validate\");\n\n        assertTrue(validator.isValid(\"http://www.apache.org/test/index.html\"), \"www.apache.org should still validate\");\n    }\n\n    @Test\n    public void testValidator290() {\n        final UrlValidator validator = new UrlValidator();\n        assertTrue(validator.isValid(\"http://xn--h1acbxfam.idn.icann.org/\"));\n//        assertTrue(validator.isValid(\"http://xn--e1afmkfd.xn--80akhbyknj4f\"));\n        // Internationalized country code top-level domains\n        assertTrue(validator.isValid(\"http://test.xn--lgbbat1ad8j\")); // Algeria\n        assertTrue(validator.isValid(\"http://test.xn--fiqs8s\")); // China\n        assertTrue(validator.isValid(\"http://test.xn--fiqz9s\")); // China\n        assertTrue(validator.isValid(\"http://test.xn--wgbh1c\")); // Egypt\n        assertTrue(validator.isValid(\"http://test.xn--j6w193g\")); // Hong Kong\n        assertTrue(validator.isValid(\"http://test.xn--h2brj9c\")); // India\n        assertTrue(validator.isValid(\"http://test.xn--mgbbh1a71e\")); // India\n        assertTrue(validator.isValid(\"http://test.xn--fpcrj9c3d\")); // India\n        assertTrue(validator.isValid(\"http://test.xn--gecrj9c\")); // India\n        assertTrue(validator.isValid(\"http://test.xn--s9brj9c\")); // India\n        assertTrue(validator.isValid(\"http://test.xn--xkc2dl3a5ee0h\")); // India\n        assertTrue(validator.isValid(\"http://test.xn--45brj9c\")); // India\n        assertTrue(validator.isValid(\"http://test.xn--mgba3a4f16a\")); // Iran\n        assertTrue(validator.isValid(\"http://test.xn--mgbayh7gpa\")); // Jordan\n        assertTrue(validator.isValid(\"http://test.xn--mgbc0a9azcg\")); // Morocco\n        assertTrue(validator.isValid(\"http://test.xn--ygbi2ammx\")); // Palestinian Territory\n        assertTrue(validator.isValid(\"http://test.xn--wgbl6a\")); // Qatar\n        assertTrue(validator.isValid(\"http://test.xn--p1ai\")); // Russia\n        assertTrue(validator.isValid(\"http://test.xn--mgberp4a5d4ar\")); // Saudi Arabia\n        assertTrue(validator.isValid(\"http://test.xn--90a3ac\")); // Serbia\n        assertTrue(validator.isValid(\"http://test.xn--yfro4i67o\")); // Singapore\n        assertTrue(validator.isValid(\"http://test.xn--clchc0ea0b2g2a9gcd\")); // Singapore\n        assertTrue(validator.isValid(\"http://test.xn--3e0b707e\")); // South Korea\n        assertTrue(validator.isValid(\"http://test.xn--fzc2c9e2c\")); // Sri Lanka\n        assertTrue(validator.isValid(\"http://test.xn--xkc2al3hye2a\")); // Sri Lanka\n        assertTrue(validator.isValid(\"http://test.xn--ogbpf8fl\")); // Syria\n        assertTrue(validator.isValid(\"http://test.xn--kprw13d\")); // Taiwan\n        assertTrue(validator.isValid(\"http://test.xn--kpry57d\")); // Taiwan\n        assertTrue(validator.isValid(\"http://test.xn--o3cw4h\")); // Thailand\n        assertTrue(validator.isValid(\"http://test.xn--pgbs0dh\")); // Tunisia\n        assertTrue(validator.isValid(\"http://test.xn--mgbaam7a8h\")); // United Arab Emirates\n        // Proposed internationalized ccTLDs\n//        assertTrue(validator.isValid(\"http://test.xn--54b7fta0cc\")); // Bangladesh\n//        assertTrue(validator.isValid(\"http://test.xn--90ae\")); // Bulgaria\n//        assertTrue(validator.isValid(\"http://test.xn--node\")); // Georgia\n//        assertTrue(validator.isValid(\"http://test.xn--4dbrk0ce\")); // Israel\n//        assertTrue(validator.isValid(\"http://test.xn--mgb9awbf\")); // Oman\n//        assertTrue(validator.isValid(\"http://test.xn--j1amh\")); // Ukraine\n//        assertTrue(validator.isValid(\"http://test.xn--mgb2ddes\")); // Yemen\n        // Test TLDs\n//        assertTrue(validator.isValid(\"http://test.xn--kgbechtv\")); // Arabic\n//        assertTrue(validator.isValid(\"http://test.xn--hgbk6aj7f53bba\")); // Persian\n//        assertTrue(validator.isValid(\"http://test.xn--0zwm56d\")); // Chinese\n//        assertTrue(validator.isValid(\"http://test.xn--g6w251d\")); // Chinese\n//        assertTrue(validator.isValid(\"http://test.xn--80akhbyknj4f\")); // Russian\n//        assertTrue(validator.isValid(\"http://test.xn--11b5bs3a9aj6g\")); // Hindi\n//        assertTrue(validator.isValid(\"http://test.xn--jxalpdlp\")); // Greek\n//        assertTrue(validator.isValid(\"http://test.xn--9t4b11yi5a\")); // Korean\n//        assertTrue(validator.isValid(\"http://test.xn--deba0ad\")); // Yiddish\n//        assertTrue(validator.isValid(\"http://test.xn--zckzah\")); // Japanese\n//        assertTrue(validator.isValid(\"http://test.xn--hlcj6aya9esc7a\")); // Tamil\n    }\n\n    @Test\n    public void testValidator309() {\n        UrlValidator urlValidator = new UrlValidator();\n        assertTrue(urlValidator.isValid(\"http://sample.ondemand.com/\"));\n        assertTrue(urlValidator.isValid(\"hTtP://sample.ondemand.CoM/\"));\n        assertTrue(urlValidator.isValid(\"httpS://SAMPLE.ONEMAND.COM/\"));\n        urlValidator = new UrlValidator(new String[] { \"HTTP\", \"HTTPS\" });\n        assertTrue(urlValidator.isValid(\"http://sample.ondemand.com/\"));\n        assertTrue(urlValidator.isValid(\"hTtP://sample.ondemand.CoM/\"));\n        assertTrue(urlValidator.isValid(\"httpS://SAMPLE.ONEMAND.COM/\"));\n    }\n\n    @Test\n    public void testValidator339() {\n        final UrlValidator urlValidator = new UrlValidator();\n        assertTrue(urlValidator.isValid(\"http://www.cnn.com/WORLD/?hpt=sitenav\")); // without\n        assertTrue(urlValidator.isValid(\"http://www.cnn.com./WORLD/?hpt=sitenav\")); // with\n        assertFalse(urlValidator.isValid(\"http://www.cnn.com../\")); // doubly dotty\n        assertFalse(urlValidator.isValid(\"http://www.cnn.invalid/\"));\n        assertFalse(urlValidator.isValid(\"http://www.cnn.invalid./\")); // check . does not affect invalid domains\n    }\n\n    @Test\n    public void testValidator339IDN() {\n        final UrlValidator urlValidator = new UrlValidator();\n        assertTrue(urlValidator.isValid(\"http://\u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442.\u0440\u0444/WORLD/?hpt=sitenav\")); // without\n        assertTrue(urlValidator.isValid(\"http://\u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442.\u0440\u0444./WORLD/?hpt=sitenav\")); // with\n        assertFalse(urlValidator.isValid(\"http://\u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442.\u0440\u0444..../\")); // very dotty\n        assertFalse(urlValidator.isValid(\"http://\u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442.\u0440\u0444.../\")); // triply dotty\n        assertFalse(urlValidator.isValid(\"http://\u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442.\u0440\u0444../\")); // doubly dotty\n    }\n\n    @Test\n    public void testValidator342() {\n        final UrlValidator urlValidator = new UrlValidator();\n        assertTrue(urlValidator.isValid(\"http://example.rocks/\"));\n        assertTrue(urlValidator.isValid(\"http://example.rocks\"));\n    }\n\n    @Test\n    public void testValidator353() { // userinfo\n        final UrlValidator validator = new UrlValidator();\n        assertTrue(validator.isValid(\"http://www.apache.org:80/path\"));\n        assertTrue(validator.isValid(\"http://user:pass@www.apache.org:80/path\"));\n        assertTrue(validator.isValid(\"http://user:@www.apache.org:80/path\"));\n        assertTrue(validator.isValid(\"http://user@www.apache.org:80/path\"));\n        assertTrue(validator.isValid(\"http://us%00er:-._~!$&'()*+,;=@www.apache.org:80/path\"));\n        assertFalse(validator.isValid(\"http://:pass@www.apache.org:80/path\"));\n        assertFalse(validator.isValid(\"http://:@www.apache.org:80/path\"));\n        assertFalse(validator.isValid(\"http://user:pa:ss@www.apache.org/path\"));\n        assertFalse(validator.isValid(\"http://user:pa@ss@www.apache.org/path\"));\n    }\n\n    @Test\n    public void testValidator361() {\n        final UrlValidator validator = new UrlValidator();\n        assertTrue(validator.isValid(\"http://hello.tokyo/\"));\n    }\n\n    @Test\n    public void testValidator363() {\n        final UrlValidator urlValidator = new UrlValidator();\n        assertTrue(urlValidator.isValid(\"http://www.example.org/a/b/hello..world\"));\n        assertTrue(urlValidator.isValid(\"http://www.example.org/a/hello..world\"));\n        assertTrue(urlValidator.isValid(\"http://www.example.org/hello.world/\"));\n        assertTrue(urlValidator.isValid(\"http://www.example.org/hello..world/\"));\n        assertTrue(urlValidator.isValid(\"http://www.example.org/hello.world\"));\n        assertTrue(urlValidator.isValid(\"http://www.example.org/hello..world\"));\n        assertTrue(urlValidator.isValid(\"http://www.example.org/..world\"));\n        assertTrue(urlValidator.isValid(\"http://www.example.org/.../world\"));\n        assertFalse(urlValidator.isValid(\"http://www.example.org/../world\"));\n        assertFalse(urlValidator.isValid(\"http://www.example.org/..\"));\n        assertFalse(urlValidator.isValid(\"http://www.example.org/../\"));\n        assertFalse(urlValidator.isValid(\"http://www.example.org/./..\"));\n        assertFalse(urlValidator.isValid(\"http://www.example.org/././..\"));\n        assertTrue(urlValidator.isValid(\"http://www.example.org/...\"));\n        assertTrue(urlValidator.isValid(\"http://www.example.org/.../\"));\n        assertTrue(urlValidator.isValid(\"http://www.example.org/.../..\"));\n    }\n\n    @Test\n    public void testValidator375() {\n        final UrlValidator validator = new UrlValidator();\n        String url = \"http://[FEDC:BA98:7654:3210:FEDC:BA98:7654:3210]:80/index.html\";\n        assertTrue(validator.isValid(url), \"IPv6 address URL should validate: \" + url);\n        url = \"http://[::1]:80/index.html\";\n        assertTrue(validator.isValid(url), \"IPv6 address URL should validate: \" + url);\n        url = \"http://FEDC:BA98:7654:3210:FEDC:BA98:7654:3210:80/index.html\";\n        assertFalse(validator.isValid(url), \"IPv6 address without [] should not validate: \" + url);\n    }\n\n    @Test\n    public void testValidator380() {\n        final UrlValidator validator = new UrlValidator();\n        assertTrue(validator.isValid(\"http://www.apache.org:80/path\"));\n        assertTrue(validator.isValid(\"http://www.apache.org:8/path\"));\n        assertTrue(validator.isValid(\"http://www.apache.org:/path\"));\n    }\n\n    @Test\n    public void testValidator382() {\n        final UrlValidator validator = new UrlValidator();\n        assertTrue(validator.isValid(\"ftp://username:password@example.com:8042/over/there/index.dtb?type=animal&name=narwhal#nose\"));\n    }\n\n    @Test\n    public void testValidator391FAILS() {\n        final String[] schemes = { \"file\" };\n        final UrlValidator urlValidator = new UrlValidator(schemes);\n        assertTrue(urlValidator.isValid(\"file:/C:/path/to/dir/\"));\n    }\n\n    @Test\n    public void testValidator391OK() {\n        final String[] schemes = { \"file\" };\n        final UrlValidator urlValidator = new UrlValidator(schemes);\n        assertTrue(urlValidator.isValid(\"file:///C:/path/to/dir/\"));\n    }\n\n    @Test\n    public void testValidator411() {\n        final UrlValidator urlValidator = new UrlValidator();\n        assertTrue(urlValidator.isValid(\"http://example.rocks:/\"));\n        assertTrue(urlValidator.isValid(\"http://example.rocks:0/\"));\n        assertTrue(urlValidator.isValid(\"http://example.rocks:65535/\"));\n        assertFalse(urlValidator.isValid(\"http://example.rocks:65536/\"));\n        assertFalse(urlValidator.isValid(\"http://example.rocks:100000/\"));\n    }\n\n    @Test\n    public void testValidator420() {\n        final UrlValidator validator = new UrlValidator();\n        assertFalse(validator.isValid(\"http://example.com/serach?address=Main Avenue\"));\n        assertTrue(validator.isValid(\"http://example.com/serach?address=Main%20Avenue\"));\n        assertTrue(validator.isValid(\"http://example.com/serach?address=Main+Avenue\"));\n    }\n\n    @Test\n    public void testValidator452() {\n        final UrlValidator urlValidator = new UrlValidator();\n        assertTrue(urlValidator.isValid(\"http://[::FFFF:129.144.52.38]:80/index.html\"));\n    }\n\n    @Test\n    public void testValidator464() {\n        final String[] schemes = { \"file\" };\n        final UrlValidator urlValidator = new UrlValidator(schemes);\n        final String fileNAK = \"file://bad ^ domain.com/label/test\";\n        assertFalse(urlValidator.isValid(fileNAK), fileNAK);\n    }\n\n    @Test\n    public void testValidator467() {\n        final UrlValidator validator = new UrlValidator(UrlValidator.ALLOW_2_SLASHES);\n        assertTrue(validator.isValid(\"https://example.com/some_path/path/\"));\n        assertTrue(validator.isValid(\"https://example.com//somepath/path/\"));\n        assertTrue(validator.isValid(\"https://example.com//some_path/path/\"));\n        assertTrue(validator.isValid(\"http://example.com//_test\")); // VALIDATOR-429\n    }\n\n    @Test\n    public void testValidator473Part1() { // reject null DomainValidator\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> new UrlValidator(new String[] {}, null, 0L, null));\n        assertEquals(\"DomainValidator must not be null\", thrown.getMessage());\n    }\n\n    @Test\n    public void testValidator473Part2() { // reject null DomainValidator with mismatched allowLocal\n        final List<DomainValidator.Item> items = new ArrayList<>();\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class,\n                () -> new UrlValidator(new String[] {}, null, 0L, DomainValidator.getInstance(true, items)));\n        assertEquals(\"DomainValidator disagrees with ALLOW_LOCAL_URLS setting\", thrown.getMessage());\n    }\n\n    @Test\n    public void testValidator473Part3() { // reject null DomainValidator with mismatched allowLocal\n        final List<DomainValidator.Item> items = new ArrayList<>();\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class,\n                () -> new UrlValidator(new String[] {}, null, UrlValidator.ALLOW_LOCAL_URLS, DomainValidator.getInstance(false, items)));\n        assertEquals(\"DomainValidator disagrees with ALLOW_LOCAL_URLS setting\", thrown.getMessage());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final boolean printStatus = false;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "printStatus = false", "syntax_pass": true}, {"attribute_expression": "private final boolean printIndex = false;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "printIndex = false", "syntax_pass": true}, {"attribute_expression": "ResultPair[] testUrlScheme = { new ResultPair(\"http://\", true), new ResultPair(\"ftp://\", true), new ResultPair(\"h3t://\", true),\n            new ResultPair(\"3ht://\", false), new ResultPair(\"http:/\", false), new ResultPair(\"http:\", false), new ResultPair(\"http/\", false),\n            new ResultPair(\"://\", false) };", "docstring": "\nThe data given below approximates the 4 parts of a URL <scheme>://<authority><path>?<query> except that the port number is broken out of authority to\nincrease the number of permutations. A complete URL is composed of a scheme+authority+port+path+query, all of which must be individually valid for the\nentire URL to be considered valid.\n", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ResultPair[]", "name": "testUrlScheme = { new ResultPair(\"http://\", true), new ResultPair(\"ftp://\", true), new ResultPair(\"h3t://\", true),\n            new ResultPair(\"3ht://\", false), new ResultPair(\"http:/\", false), new ResultPair(\"http:\", false), new ResultPair(\"http/\", false),\n            new ResultPair(\"://\", false) }", "syntax_pass": true}, {"attribute_expression": "ResultPair[] testUrlAuthority = { new ResultPair(\"www.google.com\", true), new ResultPair(\"www.google.com.\", true), new ResultPair(\"go.com\", true),\n            new ResultPair(\"go.au\", true), new ResultPair(\"0.0.0.0\", true), new ResultPair(\"255.255.255.255\", true), new ResultPair(\"256.256.256.256\", false),\n            new ResultPair(\"255.com\", true), new ResultPair(\"1.2.3.4.5\", false), new ResultPair(\"1.2.3.4.\", false), new ResultPair(\"1.2.3\", false),\n            new ResultPair(\".1.2.3.4\", false), new ResultPair(\"go.a\", false), new ResultPair(\"go.a1a\", false), new ResultPair(\"go.cc\", true),\n            new ResultPair(\"go.1aa\", false), new ResultPair(\"aaa.\", false), new ResultPair(\".aaa\", false), new ResultPair(\"aaa\", false),\n            new ResultPair(\"\", false) };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ResultPair[]", "name": "testUrlAuthority = { new ResultPair(\"www.google.com\", true), new ResultPair(\"www.google.com.\", true), new ResultPair(\"go.com\", true),\n            new ResultPair(\"go.au\", true), new ResultPair(\"0.0.0.0\", true), new ResultPair(\"255.255.255.255\", true), new ResultPair(\"256.256.256.256\", false),\n            new ResultPair(\"255.com\", true), new ResultPair(\"1.2.3.4.5\", false), new ResultPair(\"1.2.3.4.\", false), new ResultPair(\"1.2.3\", false),\n            new ResultPair(\".1.2.3.4\", false), new ResultPair(\"go.a\", false), new ResultPair(\"go.a1a\", false), new ResultPair(\"go.cc\", true),\n            new ResultPair(\"go.1aa\", false), new ResultPair(\"aaa.\", false), new ResultPair(\".aaa\", false), new ResultPair(\"aaa\", false),\n            new ResultPair(\"\", false) }", "syntax_pass": true}, {"attribute_expression": "ResultPair[] testUrlPort = { new ResultPair(\":80\", true), new ResultPair(\":65535\", true), // max possible\n            new ResultPair(\":65536\", false), // max possible +1\n            new ResultPair(\":0\", true), new ResultPair(\"\", true), new ResultPair(\":-1\", false), new ResultPair(\":65636\", false),\n            new ResultPair(\":999999999999999999\", false), new ResultPair(\":65a\", false) };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ResultPair[]", "name": "testUrlPort = { new ResultPair(\":80\", true), new ResultPair(\":65535\", true), // max possible\n            new ResultPair(\":65536\", false), // max possible +1\n            new ResultPair(\":0\", true), new ResultPair(\"\", true), new ResultPair(\":-1\", false), new ResultPair(\":65636\", false),\n            new ResultPair(\":999999999999999999\", false), new ResultPair(\":65a\", false) }", "syntax_pass": true}, {"attribute_expression": "ResultPair[] testPath = { new ResultPair(\"/test1\", true), new ResultPair(\"/t123\", true), new ResultPair(\"/$23\", true), new ResultPair(\"/..\", false),\n            new ResultPair(\"/../\", false), new ResultPair(\"/test1/\", true), new ResultPair(\"\", true), new ResultPair(\"/test1/file\", true),\n            new ResultPair(\"/..//file\", false), new ResultPair(\"/test1//file\", false) };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ResultPair[]", "name": "testPath = { new ResultPair(\"/test1\", true), new ResultPair(\"/t123\", true), new ResultPair(\"/$23\", true), new ResultPair(\"/..\", false),\n            new ResultPair(\"/../\", false), new ResultPair(\"/test1/\", true), new ResultPair(\"\", true), new ResultPair(\"/test1/file\", true),\n            new ResultPair(\"/..//file\", false), new ResultPair(\"/test1//file\", false) }", "syntax_pass": true}, {"attribute_expression": "ResultPair[] testUrlPathOptions = { new ResultPair(\"/test1\", true), new ResultPair(\"/t123\", true), new ResultPair(\"/$23\", true),\n            new ResultPair(\"/..\", false), new ResultPair(\"/../\", false), new ResultPair(\"/test1/\", true), new ResultPair(\"/#\", false), new ResultPair(\"\", true),\n            new ResultPair(\"/test1/file\", true), new ResultPair(\"/t123/file\", true), new ResultPair(\"/$23/file\", true), new ResultPair(\"/../file\", false),\n            new ResultPair(\"/..//file\", false), new ResultPair(\"/test1//file\", true), new ResultPair(\"/#/file\", false) };", "docstring": " Test allow2slash, noFragment", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ResultPair[]", "name": "testUrlPathOptions = { new ResultPair(\"/test1\", true), new ResultPair(\"/t123\", true), new ResultPair(\"/$23\", true),\n            new ResultPair(\"/..\", false), new ResultPair(\"/../\", false), new ResultPair(\"/test1/\", true), new ResultPair(\"/#\", false), new ResultPair(\"\", true),\n            new ResultPair(\"/test1/file\", true), new ResultPair(\"/t123/file\", true), new ResultPair(\"/$23/file\", true), new ResultPair(\"/../file\", false),\n            new ResultPair(\"/..//file\", false), new ResultPair(\"/test1//file\", true), new ResultPair(\"/#/file\", false) }", "syntax_pass": true}, {"attribute_expression": "ResultPair[] testUrlQuery = { new ResultPair(\"?action=view\", true), new ResultPair(\"?action=edit&mode=up\", true), new ResultPair(\"\", true) };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ResultPair[]", "name": "testUrlQuery = { new ResultPair(\"?action=view\", true), new ResultPair(\"?action=edit&mode=up\", true), new ResultPair(\"\", true) }", "syntax_pass": true}, {"attribute_expression": "Object[] testUrlParts = { testUrlScheme, testUrlAuthority, testUrlPort, testPath, testUrlQuery };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Object[]", "name": "testUrlParts = { testUrlScheme, testUrlAuthority, testUrlPort, testPath, testUrlQuery }", "syntax_pass": true}, {"attribute_expression": "Object[] testUrlPartsOptions = { testUrlScheme, testUrlAuthority, testUrlPort, testUrlPathOptions, testUrlQuery };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Object[]", "name": "testUrlPartsOptions = { testUrlScheme, testUrlAuthority, testUrlPort, testUrlPathOptions, testUrlQuery }", "syntax_pass": true}, {"attribute_expression": "int[] testPartsIndex = { 0, 0, 0, 0, 0 };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "int[]", "name": "testPartsIndex = { 0, 0, 0, 0, 0 }", "syntax_pass": true}, {"attribute_expression": "private final String[] schemes = { \"http\", \"gopher\", \"g0-To+.\", \"not_valid\" // TODO this will need to be dropped if the ctor validates schemes\n    };", "docstring": " Test data for individual url parts", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String[]", "name": "schemes = { \"http\", \"gopher\", \"g0-To+.\", \"not_valid\" // TODO this will need to be dropped if the ctor validates schemes\n    }", "syntax_pass": true}, {"attribute_expression": "ResultPair[] testScheme = { new ResultPair(\"http\", true), new ResultPair(\"ftp\", false), new ResultPair(\"httpd\", false), new ResultPair(\"gopher\", true),\n            new ResultPair(\"g0-to+.\", true), new ResultPair(\"not_valid\", false), // underscore not allowed\n            new ResultPair(\"HtTp\", true), new ResultPair(\"telnet\", false) };", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "ResultPair[]", "name": "testScheme = { new ResultPair(\"http\", true), new ResultPair(\"ftp\", false), new ResultPair(\"httpd\", false), new ResultPair(\"gopher\", true),\n            new ResultPair(\"g0-to+.\", true), new ResultPair(\"not_valid\", false), // underscore not allowed\n            new ResultPair(\"HtTp\", true), new ResultPair(\"telnet\", false) }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/DateValidatorTest.java.DateValidatorTest", "name": "DateValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/DateValidatorTest.java", "superclasses": "AbstractCalendarValidatorTest", "methods": ["[void]testCompare()", "[void]testDateValidatorMethods()", "[void]testLocaleProviders()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/DateValidatorTest.java.DateValidatorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTest Case for DateValidator.\n", "original_string": "public class DateValidatorTest extends AbstractCalendarValidatorTest {\n\n    private DateValidator dateValidator;\n\n    /**\n     * Sets up test fixtures.\n     */\n    @BeforeEach\n    protected void setUp() {\n        dateValidator = new DateValidator();\n        validator = dateValidator;\n    }\n\n    /**\n     * Test compare date methods\n     */\n    @Test\n    public void testCompare() {\n        final int sameTime = 124522;\n        final int testDate = 20050823;\n        final Date diffHour = createDate(GMT, testDate, 115922); // same date, different time\n\n        final Date value = createDate(GMT, testDate, sameTime); // test value\n        final Date date20050824 = createDate(GMT, 20050824, sameTime); // +1 day\n        final Date date20050822 = createDate(GMT, 20050822, sameTime); // -1 day\n\n        final Date date20050830 = createDate(GMT, 20050830, sameTime); // +1 week\n        final Date date20050816 = createDate(GMT, 20050816, sameTime); // -1 week\n\n        final Date date20050901 = createDate(GMT, 20050901, sameTime); // +1 month\n        final Date date20050801 = createDate(GMT, 20050801, sameTime); // same month\n        final Date date20050731 = createDate(GMT, 20050731, sameTime); // -1 month\n\n        final Date date20051101 = createDate(GMT, 20051101, sameTime); // +1 quarter (Feb Start)\n        final Date date20051001 = createDate(GMT, 20051001, sameTime); // +1 quarter\n        final Date date20050701 = createDate(GMT, 20050701, sameTime); // same quarter\n        final Date date20050630 = createDate(GMT, 20050630, sameTime); // -1 quarter\n        final Date date20050110 = createDate(GMT, 20050110, sameTime); // Previous Year qtr (Fen start)\n\n        final Date date20060101 = createDate(GMT, 20060101, sameTime); // +1 year\n        final Date date20050101 = createDate(GMT, 20050101, sameTime); // same year\n        final Date date20041231 = createDate(GMT, 20041231, sameTime); // -1 year\n\n        assertEquals(-1, dateValidator.compareDates(value, date20050824, GMT), \"date LT\"); // +1 day\n        assertEquals(0, dateValidator.compareDates(value, diffHour, GMT), \"date EQ\"); // same day, diff hour\n        assertEquals(1, dateValidator.compareDates(value, date20050822, GMT), \"date GT\"); // -1 day\n\n        assertEquals(-1, dateValidator.compareWeeks(value, date20050830, GMT), \"week LT\"); // +1 week\n        assertEquals(0, dateValidator.compareWeeks(value, date20050824, GMT), \"week =1\"); // +1 day\n        assertEquals(0, dateValidator.compareWeeks(value, date20050822, GMT), \"week =2\"); // same week\n        assertEquals(0, dateValidator.compareWeeks(value, date20050822, GMT), \"week =3\"); // -1 day\n        assertEquals(1, dateValidator.compareWeeks(value, date20050816, GMT), \"week GT\"); // -1 week\n\n        assertEquals(-1, dateValidator.compareMonths(value, date20050901, GMT), \"mnth LT\"); // +1 month\n        assertEquals(0, dateValidator.compareMonths(value, date20050830, GMT), \"mnth =1\"); // +1 week\n        assertEquals(0, dateValidator.compareMonths(value, date20050801, GMT), \"mnth =2\"); // same month\n        assertEquals(0, dateValidator.compareMonths(value, date20050816, GMT), \"mnth =3\"); // -1 week\n        assertEquals(1, dateValidator.compareMonths(value, date20050731, GMT), \"mnth GT\"); // -1 month\n\n        assertEquals(-1, dateValidator.compareQuarters(value, date20051101, GMT), \"qtrA <1\"); // +1 quarter (Feb)\n        assertEquals(-1, dateValidator.compareQuarters(value, date20051001, GMT), \"qtrA <2\"); // +1 quarter\n        assertEquals(0, dateValidator.compareQuarters(value, date20050901, GMT), \"qtrA =1\"); // +1 month\n        assertEquals(0, dateValidator.compareQuarters(value, date20050701, GMT), \"qtrA =2\"); // same quarter\n        assertEquals(0, dateValidator.compareQuarters(value, date20050731, GMT), \"qtrA =3\"); // -1 month\n        assertEquals(1, dateValidator.compareQuarters(value, date20050630, GMT), \"qtrA GT\"); // -1 quarter\n\n        // Change quarter 1 to start in Feb\n        assertEquals(-1, dateValidator.compareQuarters(value, date20051101, GMT, 2), \"qtrB LT\"); // +1 quarter (Feb)\n        assertEquals(0, dateValidator.compareQuarters(value, date20051001, GMT, 2), \"qtrB =1\"); // same quarter\n        assertEquals(0, dateValidator.compareQuarters(value, date20050901, GMT, 2), \"qtrB =2\"); // +1 month\n        assertEquals(1, dateValidator.compareQuarters(value, date20050701, GMT, 2), \"qtrB =3\"); // same quarter\n        assertEquals(1, dateValidator.compareQuarters(value, date20050731, GMT, 2), \"qtrB =4\"); // -1 month\n        assertEquals(1, dateValidator.compareQuarters(value, date20050630, GMT, 2), \"qtrB GT\"); // -1 quarter\n        assertEquals(1, dateValidator.compareQuarters(value, date20050110, GMT, 2), \"qtrB prev\"); // Jan Prev year qtr\n\n        assertEquals(-1, dateValidator.compareYears(value, date20060101, GMT), \"year LT\"); // +1 year\n        assertEquals(0, dateValidator.compareYears(value, date20050101, GMT), \"year EQ\"); // same year\n        assertEquals(1, dateValidator.compareYears(value, date20041231, GMT), \"year GT\"); // -1 year\n\n        // Compare using alternative TimeZone\n        final Date sameDayTwoAm = createDate(GMT, testDate, 20000);\n        assertEquals(-1, dateValidator.compareDates(value, date20050824, EST), \"date LT\"); // +1 day\n        assertEquals(0, dateValidator.compareDates(value, diffHour, EST), \"date EQ\"); // same day, diff hour\n        assertEquals(1, dateValidator.compareDates(value, sameDayTwoAm, EST), \"date EQ\"); // same day, diff hour\n        assertEquals(1, dateValidator.compareDates(value, date20050822, EST), \"date GT\"); // -1 day\n    }\n\n    /**\n     * Test DateValidator validate Methods\n     */\n    @Test\n    public void testDateValidatorMethods() {\n        Locale.setDefault(Locale.US);\n        final Locale locale = Locale.GERMAN;\n        final String pattern = \"yyyy-MM-dd\";\n        final String patternVal = \"2005-12-31\";\n        final String germanVal = \"31 Dez 2005\";\n        final String germanPattern = \"dd MMM yyyy\";\n        final String localeVal = \"31.12.2005\";\n        final String defaultVal = \"12/31/05\";\n        final String xxxx = \"XXXX\";\n        final Date expected = createCalendar(null, 20051231, 0).getTime();\n\n        assertEquals(expected, DateValidator.getInstance().validate(defaultVal), \"validate(A) default\");\n        assertEquals(expected, DateValidator.getInstance().validate(localeVal, locale), \"validate(A) locale \");\n        assertEquals(expected, DateValidator.getInstance().validate(patternVal, pattern), \"validate(A) pattern\");\n        assertEquals(expected, DateValidator.getInstance().validate(germanVal, germanPattern, Locale.GERMAN), \"validate(A) both\");\n\n        assertTrue(DateValidator.getInstance().isValid(defaultVal), \"isValid(A) default\");\n        assertTrue(DateValidator.getInstance().isValid(localeVal, locale), \"isValid(A) locale \");\n        assertTrue(DateValidator.getInstance().isValid(patternVal, pattern), \"isValid(A) pattern\");\n        assertTrue(DateValidator.getInstance().isValid(germanVal, germanPattern, Locale.GERMAN), \"isValid(A) both\");\n\n        assertNull(DateValidator.getInstance().validate(xxxx), \"validate(B) default\");\n        assertNull(DateValidator.getInstance().validate(xxxx, locale), \"validate(B) locale \");\n        assertNull(DateValidator.getInstance().validate(xxxx, pattern), \"validate(B) pattern\");\n        assertNull(DateValidator.getInstance().validate(\"31 Dec 2005\", germanPattern, Locale.GERMAN), \"validate(B) both\");\n\n        assertFalse(DateValidator.getInstance().isValid(xxxx), \"isValid(B) default\");\n        assertFalse(DateValidator.getInstance().isValid(xxxx, locale), \"isValid(B) locale \");\n        assertFalse(DateValidator.getInstance().isValid(xxxx, pattern), \"isValid(B) pattern\");\n        assertFalse(DateValidator.getInstance().isValid(\"31 Dec 2005\", germanPattern, Locale.GERMAN), \"isValid(B) both\");\n\n        // Test Time Zone\n        final TimeZone zone = TimeZone.getDefault().getRawOffset() == EET.getRawOffset() ? EST : EET;\n        final Date expectedZone = createCalendar(zone, 20051231, 0).getTime();\n        assertFalse(expected.getTime() == expectedZone.getTime(), \"default/zone same \" + zone);\n\n        assertEquals(expectedZone, DateValidator.getInstance().validate(defaultVal, zone), \"validate(C) default\");\n        assertEquals(expectedZone, DateValidator.getInstance().validate(localeVal, locale, zone), \"validate(C) locale \");\n        assertEquals(expectedZone, DateValidator.getInstance().validate(patternVal, pattern, zone), \"validate(C) pattern\");\n        assertEquals(expectedZone, DateValidator.getInstance().validate(germanVal, germanPattern, Locale.GERMAN, zone), \"validate(C) both\");\n    }\n\n    /**\n     * Check that locale providers are set up correctly If not, the parse will fail\n     */\n    @Test\n    public void testLocaleProviders() throws Exception {\n        final String localeProviders = SystemProperties.getJavaLocaleProviders();\n        if (localeProviders != null) { // may be null before Java 9\n            assertTrue(localeProviders.startsWith(\"COMPAT\"), \"java.locale.providers must start with COMPAT\");\n        }\n        final String txt = \"3/20/15 10:59:00 PM\"; // This relies on the locale format prior to Java 9 to parse correctly\n        final DateFormat dateformat = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, Locale.US);\n        dateformat.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n        final Date date = dateformat.parse(txt);\n        assertNotNull(date);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DateValidator dateValidator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DateValidator", "name": "dateValidator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/FloatValidatorTest.java.FloatValidatorTest", "name": "FloatValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/FloatValidatorTest.java", "superclasses": "AbstractNumberValidatorTest", "methods": ["[void]testFloatRangeMinMax()", "[void]testFloatSmallestValues()", "[void]testFloatValidatorMethods()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/FloatValidatorTest.java.FloatValidatorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTest Case for FloatValidator.\n", "original_string": "public class FloatValidatorTest extends AbstractNumberValidatorTest {\n\n    @Override\n    @BeforeEach\n    protected void setUp() {\n        super.setUp();\n\n        validator = new FloatValidator(false, 0);\n        strictValidator = new FloatValidator();\n\n        testPattern = \"#,###.#\";\n\n        // testValidateMinMax()\n        max = Float.valueOf(Float.MAX_VALUE);\n        maxPlusOne = Double.valueOf(max.doubleValue() * 10);\n        min = Float.valueOf(Float.MAX_VALUE * -1);\n        minMinusOne = Double.valueOf(min.doubleValue() * 10);\n\n        // testInvalidStrict()\n        invalidStrict = new String[] { null, \"\", \"X\", \"X12\", \"12X\", \"1X2\" };\n\n        // testInvalidNotStrict()\n        invalid = new String[] { null, \"\", \"X\", \"X12\" };\n\n        // testValid()\n        testNumber = Float.valueOf(1234.5f);\n        testZero = Float.valueOf(0);\n        validStrict = new String[] { \"0\", \"1234.5\", \"1,234.5\" };\n        validStrictCompare = new Number[] { testZero, testNumber, testNumber };\n        valid = new String[] { \"0\", \"1234.5\", \"1,234.5\", \"1,234.5\", \"1234.5X\" };\n        validCompare = new Number[] { testZero, testNumber, testNumber, testNumber, testNumber };\n\n        testStringUS = \"1,234.5\";\n        testStringDE = \"1.234,5\";\n\n        // Localized Pattern test\n        localeValue = testStringDE;\n        localePattern = \"#.###,#\";\n        testLocale = Locale.GERMANY;\n        localeExpected = testNumber;\n\n    }\n\n    /**\n     * Test Float Range/Min/Max\n     */\n    @Test\n    public void testFloatRangeMinMax() {\n        final FloatValidator validator = (FloatValidator) strictValidator;\n        final Float number9 = validator.validate(\"9\", \"#\");\n        final Float number10 = validator.validate(\"10\", \"#\");\n        final Float number11 = validator.validate(\"11\", \"#\");\n        final Float number19 = validator.validate(\"19\", \"#\");\n        final Float number20 = validator.validate(\"20\", \"#\");\n        final Float number21 = validator.validate(\"21\", \"#\");\n\n        // Test isInRange()\n        assertFalse(validator.isInRange(number9, 10, 20), \"isInRange() < min\");\n        assertTrue(validator.isInRange(number10, 10, 20), \"isInRange() = min\");\n        assertTrue(validator.isInRange(number11, 10, 20), \"isInRange() in range\");\n        assertTrue(validator.isInRange(number20, 10, 20), \"isInRange() = max\");\n        assertFalse(validator.isInRange(number21, 10, 20), \"isInRange() > max\");\n\n        // Test minValue()\n        assertFalse(validator.minValue(number9, 10), \"minValue() < min\");\n        assertTrue(validator.minValue(number10, 10), \"minValue() = min\");\n        assertTrue(validator.minValue(number11, 10), \"minValue() > min\");\n\n        // Test minValue()\n        assertTrue(validator.maxValue(number19, 20), \"maxValue() < max\");\n        assertTrue(validator.maxValue(number20, 20), \"maxValue() = max\");\n        assertFalse(validator.maxValue(number21, 20), \"maxValue() > max\");\n    }\n\n    /**\n     * Test Float validation for values too small to handle. (slightly different from max/min which are the largest +ve/-ve\n     */\n    @Test\n    public void testFloatSmallestValues() {\n        final String pattern = \"#.#################################################################\";\n        final DecimalFormat fmt = new DecimalFormat(pattern);\n\n        // Validate Smallest +ve value\n        final Float smallestPositive = Float.valueOf(Float.MIN_VALUE);\n        final String strSmallestPositive = fmt.format(smallestPositive);\n        assertEquals(smallestPositive, FloatValidator.getInstance().validate(strSmallestPositive, pattern), \"Smallest +ve\");\n\n        // Validate Smallest -ve value\n        final Float smallestNegative = Float.valueOf(Float.MIN_VALUE * -1);\n        final String strSmallestNegative = fmt.format(smallestNegative);\n        assertEquals(smallestNegative, FloatValidator.getInstance().validate(strSmallestNegative, pattern), \"Smallest -ve\");\n\n        // Validate Too Small +ve\n        final Double tooSmallPositive = Double.valueOf((double) Float.MIN_VALUE / (double) 10);\n        final String strTooSmallPositive = fmt.format(tooSmallPositive);\n        assertFalse(FloatValidator.getInstance().isValid(strTooSmallPositive, pattern), \"Too small +ve\");\n\n        // Validate Too Small -ve\n        final Double tooSmallNegative = Double.valueOf(tooSmallPositive.doubleValue() * -1);\n        final String strTooSmallNegative = fmt.format(tooSmallNegative);\n        assertFalse(FloatValidator.getInstance().isValid(strTooSmallNegative, pattern), \"Too small -ve\");\n    }\n\n    /**\n     * Test FloatValidator validate Methods\n     */\n    @Test\n    public void testFloatValidatorMethods() {\n        final Locale locale = Locale.GERMAN;\n        final String pattern = \"0,00,00\";\n        final String patternVal = \"1,23,45\";\n        final String localeVal = \"12.345\";\n        final String germanPatternVal = \"1.23.45\";\n        final String defaultVal = \"12,345\";\n        final String xxxx = \"XXXX\";\n        final Float expected = Float.valueOf(12345);\n        assertEquals(expected, FloatValidator.getInstance().validate(defaultVal), \"validate(A) default\");\n        assertEquals(expected, FloatValidator.getInstance().validate(localeVal, locale), \"validate(A) locale\");\n        assertEquals(expected, FloatValidator.getInstance().validate(patternVal, pattern), \"validate(A) pattern\");\n        assertEquals(expected, FloatValidator.getInstance().validate(germanPatternVal, pattern, Locale.GERMAN), \"validate(A) both\");\n\n        assertTrue(FloatValidator.getInstance().isValid(defaultVal), \"isValid(A) default\");\n        assertTrue(FloatValidator.getInstance().isValid(localeVal, locale), \"isValid(A) locale\");\n        assertTrue(FloatValidator.getInstance().isValid(patternVal, pattern), \"isValid(A) pattern\");\n        assertTrue(FloatValidator.getInstance().isValid(germanPatternVal, pattern, Locale.GERMAN), \"isValid(A) both\");\n\n        assertNull(FloatValidator.getInstance().validate(xxxx), \"validate(B) default\");\n        assertNull(FloatValidator.getInstance().validate(xxxx, locale), \"validate(B) locale \");\n        assertNull(FloatValidator.getInstance().validate(xxxx, pattern), \"validate(B) pattern\");\n        assertNull(FloatValidator.getInstance().validate(patternVal, pattern, Locale.GERMAN), \"validate(B) both\");\n\n        assertFalse(FloatValidator.getInstance().isValid(xxxx), \"isValid(B) default\");\n        assertFalse(FloatValidator.getInstance().isValid(xxxx, locale), \"isValid(B) locale\");\n        assertFalse(FloatValidator.getInstance().isValid(xxxx, pattern), \"isValid(B) pattern\");\n        assertFalse(FloatValidator.getInstance().isValid(patternVal, pattern, Locale.GERMAN), \"isValid(B) both\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/routines/DomainValidatorTest.java.DomainValidatorTest", "name": "DomainValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/DomainValidatorTest.java", "superclasses": "", "methods": ["[void]tesLocalTldsSortedAndLowerCase()", "[void]testAllowLocal()", "[void]testCountryCodeTldsSortedAndLowerCase()", "[void]testDomainNoDots()", "[void]testEnumIsPublic()", "[void]testGenericTldsSortedAndLowerCase()", "[void]testGetArray()", "[void]testIDN()", "[void]testIDNJava6OrLater()", "[void]testInfrastructureTldsSortedAndLowerCase()", "[void]testInvalidDomains()", "[void]testIsIDNtoASCIIBroken()", "[void]testRFC2396domainlabel()", "[void]testRFC2396toplabel()", "[void]testTopLevelDomains()", "[void]testUnicodeToASCII()", "[void]testValidator297()", "[void]testValidator306()", "[void]testValidDomains()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/DomainValidatorTest.java.DomainValidatorTest.[void]closeQuietly(Closeable)", "src/test/java/org/apache/commons/validator/routines/DomainValidatorTest.java.DomainValidatorTest.[long]download(File,String,long)", "src/test/java/org/apache/commons/validator/routines/DomainValidatorTest.java.DomainValidatorTest.[Map<String, String[]>]getHtmlInfo(File)", "src/test/java/org/apache/commons/validator/routines/DomainValidatorTest.java.DomainValidatorTest.[boolean]isInIanaList(String,Set<String>)", "src/test/java/org/apache/commons/validator/routines/DomainValidatorTest.java.DomainValidatorTest.[boolean]isInIanaList(String,String[],Set<String>)", "src/test/java/org/apache/commons/validator/routines/DomainValidatorTest.java.DomainValidatorTest.[boolean]isLowerCase(String)", "src/test/java/org/apache/commons/validator/routines/DomainValidatorTest.java.DomainValidatorTest.[boolean]isNotInRootZone(String)", "src/test/java/org/apache/commons/validator/routines/DomainValidatorTest.java.DomainValidatorTest.[boolean]isSortedLowerCase(String)", "src/test/java/org/apache/commons/validator/routines/DomainValidatorTest.java.DomainValidatorTest.[boolean]isSortedLowerCase(String,String[])", "src/test/java/org/apache/commons/validator/routines/DomainValidatorTest.java.DomainValidatorTest.[void]main(String)", "src/test/java/org/apache/commons/validator/routines/DomainValidatorTest.java.DomainValidatorTest.[void]printMap(String,Map<String, String>,String)", "src/test/java/org/apache/commons/validator/routines/DomainValidatorTest.java.DomainValidatorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTests for the DomainValidator.\n", "original_string": "public class DomainValidatorTest {\n\n    private static void closeQuietly(final Closeable in) {\n        if (in != null) {\n            try {\n                in.close();\n            } catch (final IOException ignore) {\n                // ignore\n            }\n        }\n    }\n\n    /*\n     * Download a file if it is more recent than our cached copy. Unfortunately the server does not seem to honor If-Modified-Since for the Html page, so we\n     * check if it is newer than the txt file and skip download if so\n     */\n    private static long download(final File file, final String tldUrl, final long timestamp) throws IOException {\n        final int hour = 60 * 60 * 1000; // an hour in ms\n        final long modTime;\n        // For testing purposes, don't download files more than once an hour\n        if (file.canRead()) {\n            modTime = file.lastModified();\n            if (modTime > System.currentTimeMillis() - hour) {\n                System.out.println(\"Skipping download - found recent \" + file);\n                return modTime;\n            }\n        } else {\n            modTime = 0;\n        }\n        final HttpURLConnection hc = (HttpURLConnection) new URL(tldUrl).openConnection();\n        if (modTime > 0) {\n            final SimpleDateFormat sdf = new SimpleDateFormat(\"EEE, dd MMM yyyy HH:mm:ss z\"); // Sun, 06 Nov 1994 08:49:37 GMT\n            final String since = sdf.format(new Date(modTime));\n            hc.addRequestProperty(\"If-Modified-Since\", since);\n            System.out.println(\"Found \" + file + \" with date \" + since);\n        }\n        if (hc.getResponseCode() == 304) {\n            System.out.println(\"Already have most recent \" + tldUrl);\n        } else {\n            System.out.println(\"Downloading \" + tldUrl);\n            try (InputStream is = hc.getInputStream()) {\n                Files.copy(is, file.toPath(), StandardCopyOption.REPLACE_EXISTING);\n            }\n            System.out.println(\"Done\");\n        }\n        return file.lastModified();\n    }\n\n    private static Map<String, String[]> getHtmlInfo(final File f) throws IOException {\n        final Map<String, String[]> info = new HashMap<>();\n\n//        <td><span class=\"domain tld\"><a href=\"/domains/root/db/ax.html\">.ax</a></span></td>\n        final Pattern domain = Pattern.compile(\".*<a href=\\\"/domains/root/db/([^.]+)\\\\.html\");\n//        <td>country-code</td>\n        final Pattern type = Pattern.compile(\"\\\\s+<td>([^<]+)</td>\");\n//        <!-- <td>\u00c5land Islands<br/><span class=\"tld-table-so\">\u00c5lands landskapsregering</span></td> </td> -->\n//        <td>\u00c5lands landskapsregering</td>\n        final Pattern comment = Pattern.compile(\"\\\\s+<td>([^<]+)</td>\");\n\n        try (BufferedReader br = new BufferedReader(new FileReader(f))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                final Matcher m = domain.matcher(line);\n                if (m.lookingAt()) {\n                    final String dom = m.group(1);\n                    String typ = \"??\";\n                    String com = \"??\";\n                    line = br.readLine();\n                    while (line.matches(\"^\\\\s*$\")) { // extra blank lines introduced\n                        line = br.readLine();\n                    }\n                    final Matcher t = type.matcher(line);\n                    if (t.lookingAt()) {\n                        typ = t.group(1);\n                        line = br.readLine();\n                        if (line.matches(\"\\\\s+<!--.*\")) {\n                            while (!line.matches(\".*-->.*\")) {\n                                line = br.readLine();\n                            }\n                            line = br.readLine();\n                        }\n                        // Should have comment; is it wrapped?\n                        while (!line.matches(\".*</td>.*\")) {\n                            line += \" \" + br.readLine();\n                        }\n                        final Matcher n = comment.matcher(line);\n                        if (n.lookingAt()) {\n                            com = n.group(1);\n                        }\n                        // Don't save unused entries\n                        if (com.contains(\"Not assigned\") || com.contains(\"Retired\") || typ.equals(\"test\")) {\n//                        System.out.println(\"Ignored: \" + typ + \" \" + dom + \" \" +com);\n                        } else {\n                            info.put(dom.toLowerCase(Locale.ENGLISH), new String[] { typ, com });\n//                        System.out.println(\"Storing: \" + typ + \" \" + dom + \" \" +com);\n                        }\n                    } else {\n                        System.err.println(\"Unexpected type: \" + line);\n                    }\n                }\n            }\n        }\n        return info;\n    }\n\n    // isInIanaList and isSorted are split into two methods.\n    // If/when access to the arrays is possible without reflection, the intermediate\n    // methods can be dropped\n    private static boolean isInIanaList(final String arrayName, final Set<String> ianaTlds) throws Exception {\n        final Field f = DomainValidator.class.getDeclaredField(arrayName);\n        final boolean isPrivate = Modifier.isPrivate(f.getModifiers());\n        if (isPrivate) {\n            f.setAccessible(true);\n        }\n        final String[] array = (String[]) f.get(null);\n        try {\n            return isInIanaList(arrayName, array, ianaTlds);\n        } finally {\n            if (isPrivate) {\n                f.setAccessible(false);\n            }\n        }\n    }\n\n    private static boolean isInIanaList(final String name, final String[] array, final Set<String> ianaTlds) {\n        for (final String element : array) {\n            if (!ianaTlds.contains(element)) {\n                System.out.println(name + \" contains unexpected value: \" + element);\n            }\n        }\n        return true;\n    }\n\n    private static boolean isLowerCase(final String string) {\n        return string.equals(string.toLowerCase(Locale.ENGLISH));\n    }\n\n    /**\n     * Check whether the domain is in the root zone currently. Reads the URL http://www.iana.org/domains/root/db/*domain*.html (using a local disk cache) and\n     * checks for the string \"This domain is not present in the root zone at this time.\"\n     *\n     * @param domain the domain to check\n     * @return true if the string is found\n     */\n    private static boolean isNotInRootZone(final String domain) {\n        final String tldUrl = \"http://www.iana.org/domains/root/db/\" + domain + \".html\";\n        final File rootCheck = new File(\"target\", \"tld_\" + domain + \".html\");\n        BufferedReader in = null;\n        try {\n            download(rootCheck, tldUrl, 0L);\n            in = new BufferedReader(new FileReader(rootCheck));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.contains(\"This domain is not present in the root zone at this time.\")) {\n                    return true;\n                }\n            }\n            in.close();\n        } catch (final IOException ignore) {\n            // ignore\n        } finally {\n            closeQuietly(in);\n        }\n        return false;\n    }\n\n    private static boolean isSortedLowerCase(final String arrayName) throws Exception {\n        final Field f = DomainValidator.class.getDeclaredField(arrayName);\n        final boolean isPrivate = Modifier.isPrivate(f.getModifiers());\n        if (isPrivate) {\n            f.setAccessible(true);\n        }\n        final String[] array = (String[]) f.get(null);\n        try {\n            return isSortedLowerCase(arrayName, array);\n        } finally {\n            if (isPrivate) {\n                f.setAccessible(false);\n            }\n        }\n    }\n\n    // Check if an array is strictly sorted - and lowerCase\n    private static boolean isSortedLowerCase(final String name, final String[] array) {\n        boolean sorted = true;\n        boolean strictlySorted = true;\n        final int length = array.length;\n        boolean lowerCase = isLowerCase(array[length - 1]); // Check the last entry\n        for (int i = 0; i < length - 1; i++) { // compare all but last entry with next\n            final String entry = array[i];\n            final String nextEntry = array[i + 1];\n            final int cmp = entry.compareTo(nextEntry);\n            if (cmp > 0) { // out of order\n                System.out.println(\"Out of order entry: \" + entry + \" < \" + nextEntry + \" in \" + name);\n                sorted = false;\n            } else if (cmp == 0) {\n                strictlySorted = false;\n                System.out.println(\"Duplicated entry: \" + entry + \" in \" + name);\n            }\n            if (!isLowerCase(entry)) {\n                System.out.println(\"Non lowerCase entry: \" + entry + \" in \" + name);\n                lowerCase = false;\n            }\n        }\n        return sorted && strictlySorted && lowerCase;\n    }\n\n    // Download and process local copy of https://data.iana.org/TLD/tlds-alpha-by-domain.txt\n    // Check if the internal TLD table is up to date\n    // Check if the internal TLD tables have any spurious entries\n    public static void main(final String a[]) throws Exception {\n        // Check the arrays first as this affects later checks\n        // Doing this here makes it easier when updating the lists\n        boolean ok = true;\n        for (final String list : new String[] { \"INFRASTRUCTURE_TLDS\", \"COUNTRY_CODE_TLDS\", \"GENERIC_TLDS\", \"LOCAL_TLDS\" }) {\n            ok &= isSortedLowerCase(list);\n        }\n        if (!ok) {\n            System.out.println(\"Fix arrays before retrying; cannot continue\");\n            return;\n        }\n        final Set<String> ianaTlds = new HashSet<>(); // keep for comparison with array contents\n        final DomainValidator dv = DomainValidator.getInstance();\n        final File txtFile = new File(\"target/tlds-alpha-by-domain.txt\");\n        final long timestamp = download(txtFile, \"https://data.iana.org/TLD/tlds-alpha-by-domain.txt\", 0L);\n        final File htmlFile = new File(\"target/tlds-alpha-by-domain.html\");\n        // N.B. sometimes the html file may be updated a day or so after the txt file\n        // if the txt file contains entries not found in the html file, try again in a day or two\n        download(htmlFile, \"https://www.iana.org/domains/root/db\", timestamp);\n\n        final BufferedReader br = new BufferedReader(new FileReader(txtFile));\n        String line;\n        final String header;\n        line = br.readLine(); // header\n        if (!line.startsWith(\"# Version \")) {\n            br.close();\n            throw new IOException(\"File does not have expected Version header\");\n        }\n        header = line.substring(2);\n        final boolean generateUnicodeTlds = false; // Change this to generate Unicode TLDs as well\n\n        // Parse html page to get entries\n        final Map<String, String[]> htmlInfo = getHtmlInfo(htmlFile);\n        final Map<String, String> missingTLD = new TreeMap<>(); // stores entry and comments as String[]\n        final Map<String, String> missingCC = new TreeMap<>();\n        while ((line = br.readLine()) != null) {\n            if (!line.startsWith(\"#\")) {\n                final String unicodeTld; // only different from asciiTld if that was punycode\n                final String asciiTld = line.toLowerCase(Locale.ENGLISH);\n                if (line.startsWith(\"XN--\")) {\n                    unicodeTld = IDN.toUnicode(line);\n                } else {\n                    unicodeTld = asciiTld;\n                }\n                if (!dv.isValidTld(asciiTld)) {\n                    final String[] info = htmlInfo.get(asciiTld);\n                    if (info != null) {\n                        final String type = info[0];\n                        final String comment = info[1];\n                        if (\"country-code\".equals(type)) { // Which list to use?\n                            missingCC.put(asciiTld, unicodeTld + \" \" + comment);\n                            if (generateUnicodeTlds) {\n                                missingCC.put(unicodeTld, asciiTld + \" \" + comment);\n                            }\n                        } else {\n                            missingTLD.put(asciiTld, unicodeTld + \" \" + comment);\n                            if (generateUnicodeTlds) {\n                                missingTLD.put(unicodeTld, asciiTld + \" \" + comment);\n                            }\n                        }\n                    } else {\n                        System.err.println(\"Expected to find HTML info for \" + asciiTld);\n                    }\n                }\n                ianaTlds.add(asciiTld);\n                // Don't merge these conditions; generateUnicodeTlds is final so needs to be separate to avoid a warning\n                if (generateUnicodeTlds && !unicodeTld.equals(asciiTld)) {\n                    ianaTlds.add(unicodeTld);\n                }\n            }\n        }\n        br.close();\n        // List html entries not in TLD text list\n        for (final String key : new TreeMap<>(htmlInfo).keySet()) {\n            if (!ianaTlds.contains(key)) {\n                if (isNotInRootZone(key)) {\n                    System.out.println(\"INFO: HTML entry not yet in root zone: \" + key);\n                } else {\n                    System.err.println(\"WARN: Expected to find text entry for html: \" + key);\n                }\n            }\n        }\n        if (!missingTLD.isEmpty()) {\n            printMap(header, missingTLD, \"GENERIC_TLDS\");\n        }\n        if (!missingCC.isEmpty()) {\n            printMap(header, missingCC, \"COUNTRY_CODE_TLDS\");\n        }\n        // Check if internal tables contain any additional entries\n        isInIanaList(\"INFRASTRUCTURE_TLDS\", ianaTlds);\n        isInIanaList(\"COUNTRY_CODE_TLDS\", ianaTlds);\n        isInIanaList(\"GENERIC_TLDS\", ianaTlds);\n        // Don't check local TLDS isInIanaList(\"LOCAL_TLDS\", ianaTlds);\n        System.out.println(\"Finished checks\");\n    }\n\n    private static void printMap(final String header, final Map<String, String> map, final String string) {\n        System.out.println(\"Entries missing from \" + string + \" List\\n\");\n        if (header != null) {\n            System.out.println(\"        // Taken from \" + header);\n        }\n        for (final Entry<String, String> me : map.entrySet()) {\n            System.out.println(\"        \\\"\" + me.getKey() + \"\\\", // \" + me.getValue());\n        }\n        System.out.println(\"\\nDone\");\n    }\n\n    private DomainValidator validator;\n\n    @BeforeEach\n    public void setUp() {\n        validator = DomainValidator.getInstance();\n    }\n\n    // Check array is sorted and is lower-case\n    @Test\n    public void tesLocalTldsSortedAndLowerCase() throws Exception {\n        final boolean sorted = isSortedLowerCase(\"LOCAL_TLDS\");\n        assertTrue(sorted);\n    }\n\n    @Test\n    public void testAllowLocal() {\n        final DomainValidator noLocal = DomainValidator.getInstance(false);\n        final DomainValidator allowLocal = DomainValidator.getInstance(true);\n\n        // Default is false, and should use singletons\n        assertEquals(noLocal, validator);\n\n        // Default won't allow local\n        assertFalse(noLocal.isValid(\"localhost.localdomain\"), \"localhost.localdomain should validate\");\n        assertFalse(noLocal.isValid(\"localhost\"), \"localhost should validate\");\n\n        // But it may be requested\n        assertTrue(allowLocal.isValid(\"localhost.localdomain\"), \"localhost.localdomain should validate\");\n        assertTrue(allowLocal.isValid(\"localhost\"), \"localhost should validate\");\n        assertTrue(allowLocal.isValid(\"hostname\"), \"hostname should validate\");\n        assertTrue(allowLocal.isValid(\"machinename\"), \"machinename should validate\");\n\n        // Check the localhost one with a few others\n        assertTrue(allowLocal.isValid(\"apache.org\"), \"apache.org should validate\");\n        assertFalse(allowLocal.isValid(\" apache.org \"), \"domain name with spaces shouldn't validate\");\n    }\n\n    // Check array is sorted and is lower-case\n    @Test\n    public void testCountryCodeTldsSortedAndLowerCase() throws Exception {\n        final boolean sorted = isSortedLowerCase(\"COUNTRY_CODE_TLDS\");\n        assertTrue(sorted);\n    }\n\n    @Test\n    public void testDomainNoDots() { // rfc1123\n        assertTrue(validator.isValidDomainSyntax(\"a\"), \"a (alpha) should validate\");\n        assertTrue(validator.isValidDomainSyntax(\"9\"), \"9 (alphanum) should validate\");\n        assertTrue(validator.isValidDomainSyntax(\"c-z\"), \"c-z (alpha - alpha) should validate\");\n\n        assertFalse(validator.isValidDomainSyntax(\"c-\"), \"c- (alpha -) should fail\");\n        assertFalse(validator.isValidDomainSyntax(\"-c\"), \"-c (- alpha) should fail\");\n        assertFalse(validator.isValidDomainSyntax(\"-\"), \"- (-) should fail\");\n    }\n\n    @Test\n    public void testEnumIsPublic() {\n        assertTrue(Modifier.isPublic(DomainValidator.ArrayType.class.getModifiers()));\n    }\n\n    // Check array is sorted and is lower-case\n    @Test\n    public void testGenericTldsSortedAndLowerCase() throws Exception {\n        final boolean sorted = isSortedLowerCase(\"GENERIC_TLDS\");\n        assertTrue(sorted);\n    }\n\n    @Test\n    public void testGetArray() {\n        assertNotNull(DomainValidator.getTLDEntries(ArrayType.COUNTRY_CODE_MINUS));\n        assertNotNull(DomainValidator.getTLDEntries(ArrayType.COUNTRY_CODE_PLUS));\n        assertNotNull(DomainValidator.getTLDEntries(ArrayType.GENERIC_MINUS));\n        assertNotNull(DomainValidator.getTLDEntries(ArrayType.GENERIC_PLUS));\n        assertNotNull(DomainValidator.getTLDEntries(ArrayType.LOCAL_MINUS));\n        assertNotNull(DomainValidator.getTLDEntries(ArrayType.LOCAL_PLUS));\n        assertNotNull(DomainValidator.getTLDEntries(ArrayType.COUNTRY_CODE_RO));\n        assertNotNull(DomainValidator.getTLDEntries(ArrayType.GENERIC_RO));\n        assertNotNull(DomainValidator.getTLDEntries(ArrayType.INFRASTRUCTURE_RO));\n        assertNotNull(DomainValidator.getTLDEntries(ArrayType.LOCAL_RO));\n    }\n\n    @Test\n    public void testIDN() {\n        assertTrue(validator.isValid(\"www.xn--bcher-kva.ch\"), \"b\\u00fccher.ch in IDN should validate\");\n    }\n\n    @Test\n    public void testIDNJava6OrLater() {\n        final String version = SystemProperties.getJavaVersion();\n        if (version.compareTo(\"1.6\") < 0) {\n            System.out.println(\"Cannot run Unicode IDN tests\");\n            return; // Cannot run the test\n        } // xn--d1abbgf6aiiy.xn--p1ai http://\u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442.\u0440\u0444\n        assertTrue(validator.isValid(\"www.b\\u00fccher.ch\"), \"b\\u00fccher.ch should validate\");\n        assertTrue(validator.isValid(\"xn--d1abbgf6aiiy.xn--p1ai\"), \"xn--d1abbgf6aiiy.xn--p1ai should validate\");\n        assertTrue(validator.isValid(\"\u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442.\u0440\u0444\"), \"\u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442.\u0440\u0444 should validate\");\n        assertFalse(validator.isValid(\"www.\\uFFFD.ch\"), \"www.\\uFFFD.ch FFFD should fail\");\n    }\n\n    // Check array is sorted and is lower-case\n    @Test\n    public void testInfrastructureTldsSortedAndLowerCase() throws Exception {\n        final boolean sorted = isSortedLowerCase(\"INFRASTRUCTURE_TLDS\");\n        assertTrue(sorted);\n    }\n\n    @Test\n    public void testInvalidDomains() {\n        assertFalse(validator.isValid(\".org\"), \"bare TLD .org shouldn't validate\");\n        assertFalse(validator.isValid(\" apache.org \"), \"domain name with spaces shouldn't validate\");\n        assertFalse(validator.isValid(\"apa che.org\"), \"domain name containing spaces shouldn't validate\");\n        assertFalse(validator.isValid(\"-testdomain.name\"), \"domain name starting with dash shouldn't validate\");\n        assertFalse(validator.isValid(\"testdomain-.name\"), \"domain name ending with dash shouldn't validate\");\n        assertFalse(validator.isValid(\"---c.com\"), \"domain name starting with multiple dashes shouldn't validate\");\n        assertFalse(validator.isValid(\"c--.com\"), \"domain name ending with multiple dashes shouldn't validate\");\n        assertFalse(validator.isValid(\"apache.rog\"), \"domain name with invalid TLD shouldn't validate\");\n\n        assertFalse(validator.isValid(\"http://www.apache.org\"), \"URL shouldn't validate\");\n        assertFalse(validator.isValid(\" \"), \"Empty string shouldn't validate as domain name\");\n        assertFalse(validator.isValid(null), \"Null shouldn't validate as domain name\");\n    }\n\n    // Check if IDN.toASCII is broken or not\n    @Test\n    public void testIsIDNtoASCIIBroken() {\n        System.out.println(\">>DomainValidatorTest.testIsIDNtoASCIIBroken()\");\n        final String input = \".\";\n        final boolean ok = input.equals(IDN.toASCII(input));\n        System.out.println(\"IDN.toASCII is \" + (ok ? \"OK\" : \"BROKEN\"));\n        final String[] props = { \"java.version\", // Java Runtime Environment version\n                \"java.vendor\", // Java Runtime Environment vendor\n                \"java.vm.specification.version\", // Java Virtual Machine specification version\n                \"java.vm.specification.vendor\", // Java Virtual Machine specification vendor\n                \"java.vm.specification.name\", // Java Virtual Machine specification name\n                \"java.vm.version\", // Java Virtual Machine implementation version\n                \"java.vm.vendor\", // Java Virtual Machine implementation vendor\n                \"java.vm.name\", // Java Virtual Machine implementation name\n                \"java.specification.version\", // Java Runtime Environment specification version\n                \"java.specification.vendor\", // Java Runtime Environment specification vendor\n                \"java.specification.name\", // Java Runtime Environment specification name\n                \"java.class.version\", // Java class format version number\n        };\n        for (final String t : props) {\n            System.out.println(t + \"=\" + System.getProperty(t));\n        }\n        System.out.println(\"<<DomainValidatorTest.testIsIDNtoASCIIBroken()\");\n        assertTrue(true); // dummy assertion to satisfy lint\n    }\n\n    // RFC2396: domainlabel = alphanum | alphanum *( alphanum | \"-\" ) alphanum\n    @Test\n    public void testRFC2396domainlabel() { // use fixed valid TLD\n        assertTrue(validator.isValid(\"a.ch\"), \"a.ch should validate\");\n        assertTrue(validator.isValid(\"9.ch\"), \"9.ch should validate\");\n        assertTrue(validator.isValid(\"az.ch\"), \"az.ch should validate\");\n        assertTrue(validator.isValid(\"09.ch\"), \"09.ch should validate\");\n        assertTrue(validator.isValid(\"9-1.ch\"), \"9-1.ch should validate\");\n        assertFalse(validator.isValid(\"91-.ch\"), \"91-.ch should not validate\");\n        assertFalse(validator.isValid(\"-.ch\"), \"-.ch should not validate\");\n    }\n\n    // RFC2396 toplabel = alpha | alpha *( alphanum | \"-\" ) alphanum\n    @Test\n    public void testRFC2396toplabel() {\n        // These tests use non-existent TLDs so currently need to use a package protected method\n        assertTrue(validator.isValidDomainSyntax(\"a.c\"), \"a.c (alpha) should validate\");\n        assertTrue(validator.isValidDomainSyntax(\"a.cc\"), \"a.cc (alpha alpha) should validate\");\n        assertTrue(validator.isValidDomainSyntax(\"a.c9\"), \"a.c9 (alpha alphanum) should validate\");\n        assertTrue(validator.isValidDomainSyntax(\"a.c-9\"), \"a.c-9 (alpha - alphanum) should validate\");\n        assertTrue(validator.isValidDomainSyntax(\"a.c-z\"), \"a.c-z (alpha - alpha) should validate\");\n\n        assertFalse(validator.isValidDomainSyntax(\"a.9c\"), \"a.9c (alphanum alpha) should fail\");\n        assertFalse(validator.isValidDomainSyntax(\"a.c-\"), \"a.c- (alpha -) should fail\");\n        assertFalse(validator.isValidDomainSyntax(\"a.-\"), \"a.- (-) should fail\");\n        assertFalse(validator.isValidDomainSyntax(\"a.-9\"), \"a.-9 (- alphanum) should fail\");\n    }\n\n    @Test\n    public void testTopLevelDomains() {\n        // infrastructure TLDs\n        assertTrue(validator.isValidInfrastructureTld(\".arpa\"), \".arpa should validate as iTLD\");\n        assertFalse(validator.isValidInfrastructureTld(\".com\"), \".com shouldn't validate as iTLD\");\n\n        // generic TLDs\n        assertTrue(validator.isValidGenericTld(\".name\"), \".name should validate as gTLD\");\n        assertFalse(validator.isValidGenericTld(\".us\"), \".us shouldn't validate as gTLD\");\n\n        // country code TLDs\n        assertTrue(validator.isValidCountryCodeTld(\".uk\"), \".uk should validate as ccTLD\");\n        assertFalse(validator.isValidCountryCodeTld(\".org\"), \".org shouldn't validate as ccTLD\");\n\n        // case-insensitive\n        assertTrue(validator.isValidTld(\".COM\"), \".COM should validate as TLD\");\n        assertTrue(validator.isValidTld(\".BiZ\"), \".BiZ should validate as TLD\");\n\n        // corner cases\n        assertFalse(validator.isValid(\".nope\"), \"invalid TLD shouldn't validate\"); // TODO this is not guaranteed invalid forever\n        assertFalse(validator.isValid(\"\"), \"empty string shouldn't validate as TLD\");\n        assertFalse(validator.isValid(null), \"null shouldn't validate as TLD\");\n    }\n\n    // Check that IDN.toASCII behaves as it should (when wrapped by DomainValidator.unicodeToASCII)\n    // Tests show that method incorrectly trims a trailing \".\" character\n    @Test\n    public void testUnicodeToASCII() {\n        final String[] asciidots = { \"\", \",\", \".\", // fails IDN.toASCII, but should pass wrapped version\n                \"a.\", // ditto\n                \"a.b\", \"a..b\", \"a...b\", \".a\", \"..a\", };\n        for (final String s : asciidots) {\n            assertEquals(s, DomainValidator.unicodeToASCII(s));\n        }\n        // RFC3490 3.1. 1)\n//      Whenever dots are used as label separators, the following\n//      characters MUST be recognized as dots: U+002E (full stop), U+3002\n//      (ideographic full stop), U+FF0E (fullwidth full stop), U+FF61\n//      (halfwidth ideographic full stop).\n        final String otherDots[][] = { { \"b\\u3002\", \"b.\", }, { \"b\\uFF0E\", \"b.\", }, { \"b\\uFF61\", \"b.\", }, { \"\\u3002\", \".\", }, { \"\\uFF0E\", \".\", },\n                { \"\\uFF61\", \".\", }, };\n        for (final String s[] : otherDots) {\n            assertEquals(s[1], DomainValidator.unicodeToASCII(s[0]));\n        }\n    }\n\n    @Test\n    public void testValidator297() {\n        assertTrue(validator.isValid(\"xn--d1abbgf6aiiy.xn--p1ai\"), \"xn--d1abbgf6aiiy.xn--p1ai should validate\"); // This uses a valid TLD\n    }\n\n    // labels are a max of 63 chars and domains 253\n    @Test\n    public void testValidator306() {\n        final String longString = \"abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz0123456789A\";\n        assertEquals(63, longString.length()); // 26 * 2 + 11\n\n        assertTrue(validator.isValidDomainSyntax(longString + \".com\"), \"63 chars label should validate\");\n        assertFalse(validator.isValidDomainSyntax(longString + \"x.com\"), \"64 chars label should fail\");\n\n        assertTrue(validator.isValidDomainSyntax(\"test.\" + longString), \"63 chars TLD should validate\");\n        assertFalse(validator.isValidDomainSyntax(\"test.x\" + longString), \"64 chars TLD should fail\");\n\n        final String longDomain = longString + \".\" + longString + \".\" + longString + \".\" + longString.substring(0, 61);\n        assertEquals(253, longDomain.length());\n        assertTrue(validator.isValidDomainSyntax(longDomain), \"253 chars domain should validate\");\n        assertFalse(validator.isValidDomainSyntax(longDomain + \"x\"), \"254 chars domain should fail\");\n    }\n\n    @Test\n    public void testValidDomains() {\n        assertTrue(validator.isValid(\"apache.org\"), \"apache.org should validate\");\n        assertTrue(validator.isValid(\"www.google.com\"), \"www.google.com should validate\");\n\n        assertTrue(validator.isValid(\"test-domain.com\"), \"test-domain.com should validate\");\n        assertTrue(validator.isValid(\"test---domain.com\"), \"test---domain.com should validate\");\n        assertTrue(validator.isValid(\"test-d-o-m-ain.com\"), \"test-d-o-m-ain.com should validate\");\n        assertTrue(validator.isValid(\"as.uk\"), \"two-letter domain label should validate\");\n\n        assertTrue(validator.isValid(\"ApAchE.Org\"), \"case-insensitive ApAchE.Org should validate\");\n\n        assertTrue(validator.isValid(\"z.com\"), \"single-character domain label should validate\");\n\n        assertTrue(validator.isValid(\"i.have.an-example.domain.name\"), \"i.have.an-example.domain.name should validate\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DomainValidator validator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DomainValidator", "name": "validator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/ByteValidatorTest.java.ByteValidatorTest", "name": "ByteValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/ByteValidatorTest.java", "superclasses": "AbstractNumberValidatorTest", "methods": ["[void]testByteRangeMinMax()", "[void]testByteValidatorMethods()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/ByteValidatorTest.java.ByteValidatorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTest Case for ByteValidator.\n", "original_string": "public class ByteValidatorTest extends AbstractNumberValidatorTest {\n\n    private static final Byte BYTE_MIN_VAL = Byte.valueOf(Byte.MIN_VALUE);\n    private static final Byte BYTE_MAX_VAL = Byte.valueOf(Byte.MAX_VALUE);\n    private static final String BYTE_MAX = \"127\";\n    private static final String BYTE_MAX_0 = \"127.99999999999999999999999\"; // force double rounding\n    private static final String BYTE_MAX_1 = \"128\";\n    private static final String BYTE_MIN = \"-128\";\n    private static final String BYTE_MIN_0 = \"-128.99999999999999999999999\"; // force double rounding\";\n    private static final String BYTE_MIN_1 = \"-129\";\n\n    @Override\n    @BeforeEach\n    protected void setUp() {\n        super.setUp();\n\n        validator = new ByteValidator(false, 0);\n        strictValidator = new ByteValidator();\n\n        testPattern = \"#,###\";\n\n        // testValidateMinMax()\n        max = Byte.valueOf(Byte.MAX_VALUE);\n        maxPlusOne = Long.valueOf(max.longValue() + 1);\n        min = Byte.valueOf(Byte.MIN_VALUE);\n        minMinusOne = Long.valueOf(min.longValue() - 1);\n\n        // testInvalidStrict()\n        invalidStrict = new String[] { null, \"\", \"X\", \"X12\", \"12X\", \"1X2\", \"1.2\", BYTE_MAX_1, BYTE_MIN_1, BYTE_MAX_0, BYTE_MIN_0 };\n\n        // testInvalidNotStrict()\n        invalid = new String[] { null, \"\", \"X\", \"X12\", BYTE_MAX_1, BYTE_MIN_1 };\n\n        // testValid()\n        testNumber = Byte.valueOf((byte) 123);\n        testZero = Byte.valueOf((byte) 0);\n        validStrict = new String[] { \"0\", \"123\", \",123\", BYTE_MAX, BYTE_MIN };\n        validStrictCompare = new Number[] { testZero, testNumber, testNumber, BYTE_MAX_VAL, BYTE_MIN_VAL };\n        valid = new String[] { \"0\", \"123\", \",123\", \",123.5\", \"123X\", BYTE_MAX, BYTE_MIN, BYTE_MAX_0, BYTE_MIN_0 };\n        validCompare = new Number[] { testZero, testNumber, testNumber, testNumber, testNumber, BYTE_MAX_VAL, BYTE_MIN_VAL, BYTE_MAX_VAL, BYTE_MIN_VAL };\n\n        testStringUS = \",123\";\n        testStringDE = \".123\";\n\n        // Localized Pattern test\n        localeValue = testStringDE;\n        localePattern = \"#.###\";\n        testLocale = Locale.GERMANY;\n        localeExpected = testNumber;\n\n    }\n\n    /**\n     * Test Byte Range/Min/Max\n     */\n    @Test\n    public void testByteRangeMinMax() {\n        final ByteValidator validator = (ByteValidator) strictValidator;\n        final Byte number9 = validator.validate(\"9\", \"#\");\n        final Byte number10 = validator.validate(\"10\", \"#\");\n        final Byte number11 = validator.validate(\"11\", \"#\");\n        final Byte number19 = validator.validate(\"19\", \"#\");\n        final Byte number20 = validator.validate(\"20\", \"#\");\n        final Byte number21 = validator.validate(\"21\", \"#\");\n        final byte min = (byte) 10;\n        final byte max = (byte) 20;\n\n        // Test isInRange()\n        assertFalse(validator.isInRange(number9, min, max), \"isInRange() < min\");\n        assertTrue(validator.isInRange(number10, min, max), \"isInRange() = min\");\n        assertTrue(validator.isInRange(number11, min, max), \"isInRange() in range\");\n        assertTrue(validator.isInRange(number20, min, max), \"isInRange() = max\");\n        assertFalse(validator.isInRange(number21, min, max), \"isInRange() > max\");\n\n        // Test minValue()\n        assertFalse(validator.minValue(number9, min), \"minValue() < min\");\n        assertTrue(validator.minValue(number10, min), \"minValue() = min\");\n        assertTrue(validator.minValue(number11, min), \"minValue() > min\");\n\n        // Test minValue()\n        assertTrue(validator.maxValue(number19, max), \"maxValue() < max\");\n        assertTrue(validator.maxValue(number20, max), \"maxValue() = max\");\n        assertFalse(validator.maxValue(number21, max), \"maxValue() > max\");\n    }\n\n    /**\n     * Test ByteValidator validate Methods\n     */\n    @Test\n    public void testByteValidatorMethods() {\n        final Locale locale = Locale.GERMAN;\n        final String pattern = \"0,00\";\n        final String patternVal = \"1,23\";\n        final String germanPatternVal = \"1.23\";\n        final String localeVal = \".123\";\n        final String defaultVal = \",123\";\n        final String xxxx = \"XXXX\";\n        final Byte expected = Byte.valueOf((byte) 123);\n        assertEquals(expected, ByteValidator.getInstance().validate(defaultVal), \"validate(A) default\");\n        assertEquals(expected, ByteValidator.getInstance().validate(localeVal, locale), \"validate(A) locale \");\n        assertEquals(expected, ByteValidator.getInstance().validate(patternVal, pattern), \"validate(A) pattern\");\n        assertEquals(expected, ByteValidator.getInstance().validate(germanPatternVal, pattern, Locale.GERMAN), \"validate(A) both\");\n\n        assertTrue(ByteValidator.getInstance().isValid(defaultVal), \"isValid(A) default\");\n        assertTrue(ByteValidator.getInstance().isValid(localeVal, locale), \"isValid(A) locale \");\n        assertTrue(ByteValidator.getInstance().isValid(patternVal, pattern), \"isValid(A) pattern\");\n        assertTrue(ByteValidator.getInstance().isValid(germanPatternVal, pattern, Locale.GERMAN), \"isValid(A) both\");\n\n        assertNull(ByteValidator.getInstance().validate(xxxx), \"validate(B) default\");\n        assertNull(ByteValidator.getInstance().validate(xxxx, locale), \"validate(B) locale \");\n        assertNull(ByteValidator.getInstance().validate(xxxx, pattern), \"validate(B) pattern\");\n        assertNull(ByteValidator.getInstance().validate(patternVal, pattern, Locale.GERMAN), \"validate(B) both\");\n\n        assertFalse(ByteValidator.getInstance().isValid(xxxx), \"isValid(B) default\");\n        assertFalse(ByteValidator.getInstance().isValid(xxxx, locale), \"isValid(B) locale \");\n        assertFalse(ByteValidator.getInstance().isValid(xxxx, pattern), \"isValid(B) pattern\");\n        assertFalse(ByteValidator.getInstance().isValid(patternVal, pattern, Locale.GERMAN), \"isValid(B) both\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Byte BYTE_MIN_VAL = Byte.valueOf(Byte.MIN_VALUE);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Byte", "name": "BYTE_MIN_VAL = Byte.valueOf(Byte.MIN_VALUE)", "syntax_pass": true}, {"attribute_expression": "private static final Byte BYTE_MAX_VAL = Byte.valueOf(Byte.MAX_VALUE);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Byte", "name": "BYTE_MAX_VAL = Byte.valueOf(Byte.MAX_VALUE)", "syntax_pass": true}, {"attribute_expression": "private static final String BYTE_MAX = \"127\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "BYTE_MAX = \"127\"", "syntax_pass": true}, {"attribute_expression": "private static final String BYTE_MAX_0 = \"127.99999999999999999999999\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "BYTE_MAX_0 = \"127.99999999999999999999999\"", "syntax_pass": true}, {"attribute_expression": "private static final String BYTE_MAX_1 = \"128\";", "docstring": " force double rounding", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "BYTE_MAX_1 = \"128\"", "syntax_pass": true}, {"attribute_expression": "private static final String BYTE_MIN = \"-128\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "BYTE_MIN = \"-128\"", "syntax_pass": true}, {"attribute_expression": "private static final String BYTE_MIN_0 = \"-128.99999999999999999999999\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "BYTE_MIN_0 = \"-128.99999999999999999999999\"", "syntax_pass": true}, {"attribute_expression": "private static final String BYTE_MIN_1 = \"-129\";", "docstring": " force double rounding\";", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "BYTE_MIN_1 = \"-129\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/CalendarValidatorTest.java.CalendarValidatorTest", "name": "CalendarValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/CalendarValidatorTest.java", "superclasses": "AbstractCalendarValidatorTest", "methods": ["[void]testAdjustToTimeZone()", "[void]testCalendarValidatorMethods()", "[void]testCompare()", "[void]testDateTimeStyle()", "[void]testFormat()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/CalendarValidatorTest.java.CalendarValidatorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTest Case for CalendarValidator.\n", "original_string": "public class CalendarValidatorTest extends AbstractCalendarValidatorTest {\n\n    private static final int DATE_2005_11_23 = 20051123;\n    private static final int TIME_12_03_45 = 120345;\n\n    private CalendarValidator calValidator;\n\n    @BeforeEach\n    protected void setUp() {\n        calValidator = new CalendarValidator();\n        validator = calValidator;\n    }\n\n    /**\n     * Test adjustToTimeZone() method\n     */\n    @Test\n    public void testAdjustToTimeZone() {\n\n        final Calendar calEST = createCalendar(EST, DATE_2005_11_23, TIME_12_03_45);\n        final Date dateEST = calEST.getTime();\n\n        final Calendar calGMT = createCalendar(GMT, DATE_2005_11_23, TIME_12_03_45);\n        final Date dateGMT = calGMT.getTime();\n\n        final Calendar calCET = createCalendar(EET, DATE_2005_11_23, TIME_12_03_45);\n        final Date dateCET = calCET.getTime();\n\n        // Check the dates don't match\n        assertFalse(dateGMT.getTime() == dateCET.getTime(), \"Check GMT != CET\");\n        assertFalse(dateGMT.getTime() == dateEST.getTime(), \"Check GMT != EST\");\n        assertFalse(dateCET.getTime() == dateEST.getTime(), \"Check CET != EST\");\n\n        // EST to GMT and back\n        CalendarValidator.adjustToTimeZone(calEST, GMT);\n        assertEquals(dateGMT, calEST.getTime(), \"EST to GMT\");\n        assertFalse(dateEST == calEST.getTime(), \"Check EST = GMT\");\n        CalendarValidator.adjustToTimeZone(calEST, EST);\n        assertEquals(dateEST, calEST.getTime(), \"back to EST\");\n        assertFalse(dateGMT == calEST.getTime(), \"Check EST != GMT\");\n\n        // CET to GMT and back\n        CalendarValidator.adjustToTimeZone(calCET, GMT);\n        assertEquals(dateGMT, calCET.getTime(), \"CET to GMT\");\n        assertFalse(dateCET == calCET.getTime(), \"Check CET = GMT\");\n        CalendarValidator.adjustToTimeZone(calCET, EET);\n        assertEquals(dateCET, calCET.getTime(), \"back to CET\");\n        assertFalse(dateGMT == calCET.getTime(), \"Check CET != GMT\");\n\n        // Adjust to TimeZone with Same rules\n        final Calendar calUTC = createCalendar(UTC, DATE_2005_11_23, TIME_12_03_45);\n        assertTrue(UTC.hasSameRules(GMT), \"SAME: UTC = GMT\");\n        assertEquals(calUTC.getTime(), calGMT.getTime(), \"SAME: Check time (A)\");\n        assertFalse(GMT.equals(calUTC.getTimeZone()), \"SAME: Check GMT(A)\");\n        assertTrue(UTC.equals(calUTC.getTimeZone()), \"SAME: Check UTC(A)\");\n        CalendarValidator.adjustToTimeZone(calUTC, GMT);\n        assertEquals(calUTC.getTime(), calGMT.getTime(), \"SAME: Check time (B)\");\n        assertTrue(GMT.equals(calUTC.getTimeZone()), \"SAME: Check GMT(B)\");\n        assertFalse(UTC.equals(calUTC.getTimeZone()), \"SAME: Check UTC(B)\");\n    }\n\n    /**\n     * Test CalendarValidator validate Methods\n     */\n    @Test\n    public void testCalendarValidatorMethods() {\n        Locale.setDefault(Locale.US);\n        final Locale locale = Locale.GERMAN;\n        final String pattern = \"yyyy-MM-dd\";\n        final String patternVal = \"2005-12-31\";\n        final String germanVal = \"31 Dez 2005\";\n        final String germanPattern = \"dd MMM yyyy\";\n        final String localeVal = \"31.12.2005\";\n        final String defaultVal = \"12/31/05\";\n        final String xxxx = \"XXXX\";\n        final Date expected = createCalendar(null, 20051231, 0).getTime();\n        assertEquals(expected, CalendarValidator.getInstance().validate(defaultVal).getTime(), \"validate(A) default\");\n        assertEquals(expected, CalendarValidator.getInstance().validate(localeVal, locale).getTime(), \"validate(A) locale \");\n        assertEquals(expected, CalendarValidator.getInstance().validate(patternVal, pattern).getTime(), \"validate(A) pattern\");\n        assertEquals(expected, CalendarValidator.getInstance().validate(germanVal, germanPattern, Locale.GERMAN).getTime(), \"validate(A) both\");\n\n        assertTrue(CalendarValidator.getInstance().isValid(defaultVal), \"isValid(A) default\");\n        assertTrue(CalendarValidator.getInstance().isValid(localeVal, locale), \"isValid(A) locale \");\n        assertTrue(CalendarValidator.getInstance().isValid(patternVal, pattern), \"isValid(A) pattern\");\n        assertTrue(CalendarValidator.getInstance().isValid(germanVal, germanPattern, Locale.GERMAN), \"isValid(A) both\");\n\n        assertNull(CalendarValidator.getInstance().validate(xxxx), \"validate(B) default\");\n        assertNull(CalendarValidator.getInstance().validate(xxxx, locale), \"validate(B) locale \");\n        assertNull(CalendarValidator.getInstance().validate(xxxx, pattern), \"validate(B) pattern\");\n        assertNull(CalendarValidator.getInstance().validate(\"31 Dec 2005\", germanPattern, Locale.GERMAN), \"validate(B) both\");\n\n        assertFalse(CalendarValidator.getInstance().isValid(xxxx), \"isValid(B) default\");\n        assertFalse(CalendarValidator.getInstance().isValid(xxxx, locale), \"isValid(B) locale \");\n        assertFalse(CalendarValidator.getInstance().isValid(xxxx, pattern), \"isValid(B) pattern\");\n        assertFalse(CalendarValidator.getInstance().isValid(\"31 Dec 2005\", germanPattern, Locale.GERMAN), \"isValid(B) both\");\n\n        // Test Time Zone\n        final TimeZone zone = TimeZone.getDefault().getRawOffset() == EET.getRawOffset() ? EST : EET;\n        final Date expectedZone = createCalendar(zone, 20051231, 0).getTime();\n        assertFalse(expected.getTime() == expectedZone.getTime(), \"default/EET same \");\n\n        assertEquals(expectedZone, CalendarValidator.getInstance().validate(defaultVal, zone).getTime(), \"validate(C) default\");\n        assertEquals(expectedZone, CalendarValidator.getInstance().validate(localeVal, locale, zone).getTime(), \"validate(C) locale \");\n        assertEquals(expectedZone, CalendarValidator.getInstance().validate(patternVal, pattern, zone).getTime(), \"validate(C) pattern\");\n        assertEquals(expectedZone, CalendarValidator.getInstance().validate(germanVal, germanPattern, Locale.GERMAN, zone).getTime(), \"validate(C) both\");\n    }\n\n    /**\n     * Test compare date methods\n     */\n    @Test\n    public void testCompare() {\n        final int sameTime = 124522;\n        final int testDate = 20050823;\n        final Calendar diffHour = createCalendar(GMT, testDate, 115922); // same date, different time\n        final Calendar diffMin = createCalendar(GMT, testDate, 124422); // same date, different time\n        final Calendar diffSec = createCalendar(GMT, testDate, 124521); // same date, different time\n\n        final Calendar value = createCalendar(GMT, testDate, sameTime); // test value\n        final Calendar cal20050824 = createCalendar(GMT, 20050824, sameTime); // +1 day\n        final Calendar cal20050822 = createCalendar(GMT, 20050822, sameTime); // -1 day\n\n        final Calendar cal20050830 = createCalendar(GMT, 20050830, sameTime); // +1 week\n        final Calendar cal20050816 = createCalendar(GMT, 20050816, sameTime); // -1 week\n\n        final Calendar cal20050901 = createCalendar(GMT, 20050901, sameTime); // +1 month\n        final Calendar cal20050801 = createCalendar(GMT, 20050801, sameTime); // same month\n        final Calendar cal20050731 = createCalendar(GMT, 20050731, sameTime); // -1 month\n\n        final Calendar cal20051101 = createCalendar(GMT, 20051101, sameTime); // +1 quarter (Feb Start)\n        final Calendar cal20051001 = createCalendar(GMT, 20051001, sameTime); // +1 quarter\n        final Calendar cal20050701 = createCalendar(GMT, 20050701, sameTime); // same quarter\n        final Calendar cal20050630 = createCalendar(GMT, 20050630, sameTime); // -1 quarter\n\n        final Calendar cal20060101 = createCalendar(GMT, 20060101, sameTime); // +1 year\n        final Calendar cal20050101 = createCalendar(GMT, 20050101, sameTime); // same year\n        final Calendar cal20041231 = createCalendar(GMT, 20041231, sameTime); // -1 year\n\n        assertEquals(1, calValidator.compare(value, diffHour, Calendar.HOUR_OF_DAY), \"hour GT\");\n        assertEquals(0, calValidator.compare(value, diffMin, Calendar.HOUR_OF_DAY), \"hour EQ\");\n        assertEquals(1, calValidator.compare(value, diffMin, Calendar.MINUTE), \"mins GT\");\n        assertEquals(0, calValidator.compare(value, diffSec, Calendar.MINUTE), \"mins EQ\");\n        assertEquals(1, calValidator.compare(value, diffSec, Calendar.SECOND), \"secs GT\");\n\n        assertEquals(-1, calValidator.compareDates(value, cal20050824), \"date LT\"); // +1 day\n        assertEquals(0, calValidator.compareDates(value, diffHour), \"date EQ\"); // same day, diff hour\n        assertEquals(0, calValidator.compare(value, diffHour, Calendar.DAY_OF_YEAR), \"date(B)\"); // same day, diff hour\n        assertEquals(1, calValidator.compareDates(value, cal20050822), \"date GT\"); // -1 day\n\n        assertEquals(-1, calValidator.compareWeeks(value, cal20050830), \"week LT\"); // +1 week\n        assertEquals(0, calValidator.compareWeeks(value, cal20050824), \"week =1\"); // +1 day\n        assertEquals(0, calValidator.compareWeeks(value, cal20050822), \"week =2\"); // same week\n        assertEquals(0, calValidator.compare(value, cal20050822, Calendar.WEEK_OF_MONTH), \"week =3\"); // same week\n        assertEquals(0, calValidator.compareWeeks(value, cal20050822), \"week =4\"); // -1 day\n        assertEquals(1, calValidator.compareWeeks(value, cal20050816), \"week GT\"); // -1 week\n\n        assertEquals(-1, calValidator.compareMonths(value, cal20050901), \"mnth LT\"); // +1 month\n        assertEquals(0, calValidator.compareMonths(value, cal20050830), \"mnth =1\"); // +1 week\n        assertEquals(0, calValidator.compareMonths(value, cal20050801), \"mnth =2\"); // same month\n        assertEquals(0, calValidator.compareMonths(value, cal20050816), \"mnth =3\"); // -1 week\n        assertEquals(1, calValidator.compareMonths(value, cal20050731), \"mnth GT\"); // -1 month\n\n        assertEquals(-1, calValidator.compareQuarters(value, cal20051101), \"qtrA <1\"); // +1 quarter (Feb)\n        assertEquals(-1, calValidator.compareQuarters(value, cal20051001), \"qtrA <2\"); // +1 quarter\n        assertEquals(0, calValidator.compareQuarters(value, cal20050901), \"qtrA =1\"); // +1 month\n        assertEquals(0, calValidator.compareQuarters(value, cal20050701), \"qtrA =2\"); // same quarter\n        assertEquals(0, calValidator.compareQuarters(value, cal20050731), \"qtrA =3\"); // -1 month\n        assertEquals(1, calValidator.compareQuarters(value, cal20050630), \"qtrA GT\"); // -1 quarter\n\n        // Change quarter 1 to start in Feb\n        assertEquals(-1, calValidator.compareQuarters(value, cal20051101, 2), \"qtrB LT\"); // +1 quarter (Feb)\n        assertEquals(0, calValidator.compareQuarters(value, cal20051001, 2), \"qtrB =1\"); // same quarter\n        assertEquals(0, calValidator.compareQuarters(value, cal20050901, 2), \"qtrB =2\"); // +1 month\n        assertEquals(1, calValidator.compareQuarters(value, cal20050701, 2), \"qtrB =3\"); // same quarter\n        assertEquals(1, calValidator.compareQuarters(value, cal20050731, 2), \"qtrB =4\"); // -1 month\n        assertEquals(1, calValidator.compareQuarters(value, cal20050630, 2), \"qtrB GT\"); // -1 quarter\n\n        assertEquals(-1, calValidator.compareYears(value, cal20060101), \"year LT\"); // +1 year\n        assertEquals(0, calValidator.compareYears(value, cal20050101), \"year EQ\"); // same year\n        assertEquals(1, calValidator.compareYears(value, cal20041231), \"year GT\"); // -1 year\n\n        // invalid compare\n        try {\n            calValidator.compare(value, value, -1);\n            fail(\"Invalid Compare field - expected IllegalArgumentException to be thrown\");\n        } catch (final IllegalArgumentException e) {\n            assertEquals(e.getMessage(), \"Invalid field: -1\", \"check message\");\n        }\n    }\n\n    /**\n     * Test Date/Time style Validator (there isn't an implementation for this)\n     */\n    @Test\n    public void testDateTimeStyle() {\n        // Set the default Locale\n        final Locale origDefault = Locale.getDefault();\n        Locale.setDefault(Locale.UK);\n\n        final AbstractCalendarValidator dateTimeValidator = new AbstractCalendarValidator(true, DateFormat.SHORT, DateFormat.SHORT) {\n            private static final long serialVersionUID = 1L;\n\n            @Override\n            protected Object processParsedValue(final Object value, final Format formatter) {\n                return value;\n            }\n        };\n        assertTrue(dateTimeValidator.isValid(\"31/12/05 14:23\"), \"validate(A) default\");\n        assertTrue(dateTimeValidator.isValid(\"12/31/05 2:23 PM\", Locale.US), \"validate(A) locale \");\n\n        // Restore the original default\n        Locale.setDefault(origDefault);\n    }\n\n    /**\n     * Test format methods\n     */\n    @Override\n    @Test\n    public void testFormat() {\n        // Set the default Locale\n        final Locale origDefault = Locale.getDefault();\n        Locale.setDefault(Locale.UK);\n\n        final Calendar cal20050101 = createCalendar(GMT, 20051231, 11500);\n        assertNull(calValidator.format(null), \"null\");\n        assertEquals(\"31/12/05\", calValidator.format(cal20050101), \"default\");\n        assertEquals(\"12/31/05\", calValidator.format(cal20050101, Locale.US), \"locale\");\n        assertEquals(calValidator.format(cal20050101, \"yyyy-MM-dd HH:mm\"), \"2005-12-31 01:15\", \"patternA\");\n        assertEquals(calValidator.format(cal20050101, \"yyyy-MM-dd z\"), \"2005-12-31 GMT\", \"patternB\");\n        assertEquals(\"31 Dez 2005\", calValidator.format(cal20050101, \"dd MMM yyyy\", Locale.GERMAN), \"both\");\n\n        // EST Time Zone\n        assertEquals(\"30/12/05\", calValidator.format(cal20050101, EST), \"EST default\");\n        assertEquals(\"12/30/05\", calValidator.format(cal20050101, Locale.US, EST), \"EST locale\");\n        assertEquals(calValidator.format(cal20050101, \"yyyy-MM-dd HH:mm\", EST), \"2005-12-30 20:15\", \"EST patternA\");\n        assertEquals(calValidator.format(cal20050101, \"yyyy-MM-dd z\", EST), \"2005-12-30 EST\", \"EST patternB\");\n        assertEquals(\"30 Dez 2005\", calValidator.format(cal20050101, \"dd MMM yyyy\", Locale.GERMAN, EST), \"EST both\");\n\n        // Restore the original default\n        Locale.setDefault(origDefault);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final int DATE_2005_11_23 = 20051123;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "DATE_2005_11_23 = 20051123", "syntax_pass": true}, {"attribute_expression": "private static final int TIME_12_03_45 = 120345;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "TIME_12_03_45 = 120345", "syntax_pass": true}, {"attribute_expression": "private CalendarValidator calValidator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CalendarValidator", "name": "calValidator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/ISSNValidator_convertToEAN13Test.java.ISSNValidator_convertToEAN13Test", "name": "ISSNValidator_convertToEAN13Test", "file_path": "src/test/java/org/apache/commons/validator/routines/ISSNValidator_convertToEAN13Test.java", "superclasses": "", "methods": ["[void]testConvertToEAN13Valid()", "[void]testConvertToEAN13InvalidSuffix()", "[void]testConvertToEAN13InvalidISSN()", "[void]testConvertToEAN13CheckDigitException()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/ISSNValidator_convertToEAN13Test.java.ISSNValidator_convertToEAN13Test.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ISSNValidator_convertToEAN13Test {\n\n    private ISSNValidator validator;\n\n    @BeforeEach\n    public void setUp() {\n        validator = new ISSNValidator();\n    }\n\n    @Test\n    public void testConvertToEAN13Valid() {\n        String issn = \"1234-5679\";\n        String suffix = \"00\";\n        String expectedEAN13 = \"9771234567003\";\n\n        String result = validator.convertToEAN13(issn, suffix);\n        assertEquals(expectedEAN13, result);\n    }\n\n    @Test\n    public void testConvertToEAN13InvalidSuffix() {\n        String issn = \"1234-5679\";\n        String suffix = \"0\";\n\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            validator.convertToEAN13(issn, suffix);\n        });\n        assertEquals(\"Suffix must be two digits: '0'\", exception.getMessage());\n    }\n\n    @Test\n    public void testConvertToEAN13InvalidISSN() {\n        String issn = \"1234-5678\";\n        String suffix = \"00\";\n\n        String result = validator.convertToEAN13(issn, suffix);\n        assertNull(result);\n    }\n\n    @Test\n    public void testConvertToEAN13CheckDigitException() {\n        String issn = \"1234-5679\";\n        String suffix = \"00\";\n\n        // Mocking a CheckDigitException by providing an invalid EAN13 prefix\n        String invalidEAN13 = \"9781234567003\"; // Invalid prefix '978' instead of '977'\n\n        // The actual method does not throw an IllegalArgumentException for invalid prefixes.\n        // Instead, it should return null or handle the error differently.\n        // Therefore, this test case should be adjusted to reflect the actual behavior.\n        String result = validator.convertToEAN13(issn, suffix);\n        assertEquals(\"9771234567003\", result);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ISSNValidator validator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ISSNValidator", "name": "validator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/DomainValidator_isValidTldTest.java.DomainValidator_isValidTldTest", "name": "DomainValidator_isValidTldTest", "file_path": "src/test/java/org/apache/commons/validator/routines/DomainValidator_isValidTldTest.java", "superclasses": "", "methods": ["[void]testIsValidTld_LocalTld_Valid()", "[void]testIsValidTld_LocalTld_Invalid()", "[void]testIsValidTld_GenericTld_Valid()", "[void]testIsValidTld_GenericTld_Invalid()", "[void]testIsValidTld_CountryCodeTld_Valid()", "[void]testIsValidTld_CountryCodeTld_Invalid()", "[void]testIsValidTld_InfrastructureTld_Valid()", "[void]testIsValidTld_InfrastructureTld_Invalid()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/DomainValidator_isValidTldTest.java.DomainValidator_isValidTldTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DomainValidator_isValidTldTest {\n\n    private DomainValidator validator;\n\n    @BeforeEach\n    public void setUp() {\n        validator = DomainValidator.getInstance(true);\n    }\n\n    @Test\n    public void testIsValidTld_LocalTld_Valid() {\n        assertTrue(validator.isValidTld(\"localhost\"));\n    }\n\n    @Test\n    public void testIsValidTld_LocalTld_Invalid() {\n        assertFalse(validator.isValidTld(\"invalidlocal\"));\n    }\n\n    @Test\n    public void testIsValidTld_GenericTld_Valid() {\n        assertTrue(validator.isValidTld(\"com\"));\n    }\n\n    @Test\n    public void testIsValidTld_GenericTld_Invalid() {\n        assertFalse(validator.isValidTld(\"invalidgeneric\"));\n    }\n\n    @Test\n    public void testIsValidTld_CountryCodeTld_Valid() {\n        assertTrue(validator.isValidTld(\"us\"));\n    }\n\n    @Test\n    public void testIsValidTld_CountryCodeTld_Invalid() {\n        assertFalse(validator.isValidTld(\"invalidcountry\"));\n    }\n\n    @Test\n    public void testIsValidTld_InfrastructureTld_Valid() {\n        assertTrue(validator.isValidTld(\"arpa\"));\n    }\n\n    @Test\n    public void testIsValidTld_InfrastructureTld_Invalid() {\n        assertFalse(validator.isValidTld(\"invalidinfrastructure\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DomainValidator validator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DomainValidator", "name": "validator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/IBANValidator_getValidatorTest.java.IBANValidator_getValidatorTest", "name": "IBANValidator_getValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/IBANValidator_getValidatorTest.java", "superclasses": "", "methods": ["[void]testGetValidator_ValidCode()", "[void]testGetValidator_NullCode()", "[void]testGetValidator_ShortCode()", "[void]testGetValidator_InvalidCode()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/IBANValidator_getValidatorTest.java.IBANValidator_getValidatorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IBANValidator_getValidatorTest {\n\n    private IBANValidator validator;\n\n    @BeforeEach\n    public void setUp() {\n        validator = new IBANValidator();\n    }\n\n    @Test\n    public void testGetValidator_ValidCode() {\n        String validCode = \"DE89370400440532013000\";\n        IBANValidator.Validator result = validator.getValidator(validCode);\n        assertNotNull(result);\n        assertEquals(\"DE\", result.countryCode);\n    }\n\n    @Test\n    public void testGetValidator_NullCode() {\n        IBANValidator.Validator result = validator.getValidator(null);\n        assertNull(result);\n    }\n\n    @Test\n    public void testGetValidator_ShortCode() {\n        String shortCode = \"D\";\n        IBANValidator.Validator result = validator.getValidator(shortCode);\n        assertNull(result);\n    }\n\n    @Test\n    public void testGetValidator_InvalidCode() {\n        String invalidCode = \"ZZ89370400440532013000\";\n        IBANValidator.Validator result = validator.getValidator(invalidCode);\n        assertNull(result);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private IBANValidator validator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IBANValidator", "name": "validator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/RegexValidatorTest.java.RegexValidatorTest", "name": "RegexValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/RegexValidatorTest.java", "superclasses": "", "methods": ["[void]testExceptions()", "[void]testGetPatterns()", "[void]testMissingRegex()", "[void]testMultipleInsensitive()", "[void]testMultipleSensitive()", "[void]testNullValue()", "[void]testSingle()", "[void]testToString()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/RegexValidatorTest.java.RegexValidatorTest.[void]checkArray(String,String[],String[])"], "overrides": null, "attributes": [], "class_docstring": "\nTest Case for RegexValidatorTest.\n", "original_string": "public class RegexValidatorTest {\n\n    private static final String REGEX = \"^([abc]*)(?:\\\\-)([DEF]*)(?:\\\\-)([123]*)$\";\n\n    private static final String COMPONENT_1 = \"([abc]{3})\";\n    private static final String COMPONENT_2 = \"([DEF]{3})\";\n    private static final String COMPONENT_3 = \"([123]{3})\";\n    private static final String SEPARATOR_1 = \"(?:\\\\-)\";\n    private static final String SEPARATOR_2 = \"(?:\\\\s)\";\n    private static final String REGEX_1 = \"^\" + COMPONENT_1 + SEPARATOR_1 + COMPONENT_2 + SEPARATOR_1 + COMPONENT_3 + \"$\";\n    private static final String REGEX_2 = \"^\" + COMPONENT_1 + SEPARATOR_2 + COMPONENT_2 + SEPARATOR_2 + COMPONENT_3 + \"$\";\n    private static final String REGEX_3 = \"^\" + COMPONENT_1 + COMPONENT_2 + COMPONENT_3 + \"$\";\n    private static final String[] MULTIPLE_REGEX = { REGEX_1, REGEX_2, REGEX_3 };\n\n    /**\n     * Compare two arrays\n     *\n     * @param label  Label for the test\n     * @param expect Expected array\n     * @param result Actual array\n     */\n    private void checkArray(final String label, final String[] expect, final String[] result) {\n\n        // Handle nulls\n        if (expect == null || result == null) {\n            if (expect == null && result == null) {\n                return; // valid, both null\n            }\n            fail(label + \" Null expect=\" + expect + \" result=\" + result);\n            return; // not strictly necessary, but prevents possible NPE below\n        }\n\n        // Check Length\n        if (expect.length != result.length) {\n            fail(label + \" Length expect=\" + expect.length + \" result=\" + result.length);\n        }\n\n        // Check Values\n        for (int i = 0; i < expect.length; i++) {\n            assertEquals(expect[i], result[i], label + \" value[\" + i + \"]\");\n        }\n    }\n\n    /**\n     * Test exceptions\n     */\n    @Test\n    public void testExceptions() {\n        final String invalidRegex = \"^([abCD12]*$\";\n        try {\n            new RegexValidator(invalidRegex);\n        } catch (final PatternSyntaxException e) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testGetPatterns() {\n        final RegexValidator regexValidator = new RegexValidator(MULTIPLE_REGEX);\n        assertNotSame(regexValidator.getPatterns(), regexValidator.getPatterns());\n        final Pattern[] patterns = regexValidator.getPatterns();\n        assertEquals(REGEX_1, patterns[0].pattern());\n        assertEquals(REGEX_2, patterns[1].pattern());\n        assertEquals(REGEX_3, patterns[2].pattern());\n    }\n\n    /**\n     * Test exceptions\n     */\n    @Test\n    public void testMissingRegex() {\n\n        // Single Regular Expression - null\n        try {\n            new RegexValidator((String) null);\n            fail(\"Single Null - expected IllegalArgumentException\");\n        } catch (final IllegalArgumentException e) {\n            assertEquals(\"Regular expression[0] is missing\", e.getMessage(), \"Single Null\");\n        }\n\n        // Single Regular Expression - Zero Length\n        try {\n            new RegexValidator(\"\");\n            fail(\"Single Zero Length - expected IllegalArgumentException\");\n        } catch (final IllegalArgumentException e) {\n            assertEquals(\"Regular expression[0] is missing\", e.getMessage(), \"Single Zero Length\");\n        }\n\n        // Multiple Regular Expression - Null array\n        try {\n            new RegexValidator((String[]) null);\n            fail(\"Null Array - expected IllegalArgumentException\");\n        } catch (final IllegalArgumentException e) {\n            assertEquals(\"Regular expressions are missing\", e.getMessage(), \"Null Array\");\n        }\n\n        // Multiple Regular Expression - Zero Length array\n        try {\n            new RegexValidator();\n            fail(\"Zero Length Array - expected IllegalArgumentException\");\n        } catch (final IllegalArgumentException e) {\n            assertEquals(\"Regular expressions are missing\", e.getMessage(), \"Zero Length Array\");\n        }\n\n        // Multiple Regular Expression - Array has Null\n        String[] expressions = { \"ABC\", null };\n        try {\n            new RegexValidator(expressions);\n            fail(\"Array has Null - expected IllegalArgumentException\");\n        } catch (final IllegalArgumentException e) {\n            assertEquals(\"Regular expression[1] is missing\", e.getMessage(), \"Array has Null\");\n        }\n\n        // Multiple Regular Expression - Array has Zero Length\n        expressions = new String[] { \"\", \"ABC\" };\n        try {\n            new RegexValidator(expressions);\n            fail(\"Array has Zero Length - expected IllegalArgumentException\");\n        } catch (final IllegalArgumentException e) {\n            assertEquals(\"Regular expression[0] is missing\", e.getMessage(), \"Array has Zero Length\");\n        }\n    }\n\n    /**\n     * Test with multiple regular expressions (case in-sensitive).\n     */\n    @Test\n    public void testMultipleInsensitive() {\n\n        // Set up In-sensitive Validators\n        final RegexValidator multiple = new RegexValidator(MULTIPLE_REGEX, false);\n        final RegexValidator single1 = new RegexValidator(REGEX_1, false);\n        final RegexValidator single2 = new RegexValidator(REGEX_2, false);\n        final RegexValidator single3 = new RegexValidator(REGEX_3, false);\n\n        // Set up test values\n        String value = \"AAC FDE 321\";\n        final String expect = \"AACFDE321\";\n        final String[] array = { \"AAC\", \"FDE\", \"321\" };\n\n        // isValid()\n        assertTrue(multiple.isValid(value), \"isValid() Multiple\");\n        assertFalse(single1.isValid(value), \"isValid() 1st\");\n        assertTrue(single2.isValid(value), \"isValid() 2nd\");\n        assertFalse(single3.isValid(value), \"isValid() 3rd\");\n\n        // validate()\n        assertEquals(expect, multiple.validate(value), \"validate() Multiple\");\n        assertNull(single1.validate(value), \"validate() 1st\");\n        assertEquals(expect, single2.validate(value), \"validate() 2nd\");\n        assertNull(single3.validate(value), \"validate() 3rd\");\n\n        // match()\n        checkArray(\"match() Multiple\", array, multiple.match(value));\n        checkArray(\"match() 1st\", null, single1.match(value));\n        checkArray(\"match() 2nd\", array, single2.match(value));\n        checkArray(\"match() 3rd\", null, single3.match(value));\n\n        // All invalid\n        value = \"AAC*FDE*321\";\n        assertFalse(multiple.isValid(value), \"isValid() Invalid\");\n        assertNull(multiple.validate(value), \"validate() Invalid\");\n        assertNull(multiple.match(value), \"match() Multiple\");\n    }\n\n    /**\n     * Test with multiple regular expressions (case sensitive).\n     */\n    @Test\n    public void testMultipleSensitive() {\n\n        // Set up Sensitive Validators\n        final RegexValidator multiple = new RegexValidator(MULTIPLE_REGEX);\n        final RegexValidator single1 = new RegexValidator(REGEX_1);\n        final RegexValidator single2 = new RegexValidator(REGEX_2);\n        final RegexValidator single3 = new RegexValidator(REGEX_3);\n\n        // Set up test values\n        String value = \"aac FDE 321\";\n        final String expect = \"aacFDE321\";\n        final String[] array = { \"aac\", \"FDE\", \"321\" };\n\n        // isValid()\n        assertTrue( multiple.isValid(value), \"Sensitive isValid() Multiple\");\n        assertFalse(single1.isValid(value), \"Sensitive isValid() 1st\");\n        assertTrue( single2.isValid(value), \"Sensitive isValid() 2nd\");\n        assertFalse(single3.isValid(value), \"Sensitive isValid() 3rd\");\n\n        // validate()\n        assertEquals(expect, multiple.validate(value), \"Sensitive validate() Multiple\");\n        assertNull(single1.validate(value), \"Sensitive validate() 1st\");\n        assertEquals(expect, single2.validate(value), \"Sensitive validate() 2nd\");\n        assertNull(single3.validate(value), \"Sensitive validate() 3rd\");\n\n        // match()\n        checkArray(\"Sensitive match() Multiple\", array, multiple.match(value));\n        checkArray(\"Sensitive match() 1st\", null, single1.match(value));\n        checkArray(\"Sensitive match() 2nd\", array, single2.match(value));\n        checkArray(\"Sensitive match() 3rd\", null, single3.match(value));\n\n        // All invalid\n        value = \"AAC*FDE*321\";\n        assertFalse(multiple.isValid(value), \"isValid() Invalid\");\n        assertNull(multiple.validate(value), \"validate() Invalid\");\n        assertNull(multiple.match(value), \"match() Multiple\");\n    }\n\n    /**\n     * Test Null value\n     */\n    @Test\n    public void testNullValue() {\n\n        final RegexValidator validator = new RegexValidator(REGEX);\n        assertFalse(validator.isValid(null), \"Instance isValid()\");\n        assertNull(validator.validate(null), \"Instance validate()\");\n        assertNull(validator.match(null), \"Instance match()\");\n    }\n\n    /**\n     * Test instance methods with single regular expression.\n     */\n    @Test\n    public void testSingle() {\n        final RegexValidator sensitive = new RegexValidator(REGEX);\n        final RegexValidator insensitive = new RegexValidator(REGEX, false);\n\n        // isValid()\n        assertTrue( sensitive.isValid(\"ac-DE-1\"), \"Sensitive isValid() valid\");\n        assertFalse(sensitive.isValid(\"AB-de-1\"), \"Sensitive isValid() invalid\");\n        assertTrue( insensitive.isValid(\"AB-de-1\"), \"Insensitive isValid() valid\");\n        assertFalse(insensitive.isValid(\"ABd-de-1\"), \"Insensitive isValid() invalid\");\n\n        // validate()\n        assertEquals(sensitive.validate(\"ac-DE-1\"), \"acDE1\", \"Sensitive validate() valid\");\n        assertNull(sensitive.validate(\"AB-de-1\"), \"Sensitive validate() invalid\");\n        assertEquals(insensitive.validate(\"AB-de-1\"), \"ABde1\", \"Insensitive validate() valid\");\n        assertNull(insensitive.validate(\"ABd-de-1\"), \"Insensitive validate() invalid\");\n\n        // match()\n        checkArray(\"Sensitive match() valid\", new String[] { \"ac\", \"DE\", \"1\" }, sensitive.match(\"ac-DE-1\"));\n        checkArray(\"Sensitive match() invalid\", null, sensitive.match(\"AB-de-1\"));\n        checkArray(\"Insensitive match() valid\", new String[] { \"AB\", \"de\", \"1\" }, insensitive.match(\"AB-de-1\"));\n        checkArray(\"Insensitive match() invalid\", null, insensitive.match(\"ABd-de-1\"));\n        assertEquals(new RegexValidator(\"^([A-Z]*)$\").validate(\"ABC\"), \"ABC\", \"validate one\");\n        checkArray(\"match one\", new String[] { \"ABC\" }, new RegexValidator(\"^([A-Z]*)$\").match(\"ABC\"));\n    }\n\n    /**\n     * Test toString() method\n     */\n    @Test\n    public void testToString() {\n        final RegexValidator single = new RegexValidator(REGEX);\n        assertEquals(single.toString(), \"RegexValidator{\" + REGEX + \"}\", \"Single\");\n\n        final RegexValidator multiple = new RegexValidator(REGEX, REGEX);\n        assertEquals(multiple.toString(), \"RegexValidator{\" + REGEX + \",\" + REGEX + \"}\", \"Multiple\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String REGEX = \"^([abc]*)(?:\\\\-)([DEF]*)(?:\\\\-)([123]*)$\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "REGEX = \"^([abc]*)(?:\\\\-)([DEF]*)(?:\\\\-)([123]*)$\"", "syntax_pass": true}, {"attribute_expression": "private static final String COMPONENT_1 = \"([abc]{3})\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "COMPONENT_1 = \"([abc]{3})\"", "syntax_pass": true}, {"attribute_expression": "private static final String COMPONENT_2 = \"([DEF]{3})\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "COMPONENT_2 = \"([DEF]{3})\"", "syntax_pass": true}, {"attribute_expression": "private static final String COMPONENT_3 = \"([123]{3})\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "COMPONENT_3 = \"([123]{3})\"", "syntax_pass": true}, {"attribute_expression": "private static final String SEPARATOR_1 = \"(?:\\\\-)\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "SEPARATOR_1 = \"(?:\\\\-)\"", "syntax_pass": true}, {"attribute_expression": "private static final String SEPARATOR_2 = \"(?:\\\\s)\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "SEPARATOR_2 = \"(?:\\\\s)\"", "syntax_pass": true}, {"attribute_expression": "private static final String REGEX_1 = \"^\" + COMPONENT_1 + SEPARATOR_1 + COMPONENT_2 + SEPARATOR_1 + COMPONENT_3 + \"$\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "REGEX_1 = \"^\" + COMPONENT_1 + SEPARATOR_1 + COMPONENT_2 + SEPARATOR_1 + COMPONENT_3 + \"$\"", "syntax_pass": true}, {"attribute_expression": "private static final String REGEX_2 = \"^\" + COMPONENT_1 + SEPARATOR_2 + COMPONENT_2 + SEPARATOR_2 + COMPONENT_3 + \"$\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "REGEX_2 = \"^\" + COMPONENT_1 + SEPARATOR_2 + COMPONENT_2 + SEPARATOR_2 + COMPONENT_3 + \"$\"", "syntax_pass": true}, {"attribute_expression": "private static final String REGEX_3 = \"^\" + COMPONENT_1 + COMPONENT_2 + COMPONENT_3 + \"$\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "REGEX_3 = \"^\" + COMPONENT_1 + COMPONENT_2 + COMPONENT_3 + \"$\"", "syntax_pass": true}, {"attribute_expression": "private static final String[] MULTIPLE_REGEX = { REGEX_1, REGEX_2, REGEX_3 };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "MULTIPLE_REGEX = { REGEX_1, REGEX_2, REGEX_3 }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/InetAddressValidator_isValidInet6AddressTest.java.InetAddressValidator_isValidInet6AddressTest", "name": "InetAddressValidator_isValidInet6AddressTest", "file_path": "src/test/java/org/apache/commons/validator/routines/InetAddressValidator_isValidInet6AddressTest.java", "superclasses": "", "methods": ["[void]testValidInet6Address()", "[void]testInvalidInet6Address()", "[void]testValidInet6AddressWithIPv4()", "[void]testInvalidInet6AddressWithIPv4()", "[void]testInvalidInet6AddressWithMultiplePrefixes()", "[void]testInvalidInet6AddressWithInvalidZoneId()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/InetAddressValidator_isValidInet6AddressTest.java.InetAddressValidator_isValidInet6AddressTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class InetAddressValidator_isValidInet6AddressTest {\n    private InetAddressValidator validator;\n\n    @BeforeEach\n    protected void setUp() {\n        validator = new InetAddressValidator();\n    }\n\n    @Test\n    public void testValidInet6Address() {\n        final String[] valid = {\n            \"2001:0000:1234:0000:0000:C1C0:ABCD:0876\",\n            \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/123\",\n            \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/0\",\n            \"2001:0000:1234:0000:0000:C1C0:ABCD:0876%0\",\n            \"2001:0000:1234:0000:0000:C1C0:ABCD:0876%abcdefgh\"\n        };\n        for (final String item : valid) {\n            assertTrue(validator.isValidInet6Address(item), () -> String.format(\"%s should be valid\", item));\n        }\n    }\n\n    @Test\n    public void testInvalidInet6Address() {\n        final String[] invalid = {\n            \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/129\", // too big\n            \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/-0\", // sign not allowed\n            \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/+0\", // sign not allowed\n            \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/10O\", // non-digit\n            \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/0%0\", // /bits before %node-id\n            \"2001:0000:1234:0000:0000:C1C0:ABCD:0876%abc defgh\", // space in node id\n            \"2001:0000:1234:0000:0000:C1C0:ABCD:0876%abc%defgh\" // '%' in node id\n        };\n        for (final String item : invalid) {\n            assertFalse(validator.isValidInet6Address(item), () -> String.format(\"%s should be invalid\", item));\n        }\n    }\n\n    @Test\n    public void testValidInet6AddressWithIPv4() {\n        final String valid = \"2001:0000:1234:0000:0000:C1C0:192.168.0.1\";\n        assertTrue(validator.isValidInet6Address(valid), () -> String.format(\"%s should be valid\", valid));\n    }\n\n    @Test\n    public void testInvalidInet6AddressWithIPv4() {\n        final String invalid = \"2001:0000:1234:0000:0000:C1C0:256.256.256.256\";\n        assertFalse(validator.isValidInet6Address(invalid), () -> String.format(\"%s should be invalid\", invalid));\n    }\n\n    @Test\n    public void testInvalidInet6AddressWithMultiplePrefixes() {\n        final String invalid = \"2001:0000:1234:0000:0000:C1C0:ABCD:0876/64/64\";\n        assertFalse(validator.isValidInet6Address(invalid), () -> String.format(\"%s should be invalid\", invalid));\n    }\n\n    @Test\n    public void testInvalidInet6AddressWithInvalidZoneId() {\n        final String invalid = \"2001:0000:1234:0000:0000:C1C0:ABCD:0876%abc/defgh\";\n        assertFalse(validator.isValidInet6Address(invalid), () -> String.format(\"%s should be invalid\", invalid));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private InetAddressValidator validator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "InetAddressValidator", "name": "validator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/DoubleValidatorTest.java.DoubleValidatorTest", "name": "DoubleValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/DoubleValidatorTest.java", "superclasses": "AbstractNumberValidatorTest", "methods": ["[void]testDoubleRangeMinMax()", "[void]testDoubleValidatorMethods()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/DoubleValidatorTest.java.DoubleValidatorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTest Case for DoubleValidator.\n", "original_string": "public class DoubleValidatorTest extends AbstractNumberValidatorTest {\n\n    @Override\n    @BeforeEach\n    protected void setUp() {\n        super.setUp();\n\n        validator = new DoubleValidator(false, 0);\n        strictValidator = new DoubleValidator();\n\n        testPattern = \"#,###.#\";\n\n        // testValidateMinMax()\n        max = null;\n        maxPlusOne = null;\n        min = null;\n        minMinusOne = null;\n\n        // testInvalidStrict()\n        invalidStrict = new String[] { null, \"\", \"X\", \"X12\", \"12X\", \"1X2\" };\n\n        // testInvalidNotStrict()\n        invalid = new String[] { null, \"\", \"X\", \"X12\" };\n\n        // testValid()\n        testNumber = Double.valueOf(1234.5);\n        testZero = Double.valueOf(0);\n        validStrict = new String[] { \"0\", \"1234.5\", \"1,234.5\" };\n        validStrictCompare = new Number[] { testZero, testNumber, testNumber };\n        valid = new String[] { \"0\", \"1234.5\", \"1,234.5\", \"1,234.5\", \"1234.5X\" };\n        validCompare = new Number[] { testZero, testNumber, testNumber, testNumber, testNumber };\n\n        testStringUS = \"1,234.5\";\n        testStringDE = \"1.234,5\";\n\n        // Localized Pattern test\n        localeValue = testStringDE;\n        localePattern = \"#.###,#\";\n        testLocale = Locale.GERMANY;\n        localeExpected = testNumber;\n\n    }\n\n    /**\n     * Test Double Range/Min/Max\n     */\n    @Test\n    public void testDoubleRangeMinMax() {\n        final DoubleValidator validator = (DoubleValidator) strictValidator;\n        final Double number9 = validator.validate(\"9\", \"#\");\n        final Double number10 = validator.validate(\"10\", \"#\");\n        final Double number11 = validator.validate(\"11\", \"#\");\n        final Double number19 = validator.validate(\"19\", \"#\");\n        final Double number20 = validator.validate(\"20\", \"#\");\n        final Double number21 = validator.validate(\"21\", \"#\");\n\n        // Test isInRange()\n        assertFalse(validator.isInRange(number9, 10, 20), \"isInRange() < min\");\n        assertTrue(validator.isInRange(number10, 10, 20), \"isInRange() = min\");\n        assertTrue(validator.isInRange(number11, 10, 20), \"isInRange() in range\");\n        assertTrue(validator.isInRange(number20, 10, 20), \"isInRange() = max\");\n        assertFalse(validator.isInRange(number21, 10, 20), \"isInRange() > max\");\n\n        // Test minValue()\n        assertFalse(validator.minValue(number9, 10), \"minValue() < min\");\n        assertTrue(validator.minValue(number10, 10), \"minValue() = min\");\n        assertTrue(validator.minValue(number11, 10), \"minValue() > min\");\n\n        // Test minValue()\n        assertTrue(validator.maxValue(number19, 20), \"maxValue() < max\");\n        assertTrue(validator.maxValue(number20, 20), \"maxValue() = max\");\n        assertFalse(validator.maxValue(number21, 20), \"maxValue() > max\");\n    }\n\n    /**\n     * Test DoubleValidator validate Methods\n     */\n    @Test\n    public void testDoubleValidatorMethods() {\n        final Locale locale = Locale.GERMAN;\n        final String pattern = \"0,00,00\";\n        final String patternVal = \"1,23,45\";\n        final String germanPatternVal = \"1.23.45\";\n        final String localeVal = \"12.345\";\n        final String defaultVal = \"12,345\";\n        final String xxxx = \"XXXX\";\n        final Double expected = Double.valueOf(12345);\n        assertEquals(expected, DoubleValidator.getInstance().validate(defaultVal), \"validate(A) default\");\n        assertEquals(expected, DoubleValidator.getInstance().validate(localeVal, locale), \"validate(A) locale\");\n        assertEquals(expected, DoubleValidator.getInstance().validate(patternVal, pattern), \"validate(A) pattern\");\n        assertEquals(expected, DoubleValidator.getInstance().validate(germanPatternVal, pattern, Locale.GERMAN), \"validate(A) both\");\n\n        assertTrue(DoubleValidator.getInstance().isValid(defaultVal), \"isValid(A) default\");\n        assertTrue(DoubleValidator.getInstance().isValid(localeVal, locale), \"isValid(A) locale\");\n        assertTrue(DoubleValidator.getInstance().isValid(patternVal, pattern), \"isValid(A) pattern\");\n        assertTrue(DoubleValidator.getInstance().isValid(germanPatternVal, pattern, Locale.GERMAN), \"isValid(A) both\");\n\n        assertNull(DoubleValidator.getInstance().validate(xxxx), \"validate(B) default\");\n        assertNull(DoubleValidator.getInstance().validate(xxxx, locale), \"validate(B) locale \");\n        assertNull(DoubleValidator.getInstance().validate(xxxx, pattern), \"validate(B) pattern\");\n        assertNull(DoubleValidator.getInstance().validate(patternVal, pattern, Locale.GERMAN), \"validate(B) both\");\n\n        assertFalse(DoubleValidator.getInstance().isValid(xxxx), \"isValid(B) default\");\n        assertFalse(DoubleValidator.getInstance().isValid(xxxx, locale), \"isValid(B) locale\");\n        assertFalse(DoubleValidator.getInstance().isValid(xxxx, pattern), \"isValid(B) pattern\");\n        assertFalse(DoubleValidator.getInstance().isValid(patternVal, pattern, Locale.GERMAN), \"isValid(B) both\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/routines/ISSNValidatorTest.java.ISSNValidatorTest", "name": "ISSNValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/ISSNValidatorTest.java", "superclasses": "", "methods": ["[void]testConversionErrors()", "[void]testInvalid()", "[void]testIsValidExtract()", "[void]testIsValidISSN()", "[void]testIsValidISSNConvert()", "[void]testIsValidISSNConvertNull()", "[void]testIsValidISSNConvertSuffix()", "[void]testNull()", "[void]testValidCheckDigitEan13()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests {@link ISSNValidator}.\n", "original_string": "public class ISSNValidatorTest {\n\n    private static final ISSNValidator VALIDATOR = ISSNValidator.getInstance();\n\n    private static final String[] VALID_FORMAT = { \"ISSN 0317-8471\", \"1050-124X\", \"ISSN 1562-6865\", \"1063-7710\", \"1748-7188\", \"ISSN 0264-2875\", \"1750-0095\",\n            \"1188-1534\", \"1911-1479\", \"ISSN 1911-1460\", \"0001-6772\", \"1365-201X\", \"0264-3596\", \"1144-875X\", };\n\n    private static final String[] INVALID_FORMAT = { \"\", // empty\n            \"   \", // empty\n            \"ISBN 0317-8471\", // wrong prefix\n            \"'1050-124X\", // leading garbage\n            \"ISSN1562-6865\", // missing separator\n            \"10637710\", // missing separator\n            \"1748-7188'\", // trailing garbage\n            \"ISSN  0264-2875\", // extra space\n            \"1750 0095\", // invalid separator\n            \"1188_1534\", // invalid separator\n            \"1911-1478\", // invalid checkdigit\n    };\n\n    /**\n     * Test Invalid EAN-13 ISSN prefix codes Test Input length\n     */\n    @Test\n    public void testConversionErrors() {\n        String input = null;\n        try {\n            input = \"9780072129519\";\n            VALIDATOR.extractFromEAN13(input);\n            fail(\"Expected IllegalArgumentException for '\" + input + \"'\");\n        } catch (final IllegalArgumentException e) {\n            // expected result\n        }\n        try {\n            input = \"9791090636071\";\n            VALIDATOR.extractFromEAN13(input);\n            fail(\"Expected IllegalArgumentException for '\" + input + \"'\");\n        } catch (final IllegalArgumentException e) {\n            // expected result\n        }\n        try {\n            input = \"03178471\";\n            VALIDATOR.extractFromEAN13(input);\n            fail(\"Expected IllegalArgumentException for '\" + input + \"'\");\n        } catch (final IllegalArgumentException e) {\n            // expected result\n        }\n    }\n\n    /**\n     * Test Invalid ISSN codes\n     */\n    @Test\n    public void testInvalid() {\n        for (final String f : INVALID_FORMAT) {\n            assertFalse(VALIDATOR.isValid(f), f);\n        }\n    }\n\n    /**\n     * Test valid EAN-13 ISSN codes and extract the ISSN\n     */\n    @Test\n    public void testIsValidExtract() {\n        assertEquals(\"12345679\", VALIDATOR.extractFromEAN13(\"9771234567003\"));\n        assertEquals(\"00014664\", VALIDATOR.extractFromEAN13(\"9770001466006\"));\n        assertEquals(\"03178471\", VALIDATOR.extractFromEAN13(\"9770317847001\"));\n        assertEquals(\"1144875X\", VALIDATOR.extractFromEAN13(\"9771144875007\"));\n    }\n\n    /**\n     * Test isValid() ISSN codes\n     */\n    @Test\n    public void testIsValidISSN() {\n        for (final String f : VALID_FORMAT) {\n            assertTrue(VALIDATOR.isValid(f), f);\n        }\n    }\n\n    /**\n     * Test isValid() ISSN codes and convert them\n     */\n    @Test\n    public void testIsValidISSNConvert() {\n        final CheckDigit ean13cd = EAN13CheckDigit.EAN13_CHECK_DIGIT;\n        final Random r = new Random();\n        for (final String f : VALID_FORMAT) {\n            final String suffix = String.format(\"%02d\", r.nextInt(100));\n            final String ean13 = VALIDATOR.convertToEAN13(f, suffix);\n            assertTrue(ean13cd.isValid(ean13), ean13);\n        }\n        // internet samples\n        assertEquals(VALIDATOR.convertToEAN13(\"1144-875X\", \"00\"), \"9771144875007\");\n        assertEquals(VALIDATOR.convertToEAN13(\"0264-3596\", \"00\"), \"9770264359008\");\n        assertEquals(VALIDATOR.convertToEAN13(\"1234-5679\", \"00\"), \"9771234567003\");\n    }\n\n    @Test\n    public void testIsValidISSNConvertNull() {\n        assertNull(VALIDATOR.convertToEAN13(null, \"00\"));\n    }\n\n    @Test\n    public void testIsValidISSNConvertSuffix() {\n        assertThrows(IllegalArgumentException.class, () -> VALIDATOR.convertToEAN13(null, null));\n        assertThrows(IllegalArgumentException.class, () -> VALIDATOR.convertToEAN13(null, \"\"));\n        assertThrows(IllegalArgumentException.class, () -> VALIDATOR.convertToEAN13(null, \"0\"));\n        assertThrows(IllegalArgumentException.class, () -> VALIDATOR.convertToEAN13(null, \"A\"));\n        assertThrows(IllegalArgumentException.class, () -> VALIDATOR.convertToEAN13(null, \"AA\"));\n        assertThrows(IllegalArgumentException.class, () -> VALIDATOR.convertToEAN13(null, \"999\"));\n    }\n\n    /**\n     * Test null values\n     */\n    @Test\n    public void testNull() {\n        assertFalse(VALIDATOR.isValid(null), \"isValid\");\n    }\n\n    /**\n     * Test Invalid EAN-13 ISSN codes\n     */\n    @Test\n    public void testValidCheckDigitEan13() {\n        assertNull(VALIDATOR.extractFromEAN13(\"9771234567001\"));\n        assertNull(VALIDATOR.extractFromEAN13(\"9771234567002\"));\n        assertNotNull(VALIDATOR.extractFromEAN13(\"9771234567003\")); // valid check digit\n        assertNull(VALIDATOR.extractFromEAN13(\"9771234567004\"));\n        assertNull(VALIDATOR.extractFromEAN13(\"9771234567005\"));\n        assertNull(VALIDATOR.extractFromEAN13(\"9771234567006\"));\n        assertNull(VALIDATOR.extractFromEAN13(\"9771234567007\"));\n        assertNull(VALIDATOR.extractFromEAN13(\"9771234567008\"));\n        assertNull(VALIDATOR.extractFromEAN13(\"9771234567009\"));\n        assertNull(VALIDATOR.extractFromEAN13(\"9771234567000\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final ISSNValidator VALIDATOR = ISSNValidator.getInstance();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ISSNValidator", "name": "VALIDATOR = ISSNValidator.getInstance()", "syntax_pass": true}, {"attribute_expression": "private static final String[] VALID_FORMAT = { \"ISSN 0317-8471\", \"1050-124X\", \"ISSN 1562-6865\", \"1063-7710\", \"1748-7188\", \"ISSN 0264-2875\", \"1750-0095\",\n            \"1188-1534\", \"1911-1479\", \"ISSN 1911-1460\", \"0001-6772\", \"1365-201X\", \"0264-3596\", \"1144-875X\", };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "VALID_FORMAT = { \"ISSN 0317-8471\", \"1050-124X\", \"ISSN 1562-6865\", \"1063-7710\", \"1748-7188\", \"ISSN 0264-2875\", \"1750-0095\",\n            \"1188-1534\", \"1911-1479\", \"ISSN 1911-1460\", \"0001-6772\", \"1365-201X\", \"0264-3596\", \"1144-875X\", }", "syntax_pass": true}, {"attribute_expression": "private static final String[] INVALID_FORMAT = { \"\", // empty\n            \"   \", // empty\n            \"ISBN 0317-8471\", // wrong prefix\n            \"'1050-124X\", // leading garbage\n            \"ISSN1562-6865\", // missing separator\n            \"10637710\", // missing separator\n            \"1748-7188'\", // trailing garbage\n            \"ISSN  0264-2875\", // extra space\n            \"1750 0095\", // invalid separator\n            \"1188_1534\", // invalid separator\n            \"1911-1478\", // invalid checkdigit\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "INVALID_FORMAT = { \"\", // empty\n            \"   \", // empty\n            \"ISBN 0317-8471\", // wrong prefix\n            \"'1050-124X\", // leading garbage\n            \"ISSN1562-6865\", // missing separator\n            \"10637710\", // missing separator\n            \"1748-7188'\", // trailing garbage\n            \"ISSN  0264-2875\", // extra space\n            \"1750 0095\", // invalid separator\n            \"1188_1534\", // invalid separator\n            \"1911-1478\", // invalid checkdigit\n    }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/DateValidator_compareDatesTest.java.DateValidator_compareDatesTest", "name": "DateValidator_compareDatesTest", "file_path": "src/test/java/org/apache/commons/validator/routines/DateValidator_compareDatesTest.java", "superclasses": "", "methods": ["[void]testCompareDates_SameDay()", "[void]testCompareDates_DifferentDays()", "[void]testCompareDates_DifferentTimeZones()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/DateValidator_compareDatesTest.java.DateValidator_compareDatesTest.[void]setUp()", "src/test/java/org/apache/commons/validator/routines/DateValidator_compareDatesTest.java.DateValidator_compareDatesTest.[Date]createDate(TimeZone,int,int,int,int,int,int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DateValidator_compareDatesTest {\n    private DateValidator dateValidator;\n    private static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");\n    private static final TimeZone EST = TimeZone.getTimeZone(\"EST\");\n\n    @BeforeEach\n    protected void setUp() {\n        dateValidator = new DateValidator();\n    }\n\n    @Test\n    public void testCompareDates_SameDay() {\n        Date date1 = createDate(GMT, 2023, Calendar.OCTOBER, 10, 12, 0, 0);\n        Date date2 = createDate(GMT, 2023, Calendar.OCTOBER, 10, 14, 0, 0);\n        assertEquals(0, dateValidator.compareDates(date1, date2, GMT), \"Same day, different time\");\n    }\n\n    @Test\n    public void testCompareDates_DifferentDays() {\n        Date date1 = createDate(GMT, 2023, Calendar.OCTOBER, 10, 12, 0, 0);\n        Date date2 = createDate(GMT, 2023, Calendar.OCTOBER, 11, 12, 0, 0);\n        assertEquals(-1, dateValidator.compareDates(date1, date2, GMT), \"Earlier day\");\n        assertEquals(1, dateValidator.compareDates(date2, date1, GMT), \"Later day\");\n    }\n\n    @Test\n    public void testCompareDates_DifferentTimeZones() {\n        Date date1 = createDate(GMT, 2023, Calendar.OCTOBER, 10, 12, 0, 0);\n        Date date2 = createDate(EST, 2023, Calendar.OCTOBER, 10, 12, 0, 0);\n        assertEquals(0, dateValidator.compareDates(date1, date2, GMT), \"Same day, different time zones\");\n    }\n\n    private Date createDate(TimeZone timeZone, int year, int month, int day, int hour, int minute, int second) {\n        Calendar calendar = Calendar.getInstance(timeZone);\n        calendar.set(year, month, day, hour, minute, second);\n        calendar.set(Calendar.MILLISECOND, 0);\n        return calendar.getTime();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DateValidator dateValidator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DateValidator", "name": "dateValidator", "syntax_pass": true}, {"attribute_expression": "private static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "TimeZone", "name": "GMT = TimeZone.getTimeZone(\"GMT\")", "syntax_pass": true}, {"attribute_expression": "private static final TimeZone EST = TimeZone.getTimeZone(\"EST\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "TimeZone", "name": "EST = TimeZone.getTimeZone(\"EST\")", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/IBANValidatorTest.java.IBANValidatorTest", "name": "IBANValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/IBANValidatorTest.java", "superclasses": "", "methods": ["[void]testGetRegexValidatortPatterns()", "[void]testGetValidator()", "[void]testHasValidator()", "[void]testInValid()", "[void]testNull()", "[void]testSetDefaultValidator1()", "[void]testSetDefaultValidator2()", "[void]testSetValidatorLC()", "[void]testSetValidatorLen1()", "[void]testSetValidatorLen35()", "[void]testSetValidatorLen7()", "[void]testSorted()", "[void]testValid()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/IBANValidatorTest.java.IBANValidatorTest.[int]checkIBAN(File,IBANValidator)", "src/test/java/org/apache/commons/validator/routines/IBANValidatorTest.java.IBANValidatorTest.[String]fmtRE(String,int)", "src/test/java/org/apache/commons/validator/routines/IBANValidatorTest.java.IBANValidatorTest.[String]formatToRE(String,int)", "src/test/java/org/apache/commons/validator/routines/IBANValidatorTest.java.IBANValidatorTest.[void]main(String[])", "src/test/java/org/apache/commons/validator/routines/IBANValidatorTest.java.IBANValidatorTest.[void]printEntry(String,String,String,String)"], "overrides": null, "attributes": [], "class_docstring": "\nTests {@link IBANValidator}.\n", "original_string": "public class IBANValidatorTest {\n\n    private static final IBANValidator VALIDATOR = IBANValidator.getInstance();\n\n    // Unfortunately Java only returns the last match of repeated patterns\n    // Use a manual repeat instead\n    private static final String IBAN_PART = \"(?:(\\\\d+)!([acn]))\"; // Assume all parts are fixed length\n\n    private static final Pattern IBAN_PAT = Pattern\n            .compile(\"([A-Z]{2})\" + IBAN_PART + IBAN_PART + IBAN_PART + IBAN_PART + \"?\" + IBAN_PART + \"?\" + IBAN_PART + \"?\" + IBAN_PART + \"?\");\n\n    // It's not clear whether IBANs can contain lower case characters\n    // so we test for both where possible\n    // Note that the BIC near the start of the code is always upper case or digits\n    // @formatter:off\n    private static final String[] VALID_IBAN_FIXTURES = {\n            \"AD1200012030200359100100\",\n            \"AE070331234567890123456\",\n            \"AL47212110090000000235698741\",\n            \"AT611904300234573201\",\n            \"AZ21NABZ00000000137010001944\",\n            \"BA391290079401028494\",\n            \"BE68539007547034\",\n            \"BG80BNBG96611020345678\",\n            \"BH67BMAG00001299123456\",\n            \"BI4210000100010000332045181\",\n            \"BR1800000000141455123924100C2\",\n            \"BR1800360305000010009795493C1\",\n            \"BR9700360305000010009795493P1\",\n            \"BY13NBRB3600900000002Z00AB00\",\n            \"CH9300762011623852957\",\n            \"CR05015202001026284066\",\n            \"CY17002001280000001200527600\",\n            \"CZ6508000000192000145399\",\n            \"CZ9455000000001011038930\",\n            \"DE89370400440532013000\",\n            \"DJ2110002010010409943020008\",\n            \"DK5000400440116243\",\n            \"DO28BAGR00000001212453611324\",\n            \"EE382200221020145685\",\n            \"EG380019000500000000263180002\",\n            \"ES9121000418450200051332\",\n            \"FI2112345600000785\",\n            \"FI5542345670000081\",\n              // FI other\n              \"AX2112345600000785\", // FI other\n              \"AX5542345670000081\", // FI other\n            \"FK88SC123456789012\",\n            \"FO6264600001631634\",\n            \"FR1420041010050500013M02606\",\n              // FR 'other'\n              \"BL6820041010050500013M02606\", // FR other\n              \"GF4120041010050500013M02606\", // FR other\n              \"GP1120041010050500013M02606\", // FR other\n              \"MF8420041010050500013M02606\", // FR other\n              \"MQ5120041010050500013M02606\", // FR other\n              \"NC8420041010050500013M02606\", // FR other\n              \"PF5720041010050500013M02606\", // FR other\n              \"PM3620041010050500013M02606\", // FR other\n              \"RE4220041010050500013M02606\", // FR other\n              \"TF2120041010050500013M02606\", // FR other\n              \"WF9120041010050500013M02606\", // FR other\n              \"YT3120041010050500013M02606\", // FR other\n            \"GB29NWBK60161331926819\",\n              // GB 'other'\n//              \"IM...\", // GB other\n//              \"JE...\", // GB other\n//              \"GG...\", // GB other\n            \"GE29NB0000000101904917\",\n            \"GI75NWBK000000007099453\",\n            \"GL8964710001000206\",\n            \"GR1601101250000000012300695\",\n            \"GT82TRAJ01020000001210029690\",\n            \"HR1210010051863000160\",\n            \"HU42117730161111101800000000\",\n            \"IE29AIBK93115212345678\",\n            \"IL620108000000099999999\",\n            \"IQ98NBIQ850123456789012\",\n            \"IS140159260076545510730339\",\n            \"IT60X0542811101000000123456\",\n            \"JO94CBJO0010000000000131000302\",\n            \"KW81CBKU0000000000001234560101\",\n            \"KZ86125KZT5004100100\",\n            \"LB62099900000001001901229114\",\n            \"LC55HEMM000100010012001200023015\",\n            \"LI21088100002324013AA\",\n            \"LT121000011101001000\",\n            \"LU280019400644750000\",\n            \"LY83002048000020100120361\",\n            \"LV80BANK0000435195001\",\n            \"LY83002048000020100120361\",\n            \"MC5811222000010123456789030\",\n            \"MD24AG000225100013104168\",\n            \"ME25505000012345678951\",\n            \"MK07250120000058984\",\n            \"MN121234123456789123\",\n            \"MR1300020001010000123456753\",\n            \"MT84MALT011000012345MTLCAST001S\",\n            \"MU17BOMM0101101030300200000MUR\",\n            \"NI45BAPR00000013000003558124\",\n            \"NL91ABNA0417164300\",\n            \"NO9386011117947\",\n            \"OM810180000001299123456\",\n            \"PK36SCBL0000001123456702\",\n            \"PL61109010140000071219812874\",\n            \"PS92PALS000000000400123456702\",\n            \"PT50000201231234567890154\",\n            \"QA58DOHB00001234567890ABCDEFG\",\n            \"RO49AAAA1B31007593840000\",\n            \"RS35260005601001611379\",\n            \"RU0204452560040702810412345678901\",\n            \"SA0380000000608010167519\",\n            \"SC18SSCB11010000000000001497USD\",\n            \"SD8811123456789012\",\n            \"SE4550000000058398257466\",\n            \"SI56191000000123438\",\n            \"SI56263300012039086\",\n            \"SK3112000000198742637541\",\n            \"SM86U0322509800000000270100\",\n            \"SO211000001001000100141\",\n            \"ST68000100010051845310112\",\n            \"SV62CENR00000000000000700025\",\n            \"SV43ACAT00000000000000123123\",\n            \"TL380080012345678910157\",\n            \"TN5910006035183598478831\",\n            \"TR330006100519786457841326\",\n            \"UA213223130000026007233566001\",\n            \"UA213996220000026007233566001\",\n            \"VA59001123000012345678\",\n            \"VG96VPVG0000012345678901\",\n            \"XK051212012345678906\",\n    };\n    // @formatter:on\n\n    // @formatter:off\n    private static final String[] INVALID_IBAN_FIXTURES = {\n            \"\",                        // empty\n            \"   \",                     // empty\n            \"A\",                       // too short\n            \"AB\",                      // too short\n            \"FR1420041010050500013m02606\", // lowercase version\n            \"MT84MALT011000012345mtlcast001s\", // lowercase version\n            \"LI21088100002324013aa\", // lowercase version\n            \"QA58DOHB00001234567890abcdefg\", // lowercase version\n            \"RO49AAAA1b31007593840000\", // lowercase version\n            \"LC62HEMM000100010012001200023015\", // wrong in SWIFT\n            \"BY00NBRB3600000000000Z00AB00\", // Wrong in SWIFT v73\n            \"ST68000200010192194210112\", // ditto\n            \"SV62CENR0000000000000700025\", // ditto\n    };\n    // @formatter:on\n\n    private static int checkIBAN(final File file, final IBANValidator val) throws Exception {\n        // The IBAN Registry (TXT) file is a TAB-separated file\n        // Rows are the entry types, columns are the countries\n        final CSVFormat format = CSVFormat.DEFAULT.builder().setDelimiter('\\t').build();\n        final Reader rdr = new InputStreamReader(new FileInputStream(file), \"ISO_8859_1\");\n        try (final CSVParser p = new CSVParser(rdr, format)) {\n            CSVRecord country = null;\n            CSVRecord cc = null;\n            CSVRecord structure = null;\n            CSVRecord length = null;\n            for (final CSVRecord o : p) {\n                final String item = o.get(0);\n                switch (item) {\n                case \"Name of country\":\n                    country = o;\n                    break;\n                case \"IBAN prefix country code (ISO 3166)\":\n                    cc = o;\n                    break;\n                case \"IBAN structure\":\n                    structure = o;\n                    break;\n                case \"IBAN length\":\n                    length = o;\n                    break;\n                default:\n                    break;\n                }\n            }\n            assertNotNull(country);\n            assertNotNull(length);\n            assertNotNull(structure);\n            assertNotNull(cc);\n            for (int i = 1; i < country.size(); i++) {\n                try {\n\n                    final String newLength = length.get(i).split(\"!\")[0]; // El Salvador currently has \"28!n\"\n                    final String newRE = fmtRE(structure.get(i), Integer.parseInt(newLength));\n                    final Validator valre = val.getValidator(cc.get(i));\n                    if (valre == null) {\n                        System.out.println(\"// Missing entry:\");\n                        printEntry(cc.get(i), newLength, newRE, country.get(i));\n                    } else {\n                        final String currentLength = Integer.toString(valre.getIbanLength());\n                        final String currentRE = valre.getRegexValidator().toString().replaceAll(\"^.+?\\\\{(.+)}\", \"$1\") // Extract RE from RegexValidator{re}\n                                                                                                                       // string\n                                .replace(\"\\\\d\", \"\\\\\\\\d\"); // convert \\d to \\\\d\n                        // The above assumes that the RegexValidator contains a single Regex\n                        if (currentRE.equals(newRE) && currentLength.equals(newLength)) {\n\n                        } else {\n                            System.out.println(\"// Expected: \" + newRE + \", \" + newLength + \" Actual: \" + currentRE + \", \" + currentLength);\n                            printEntry(cc.get(i), newLength, newRE, country.get(i));\n                        }\n\n                    }\n\n                } catch (final IllegalArgumentException e) {\n                    e.printStackTrace();\n                }\n            }\n            p.close();\n            return country.size();\n        }\n    }\n\n    private static String fmtRE(final String ibanPat, final int ibanLen) {\n        final Matcher m = IBAN_PAT.matcher(ibanPat);\n        if (!m.matches()) {\n            throw new IllegalArgumentException(\"Unexpected IBAN pattern \" + ibanPat);\n        }\n        final StringBuilder sb = new StringBuilder();\n        final String cc = m.group(1); // country code\n        int totalLen = cc.length();\n        sb.append(cc);\n        int len = Integer.parseInt(m.group(2)); // length of part\n        String curType = m.group(3); // part type\n        for (int i = 4; i <= m.groupCount(); i += 2) {\n            if (m.group(i) == null) { // reached an optional group\n                break;\n            }\n            final int count = Integer.parseInt(m.group(i));\n            final String type = m.group(i + 1);\n            if (type.equals(curType)) { // more of the same type\n                len += count;\n            } else {\n                sb.append(formatToRE(curType, len));\n                totalLen += len;\n                curType = type;\n                len = count;\n            }\n        }\n        sb.append(formatToRE(curType, len));\n        totalLen += len;\n        if (ibanLen != totalLen) {\n            throw new IllegalArgumentException(\"IBAN pattern \" + ibanPat + \" does not match length \" + ibanLen);\n        }\n        return sb.toString();\n    }\n\n    // convert IBAN type string and length to regex\n    private static String formatToRE(final String type, final int len) {\n        final char ctype = type.charAt(0); // assume type.length() == 1\n        switch (ctype) {\n        case 'n':\n            return String.format(\"\\\\\\\\d{%d}\", len);\n        case 'a':\n            return String.format(\"[A-Z]{%d}\", len);\n        case 'c':\n            return String.format(\"[A-Z0-9]{%d}\", len);\n        default:\n            throw new IllegalArgumentException(\"Unexpected type \" + type);\n        }\n    }\n\n    public static void main(final String[] a) throws Exception {\n        final IBANValidator validator = new IBANValidator();\n        final File ibanTsv = new File(\"target\", \"iban-registry.tsv\");\n        int countries = 0;\n        if (ibanTsv.canRead()) {\n            countries = checkIBAN(ibanTsv, validator);\n        } else {\n            System.out.println(\"Please load the file \" + ibanTsv.getCanonicalPath() + \" from https://www.swift.com/standards/data-standards/iban\");\n        }\n        System.out.println(\"Processed \" + countries + \" countries.\");\n    }\n\n    private static void printEntry(final String ccode, final String length, final String ib, final String country) {\n        final String fmt = String.format(\"\\\"%s\\\"\", ib);\n        System.out.printf(\"            new Validator(\\\"%s\\\", %s, %-40s), // %s\\n\", ccode, length, fmt, country);\n    }\n\n    @Test\n    public void testGetRegexValidatortPatterns() {\n        assertNotNull(VALIDATOR.getValidator(\"GB\").getRegexValidator().getPatterns(), \"GB\");\n    }\n\n    @Test\n    public void testGetValidator() {\n        assertNotNull(VALIDATOR.getValidator(\"GB\"), \"GB\");\n        assertNull(VALIDATOR.getValidator(\"gb\"), \"gb\");\n    }\n\n    @Test\n    public void testHasValidator() {\n        assertTrue(VALIDATOR.hasValidator(\"GB\"), \"GB\");\n        assertFalse(VALIDATOR.hasValidator(\"gb\"), \"gb\");\n    }\n\n    @Test\n    public void testInValid() {\n        for (final String f : INVALID_IBAN_FIXTURES) {\n            assertFalse(VALIDATOR.isValid(f), f);\n        }\n    }\n\n    @Test\n    public void testNull() {\n        assertFalse(VALIDATOR.isValid(null), \"isValid(null)\");\n    }\n\n    @Test\n    public void testSetDefaultValidator1() {\n        final IllegalStateException thrown = assertThrows(IllegalStateException.class, () -> VALIDATOR.setValidator(\"GB\", 15, \"GB\"));\n        assertEquals(\"The singleton validator cannot be modified\", thrown.getMessage());\n\n    }\n\n    @Test\n    public void testSetDefaultValidator2() {\n        final IllegalStateException thrown = assertThrows(IllegalStateException.class, () -> VALIDATOR.setValidator(\"GB\", -1, \"GB\"));\n        assertEquals(\"The singleton validator cannot be modified\", thrown.getMessage());\n    }\n\n    @Test\n    public void testSetValidatorLC() {\n        final IBANValidator validator = new IBANValidator();\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> validator.setValidator(\"gb\", 15, \"GB\"));\n        assertEquals(\"Invalid country Code; must be exactly 2 upper-case characters\", thrown.getMessage());\n    }\n\n    @Test\n    public void testSetValidatorLen1() {\n        final IBANValidator validator = new IBANValidator();\n        assertNotNull(validator.setValidator(\"GB\", -1, \"\"), \"should be present\");\n        assertNull(validator.setValidator(\"GB\", -1, \"\"), \"no longer present\");\n    }\n\n    @Test\n    public void testSetValidatorLen35() {\n        final IBANValidator validator = new IBANValidator();\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> validator.setValidator(\"GB\", 35, \"GB\"));\n        assertEquals(\"Invalid length parameter, must be in range 8 to 34 inclusive: 35\", thrown.getMessage());\n    }\n\n    @Test\n    public void testSetValidatorLen7() {\n        final IBANValidator validator = new IBANValidator();\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> validator.setValidator(\"GB\", 7, \"GB\"));\n        assertEquals(\"Invalid length parameter, must be in range 8 to 34 inclusive: 7\", thrown.getMessage());\n    }\n\n    @Test\n    public void testSorted() {\n        final IBANValidator validator = new IBANValidator();\n        final Validator[] vals = validator.getDefaultValidators();\n        assertNotNull(vals);\n        for (int i = 1; i < vals.length; i++) {\n            if (vals[i].countryCode.compareTo(vals[i - 1].countryCode) <= 0) {\n                fail(\"Not sorted: \" + vals[i].countryCode + \" <= \" + vals[i - 1].countryCode);\n            }\n        }\n    }\n\n    @Test\n    public void testValid() {\n        for (final String f : VALID_IBAN_FIXTURES) {\n            assertTrue(IBANCheckDigit.IBAN_CHECK_DIGIT.isValid(f), \"Checksum fail: \" + f);\n            assertTrue(VALIDATOR.hasValidator(f), \"Missing validator: \" + f);\n            assertTrue(VALIDATOR.isValid(f), f);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final IBANValidator VALIDATOR = IBANValidator.getInstance();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "IBANValidator", "name": "VALIDATOR = IBANValidator.getInstance()", "syntax_pass": true}, {"attribute_expression": "private static final String IBAN_PART = \"(?:(\\\\d+)!([acn]))\";", "docstring": " Use a manual repeat instead", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "IBAN_PART = \"(?:(\\\\d+)!([acn]))\"", "syntax_pass": true}, {"attribute_expression": "private static final Pattern IBAN_PAT = Pattern\n            .compile(\"([A-Z]{2})\" + IBAN_PART + IBAN_PART + IBAN_PART + IBAN_PART + \"?\" + IBAN_PART + \"?\" + IBAN_PART + \"?\" + IBAN_PART + \"?\");", "docstring": " Assume all parts are fixed length", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "IBAN_PAT = Pattern\n            .compile(\"([A-Z]{2})\" + IBAN_PART + IBAN_PART + IBAN_PART + IBAN_PART + \"?\" + IBAN_PART + \"?\" + IBAN_PART + \"?\" + IBAN_PART + \"?\")", "syntax_pass": true}, {"attribute_expression": "private static final String[] VALID_IBAN_FIXTURES = {\n            \"AD1200012030200359100100\",\n            \"AE070331234567890123456\",\n            \"AL47212110090000000235698741\",\n            \"AT611904300234573201\",\n            \"AZ21NABZ00000000137010001944\",\n            \"BA391290079401028494\",\n            \"BE68539007547034\",\n            \"BG80BNBG96611020345678\",\n            \"BH67BMAG00001299123456\",\n            \"BI4210000100010000332045181\",\n            \"BR1800000000141455123924100C2\",\n            \"BR1800360305000010009795493C1\",\n            \"BR9700360305000010009795493P1\",\n            \"BY13NBRB3600900000002Z00AB00\",\n            \"CH9300762011623852957\",\n            \"CR05015202001026284066\",\n            \"CY17002001280000001200527600\",\n            \"CZ6508000000192000145399\",\n            \"CZ9455000000001011038930\",\n            \"DE89370400440532013000\",\n            \"DJ2110002010010409943020008\",\n            \"DK5000400440116243\",\n            \"DO28BAGR00000001212453611324\",\n            \"EE382200221020145685\",\n            \"EG380019000500000000263180002\",\n            \"ES9121000418450200051332\",\n            \"FI2112345600000785\",\n            \"FI5542345670000081\",\n              // FI other\n              \"AX2112345600000785\", // FI other\n              \"AX5542345670000081\", // FI other\n            \"FK88SC123456789012\",\n            \"FO6264600001631634\",\n            \"FR1420041010050500013M02606\",\n              // FR 'other'\n              \"BL6820041010050500013M02606\", // FR other\n              \"GF4120041010050500013M02606\", // FR other\n              \"GP1120041010050500013M02606\", // FR other\n              \"MF8420041010050500013M02606\", // FR other\n              \"MQ5120041010050500013M02606\", // FR other\n              \"NC8420041010050500013M02606\", // FR other\n              \"PF5720041010050500013M02606\", // FR other\n              \"PM3620041010050500013M02606\", // FR other\n              \"RE4220041010050500013M02606\", // FR other\n              \"TF2120041010050500013M02606\", // FR other\n              \"WF9120041010050500013M02606\", // FR other\n              \"YT3120041010050500013M02606\", // FR other\n            \"GB29NWBK60161331926819\",\n              // GB 'other'\n//              \"IM...\", // GB other\n//              \"JE...\", // GB other\n//              \"GG...\", // GB other\n            \"GE29NB0000000101904917\",\n            \"GI75NWBK000000007099453\",\n            \"GL8964710001000206\",\n            \"GR1601101250000000012300695\",\n            \"GT82TRAJ01020000001210029690\",\n            \"HR1210010051863000160\",\n            \"HU42117730161111101800000000\",\n            \"IE29AIBK93115212345678\",\n            \"IL620108000000099999999\",\n            \"IQ98NBIQ850123456789012\",\n            \"IS140159260076545510730339\",\n            \"IT60X0542811101000000123456\",\n            \"JO94CBJO0010000000000131000302\",\n            \"KW81CBKU0000000000001234560101\",\n            \"KZ86125KZT5004100100\",\n            \"LB62099900000001001901229114\",\n            \"LC55HEMM000100010012001200023015\",\n            \"LI21088100002324013AA\",\n            \"LT121000011101001000\",\n            \"LU280019400644750000\",\n            \"LY83002048000020100120361\",\n            \"LV80BANK0000435195001\",\n            \"LY83002048000020100120361\",\n            \"MC5811222000010123456789030\",\n            \"MD24AG000225100013104168\",\n            \"ME25505000012345678951\",\n            \"MK07250120000058984\",\n            \"MN121234123456789123\",\n            \"MR1300020001010000123456753\",\n            \"MT84MALT011000012345MTLCAST001S\",\n            \"MU17BOMM0101101030300200000MUR\",\n            \"NI45BAPR00000013000003558124\",\n            \"NL91ABNA0417164300\",\n            \"NO9386011117947\",\n            \"OM810180000001299123456\",\n            \"PK36SCBL0000001123456702\",\n            \"PL61109010140000071219812874\",\n            \"PS92PALS000000000400123456702\",\n            \"PT50000201231234567890154\",\n            \"QA58DOHB00001234567890ABCDEFG\",\n            \"RO49AAAA1B31007593840000\",\n            \"RS35260005601001611379\",\n            \"RU0204452560040702810412345678901\",\n            \"SA0380000000608010167519\",\n            \"SC18SSCB11010000000000001497USD\",\n            \"SD8811123456789012\",\n            \"SE4550000000058398257466\",\n            \"SI56191000000123438\",\n            \"SI56263300012039086\",\n            \"SK3112000000198742637541\",\n            \"SM86U0322509800000000270100\",\n            \"SO211000001001000100141\",\n            \"ST68000100010051845310112\",\n            \"SV62CENR00000000000000700025\",\n            \"SV43ACAT00000000000000123123\",\n            \"TL380080012345678910157\",\n            \"TN5910006035183598478831\",\n            \"TR330006100519786457841326\",\n            \"UA213223130000026007233566001\",\n            \"UA213996220000026007233566001\",\n            \"VA59001123000012345678\",\n            \"VG96VPVG0000012345678901\",\n            \"XK051212012345678906\",\n    };", "docstring": " @formatter:off", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "VALID_IBAN_FIXTURES = {\n            \"AD1200012030200359100100\",\n            \"AE070331234567890123456\",\n            \"AL47212110090000000235698741\",\n            \"AT611904300234573201\",\n            \"AZ21NABZ00000000137010001944\",\n            \"BA391290079401028494\",\n            \"BE68539007547034\",\n            \"BG80BNBG96611020345678\",\n            \"BH67BMAG00001299123456\",\n            \"BI4210000100010000332045181\",\n            \"BR1800000000141455123924100C2\",\n            \"BR1800360305000010009795493C1\",\n            \"BR9700360305000010009795493P1\",\n            \"BY13NBRB3600900000002Z00AB00\",\n            \"CH9300762011623852957\",\n            \"CR05015202001026284066\",\n            \"CY17002001280000001200527600\",\n            \"CZ6508000000192000145399\",\n            \"CZ9455000000001011038930\",\n            \"DE89370400440532013000\",\n            \"DJ2110002010010409943020008\",\n            \"DK5000400440116243\",\n            \"DO28BAGR00000001212453611324\",\n            \"EE382200221020145685\",\n            \"EG380019000500000000263180002\",\n            \"ES9121000418450200051332\",\n            \"FI2112345600000785\",\n            \"FI5542345670000081\",\n              // FI other\n              \"AX2112345600000785\", // FI other\n              \"AX5542345670000081\", // FI other\n            \"FK88SC123456789012\",\n            \"FO6264600001631634\",\n            \"FR1420041010050500013M02606\",\n              // FR 'other'\n              \"BL6820041010050500013M02606\", // FR other\n              \"GF4120041010050500013M02606\", // FR other\n              \"GP1120041010050500013M02606\", // FR other\n              \"MF8420041010050500013M02606\", // FR other\n              \"MQ5120041010050500013M02606\", // FR other\n              \"NC8420041010050500013M02606\", // FR other\n              \"PF5720041010050500013M02606\", // FR other\n              \"PM3620041010050500013M02606\", // FR other\n              \"RE4220041010050500013M02606\", // FR other\n              \"TF2120041010050500013M02606\", // FR other\n              \"WF9120041010050500013M02606\", // FR other\n              \"YT3120041010050500013M02606\", // FR other\n            \"GB29NWBK60161331926819\",\n              // GB 'other'\n//              \"IM...\", // GB other\n//              \"JE...\", // GB other\n//              \"GG...\", // GB other\n            \"GE29NB0000000101904917\",\n            \"GI75NWBK000000007099453\",\n            \"GL8964710001000206\",\n            \"GR1601101250000000012300695\",\n            \"GT82TRAJ01020000001210029690\",\n            \"HR1210010051863000160\",\n            \"HU42117730161111101800000000\",\n            \"IE29AIBK93115212345678\",\n            \"IL620108000000099999999\",\n            \"IQ98NBIQ850123456789012\",\n            \"IS140159260076545510730339\",\n            \"IT60X0542811101000000123456\",\n            \"JO94CBJO0010000000000131000302\",\n            \"KW81CBKU0000000000001234560101\",\n            \"KZ86125KZT5004100100\",\n            \"LB62099900000001001901229114\",\n            \"LC55HEMM000100010012001200023015\",\n            \"LI21088100002324013AA\",\n            \"LT121000011101001000\",\n            \"LU280019400644750000\",\n            \"LY83002048000020100120361\",\n            \"LV80BANK0000435195001\",\n            \"LY83002048000020100120361\",\n            \"MC5811222000010123456789030\",\n            \"MD24AG000225100013104168\",\n            \"ME25505000012345678951\",\n            \"MK07250120000058984\",\n            \"MN121234123456789123\",\n            \"MR1300020001010000123456753\",\n            \"MT84MALT011000012345MTLCAST001S\",\n            \"MU17BOMM0101101030300200000MUR\",\n            \"NI45BAPR00000013000003558124\",\n            \"NL91ABNA0417164300\",\n            \"NO9386011117947\",\n            \"OM810180000001299123456\",\n            \"PK36SCBL0000001123456702\",\n            \"PL61109010140000071219812874\",\n            \"PS92PALS000000000400123456702\",\n            \"PT50000201231234567890154\",\n            \"QA58DOHB00001234567890ABCDEFG\",\n            \"RO49AAAA1B31007593840000\",\n            \"RS35260005601001611379\",\n            \"RU0204452560040702810412345678901\",\n            \"SA0380000000608010167519\",\n            \"SC18SSCB11010000000000001497USD\",\n            \"SD8811123456789012\",\n            \"SE4550000000058398257466\",\n            \"SI56191000000123438\",\n            \"SI56263300012039086\",\n            \"SK3112000000198742637541\",\n            \"SM86U0322509800000000270100\",\n            \"SO211000001001000100141\",\n            \"ST68000100010051845310112\",\n            \"SV62CENR00000000000000700025\",\n            \"SV43ACAT00000000000000123123\",\n            \"TL380080012345678910157\",\n            \"TN5910006035183598478831\",\n            \"TR330006100519786457841326\",\n            \"UA213223130000026007233566001\",\n            \"UA213996220000026007233566001\",\n            \"VA59001123000012345678\",\n            \"VG96VPVG0000012345678901\",\n            \"XK051212012345678906\",\n    }", "syntax_pass": true}, {"attribute_expression": "private static final String[] INVALID_IBAN_FIXTURES = {\n            \"\",                        // empty\n            \"   \",                     // empty\n            \"A\",                       // too short\n            \"AB\",                      // too short\n            \"FR1420041010050500013m02606\", // lowercase version\n            \"MT84MALT011000012345mtlcast001s\", // lowercase version\n            \"LI21088100002324013aa\", // lowercase version\n            \"QA58DOHB00001234567890abcdefg\", // lowercase version\n            \"RO49AAAA1b31007593840000\", // lowercase version\n            \"LC62HEMM000100010012001200023015\", // wrong in SWIFT\n            \"BY00NBRB3600000000000Z00AB00\", // Wrong in SWIFT v73\n            \"ST68000200010192194210112\", // ditto\n            \"SV62CENR0000000000000700025\", // ditto\n    };", "docstring": " @formatter:off", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "INVALID_IBAN_FIXTURES = {\n            \"\",                        // empty\n            \"   \",                     // empty\n            \"A\",                       // too short\n            \"AB\",                      // too short\n            \"FR1420041010050500013m02606\", // lowercase version\n            \"MT84MALT011000012345mtlcast001s\", // lowercase version\n            \"LI21088100002324013aa\", // lowercase version\n            \"QA58DOHB00001234567890abcdefg\", // lowercase version\n            \"RO49AAAA1b31007593840000\", // lowercase version\n            \"LC62HEMM000100010012001200023015\", // wrong in SWIFT\n            \"BY00NBRB3600000000000Z00AB00\", // Wrong in SWIFT v73\n            \"ST68000200010192194210112\", // ditto\n            \"SV62CENR0000000000000700025\", // ditto\n    }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/DateValidator_compareWeeksTest.java.DateValidator_compareWeeksTest", "name": "DateValidator_compareWeeksTest", "file_path": "src/test/java/org/apache/commons/validator/routines/DateValidator_compareWeeksTest.java", "superclasses": "", "methods": ["[void]testCompareWeeks()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/DateValidator_compareWeeksTest.java.DateValidator_compareWeeksTest.[void]setUp()", "src/test/java/org/apache/commons/validator/routines/DateValidator_compareWeeksTest.java.DateValidator_compareWeeksTest.[Date]createDate(TimeZone,int,int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DateValidator_compareWeeksTest {\n    private DateValidator dateValidator;\n    private static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");\n    private static final TimeZone EST = TimeZone.getTimeZone(\"EST\");\n\n    @BeforeEach\n    protected void setUp() {\n        dateValidator = new DateValidator();\n    }\n\n    @Test\n    public void testCompareWeeks() {\n        final int sameTime = 124522;\n        final int testDate = 20050823;\n        final Date value = createDate(GMT, testDate, sameTime); // test value\n        final Date date20050830 = createDate(GMT, 20050830, sameTime); // +1 week\n        final Date date20050816 = createDate(GMT, 20050816, sameTime); // -1 week\n\n        assertEquals(-1, dateValidator.compareWeeks(value, date20050830, GMT), \"week LT\"); // +1 week\n        assertEquals(0, dateValidator.compareWeeks(value, createDate(GMT, 20050824, sameTime), GMT), \"week =1\"); // +1 day\n        assertEquals(0, dateValidator.compareWeeks(value, createDate(GMT, 20050822, sameTime), GMT), \"week =2\"); // same week\n        assertEquals(0, dateValidator.compareWeeks(value, createDate(GMT, 20050822, sameTime), GMT), \"week =3\"); // -1 day\n        assertEquals(1, dateValidator.compareWeeks(value, date20050816, GMT), \"week GT\"); // -1 week\n    }\n\n    private Date createDate(TimeZone timeZone, int date, int time) {\n        Calendar calendar = Calendar.getInstance(timeZone);\n        calendar.set(Calendar.YEAR, date / 10000);\n        calendar.set(Calendar.MONTH, (date % 10000) / 100 - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, date % 100);\n        calendar.set(Calendar.HOUR_OF_DAY, time / 10000);\n        calendar.set(Calendar.MINUTE, (time % 10000) / 100);\n        calendar.set(Calendar.SECOND, time % 100);\n        calendar.set(Calendar.MILLISECOND, 0);\n        return calendar.getTime();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DateValidator dateValidator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DateValidator", "name": "dateValidator", "syntax_pass": true}, {"attribute_expression": "private static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "TimeZone", "name": "GMT = TimeZone.getTimeZone(\"GMT\")", "syntax_pass": true}, {"attribute_expression": "private static final TimeZone EST = TimeZone.getTimeZone(\"EST\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "TimeZone", "name": "EST = TimeZone.getTimeZone(\"EST\")", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/PercentValidatorTest.java.PercentValidatorTest", "name": "PercentValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/PercentValidatorTest.java", "superclasses": "", "methods": ["[void]testFormatType()", "[void]testInvalid()", "[void]testValid()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/PercentValidatorTest.java.PercentValidatorTest.[void]setUp()", "src/test/java/org/apache/commons/validator/routines/PercentValidatorTest.java.PercentValidatorTest.[void]tearDown()"], "overrides": null, "attributes": [], "class_docstring": "\nTest Case for PercentValidator.\n", "original_string": "public class PercentValidatorTest {\n\n    protected PercentValidator validator;\n\n    @BeforeEach\n    protected void setUp() {\n        validator = new PercentValidator();\n    }\n\n    /**\n     * Tear down\n     */\n    @AfterEach\n    protected void tearDown() {\n        validator = null;\n    }\n\n    /**\n     * Test Format Type\n     */\n    @Test\n    public void testFormatType() {\n        assertEquals(2, PercentValidator.getInstance().getFormatType(), \"Format Type A\");\n        assertEquals(AbstractNumberValidator.PERCENT_FORMAT, PercentValidator.getInstance().getFormatType(), \"Format Type B\");\n    }\n\n    /**\n     * Test Invalid percentage values\n     */\n    @Test\n    public void testInvalid() {\n        final BigDecimalValidator validator = PercentValidator.getInstance();\n\n        // Invalid Missing\n        assertFalse(validator.isValid(null), \"isValid() Null Value\");\n        assertFalse(validator.isValid(\"\"), \"isValid() Empty Value\");\n        assertNull(validator.validate(null), \"validate() Null Value\");\n        assertNull(validator.validate(\"\"), \"validate() Empty Value\");\n\n        // Invalid UK\n        assertFalse(validator.isValid(\"12@\", Locale.UK), \"UK wrong symbol\"); // ???\n        assertFalse(validator.isValid(\"(12%)\", Locale.UK), \"UK wrong negative\");\n\n        // Invalid US - can't find a Locale with different symbols!\n        assertFalse(validator.isValid(\"12@\", Locale.US), \"US wrong symbol\"); // ???\n        assertFalse(validator.isValid(\"(12%)\", Locale.US), \"US wrong negative\");\n    }\n\n    /**\n     * Test Valid percentage values\n     */\n    @Test\n    public void testValid() {\n        // Set the default Locale\n        final Locale origDefault = Locale.getDefault();\n        Locale.setDefault(Locale.UK);\n\n        final BigDecimalValidator validator = PercentValidator.getInstance();\n        final BigDecimal expected = new BigDecimal(\"0.12\");\n        final BigDecimal negative = new BigDecimal(\"-0.12\");\n        final BigDecimal hundred = new BigDecimal(\"1.00\");\n\n        assertEquals(expected, validator.validate(\"12%\"), \"Default locale\");\n        assertEquals(negative, validator.validate(\"-12%\"), \"Default negtve\");\n\n        // Invalid UK\n        assertEquals(expected, validator.validate(\"12%\", Locale.UK), \"UK locale\");\n        assertEquals(negative, validator.validate(\"-12%\", Locale.UK), \"UK negative\");\n        assertEquals(expected, validator.validate(\"12\", Locale.UK), \"UK No symbol\");\n\n        // Invalid US - can't find a Locale with different symbols!\n        assertEquals(expected, validator.validate(\"12%\", Locale.US), \"US locale\");\n        assertEquals(negative, validator.validate(\"-12%\", Locale.US), \"US negative\");\n        assertEquals(expected, validator.validate(\"12\", Locale.US), \"US No symbol\");\n\n        assertEquals(hundred, validator.validate(\"100%\"), \"100%\");\n\n        // Restore the original default\n        Locale.setDefault(origDefault);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected PercentValidator validator;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "PercentValidator", "name": "validator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/InetAddressValidator_isValidInet4AddressTest.java.InetAddressValidator_isValidInet4AddressTest", "name": "InetAddressValidator_isValidInet4AddressTest", "file_path": "src/test/java/org/apache/commons/validator/routines/InetAddressValidator_isValidInet4AddressTest.java", "superclasses": "", "methods": ["[void]testValidInet4Address()", "[void]testInvalidInet4Address()", "[void]testInvalidFormatInet4Address()", "[void]testLeadingZeroInet4Address()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/InetAddressValidator_isValidInet4AddressTest.java.InetAddressValidator_isValidInet4AddressTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class InetAddressValidator_isValidInet4AddressTest {\n    private InetAddressValidator validator;\n\n    @BeforeEach\n    protected void setUp() {\n        validator = new InetAddressValidator();\n    }\n\n    @Test\n    public void testValidInet4Address() {\n        final String[] valid = { \"192.168.0.1\", \"10.0.0.1\", \"172.16.254.1\", \"255.255.255.255\" };\n        for (final String item : valid) {\n            assertTrue(validator.isValidInet4Address(item), () -> String.format(\"%s should be valid\", item));\n        }\n    }\n\n    @Test\n    public void testInvalidInet4Address() {\n        final String[] invalid = { \"256.256.256.256\", \"192.168.0\", \"192.168.0.1.1\", \"192.168.0.1.\", \"192.168.0.01\", \"192.168.0.1/24\" };\n        for (final String item : invalid) {\n            assertFalse(validator.isValidInet4Address(item), () -> String.format(\"%s should be invalid\", item));\n        }\n    }\n\n    @Test\n    public void testInvalidFormatInet4Address() {\n        final String[] invalidFormat = { \"192.168.0.a\", \"192.168.0.-1\", \"192.168.0.256\", \"192.168.0.1 \", \" 192.168.0.1\" };\n        for (final String item : invalidFormat) {\n            assertFalse(validator.isValidInet4Address(item), () -> String.format(\"%s should be invalid\", item));\n        }\n    }\n\n    @Test\n    public void testLeadingZeroInet4Address() {\n        final String[] invalidLeadingZero = { \"192.168.00.1\", \"192.168.0.01\", \"0192.168.0.1\" };\n        for (final String item : invalidLeadingZero) {\n            assertFalse(validator.isValidInet4Address(item), () -> String.format(\"%s should be invalid\", item));\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private InetAddressValidator validator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "InetAddressValidator", "name": "validator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/DateValidator_compareMonthsTest.java.DateValidator_compareMonthsTest", "name": "DateValidator_compareMonthsTest", "file_path": "src/test/java/org/apache/commons/validator/routines/DateValidator_compareMonthsTest.java", "superclasses": "", "methods": ["[void]testCompareMonths()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/DateValidator_compareMonthsTest.java.DateValidator_compareMonthsTest.[void]setUp()", "src/test/java/org/apache/commons/validator/routines/DateValidator_compareMonthsTest.java.DateValidator_compareMonthsTest.[Date]createDate(TimeZone,int,int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DateValidator_compareMonthsTest {\n    private DateValidator dateValidator;\n    private static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");\n    private static final TimeZone EST = TimeZone.getTimeZone(\"EST\");\n\n    @BeforeEach\n    protected void setUp() {\n        dateValidator = new DateValidator();\n    }\n\n    @Test\n    public void testCompareMonths() {\n        final int sameTime = 124522;\n        final int testDate = 20050823;\n\n        final Date value = createDate(GMT, testDate, sameTime); // test value\n        final Date date20050901 = createDate(GMT, 20050901, sameTime); // +1 month\n        final Date date20050801 = createDate(GMT, 20050801, sameTime); // same month\n        final Date date20050731 = createDate(GMT, 20050731, sameTime); // -1 month\n\n        assertEquals(-1, dateValidator.compareMonths(value, date20050901, GMT), \"mnth LT\"); // +1 month\n        assertEquals(0, dateValidator.compareMonths(value, date20050801, GMT), \"mnth EQ\"); // same month\n        assertEquals(1, dateValidator.compareMonths(value, date20050731, GMT), \"mnth GT\"); // -1 month\n\n        // Compare using alternative TimeZone\n        final Date sameDayTwoAm = createDate(GMT, testDate, 20000);\n        assertEquals(-1, dateValidator.compareMonths(value, date20050901, EST), \"mnth LT\"); // +1 month\n        assertEquals(0, dateValidator.compareMonths(value, date20050801, EST), \"mnth EQ\"); // same month\n        assertEquals(1, dateValidator.compareMonths(value, date20050731, EST), \"mnth GT\"); // -1 month\n    }\n\n    private Date createDate(TimeZone timeZone, int date, int time) {\n        Calendar calendar = Calendar.getInstance(timeZone);\n        calendar.set(Calendar.YEAR, date / 10000);\n        calendar.set(Calendar.MONTH, (date % 10000) / 100 - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, date % 100);\n        calendar.set(Calendar.HOUR_OF_DAY, time / 10000);\n        calendar.set(Calendar.MINUTE, (time % 10000) / 100);\n        calendar.set(Calendar.SECOND, time % 100);\n        calendar.set(Calendar.MILLISECOND, 0);\n        return calendar.getTime();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DateValidator dateValidator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DateValidator", "name": "dateValidator", "syntax_pass": true}, {"attribute_expression": "private static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "TimeZone", "name": "GMT = TimeZone.getTimeZone(\"GMT\")", "syntax_pass": true}, {"attribute_expression": "private static final TimeZone EST = TimeZone.getTimeZone(\"EST\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "TimeZone", "name": "EST = TimeZone.getTimeZone(\"EST\")", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/CodeValidatorTest.java.CodeValidatorTest", "name": "CodeValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/CodeValidatorTest.java", "superclasses": "", "methods": ["[void]testCheckDigit()", "[void]testConstructors()", "[void]testLength()", "[void]testNoInput()", "[void]testRegex()", "[void]testValidator294Part1()", "[void]testValidator294Part2()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nCodeValidatorTest.java.\n", "original_string": "public class CodeValidatorTest {\n\n    /**\n     * Test Check Digit.\n     */\n    @Test\n    public void testCheckDigit() {\n        CodeValidator validator = new CodeValidator((String) null, -1, -1, (CheckDigit) null);\n        final String invalidEAN = \"9781930110992\";\n        final String validEAN = \"9781930110991\";\n\n        // Test no CheckDigit (i.e. null)\n        assertNull(validator.getCheckDigit(), \"No CheckDigit\");\n        assertEquals(invalidEAN, validator.validate(invalidEAN), \"No CheckDigit invalid\");\n        assertEquals(validEAN, validator.validate(validEAN), \"No CheckDigit valid\");\n        assertTrue(validator.isValid(invalidEAN), \"No CheckDigit (is) invalid\");\n        assertTrue(validator.isValid(validEAN), \"No CheckDigit (is) valid\");\n\n        // Use the EAN-13 check digit routine\n        validator = new CodeValidator((String) null, -1, EAN13CheckDigit.EAN13_CHECK_DIGIT);\n\n        assertNotNull(validator.getCheckDigit(), \"EAN CheckDigit\");\n        assertNull(validator.validate(invalidEAN), \"EAN CheckDigit invalid\");\n        assertEquals(validEAN, validator.validate(validEAN), \"EAN CheckDigit valid\");\n        assertFalse(validator.isValid(invalidEAN), \"EAN CheckDigit (is) invalid\");\n        assertTrue(validator.isValid(validEAN), \"EAN CheckDigit (is) valid\");\n        assertNull(validator.validate(\"978193011099X\"), \"EAN CheckDigit ex\");\n    }\n\n    /**\n     * Test Regular Expression.\n     */\n    @Test\n    public void testConstructors() {\n        CodeValidator validator;\n        final RegexValidator regex = new RegexValidator(\"^[0-9]*$\");\n\n        // Constructor 1\n        validator = new CodeValidator(regex, EAN13CheckDigit.EAN13_CHECK_DIGIT);\n        assertEquals(regex, validator.getRegexValidator(), \"Constructor 1 - regex\");\n        assertEquals(-1, validator.getMinLength(), \"Constructor 1 - min length\");\n        assertEquals(-1, validator.getMaxLength(), \"Constructor 1 - max length\");\n        assertEquals(EAN13CheckDigit.EAN13_CHECK_DIGIT, validator.getCheckDigit(), \"Constructor 1 - check digit\");\n\n        // Constructor 2\n        validator = new CodeValidator(regex, 13, EAN13CheckDigit.EAN13_CHECK_DIGIT);\n        assertEquals(regex, validator.getRegexValidator(), \"Constructor 2 - regex\");\n        assertEquals(13, validator.getMinLength(), \"Constructor 2 - min length\");\n        assertEquals(13, validator.getMaxLength(), \"Constructor 2 - max length\");\n        assertEquals(EAN13CheckDigit.EAN13_CHECK_DIGIT, validator.getCheckDigit(), \"Constructor 2 - check digit\");\n\n        // Constructor 3\n        validator = new CodeValidator(regex, 10, 20, EAN13CheckDigit.EAN13_CHECK_DIGIT);\n        assertEquals(regex, validator.getRegexValidator(), \"Constructor 3 - regex\");\n        assertEquals(10, validator.getMinLength(), \"Constructor 3 - min length\");\n        assertEquals(20, validator.getMaxLength(), \"Constructor 3 - max length\");\n        assertEquals(EAN13CheckDigit.EAN13_CHECK_DIGIT, validator.getCheckDigit(), \"Constructor 3 - check digit\");\n\n        // Constructor 4\n        validator = new CodeValidator(\"^[0-9]*$\", EAN13CheckDigit.EAN13_CHECK_DIGIT);\n        assertEquals(validator.getRegexValidator().toString(), \"RegexValidator{^[0-9]*$}\", \"Constructor 4 - regex\");\n        assertEquals(-1, validator.getMinLength(), \"Constructor 4 - min length\");\n        assertEquals(-1, validator.getMaxLength(), \"Constructor 4 - max length\");\n        assertEquals(EAN13CheckDigit.EAN13_CHECK_DIGIT, validator.getCheckDigit(), \"Constructor 4 - check digit\");\n\n        // Constructor 5\n        validator = new CodeValidator(\"^[0-9]*$\", 13, EAN13CheckDigit.EAN13_CHECK_DIGIT);\n        assertEquals(validator.getRegexValidator().toString(), \"RegexValidator{^[0-9]*$}\", \"Constructor 5 - regex\");\n        assertEquals(13, validator.getMinLength(), \"Constructor 5 - min length\");\n        assertEquals(13, validator.getMaxLength(), \"Constructor 5 - max length\");\n        assertEquals(EAN13CheckDigit.EAN13_CHECK_DIGIT, validator.getCheckDigit(), \"Constructor 5 - check digit\");\n\n        // Constructor 6\n        validator = new CodeValidator(\"^[0-9]*$\", 10, 20, EAN13CheckDigit.EAN13_CHECK_DIGIT);\n        assertEquals(validator.getRegexValidator().toString(), \"RegexValidator{^[0-9]*$}\", \"Constructor 6 - regex\");\n        assertEquals(10, validator.getMinLength(), \"Constructor 6 - min length\");\n        assertEquals(20, validator.getMaxLength(), \"Constructor 6 - max length\");\n        assertEquals(EAN13CheckDigit.EAN13_CHECK_DIGIT, validator.getCheckDigit(), \"Constructor 6 - check digit\");\n    }\n\n    /**\n     * Test the minimum/maximum length\n     */\n    @Test\n    public void testLength() {\n        CodeValidator validator = new CodeValidator((String) null, -1, -1, (CheckDigit) null);\n        final String length10 = \"1234567890\";\n        final String length11 = \"12345678901\";\n        final String length12 = \"123456789012\";\n        final String length20 = \"12345678901234567890\";\n        final String length21 = \"123456789012345678901\";\n        final String length22 = \"1234567890123456789012\";\n\n        assertEquals(-1, validator.getMinLength(), \"No min\");\n        assertEquals(-1, validator.getMaxLength(), \"No max\");\n\n        assertEquals(length10, validator.validate(length10), \"No Length 10\");\n        assertEquals(length11, validator.validate(length11), \"No Length 11\");\n        assertEquals(length12, validator.validate(length12), \"No Length 12\");\n        assertEquals(length20, validator.validate(length20), \"No Length 20\");\n        assertEquals(length21, validator.validate(length21), \"No Length 21\");\n        assertEquals(length22, validator.validate(length22), \"No Length 22\");\n\n        validator = new CodeValidator((String) null, 11, -1, (CheckDigit) null);\n        assertEquals(11, validator.getMinLength(), \"Min 11 - min\");\n        assertEquals(-1, validator.getMaxLength(), \"Min 11 - max\");\n        assertNull(validator.validate(length10), \"Min 11 - 10\");\n        assertEquals(length11, validator.validate(length11), \"Min 11 - 11\");\n        assertEquals(length12, validator.validate(length12), \"Min 11 - 12\");\n        assertEquals(length20, validator.validate(length20), \"Min 11 - 20\");\n        assertEquals(length21, validator.validate(length21), \"Min 11 - 21\");\n        assertEquals(length22, validator.validate(length22), \"Min 11 - 22\");\n\n        validator = new CodeValidator((String) null, -1, 21, (CheckDigit) null);\n        assertEquals(-1, validator.getMinLength(), \"Max 21 - min\");\n        assertEquals(21, validator.getMaxLength(), \"Max 21 - max\");\n        assertEquals(length10, validator.validate(length10), \"Max 21 - 10\");\n        assertEquals(length11, validator.validate(length11), \"Max 21 - 11\");\n        assertEquals(length12, validator.validate(length12), \"Max 21 - 12\");\n        assertEquals(length20, validator.validate(length20), \"Max 21 - 20\");\n        assertEquals(length21, validator.validate(length21), \"Max 21 - 21\");\n        assertNull(validator.validate(length22), \"Max 21 - 22\");\n\n        validator = new CodeValidator((String) null, 11, 21, (CheckDigit) null);\n        assertEquals(11, validator.getMinLength(), \"Min 11 / Max 21 - min\");\n        assertEquals(21, validator.getMaxLength(), \"Min 11 / Max 21 - max\");\n        assertNull(validator.validate(length10), \"Min 11 / Max 21 - 10\");\n        assertEquals(length11, validator.validate(length11), \"Min 11 / Max 21 - 11\");\n        assertEquals(length12, validator.validate(length12), \"Min 11 / Max 21 - 12\");\n        assertEquals(length20, validator.validate(length20), \"Min 11 / Max 21 - 20\");\n        assertEquals(length21, validator.validate(length21), \"Min 11 / Max 21 - 21\");\n        assertNull(validator.validate(length22), \"Min 11 / Max 21 - 22\");\n\n        validator = new CodeValidator((String) null, 11, 11, (CheckDigit) null);\n        assertEquals(11, validator.getMinLength(), \"Exact 11 - min\");\n        assertEquals(11, validator.getMaxLength(), \"Exact 11 - max\");\n        assertNull(validator.validate(length10), \"Exact 11 - 10\");\n        assertEquals(length11, validator.validate(length11), \"Exact 11 - 11\");\n        assertNull(validator.validate(length12), \"Exact 11 - 12\");\n    }\n\n    /**\n     * Test Regular Expression.\n     */\n    @Test\n    public void testNoInput() {\n        final CodeValidator validator = new CodeValidator((String) null, -1, -1, (CheckDigit) null);\n        assertNull(validator.validate(null), \"Null\");\n        assertNull(validator.validate(\"\"), \"Zero Length\");\n        assertNull(validator.validate(\"   \"), \"Spaces\");\n        assertEquals(validator.validate(\" A  \"), \"A\", \"Trimmed\");\n    }\n\n    /**\n     * Test Regular Expression.\n     */\n    @Test\n    public void testRegex() {\n        CodeValidator validator = new CodeValidator((String) null, -1, -1, (CheckDigit) null);\n\n        final String value2 = \"12\";\n        final String value3 = \"123\";\n        final String value4 = \"1234\";\n        final String value5 = \"12345\";\n        final String invalid = \"12a4\";\n\n        // No Regular Expression\n        assertNull(validator.getRegexValidator(), \"No Regex\");\n        assertEquals(value2, validator.validate(value2), \"No Regex 2\");\n        assertEquals(value3, validator.validate(value3), \"No Regex 3\");\n        assertEquals(value4, validator.validate(value4), \"No Regex 4\");\n        assertEquals(value5, validator.validate(value5), \"No Regex 5\");\n        assertEquals(invalid, validator.validate(invalid), \"No Regex invalid\");\n\n        // Regular Expression\n        String regex = \"^([0-9]{3,4})$\";\n        validator = new CodeValidator(regex, -1, -1, (CheckDigit) null);\n        assertNotNull(validator.getRegexValidator(), \"No Regex\");\n        assertNull(validator.validate(value2), \"Regex 2\");\n        assertEquals(value3, validator.validate(value3), \"Regex 3\");\n        assertEquals(value4, validator.validate(value4), \"Regex 4\");\n        assertNull(validator.validate(value5), \"Regex 5\");\n        assertNull(validator.validate(invalid), \"Regex invalid\");\n\n        // Reformatted\n        regex = \"^([0-9]{3})(?:[-\\\\s])([0-9]{3})$\";\n        validator = new CodeValidator(new RegexValidator(regex), 6, (CheckDigit) null);\n        assertEquals(validator.validate(\"123-456\"), \"123456\", \"Reformat 123-456\");\n        assertEquals(validator.validate(\"123 456\"), \"123456\", \"Reformat 123 456\");\n        assertNull(validator.validate(\"123456\"), \"Reformat 123456\");\n        assertNull(validator.validate(\"123.456\"), \"Reformat 123.456\");\n\n        regex = \"^(?:([0-9]{3})(?:[-\\\\s])([0-9]{3}))|([0-9]{6})$\";\n        validator = new CodeValidator(new RegexValidator(regex), 6, (CheckDigit) null);\n        assertEquals(validator.getRegexValidator().toString(), \"RegexValidator{\" + regex + \"}\", \"Reformat 2 Regex\");\n        assertEquals(validator.validate(\"123-456\"), \"123456\", \"Reformat 2 123-456\");\n        assertEquals(validator.validate(\"123 456\"), \"123456\", \"Reformat 2 123 456\");\n        assertEquals(validator.validate(\"123456\"), \"123456\", \"Reformat 2 123456\");\n\n    }\n\n    @Test\n    public void testValidator294Part1() {\n        CodeValidator validator = new CodeValidator((String) null, 0, -1, (CheckDigit) null);\n        assertNull(validator.validate(null), \"Null\");\n        validator = new CodeValidator((String) null, -1, 0, (CheckDigit) null);\n        assertNull(validator.validate(null), \"Null\");\n    }\n\n    @Test\n    public void testValidator294Part2() {\n        final CodeValidator validator = new CodeValidator((String) null, -1, 0, (CheckDigit) null);\n        assertNull(validator.validate(null), \"Null\");\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/routines/LongValidatorTest.java.LongValidatorTest", "name": "LongValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/LongValidatorTest.java", "superclasses": "AbstractNumberValidatorTest", "methods": ["[void]testLongRangeMinMax()", "[void]testLongValidatorMethods()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/LongValidatorTest.java.LongValidatorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTest Case for LongValidator.\n", "original_string": "public class LongValidatorTest extends AbstractNumberValidatorTest {\n\n    private static final Long LONG_MIN_VAL = Long.valueOf(Long.MIN_VALUE);\n    private static final Long LONG_MAX_VAL = Long.valueOf(Long.MAX_VALUE);\n    private static final String LONG_MAX = \"9223372036854775807\";\n    private static final String LONG_MAX_0 = \"9223372036854775807.99999999999999999999999\"; // force double rounding\n    private static final String LONG_MAX_1 = \"9223372036854775808\";\n    private static final String LONG_MIN = \"-9223372036854775808\";\n    private static final String LONG_MIN_0 = \"-9223372036854775808.99999999999999999999999\"; // force double rounding\n    private static final String LONG_MIN_1 = \"-9223372036854775809\";\n\n    private static final String NINES = \"9999999999999999999999999999999999999\";\n\n    @Override\n    @BeforeEach\n    protected void setUp() {\n        super.setUp();\n\n        validator = new LongValidator(false, 0);\n        strictValidator = new LongValidator();\n\n        testPattern = \"#,###\";\n\n        // testValidateMinMax()\n        max = null;\n        maxPlusOne = null;\n        min = null;\n        minMinusOne = null;\n\n        // testInvalidStrict()\n        invalidStrict = new String[] { null, \"\", \"X\", \"X12\", \"12X\", \"1X2\", \"1.2\", LONG_MAX_1, LONG_MIN_1, NINES };\n\n        // testInvalidNotStrict()\n        invalid = new String[] { null, \"\", \"X\", \"X12\", \"\", LONG_MAX_1, LONG_MIN_1, NINES };\n\n        // testValid()\n        testNumber = Long.valueOf(1234);\n        testZero = Long.valueOf(0);\n        validStrict = new String[] { \"0\", \"1234\", \"1,234\", LONG_MAX, LONG_MIN };\n        validStrictCompare = new Number[] { testZero, testNumber, testNumber, LONG_MAX_VAL, LONG_MIN_VAL };\n        valid = new String[] { \"0\", \"1234\", \"1,234\", \"1,234.5\", \"1234X\", LONG_MAX, LONG_MIN, LONG_MAX_0, LONG_MIN_0 };\n        validCompare = new Number[] { testZero, testNumber, testNumber, testNumber, testNumber, LONG_MAX_VAL, LONG_MIN_VAL, LONG_MAX_VAL, LONG_MIN_VAL };\n\n        testStringUS = \"1,234\";\n        testStringDE = \"1.234\";\n\n        // Localized Pattern test\n        localeValue = testStringDE;\n        localePattern = \"#.###\";\n        testLocale = Locale.GERMANY;\n        localeExpected = testNumber;\n\n    }\n\n    /**\n     * Test Long Range/Min/Max\n     */\n    @Test\n    public void testLongRangeMinMax() {\n        final LongValidator validator = (LongValidator) strictValidator;\n        final Long number9 = validator.validate(\"9\", \"#\");\n        final Long number10 = validator.validate(\"10\", \"#\");\n        final Long number11 = validator.validate(\"11\", \"#\");\n        final Long number19 = validator.validate(\"19\", \"#\");\n        final Long number20 = validator.validate(\"20\", \"#\");\n        final Long number21 = validator.validate(\"21\", \"#\");\n\n        // Test isInRange()\n        assertFalse(validator.isInRange(number9, 10, 20), \"isInRange() < min\");\n        assertTrue(validator.isInRange(number10, 10, 20), \"isInRange() = min\");\n        assertTrue(validator.isInRange(number11, 10, 20), \"isInRange() in range\");\n        assertTrue(validator.isInRange(number20, 10, 20), \"isInRange() = max\");\n        assertFalse(validator.isInRange(number21, 10, 20), \"isInRange() > max\");\n\n        // Test minValue()\n        assertFalse(validator.minValue(number9, 10), \"minValue() < min\");\n        assertTrue(validator.minValue(number10, 10), \"minValue() = min\");\n        assertTrue(validator.minValue(number11, 10), \"minValue() > min\");\n\n        // Test minValue()\n        assertTrue(validator.maxValue(number19, 20), \"maxValue() < max\");\n        assertTrue(validator.maxValue(number20, 20), \"maxValue() = max\");\n        assertFalse(validator.maxValue(number21, 20), \"maxValue() > max\");\n    }\n\n    /**\n     * Test LongValidator validate Methods\n     */\n    @Test\n    public void testLongValidatorMethods() {\n        final Locale locale = Locale.GERMAN;\n        final String pattern = \"0,00,00\";\n        final String patternVal = \"1,23,45\";\n        final String germanPatternVal = \"1.23.45\";\n        final String localeVal = \"12.345\";\n        final String defaultVal = \"12,345\";\n        final String xxxx = \"XXXX\";\n        final Long expected = Long.valueOf(12345);\n        assertEquals(expected, LongValidator.getInstance().validate(defaultVal), \"validate(A) default\");\n        assertEquals(expected, LongValidator.getInstance().validate(localeVal, locale), \"validate(A) locale\");\n        assertEquals(expected, LongValidator.getInstance().validate(patternVal, pattern), \"validate(A) pattern\");\n        assertEquals(expected, LongValidator.getInstance().validate(germanPatternVal, pattern, Locale.GERMAN), \"validate(A) both\");\n\n        assertTrue(LongValidator.getInstance().isValid(defaultVal), \"isValid(A) default\");\n        assertTrue(LongValidator.getInstance().isValid(localeVal, locale), \"isValid(A) locale\");\n        assertTrue(LongValidator.getInstance().isValid(patternVal, pattern), \"isValid(A) pattern\");\n        assertTrue(LongValidator.getInstance().isValid(germanPatternVal, pattern, Locale.GERMAN), \"isValid(A) both\");\n\n        assertNull(LongValidator.getInstance().validate(xxxx), \"validate(B) default\");\n        assertNull(LongValidator.getInstance().validate(xxxx, locale), \"validate(B) locale\");\n        assertNull(LongValidator.getInstance().validate(xxxx, pattern), \"validate(B) pattern\");\n        assertNull(LongValidator.getInstance().validate(patternVal, pattern, Locale.GERMAN), \"validate(B) both\");\n\n        assertFalse(LongValidator.getInstance().isValid(xxxx), \"isValid(B) default\");\n        assertFalse(LongValidator.getInstance().isValid(xxxx, locale), \"isValid(B) locale\");\n        assertFalse(LongValidator.getInstance().isValid(xxxx, pattern), \"isValid(B) pattern\");\n        assertFalse(LongValidator.getInstance().isValid(patternVal, pattern, Locale.GERMAN), \"isValid(B) both\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Long LONG_MIN_VAL = Long.valueOf(Long.MIN_VALUE);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Long", "name": "LONG_MIN_VAL = Long.valueOf(Long.MIN_VALUE)", "syntax_pass": true}, {"attribute_expression": "private static final Long LONG_MAX_VAL = Long.valueOf(Long.MAX_VALUE);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Long", "name": "LONG_MAX_VAL = Long.valueOf(Long.MAX_VALUE)", "syntax_pass": true}, {"attribute_expression": "private static final String LONG_MAX = \"9223372036854775807\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "LONG_MAX = \"9223372036854775807\"", "syntax_pass": true}, {"attribute_expression": "private static final String LONG_MAX_0 = \"9223372036854775807.99999999999999999999999\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "LONG_MAX_0 = \"9223372036854775807.99999999999999999999999\"", "syntax_pass": true}, {"attribute_expression": "private static final String LONG_MAX_1 = \"9223372036854775808\";", "docstring": " force double rounding", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "LONG_MAX_1 = \"9223372036854775808\"", "syntax_pass": true}, {"attribute_expression": "private static final String LONG_MIN = \"-9223372036854775808\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "LONG_MIN = \"-9223372036854775808\"", "syntax_pass": true}, {"attribute_expression": "private static final String LONG_MIN_0 = \"-9223372036854775808.99999999999999999999999\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "LONG_MIN_0 = \"-9223372036854775808.99999999999999999999999\"", "syntax_pass": true}, {"attribute_expression": "private static final String LONG_MIN_1 = \"-9223372036854775809\";", "docstring": " force double rounding", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "LONG_MIN_1 = \"-9223372036854775809\"", "syntax_pass": true}, {"attribute_expression": "private static final String NINES = \"9999999999999999999999999999999999999\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "NINES = \"9999999999999999999999999999999999999\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/EmailValidatorTest.java.EmailValidatorTest", "name": "EmailValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/EmailValidatorTest.java", "superclasses": "", "methods": ["[void]testEmail()", "[void]testEmailAtTLD()", "[void]testEmailExtension()", "[void]testEmailFromPerl()", "[void]testEmailLocalhost()", "[void]testEmailUserName()", "[void]testEmailWithBogusCharacter()", "[void]testEmailWithCommas()", "[void]testEmailWithControlChars()", "[void]testEmailWithDash()", "[void]testEmailWithDotEnd()", "[void]testEmailWithNumericAddress()", "[void]testEmailWithSlashes()", "[void]testEmailWithSpaces()", "[void]testValidator235()", "[void]testValidator278()", "[void]testValidator293()", "[void]testValidator315()", "[void]testValidator359()", "[void]testValidator365()", "[void]testValidator374()", "[void]testValidator473Part1()", "[void]testValidator473Part2()", "[void]testValidator473Part3()", "[void]testValidator473Part4()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/EmailValidatorTest.java.EmailValidatorTest.[void]main(String[])", "src/test/java/org/apache/commons/validator/routines/EmailValidatorTest.java.EmailValidatorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nPerforms Validation Test for e-mail validations.\n", "original_string": "public class EmailValidatorTest {\n\n    /**\n     * The key used to retrieve the set of validation rules from the xml file.\n     */\n    protected static final String FORM_KEY = \"emailForm\";\n\n    /**\n     * The key used to retrieve the validator action.\n     */\n    protected static final String ACTION = \"email\";\n\n    /**\n     * These test values derive directly from RFC 822 & Mail::RFC822::Address & RFC::RFC822::Address perl test.pl For traceability don't combine these test\n     * values with other tests.\n     */\n    private static final ResultPair[] TEST_EMAIL_FROM_PERL = {\n        // @formatter:off\n        new ResultPair(\"abigail@example.com\", true),\n        new ResultPair(\"abigail@example.com \", true),\n        new ResultPair(\" abigail@example.com\", true),\n        new ResultPair(\"abigail @example.com \", true),\n        new ResultPair(\"*@example.net\", true),\n        new ResultPair(\"\\\"\\\\\\\"\\\"@foo.bar\", true),\n        new ResultPair(\"fred&barny@example.com\", true),\n        new ResultPair(\"---@example.com\", true),\n        new ResultPair(\"foo-bar@example.net\", true),\n        new ResultPair(\"\\\"127.0.0.1\\\"@[127.0.0.1]\", true),\n        new ResultPair(\"Abigail <abigail@example.com>\", true),\n        new ResultPair(\"Abigail<abigail@example.com>\", true),\n        new ResultPair(\"Abigail<@a,@b,@c:abigail@example.com>\", true),\n        new ResultPair(\"\\\"This is a phrase\\\"<abigail@example.com>\", true),\n        new ResultPair(\"\\\"Abigail \\\"<abigail@example.com>\", true),\n        new ResultPair(\"\\\"Joe & J. Harvey\\\" <example @Org>\", true),\n        new ResultPair(\"Abigail <abigail @ example.com>\", true),\n        new ResultPair(\"Abigail made this <  abigail   @   example  .    com    >\", true),\n        new ResultPair(\"Abigail(the bitch)@example.com\", true),\n        new ResultPair(\"Abigail <abigail @ example . (bar) com >\", true),\n        new ResultPair(\"Abigail < (one)  abigail (two) @(three) example . (bar) com (quz) >\", true),\n        new ResultPair(\"Abigail (foo) (((baz)(nested) (comment)) ! ) < (one)  abigail (two) @(three) example . (bar) com (quz) >\", true),\n        new ResultPair(\"Abigail <abigail(fo\\\\(o)@example.com>\", true),\n        new ResultPair(\"Abigail <abigail(fo\\\\)o)@example.com> \", true),\n        new ResultPair(\"(foo) abigail@example.com\", true),\n        new ResultPair(\"abigail@example.com (foo)\", true),\n        new ResultPair(\"\\\"Abi\\\\\\\"gail\\\" <abigail@example.com>\", true),\n        new ResultPair(\"abigail@[example.com]\", true),\n        new ResultPair(\"abigail@[exa\\\\[ple.com]\", true),\n        new ResultPair(\"abigail@[exa\\\\]ple.com]\", true),\n        new ResultPair(\"\\\":sysmail\\\"@  Some-Group. Some-Org\", true),\n        new ResultPair(\"Muhammed.(I am  the greatest) Ali @(the) Vegas.WBA\", true),\n        new ResultPair(\"mailbox.sub1.sub2@this-domain\", true),\n        new ResultPair(\"sub-net.mailbox@sub-domain.domain\", true),\n        new ResultPair(\"name:;\", true),\n        new ResultPair(\"':;\", true),\n        new ResultPair(\"name:   ;\", true),\n        new ResultPair(\"Alfred Neuman <Neuman@BBN-TENEXA>\", true),\n        new ResultPair(\"Neuman@BBN-TENEXA\", true),\n        new ResultPair(\"\\\"George, Ted\\\" <Shared@Group.Arpanet>\", true),\n        new ResultPair(\"Wilt . (the  Stilt) Chamberlain@NBA.US\", true),\n        new ResultPair(\"Cruisers:  Port@Portugal, Jones@SEA;\", true),\n        new ResultPair(\"$@[]\", true),\n        new ResultPair(\"*()@[]\", true),\n        new ResultPair(\"\\\"quoted ( brackets\\\" ( a comment )@example.com\", true),\n        new ResultPair(\"\\\"Joe & J. Harvey\\\"\\\\x0D\\\\x0A     <ddd\\\\@ Org>\", true),\n        new ResultPair(\"\\\"Joe &\\\\x0D\\\\x0A J. Harvey\\\" <ddd \\\\@ Org>\", true),\n        new ResultPair(\"Gourmets:  Pompous Person <WhoZiWhatZit\\\\@Cordon-Bleu>,\\\\x0D\\\\x0A\" +\n            \"        Childs\\\\@WGBH.Boston, \\\"Galloping Gourmet\\\"\\\\@\\\\x0D\\\\x0A\" +\n            \"        ANT.Down-Under (Australian National Television),\\\\x0D\\\\x0A\" +\n            \"        Cheapie\\\\@Discount-Liquors;\", true),\n        new ResultPair(\"   Just a string\", false),\n        new ResultPair(\"string\", false),\n        new ResultPair(\"(comment)\", false),\n        new ResultPair(\"()@example.com\", false),\n        new ResultPair(\"fred(&)barny@example.com\", false),\n        new ResultPair(\"fred\\\\ barny@example.com\", false),\n        new ResultPair(\"Abigail <abi gail @ example.com>\", false),\n        new ResultPair(\"Abigail <abigail(fo(o)@example.com>\", false),\n        new ResultPair(\"Abigail <abigail(fo) o)@example.com>\", false),\n        new ResultPair(\"\\\"Abi\\\"gail\\\" <abigail@example.com>\", false),\n        new ResultPair(\"abigail@[exa]ple.com]\", false),\n        new ResultPair(\"abigail@[exa[ple.com]\", false),\n        new ResultPair(\"abigail@[exaple].com]\", false),\n        new ResultPair(\"abigail@\", false),\n        new ResultPair(\"@example.com\", false),\n        new ResultPair(\"phrase: abigail@example.com abigail@example.com ;\", false),\n        new ResultPair(\"invalid\ufffdchar@example.com\", false)\n    // @formatter:on\n    };\n\n    public static void main(final String[] args) {\n        final EmailValidator validator = EmailValidator.getInstance();\n        for (final String arg : args) {\n            System.out.printf(\"%s: %s%n\", arg, validator.isValid(arg));\n        }\n    }\n\n    private EmailValidator validator;\n\n    @BeforeEach\n    public void setUp() {\n        validator = EmailValidator.getInstance();\n    }\n\n    /**\n     * Tests the e-mail validation.\n     */\n    @Test\n    public void testEmail() {\n        assertTrue(validator.isValid(\"jsmith@apache.org\"));\n    }\n\n    /**\n     * Tests the e-mail validation with a user at a TLD\n     *\n     * https://tools.ietf.org/html/rfc5321#section-2.3.5 (In the case of a top-level domain used by itself in an email address, a single string is used without\n     * any dots)\n     */\n    @Test\n    public void testEmailAtTLD() {\n        final EmailValidator val = EmailValidator.getInstance(false, true);\n        assertTrue(val.isValid(\"test@com\"));\n    }\n\n    /**\n     * Tests the e-mail validation.\n     */\n    @Test\n    public void testEmailExtension() {\n        assertTrue(validator.isValid(\"jsmith@apache.org\"));\n\n        assertTrue(validator.isValid(\"jsmith@apache.com\"));\n\n        assertTrue(validator.isValid(\"jsmith@apache.net\"));\n\n        assertTrue(validator.isValid(\"jsmith@apache.info\"));\n\n        assertFalse(validator.isValid(\"jsmith@apache.\"));\n\n        assertFalse(validator.isValid(\"jsmith@apache.c\"));\n\n        assertTrue(validator.isValid(\"someone@yahoo.museum\"));\n\n        assertFalse(validator.isValid(\"someone@yahoo.mu-seum\"));\n    }\n\n    /**\n     * Write this test based on perl Mail::RFC822::Address which takes its example email address directly from RFC822\n     *\n     * This test fails so disable it The real solution is to fix the email parsing.\n     */\n    @Disabled(\"VALIDATOR-267\")\n    @Test\n    public void testEmailFromPerl() {\n        int errors = 0;\n        for (final ResultPair element : TEST_EMAIL_FROM_PERL) {\n            final String item = element.item;\n            final boolean exp = element.valid;\n            final boolean act = validator.isValid(item);\n            if (act != exp) {\n                System.out.printf(\"%s: expected %s actual %s%n\", item, exp, act);\n                errors += 1;\n            }\n        }\n        assertEquals(0, errors, \"Expected 0 errors\");\n    }\n\n    /**\n     * Test that @localhost and @localhost.localdomain addresses are declared as valid when requested.\n     */\n    @Test\n    public void testEmailLocalhost() {\n        // Check the default is not to allow\n        final EmailValidator noLocal = EmailValidator.getInstance(false);\n        final EmailValidator allowLocal = EmailValidator.getInstance(true);\n        assertEquals(validator, noLocal);\n\n        // Depends on the validator\n        assertTrue(allowLocal.isValid(\"joe@localhost.localdomain\"), \"@localhost.localdomain should be accepted but wasn't\");\n        assertTrue(allowLocal.isValid(\"joe@localhost\"), \"@localhost should be accepted but wasn't\");\n\n        assertFalse(noLocal.isValid(\"joe@localhost.localdomain\"), \"@localhost.localdomain should be accepted but wasn't\");\n        assertFalse(noLocal.isValid(\"joe@localhost\"), \"@localhost should be accepted but wasn't\");\n    }\n\n    /**\n     * Write this test according to parts of RFC, as opposed to the type of character that is being tested.\n     */\n    @Test\n    public void testEmailUserName() {\n\n        assertTrue(validator.isValid(\"joe1blow@apache.org\"));\n\n        assertTrue(validator.isValid(\"joe$blow@apache.org\"));\n\n        assertTrue(validator.isValid(\"joe-@apache.org\"));\n\n        assertTrue(validator.isValid(\"joe_@apache.org\"));\n\n        assertTrue(validator.isValid(\"joe+@apache.org\")); // + is valid unquoted\n\n        assertTrue(validator.isValid(\"joe!@apache.org\")); // ! is valid unquoted\n\n        assertTrue(validator.isValid(\"joe*@apache.org\")); // * is valid unquoted\n\n        assertTrue(validator.isValid(\"joe'@apache.org\")); // ' is valid unquoted\n\n        assertTrue(validator.isValid(\"joe%45@apache.org\")); // % is valid unquoted\n\n        assertTrue(validator.isValid(\"joe?@apache.org\")); // ? is valid unquoted\n\n        assertTrue(validator.isValid(\"joe&@apache.org\")); // & ditto\n\n        assertTrue(validator.isValid(\"joe=@apache.org\")); // = ditto\n\n        assertTrue(validator.isValid(\"+joe@apache.org\")); // + is valid unquoted\n\n        assertTrue(validator.isValid(\"!joe@apache.org\")); // ! is valid unquoted\n\n        assertTrue(validator.isValid(\"*joe@apache.org\")); // * is valid unquoted\n\n        assertTrue(validator.isValid(\"'joe@apache.org\")); // ' is valid unquoted\n\n        assertTrue(validator.isValid(\"%joe45@apache.org\")); // % is valid unquoted\n\n        assertTrue(validator.isValid(\"?joe@apache.org\")); // ? is valid unquoted\n\n        assertTrue(validator.isValid(\"&joe@apache.org\")); // & ditto\n\n        assertTrue(validator.isValid(\"=joe@apache.org\")); // = ditto\n\n        assertTrue(validator.isValid(\"+@apache.org\")); // + is valid unquoted\n\n        assertTrue(validator.isValid(\"!@apache.org\")); // ! is valid unquoted\n\n        assertTrue(validator.isValid(\"*@apache.org\")); // * is valid unquoted\n\n        assertTrue(validator.isValid(\"'@apache.org\")); // ' is valid unquoted\n\n        assertTrue(validator.isValid(\"%@apache.org\")); // % is valid unquoted\n\n        assertTrue(validator.isValid(\"?@apache.org\")); // ? is valid unquoted\n\n        assertTrue(validator.isValid(\"&@apache.org\")); // & ditto\n\n        assertTrue(validator.isValid(\"=@apache.org\")); // = ditto\n\n        // UnQuoted Special characters are invalid\n\n        assertFalse(validator.isValid(\"joe.@apache.org\")); // . not allowed at end of local part\n\n        assertFalse(validator.isValid(\".joe@apache.org\")); // . not allowed at start of local part\n\n        assertFalse(validator.isValid(\".@apache.org\")); // . not allowed alone\n\n        assertTrue(validator.isValid(\"joe.ok@apache.org\")); // . allowed embedded\n\n        assertFalse(validator.isValid(\"joe..ok@apache.org\")); // .. not allowed embedded\n\n        assertFalse(validator.isValid(\"..@apache.org\")); // .. not allowed alone\n\n        assertFalse(validator.isValid(\"joe(@apache.org\"));\n\n        assertFalse(validator.isValid(\"joe)@apache.org\"));\n\n        assertFalse(validator.isValid(\"joe,@apache.org\"));\n\n        assertFalse(validator.isValid(\"joe;@apache.org\"));\n\n        // Quoted Special characters are valid\n        assertTrue(validator.isValid(\"\\\"joe.\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\".joe\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\"joe+\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\"joe@\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\"joe!\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\"joe*\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\"joe'\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\"joe(\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\"joe)\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\"joe,\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\"joe%45\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\"joe;\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\"joe?\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\"joe&\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\"joe=\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\"..\\\"@apache.org\"));\n\n        // escaped quote character valid in quoted string\n        assertTrue(validator.isValid(\"\\\"john\\\\\\\"doe\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"john56789.john56789.john56789.john56789.john56789.john56789.john@example.com\"));\n\n        assertFalse(validator.isValid(\"john56789.john56789.john56789.john56789.john56789.john56789.john5@example.com\"));\n\n        assertTrue(validator.isValid(\"\\\\>escape\\\\\\\\special\\\\^characters\\\\<@example.com\"));\n\n        assertTrue(validator.isValid(\"Abc\\\\@def@example.com\"));\n\n        assertFalse(validator.isValid(\"Abc@def@example.com\"));\n\n        assertTrue(validator.isValid(\"space\\\\ monkey@example.com\"));\n    }\n\n    /**\n     * Tests the e-mail validation with an RCS-noncompliant character in the address.\n     */\n    @Test\n    public void testEmailWithBogusCharacter() {\n\n        assertFalse(validator.isValid(\"andy.noble@\\u008fdata-workshop.com\"));\n\n        // The ' character is valid in an email username.\n        assertTrue(validator.isValid(\"andy.o'reilly@data-workshop.com\"));\n\n        // But not in the domain name.\n        assertFalse(validator.isValid(\"andy@o'reilly.data-workshop.com\"));\n\n        // The + character is valid in an email username.\n        assertTrue(validator.isValid(\"foo+bar@i.am.not.in.us.example.com\"));\n\n        // But not in the domain name\n        assertFalse(validator.isValid(\"foo+bar@example+3.com\"));\n\n        // Domains with only special characters aren't allowed (VALIDATOR-286)\n        assertFalse(validator.isValid(\"test@%*.com\"));\n        assertFalse(validator.isValid(\"test@^&#.com\"));\n\n    }\n\n    /**\n     * Tests the email validation with commas.\n     */\n    @Test\n    public void testEmailWithCommas() {\n        assertFalse(validator.isValid(\"joeblow@apa,che.org\"));\n\n        assertFalse(validator.isValid(\"joeblow@apache.o,rg\"));\n\n        assertFalse(validator.isValid(\"joeblow@apache,org\"));\n\n    }\n\n    /**\n     * Tests the email validation with ASCII control characters. (i.e. ASCII chars 0 - 31 and 127)\n     */\n    @Test\n    public void testEmailWithControlChars() {\n        for (char c = 0; c < 32; c++) {\n            assertFalse(validator.isValid(\"foo\" + c + \"bar@domain.com\"), \"Test control char \" + (int) c);\n        }\n        assertFalse(validator.isValid(\"foo\" + (char) 127 + \"bar@domain.com\"), \"Test control char 127\");\n    }\n\n    /**\n     * <p>\n     * Tests the e-mail validation with a dash in the address.\n     * </p>\n     */\n    @Test\n    public void testEmailWithDash() {\n        assertTrue(validator.isValid(\"andy.noble@data-workshop.com\"));\n\n        assertFalse(validator.isValid(\"andy-noble@data-workshop.-com\"));\n\n        assertFalse(validator.isValid(\"andy-noble@data-workshop.c-om\"));\n\n        assertFalse(validator.isValid(\"andy-noble@data-workshop.co-m\"));\n    }\n\n    /**\n     * Tests the e-mail validation with a dot at the end of the address.\n     */\n    @Test\n    public void testEmailWithDotEnd() {\n        assertFalse(validator.isValid(\"andy.noble@data-workshop.com.\"));\n    }\n\n    /**\n     * Tests the email validation with numeric domains.\n     */\n    @Test\n    public void testEmailWithNumericAddress() {\n        assertTrue(validator.isValid(\"someone@[216.109.118.76]\"));\n        assertTrue(validator.isValid(\"someone@yahoo.com\"));\n    }\n\n    /**\n     * VALIDATOR-296 - A / or a ! is valid in the user part, but not in the domain part\n     */\n    @Test\n    public void testEmailWithSlashes() {\n        assertTrue(validator.isValid(\"joe!/blow@apache.org\"), \"/ and ! valid in username\");\n        assertFalse(validator.isValid(\"joe@ap/ache.org\"), \"/ not valid in domain\");\n        assertFalse(validator.isValid(\"joe@apac!he.org\"), \"! not valid in domain\");\n    }\n\n    /**\n     * Tests the email validation with spaces.\n     */\n    @Test\n    public void testEmailWithSpaces() {\n        assertFalse(validator.isValid(\"joeblow @apache.org\"));\n\n        assertFalse(validator.isValid(\"joeblow@ apache.org\"));\n\n        assertFalse(validator.isValid(\" joeblow@apache.org\"));\n\n        assertFalse(validator.isValid(\"joeblow@apache.org \"));\n\n        assertFalse(validator.isValid(\"joe blow@apache.org \"));\n\n        assertFalse(validator.isValid(\"joeblow@apa che.org \"));\n\n        assertTrue(validator.isValid(\"\\\"joeblow \\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\" joeblow\\\"@apache.org\"));\n\n        assertTrue(validator.isValid(\"\\\" joe blow \\\"@apache.org\"));\n\n    }\n\n    @Test\n    public void testValidator235() {\n        final String version = SystemProperties.getJavaVersion();\n        if (version.compareTo(\"1.6\") < 0) {\n            System.out.println(\"Cannot run Unicode IDN tests\");\n            return; // Cannot run the test\n        }\n        assertTrue(validator.isValid(\"someone@xn--d1abbgf6aiiy.xn--p1ai\"), \"xn--d1abbgf6aiiy.xn--p1ai should validate\");\n        assertTrue(validator.isValid(\"someone@\u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442.\u0440\u0444\"), \"\u043f\u0440\u0435\u0437\u0438\u0434\u0435\u043d\u0442.\u0440\u0444 should validate\");\n        assertTrue(validator.isValid(\"someone@www.b\\u00fccher.ch\"), \"www.b\\u00fccher.ch should validate\");\n        assertFalse(validator.isValid(\"someone@www.\\uFFFD.ch\"), \"www.\\uFFFD.ch FFFD should fail\");\n        assertTrue(validator.isValid(\"someone@www.b\\u00fccher.ch\"), \"www.b\\u00fccher.ch should validate\");\n        assertFalse(validator.isValid(\"someone@www.\\uFFFD.ch\"), \"www.\\uFFFD.ch FFFD should fail\");\n    }\n\n    @Test\n    public void testValidator278() {\n        assertFalse(validator.isValid(\"someone@-test.com\")); // hostname starts with dash/hyphen\n        assertFalse(validator.isValid(\"someone@test-.com\")); // hostname ends with dash/hyphen\n    }\n\n    @Test\n    public void testValidator293() {\n        assertTrue(validator.isValid(\"abc-@abc.com\"));\n        assertTrue(validator.isValid(\"abc_@abc.com\"));\n        assertTrue(validator.isValid(\"abc-def@abc.com\"));\n        assertTrue(validator.isValid(\"abc_def@abc.com\"));\n        assertFalse(validator.isValid(\"abc@abc_def.com\"));\n    }\n\n    @Test\n    public void testValidator315() {\n        assertFalse(validator.isValid(\"me@at&t.net\"));\n        assertTrue(validator.isValid(\"me@att.net\")); // Make sure TLD is not the cause of the failure\n    }\n\n    @Test\n    public void testValidator359() {\n        final EmailValidator val = EmailValidator.getInstance(false, true);\n        assertFalse(val.isValid(\"test@.com\"));\n    }\n\n    @Test\n    public void testValidator365() {\n        assertFalse(validator.isValid(\"Loremipsumdolorsitametconsecteturadipiscingelit.Nullavitaeligulamattisrhoncusnuncegestasmattisleo.\"\n                + \"Donecnonsapieninmagnatristiquedictumaacturpis.Fusceorciduifacilisisutsapieneuconsequatpharetralectus.\"\n                + \"Quisqueenimestpulvinarutquamvitaeportamattisex.Nullamquismaurisplaceratconvallisjustoquisportamauris.\"\n                + \"Innullalacusconvalliseufringillautvenenatissitametdiam.Maecenasluctusligulascelerisquepulvinarfeugiat.\"\n                + \"Sedmolestienullaaliquetorciluctusidpharetranislfinibus.Suspendissemalesuadatinciduntduisitametportaarcusollicitudinnec.\"\n                + \"Donecetmassamagna.Curabitururnadiampretiumveldignissimporttitorfringillaeuneque.\"\n                + \"Duisantetelluspharetraidtinciduntinterdummolestiesitametfelis.Utquisquamsitametantesagittisdapibusacnonodio.\"\n                + \"Namrutrummolestiediamidmattis.Cumsociisnatoquepenatibusetmagnisdisparturientmontesnasceturridiculusmus.\"\n                + \"Morbiposueresedmetusacconsectetur.Etiamquisipsumvitaejustotempusmaximus.Sedultriciesplaceratvolutpat.\"\n                + \"Integerlacuslectusmaximusacornarequissagittissitametjusto.\"\n                + \"Cumsociisnatoquepenatibusetmagnisdisparturientmontesnasceturridiculusmus.Maecenasindictumpurussedrutrumex.Nullafacilisi.\"\n                + \"Integerfinibusfinibusmietpharetranislfaucibusvel.Maecenasegetdolorlacinialobortisjustovelullamcorpersem.\"\n                + \"Vivamusaliquetpurusidvariusornaresapienrisusrutrumnisitinciduntmollissemnequeidmetus.\"\n                + \"Etiamquiseleifendpurus.Nuncfelisnuncscelerisqueiddignissimnecfinibusalibero.\"\n                + \"Nuncsemperenimnequesitamethendreritpurusfacilisisac.Maurisdapibussemperfelisdignissimgravida.\"\n                + \"Aeneanultricesblanditnequealiquamfinibusodioscelerisqueac.Aliquamnecmassaeumaurisfaucibusfringilla.\"\n                + \"Etiamconsequatligulanisisitametaliquamnibhtemporquis.Nuncinterdumdignissimnullaatsodalesarcusagittiseu.\"\n                + \"Proinpharetrametusneclacuspulvinarsedvolutpatliberoornare.Sedligulanislpulvinarnonlectuseublanditfacilisisante.\"\n                + \"Sedmollisnislalacusauctorsuscipit.Inhachabitasseplateadictumst.Phasellussitametvelittemporvenenatisfeliseuegestasrisus.\"\n                + \"Aliquameteratsitametnibhcommodofinibus.Morbiefficiturodiovelpulvinariaculis.\"\n                + \"Aeneantemporipsummassaaconsecteturturpisfaucibusultrices.Praesentsodalesmaurisquisportafermentum.\"\n                + \"Etiamnisinislvenenatisvelauctorutullamcorperinjusto.Proinvelligulaerat.Phasellusvestibulumgravidamassanonfeugiat.\"\n                + \"Maecenaspharetraeuismodmetusegetefficitur.Suspendisseamet@gmail.com\"));\n    }\n\n    @Test\n    public void testValidator374() {\n        assertTrue(validator.isValid(\"abc@school.school\"));\n    }\n\n    @Test\n    public void testValidator473Part1() { // reject null DomainValidator\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class, () -> new EmailValidator(false, false, null));\n        assertEquals(\"DomainValidator cannot be null\", thrown.getMessage());\n    }\n\n    @Test\n    public void testValidator473Part2() { // reject null DomainValidator with mismatched allowLocal\n        final List<DomainValidator.Item> items = new ArrayList<>();\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class,\n                () -> new EmailValidator(false, false, DomainValidator.getInstance(true, items)));\n        assertEquals(\"DomainValidator must agree with allowLocal setting\", thrown.getMessage());\n    }\n\n    @Test\n    public void testValidator473Part3() { // reject null DomainValidator with mismatched allowLocal\n        final List<DomainValidator.Item> items = new ArrayList<>();\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class,\n                () -> new EmailValidator(true, false, DomainValidator.getInstance(false, items)));\n        assertEquals(\"DomainValidator must agree with allowLocal setting\", thrown.getMessage());\n    }\n\n    @Test\n    public void testValidator473Part4() { // Show that can override domain validation\n        assertFalse(validator.isValidDomain(\"test.local\"));\n        final List<DomainValidator.Item> items = new ArrayList<>();\n        items.add(new DomainValidator.Item(DomainValidator.ArrayType.GENERIC_PLUS, \"local\"));\n        final EmailValidator val = new EmailValidator(true, false, DomainValidator.getInstance(true, items));\n        assertTrue(val.isValidDomain(\"test.local\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected static final String FORM_KEY = \"emailForm\";", "docstring": "\nThe key used to retrieve the set of validation rules from the xml file.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "FORM_KEY = \"emailForm\"", "syntax_pass": true}, {"attribute_expression": "protected static final String ACTION = \"email\";", "docstring": "\nThe key used to retrieve the validator action.\n", "modifiers": "protected static final", "marker_annotations": [], "non_marker_annotations": ["protected", "static", "final"], "comments": [], "type": "String", "name": "ACTION = \"email\"", "syntax_pass": true}, {"attribute_expression": "private static final ResultPair[] TEST_EMAIL_FROM_PERL = {\n        // @formatter:off\n        new ResultPair(\"abigail@example.com\", true),\n        new ResultPair(\"abigail@example.com \", true),\n        new ResultPair(\" abigail@example.com\", true),\n        new ResultPair(\"abigail @example.com \", true),\n        new ResultPair(\"*@example.net\", true),\n        new ResultPair(\"\\\"\\\\\\\"\\\"@foo.bar\", true),\n        new ResultPair(\"fred&barny@example.com\", true),\n        new ResultPair(\"---@example.com\", true),\n        new ResultPair(\"foo-bar@example.net\", true),\n        new ResultPair(\"\\\"127.0.0.1\\\"@[127.0.0.1]\", true),\n        new ResultPair(\"Abigail <abigail@example.com>\", true),\n        new ResultPair(\"Abigail<abigail@example.com>\", true),\n        new ResultPair(\"Abigail<@a,@b,@c:abigail@example.com>\", true),\n        new ResultPair(\"\\\"This is a phrase\\\"<abigail@example.com>\", true),\n        new ResultPair(\"\\\"Abigail \\\"<abigail@example.com>\", true),\n        new ResultPair(\"\\\"Joe & J. Harvey\\\" <example @Org>\", true),\n        new ResultPair(\"Abigail <abigail @ example.com>\", true),\n        new ResultPair(\"Abigail made this <  abigail   @   example  .    com    >\", true),\n        new ResultPair(\"Abigail(the bitch)@example.com\", true),\n        new ResultPair(\"Abigail <abigail @ example . (bar) com >\", true),\n        new ResultPair(\"Abigail < (one)  abigail (two) @(three) example . (bar) com (quz) >\", true),\n        new ResultPair(\"Abigail (foo) (((baz)(nested) (comment)) ! ) < (one)  abigail (two) @(three) example . (bar) com (quz) >\", true),\n        new ResultPair(\"Abigail <abigail(fo\\\\(o)@example.com>\", true),\n        new ResultPair(\"Abigail <abigail(fo\\\\)o)@example.com> \", true),\n        new ResultPair(\"(foo) abigail@example.com\", true),\n        new ResultPair(\"abigail@example.com (foo)\", true),\n        new ResultPair(\"\\\"Abi\\\\\\\"gail\\\" <abigail@example.com>\", true),\n        new ResultPair(\"abigail@[example.com]\", true),\n        new ResultPair(\"abigail@[exa\\\\[ple.com]\", true),\n        new ResultPair(\"abigail@[exa\\\\]ple.com]\", true),\n        new ResultPair(\"\\\":sysmail\\\"@  Some-Group. Some-Org\", true),\n        new ResultPair(\"Muhammed.(I am  the greatest) Ali @(the) Vegas.WBA\", true),\n        new ResultPair(\"mailbox.sub1.sub2@this-domain\", true),\n        new ResultPair(\"sub-net.mailbox@sub-domain.domain\", true),\n        new ResultPair(\"name:;\", true),\n        new ResultPair(\"':;\", true),\n        new ResultPair(\"name:   ;\", true),\n        new ResultPair(\"Alfred Neuman <Neuman@BBN-TENEXA>\", true),\n        new ResultPair(\"Neuman@BBN-TENEXA\", true),\n        new ResultPair(\"\\\"George, Ted\\\" <Shared@Group.Arpanet>\", true),\n        new ResultPair(\"Wilt . (the  Stilt) Chamberlain@NBA.US\", true),\n        new ResultPair(\"Cruisers:  Port@Portugal, Jones@SEA;\", true),\n        new ResultPair(\"$@[]\", true),\n        new ResultPair(\"*()@[]\", true),\n        new ResultPair(\"\\\"quoted ( brackets\\\" ( a comment )@example.com\", true),\n        new ResultPair(\"\\\"Joe & J. Harvey\\\"\\\\x0D\\\\x0A     <ddd\\\\@ Org>\", true),\n        new ResultPair(\"\\\"Joe &\\\\x0D\\\\x0A J. Harvey\\\" <ddd \\\\@ Org>\", true),\n        new ResultPair(\"Gourmets:  Pompous Person <WhoZiWhatZit\\\\@Cordon-Bleu>,\\\\x0D\\\\x0A\" +\n            \"        Childs\\\\@WGBH.Boston, \\\"Galloping Gourmet\\\"\\\\@\\\\x0D\\\\x0A\" +\n            \"        ANT.Down-Under (Australian National Television),\\\\x0D\\\\x0A\" +\n            \"        Cheapie\\\\@Discount-Liquors;\", true),\n        new ResultPair(\"   Just a string\", false),\n        new ResultPair(\"string\", false),\n        new ResultPair(\"(comment)\", false),\n        new ResultPair(\"()@example.com\", false),\n        new ResultPair(\"fred(&)barny@example.com\", false),\n        new ResultPair(\"fred\\\\ barny@example.com\", false),\n        new ResultPair(\"Abigail <abi gail @ example.com>\", false),\n        new ResultPair(\"Abigail <abigail(fo(o)@example.com>\", false),\n        new ResultPair(\"Abigail <abigail(fo) o)@example.com>\", false),\n        new ResultPair(\"\\\"Abi\\\"gail\\\" <abigail@example.com>\", false),\n        new ResultPair(\"abigail@[exa]ple.com]\", false),\n        new ResultPair(\"abigail@[exa[ple.com]\", false),\n        new ResultPair(\"abigail@[exaple].com]\", false),\n        new ResultPair(\"abigail@\", false),\n        new ResultPair(\"@example.com\", false),\n        new ResultPair(\"phrase: abigail@example.com abigail@example.com ;\", false),\n        new ResultPair(\"invalid\ufffdchar@example.com\", false)\n    // @formatter:on\n    };", "docstring": "\nThese test values derive directly from RFC 822 & Mail::RFC822::Address & RFC::RFC822::Address perl test.pl For traceability don't combine these test\nvalues with other tests.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "ResultPair[]", "name": "TEST_EMAIL_FROM_PERL = {\n        // @formatter:off\n        new ResultPair(\"abigail@example.com\", true),\n        new ResultPair(\"abigail@example.com \", true),\n        new ResultPair(\" abigail@example.com\", true),\n        new ResultPair(\"abigail @example.com \", true),\n        new ResultPair(\"*@example.net\", true),\n        new ResultPair(\"\\\"\\\\\\\"\\\"@foo.bar\", true),\n        new ResultPair(\"fred&barny@example.com\", true),\n        new ResultPair(\"---@example.com\", true),\n        new ResultPair(\"foo-bar@example.net\", true),\n        new ResultPair(\"\\\"127.0.0.1\\\"@[127.0.0.1]\", true),\n        new ResultPair(\"Abigail <abigail@example.com>\", true),\n        new ResultPair(\"Abigail<abigail@example.com>\", true),\n        new ResultPair(\"Abigail<@a,@b,@c:abigail@example.com>\", true),\n        new ResultPair(\"\\\"This is a phrase\\\"<abigail@example.com>\", true),\n        new ResultPair(\"\\\"Abigail \\\"<abigail@example.com>\", true),\n        new ResultPair(\"\\\"Joe & J. Harvey\\\" <example @Org>\", true),\n        new ResultPair(\"Abigail <abigail @ example.com>\", true),\n        new ResultPair(\"Abigail made this <  abigail   @   example  .    com    >\", true),\n        new ResultPair(\"Abigail(the bitch)@example.com\", true),\n        new ResultPair(\"Abigail <abigail @ example . (bar) com >\", true),\n        new ResultPair(\"Abigail < (one)  abigail (two) @(three) example . (bar) com (quz) >\", true),\n        new ResultPair(\"Abigail (foo) (((baz)(nested) (comment)) ! ) < (one)  abigail (two) @(three) example . (bar) com (quz) >\", true),\n        new ResultPair(\"Abigail <abigail(fo\\\\(o)@example.com>\", true),\n        new ResultPair(\"Abigail <abigail(fo\\\\)o)@example.com> \", true),\n        new ResultPair(\"(foo) abigail@example.com\", true),\n        new ResultPair(\"abigail@example.com (foo)\", true),\n        new ResultPair(\"\\\"Abi\\\\\\\"gail\\\" <abigail@example.com>\", true),\n        new ResultPair(\"abigail@[example.com]\", true),\n        new ResultPair(\"abigail@[exa\\\\[ple.com]\", true),\n        new ResultPair(\"abigail@[exa\\\\]ple.com]\", true),\n        new ResultPair(\"\\\":sysmail\\\"@  Some-Group. Some-Org\", true),\n        new ResultPair(\"Muhammed.(I am  the greatest) Ali @(the) Vegas.WBA\", true),\n        new ResultPair(\"mailbox.sub1.sub2@this-domain\", true),\n        new ResultPair(\"sub-net.mailbox@sub-domain.domain\", true),\n        new ResultPair(\"name:;\", true),\n        new ResultPair(\"':;\", true),\n        new ResultPair(\"name:   ;\", true),\n        new ResultPair(\"Alfred Neuman <Neuman@BBN-TENEXA>\", true),\n        new ResultPair(\"Neuman@BBN-TENEXA\", true),\n        new ResultPair(\"\\\"George, Ted\\\" <Shared@Group.Arpanet>\", true),\n        new ResultPair(\"Wilt . (the  Stilt) Chamberlain@NBA.US\", true),\n        new ResultPair(\"Cruisers:  Port@Portugal, Jones@SEA;\", true),\n        new ResultPair(\"$@[]\", true),\n        new ResultPair(\"*()@[]\", true),\n        new ResultPair(\"\\\"quoted ( brackets\\\" ( a comment )@example.com\", true),\n        new ResultPair(\"\\\"Joe & J. Harvey\\\"\\\\x0D\\\\x0A     <ddd\\\\@ Org>\", true),\n        new ResultPair(\"\\\"Joe &\\\\x0D\\\\x0A J. Harvey\\\" <ddd \\\\@ Org>\", true),\n        new ResultPair(\"Gourmets:  Pompous Person <WhoZiWhatZit\\\\@Cordon-Bleu>,\\\\x0D\\\\x0A\" +\n            \"        Childs\\\\@WGBH.Boston, \\\"Galloping Gourmet\\\"\\\\@\\\\x0D\\\\x0A\" +\n            \"        ANT.Down-Under (Australian National Television),\\\\x0D\\\\x0A\" +\n            \"        Cheapie\\\\@Discount-Liquors;\", true),\n        new ResultPair(\"   Just a string\", false),\n        new ResultPair(\"string\", false),\n        new ResultPair(\"(comment)\", false),\n        new ResultPair(\"()@example.com\", false),\n        new ResultPair(\"fred(&)barny@example.com\", false),\n        new ResultPair(\"fred\\\\ barny@example.com\", false),\n        new ResultPair(\"Abigail <abi gail @ example.com>\", false),\n        new ResultPair(\"Abigail <abigail(fo(o)@example.com>\", false),\n        new ResultPair(\"Abigail <abigail(fo) o)@example.com>\", false),\n        new ResultPair(\"\\\"Abi\\\"gail\\\" <abigail@example.com>\", false),\n        new ResultPair(\"abigail@[exa]ple.com]\", false),\n        new ResultPair(\"abigail@[exa[ple.com]\", false),\n        new ResultPair(\"abigail@[exaple].com]\", false),\n        new ResultPair(\"abigail@\", false),\n        new ResultPair(\"@example.com\", false),\n        new ResultPair(\"phrase: abigail@example.com abigail@example.com ;\", false),\n        new ResultPair(\"invalid\ufffdchar@example.com\", false)\n    // @formatter:on\n    }", "syntax_pass": true}, {"attribute_expression": "private EmailValidator validator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "EmailValidator", "name": "validator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/DomainValidatorStartupTest.java.DomainValidatorStartupTest", "name": "DomainValidatorStartupTest", "file_path": "src/test/java/org/apache/commons/validator/routines/DomainValidatorStartupTest.java", "superclasses": "", "methods": ["[void]testCannotUpdate()", "[void]testInstanceOverride()", "[void]testUpdateBaseArrayCC()", "[void]testUpdateBaseArrayGeneric()", "[void]testUpdateBaseArrayInfra()", "[void]testUpdateBaseArrayLocal()", "[void]testUpdateCountryCode1a()", "[void]testUpdateCountryCode1b()", "[void]testUpdateCountryCode2()", "[void]testUpdateCountryCode3a()", "[void]testUpdateCountryCode3b()", "[void]testUpdateCountryCode3c()", "[void]testUpdateGeneric1()", "[void]testUpdateGeneric2()", "[void]testUpdateGeneric3()", "[void]testUpdateGeneric4()", "[void]testUpdateGeneric5()", "[void]testValidator412a()", "[void]testValidator412b()", "[void]testValidator412c()", "[void]testValidator412d()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nStartup Tests for the DomainValidator.\n\nTODO Port to JUnit 5.\n", "original_string": "@RunWith(ClassLoaderPerTestRunner.class)\npublic class DomainValidatorStartupTest {\n\n    @Test\n    public void testCannotUpdate() {\n        DomainValidator.updateTLDOverride(ArrayType.GENERIC_PLUS, \"ch\"); // OK\n        final DomainValidator dv = DomainValidator.getInstance();\n        assertNotNull(dv);\n        assertThrows(IllegalStateException.class, () -> DomainValidator.updateTLDOverride(ArrayType.GENERIC_PLUS, \"ch\"));\n    }\n\n    @Test\n    public void testInstanceOverride() { // Show that the instance picks up static values\n        DomainValidator.updateTLDOverride(ArrayType.GENERIC_PLUS, \"gp\");\n        DomainValidator.updateTLDOverride(ArrayType.GENERIC_MINUS, \"com\");\n        DomainValidator.updateTLDOverride(ArrayType.COUNTRY_CODE_PLUS, \"cp\");\n        DomainValidator.updateTLDOverride(ArrayType.COUNTRY_CODE_MINUS, \"ch\");\n        DomainValidator validator = DomainValidator.getInstance(false);\n        assertTrue(validator.isValidGenericTld(\"gp\"));\n        assertFalse(validator.isValidGenericTld(\"com\"));\n        assertTrue(validator.isValidCountryCodeTld(\"cp\"));\n        assertFalse(validator.isValidCountryCodeTld(\"ch\"));\n\n        // show we can override them for a new instance\n        final List<DomainValidator.Item> items = new ArrayList<>();\n        items.add(new DomainValidator.Item(ArrayType.GENERIC_MINUS, \"\"));\n        items.add(new DomainValidator.Item(ArrayType.COUNTRY_CODE_MINUS, \"\"));\n        validator = DomainValidator.getInstance(false, items);\n        assertTrue(validator.isValidGenericTld(\"gp\"));\n        assertTrue(validator.isValidGenericTld(\"com\")); // Should be true again\n        assertTrue(validator.isValidCountryCodeTld(\"cp\"));\n        assertTrue(validator.isValidCountryCodeTld(\"ch\")); // Should be true again\n\n        // Show the class overrides are unaffected\n        validator = DomainValidator.getInstance(false);\n        assertTrue(validator.isValidGenericTld(\"gp\"));\n        assertFalse(validator.isValidGenericTld(\"com\"));\n        assertTrue(validator.isValidCountryCodeTld(\"cp\"));\n        assertFalse(validator.isValidCountryCodeTld(\"ch\"));\n    }\n\n    @Test\n    public void testUpdateBaseArrayCC() {\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class,\n                () -> DomainValidator.updateTLDOverride(ArrayType.COUNTRY_CODE_RO, \"com\"));\n        assertEquals(\"Cannot update the table: COUNTRY_CODE_RO\", thrown.getMessage());\n    }\n\n    @Test\n    public void testUpdateBaseArrayGeneric() {\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class,\n                () -> DomainValidator.updateTLDOverride(ArrayType.GENERIC_RO, \"com\"));\n        assertEquals(\"Cannot update the table: GENERIC_RO\", thrown.getMessage());\n    }\n\n    @Test\n    public void testUpdateBaseArrayInfra() {\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class,\n                () -> DomainValidator.updateTLDOverride(ArrayType.INFRASTRUCTURE_RO, \"com\"));\n        assertEquals(\"Cannot update the table: INFRASTRUCTURE_RO\", thrown.getMessage());\n    }\n\n    @Test\n    public void testUpdateBaseArrayLocal() {\n        final IllegalArgumentException thrown = assertThrows(IllegalArgumentException.class,\n                () -> DomainValidator.updateTLDOverride(ArrayType.LOCAL_RO, \"com\"));\n        assertEquals(\"Cannot update the table: LOCAL_RO\", thrown.getMessage());\n    }\n\n    @Test\n    public void testUpdateCountryCode1a() {\n        final DomainValidator validator = DomainValidator.getInstance();\n        assertFalse(validator.isValidCountryCodeTld(\"com\")); // cannot be valid\n    }\n\n    @Test\n    public void testUpdateCountryCode1b() {\n        DomainValidator.updateTLDOverride(ArrayType.COUNTRY_CODE_PLUS, \"com\");\n        final DomainValidator validator = DomainValidator.getInstance();\n        assertTrue(validator.isValidCountryCodeTld(\"com\")); // it is now!\n    }\n\n    @Test\n    public void testUpdateCountryCode2() {\n        DomainValidator.updateTLDOverride(ArrayType.COUNTRY_CODE_PLUS, \"com\");\n        DomainValidator.updateTLDOverride(ArrayType.COUNTRY_CODE_MINUS, \"com\");\n        final DomainValidator validator = DomainValidator.getInstance();\n        assertFalse(validator.isValidCountryCodeTld(\"com\")); // show that minus overrides the rest\n    }\n\n    @Test\n    public void testUpdateCountryCode3a() { // show ch is valid\n        final DomainValidator validator = DomainValidator.getInstance();\n        assertTrue(validator.isValidCountryCodeTld(\"ch\"));\n    }\n\n    @Test\n    public void testUpdateCountryCode3b() { // show ch can be made invalid\n        DomainValidator.updateTLDOverride(ArrayType.COUNTRY_CODE_MINUS, \"ch\");\n        final DomainValidator validator = DomainValidator.getInstance();\n        assertFalse(validator.isValidCountryCodeTld(\"ch\"));\n    }\n\n    @Test\n    public void testUpdateCountryCode3c() { // show ch can be made valid again by replacing the CC array\n        DomainValidator.updateTLDOverride(ArrayType.COUNTRY_CODE_MINUS, \"ch\");\n        DomainValidator.updateTLDOverride(ArrayType.COUNTRY_CODE_MINUS, \"xx\");\n        final DomainValidator validator = DomainValidator.getInstance();\n        assertTrue(validator.isValidCountryCodeTld(\"ch\"));\n    }\n\n    @Test\n    public void testUpdateGeneric1() {\n        final DomainValidator validator = DomainValidator.getInstance();\n        assertFalse(validator.isValidGenericTld(\"ch\")); // cannot be valid\n    }\n\n    @Test\n    public void testUpdateGeneric2() {\n        DomainValidator.updateTLDOverride(ArrayType.GENERIC_PLUS, \"ch\");\n        final DomainValidator validator = DomainValidator.getInstance();\n        assertTrue(validator.isValidGenericTld(\"ch\")); // it is now!\n    }\n\n    @Test\n    public void testUpdateGeneric3() {\n        DomainValidator.updateTLDOverride(ArrayType.GENERIC_PLUS, \"ch\");\n        DomainValidator.updateTLDOverride(ArrayType.GENERIC_MINUS, \"ch\");\n        final DomainValidator validator = DomainValidator.getInstance();\n        assertFalse(validator.isValidGenericTld(\"ch\")); // show that minus overrides the rest\n        assertTrue(validator.isValidGenericTld(\"com\"));\n    }\n\n    @Test\n    public void testUpdateGeneric4() {\n        DomainValidator.updateTLDOverride(ArrayType.GENERIC_PLUS, \"ch\");\n        DomainValidator.updateTLDOverride(ArrayType.GENERIC_MINUS, \"ch\");\n        DomainValidator.updateTLDOverride(ArrayType.GENERIC_MINUS, \"com\");\n        final DomainValidator validator = DomainValidator.getInstance();\n        assertFalse(validator.isValidGenericTld(\"com\"));\n    }\n\n    @Test\n    public void testUpdateGeneric5() {\n        DomainValidator.updateTLDOverride(ArrayType.GENERIC_PLUS, \"ch\");\n        DomainValidator.updateTLDOverride(ArrayType.GENERIC_MINUS, \"ch\");\n        DomainValidator.updateTLDOverride(ArrayType.GENERIC_MINUS, \"com\");\n        DomainValidator.updateTLDOverride(ArrayType.GENERIC_MINUS, \"xx\"); // change the minus list\n        final DomainValidator validator = DomainValidator.getInstance();\n        assertTrue(validator.isValidGenericTld(\"com\"));\n    }\n\n    @Test\n    public void testValidator412a() {\n        final DomainValidator validator = DomainValidator.getInstance();\n        assertFalse(validator.isValidGenericTld(\"local\"));\n        assertFalse(validator.isValid(\"abc.local\"));\n        assertFalse(validator.isValidGenericTld(\"pvt\"));\n        assertFalse(validator.isValid(\"abc.pvt\"));\n    }\n\n    @Test\n    public void testValidator412b() {\n        DomainValidator.updateTLDOverride(ArrayType.GENERIC_PLUS, \"local\", \"pvt\");\n        final DomainValidator validator = DomainValidator.getInstance();\n        assertTrue(validator.isValidGenericTld(\"local\"));\n        assertTrue(validator.isValid(\"abc.local\"));\n        assertTrue(validator.isValidGenericTld(\"pvt\"));\n        assertTrue(validator.isValid(\"abc.pvt\"));\n    }\n\n    @Test\n    public void testValidator412c() {\n        final DomainValidator validator = DomainValidator.getInstance(true);\n        assertFalse(validator.isValidLocalTld(\"local\"));\n        assertFalse(validator.isValid(\"abc.local\"));\n        assertFalse(validator.isValidLocalTld(\"pvt\"));\n        assertFalse(validator.isValid(\"abc.pvt\"));\n    }\n\n    @Test\n    public void testValidator412d() {\n        DomainValidator.updateTLDOverride(ArrayType.LOCAL_PLUS, \"local\", \"pvt\");\n        final DomainValidator validator = DomainValidator.getInstance(true);\n        assertTrue(validator.isValidLocalTld(\"local\"));\n        assertTrue(validator.isValidLocalTld(\"pvt\"));\n        assertTrue(validator.isValid(\"abc.local\"));\n        assertTrue(validator.isValid(\"abc.pvt\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/routines/ShortValidatorTest.java.ShortValidatorTest", "name": "ShortValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/ShortValidatorTest.java", "superclasses": "AbstractNumberValidatorTest", "methods": ["[void]testShortRangeMinMax()", "[void]testShortValidatorMethods()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/ShortValidatorTest.java.ShortValidatorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTest Case for ShortValidator.\n", "original_string": "public class ShortValidatorTest extends AbstractNumberValidatorTest {\n\n    @Override\n    @BeforeEach\n    protected void setUp() {\n        super.setUp();\n\n        validator = new ShortValidator(false, 0);\n        strictValidator = new ShortValidator();\n\n        testPattern = \"#,###\";\n\n        // testValidateMinMax()\n        max = Short.valueOf(Short.MAX_VALUE);\n        maxPlusOne = Long.valueOf(max.longValue() + 1);\n        min = Short.valueOf(Short.MIN_VALUE);\n        minMinusOne = Long.valueOf(min.longValue() - 1);\n\n        // testInvalidStrict()\n        invalidStrict = new String[] { null, \"\", \"X\", \"X12\", \"12X\", \"1X2\", \"1.2\" };\n\n        // testInvalidNotStrict()\n        invalid = new String[] { null, \"\", \"X\", \"X12\" };\n\n        // testValid()\n        testNumber = Short.valueOf((short) 1234);\n        testZero = Short.valueOf((short) 0);\n        validStrict = new String[] { \"0\", \"1234\", \"1,234\" };\n        validStrictCompare = new Number[] { testZero, testNumber, testNumber };\n        valid = new String[] { \"0\", \"1234\", \"1,234\", \"1,234.5\", \"1234X\" };\n        validCompare = new Number[] { testZero, testNumber, testNumber, testNumber, testNumber };\n\n        testStringUS = \"1,234\";\n        testStringDE = \"1.234\";\n\n        // Localized Pattern test\n        localeValue = testStringDE;\n        localePattern = \"#.###\";\n        testLocale = Locale.GERMANY;\n        localeExpected = testNumber;\n\n    }\n\n    /**\n     * Test Short Range/Min/Max\n     */\n    @Test\n    public void testShortRangeMinMax() {\n        final ShortValidator validator = (ShortValidator) strictValidator;\n        final Short number9 = validator.validate(\"9\", \"#\");\n        final Short number10 = validator.validate(\"10\", \"#\");\n        final Short number11 = validator.validate(\"11\", \"#\");\n        final Short number19 = validator.validate(\"19\", \"#\");\n        final Short number20 = validator.validate(\"20\", \"#\");\n        final Short number21 = validator.validate(\"21\", \"#\");\n        final short min = (short) 10;\n        final short max = (short) 20;\n\n        // Test isInRange()\n        assertFalse(validator.isInRange(number9, min, max), \"isInRange() < min\");\n        assertTrue(validator.isInRange(number10, min, max), \"isInRange() = min\");\n        assertTrue(validator.isInRange(number11, min, max), \"isInRange() in range\");\n        assertTrue(validator.isInRange(number20, min, max), \"isInRange() = max\");\n        assertFalse(validator.isInRange(number21, min, max), \"isInRange() > max\");\n\n        // Test minValue()\n        assertFalse(validator.minValue(number9, min), \"minValue() < min\");\n        assertTrue(validator.minValue(number10, min), \"minValue() = min\");\n        assertTrue(validator.minValue(number11, min), \"minValue() > min\");\n\n        // Test minValue()\n        assertTrue(validator.maxValue(number19, max), \"maxValue() < max\");\n        assertTrue(validator.maxValue(number20, max), \"maxValue() = max\");\n        assertFalse(validator.maxValue(number21, max), \"maxValue() > max\");\n    }\n\n    /**\n     * Test ShortValidator validate Methods\n     */\n    @Test\n    public void testShortValidatorMethods() {\n        final Locale locale = Locale.GERMAN;\n        final String pattern = \"0,00,00\";\n        final String patternVal = \"1,23,45\";\n        final String germanPatternVal = \"1.23.45\";\n        final String localeVal = \"12.345\";\n        final String defaultVal = \"12,345\";\n        final String xxxx = \"XXXX\";\n        final Short expected = Short.valueOf((short) 12345);\n        assertEquals(expected, ShortValidator.getInstance().validate(defaultVal), \"validate(A) default\");\n        assertEquals(expected, ShortValidator.getInstance().validate(localeVal, locale), \"validate(A) locale\");\n        assertEquals(expected, ShortValidator.getInstance().validate(patternVal, pattern), \"validate(A) pattern\");\n        assertEquals(expected, ShortValidator.getInstance().validate(germanPatternVal, pattern, Locale.GERMAN), \"validate(A) both\");\n\n        assertTrue(ShortValidator.getInstance().isValid(defaultVal), \"isValid(A) default\");\n        assertTrue(ShortValidator.getInstance().isValid(localeVal, locale), \"isValid(A) locale\");\n        assertTrue(ShortValidator.getInstance().isValid(patternVal, pattern), \"isValid(A) pattern\");\n        assertTrue(ShortValidator.getInstance().isValid(germanPatternVal, pattern, Locale.GERMAN), \"isValid(A) both\");\n\n        assertNull(ShortValidator.getInstance().validate(xxxx), \"validate(B) default\");\n        assertNull(ShortValidator.getInstance().validate(xxxx, locale), \"validate(B) locale\");\n        assertNull(ShortValidator.getInstance().validate(xxxx, pattern), \"validate(B) pattern\");\n        assertNull(ShortValidator.getInstance().validate(patternVal, pattern, Locale.GERMAN), \"validate(B) both\");\n\n        assertFalse(ShortValidator.getInstance().isValid(xxxx), \"isValid(B) default\");\n        assertFalse(ShortValidator.getInstance().isValid(xxxx, locale), \"isValid(B) locale\");\n        assertFalse(ShortValidator.getInstance().isValid(xxxx, pattern), \"isValid(B) pattern\");\n        assertFalse(ShortValidator.getInstance().isValid(patternVal, pattern, Locale.GERMAN), \"isValid(B) both\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/routines/RegexValidator_validateTest.java.RegexValidator_validateTest", "name": "RegexValidator_validateTest", "file_path": "src/test/java/org/apache/commons/validator/routines/RegexValidator_validateTest.java", "superclasses": "", "methods": ["[void]testValidateNullValue()", "[void]testValidateSingleGroupMatch()", "[void]testValidateMultipleGroupMatch()", "[void]testValidateNoMatch()", "[void]testValidateMultipleGroupsConcatenation()", "[void]testValidateWithIsValid()", "[void]testValidateWithMatch()", "[void]testValidateToString()", "[void]testGetPatterns()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/RegexValidator_validateTest.java.RegexValidator_validateTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RegexValidator_validateTest {\n\n    private static final String[] MULTIPLE_REGEX = {\n        \"^([A-Z]{2})$\", // Matches two uppercase letters\n        \"^([0-9]{3})$\", // Matches three digits\n        \"^([a-z]{4})$\"  // Matches four lowercase letters\n    };\n\n    private RegexValidator regexValidator;\n\n    @BeforeEach\n    public void setUp() {\n        regexValidator = new RegexValidator(MULTIPLE_REGEX);\n    }\n\n    @Test\n    public void testValidateNullValue() {\n        assertNull(regexValidator.validate(null));\n    }\n\n    @Test\n    public void testValidateSingleGroupMatch() {\n        assertEquals(\"AB\", regexValidator.validate(\"AB\"));\n    }\n\n    @Test\n    public void testValidateMultipleGroupMatch() {\n        assertEquals(\"123\", regexValidator.validate(\"123\"));\n    }\n\n    @Test\n    public void testValidateNoMatch() {\n        assertNull(regexValidator.validate(\"XYZ\"));\n    }\n\n    @Test\n    public void testValidateMultipleGroupsConcatenation() {\n        assertEquals(\"abcd\", regexValidator.validate(\"abcd\"));\n    }\n\n    @Test\n    public void testValidateWithIsValid() {\n        String value = \"AB\";\n        assertTrue(regexValidator.isValid(value));\n        assertEquals(\"AB\", regexValidator.validate(value));\n    }\n\n    @Test\n    public void testValidateWithMatch() {\n        String value = \"123\";\n        String[] matchedGroups = regexValidator.match(value);\n        assertNotNull(matchedGroups);\n        assertEquals(1, matchedGroups.length);\n        assertEquals(\"123\", matchedGroups[0]);\n        assertEquals(\"123\", regexValidator.validate(value));\n    }\n\n    @Test\n    public void testValidateToString() {\n        String value = \"abcd\";\n        regexValidator.validate(value);\n        String validatorString = regexValidator.toString();\n        assertTrue(validatorString.contains(\"^([A-Z]{2})$\"));\n        assertTrue(validatorString.contains(\"^([0-9]{3})$\"));\n        assertTrue(validatorString.contains(\"^([a-z]{4})$\"));\n    }\n\n    @Test\n    public void testGetPatterns() {\n        assertNotSame(regexValidator.getPatterns(), regexValidator.getPatterns());\n        Pattern[] patterns = regexValidator.getPatterns();\n        assertEquals(\"^([A-Z]{2})$\", patterns[0].pattern());\n        assertEquals(\"^([0-9]{3})$\", patterns[1].pattern());\n        assertEquals(\"^([a-z]{4})$\", patterns[2].pattern());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String[] MULTIPLE_REGEX = {\n        \"^([A-Z]{2})$\", // Matches two uppercase letters\n        \"^([0-9]{3})$\", // Matches three digits\n        \"^([a-z]{4})$\"  // Matches four lowercase letters\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "MULTIPLE_REGEX = {\n        \"^([A-Z]{2})$\", // Matches two uppercase letters\n        \"^([0-9]{3})$\", // Matches three digits\n        \"^([a-z]{4})$\"  // Matches four lowercase letters\n    }", "syntax_pass": true}, {"attribute_expression": "private RegexValidator regexValidator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RegexValidator", "name": "regexValidator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/DomainValidator_isValidLocalTldTest.java.DomainValidator_isValidLocalTldTest", "name": "DomainValidator_isValidLocalTldTest", "file_path": "src/test/java/org/apache/commons/validator/routines/DomainValidator_isValidLocalTldTest.java", "superclasses": "", "methods": ["[void]testIsValidLocalTld_ValidLocalTld()", "[void]testIsValidLocalTld_InvalidLocalTld()", "[void]testIsValidLocalTld_ValidLocalTldWithPlus()", "[void]testIsValidLocalTld_InvalidLocalTldWithMinus()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/DomainValidator_isValidLocalTldTest.java.DomainValidator_isValidLocalTldTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DomainValidator_isValidLocalTldTest {\n\n    private DomainValidator validator;\n\n    @BeforeEach\n    public void setUp() {\n        validator = DomainValidator.getInstance(true);\n    }\n\n    @Test\n    public void testIsValidLocalTld_ValidLocalTld() {\n        assertTrue(validator.isValidLocalTld(\"localhost\"));\n    }\n\n    @Test\n    public void testIsValidLocalTld_InvalidLocalTld() {\n        assertFalse(validator.isValidLocalTld(\"invalidlocal\"));\n    }\n\n    @Test\n    public void testIsValidLocalTld_ValidLocalTldWithPlus() {\n        assertTrue(validator.isValidLocalTld(\"localdomain\"));\n    }\n\n    @Test\n    public void testIsValidLocalTld_InvalidLocalTldWithMinus() {\n        assertFalse(validator.isValidLocalTld(\"invalidlocal\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DomainValidator validator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DomainValidator", "name": "validator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/IntegerValidatorTest.java.IntegerValidatorTest", "name": "IntegerValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/IntegerValidatorTest.java", "superclasses": "AbstractNumberValidatorTest", "methods": ["[void]testIntegerRangeMinMax()", "[void]testIntegerValidatorMethods()", "[void]testMinMaxValues()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/IntegerValidatorTest.java.IntegerValidatorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTest Case for IntegerValidator.\n", "original_string": "public class IntegerValidatorTest extends AbstractNumberValidatorTest {\n\n    private static final Integer INT_MIN_VAL = Integer.valueOf(Integer.MIN_VALUE);\n    private static final Integer INT_MAX_VAL = Integer.valueOf(Integer.MAX_VALUE);\n    private static final String INT_MAX = \"2147483647\";\n    private static final String INT_MAX_0 = \"2147483647.99999999999999999999999\"; // force double rounding\n    private static final String INT_MAX_1 = \"2147483648\";\n    private static final String INT_MIN = \"-2147483648\";\n    private static final String INT_MIN_0 = \"-2147483648.99999999999999999999999\"; // force double rounding\";\n    private static final String INT_MIN_1 = \"-2147483649\";\n\n    @Override\n    @BeforeEach\n    protected void setUp() {\n        super.setUp();\n\n        validator = new IntegerValidator(false, 0);\n        strictValidator = new IntegerValidator();\n\n        testPattern = \"#,###\";\n\n        // testValidateMinMax()\n        max = Integer.valueOf(Integer.MAX_VALUE);\n        maxPlusOne = Long.valueOf(max.longValue() + 1);\n        min = Integer.valueOf(Integer.MIN_VALUE);\n        minMinusOne = Long.valueOf(min.longValue() - 1);\n\n        // testInvalidStrict()\n        invalidStrict = new String[] { null, \"\", \"X\", \"X12\", \"12X\", \"1X2\", \"1.2\", INT_MAX_1, INT_MIN_1 };\n\n        // testInvalidNotStrict()\n        invalid = new String[] { null, \"\", \"X\", \"X12\", INT_MAX_1, INT_MIN_1 };\n\n        // testValid()\n        testNumber = Integer.valueOf(1234);\n        testZero = Integer.valueOf(0);\n        validStrict = new String[] { \"0\", \"1234\", \"1,234\", INT_MAX, INT_MIN };\n        validStrictCompare = new Number[] { testZero, testNumber, testNumber, INT_MAX_VAL, INT_MIN_VAL };\n        valid = new String[] { \"0\", \"1234\", \"1,234\", \"1,234.5\", \"1234X\", INT_MAX, INT_MIN, INT_MAX_0, INT_MIN_0 };\n        validCompare = new Number[] { testZero, testNumber, testNumber, testNumber, testNumber, INT_MAX_VAL, INT_MIN_VAL, INT_MAX_VAL, INT_MIN_VAL };\n\n        testStringUS = \"1,234\";\n        testStringDE = \"1.234\";\n\n        // Localized Pattern test\n        localeValue = testStringDE;\n        localePattern = \"#.###\";\n        testLocale = Locale.GERMANY;\n        localeExpected = testNumber;\n    }\n\n    /**\n     * Test Integer Range/Min/Max\n     */\n    @Test\n    public void testIntegerRangeMinMax() {\n        final IntegerValidator validator = (IntegerValidator) strictValidator;\n        final Integer number9 = validator.validate(\"9\", \"#\");\n        final Integer number10 = validator.validate(\"10\", \"#\");\n        final Integer number11 = validator.validate(\"11\", \"#\");\n        final Integer number19 = validator.validate(\"19\", \"#\");\n        final Integer number20 = validator.validate(\"20\", \"#\");\n        final Integer number21 = validator.validate(\"21\", \"#\");\n\n        // Test isInRange()\n        assertFalse(validator.isInRange(number9, 10, 20), \"isInRange() < min\");\n        assertTrue(validator.isInRange(number10, 10, 20), \"isInRange() = min\");\n        assertTrue(validator.isInRange(number11, 10, 20), \"isInRange() in range\");\n        assertTrue(validator.isInRange(number20, 10, 20), \"isInRange() = max\");\n        assertFalse(validator.isInRange(number21, 10, 20), \"isInRange() > max\");\n\n        // Test minValue()\n        assertFalse(validator.minValue(number9, 10), \"minValue() < min\");\n        assertTrue(validator.minValue(number10, 10), \"minValue() = min\");\n        assertTrue(validator.minValue(number11, 10), \"minValue() > min\");\n\n        // Test minValue()\n        assertTrue(validator.maxValue(number19, 20), \"maxValue() < max\");\n        assertTrue(validator.maxValue(number20, 20), \"maxValue() = max\");\n        assertFalse(validator.maxValue(number21, 20), \"maxValue() > max\");\n    }\n\n    /**\n     * Test IntegerValidator validate Methods\n     */\n    @Test\n    public void testIntegerValidatorMethods() {\n        final Locale locale = Locale.GERMAN;\n        final String pattern = \"0,00,00\";\n        final String patternVal = \"1,23,45\";\n        final String germanPatternVal = \"1.23.45\";\n        final String localeVal = \"12.345\";\n        final String defaultVal = \"12,345\";\n        final String xxxx = \"XXXX\";\n        final Integer expected = Integer.valueOf(12345);\n        assertEquals(expected, IntegerValidator.getInstance().validate(defaultVal), \"validate(A) default\");\n        assertEquals(expected, IntegerValidator.getInstance().validate(localeVal, locale), \"validate(A) locale\");\n        assertEquals(expected, IntegerValidator.getInstance().validate(patternVal, pattern), \"validate(A) pattern\");\n        assertEquals(expected, IntegerValidator.getInstance().validate(germanPatternVal, pattern, Locale.GERMAN), \"validate(A) both\");\n\n        assertTrue(IntegerValidator.getInstance().isValid(defaultVal), \"isValid(A) default\");\n        assertTrue(IntegerValidator.getInstance().isValid(localeVal, locale), \"isValid(A) locale\");\n        assertTrue(IntegerValidator.getInstance().isValid(patternVal, pattern), \"isValid(A) pattern\");\n        assertTrue(IntegerValidator.getInstance().isValid(germanPatternVal, pattern, Locale.GERMAN), \"isValid(A) both\");\n\n        assertNull(IntegerValidator.getInstance().validate(xxxx), \"validate(B) default\");\n        assertNull(IntegerValidator.getInstance().validate(xxxx, locale), \"validate(B) locale\");\n        assertNull(IntegerValidator.getInstance().validate(xxxx, pattern), \"validate(B) pattern\");\n        assertNull(IntegerValidator.getInstance().validate(patternVal, pattern, Locale.GERMAN), \"validate(B) both\");\n\n        assertFalse(IntegerValidator.getInstance().isValid(xxxx), \"isValid(B) default\");\n        assertFalse(IntegerValidator.getInstance().isValid(xxxx, locale), \"isValid(B) locale\");\n        assertFalse(IntegerValidator.getInstance().isValid(xxxx, pattern), \"isValid(B) pattern\");\n        assertFalse(IntegerValidator.getInstance().isValid(patternVal, pattern, Locale.GERMAN), \"isValid(B) both\");\n    }\n\n    @Test\n    public void testMinMaxValues() {\n        assertTrue(validator.isValid(\"2147483647\"), \"2147483647 is max integer\");\n        assertFalse(validator.isValid(\"2147483648\"), \"2147483648 > max integer\");\n        assertTrue(validator.isValid(\"-2147483648\"), \"-2147483648 is min integer\");\n        assertFalse(validator.isValid(\"-2147483649\"), \"-2147483649 < min integer\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Integer INT_MIN_VAL = Integer.valueOf(Integer.MIN_VALUE);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "INT_MIN_VAL = Integer.valueOf(Integer.MIN_VALUE)", "syntax_pass": true}, {"attribute_expression": "private static final Integer INT_MAX_VAL = Integer.valueOf(Integer.MAX_VALUE);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Integer", "name": "INT_MAX_VAL = Integer.valueOf(Integer.MAX_VALUE)", "syntax_pass": true}, {"attribute_expression": "private static final String INT_MAX = \"2147483647\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "INT_MAX = \"2147483647\"", "syntax_pass": true}, {"attribute_expression": "private static final String INT_MAX_0 = \"2147483647.99999999999999999999999\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "INT_MAX_0 = \"2147483647.99999999999999999999999\"", "syntax_pass": true}, {"attribute_expression": "private static final String INT_MAX_1 = \"2147483648\";", "docstring": " force double rounding", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "INT_MAX_1 = \"2147483648\"", "syntax_pass": true}, {"attribute_expression": "private static final String INT_MIN = \"-2147483648\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "INT_MIN = \"-2147483648\"", "syntax_pass": true}, {"attribute_expression": "private static final String INT_MIN_0 = \"-2147483648.99999999999999999999999\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "INT_MIN_0 = \"-2147483648.99999999999999999999999\"", "syntax_pass": true}, {"attribute_expression": "private static final String INT_MIN_1 = \"-2147483649\";", "docstring": " force double rounding\";", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "INT_MIN_1 = \"-2147483649\"", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/IBANValidator_isValidTest.java.IBANValidator_isValidTest", "name": "IBANValidator_isValidTest", "file_path": "src/test/java/org/apache/commons/validator/routines/IBANValidator_isValidTest.java", "superclasses": "", "methods": ["[void]testIsValidWithValidIBAN()", "[void]testIsValidWithInvalidLength()", "[void]testIsValidWithInvalidFormat()", "[void]testIsValidWithNullCode()", "[void]testIsValidWithEmptyCode()", "[void]testIsValidWithUnknownCountryCode()", "[void]testIsValidWithLowercaseCountryCode()", "[void]testIsValidWithInvalidCheckDigit()", "[void]testIsValidWithValidIBANForOtherCountryCode()", "[void]testIsValidWithValidIBANForMultipleCountryCodes()", "[void]testIsValidWithValidIBANForShortestLength()", "[void]testIsValidWithValidIBANForLongestLength()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/IBANValidator_isValidTest.java.IBANValidator_isValidTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IBANValidator_isValidTest {\n\n    private static IBANValidator validator;\n\n    @BeforeAll\n    public static void setUp() {\n        validator = new IBANValidator();\n    }\n\n    @Test\n    public void testIsValidWithValidIBAN() {\n        assertTrue(validator.isValid(\"GB82WEST12345698765432\"));\n    }\n\n    @Test\n    public void testIsValidWithInvalidLength() {\n        assertFalse(validator.isValid(\"GB82WEST1234569876543\"));\n    }\n\n    @Test\n    public void testIsValidWithInvalidFormat() {\n        assertFalse(validator.isValid(\"GB82WEST1234569876543A\"));\n    }\n\n    @Test\n    public void testIsValidWithNullCode() {\n        assertFalse(validator.isValid(null));\n    }\n\n    @Test\n    public void testIsValidWithEmptyCode() {\n        assertFalse(validator.isValid(\"\"));\n    }\n\n    @Test\n    public void testIsValidWithUnknownCountryCode() {\n        assertFalse(validator.isValid(\"ZZ82WEST12345698765432\"));\n    }\n\n    @Test\n    public void testIsValidWithLowercaseCountryCode() {\n        assertFalse(validator.isValid(\"gb82WEST12345698765432\"));\n    }\n\n    @Test\n    public void testIsValidWithInvalidCheckDigit() {\n        assertFalse(validator.isValid(\"GB82WEST12345698765433\"));\n    }\n\n    @Test\n    public void testIsValidWithValidIBANForOtherCountryCode() {\n        assertTrue(validator.isValid(\"DE89370400440532013000\"));\n    }\n\n    @Test\n    public void testIsValidWithValidIBANForMultipleCountryCodes() {\n        assertTrue(validator.isValid(\"FR1420041010050500013M02606\"));\n    }\n\n    @Test\n    public void testIsValidWithValidIBANForShortestLength() {\n        assertTrue(validator.isValid(\"NO9386011117947\"));\n    }\n\n    @Test\n    public void testIsValidWithValidIBANForLongestLength() {\n        assertTrue(validator.isValid(\"MU17BOMM0101101030300200000MUR\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static IBANValidator validator;", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "IBANValidator", "name": "validator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/DateValidator_compareQuartersTest.java.DateValidator_compareQuartersTest", "name": "DateValidator_compareQuartersTest", "file_path": "src/test/java/org/apache/commons/validator/routines/DateValidator_compareQuartersTest.java", "superclasses": "", "methods": ["[void]testCompareQuarters()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/DateValidator_compareQuartersTest.java.DateValidator_compareQuartersTest.[void]setUp()", "src/test/java/org/apache/commons/validator/routines/DateValidator_compareQuartersTest.java.DateValidator_compareQuartersTest.[Date]createDate(TimeZone,int,int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DateValidator_compareQuartersTest {\n    private DateValidator dateValidator;\n    private static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");\n    private static final TimeZone EST = TimeZone.getTimeZone(\"EST\");\n\n    @BeforeEach\n    protected void setUp() {\n        dateValidator = new DateValidator();\n    }\n\n    @Test\n    public void testCompareQuarters() {\n        final int sameTime = 124522;\n        final int testDate = 20050823;\n\n        final Date value = createDate(GMT, testDate, sameTime); // test value\n        final Date date20051101 = createDate(GMT, 20051101, sameTime); // +1 quarter (Feb Start)\n        final Date date20051001 = createDate(GMT, 20051001, sameTime); // +1 quarter\n        final Date date20050701 = createDate(GMT, 20050701, sameTime); // same quarter\n        final Date date20050630 = createDate(GMT, 20050630, sameTime); // -1 quarter\n        final Date date20050110 = createDate(GMT, 20050110, sameTime); // Previous Year qtr (Fen start)\n\n        assertEquals(-1, dateValidator.compareQuarters(value, date20051101, GMT), \"qtrA <1\"); // +1 quarter (Feb)\n        assertEquals(-1, dateValidator.compareQuarters(value, date20051001, GMT), \"qtrA <2\"); // +1 quarter\n        assertEquals(0, dateValidator.compareQuarters(value, date20050701, GMT), \"qtrA =2\"); // same quarter\n        assertEquals(1, dateValidator.compareQuarters(value, date20050630, GMT), \"qtrA GT\"); // -1 quarter\n\n        // Change quarter 1 to start in Feb\n        assertEquals(-1, dateValidator.compareQuarters(value, date20051101, GMT, 2), \"qtrB LT\"); // +1 quarter (Feb)\n        assertEquals(0, dateValidator.compareQuarters(value, date20051001, GMT, 2), \"qtrB =1\"); // same quarter\n        assertEquals(1, dateValidator.compareQuarters(value, date20050701, GMT, 2), \"qtrB =3\"); // same quarter\n        assertEquals(1, dateValidator.compareQuarters(value, date20050630, GMT, 2), \"qtrB GT\"); // -1 quarter\n        assertEquals(1, dateValidator.compareQuarters(value, date20050110, GMT, 2), \"qtrB prev\"); // Jan Prev year qtr\n    }\n\n    private Date createDate(TimeZone timeZone, int date, int time) {\n        Calendar calendar = Calendar.getInstance(timeZone);\n        calendar.set(Calendar.YEAR, date / 10000);\n        calendar.set(Calendar.MONTH, (date % 10000) / 100 - 1);\n        calendar.set(Calendar.DAY_OF_MONTH, date % 100);\n        calendar.set(Calendar.HOUR_OF_DAY, time / 10000);\n        calendar.set(Calendar.MINUTE, (time % 10000) / 100);\n        calendar.set(Calendar.SECOND, time % 100);\n        calendar.set(Calendar.MILLISECOND, 0);\n        return calendar.getTime();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DateValidator dateValidator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DateValidator", "name": "dateValidator", "syntax_pass": true}, {"attribute_expression": "private static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "TimeZone", "name": "GMT = TimeZone.getTimeZone(\"GMT\")", "syntax_pass": true}, {"attribute_expression": "private static final TimeZone EST = TimeZone.getTimeZone(\"EST\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "TimeZone", "name": "EST = TimeZone.getTimeZone(\"EST\")", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/CalendarValidator_adjustToTimeZoneTest.java.CalendarValidator_adjustToTimeZoneTest", "name": "CalendarValidator_adjustToTimeZoneTest", "file_path": "src/test/java/org/apache/commons/validator/routines/CalendarValidator_adjustToTimeZoneTest.java", "superclasses": "", "methods": ["[void]testAdjustToTimeZoneSameRules()", "[void]testAdjustToTimeZoneDifferentRules()", "[void]testAdjustToTimeZoneDifferentRulesWithDifferentDate()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/CalendarValidator_adjustToTimeZoneTest.java.CalendarValidator_adjustToTimeZoneTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CalendarValidator_adjustToTimeZoneTest {\n\n    private CalendarValidator calValidator;\n\n    @BeforeEach\n    protected void setUp() {\n        calValidator = new CalendarValidator();\n    }\n\n    @Test\n    public void testAdjustToTimeZoneSameRules() {\n        Calendar calendar = Calendar.getInstance();\n        TimeZone originalTimeZone = calendar.getTimeZone();\n        CalendarValidator.adjustToTimeZone(calendar, originalTimeZone);\n        assertEquals(originalTimeZone, calendar.getTimeZone(), \"Time zone should remain the same\");\n    }\n\n    @Test\n    public void testAdjustToTimeZoneDifferentRules() {\n        Calendar calendar = Calendar.getInstance();\n        TimeZone originalTimeZone = calendar.getTimeZone();\n        TimeZone newTimeZone = TimeZone.getTimeZone(\"America/New_York\");\n\n        int year = calendar.get(Calendar.YEAR);\n        int month = calendar.get(Calendar.MONTH);\n        int date = calendar.get(Calendar.DATE);\n        int hour = calendar.get(Calendar.HOUR_OF_DAY);\n        int minute = calendar.get(Calendar.MINUTE);\n\n        CalendarValidator.adjustToTimeZone(calendar, newTimeZone);\n\n        assertEquals(newTimeZone, calendar.getTimeZone(), \"Time zone should be updated\");\n        assertEquals(year, calendar.get(Calendar.YEAR), \"Year should remain the same\");\n        assertEquals(month, calendar.get(Calendar.MONTH), \"Month should remain the same\");\n        assertEquals(date, calendar.get(Calendar.DATE), \"Date should remain the same\");\n        assertEquals(hour, calendar.get(Calendar.HOUR_OF_DAY), \"Hour should remain the same\");\n        assertEquals(minute, calendar.get(Calendar.MINUTE), \"Minute should remain the same\");\n    }\n\n    @Test\n    public void testAdjustToTimeZoneDifferentRulesWithDifferentDate() {\n        Calendar calendar = Calendar.getInstance();\n        calendar.set(2023, Calendar.OCTOBER, 10, 15, 30);\n        TimeZone newTimeZone = TimeZone.getTimeZone(\"America/New_York\");\n\n        int year = calendar.get(Calendar.YEAR);\n        int month = calendar.get(Calendar.MONTH);\n        int date = calendar.get(Calendar.DATE);\n        int hour = calendar.get(Calendar.HOUR_OF_DAY);\n        int minute = calendar.get(Calendar.MINUTE);\n\n        CalendarValidator.adjustToTimeZone(calendar, newTimeZone);\n\n        assertEquals(newTimeZone, calendar.getTimeZone(), \"Time zone should be updated\");\n        assertEquals(year, calendar.get(Calendar.YEAR), \"Year should remain the same\");\n        assertEquals(month, calendar.get(Calendar.MONTH), \"Month should remain the same\");\n        assertEquals(date, calendar.get(Calendar.DATE), \"Date should remain the same\");\n        assertEquals(hour, calendar.get(Calendar.HOUR_OF_DAY), \"Hour should remain the same\");\n        assertEquals(minute, calendar.get(Calendar.MINUTE), \"Minute should remain the same\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CalendarValidator calValidator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CalendarValidator", "name": "calValidator", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/CurrencyValidatorTest.java.CurrencyValidatorTest", "name": "CurrencyValidatorTest", "file_path": "src/test/java/org/apache/commons/validator/routines/CurrencyValidatorTest.java", "superclasses": "", "methods": ["[void]testFormatType()", "[void]testIntegerInvalid()", "[void]testIntegerValid()", "[void]testInvalid()", "[void]testPattern()", "[void]testValid()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/CurrencyValidatorTest.java.CurrencyValidatorTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nTest Case for CurrencyValidator.\n", "original_string": "public class CurrencyValidatorTest {\n\n    private static final char CURRENCY_SYMBOL = '\\u00A4';\n\n    private String usDollar;\n    private String ukPound;\n\n    @BeforeEach\n    protected void setUp() {\n        usDollar = new DecimalFormatSymbols(Locale.US).getCurrencySymbol();\n        ukPound = new DecimalFormatSymbols(Locale.UK).getCurrencySymbol();\n    }\n\n    /**\n     * Test Format Type\n     */\n    @Test\n    public void testFormatType() {\n        assertEquals(1, CurrencyValidator.getInstance().getFormatType(), \"Format Type A\");\n        assertEquals(AbstractNumberValidator.CURRENCY_FORMAT, CurrencyValidator.getInstance().getFormatType(), \"Format Type B\");\n    }\n\n    /**\n     * Test Invalid integer (non decimal) currency values\n     */\n    @Test\n    public void testIntegerInvalid() {\n        final CurrencyValidator validator = new CurrencyValidator(true, false);\n\n        // Invalid UK - has decimals\n        assertFalse(validator.isValid(ukPound + \"1,234.56\", Locale.UK), \"UK positive\");\n        assertFalse(validator.isValid(\"-\" + ukPound + \"1,234.56\", Locale.UK), \"UK negative\");\n\n        // Invalid US - has decimals\n        assertFalse(validator.isValid(usDollar + \"1,234.56\", Locale.US), \"US positive\");\n        assertFalse(validator.isValid(\"(\" + usDollar + \"1,234.56)\", Locale.US), \"US negative\");\n    }\n\n    /**\n     * Test Valid integer (non-decimal) currency values\n     */\n    @Test\n    public void testIntegerValid() {\n        // Set the default Locale\n        final Locale origDefault = Locale.getDefault();\n        Locale.setDefault(Locale.UK);\n\n        final CurrencyValidator validator = new CurrencyValidator();\n        final BigDecimal expected = new BigDecimal(\"1234.00\");\n        final BigDecimal negative = new BigDecimal(\"-1234.00\");\n\n        assertEquals(expected, validator.validate(ukPound + \"1,234\"), \"Default locale\");\n\n        assertEquals(expected, validator.validate(ukPound + \"1,234\", Locale.UK), \"UK locale\");\n        assertEquals(negative, validator.validate(\"-\" + ukPound + \"1,234\", Locale.UK), \"UK negative\");\n\n        assertEquals(expected, validator.validate(usDollar + \"1,234\", Locale.US), \"US locale\");\n        assertEquals(negative, validator.validate(\"(\" + usDollar + \"1,234)\", Locale.US), \"US negative\");\n\n        // Restore the original default\n        Locale.setDefault(origDefault);\n    }\n\n    /**\n     * Test Invalid currency values\n     */\n    @Test\n    public void testInvalid() {\n        final BigDecimalValidator validator = CurrencyValidator.getInstance();\n\n        // Invalid Missing\n        assertFalse(validator.isValid(null), \"isValid() Null Value\");\n        assertFalse(validator.isValid(\"\"), \"isValid() Empty Value\");\n        assertNull(validator.validate(null), \"validate() Null Value\");\n        assertNull(validator.validate(\"\"), \"validate() Empty Value\");\n\n        // Invalid UK\n        assertFalse(validator.isValid(usDollar + \"1,234.56\", Locale.UK), \"UK wrong symbol\");\n        assertFalse(validator.isValid(\"(\" + ukPound + \"1,234.56)\", Locale.UK), \"UK wrong negative\");\n\n        // Invalid US\n        assertFalse(validator.isValid(ukPound + \"1,234.56\", Locale.US), \"US wrong symbol\");\n        assertFalse(validator.isValid(\"-\" + usDollar + \"1,234.56\", Locale.US), \"US wrong negative\");\n    }\n\n    /**\n     * Test currency values with a pattern\n     */\n    @Test\n    public void testPattern() {\n        // Set the default Locale\n        final Locale origDefault = Locale.getDefault();\n        Locale.setDefault(Locale.UK);\n\n        final BigDecimalValidator validator = CurrencyValidator.getInstance();\n        final String basicPattern = CURRENCY_SYMBOL + \"#,##0.000\";\n        final String pattern = basicPattern + \";[\" + basicPattern + \"]\";\n        final BigDecimal expected = new BigDecimal(\"1234.567\");\n        final BigDecimal negative = new BigDecimal(\"-1234.567\");\n\n        // Test Pattern\n        assertEquals(expected, validator.validate(ukPound + \"1,234.567\", pattern), \"default\");\n        assertEquals(negative, validator.validate(\"[\" + ukPound + \"1,234.567]\", pattern), \"negative\");\n        assertEquals(expected, validator.validate(\"1,234.567\", pattern), \"no symbol +ve\");\n        assertEquals(negative, validator.validate(\"[1,234.567]\", pattern), \"no symbol -ve\");\n\n        // Test Pattern & Locale\n        assertEquals(expected, validator.validate(usDollar + \"1,234.567\", pattern, Locale.US), \"default\");\n        assertEquals(negative, validator.validate(\"[\" + usDollar + \"1,234.567]\", pattern, Locale.US), \"negative\");\n        assertEquals(expected, validator.validate(\"1,234.567\", pattern, Locale.US), \"no symbol +ve\");\n        assertEquals(negative, validator.validate(\"[1,234.567]\", pattern, Locale.US), \"no symbol -ve\");\n\n        // invalid\n        assertFalse(validator.isValid(usDollar + \"1,234.567\", pattern), \"invalid symbol\");\n        assertFalse(validator.isValid(ukPound + \"1,234.567\", pattern, Locale.US), \"invalid symbol\");\n\n        // Restore the original default\n        Locale.setDefault(origDefault);\n    }\n\n    /**\n     * Test Valid currency values\n     */\n    @Test\n    public void testValid() {\n        // Set the default Locale\n        final Locale origDefault = Locale.getDefault();\n        Locale.setDefault(Locale.UK);\n\n        final BigDecimalValidator validator = CurrencyValidator.getInstance();\n        final BigDecimal expected = new BigDecimal(\"1234.56\");\n        final BigDecimal negative = new BigDecimal(\"-1234.56\");\n        final BigDecimal noDecimal = new BigDecimal(\"1234.00\");\n        final BigDecimal oneDecimal = new BigDecimal(\"1234.50\");\n\n        assertEquals(expected, validator.validate(ukPound + \"1,234.56\"), \"Default locale\");\n\n        assertEquals(expected, validator.validate(ukPound + \"1,234.56\", Locale.UK), \"UK locale\");\n        assertEquals(negative, validator.validate(\"-\" + ukPound + \"1,234.56\", Locale.UK), \"UK negative\");\n        assertEquals(noDecimal, validator.validate(ukPound + \"1,234\", Locale.UK), \"UK no decimal\");\n        assertEquals(oneDecimal, validator.validate(ukPound + \"1,234.5\", Locale.UK), \"UK 1 decimal\");\n        assertEquals(expected, validator.validate(ukPound + \"1,234.567\", Locale.UK), \"UK 3 decimal\");\n        assertEquals(expected, validator.validate(\"1,234.56\", Locale.UK), \"UK no symbol\");\n\n        assertEquals(expected, validator.validate(usDollar + \"1,234.56\", Locale.US), \"US locale\");\n        assertEquals(negative, validator.validate(\"(\" + usDollar + \"1,234.56)\", Locale.US), \"US negative\");\n        assertEquals(noDecimal, validator.validate(usDollar + \"1,234\", Locale.US), \"US no decimal\");\n        assertEquals(oneDecimal, validator.validate(usDollar + \"1,234.5\", Locale.US), \"US 1 decimal\");\n        assertEquals(expected, validator.validate(usDollar + \"1,234.567\", Locale.US), \"US 3 decimal\");\n        assertEquals(expected, validator.validate(\"1,234.56\", Locale.US), \"US no symbol\");\n\n        // Restore the original default\n        Locale.setDefault(origDefault);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final char CURRENCY_SYMBOL = '\\u00A4';", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "CURRENCY_SYMBOL = '\\u00A4'", "syntax_pass": true}, {"attribute_expression": "private String usDollar;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "usDollar", "syntax_pass": true}, {"attribute_expression": "private String ukPound;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "ukPound", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/checkdigit/VerhoeffCheckDigitTest.java.VerhoeffCheckDigitTest", "name": "VerhoeffCheckDigitTest", "file_path": "src/test/java/org/apache/commons/validator/routines/checkdigit/VerhoeffCheckDigitTest.java", "superclasses": "AbstractCheckDigitTest", "methods": ["[void]testZeroSum()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/checkdigit/VerhoeffCheckDigitTest.java.VerhoeffCheckDigitTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nVerhoeff Check Digit Test.\n", "original_string": "public class VerhoeffCheckDigitTest extends AbstractCheckDigitTest {\n\n    /**\n     * Sets up routine & valid codes.\n     */\n    @BeforeEach\n    protected void setUp() {\n        routine = VerhoeffCheckDigit.VERHOEFF_CHECK_DIGIT;\n        valid = new String[] { \"15\", \"1428570\", \"12345678902\" };\n    }\n\n    /**\n     * Test zero sum\n     */\n    @Override\n    @Test\n    public void testZeroSum() {\n        // ignore, don't run this test\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/routines/checkdigit/CUSIPCheckDigitTest.java.CUSIPCheckDigitTest", "name": "CUSIPCheckDigitTest", "file_path": "src/test/java/org/apache/commons/validator/routines/checkdigit/CUSIPCheckDigitTest.java", "superclasses": "AbstractCheckDigitTest", "methods": ["[void]testValidator336InvalidCheckDigits()", "[void]testValidator336ValidCheckDigits()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/checkdigit/CUSIPCheckDigitTest.java.CUSIPCheckDigitTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nCUSIP Check Digit Test.\n", "original_string": "public class CUSIPCheckDigitTest extends AbstractCheckDigitTest {\n\n    private static final String[] INVALID_CHECK_DIGITS = { \"DUS0421CW\", \"DUS0421CN\", \"DUS0421CE\" };\n\n    private static final String[] VALID_CHECK_DIGITS = { \"DUS0421C5\" };\n\n    /**\n     * Sets up routine & valid codes.\n     */\n    @BeforeEach\n    protected void setUp() {\n        routine = CUSIPCheckDigit.CUSIP_CHECK_DIGIT;\n        valid = new String[] { \"037833100\", \"931142103\", \"837649128\", \"392690QT3\", \"594918104\", \"86770G101\", \"Y8295N109\", \"G8572F100\" };\n        invalid = new String[] { \"0378#3100\" };\n    }\n\n    @Test\n    public void testValidator336InvalidCheckDigits() {\n        for (final String invalidCheckDigit : INVALID_CHECK_DIGITS) {\n            assertFalse(routine.isValid(invalidCheckDigit), () -> \"Should fail: \" + invalidCheckDigit);\n        }\n    }\n\n    @Test\n    public void testValidator336ValidCheckDigits() {\n        for (final String validCheckDigit : VALID_CHECK_DIGITS) {\n            assertTrue(routine.isValid(validCheckDigit), () -> \"Should fail: \" + validCheckDigit);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String[] INVALID_CHECK_DIGITS = { \"DUS0421CW\", \"DUS0421CN\", \"DUS0421CE\" };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "INVALID_CHECK_DIGITS = { \"DUS0421CW\", \"DUS0421CN\", \"DUS0421CE\" }", "syntax_pass": true}, {"attribute_expression": "private static final String[] VALID_CHECK_DIGITS = { \"DUS0421C5\" };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "VALID_CHECK_DIGITS = { \"DUS0421C5\" }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/checkdigit/ISINCheckDigitTest.java.ISINCheckDigitTest", "name": "ISINCheckDigitTest", "file_path": "src/test/java/org/apache/commons/validator/routines/checkdigit/ISINCheckDigitTest.java", "superclasses": "AbstractCheckDigitTest", "methods": ["[void]testValidator345()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/checkdigit/ISINCheckDigitTest.java.ISINCheckDigitTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nISIN Check Digit Test.\n", "original_string": "public class ISINCheckDigitTest extends AbstractCheckDigitTest {\n\n    private static final String[] INVALID_CHECK_DIGITS = { \"US037833100O\", // proper check digit is '5', see above\n            \"BMG8571G109D\", // proper check digit is '6', see above\n            \"AU0000XVGZAD\", // proper check digit is '3', see above\n            \"GB000263494I\", // proper check digit is '6', see above\n            \"FR000402625C\", // proper check digit is '0', see above\n            \"DK000976334H\", // proper check digit is '4', see above\n    };\n\n    /**\n     * Sets up routine & valid codes.\n     */\n    @BeforeEach\n    protected void setUp() {\n        routine = ISINCheckDigit.ISIN_CHECK_DIGIT;\n        valid = new String[] { \"US0378331005\", \"BMG8571G1096\", \"AU0000XVGZA3\", \"GB0002634946\", \"FR0004026250\", \"3133EHHF3\", // see VALIDATOR-422 Valid\n                                                                                                                            // check-digit, but not valid ISIN\n                \"DK0009763344\", \"dk0009763344\", // TODO lowercase is currently accepted, but is this valid?\n                \"AU0000xvgza3\", // lowercase NSIN\n                \"EZ0000000003\", // Invented; for use in ISINValidatorTest\n                \"XS0000000009\", // ditto\n                \"AA0000000006\", // ditto\n        };\n        invalid = new String[] { \"0378#3100\" };\n    }\n\n    @Test\n    public void testValidator345() {\n        for (final String invalidCheckDigit : INVALID_CHECK_DIGITS) {\n            assertFalse(routine.isValid(invalidCheckDigit), () -> \"Should fail: \" + invalidCheckDigit);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String[] INVALID_CHECK_DIGITS = { \"US037833100O\", // proper check digit is '5', see above\n            \"BMG8571G109D\", // proper check digit is '6', see above\n            \"AU0000XVGZAD\", // proper check digit is '3', see above\n            \"GB000263494I\", // proper check digit is '6', see above\n            \"FR000402625C\", // proper check digit is '0', see above\n            \"DK000976334H\", // proper check digit is '4', see above\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "INVALID_CHECK_DIGITS = { \"US037833100O\", // proper check digit is '5', see above\n            \"BMG8571G109D\", // proper check digit is '6', see above\n            \"AU0000XVGZAD\", // proper check digit is '3', see above\n            \"GB000263494I\", // proper check digit is '6', see above\n            \"FR000402625C\", // proper check digit is '0', see above\n            \"DK000976334H\", // proper check digit is '4', see above\n    }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/checkdigit/ModulusTenCheckDigit_toStringTest.java.ModulusTenCheckDigit_toStringTest", "name": "ModulusTenCheckDigit_toStringTest", "file_path": "src/test/java/org/apache/commons/validator/routines/checkdigit/ModulusTenCheckDigit_toStringTest.java", "superclasses": "", "methods": ["[void]testToStringWithRightPosAndSumWeightedDigits()", "[void]testToStringWithLeftPosAndNoSumWeightedDigits()", "[void]testToStringWithEmptyPositionWeight()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/checkdigit/ModulusTenCheckDigit_toStringTest.java.ModulusTenCheckDigit_toStringTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ModulusTenCheckDigit_toStringTest {\n\n    private ModulusTenCheckDigit routine;\n\n    @BeforeEach\n    protected void setUp() {\n        routine = new ModulusTenCheckDigit(new int[] { 1, 2 }, true, true);\n    }\n\n    @Test\n    public void testToStringWithRightPosAndSumWeightedDigits() {\n        String expected = \"ModulusTenCheckDigit[postitionWeight=[1, 2], useRightPos=true, sumWeightedDigits=true]\";\n        assertEquals(expected, routine.toString());\n    }\n\n    @Test\n    public void testToStringWithLeftPosAndNoSumWeightedDigits() {\n        routine = new ModulusTenCheckDigit(new int[] { 3, 4 }, false, false);\n        String expected = \"ModulusTenCheckDigit[postitionWeight=[3, 4], useRightPos=false, sumWeightedDigits=false]\";\n        assertEquals(expected, routine.toString());\n    }\n\n    @Test\n    public void testToStringWithEmptyPositionWeight() {\n        routine = new ModulusTenCheckDigit(new int[] {}, false, false);\n        String expected = \"ModulusTenCheckDigit[postitionWeight=[], useRightPos=false, sumWeightedDigits=false]\";\n        assertEquals(expected, routine.toString());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private ModulusTenCheckDigit routine;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ModulusTenCheckDigit", "name": "routine", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/checkdigit/ModulusTenCheckDigit_isValidTest.java.ModulusTenCheckDigit_isValidTest", "name": "ModulusTenCheckDigit_isValidTest", "file_path": "src/test/java/org/apache/commons/validator/routines/checkdigit/ModulusTenCheckDigit_isValidTest.java", "superclasses": "", "methods": ["[void]testIsValid_BlankOrNullCode()", "[void]testIsValid_NonDigitCheckDigit()", "[void]testIsValid_ValidCode()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ModulusTenCheckDigit_isValidTest {\n\n    @Test\n    void testIsValid_BlankOrNullCode() {\n        ModulusTenCheckDigit checkDigit = new ModulusTenCheckDigit(new int[]{1});\n        assertFalse(checkDigit.isValid(null));\n        assertFalse(checkDigit.isValid(\"\"));\n        assertFalse(checkDigit.isValid(\"   \"));\n    }\n\n    @Test\n    void testIsValid_NonDigitCheckDigit() {\n        ModulusTenCheckDigit checkDigit = new ModulusTenCheckDigit(new int[]{1});\n        assertFalse(checkDigit.isValid(\"123A\"));\n    }\n\n    @Test\n    void testIsValid_ValidCode() {\n        ModulusTenCheckDigit checkDigit = new ModulusTenCheckDigit(new int[]{1});\n        assertTrue(checkDigit.isValid(\"1234\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/routines/checkdigit/IBANCheckDigitTest.java.IBANCheckDigitTest", "name": "IBANCheckDigitTest", "file_path": "src/test/java/org/apache/commons/validator/routines/checkdigit/IBANCheckDigitTest.java", "superclasses": "AbstractCheckDigitTest", "methods": ["[void]testOther()", "[void]testZeroSum()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/checkdigit/IBANCheckDigitTest.java.IBANCheckDigitTest.[]IBANCheckDigitTest()", "src/test/java/org/apache/commons/validator/routines/checkdigit/IBANCheckDigitTest.java.IBANCheckDigitTest.[String]checkDigit(String)", "src/test/java/org/apache/commons/validator/routines/checkdigit/IBANCheckDigitTest.java.IBANCheckDigitTest.[String[]]createInvalidCodes(String[])", "src/test/java/org/apache/commons/validator/routines/checkdigit/IBANCheckDigitTest.java.IBANCheckDigitTest.[String]removeCheckDigit(String)", "src/test/java/org/apache/commons/validator/routines/checkdigit/IBANCheckDigitTest.java.IBANCheckDigitTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nIBAN Check Digit Test.\n", "original_string": "public class IBANCheckDigitTest extends AbstractCheckDigitTest {\n\n    public IBANCheckDigitTest() {\n        checkDigitLth = 2;\n    }\n\n    /**\n     * Returns the check digit (i.e. last character) for a code.\n     *\n     * @param code The code\n     * @return The check digit\n     */\n    @Override\n    protected String checkDigit(final String code) {\n        if (code == null || code.length() <= checkDigitLth) {\n            return \"\";\n        }\n        return code.substring(2, 4);\n    }\n\n    /**\n     * Returns an array of codes with invalid check digits.\n     *\n     * @param codes Codes with valid check digits\n     * @return Codes with invalid check digits\n     */\n    @Override\n    protected String[] createInvalidCodes(final String[] codes) {\n        final List<String> list = new ArrayList<>();\n\n        // create invalid check digit values\n        for (final String code2 : codes) {\n            final String code = removeCheckDigit(code2);\n            final String check = checkDigit(code2);\n            for (int j = 2; j <= 98; j++) { // check digits can be from 02-98 (00 and 01 are not possible)\n                final String curr = j > 9 ? \"\" + j : \"0\" + j;\n                if (!curr.equals(check)) {\n                    list.add(code.substring(0, 2) + curr + code.substring(4));\n                }\n            }\n        }\n\n        return list.toArray(new String[0]);\n    }\n\n    /**\n     * Returns a code with the Check Digits (i.e. characters 3&4) set to \"00\".\n     *\n     * @param code The code\n     * @return The code with the zeroed check digits\n     */\n    @Override\n    protected String removeCheckDigit(final String code) {\n        return code.substring(0, 2) + \"00\" + code.substring(4);\n    }\n\n    /**\n     * Sets up routine & valid codes.\n     */\n    @BeforeEach\n    protected void setUp() {\n        routine = IBANCheckDigit.IBAN_CHECK_DIGIT;\n        valid = new String[] { \"AD1200012030200359100100\", // Andorra\n                \"AE070331234567890123456\", // United Arab Emirates\n                \"AL47212110090000000235698741\", // Albania\n                \"AT611904300234573201\", // Austria\n                \"AZ21NABZ00000000137010001944\", // Azerbaijan\n                \"BA391290079401028494\", // Bosnia and Herzegovina\n                \"BE62510007547061\", // Belgium\n                \"BE68539007547034\", // Belgium\n                \"BG80BNBG96611020345678\", // Bulgaria\n                \"BH67BMAG00001299123456\", // Bahrain\n                \"BI4210000100010000332045181\", // Burundi\n                \"BR1800000000141455123924100C2\", // Brazil\n                \"BY13NBRB3600900000002Z00AB00\", // Belarus\n                \"CH3900700115201849173\", // Switzerland\n                \"CH9300762011623852957\", // Switzerland\n                \"CR05015202001026284066\", // Costa Rica\n                \"CY17002001280000001200527600\", // Cyprus\n                \"CZ6508000000192000145399\", // Czechoslovakia\n                \"DE89370400440532013000\", // Germany\n                \"DJ2110002010010409943020008\", // Djibouti\n                \"DK5000400440116243\", // Denmark\n                \"DO28BAGR00000001212453611324\", // Dominican Republic\n                \"EE382200221020145685\", // Estonia\n                \"ES8023100001180000012345\", // Spain\n                \"FI2112345600000785\", // Finland\n                \"FO6264600001631634\", // Denmark (Faroes)\n                \"FR1420041010050500013M02606\", // France\n                \"GB29NWBK60161331926819\", // UK\n                \"GI75NWBK000000007099453\", // Gibraltar\n                \"GL8964710001000206\", // Denmark (Greenland)\n                \"GR1601101250000000012300695\", // Greece\n                \"GT82TRAJ01020000001210029690\", // Guatemala\n                \"HR1210010051863000160\", // Croatia\n                \"HU42117730161111101800000000\", // Hungary\n                \"IE29AIBK93115212345678\", // Ireland\n                \"IL620108000000099999999\", // Israel\n                \"IQ98NBIQ850123456789012\", // Iraq\n                \"IS140159260076545510730339\", // Iceland\n                \"IT60X0542811101000000123456\", // Italy\n                \"JO94CBJO0010000000000131000302\", // Jordan\n                \"KW81CBKU0000000000001234560101\", // Kuwait\n                \"KZ86125KZT5004100100\", // Kazakhstan\n                \"LB62099900000001001901229114\", // Lebanon\n                \"LC55HEMM000100010012001200023015\", // Saint Lucia\n                \"LI21088100002324013AA\", // Liechtenstein (Principality of)\n                \"LT121000011101001000\", // Lithuania\n                \"LU280019400644750000\", // Luxembourg\n                \"LV80BANK0000435195001\", // Latvia\n                \"MC5811222000010123456789030\", // Monaco\n                \"MD24AG000225100013104168\", // Moldova\n                \"ME25505000012345678951\", // Montenegro\n                \"MK07250120000058984\", // Macedonia, Former Yugoslav Republic of\n                \"MR1300020001010000123456753\", // Mauritania\n                \"MT84MALT011000012345MTLCAST001S\", // Malta\n                \"MU17BOMM0101101030300200000MUR\", // Mauritius\n                \"NL39RABO0300065264\", // Netherlands\n                \"NL91ABNA0417164300\", // Netherlands\n                \"NO9386011117947\", // Norway\n                \"PK36SCBL0000001123456702\", // Pakistan\n                \"PL27114020040000300201355387\", // Poland\n                \"PL60102010260000042270201111\", // Poland\n                \"PS92PALS000000000400123456702\", // Palestine, State of\n                \"PT50000201231234567890154\", // Portugal\n                \"QA58DOHB00001234567890ABCDEFG\", // Qatar\n                \"RO49AAAA1B31007593840000\", // Romania\n                \"RS35260005601001611379\", // Serbia\n                \"RU0204452560040702810412345678901\", // Russia\n                \"SA0380000000608010167519\", // Saudi Arabia\n                \"SC18SSCB11010000000000001497USD\", // Seychelles\n                \"SD8811123456789012\", // Sudan\n                \"SE3550000000054910000003\", // Sweden\n                \"SD2129010501234001\", // Sudan\n                \"SI56191000000123438\", // Slovenia\n                \"SK3112000000198742637541\", // Slovak Republic\n                \"SM86U0322509800000000270100\", // San Marino\n                \"ST68000100010051845310112\", // Sao Tome and Principe\n                \"SV62CENR00000000000000700025\", // El Salvador\n                \"TL380080012345678910157\", // Timor-Leste\n                \"TN5910006035183598478831\", // Tunisia\n                \"TR330006100519786457841326\", // Turkey\n                \"UA213223130000026007233566001\", // Ukraine\n                \"VA59001123000012345678\", // Vatican City State\n                \"VG96VPVG0000012345678901\", // Virgin Islands, British\n                \"XK051212012345678906\", // Republic of Kosovo\n\n                // Codes AA and ZZ will never be used as ISO countries nor in IBANs\n                // add some dummy calculated codes to test the limits\n                // Current minimum length is Norway = 15\n                // Current maximum length is Malta = 31\n                // N.B. These codes will fail online checkers which validate the IBAN format\n                // 234567890123456789012345678901\n                \"AA0200000000053\", \"AA9700000000089\", \"AA9800000000071\", \"ZZ02ZZZZZZZZZZZZZZZZZZZZZZZZZ04\", \"ZZ97ZZZZZZZZZZZZZZZZZZZZZZZZZ40\",\n                \"ZZ98ZZZZZZZZZZZZZZZZZZZZZZZZZ22\", };\n        /*\n         * sources https://intranet.birmingham.ac.uk/finance/documents/public/IBAN.pdf\n         * http://www.paymentscouncil.org.uk/resources_and_publications/ibans_in_europe/\n         */\n        invalid = new String[] { \"510007+47061BE63\", \"IE01AIBK93118702569045\", \"AA0000000000089\", \"AA9900000000053\", };\n        zeroSum = null;\n        missingMessage = \"Invalid Code length=0\";\n\n    }\n\n    @Test\n    public void testOther() throws Exception {\n        try (BufferedReader rdr = new BufferedReader(new InputStreamReader(this.getClass().getResourceAsStream(\"IBANtests.txt\"), \"ASCII\"))) {\n            String line;\n            while ((line = rdr.readLine()) != null) {\n                if (!line.startsWith(\"#\") && !line.isEmpty()) {\n                    if (line.startsWith(\"-\")) {\n                        line = line.substring(1);\n                        Assert.assertFalse(line, routine.isValid(line.replace(\" \", \"\")));\n                    } else {\n                        Assert.assertTrue(line, routine.isValid(line.replace(\" \", \"\")));\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Test zero sum\n     */\n    @Override\n    @Test\n    public void testZeroSum() {\n        // ignore, don't run this test\n\n        // example code used to create dummy IBANs\n//        try {\n//            for(int i=0; i<97;i++) {\n//                String check = String.format(\"ZZ00ZZZZZZZZZZZZZZZZZZZZZZZZZ%02d\", new Object[]{Integer.valueOf(i)});\n//                String chk = routine.calculate(check);\n//                if (chk.equals(\"97\")||chk.equals(\"98\")||chk.equals(\"02\")) {\n//                    System.out.println(check+ \" \"+chk);\n//                }\n//            }\n//        } catch (CheckDigitException e) {\n//            e.printStackTrace();\n//        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/routines/checkdigit/SedolCheckDigitTest.java.SedolCheckDigitTest", "name": "SedolCheckDigitTest", "file_path": "src/test/java/org/apache/commons/validator/routines/checkdigit/SedolCheckDigitTest.java", "superclasses": "AbstractCheckDigitTest", "methods": ["[void]testValidator346()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/checkdigit/SedolCheckDigitTest.java.SedolCheckDigitTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nISIN Check Digit Test.\n", "original_string": "public class SedolCheckDigitTest extends AbstractCheckDigitTest {\n\n    private static final String[] INVALID_CHECK_DIGITS = { \"026349E\", // proper check digit is '4', see above\n            \"087061C\", // proper check digit is '2', see above\n            \"B06LQ9H\", // proper check digit is '7', see above\n            \"343757F\", // proper check digit is '5', see above\n            \"B07LF5F\", // proper check digit is '5', see above\n    };\n\n    /**\n     * Sets up routine & valid codes.\n     */\n    @BeforeEach\n    protected void setUp() {\n        routine = SedolCheckDigit.SEDOL_CHECK_DIGIT;\n        valid = new String[] { \"0263494\", \"0870612\", \"B06LQ97\", \"3437575\", \"B07LF55\", };\n        invalid = new String[] { \"123#567\" };\n        zeroSum = \"0000000\";\n    }\n\n    @Test\n    public void testValidator346() {\n        for (final String invalidCheckDigit : INVALID_CHECK_DIGITS) {\n            assertFalse(routine.isValid(invalidCheckDigit), () -> \"Should fail: \" + invalidCheckDigit);\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String[] INVALID_CHECK_DIGITS = { \"026349E\", // proper check digit is '4', see above\n            \"087061C\", // proper check digit is '2', see above\n            \"B06LQ9H\", // proper check digit is '7', see above\n            \"343757F\", // proper check digit is '5', see above\n            \"B07LF5F\", // proper check digit is '5', see above\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "INVALID_CHECK_DIGITS = { \"026349E\", // proper check digit is '4', see above\n            \"087061C\", // proper check digit is '2', see above\n            \"B06LQ9H\", // proper check digit is '7', see above\n            \"343757F\", // proper check digit is '5', see above\n            \"B07LF5F\", // proper check digit is '5', see above\n    }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/checkdigit/ModulusTenSedolCheckDigitTest.java.ModulusTenSedolCheckDigitTest", "name": "ModulusTenSedolCheckDigitTest", "file_path": "src/test/java/org/apache/commons/validator/routines/checkdigit/ModulusTenSedolCheckDigitTest.java", "superclasses": "AbstractCheckDigitTest", "methods": ["[void]testValidator346()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/checkdigit/ModulusTenSedolCheckDigitTest.java.ModulusTenSedolCheckDigitTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nModulusTenCheckDigit SEDOL Test.\n", "original_string": "public class ModulusTenSedolCheckDigitTest extends AbstractCheckDigitTest {\n\n    private static final String[] INVALID_CHECK_DIGITS = { \"026349E\", // proper check digit is '4', see above\n            \"087061C\", // proper check digit is '2', see above\n            \"B06LQ9H\", // proper check digit is '7', see above\n            \"343757F\", // proper check digit is '5', see above\n            \"B07LF5F\", // proper check digit is '5', see above\n    };\n\n    /**\n     * Sets up routine & valid codes.\n     */\n    @BeforeEach\n    protected void setUp() {\n        routine = new ModulusTenCheckDigit(new int[] { 1, 3, 1, 7, 3, 9, 1 });\n        valid = new String[] { \"0263494\", \"0870612\", \"B06LQ97\", \"3437575\", \"B07LF55\", };\n        invalid = new String[] { \"123#567\" };\n        zeroSum = \"0000000\";\n    }\n\n    @Test\n    public void testValidator346() {\n        for (final String invalidCheckDigit : INVALID_CHECK_DIGITS) {\n            assertFalse(routine.isValid(invalidCheckDigit), () -> \"Should fail: \" + invalidCheckDigit);\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String[] INVALID_CHECK_DIGITS = { \"026349E\", // proper check digit is '4', see above\n            \"087061C\", // proper check digit is '2', see above\n            \"B06LQ9H\", // proper check digit is '7', see above\n            \"343757F\", // proper check digit is '5', see above\n            \"B07LF5F\", // proper check digit is '5', see above\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "INVALID_CHECK_DIGITS = { \"026349E\", // proper check digit is '4', see above\n            \"087061C\", // proper check digit is '2', see above\n            \"B06LQ9H\", // proper check digit is '7', see above\n            \"343757F\", // proper check digit is '5', see above\n            \"B07LF5F\", // proper check digit is '5', see above\n    }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/checkdigit/IBANCheckDigit_isValidTest.java.IBANCheckDigit_isValidTest", "name": "IBANCheckDigit_isValidTest", "file_path": "src/test/java/org/apache/commons/validator/routines/checkdigit/IBANCheckDigit_isValidTest.java", "superclasses": "", "methods": ["[void]testIsValid_ValidCode()", "[void]testIsValid_NullCode()", "[void]testIsValid_ShortCode()", "[void]testIsValid_InvalidCheckDigits()", "[void]testIsValid_CheckDigitException()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class IBANCheckDigit_isValidTest {\n\n    @Test\n    void testIsValid_ValidCode() {\n        IBANCheckDigit checkDigit = new IBANCheckDigit();\n        assertTrue(checkDigit.isValid(\"GB82WEST12345698765432\"));\n    }\n\n    @Test\n    void testIsValid_NullCode() {\n        IBANCheckDigit checkDigit = new IBANCheckDigit();\n        assertFalse(checkDigit.isValid(null));\n    }\n\n    @Test\n    void testIsValid_ShortCode() {\n        IBANCheckDigit checkDigit = new IBANCheckDigit();\n        assertFalse(checkDigit.isValid(\"GB82\"));\n    }\n\n    @Test\n    void testIsValid_InvalidCheckDigits() {\n        IBANCheckDigit checkDigit = new IBANCheckDigit();\n        assertFalse(checkDigit.isValid(\"GB82WEST12345698765400\"));\n        assertFalse(checkDigit.isValid(\"GB82WEST12345698765401\"));\n        assertFalse(checkDigit.isValid(\"GB82WEST12345698765499\"));\n    }\n\n    @Test\n    void testIsValid_CheckDigitException() {\n        IBANCheckDigit checkDigit = new IBANCheckDigit();\n        assertFalse(checkDigit.isValid(\"GB82WEST123456987654XX\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/routines/checkdigit/ISBNCheckDigit_isValidTest.java.ISBNCheckDigit_isValidTest", "name": "ISBNCheckDigit_isValidTest", "file_path": "src/test/java/org/apache/commons/validator/routines/checkdigit/ISBNCheckDigit_isValidTest.java", "superclasses": "", "methods": ["[void]testIsValidWithNullCode()", "[void]testIsValidWithValidISBN10()", "[void]testIsValidWithInvalidISBN10()", "[void]testIsValidWithValidISBN13()", "[void]testIsValidWithInvalidISBN13()", "[void]testIsValidWithInvalidLength()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/checkdigit/ISBNCheckDigit_isValidTest.java.ISBNCheckDigit_isValidTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ISBNCheckDigit_isValidTest {\n    private CheckDigit routine;\n\n    @BeforeEach\n    protected void setUp() {\n        routine = ISBNCheckDigit.ISBN_CHECK_DIGIT;\n    }\n\n    @Test\n    public void testIsValidWithNullCode() {\n        assertFalse(routine.isValid(null), \"isValid() with null code\");\n    }\n\n    @Test\n    public void testIsValidWithValidISBN10() {\n        assertTrue(routine.isValid(\"020163385X\"), \"isValid() with valid ISBN-10 code\");\n    }\n\n    @Test\n    public void testIsValidWithInvalidISBN10() {\n        assertFalse(routine.isValid(\"0201633851\"), \"isValid() with invalid ISBN-10 code\");\n    }\n\n    @Test\n    public void testIsValidWithValidISBN13() {\n        assertTrue(routine.isValid(\"9780072129519\"), \"isValid() with valid ISBN-13 code\");\n    }\n\n    @Test\n    public void testIsValidWithInvalidISBN13() {\n        assertFalse(routine.isValid(\"9780072129518\"), \"isValid() with invalid ISBN-13 code\");\n    }\n\n    @Test\n    public void testIsValidWithInvalidLength() {\n        assertFalse(routine.isValid(\"123456789\"), \"isValid() with length 9\");\n        assertFalse(routine.isValid(\"12345678901\"), \"isValid() with length 11\");\n        assertFalse(routine.isValid(\"123456789012\"), \"isValid() with length 12\");\n        assertFalse(routine.isValid(\"12345678901234\"), \"isValid() with length 14\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CheckDigit routine;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CheckDigit", "name": "routine", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/checkdigit/ISBNCheckDigitTest.java.ISBNCheckDigitTest", "name": "ISBNCheckDigitTest", "file_path": "src/test/java/org/apache/commons/validator/routines/checkdigit/ISBNCheckDigitTest.java", "superclasses": "AbstractCheckDigitTest", "methods": ["[void]testInvalidLength()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/checkdigit/ISBNCheckDigitTest.java.ISBNCheckDigitTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nISBN-10/ISBN-13 Check Digit Test.\n", "original_string": "public class ISBNCheckDigitTest extends AbstractCheckDigitTest {\n\n    /**\n     * Sets up routine & valid codes.\n     */\n    @BeforeEach\n    protected void setUp() {\n        routine = ISBNCheckDigit.ISBN_CHECK_DIGIT;\n        valid = new String[] { \"9780072129519\", \"9780764558313\", \"1930110995\", \"020163385X\", \"1590596277\", // ISBN-10 Ubuntu Book\n                \"9781590596272\" // ISBN-13 Ubuntu Book\n        };\n        missingMessage = \"ISBN Code is missing\";\n        zeroSum = \"000000000000\";\n    }\n\n    /**\n     * Sets up routine & valid codes.\n     */\n    @Test\n    public void testInvalidLength() {\n        assertFalse(routine.isValid(\"123456789\"), \"isValid() Lth 9 \");\n        assertFalse(routine.isValid(\"12345678901\"), \"isValid() Lth 11\");\n        assertFalse(routine.isValid(\"123456789012\"), \"isValid() Lth 12\");\n        assertFalse(routine.isValid(\"12345678901234\"), \"isValid() Lth 14\");\n\n        try {\n            routine.calculate(\"12345678\");\n            fail(\"calculate() Lth 8 - expected exception\");\n        } catch (final Exception e) {\n            assertEquals(e.getMessage(), \"Invalid ISBN Length = 8\", \"calculate() Lth 8\");\n        }\n\n        try {\n            routine.calculate(\"1234567890\");\n            fail(\"calculate() Lth 10 - expected exception\");\n        } catch (final Exception e) {\n            assertEquals(\"Invalid ISBN Length = 10\", e.getMessage(), \"calculate() Lth 10\");\n        }\n\n        try {\n            routine.calculate(\"12345678901\");\n            fail(\"calculate() Lth 11 - expected exception\");\n        } catch (final Exception e) {\n            assertEquals(\"Invalid ISBN Length = 11\", e.getMessage(), \"calculate() Lth 11\");\n        }\n\n        try {\n            routine.calculate(\"1234567890123\");\n            fail(\"calculate() Lth 13 - expected exception\");\n        } catch (final Exception e) {\n            assertEquals(\"Invalid ISBN Length = 13\", e.getMessage(), \"calculate() Lth 13\");\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/routines/checkdigit/IBANCheckDigit_calculateTest.java.IBANCheckDigit_calculateTest", "name": "IBANCheckDigit_calculateTest", "file_path": "src/test/java/org/apache/commons/validator/routines/checkdigit/IBANCheckDigit_calculateTest.java", "superclasses": "", "methods": ["[void]testCalculateValidCode()", "[void]testCalculateInvalidCodeLength()", "[void]testCalculateNullCode()", "[void]testIsValidWithValidCode()", "[void]testIsValidWithInvalidCodeLength()", "[void]testIsValidWithNullCode()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/checkdigit/IBANCheckDigit_calculateTest.java.IBANCheckDigit_calculateTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IBANCheckDigit_calculateTest {\n\n    private IBANCheckDigit ibanCheckDigit;\n\n    @BeforeEach\n    public void setUp() {\n        ibanCheckDigit = new IBANCheckDigit();\n    }\n\n    @Test\n    public void testCalculateValidCode() throws CheckDigitException {\n        String code = \"GB82WEST12345698765432\";\n        String expectedCheckDigit = \"82\";\n        assertEquals(expectedCheckDigit, ibanCheckDigit.calculate(code));\n    }\n\n    @Test\n    public void testCalculateInvalidCodeLength() {\n        String code = \"GB82\";\n        CheckDigitException exception = assertThrows(CheckDigitException.class, () -> {\n            ibanCheckDigit.calculate(code);\n        });\n        assertEquals(\"Invalid Code length=4\", exception.getMessage());\n    }\n\n    @Test\n    public void testCalculateNullCode() {\n        CheckDigitException exception = assertThrows(CheckDigitException.class, () -> {\n            ibanCheckDigit.calculate(null);\n        });\n        assertEquals(\"Invalid Code length=0\", exception.getMessage());\n    }\n\n    @Test\n    public void testIsValidWithValidCode() {\n        String code = \"GB82WEST12345698765432\";\n        assertTrue(ibanCheckDigit.isValid(code));\n    }\n\n    @Test\n    public void testIsValidWithInvalidCodeLength() {\n        String code = \"GB82\";\n        assertFalse(ibanCheckDigit.isValid(code));\n    }\n\n    @Test\n    public void testIsValidWithNullCode() {\n        assertFalse(ibanCheckDigit.isValid(null));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private IBANCheckDigit ibanCheckDigit;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "IBANCheckDigit", "name": "ibanCheckDigit", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/routines/checkdigit/ModulusTenCUSIPCheckDigitTest.java.ModulusTenCUSIPCheckDigitTest", "name": "ModulusTenCUSIPCheckDigitTest", "file_path": "src/test/java/org/apache/commons/validator/routines/checkdigit/ModulusTenCUSIPCheckDigitTest.java", "superclasses": "AbstractCheckDigitTest", "methods": ["[void]testValidator336InvalidCheckDigits()", "[void]testValidator336ValidCheckDigits()"], "method_uris": ["src/test/java/org/apache/commons/validator/routines/checkdigit/ModulusTenCUSIPCheckDigitTest.java.ModulusTenCUSIPCheckDigitTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "\nModulusTenCheckDigit CUSIP Test.\n", "original_string": "public class ModulusTenCUSIPCheckDigitTest extends AbstractCheckDigitTest {\n\n    private static final String[] INVALID_CHECK_DIGITS = { \"DUS0421CW\", \"DUS0421CN\", \"DUS0421CE\" };\n\n    private static final String[] VALID_CHECK_DIGITS = { \"DUS0421C5\" };\n\n    /**\n     * Sets up routine & valid codes.\n     */\n    @BeforeEach\n    protected void setUp() {\n        routine = new ModulusTenCheckDigit(new int[] { 1, 2 }, true, true);\n        valid = new String[] { \"037833100\", \"931142103\", \"837649128\", \"392690QT3\", \"594918104\", \"86770G101\", \"Y8295N109\", \"G8572F100\" };\n        invalid = new String[] { \"0378#3100\" };\n    }\n\n    @Test\n    public void testValidator336InvalidCheckDigits() {\n        for (final String invalidCheckDigit : INVALID_CHECK_DIGITS) {\n            assertFalse(routine.isValid(invalidCheckDigit), () -> \"Should fail: \" + invalidCheckDigit);\n        }\n    }\n\n    @Test\n    public void testValidator336ValidCheckDigits() {\n        for (final String validCheckDigit : VALID_CHECK_DIGITS) {\n            assertTrue(routine.isValid(validCheckDigit), () -> \"Should fail: \" + validCheckDigit);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String[] INVALID_CHECK_DIGITS = { \"DUS0421CW\", \"DUS0421CN\", \"DUS0421CE\" };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "INVALID_CHECK_DIGITS = { \"DUS0421CW\", \"DUS0421CN\", \"DUS0421CE\" }", "syntax_pass": true}, {"attribute_expression": "private static final String[] VALID_CHECK_DIGITS = { \"DUS0421C5\" };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "VALID_CHECK_DIGITS = { \"DUS0421C5\" }", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/util/Flags_equalsTest.java.Flags_equalsTest", "name": "Flags_equalsTest", "file_path": "src/test/java/org/apache/commons/validator/util/Flags_equalsTest.java", "superclasses": "", "methods": ["[void]testEqualsSameObject()", "[void]testEqualsDifferentObjectType()", "[void]testEqualsDifferentFlags()", "[void]testEqualsSameFlags()", "[void]testEqualsAfterTurnOn()", "[void]testEqualsAfterTurnOff()", "[void]testEqualsHashCodeConsistency()", "[void]testEqualsStateVerification()"], "method_uris": ["src/test/java/org/apache/commons/validator/util/Flags_equalsTest.java.Flags_equalsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Flags_equalsTest {\n\n    private Flags flags1;\n    private Flags flags2;\n\n    @BeforeEach\n    public void setUp() {\n        flags1 = new Flags(0xFFFFFFFFFFFFFFFFL);\n        flags2 = new Flags(0xFFFFFFFFFFFFFFFFL);\n    }\n\n    @Test\n    public void testEqualsSameObject() {\n        assertTrue(flags1.equals(flags1));\n    }\n\n    @Test\n    public void testEqualsDifferentObjectType() {\n        assertFalse(flags1.equals(\"Not a Flags object\"));\n    }\n\n    @Test\n    public void testEqualsDifferentFlags() {\n        flags2.turnOff(0x8000000000000000L);\n        assertFalse(flags1.equals(flags2));\n    }\n\n    @Test\n    public void testEqualsSameFlags() {\n        assertTrue(flags1.equals(flags2));\n    }\n\n    @Test\n    public void testEqualsAfterTurnOn() {\n        flags2.turnOff(0x8000000000000000L);\n        flags2.turnOn(0x8000000000000000L);\n        assertTrue(flags1.equals(flags2));\n    }\n\n    @Test\n    public void testEqualsAfterTurnOff() {\n        flags2.turnOff(0x8000000000000000L);\n        assertFalse(flags1.equals(flags2));\n    }\n\n    @Test\n    public void testEqualsHashCodeConsistency() {\n        if (flags1.equals(flags2)) {\n            assertEquals(flags1.hashCode(), flags2.hashCode());\n        }\n    }\n\n    @Test\n    public void testEqualsStateVerification() {\n        final long highOrderBit = 0x8000000000000000L;\n        assertTrue(flags1.isOn(highOrderBit));\n        assertTrue(flags2.isOn(highOrderBit));\n        assertTrue(flags1.equals(flags2));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Flags flags1;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Flags", "name": "flags1", "syntax_pass": true}, {"attribute_expression": "private Flags flags2;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Flags", "name": "flags2", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/util/ValidatorUtilsTest.java.ValidatorUtilsTest", "name": "ValidatorUtilsTest", "file_path": "src/test/java/org/apache/commons/validator/util/ValidatorUtilsTest.java", "superclasses": "", "methods": ["[void]testCopyFastHashMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTests {@link ValidatorUtilsTest}.\n", "original_string": "public class ValidatorUtilsTest {\n\n    @Test\n    public void testCopyFastHashMap() {\n        final FastHashMap original = new FastHashMap();\n        original.put(\"key1\", \"value1\");\n        original.put(\"key2\", \"value2\");\n        original.put(\"key3\", \"value3\");\n        original.setFast(true);\n        final FastHashMap copy = ValidatorUtils.copyFastHashMap(original);\n        assertEquals(original, copy);\n      }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/util/FlagsTest.java.FlagsTest", "name": "FlagsTest", "file_path": "src/test/java/org/apache/commons/validator/util/FlagsTest.java", "superclasses": "", "methods": ["[void]testClear()", "[void]testClone()", "[void]testEqualsObject()", "[void]testGetFlags()", "[void]testHashCode()", "[void]testIsOnIsFalseWhenNotAllFlagsInArgumentAreOn()", "[void]testIsOnIsTrueWhenHighOrderBitIsSetAndQueried()", "[void]testIsOnOff()", "[void]testToString()", "[void]testTurnOff()", "[void]testTurnOffAll()", "[void]testTurnOnAll()", "[void]testTurnOnOff()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nTest the Flags class.\n", "original_string": "public class FlagsTest {\n\n    /**\n     * Declare some flags for testing.\n     */\n    private static final long LONG_FLAG = 1;\n    private static final long LONG_FLAG_2 = 2;\n    private static final int INT_FLAG = 4;\n\n    @Test\n    public void testClear() {\n        final Flags f = new Flags(98432);\n        f.clear();\n        assertEquals(0, f.getFlags());\n    }\n\n    /**\n     * Test for Object clone()\n     */\n    @Test\n    public void testClone() {\n    }\n\n    /**\n     * Test for boolean equals(Object)\n     */\n    @Test\n    public void testEqualsObject() {\n    }\n\n    @Test\n    public void testGetFlags() {\n        final Flags f = new Flags(45);\n        assertEquals(f.getFlags(), 45);\n    }\n\n    @Test\n    public void testHashCode() {\n        final Flags f = new Flags(45);\n        assertEquals(f.hashCode(), 45);\n    }\n\n    @Test\n    public void testIsOnIsFalseWhenNotAllFlagsInArgumentAreOn() {\n        final Flags first = new Flags(1);\n        final long firstAndSecond = 3;\n\n        assertFalse(first.isOn(firstAndSecond));\n    }\n\n    @Test\n    public void testIsOnIsTrueWhenHighOrderBitIsSetAndQueried() {\n        final Flags allOn = new Flags(~0);\n        final long highOrderBit = 0x8000000000000000L;\n\n        assertTrue(allOn.isOn(highOrderBit));\n    }\n\n    @Test\n    public void testIsOnOff() {\n        final Flags f = new Flags();\n        f.turnOn(LONG_FLAG);\n        f.turnOn(INT_FLAG);\n        assertTrue(f.isOn(LONG_FLAG));\n        assertTrue(!f.isOff(LONG_FLAG));\n\n        assertTrue(f.isOn(INT_FLAG));\n        assertTrue(!f.isOff(INT_FLAG));\n\n        assertTrue(f.isOff(LONG_FLAG_2));\n    }\n\n    /**\n     * Test for String toString()\n     */\n    @Test\n    public void testToString() {\n        final Flags f = new Flags();\n        String s = f.toString();\n        assertEquals(64, s.length());\n\n        f.turnOn(INT_FLAG);\n        s = f.toString();\n        assertEquals(64, s.length());\n\n        assertEquals(\"0000000000000000000000000000000000000000000000000000000000000100\", s);\n    }\n\n    @Test\n    public void testTurnOff() {\n    }\n\n    @Test\n    public void testTurnOffAll() {\n        final Flags f = new Flags(98432);\n        f.turnOffAll();\n        assertEquals(0, f.getFlags());\n    }\n\n    @Test\n    public void testTurnOnAll() {\n        final Flags f = new Flags();\n        f.turnOnAll();\n        assertEquals(~0, f.getFlags());\n    }\n\n    @Test\n    public void testTurnOnOff() {\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final long LONG_FLAG = 1;", "docstring": "\nDeclare some flags for testing.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "LONG_FLAG = 1", "syntax_pass": true}, {"attribute_expression": "private static final long LONG_FLAG_2 = 2;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "LONG_FLAG_2 = 2", "syntax_pass": true}, {"attribute_expression": "private static final int INT_FLAG = 4;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "INT_FLAG = 4", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/util/Flags_toStringTest.java.Flags_toStringTest", "name": "Flags_toStringTest", "file_path": "src/test/java/org/apache/commons/validator/util/Flags_toStringTest.java", "superclasses": "", "methods": ["[void]testToStringAllFlagsOff()", "[void]testToStringAllFlagsOn()", "[void]testToStringSingleFlagOn()", "[void]testToStringMultipleFlagsOn()", "[void]testToStringTurnOffFlag()"], "method_uris": ["src/test/java/org/apache/commons/validator/util/Flags_toStringTest.java.Flags_toStringTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Flags_toStringTest {\n\n    private Flags flags;\n\n    @BeforeEach\n    public void setUp() {\n        flags = new Flags();\n    }\n\n    @Test\n    public void testToStringAllFlagsOff() {\n        flags.turnOffAll();\n        assertEquals(\"0000000000000000000000000000000000000000000000000000000000000000\", flags.toString());\n    }\n\n    @Test\n    public void testToStringAllFlagsOn() {\n        flags.turnOnAll();\n        assertEquals(\"1111111111111111111111111111111111111111111111111111111111111111\", flags.toString());\n    }\n\n    @Test\n    public void testToStringSingleFlagOn() {\n        flags.turnOn(1L);\n        assertEquals(\"0000000000000000000000000000000000000000000000000000000000000001\", flags.toString());\n    }\n\n    @Test\n    public void testToStringMultipleFlagsOn() {\n        flags.turnOn(1L);\n        flags.turnOn(4L);\n        assertEquals(\"0000000000000000000000000000000000000000000000000000000000000101\", flags.toString());\n    }\n\n    @Test\n    public void testToStringTurnOffFlag() {\n        flags.turnOnAll();\n        flags.turnOff(1L);\n        assertEquals(\"1111111111111111111111111111111111111111111111111111111111111110\", flags.toString());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Flags flags;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Flags", "name": "flags", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/util/Flags_cloneTest.java.Flags_cloneTest", "name": "Flags_cloneTest", "file_path": "src/test/java/org/apache/commons/validator/util/Flags_cloneTest.java", "superclasses": "", "methods": ["[void]testCloneWithAllFlagsOn()", "[void]testCloneWithAllFlagsOff()", "[void]testCloneWithMixedFlags()"], "method_uris": ["src/test/java/org/apache/commons/validator/util/Flags_cloneTest.java.Flags_cloneTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Flags_cloneTest {\n    private Flags flags;\n\n    @BeforeEach\n    public void setUp() {\n        flags = new Flags(0xFFFFFFFFFFFFFFFFL);\n    }\n\n    @Test\n    public void testCloneWithAllFlagsOn() {\n        Flags clonedFlags = (Flags) flags.clone();\n        assertEquals(flags.getFlags(), clonedFlags.getFlags());\n        assertTrue(flags.equals(clonedFlags));\n    }\n\n    @Test\n    public void testCloneWithAllFlagsOff() {\n        flags.turnOffAll();\n        Flags clonedFlags = (Flags) flags.clone();\n        assertEquals(flags.getFlags(), clonedFlags.getFlags());\n        assertTrue(flags.equals(clonedFlags));\n    }\n\n    @Test\n    public void testCloneWithMixedFlags() {\n        flags.turnOff(0xAAAAAAAAAAAAAAAAL); // Turn off every other flag\n        Flags clonedFlags = (Flags) flags.clone();\n        assertEquals(flags.getFlags(), clonedFlags.getFlags());\n        assertTrue(flags.equals(clonedFlags));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Flags flags;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Flags", "name": "flags", "syntax_pass": true}]}, {"uris": "src/test/java/org/apache/commons/validator/util/ValidatorUtils_copyFastHashMapTest.java.ValidatorUtils_copyFastHashMapTest", "name": "ValidatorUtils_copyFastHashMapTest", "file_path": "src/test/java/org/apache/commons/validator/util/ValidatorUtils_copyFastHashMapTest.java", "superclasses": "", "methods": ["[void]testCopyFastHashMap()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ValidatorUtils_copyFastHashMapTest {\n\n    @Test\n    public void testCopyFastHashMap() {\n        FastHashMap original = new FastHashMap();\n        original.put(\"key1\", new Msg());\n        original.put(\"key2\", new Arg());\n        original.put(\"key3\", new Var());\n        original.put(\"key4\", \"value4\");\n\n        FastHashMap copied = ValidatorUtils.copyFastHashMap(original);\n\n        assertEquals(original.size(), copied.size());\n        assertTrue(copied.get(\"key1\") instanceof Msg);\n        assertTrue(copied.get(\"key2\") instanceof Arg);\n        assertTrue(copied.get(\"key3\") instanceof Var);\n        assertEquals(\"value4\", copied.get(\"key4\"));\n        assertFalse(original.getFast() == copied.getFast());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/util/ValidatorUtils_copyMapTest.java.ValidatorUtils_copyMapTest", "name": "ValidatorUtils_copyMapTest", "file_path": "src/test/java/org/apache/commons/validator/util/ValidatorUtils_copyMapTest.java", "superclasses": "", "methods": ["[void]testCopyMapWithMsg()", "[void]testCopyMapWithArg()", "[void]testCopyMapWithVar()", "[void]testCopyMapWithOtherTypes()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ValidatorUtils_copyMapTest {\n\n    @Test\n    public void testCopyMapWithMsg() {\n        Map<String, Object> original = new HashMap<>();\n        Msg msg = new Msg();\n        msg.setName(\"testMsg\");\n        original.put(\"msgKey\", msg);\n\n        Map<String, Object> copy = ValidatorUtils.copyMap(original);\n        assertTrue(copy.containsKey(\"msgKey\"));\n        assertTrue(copy.get(\"msgKey\") instanceof Msg);\n        assertEquals(msg.getName(), ((Msg) copy.get(\"msgKey\")).getName());\n    }\n\n    @Test\n    public void testCopyMapWithArg() {\n        Map<String, Object> original = new HashMap<>();\n        Arg arg = new Arg();\n        arg.setName(\"testArg\");\n        original.put(\"argKey\", arg);\n\n        Map<String, Object> copy = ValidatorUtils.copyMap(original);\n        assertTrue(copy.containsKey(\"argKey\"));\n        assertTrue(copy.get(\"argKey\") instanceof Arg);\n        assertEquals(arg.getName(), ((Arg) copy.get(\"argKey\")).getName());\n    }\n\n    @Test\n    public void testCopyMapWithVar() {\n        Map<String, Object> original = new HashMap<>();\n        Var var = new Var();\n        var.setName(\"testVar\");\n        original.put(\"varKey\", var);\n\n        Map<String, Object> copy = ValidatorUtils.copyMap(original);\n        assertTrue(copy.containsKey(\"varKey\"));\n        assertTrue(copy.get(\"varKey\") instanceof Var);\n        assertEquals(var.getName(), ((Var) copy.get(\"varKey\")).getName());\n    }\n\n    @Test\n    public void testCopyMapWithOtherTypes() {\n        Map<String, Object> original = new HashMap<>();\n        original.put(\"stringKey\", \"stringValue\");\n        original.put(\"intKey\", 123);\n\n        Map<String, Object> copy = ValidatorUtils.copyMap(original);\n        assertEquals(\"stringValue\", copy.get(\"stringKey\"));\n        assertEquals(123, copy.get(\"intKey\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/util/ValidatorUtils_replaceTest.java.ValidatorUtils_replaceTest", "name": "ValidatorUtils_replaceTest", "file_path": "src/test/java/org/apache/commons/validator/util/ValidatorUtils_replaceTest.java", "superclasses": "", "methods": ["[void]testReplace_AllNonNull()", "[void]testReplace_AnyNull()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ValidatorUtils_replaceTest {\n\n    @Test\n    void testReplace_AllNonNull() {\n        String result = ValidatorUtils.replace(\"Hello World\", \"World\", \"Universe\");\n        assertEquals(\"Hello Universe\", result);\n    }\n\n    @Test\n    void testReplace_AnyNull() {\n        String result = ValidatorUtils.replace(null, \"key\", \"value\");\n        assertNull(result);\n\n        result = ValidatorUtils.replace(\"Hello World\", null, \"value\");\n        assertEquals(\"Hello World\", result);\n\n        result = ValidatorUtils.replace(\"Hello World\", \"key\", null);\n        assertEquals(\"Hello World\", result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/org/apache/commons/validator/util/ValidatorUtils_getValueAsStringTest.java.ValidatorUtils_getValueAsStringTest", "name": "ValidatorUtils_getValueAsStringTest", "file_path": "src/test/java/org/apache/commons/validator/util/ValidatorUtils_getValueAsStringTest.java", "superclasses": "", "methods": ["[void]testGetValueAsString_PropertyFound()", "[void]testGetValueAsString_PropertyNotFound()", "[void]testGetValueAsString_PropertyIsNull()", "[void]testGetValueAsString_PropertyIsStringArray()", "[void]testGetValueAsString_PropertyIsEmptyStringArray()", "[void]testGetValueAsString_PropertyIsCollection()", "[void]testGetValueAsString_PropertyIsEmptyCollection()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    public static class TestBean {\n        private String someProperty;\n        private String nullProperty;\n        private String[] stringArrayProperty;\n        private String[] emptyStringArrayProperty;\n        private Collection<String> collectionProperty;\n        private Collection<String> emptyCollectionProperty;\n\n        public String getSomeProperty() {\n            return someProperty;\n        }\n\n        public void setSomeProperty(String someProperty) {\n            this.someProperty = someProperty;\n        }\n\n        public String getNullProperty() {\n            return nullProperty;\n        }\n\n        public void setNullProperty(String nullProperty) {\n            this.nullProperty = nullProperty;\n        }\n\n        public String[] getStringArrayProperty() {\n            return stringArrayProperty;\n        }\n\n        public void setStringArrayProperty(String[] stringArrayProperty) {\n            this.stringArrayProperty = stringArrayProperty;\n        }\n\n        public String[] getEmptyStringArrayProperty() {\n            return emptyStringArrayProperty;\n        }\n\n        public void setEmptyStringArrayProperty(String[] emptyStringArrayProperty) {\n            this.emptyStringArrayProperty = emptyStringArrayProperty;\n        }\n\n        public Collection<String> getCollectionProperty() {\n            return collectionProperty;\n        }\n\n        public void setCollectionProperty(Collection<String> collectionProperty) {\n            this.collectionProperty = collectionProperty;\n        }\n\n        public Collection<String> getEmptyCollectionProperty() {\n            return emptyCollectionProperty;\n        }\n\n        public void setEmptyCollectionProperty(Collection<String> emptyCollectionProperty) {\n            this.emptyCollectionProperty = emptyCollectionProperty;\n        }\n    }", "definition": "    public static class TestBean", "class_docstring": "", "name": "TestBean", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private String someProperty;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "someProperty", "syntax_pass": true}, {"attribute_expression": "private String nullProperty;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "nullProperty", "syntax_pass": true}, {"attribute_expression": "private String[] stringArrayProperty;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String[]", "name": "stringArrayProperty", "syntax_pass": true}, {"attribute_expression": "private String[] emptyStringArrayProperty;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String[]", "name": "emptyStringArrayProperty", "syntax_pass": true}, {"attribute_expression": "private Collection<String> collectionProperty;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "collectionProperty", "syntax_pass": true}, {"attribute_expression": "private Collection<String> emptyCollectionProperty;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Collection<String>", "name": "emptyCollectionProperty", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public String getSomeProperty() {\n            return someProperty;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getSomeProperty", "params": [], "body": "                                        {\n            return someProperty;\n        }", "signature": "public String getSomeProperty()"}, {"syntax_pass": true, "original_string": "        public void setSomeProperty(String someProperty) {\n            this.someProperty = someProperty;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setSomeProperty", "params": [{"name": "someProperty", "type": "String"}], "body": "                                                         {\n            this.someProperty = someProperty;\n        }", "signature": "public void setSomeProperty(String someProperty)"}, {"syntax_pass": true, "original_string": "        public String getNullProperty() {\n            return nullProperty;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "getNullProperty", "params": [], "body": "                                        {\n            return nullProperty;\n        }", "signature": "public String getNullProperty()"}, {"syntax_pass": true, "original_string": "        public void setNullProperty(String nullProperty) {\n            this.nullProperty = nullProperty;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setNullProperty", "params": [{"name": "nullProperty", "type": "String"}], "body": "                                                         {\n            this.nullProperty = nullProperty;\n        }", "signature": "public void setNullProperty(String nullProperty)"}, {"syntax_pass": true, "original_string": "        public String[] getStringArrayProperty() {\n            return stringArrayProperty;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String[]", "classes": []}, "name": "getStringArrayProperty", "params": [], "body": "                                                 {\n            return stringArrayProperty;\n        }", "signature": "public String[] getStringArrayProperty()"}, {"syntax_pass": true, "original_string": "        public void setStringArrayProperty(String[] stringArrayProperty) {\n            this.stringArrayProperty = stringArrayProperty;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setStringArrayProperty", "params": [{"name": "stringArrayProperty", "type": "String[]"}], "body": "                                                                         {\n            this.stringArrayProperty = stringArrayProperty;\n        }", "signature": "public void setStringArrayProperty(String[] stringArrayProperty)"}, {"syntax_pass": true, "original_string": "        public String[] getEmptyStringArrayProperty() {\n            return emptyStringArrayProperty;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String[]", "classes": []}, "name": "getEmptyStringArrayProperty", "params": [], "body": "                                                      {\n            return emptyStringArrayProperty;\n        }", "signature": "public String[] getEmptyStringArrayProperty()"}, {"syntax_pass": true, "original_string": "        public void setEmptyStringArrayProperty(String[] emptyStringArrayProperty) {\n            this.emptyStringArrayProperty = emptyStringArrayProperty;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setEmptyStringArrayProperty", "params": [{"name": "emptyStringArrayProperty", "type": "String[]"}], "body": "                                                                                   {\n            this.emptyStringArrayProperty = emptyStringArrayProperty;\n        }", "signature": "public void setEmptyStringArrayProperty(String[] emptyStringArrayProperty)"}, {"syntax_pass": true, "original_string": "        public Collection<String> getCollectionProperty() {\n            return collectionProperty;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<String>", "classes": []}, "name": "getCollectionProperty", "params": [], "body": "                                                          {\n            return collectionProperty;\n        }", "signature": "public Collection<String> getCollectionProperty()"}, {"syntax_pass": true, "original_string": "        public void setCollectionProperty(Collection<String> collectionProperty) {\n            this.collectionProperty = collectionProperty;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setCollectionProperty", "params": [{"name": "collectionProperty", "type": "Collection<String>"}], "body": "                                                                                 {\n            this.collectionProperty = collectionProperty;\n        }", "signature": "public void setCollectionProperty(Collection<String> collectionProperty)"}, {"syntax_pass": true, "original_string": "        public Collection<String> getEmptyCollectionProperty() {\n            return emptyCollectionProperty;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Collection<String>", "classes": []}, "name": "getEmptyCollectionProperty", "params": [], "body": "                                                               {\n            return emptyCollectionProperty;\n        }", "signature": "public Collection<String> getEmptyCollectionProperty()"}, {"syntax_pass": true, "original_string": "        public void setEmptyCollectionProperty(Collection<String> emptyCollectionProperty) {\n            this.emptyCollectionProperty = emptyCollectionProperty;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "setEmptyCollectionProperty", "params": [{"name": "emptyCollectionProperty", "type": "Collection<String>"}], "body": "                                                                                           {\n            this.emptyCollectionProperty = emptyCollectionProperty;\n        }", "signature": "public void setEmptyCollectionProperty(Collection<String> emptyCollectionProperty)"}]}], "class_docstring": "", "original_string": "public class ValidatorUtils_getValueAsStringTest {\n\n    public static class TestBean {\n        private String someProperty;\n        private String nullProperty;\n        private String[] stringArrayProperty;\n        private String[] emptyStringArrayProperty;\n        private Collection<String> collectionProperty;\n        private Collection<String> emptyCollectionProperty;\n\n        public String getSomeProperty() {\n            return someProperty;\n        }\n\n        public void setSomeProperty(String someProperty) {\n            this.someProperty = someProperty;\n        }\n\n        public String getNullProperty() {\n            return nullProperty;\n        }\n\n        public void setNullProperty(String nullProperty) {\n            this.nullProperty = nullProperty;\n        }\n\n        public String[] getStringArrayProperty() {\n            return stringArrayProperty;\n        }\n\n        public void setStringArrayProperty(String[] stringArrayProperty) {\n            this.stringArrayProperty = stringArrayProperty;\n        }\n\n        public String[] getEmptyStringArrayProperty() {\n            return emptyStringArrayProperty;\n        }\n\n        public void setEmptyStringArrayProperty(String[] emptyStringArrayProperty) {\n            this.emptyStringArrayProperty = emptyStringArrayProperty;\n        }\n\n        public Collection<String> getCollectionProperty() {\n            return collectionProperty;\n        }\n\n        public void setCollectionProperty(Collection<String> collectionProperty) {\n            this.collectionProperty = collectionProperty;\n        }\n\n        public Collection<String> getEmptyCollectionProperty() {\n            return emptyCollectionProperty;\n        }\n\n        public void setEmptyCollectionProperty(Collection<String> emptyCollectionProperty) {\n            this.emptyCollectionProperty = emptyCollectionProperty;\n        }\n    }\n\n    @Test\n    public void testGetValueAsString_PropertyFound() throws Exception {\n        TestBean bean = new TestBean();\n        String property = \"someProperty\";\n        String expectedValue = \"someValue\";\n\n        PropertyUtils.setProperty(bean, property, expectedValue);\n\n        String result = ValidatorUtils.getValueAsString(bean, property);\n\n        assertEquals(expectedValue, result);\n    }\n\n    @Test\n    public void testGetValueAsString_PropertyNotFound() throws Exception {\n        TestBean bean = new TestBean();\n        String property = \"nonExistentProperty\";\n\n        String result = ValidatorUtils.getValueAsString(bean, property);\n\n        assertNull(result);\n    }\n\n    @Test\n    public void testGetValueAsString_PropertyIsNull() throws Exception {\n        TestBean bean = new TestBean();\n        String property = \"nullProperty\";\n\n        PropertyUtils.setProperty(bean, property, null);\n\n        String result = ValidatorUtils.getValueAsString(bean, property);\n\n        assertNull(result);\n    }\n\n    @Test\n    public void testGetValueAsString_PropertyIsStringArray() throws Exception {\n        TestBean bean = new TestBean();\n        String property = \"stringArrayProperty\";\n        String[] stringArray = {\"value1\", \"value2\"};\n\n        PropertyUtils.setProperty(bean, property, stringArray);\n\n        String result = ValidatorUtils.getValueAsString(bean, property);\n\n        assertEquals(stringArray.toString(), result);\n    }\n\n    @Test\n    public void testGetValueAsString_PropertyIsEmptyStringArray() throws Exception {\n        TestBean bean = new TestBean();\n        String property = \"emptyStringArrayProperty\";\n        String[] emptyStringArray = {};\n\n        PropertyUtils.setProperty(bean, property, emptyStringArray);\n\n        String result = ValidatorUtils.getValueAsString(bean, property);\n\n        assertEquals(\"\", result);\n    }\n\n    @Test\n    public void testGetValueAsString_PropertyIsCollection() throws Exception {\n        TestBean bean = new TestBean();\n        String property = \"collectionProperty\";\n        Collection<String> collection = Collections.singletonList(\"value1\");\n\n        PropertyUtils.setProperty(bean, property, collection);\n\n        String result = ValidatorUtils.getValueAsString(bean, property);\n\n        assertEquals(collection.toString(), result);\n    }\n\n    @Test\n    public void testGetValueAsString_PropertyIsEmptyCollection() throws Exception {\n        TestBean bean = new TestBean();\n        String property = \"emptyCollectionProperty\";\n        Collection<String> emptyCollection = Collections.emptyList();\n\n        PropertyUtils.setProperty(bean, property, emptyCollection);\n\n        String result = ValidatorUtils.getValueAsString(bean, property);\n\n        assertEquals(\"\", result);\n    }\n}", "super_interfaces": [], "fields": []}]