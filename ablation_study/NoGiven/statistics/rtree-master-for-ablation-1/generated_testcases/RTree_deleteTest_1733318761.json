[{"strategy": "retry", "code": "\npackage com.github.davidmoten.rtree;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.github.davidmoten.rtree.geometry.Geometry;\nimport com.github.davidmoten.rtree.geometry.Rectangle;\n\nimport rx.Observable;\n\npublic class RTree_deleteTest {\n\n    private RTree<Object, Rectangle> tree;\n\n    @Before\n    public void setUp() {\n        tree = RTree.star().maxChildren(4).<Object, Rectangle> create();\n    }\n\n    @Test\n    public void testDeleteSingleEntry() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        tree = tree.add(e1);\n        Observable<RTree<Object, Rectangle>> result = tree.delete(Observable.just(e1), false);\n        result.forEach(t -> assertTrue(t.entries().isEmpty().toBlocking().single()));\n    }\n\n    @Test\n    public void testDeleteMultipleEntries() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        Entry<Object, Rectangle> e2 = RTreeTest.e(2);\n        List<Entry<Object, Rectangle>> entries = Arrays.asList(e1, e2);\n        tree = tree.add(entries);\n        Observable<RTree<Object, Rectangle>> result = tree.delete(Observable.from(entries), false);\n        result.forEach(t -> assertEquals(0L, t.entries().count().toBlocking().single()));\n    }\n\n    @Test\n    public void testDeleteAllEntries() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        Entry<Object, Rectangle> e2 = RTreeTest.e(2);\n        List<Entry<Object, Rectangle>> entries = Arrays.asList(e1, e2);\n        tree = tree.add(entries);\n        Observable<RTree<Object, Rectangle>> result = tree.delete(Observable.from(entries), true);\n        result.forEach(t -> assertEquals(0L, t.entries().count().toBlocking().single()));\n    }\n\n    @Test\n    public void testDeleteNonExistentEntry() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        Entry<Object, Rectangle> e2 = RTreeTest.e(2);\n        tree = tree.add(e1);\n        Observable<RTree<Object, Rectangle>> result = tree.delete(Observable.just(e2), false);\n        result.forEach(t -> assertEquals(1L, t.entries().count().toBlocking().single()));\n    }\n\n    @Test\n    public void testDeleteAndAddEntry() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        tree = tree.add(e1);\n        Observable<RTree<Object, Rectangle>> result = tree.delete(Observable.just(e1), false);\n        result.forEach(t -> {\n            assertTrue(t.entries().isEmpty().toBlocking().single());\n            t = t.add(e1);\n            assertEquals(1L, t.entries().count().toBlocking().single());\n        });\n    }\n\n    @Test\n    public void testDeleteAndSearchEntry() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        tree = tree.add(e1);\n        Observable<RTree<Object, Rectangle>> result = tree.delete(Observable.just(e1), false);\n        result.forEach(t -> {\n            assertTrue(t.entries().isEmpty().toBlocking().single());\n            t.search(e1.geometry()).forEach(entry -> assertTrue(false));\n        });\n    }\n\n    private static Entry<Object, Rectangle> e(int id) {\n        return Entries.entry(new Object(), rectangle(0, 0, id, id));\n    }\n}\n"}]