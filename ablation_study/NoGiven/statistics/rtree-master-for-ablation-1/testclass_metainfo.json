[{"uris": "src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest", "name": "RTreeTest", "file_path": "src/test/java/com/github/davidmoten/rtree/RTreeTest.java", "superclasses": "", "methods": ["[void]testInstantiation()", "[void]testSearchEmptyTree()", "[void]testSearchOnOneItem()", "[void]testTreeWithOneItemIsNotEmpty()", "[void]testVisualizerWithEmptyTree()", "[void]testBulkLoadingEmpty()", "[void]testBulkLoadingWithOneItemIsNotEmpty()", "[void]testBulkLoadingEntryCount()", "[void]testSearchOnOneItemOnBulkLoadingRTree()", "[void]testAddObservable()", "[void]testPerformanceAndEntriesCount()", "[void]testSearchOfPoint()", "[void]testSearchOfPointWithinDistance()", "[void]testDeleteWithGeometry()", "[void]testDeleteIssue81()", "[void]testDepthWith0()", "[void]testContext()", "[void]testIterableDeletion()", "[void]testObservableDeletion()", "[void]testFullDeletion()", "[void]testPartialDeletion()", "[void]testDepthWithMaxChildren3Entries1()", "[void]testDepthWithMaxChildren3Entries2()", "[void]testDepthWithMaxChildren3Entries3()", "[void]testDepthWithMaxChildren3Entries4()", "[void]testDepthWithMaxChildren3Entries8()", "[void]testDepthWithMaxChildren3Entries10()", "[void]testSizeIsZeroIfTreeEmpty()", "[void]testSizeIsOneIfTreeHasOneEntry()", "[void]testSizeIsFiveIfTreeHasFiveEntries()", "[void]testSizeAfterDelete()", "[void]testDeletionThatRemovesAllNodesChildren()", "[void]testDeleteOfEntryThatDoesNotExistFromTreeOfOneEntry()", "[void]testDeleteFromEmptyTree()", "[void]testBuilder1()", "[void]testDeletionOfEntryThatDoesNotExistFromNonLeaf()", "[void]testBuilder2()", "[void]testBuilder3()", "[void]testBuilder4()", "[void]testBackpressureIterationForUpTo1000Entries()", "[void]testNearestSameDirection()", "[void]testNearestDifferentDirections()", "[void]testNearestToAPoint()", "[void]testNearestReturnsInOrder()", "[void]testNearestHonoursUnsubscribeJustBeforeCompletion()", "[void]testVisualizer()", "[void]testSplitterRStarThrowsExceptionOnEmptyList()", "[void]testSearchOnGreekDataUsingFlatBuffersFactory()", "[void]testVisualizerWithGreekData()", "[void]testDeleteOneFromOne()", "[void]testDeleteOneFromTreeWithDepthGreaterThanOne()", "[void]testDeleteOneFromLargeTreeThenDeleteAllAndEnsureEmpty()", "[void]testDeleteOnlyDeleteOneIfThereAreMoreThanMaxChildren()", "[void]testDeleteAllIfThereAreMoreThanMaxChildren()", "[void]testDeleteItemThatIsNotPresentDoesNothing()", "[void]testExampleOnReadMe()", "[void]testUnsubscribe()", "[void]testSearchConditionAlwaysFalse()", "[void]testAddOverload()", "[void]testDeleteOverload()", "[void]testStandardRTreeSearch()", "[void]testStandardRTreeSearch2()", "[void]testBulkLoadingTreeAndStarTreeReturnsSameAsStandardRTree()", "[void]testUnsubscribeWhileIteratingLeafNode()", "[void]testUnsubscribeWhileIteratingNonLeafNode()", "[void]testSearchWithIntersectsRectangleFunction()", "[void]testSearchWithIntersectsPointFunctionReturnsOne()", "[void]testSearchWithIntersectsPointFunctionReturnsNone()", "[void]testSearchWithDistanceFunctionIntersectsMbrButNotActualGeometry()", "[void]testSearchWithDistanceFunctionIntersectsMbrAndActualGeometry()", "[void]testSearchWithDistanceFunctionIntersectsNothing()", "[void]calculateDepthOfEmptyTree()", "[void]calculateAsStringOfEmptyTree()", "[void]testForMeiZhao()", "[void]testSearchWithCircleFindsCentreOnly()", "[void]testSearchWithCircleFindsAll()", "[void]testSearchWithLineFindsAll()", "[void]testSearchWithLineFindsOne()", "[void]testSearchWithLineFindsNone()", "[void]testRTreeRootMbrWhenRTreeEmpty()", "[void]testRTreeRootMbrWhenRTreeNonEmpty()", "[void]testIntersectsPointLine()", "[void]testGroupByIssue40()", "[void]testBackpressureForOverflow()", "[void]testDeleteIssue81d()", "[void]testDeleteIssue81f()", "[void]testSearchGreekEarthquakesDouble()"], "method_uris": ["src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest.[void]testSaveFileException()", "src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest.[List<Entry<Object, Geometry>>]createRandomEntries(long)", "src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest.[RTree<Object, Geometry>]createRandomRTree(long)", "src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest.[Entry<Object, Geometry>]randomEntry()", "src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest.[Subscriber<Entry<Object, T>>]createBackpressureSubscriber(Collection<Entry<Object, T>>)", "src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest.[void]testBuiltTree(RTree<Object, Point>)", "src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest.[RTree<Object, Rectangle>]create(int,int)", "src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest.[Func1<Entry<T, ?>, T>]toValue()", "src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest.[Point]nextPoint()", "src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest.[Entry<Object, Rectangle>]e(int)", "src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest.[Entry<Object, Rectangle>]e2(int)", "src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest.[Rectangle]r(int)", "src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest.[Rectangle]r(double,double)", "src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest.[Rectangle]r(float,float)", "src/test/java/com/github/davidmoten/rtree/RTreeTest.java.RTreeTest.[Rectangle]random(Precision)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RTreeTest {\n\n    private static final double PRECISION = 0.000001;\n\n    @Test\n    public void testInstantiation() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertTrue(tree.entries().isEmpty().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertTrue(tree.search(r(1)).isEmpty().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchOnOneItem() {\n        RTree<Object, Rectangle> tree = RTree.create();\n        Entry<Object, Rectangle> entry = e(1);\n        tree = tree.add(entry);\n        assertEquals(Arrays.asList(entry), tree.search(r(1)).toList().toBlocking().single());\n    }\n\n    @Test\n    public void testTreeWithOneItemIsNotEmpty() {\n        RTree<Object, Geometry> tree = RTree.create().add(e(1));\n        assertFalse(tree.isEmpty());\n    }\n\n    // @Test(expected = IOException.class)\n    public void testSaveFileException() throws IOException {\n        FileLock lock = null;\n        RandomAccessFile file = null;\n        try {\n            String filename = \"target/locked.png\";\n            File f = new File(filename);\n            f.createNewFile();\n            file = new RandomAccessFile(f, \"rw\");\n            lock = file.getChannel().lock();\n            RTree.create().visualize(600, 600).save(filename, \"PNG\");\n        } finally {\n            try {\n                lock.release();\n                file.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    @Test\n    public void testVisualizerWithEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        tree.visualize(600, 600).save(\"target/tree.png\", \"PNG\");\n    }\n\n    @Test\n    public void testBulkLoadingEmpty() {\n        RTree<Object, Point> tree = RTree.create(new ArrayList<Entry<Object, Point>>());\n        assertTrue(tree.entries().isEmpty().toBlocking().single());\n    }\n\n    @Test\n    public void testBulkLoadingWithOneItemIsNotEmpty() {\n        RTree<Object, Rectangle> tree = RTree.create(Arrays.asList(e(1)));\n        assertFalse(tree.isEmpty());\n    }\n\n    @Test\n    public void testBulkLoadingEntryCount() {\n        List<Entry<Integer, Geometry>> entries = new ArrayList<Entry<Integer, Geometry>>(10000);\n        for (int i = 1; i <= 10000; i++) {\n            Point point = nextPoint();\n            // System.out.println(\"point(\" + point.x() + \",\" + point.y() +\n            // \"),\");\n            entries.add(new EntryDefault<Integer, Geometry>(i, point));\n        }\n        RTree<Integer, Geometry> tree = RTree.create(entries);\n        int entrySize = tree.entries().count().toBlocking().single();\n        System.out.println(\"entry count: \" + entrySize);\n        assertEquals(entrySize, entries.size());\n    }\n\n    @Test\n    public void testSearchOnOneItemOnBulkLoadingRTree() {\n        Entry<Object, Rectangle> entry = e(1);\n        RTree<Object, Rectangle> tree = RTree.create(Arrays.asList(entry));\n        assertEquals(Arrays.asList(entry), tree.search(r(1)).toList().toBlocking().single());\n    }\n\n    @Test\n    public void testAddObservable() {\n        Entry<Object, Rectangle> e1 = e(1);\n        Entry<Object, Rectangle> e2 = e2(1);\n\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e1)\n                .add(e2).delete(e1);\n        RTree<Object, Rectangle> emptyTree = RTree.maxChildren(4).create();\n        rx.Observable<?> deletedtree = emptyTree.add(tree.entries());\n        assertEquals(2, (int) deletedtree.count().toBlocking().single());\n    }\n\n    @Test\n    public void testPerformanceAndEntriesCount() {\n\n        long repeats = Long.parseLong(System.getProperty(\"r\", \"1\"));\n        long n = Long.parseLong(System.getProperty(\"n\", \"10000\"));\n        RTree<Object, Geometry> tree = null;\n        while (--repeats >= 0) {\n            long t = System.currentTimeMillis();\n            tree = createRandomRTree(n);\n            long diff = System.currentTimeMillis() - t;\n            System.out.println(\"inserts/second = \" + ((double) n / diff * 1000));\n        }\n        assertEquals(n, (int) tree.entries().count().toBlocking().single());\n\n        long t = System.currentTimeMillis();\n        Entry<Object, Geometry> entry = tree.search(rectangle(0, 0, 500, 500)).first().toBlocking()\n                .single();\n        long diff = System.currentTimeMillis() - t;\n        System.out.println(\"found \" + entry);\n        System.out.println(\"time to get nearest with \" + n + \" entries=\" + diff);\n\n    }\n\n    @Test\n    public void testSearchOfPoint() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        List<Entry<Object, Geometry>> list = tree.search(point(1, 1)).toList().toBlocking()\n                .single();\n        assertEquals(1, list.size());\n        assertEquals(value, list.get(0).value());\n    }\n\n    @Test\n    public void testSearchOfPointWithinDistance() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        List<Entry<Object, Geometry>> list = tree.search(point(1, 1), 2).toList().toBlocking()\n                .single();\n        assertEquals(1, list.size());\n        assertEquals(value, list.get(0).value());\n    }\n\n    static List<Entry<Object, Geometry>> createRandomEntries(long n) {\n        List<Entry<Object, Geometry>> list = new ArrayList<Entry<Object, Geometry>>();\n        for (long i = 0; i < n; i++)\n            list.add(randomEntry());\n        return list;\n    }\n\n    static RTree<Object, Geometry> createRandomRTree(long n) {\n        RTree<Object, Geometry> tree = RTree.maxChildren(4).create();\n        for (long i = 0; i < n; i++) {\n            Entry<Object, Geometry> entry = randomEntry();\n            tree = tree.add(entry);\n        }\n        return tree;\n    }\n\n    static Entry<Object, Geometry> randomEntry() {\n        return entry(new Object(), (Geometry) random(Precision.SINGLE));\n    }\n\n    @Test\n    public void testDeleteWithGeometry() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).create();\n        Entry<Object, Rectangle> entry = e(1);\n        Entry<Object, Rectangle> entry2 = e2(1);\n        tree = tree.add(entry).add(entry2);\n\n        tree = tree.delete(entry.value(), entry.geometry(), true);\n        List<Entry<Object, Rectangle>> entries = tree.entries().toList().toBlocking().single();\n        assertTrue(entries.contains(entry2) && !entries.contains(entry));\n    }\n    \n    @Test\n    public void testDeleteIssue81() {\n        RTree<Object, Point> t = RTree.create();\n        t = t.add(1, Geometries.pointGeographic(123, 23));\n        t = t.delete(1, Geometries.pointGeographic(123, 23));\n        assertEquals(0, t.size());\n    }\n\n    @Test\n    public void testDepthWith0() {\n        RTree<Object, Geometry> tree = RTree.create();\n        tree = tree.add(createRandomEntries(5));\n        List<Entry<Object, Geometry>> entries = tree.entries().toList().toBlocking().single();\n        RTree<Object, Geometry> deletedTree = tree.delete(entries, true);\n        assertTrue(deletedTree.isEmpty());\n    }\n\n    @Test\n    public void testContext() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertNotNull(tree.context());\n    }\n\n    @Test\n    public void testIterableDeletion() {\n        RTree<Object, Rectangle> tree = RTree.create();\n        Entry<Object, Rectangle> entry1 = e(1);\n        Entry<Object, Rectangle> entry2 = e(2);\n        Entry<Object, Rectangle> entry3 = e(3);\n        tree = tree.add(entry1).add(entry2).add(entry3);\n\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        list.add(entry1);\n        list.add(entry3);\n        RTree<Object, Rectangle> deletedTree = tree.delete(list);\n        List<Entry<Object, Rectangle>> entries = deletedTree.entries().toList().toBlocking()\n                .single();\n        assertTrue(\n                entries.contains(entry2) && !entries.contains(entry1) && !entries.contains(entry3));\n    }\n\n    @Test\n    public void testObservableDeletion() {\n        RTree<Object, Rectangle> tree = RTree.create();\n        Entry<Object, Rectangle> entry1 = e(1);\n        Entry<Object, Rectangle> entry2 = e(3);\n        Entry<Object, Rectangle> entry3 = e(5);\n        tree = tree.add(entry1).add(entry2).add(entry3);\n        rx.Observable<Entry<Object, Rectangle>> obs = tree.search(r(2), 5);\n        rx.Observable<RTree<Object, Rectangle>> deleted = tree.delete(obs, true);\n        assertTrue(deleted.elementAt(deleted.count().toBlocking().single() - 1).count().toBlocking()\n                .single() == 1);\n    }\n\n    @Test\n    public void testFullDeletion() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).create();\n        Entry<Object, Rectangle> entry = e(1);\n        tree = tree.add(entry).add(entry);\n        tree = tree.delete(entry, true);\n        assertTrue(tree.isEmpty());\n    }\n\n    @Test\n    public void testPartialDeletion() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).create();\n        Entry<Object, Rectangle> entry = e(1);\n        tree = tree.add(entry).add(entry);\n        tree = tree.delete(entry, false);\n        List<Entry<Object, Rectangle>> entries = tree.entries().toList().toBlocking().single();\n        int countEntries = tree.entries().count().toBlocking().single();\n        assertTrue(countEntries == 1);\n        assertTrue(entries.get(0).equals(entry));\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries1() {\n        RTree<Object, Rectangle> tree = create(3, 1);\n        assertEquals(1, tree.calculateDepth());\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries2() {\n        RTree<Object, Rectangle> tree = create(3, 2);\n        assertEquals(1, tree.calculateDepth());\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries3() {\n        RTree<Object, Rectangle> tree = create(3, 3);\n        assertEquals(1, tree.calculateDepth());\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries4() {\n        RTree<Object, Rectangle> tree = create(3, 4);\n        assertEquals(2, tree.calculateDepth());\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries8() {\n        RTree<Object, Rectangle> tree = create(3, 8);\n        tree.visualize(800, 800).save(new File(\"target/treeLittle.png\"), \"PNG\");\n        assertEquals(3, tree.calculateDepth());\n    }\n\n    @Test\n    public void testDepthWithMaxChildren3Entries10() {\n        RTree<Object, Rectangle> tree = create(3, 10);\n        assertEquals(3, tree.calculateDepth());\n    }\n\n    @Test\n    public void testSizeIsZeroIfTreeEmpty() {\n        assertEquals(0, create(3, 0).size());\n    }\n\n    @Test\n    public void testSizeIsOneIfTreeHasOneEntry() {\n        assertEquals(1, create(3, 1).size());\n    }\n\n    @Test\n    public void testSizeIsFiveIfTreeHasFiveEntries() {\n        assertEquals(5, create(3, 5).size());\n    }\n\n    @Test\n    public void testSizeAfterDelete() {\n        Entry<Object, Rectangle> entry = e(1);\n        RTree<Object, Rectangle> tree = create(3, 0).add(entry).add(entry).add(entry).delete(entry);\n        assertEquals(2, tree.size());\n\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeletionThatRemovesAllNodesChildren() {\n        RTree<Object, Rectangle> tree = create(3, 8);\n        tree = tree.add(e(10));\n        // node children are now 1,2 and 3,4\n        assertEquals(3, tree.calculateDepth());\n        tree = tree.delete(e(10));\n        // node children are now 1,2 and 3\n        assertEquals(3, tree.calculateDepth());\n        assertEquals(Sets.newHashSet(e(1), e(2), e(3), e(4), e(5), e(6), e(7), e(8)),\n                Sets.newHashSet(tree.entries().toList().toBlocking().single()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeleteOfEntryThatDoesNotExistFromTreeOfOneEntry() {\n        RTree<Object, Geometry> tree = RTree.create().add(e(1));\n        tree = tree.delete(e(2));\n        assertEquals(Lists.newArrayList(e(1)), tree.entries().toList().toBlocking().single());\n    }\n\n    @Test\n    public void testDeleteFromEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        tree = tree.delete(e(2));\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testBuilder1() {\n        RTree<Object, Point> tree = RTree.minChildren(1).maxChildren(4)\n                .selector(new SelectorMinimalAreaIncrease()).splitter(new SplitterQuadratic())\n                .create();\n        testBuiltTree(tree);\n    }\n\n    @Test\n    public void testDeletionOfEntryThatDoesNotExistFromNonLeaf() {\n        RTree<Object, Rectangle> tree = create(3, 100).delete(e(1000));\n        assertEquals(100, (int) tree.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testBuilder2() {\n        RTree<Object, Point> tree = RTree.selector(new SelectorMinimalAreaIncrease()).minChildren(1)\n                .maxChildren(4).splitter(new SplitterQuadratic()).create();\n        testBuiltTree(tree);\n    }\n\n    @Test\n    public void testBuilder3() {\n        RTree<Object, Point> tree = RTree.maxChildren(4).selector(new SelectorMinimalAreaIncrease())\n                .minChildren(1).splitter(new SplitterQuadratic()).create();\n        testBuiltTree(tree);\n    }\n\n    @Test\n    public void testBuilder4() {\n        RTree<Object, Point> tree = RTree.splitter(new SplitterQuadratic()).maxChildren(4)\n                .selector(new SelectorMinimalAreaIncrease()).minChildren(1).create();\n        testBuiltTree(tree);\n    }\n\n    @Test\n    public void testBackpressureIterationForUpTo1000Entries() {\n        List<Entry<Object, Rectangle>> entries = Utilities.entries1000(Precision.SINGLE);\n        RTree<Object, Rectangle> tree = RTree.star().create();\n        for (int i = 1; i <= 1000; i++) {\n            tree = tree.add(entries.get(i - 1));\n            final HashSet<Entry<Object, Rectangle>> set = new HashSet<Entry<Object, Rectangle>>();\n            tree.entries().subscribe(createBackpressureSubscriber(set));\n            assertEquals(new HashSet<Entry<Object, Rectangle>>(entries.subList(0, i)), set);\n        }\n    }\n\n    private static <T extends Geometry> Subscriber<Entry<Object, T>> createBackpressureSubscriber(\n            final Collection<Entry<Object, T>> collection) {\n        return new Subscriber<Entry<Object, T>>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Entry<Object, T> t) {\n                collection.add(t);\n                request(1);\n            }\n        };\n    }\n\n    private void testBuiltTree(RTree<Object, Point> tree) {\n        for (int i = 1; i <= 1000; i++) {\n            tree = tree.add(i, Geometries.point(i, i));\n        }\n        assertEquals(1000, (int) tree.entries().count().toBlocking().single());\n    }\n\n    private static RTree<Object, Rectangle> create(int maxChildren, int n) {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(maxChildren).create();\n        for (int i = 1; i <= n; i++)\n            tree = tree.add(e(i));\n        return tree;\n    }\n\n    @Test\n    public void testNearestSameDirection() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e(1))\n                .add(e(2)).add(e(3)).add(e(10)).add(e(11));\n        List<Entry<Object, Rectangle>> list = tree.nearest(r(9), 10, 2).toList().toBlocking()\n                .single();\n        assertEquals(2, list.size());\n        System.out.println(list);\n        assertEquals(10, list.get(0).geometry().mbr().x1(), PRECISION);\n        assertEquals(11, list.get(1).geometry().mbr().x1(), PRECISION);\n\n        List<Entry<Object, Rectangle>> list2 = tree.nearest(r(10), 8, 3).toList().toBlocking()\n                .single();\n        assertEquals(2, list2.size());\n        assertEquals(10, list2.get(1).geometry().mbr().x1(), PRECISION);\n        assertEquals(11, list2.get(0).geometry().mbr().x1(), PRECISION);\n    }\n\n    @Test\n    public void testNearestDifferentDirections() {\n        RTree<Object, Geometry> tree = RTree.maxChildren(4).create().add(e(1)).add(e(2)).add(e(3))\n                .add(e(9)).add(e(10));\n        List<Entry<Object, Geometry>> list = tree.nearest(r(6), 10, 2).toList().toBlocking()\n                .single();\n        assertEquals(2, list.size());\n        assertEquals(3, list.get(0).geometry().mbr().x1(), PRECISION);\n        assertEquals(9, list.get(1).geometry().mbr().x1(), PRECISION);\n    }\n\n    @Test\n    public void testNearestToAPoint() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        List<Entry<Object, Geometry>> list = tree.nearest(point(2, 2), 3, 2).toList().toBlocking()\n                .single();\n        assertEquals(1, list.size());\n        assertEquals(value, list.get(0).value());\n    }\n\n    @Test\n    public void testNearestReturnsInOrder() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1))\n                .add(value, point(2, 2)).add(value, point(3, 3)).add(value, point(4, 4));\n        List<Entry<Object, Geometry>> list = tree.nearest(point(0, 0), 10, 10).toList().toBlocking()\n                .single();\n        System.out.println(list);\n        assertEquals(4, list.size());\n        assertEquals(point(1, 1), list.get(0).geometry());\n        assertEquals(point(2, 2), list.get(1).geometry());\n        assertEquals(point(3, 3), list.get(2).geometry());\n        assertEquals(point(4, 4), list.get(3).geometry());\n    }\n\n    @Test\n    public void testNearestHonoursUnsubscribeJustBeforeCompletion() {\n        Object value = new Object();\n        RTree<Object, Geometry> tree = RTree.create().add(value, point(1, 1));\n        final AtomicBoolean completeCalled = new AtomicBoolean(false);\n        tree.nearest(point(0, 0), 10, 10).subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n                completeCalled.set(true);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Object t) {\n                unsubscribe();\n            }\n        });\n        assertFalse(completeCalled.get());\n    }\n\n    @Test\n    public void testVisualizer() {\n        List<Entry<Object, Geometry>> entries = createRandomEntries(1000);\n        int maxChildren = 8;\n        RTree<Object, Geometry> tree = RTree.maxChildren(maxChildren).create().add(entries);\n        tree.visualize(600, 600).save(\"target/tree.png\");\n\n        RTree<Object, Geometry> tree2 = RTree.star().maxChildren(maxChildren).create().add(entries);\n        tree2.visualize(600, 600).save(\"target/tree2.png\");\n\n        RTree<Object, Geometry> tree3 = RTree.maxChildren(maxChildren).create(entries);\n        tree3.visualize(600, 600).save(\"target/tree3.png\");\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testSplitterRStarThrowsExceptionOnEmptyList() {\n        SplitterRStar spl = new SplitterRStar();\n        spl.split(Collections.<HasGeometry>emptyList(), 4);\n    }\n\n    @Test\n    public void testSearchOnGreekDataUsingFlatBuffersFactory() {\n\n    }\n\n    @Test\n    public void testVisualizerWithGreekData() {\n        List<Entry<Object, Point>> entries = GreekEarthquakes.entriesList(Precision.DOUBLE);\n        int maxChildren = 8;\n        RTree<Object, Point> tree = RTree.maxChildren(maxChildren)\n                .factory(new FactoryFlatBuffers<Object, Geometry>(new Func1<Object, byte[]>() {\n                    @Override\n                    public byte[] call(Object o) {\n                        return \"boo\".getBytes();\n                    }\n                }, new Func1<byte[], Object>() {\n                    @Override\n                    public Object call(byte[] t) {\n                        return new String(t);\n                    }\n                })).<Object, Point>create().add(entries);\n        tree.visualize(2000, 2000).save(\"target/greek.png\");\n\n        // do search\n        int found = tree.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)).count().toBlocking()\n                .single();\n        System.out.println(\"found=\" + found);\n        assertEquals(22, found);\n\n        RTree<Object, Point> tree2 = RTree.maxChildren(maxChildren).star().<Object, Point>create()\n                .add(entries);\n        tree2.visualize(2000, 2000).save(\"target/greek2.png\");\n\n        RTree<Object, Point> tree3 = RTree.maxChildren(maxChildren).create(entries);\n        tree3.visualize(2000, 2000).save(\"target/greek3.png\");\n    }\n\n    @Test\n    public void testDeleteOneFromOne() {\n        Entry<Object, Rectangle> e1 = e(1);\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e1)\n                .delete(e1);\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testDeleteOneFromTreeWithDepthGreaterThanOne() {\n        Entry<Object, Rectangle> e1 = e(1);\n        RTree<Object, Rectangle> tree = RTree.maxChildren(4).<Object, Rectangle>create().add(e1)\n                .add(e(2)).add(e(3)).add(e(4)).add(e(5)).add(e(6)).add(e(7)).add(e(8)).add(e(9))\n                .add(e(10)).delete(e1);\n        assertEquals(9, (int) tree.entries().count().toBlocking().single());\n        assertFalse(tree.entries().contains(e1).toBlocking().single());\n    }\n\n    @Test\n    public void testDeleteOneFromLargeTreeThenDeleteAllAndEnsureEmpty() {\n        int n = 10000;\n        RTree<Object, Geometry> tree = createRandomRTree(n).add(e(1)).add(e(2)).delete(e(1));\n        assertEquals(n + 1, (int) tree.entries().count().toBlocking().single());\n        assertFalse(tree.entries().contains(e(1)).toBlocking().single());\n        assertTrue(tree.entries().contains(e(2)).toBlocking().single());\n        n++;\n        assertEquals(n, tree.size());\n\n        for (Entry<Object, Geometry> entry : tree.entries().toBlocking().toIterable()) {\n            tree = tree.delete(entry);\n            n--;\n            assertEquals(n, tree.size());\n        }\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n        assertTrue(tree.isEmpty());\n    }\n\n    @Test\n    public void testDeleteOnlyDeleteOneIfThereAreMoreThanMaxChildren() {\n        Entry<Object, Rectangle> e1 = e(1);\n        int count = RTree.maxChildren(4).create().add(e1).add(e1).add(e1).add(e1).add(e1).delete(e1)\n                .search(e1.geometry().mbr()).count().toBlocking().single();\n        assertEquals(4, count);\n    }\n\n    @Test\n    public void testDeleteAllIfThereAreMoreThanMaxChildren() {\n        Entry<Object, Rectangle> e1 = e(1);\n        int count = RTree.maxChildren(4).create().add(e1).add(e1).add(e1).add(e1).add(e1)\n                .delete(e1, true).search(e1.geometry().mbr()).count().toBlocking().single();\n        assertEquals(0, count);\n    }\n\n    @Test\n    public void testDeleteItemThatIsNotPresentDoesNothing() {\n        Entry<Object, Rectangle> e1 = e(1);\n        Entry<Object, Rectangle> e2 = e(2);\n        RTree<Object, Rectangle> tree = RTree.<Object, Rectangle>create().add(e1);\n        assertTrue(tree == tree.delete(e2));\n    }\n\n    @Test\n    public void testExampleOnReadMe() {\n        RTree<String, Geometry> tree = RTree.maxChildren(5).create();\n        tree = tree.add(entry(\"DAVE\", point(10, 20))).add(entry(\"FRED\", point(12, 25)))\n                .add(entry(\"MARY\", point(97, 125)));\n    }\n\n    @Test(timeout = 2000)\n    public void testUnsubscribe() {\n        RTree<Object, Geometry> tree = createRandomRTree(1000);\n        assertEquals(0, (int) tree.entries().take(0).count().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchConditionAlwaysFalse() {\n        @SuppressWarnings(\"unchecked\")\n        RTree<Object, Geometry> tree = (RTree<Object, Geometry>) (RTree<?, ?>) create(3, 3);\n        assertEquals(0, (int) tree.search(Functions.alwaysFalse()).count().toBlocking().single());\n    }\n\n    @Test\n    public void testAddOverload() {\n        @SuppressWarnings(\"unchecked\")\n        RTree<Object, Geometry> tree = (RTree<Object, Geometry>) (RTree<?, ?>) create(3, 0);\n        tree = tree.add(123, Geometries.point(1, 2));\n        assertEquals(1, (int) tree.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testDeleteOverload() {\n        @SuppressWarnings(\"unchecked\")\n        RTree<Object, Geometry> tree = (RTree<Object, Geometry>) (RTree<?, ?>) create(3, 0);\n        tree = tree.add(123, Geometries.point(1, 2)).delete(123, Geometries.point(1, 2));\n        assertEquals(0, (int) tree.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testStandardRTreeSearch() {\n        Rectangle r = rectangle(13.0, 23.0, 50.0, 80.0);\n        Point[] points = { point(59.0, 91.0), point(86.0, 14.0), point(36.0, 60.0),\n                point(57.0, 36.0), point(14.0, 37.0) };\n\n        RTree<Integer, Geometry> tree = RTree.create();\n        for (int i = 0; i < points.length; i++) {\n            Point point = points[i];\n            System.out.println(\"point(\" + point.x() + \",\" + point.y() + \"), value=\" + (i + 1));\n            tree = tree.add(i + 1, point);\n        }\n        System.out.println(tree.asString());\n        System.out.println(\"searching \" + r);\n        Set<Integer> set = new HashSet<Integer>(\n                tree.search(r).map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n        assertEquals(new HashSet<Integer>(asList(3, 5)), set);\n    }\n\n    @Test\n    public void testStandardRTreeSearch2() {\n        Rectangle r = rectangle(10.0, 10.0, 50.0, 50.0);\n        Point[] points = { point(28.0, 19.0), point(29.0, 4.0), point(10.0, 63.0),\n                point(34.0, 85.0), point(62.0, 45.0) };\n\n        RTree<Integer, Geometry> tree = RTree.create();\n        for (int i = 0; i < points.length; i++) {\n            Point point = points[i];\n            System.out.println(\"point(\" + point.x() + \",\" + point.y() + \"), value=\" + (i + 1));\n            tree = tree.add(i + 1, point);\n        }\n        System.out.println(tree.asString());\n        System.out.println(\"searching \" + r);\n        Set<Integer> set = new HashSet<Integer>(\n                tree.search(r).map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n        assertEquals(new HashSet<Integer>(asList(1)), set);\n    }\n\n    @Test\n    public void testBulkLoadingTreeAndStarTreeReturnsSameAsStandardRTree() {\n\n        RTree<Integer, Geometry> tree1 = RTree.create();\n        RTree<Integer, Geometry> tree2 = RTree.star().create();\n\n        Rectangle[] testRects = { rectangle(0, 0, 0, 0), rectangle(0, 0, 100, 100),\n                rectangle(0, 0, 10, 10), rectangle(0.12, 0.25, 50.356, 50.756),\n                rectangle(1, 0.252, 50, 69.23), rectangle(13.12, 23.123, 50.45, 80.9),\n                rectangle(10, 10, 50, 50) };\n\n        List<Entry<Integer, Geometry>> entries = new ArrayList<Entry<Integer, Geometry>>(10000);\n        for (int i = 1; i <= 10000; i++) {\n            Point point = nextPoint();\n            // System.out.println(\"point(\" + point.x() + \",\" + point.y() +\n            // \"),\");\n            tree1 = tree1.add(i, point);\n            tree2 = tree2.add(i, point);\n            entries.add(new EntryDefault<Integer, Geometry>(i, point));\n        }\n        RTree<Integer, Geometry> tree3 = RTree.create(entries);\n\n        // tree2.visualize(2000, 2000).save(\"target/tree22.png\");\n        // tree3.visualize(2000, 2000).save(\"target/tree33.png\");\n\n        for (Rectangle r : testRects) {\n            Set<Integer> res1 = new HashSet<Integer>(tree1.search(r)\n                    .map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n            Set<Integer> res2 = new HashSet<Integer>(tree2.search(r)\n                    .map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n            Set<Integer> res3 = new HashSet<Integer>(tree3.search(r)\n                    .map(RTreeTest.<Integer>toValue()).toList().toBlocking().single());\n            System.out.println(\"searchRect= rectangle(\" + r.x1() + \",\" + r.y1() + \",\" + r.x2() + \",\"\n                    + r.y2() + \")\");\n            System.out.println(\"res1.size=\" + res1.size() + \",res2.size=\" + res2.size()\n                    + \",res3.size=\" + res3.size());\n            // System.out.println(\"res1=\" + res1 + \",res2=\" + res2 + \",res3=\" + res3);\n            assertEquals(res1.size(), res2.size());\n            assertEquals(res1.size(), res3.size());\n        }\n    }\n\n    @Test\n    public void testUnsubscribeWhileIteratingLeafNode() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(5).<Object, Rectangle>create().add(e(1))\n                .add(e(2));\n        tree.entries().subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n                unsubscribe();\n            }\n        });\n    }\n\n    @Test\n    public void testUnsubscribeWhileIteratingNonLeafNode() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        RTree<Object, Rectangle> tree = RTree.maxChildren(3).<Object, Rectangle>create().add(e(1))\n                .add(e(2)).add(e(3)).add(e(4));\n        tree.entries().subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n                completed.set(true);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n                unsubscribe();\n            }\n        });\n        assertFalse(completed.get());\n    }\n\n    @Test\n    public void testSearchWithIntersectsRectangleFunction() {\n        RTree<Integer, Rectangle> tree = RTree.create();\n        tree.search(circle(0, 0, 1), rectangleIntersectsCircle);\n    }\n\n    @Test\n    public void testSearchWithIntersectsPointFunctionReturnsOne() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0));\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1),\n                pointIntersectsCircle);\n        assertEquals(1, (int) entries.count().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchWithIntersectsPointFunctionReturnsNone() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(10, 10));\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1),\n                pointIntersectsCircle);\n        assertEquals(0, (int) entries.count().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchWithDistanceFunctionIntersectsMbrButNotActualGeometry() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0)).add(2,\n                point(1, 1));\n\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1), 0.1,\n                distanceCircleToPoint);\n        assertEquals(1, (int) entries.count().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchWithDistanceFunctionIntersectsMbrAndActualGeometry() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0)).add(2,\n                point(1, 1));\n\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(0, 0, 1), 0.5,\n                distanceCircleToPoint);\n        assertEquals(2, (int) entries.count().toBlocking().single());\n    }\n\n    @Test\n    public void testSearchWithDistanceFunctionIntersectsNothing() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(0, 0)).add(2,\n                point(1, 1));\n\n        Observable<Entry<Integer, Point>> entries = tree.search(circle(10, 10, 1), 0.5,\n                distanceCircleToPoint);\n        assertEquals(0, (int) entries.count().toBlocking().single());\n    }\n\n    @Test\n    public void calculateDepthOfEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertEquals(0, tree.calculateDepth());\n    }\n\n    @Test\n    public void calculateAsStringOfEmptyTree() {\n        RTree<Object, Geometry> tree = RTree.create();\n        assertEquals(\"\", tree.asString());\n    }\n\n    @Test\n    public void testForMeiZhao() {\n        for (int minChildren = 1; minChildren <= 2; minChildren++) {\n            RTree<Integer, Point> tree = RTree.maxChildren(3).minChildren(minChildren)\n                    .<Integer, Point>create().add(1, point(1, 9)).add(2, point(2, 10))\n                    .add(3, point(4, 8)).add(4, point(6, 7)).add(5, point(9, 10))\n                    .add(6, point(7, 5)).add(7, point(5, 6)).add(8, point(4, 3)).add(9, point(3, 2))\n                    .add(10, point(9, 1)).add(11, point(10, 4)).add(12, point(6, 2))\n                    .add(13, point(8, 3));\n            System.out.println(tree.asString());\n        }\n    }\n\n    @Test\n    public void testSearchWithCircleFindsCentreOnly() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.circle(2, 2, 1)).toList()\n                .toBlocking().single();\n        assertEquals(1, list.size());\n        assertEquals(2, (int) list.get(0).value());\n    }\n\n    @Test\n    public void testSearchWithCircleFindsAll() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.circle(2, 2, 1.5)).toList()\n                .toBlocking().single();\n        assertEquals(3, list.size());\n    }\n\n    @Test\n    public void testSearchWithLineFindsAll() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.line(0, 0, 4, 4)).toList()\n                .toBlocking().single();\n        assertEquals(3, list.size());\n    }\n\n    @Test\n    public void testSearchWithLineFindsOne() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.line(1.5, 1.5, 2.5, 2.5)).toList()\n                .toBlocking().single();\n        assertEquals(1, list.size());\n        assertEquals(2, (int) list.get(0).value());\n    }\n\n    @Test\n    public void testSearchWithLineFindsNone() {\n        RTree<Integer, Point> tree = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).add(3, point(3, 3));\n        List<Entry<Integer, Point>> list = tree.search(Geometries.line(1.5, 1.5, 2.6, 2.5)).toList()\n                .toBlocking().single();\n        System.out.println(list);\n        assertEquals(0, list.size());\n    }\n\n    @Test\n    public void testRTreeRootMbrWhenRTreeEmpty() {\n        assertFalse(RTree.create().mbr().isPresent());\n    }\n\n    @Test\n    public void testRTreeRootMbrWhenRTreeNonEmpty() {\n        Optional<Rectangle> r = RTree.<Integer, Point>create().add(1, point(1, 1))\n                .add(2, point(2, 2)).mbr();\n        assertEquals(Geometries.rectangle(1, 1, 2, 2), r.get());\n    }\n\n    @Test\n    public void testIntersectsPointLine() {\n        assertTrue(Intersects.lineIntersectsPoint.call(line(1, 1, 2, 2), point(1, 1)));\n    }\n\n    @Test(timeout = 30000000)\n    public void testGroupByIssue40() {\n        RTree<Integer, Geometry> tree = RTree.star().create();\n\n        tree = tree.add(1, Geometries.point(13.0, 52.0));\n        tree = tree.add(2, Geometries.point(13.0, 52.0));\n        tree = tree.add(3, Geometries.point(13.0, 52.0));\n        tree = tree.add(4, Geometries.point(13.0, 52.0));\n        tree = tree.add(5, Geometries.point(13.0, 52.0));\n        tree = tree.add(6, Geometries.point(13.0, 52.0));\n\n        Rectangle rectangle = Geometries.rectangle(12.9, 51.9, 13.1, 52.1);\n        assertEquals(Integer.valueOf(2), tree.search(rectangle).doOnRequest(new Action1<Long>() {\n            @Override\n            public void call(Long n) {\n                System.out.println(\"requestFromGroupBy=\" + n);\n            }\n        }).groupBy(new Func1<Entry<Integer, Geometry>, Boolean>() {\n            @Override\n            public Boolean call(Entry<Integer, Geometry> entry) {\n                System.out.println(entry);\n                return entry.value() % 2 == 0;\n            }\n        }).doOnRequest(new Action1<Long>() {\n            @Override\n            public void call(Long n) {\n                System.out.println(\"requestFromFlatMap=\" + n);\n            }\n        }).flatMap(\n                new Func1<GroupedObservable<Boolean, Entry<Integer, Geometry>>, Observable<Integer>>() {\n                    @Override\n                    public Observable<Integer> call(\n                            GroupedObservable<Boolean, Entry<Integer, Geometry>> group) {\n                        return group.count();\n                    }\n                }).count().toBlocking().single());\n    }\n\n    @Test\n    public void testBackpressureForOverflow() {\n        RTree<Integer, Geometry> tree = RTree.star().create();\n\n        tree = tree.add(1, Geometries.point(13.0, 52.0));\n        tree = tree.add(2, Geometries.point(13.0, 52.0));\n        tree = tree.add(3, Geometries.point(13.0, 52.0));\n        tree = tree.add(4, Geometries.point(13.0, 52.0));\n        tree = tree.add(5, Geometries.point(13.0, 52.0));\n        tree = tree.add(6, Geometries.point(13.0, 52.0));\n        final AtomicInteger count = new AtomicInteger();\n        Rectangle rectangle = Geometries.rectangle(12.9, 51.9, 13.1, 52.1);\n        tree.search(rectangle).subscribe(new Subscriber<Object>() {\n\n            @Override\n            public void onStart() {\n                request(4);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Object t) {\n                request(Long.MAX_VALUE);\n                count.incrementAndGet();\n            }\n        });\n        assertEquals(6, count.get());\n        assertEquals(6, (int) tree.search(rectangle).count().toBlocking().single());\n\n    }\n    \n    @Test\n    public void testDeleteIssue81d() {\n         RTree<Object, Point> t = RTree.create();\n         t = t.add(1, Geometries.pointGeographic(123.4d, 23.3d));\n         t = t.delete(1, Geometries.pointGeographic(123.4d, 23.3d));\n         assertEquals(0, t.size());\n     }\n    \n     @Test\n     public void testDeleteIssue81f() {\n         RTree<Object, Point> t = RTree.create();\n         t = t.add(1, Geometries.pointGeographic(123.4f, 23.3f));\n         t = t.delete(1, Geometries.pointGeographic(123.4f, 23.3f));\n         assertEquals(0, t.size());\n     }\n\n    private static Func2<Point, Circle, Double> distanceCircleToPoint = new Func2<Point, Circle, Double>() {\n        @Override\n        public Double call(Point point, Circle circle) {\n            return circle.distance(point.mbr());\n        }\n    };\n\n    private static <T> Func1<Entry<T, ?>, T> toValue() {\n        return new Func1<Entry<T, ?>, T>() {\n\n            @Override\n            public T call(Entry<T, ?> entry) {\n                return entry.value();\n            }\n        };\n    }\n\n    private static Point nextPoint() {\n\n        double randomX = Math.round(Math.random() * 100);\n\n        double randomY = Math.round(Math.random() * 100);\n\n        return Geometries.point(randomX, randomY);\n\n    }\n\n    static Entry<Object, Rectangle> e(int n) {\n        return Entries.<Object, Rectangle>entry(n, r(n));\n    }\n\n    static Entry<Object, Rectangle> e2(int n) {\n        return Entries.<Object, Rectangle>entry(n, r(n - 1));\n    }\n\n    private static Rectangle r(int n) {\n        return rectangle(n, n, n + 1, n + 1);\n    }\n\n    private static Rectangle r(double n, double m) {\n        return rectangle(n, m, n + 1, m + 1);\n    }\n\n    private static Rectangle r(float n, float m) {\n        return rectangle(n, m, n + 1, m + 1);\n    }\n\n    static Rectangle random(Precision precision) {\n        if (precision == Precision.SINGLE)\n            return r((float) Math.random() * 1000, (float) Math.random() * 1000);\n        else\n            return r(Math.random() * 1000, Math.random() * 1000);\n    }\n\n    @Test\n    public void testSearchGreekEarthquakesDouble() {\n        Observable<Entry<Object, Point>> entriesDouble = GreekEarthquakes.entries(Precision.DOUBLE);\n        RTree<Object, Point> t = RTree.maxChildren(4).<Object, Point>create().add(entriesDouble)\n                .last().toBlocking().single(); //\n        t.search(Geometries.rectangle(40, 27.0, 40.5, 27.5)) //\n                .test() //\n                .assertValueCount(22) //\n                .assertCompleted();\n    }\n    \n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final double PRECISION = 0.000001;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "PRECISION = 0.000001", "syntax_pass": true}, {"attribute_expression": "private static Func2<Point, Circle, Double> distanceCircleToPoint = new Func2<Point, Circle, Double>() {\n        @Override\n        public Double call(Point point, Circle circle) {\n            return circle.distance(point.mbr());\n        }\n    };", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "Func2<Point, Circle, Double>", "name": "distanceCircleToPoint = new Func2<Point, Circle, Double>() {\n        @Override\n        public Double call(Point point, Circle circle) {\n            return circle.distance(point.mbr());\n        }\n    }", "syntax_pass": true}]}, {"uris": "src/test/java/com/github/davidmoten/rtree/ComparatorsTest.java.ComparatorsTest", "name": "ComparatorsTest", "file_path": "src/test/java/com/github/davidmoten/rtree/ComparatorsTest.java", "superclasses": "", "methods": ["[void]testConstructorIsPrivate()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ComparatorsTest {\n\n    @Test\n    public void testConstructorIsPrivate() {\n        Asserts.assertIsUtilityClass(Comparators.class);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/UtilTest.java.UtilTest", "name": "UtilTest", "file_path": "src/test/java/com/github/davidmoten/rtree/UtilTest.java", "superclasses": "", "methods": ["[void]coverPrivateConstructor()", "[void]testMbrWithNegativeValues()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class UtilTest {\n\n    @Test\n    public void coverPrivateConstructor() {\n        Asserts.assertIsUtilityClass(Util.class);\n    }\n\n    @Test\n    public void testMbrWithNegativeValues() {\n        Rectangle r = Geometries.rectangle(-2D, -2, -1, -1);\n        Rectangle mbr = Util.mbr(Collections.singleton(r));\n        assertEquals(r, mbr);\n        System.out.println(r);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/QuadraticSplitterTest.java.QuadraticSplitterTest", "name": "QuadraticSplitterTest", "file_path": "src/test/java/com/github/davidmoten/rtree/QuadraticSplitterTest.java", "superclasses": "", "methods": ["[void]testWorstCombinationOn3()", "[void]testWorstCombinationOnTwoEntries()", "[void]testWorstCombinationOn4()", "[void]testGetBestCandidateForGroup1()", "[void]testGetBestCandidateForGroup2()", "[void]testGetBestCandidateForGroup3()", "[void]testSplit()", "[void]testSplit2()", "[void]testSplit3()", "[void]testExceptionForSplitEmptyList()"], "method_uris": ["src/test/java/com/github/davidmoten/rtree/QuadraticSplitterTest.java.QuadraticSplitterTest.[Mbr]r(int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class QuadraticSplitterTest {\n\n    @Test\n    public void testWorstCombinationOn3() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(100);\n        final Mbr r3 = r(3);\n        final Pair<Mbr> pair = SplitterQuadratic.worstCombination(Arrays.asList(r1, r2, r3));\n        assertEquals(r1, pair.value1());\n        assertEquals(r2, pair.value2());\n    }\n\n    @Test\n    public void testWorstCombinationOnTwoEntries() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Pair<Mbr> pair = SplitterQuadratic.worstCombination(Arrays.asList(r1, r2));\n        assertEquals(r1, pair.value1());\n        assertEquals(r2, pair.value2());\n    }\n\n    @Test\n    public void testWorstCombinationOn4() {\n        final Mbr r1 = r(2);\n        final Mbr r2 = r(1);\n        final Mbr r3 = r(3);\n        final Mbr r4 = r(4);\n        final Pair<Mbr> pair = SplitterQuadratic.worstCombination(Arrays.asList(r1, r2, r3, r4));\n        assertEquals(r2, pair.value1());\n        assertEquals(r4, pair.value2());\n    }\n\n    @Test\n    public void testGetBestCandidateForGroup1() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final List<Mbr> list = Collections.singletonList(r1);\n        final List<Mbr> group = Collections.singletonList(r2);\n        final Mbr r = SplitterQuadratic.getBestCandidateForGroup(list, group, Util.mbr(group));\n        assertEquals(r1, r);\n    }\n\n    @Test\n    public void testGetBestCandidateForGroup2() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(10);\n        final List<Mbr> list = Collections.singletonList(r1);\n        final List<Mbr> group = Arrays.asList(r2, r3);\n        final Mbr r = SplitterQuadratic.getBestCandidateForGroup(list, group, Util.mbr(group));\n        assertEquals(r1, r);\n    }\n\n    @Test\n    public void testGetBestCandidateForGroup3() {\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(10);\n        final List<Mbr> list = Arrays.asList(r1, r2);\n        final List<Mbr> group = Arrays.asList(r3);\n        final Mbr r = SplitterQuadratic.getBestCandidateForGroup(list, group, Util.mbr(group));\n        assertEquals(r2, r);\n    }\n\n    @Test\n    public void testSplit() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(100);\n        final Mbr r4 = r(101);\n        final ListPair<Mbr> pair = q.split(Arrays.asList(r1, r2, r3, r4), 2);\n        assertEquals(Sets.newHashSet(r1, r2), Sets.newHashSet(pair.group1().list()));\n        assertEquals(Sets.newHashSet(r3, r4), Sets.newHashSet(pair.group2().list()));\n    }\n\n    @Test\n    public void testSplit2() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(100);\n        final Mbr r4 = r(101);\n        final Mbr r5 = r(103);\n        final ListPair<Mbr> pair = q.split(Arrays.asList(r1, r2, r3, r4, r5), 2);\n        assertEquals(Sets.newHashSet(r1, r2), Sets.newHashSet(pair.group1().list()));\n        assertEquals(Sets.newHashSet(r3, r4, r5), Sets.newHashSet(pair.group2().list()));\n    }\n\n    @Test\n    public void testSplit3() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        final Mbr r1 = r(1);\n        final Mbr r2 = r(2);\n        final Mbr r3 = r(100);\n        final Mbr r4 = r(101);\n        final Mbr r5 = r(103);\n        final Mbr r6 = r(104);\n        final ListPair<Mbr> pair = q.split(Arrays.asList(r1, r2, r3, r4, r5, r6), 3);\n        assertEquals(Sets.newHashSet(r1, r2, r3), Sets.newHashSet(pair.group1().list()));\n        assertEquals(Sets.newHashSet(r4, r5, r6), Sets.newHashSet(pair.group2().list()));\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testExceptionForSplitEmptyList() {\n        final SplitterQuadratic q = new SplitterQuadratic();\n        q.split(Collections.<HasGeometry> emptyList(), 3);\n    }\n\n    private static Mbr r(int n) {\n        return new Mbr(Geometries.rectangle(n, n, n + 1, n + 1));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/LatLongExampleTest.java.LatLongExampleTest", "name": "LatLongExampleTest", "file_path": "src/test/java/com/github/davidmoten/rtree/LatLongExampleTest.java", "superclasses": "", "methods": ["[void]testLatLongExample()", "[void]testSearchLatLongCircles()"], "method_uris": ["src/test/java/com/github/davidmoten/rtree/LatLongExampleTest.java.LatLongExampleTest.[Observable<Entry<T, Point>>]search(RTree<T, Point>,Point,double)", "src/test/java/com/github/davidmoten/rtree/LatLongExampleTest.java.LatLongExampleTest.[Rectangle]createBounds(Position,double)", "src/test/java/com/github/davidmoten/rtree/LatLongExampleTest.java.LatLongExampleTest.[GeoCircleValue<T>]createGeoCircleValue(Point,double,T)", "src/test/java/com/github/davidmoten/rtree/LatLongExampleTest.java.LatLongExampleTest.[RTree<GeoCircleValue<T>, Rectangle>]add(RTree<GeoCircleValue<T>, Rectangle>,GeoCircleValue<T>)"], "overrides": null, "attributes": [{"original_string": "    private static class GeoCircleValue<T> {\n\n        GeoCircleValue(float lat, float lon, double radiusKm, T value) {\n            this.lat = lat;\n            this.lon = lon;\n            this.radiusKm = radiusKm;\n            this.value = value;\n        }\n\n        float lat;\n        float lon;\n        double radiusKm;\n        T value;\n    }", "definition": "    private static class GeoCircleValue<T>", "class_docstring": "", "name": "GeoCircleValue", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "float lat;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "float", "name": "lat", "syntax_pass": true}, {"attribute_expression": "float lon;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "float", "name": "lon", "syntax_pass": true}, {"attribute_expression": "double radiusKm;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "double", "name": "radiusKm", "syntax_pass": true}, {"attribute_expression": "T value;", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "T", "name": "value", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        GeoCircleValue(float lat, float lon, double radiusKm, T value) {\n            this.lat = lat;\n            this.lon = lon;\n            this.radiusKm = radiusKm;\n            this.value = value;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "GeoCircleValue", "params": [{"name": "lat", "type": "float"}, {"name": "lon", "type": "float"}, {"name": "radiusKm", "type": "double"}, {"name": "value", "type": "T"}], "body": "                                                                       {\n            this.lat = lat;\n            this.lon = lon;\n            this.radiusKm = radiusKm;\n            this.value = value;\n        }", "signature": "GeoCircleValue(float lat, float lon, double radiusKm, T value)"}]}], "class_docstring": "", "original_string": "public class LatLongExampleTest {\n\n    private static final Point sydney = Geometries.point(151.2094, -33.86);\n    private static final Point canberra = Geometries.point(149.1244, -35.3075);\n    private static final Point brisbane = Geometries.point(153.0278, -27.4679);\n    private static final Point bungendore = Geometries.point(149.4500, -35.2500);\n\n    @Test\n    public void testLatLongExample() {\n\n        // This is to demonstrate how to use rtree to to do distance searches\n        // with Lat Long points\n\n        // Let's find all cities within 300km of Canberra\n\n        RTree<String, Point> tree = RTree.star().create();\n        tree = tree.add(\"Sydney\", sydney);\n        tree = tree.add(\"Brisbane\", brisbane);\n\n        // Now search for all locations within 300km of Canberra\n        final double distanceKm = 300;\n        List<Entry<String, Point>> list = search(tree, canberra, distanceKm)\n                // get the result\n                .toList().toBlocking().single();\n\n        // should have returned Sydney only\n        assertEquals(1, list.size());\n        assertEquals(\"Sydney\", list.get(0).value());\n    }\n\n    public static <T> Observable<Entry<T, Point>> search(RTree<T, Point> tree, Point lonLat,\n            final double distanceKm) {\n        // First we need to calculate an enclosing lat long rectangle for this\n        // distance then we refine on the exact distance\n        final Position from = Position.create(lonLat.y(), lonLat.x());\n        Rectangle bounds = createBounds(from, distanceKm);\n\n        return tree\n                // do the first search using the bounds\n                .search(bounds)\n                // refine using the exact distance\n                .filter(new Func1<Entry<T, Point>, Boolean>() {\n                    @Override\n                    public Boolean call(Entry<T, Point> entry) {\n                        Point p = entry.geometry();\n                        Position position = Position.create(p.y(), p.x());\n                        return from.getDistanceToKm(position) < distanceKm;\n                    }\n                });\n    }\n\n    @Test\n    public void testSearchLatLongCircles() {\n        RTree<GeoCircleValue<String>, Rectangle> tree = RTree.star().create();\n        // create circles around these major towns\n        GeoCircleValue<String> sydneyCircle = createGeoCircleValue(sydney, 100, \"Sydney\");\n        GeoCircleValue<String> canberraCircle = createGeoCircleValue(canberra, 50, \"Canberra\");\n        GeoCircleValue<String> brisbaneCircle = createGeoCircleValue(brisbane, 200, \"Brisbane\");\n\n        // add the circles to the RTree using the bounding box of the circle as\n        // the geometry\n        tree = add(tree, sydneyCircle);\n        tree = add(tree, canberraCircle);\n        tree = add(tree, brisbaneCircle);\n\n        // now find the circles that contain bungendore (which is 30km from\n        // Canberra)\n        final Point location = bungendore;\n        String result = tree.search(location)\n                // filter on the exact distance from the centre of the GeoCircle\n                .filter(new Func1<Entry<GeoCircleValue<String>, Rectangle>, Boolean>() {\n                    Position from = Position.create(location.y(), location.x());\n\n                    @Override\n                    public Boolean call(Entry<GeoCircleValue<String>, Rectangle> entry) {\n                        Position centre = Position.create(entry.value().lat, entry.value().lon);\n                        return from.getDistanceToKm(centre) < entry.value().radiusKm;\n                    }\n                })\n                // do the search (only expect one value)\n                .toBlocking().single()\n                // get the name of the GoeCircleValue returned\n                .value().value;\n        assertEquals(\"Canberra\", result);\n    }\n\n    private static Rectangle createBounds(final Position from, final double distanceKm) {\n        // this calculates a pretty accurate bounding box. Depending on the\n        // performance you require you wouldn't have to be this accurate because\n        // accuracy is enforced later\n        Position north = from.predict(distanceKm, 0);\n        Position south = from.predict(distanceKm, 180);\n        Position east = from.predict(distanceKm, 90);\n        Position west = from.predict(distanceKm, 270);\n\n        return Geometries.rectangle(west.getLon(), south.getLat(), east.getLon(), north.getLat());\n    }\n\n    private static <T> GeoCircleValue<T> createGeoCircleValue(Point point, double radiusKm,\n            T value) {\n        return new GeoCircleValue<T>((float) point.y(), (float) point.x(), radiusKm, value);\n    }\n\n    private static <T> RTree<GeoCircleValue<T>, Rectangle> add(\n            RTree<GeoCircleValue<T>, Rectangle> tree, GeoCircleValue<T> c) {\n        return tree.add(c, createBounds(Position.create(c.lat, c.lon), c.radiusKm));\n    }\n\n    private static class GeoCircleValue<T> {\n\n        GeoCircleValue(float lat, float lon, double radiusKm, T value) {\n            this.lat = lat;\n            this.lon = lon;\n            this.radiusKm = radiusKm;\n            this.value = value;\n        }\n\n        float lat;\n        float lon;\n        double radiusKm;\n        T value;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Point sydney = Geometries.point(151.2094, -33.86);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Point", "name": "sydney = Geometries.point(151.2094, -33.86)", "syntax_pass": true}, {"attribute_expression": "private static final Point canberra = Geometries.point(149.1244, -35.3075);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Point", "name": "canberra = Geometries.point(149.1244, -35.3075)", "syntax_pass": true}, {"attribute_expression": "private static final Point brisbane = Geometries.point(153.0278, -27.4679);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Point", "name": "brisbane = Geometries.point(153.0278, -27.4679)", "syntax_pass": true}, {"attribute_expression": "private static final Point bungendore = Geometries.point(149.4500, -35.2500);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Point", "name": "bungendore = Geometries.point(149.4500, -35.2500)", "syntax_pass": true}]}, {"uris": "src/test/java/com/github/davidmoten/rtree/SerializersTest.java.SerializersTest", "name": "SerializersTest", "file_path": "src/test/java/com/github/davidmoten/rtree/SerializersTest.java", "superclasses": "", "methods": ["[void]testJavaIoSerialization()", "[void]testStringPointSerialization()", "[void]testStringRectangleFloatSerialization()", "[void]testStringRectangleDoubleSerialization()", "[void]testStringCircleFloatSerialization()", "[void]testStringCircleDoubleSerialization()", "[void]testStringLineFloatSerialization()", "[void]testStringLineDoubleSerialization()", "[void]testAddToFlatBuffers()", "[void]testDeleteFromFlatBuffers()", "[void]testAddToFlatBuffersWhenRootNodeIsNonLeaf()", "[void]testDeleteFromFlatBuffersWhenRootNodeIsNonLeaf()", "[void]canRoundTripEmptyTree()", "[void]isUtilityClass()"], "method_uris": ["src/test/java/com/github/davidmoten/rtree/SerializersTest.java.SerializersTest.[void]checkRoundTripPoint(Serializer<String, Point>)", "src/test/java/com/github/davidmoten/rtree/SerializersTest.java.SerializersTest.[void]check(Serializer<String, S>,Entry<String, S>,Entry<String, S>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SerializersTest {\n\n    @Test\n    public void testJavaIoSerialization() throws IOException {\n        Serializer<String, Point> serializer = Serializers.flatBuffers().javaIo();\n        checkRoundTripPoint(serializer);\n    }\n\n    @Test\n    public void testStringPointSerialization() throws IOException {\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        checkRoundTripPoint(serializer);\n    }\n\n    @Test\n    public void testStringRectangleFloatSerialization() throws IOException {\n        Serializer<String, Rectangle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Rectangle> a = Entries.entry(\"hello\", Geometries.rectangle(1, 2, 3, 4));\n        Entry<String, Rectangle> b = Entries.entry(\"there\", Geometries.rectangle(3, 4, 5, 6));\n        check(serializer, a, b);\n    }\n\n    @Test\n    public void testStringRectangleDoubleSerialization() throws IOException {\n        Serializer<String, Rectangle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Rectangle> a = Entries.entry(\"hello\",\n                Geometries.rectangle(1.0000000001, 2, 3, 4));\n        Entry<String, Rectangle> b = Entries.entry(\"there\",\n                Geometries.rectangle(3.0000000001, 4, 5, 6));\n        check(serializer, a, b);\n    }\n\n    @Test\n    public void testStringCircleFloatSerialization() throws IOException {\n        Serializer<String, Circle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Circle> a = Entries.entry(\"hello\", Geometries.circle(1, 2, 3));\n        Entry<String, Circle> b = Entries.entry(\"there\", Geometries.circle(3, 4, 5));\n        check(serializer, a, b);\n    }\n\n    @Test\n    public void testStringCircleDoubleSerialization() throws IOException {\n        Serializer<String, Circle> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Circle> a = Entries.entry(\"hello\", Geometries.circle(1.0000000001, 2, 3));\n        Entry<String, Circle> b = Entries.entry(\"there\", Geometries.circle(3.0000000001, 4, 5));\n        check(serializer, a, b);\n    }\n\n    @Test\n    public void testStringLineFloatSerialization() throws IOException {\n        Serializer<String, Line> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Line> a = Entries.entry(\"hello\", Geometries.line(1, 2, 3, 4));\n        Entry<String, Line> b = Entries.entry(\"there\", Geometries.line(3, 4, 5, 6));\n        check(serializer, a, b);\n    }\n\n    @Test\n    public void testStringLineDoubleSerialization() throws IOException {\n        Serializer<String, Line> serializer = Serializers.flatBuffers().utf8();\n        Entry<String, Line> a = Entries.entry(\"hello\", Geometries.line(1.0000000001, 2, 3, 4));\n        Entry<String, Line> b = Entries.entry(\"there\", Geometries.line(3.0000000001, 4, 5, 6));\n        check(serializer, a, b);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAddToFlatBuffers() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.add(c);\n        assertEquals(Sets.newHashSet(a, b, c),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeleteFromFlatBuffers() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.delete(a);\n        assertEquals(Sets.newHashSet(b),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testAddToFlatBuffersWhenRootNodeIsNonLeaf() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n        Entry<String, Point> d = Entries.entry(\"smart\", Geometries.point(7, 8));\n        Entry<String, Point> e = Entries.entry(\"person\", Geometries.point(9, 10));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b).add(c).add(d).add(e);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.add(c);\n        assertEquals(Sets.newHashSet(a, b, c, d, e),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testDeleteFromFlatBuffersWhenRootNodeIsNonLeaf() throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        Entry<String, Point> c = Entries.entry(\"you\", Geometries.point(5, 6));\n        Entry<String, Point> d = Entries.entry(\"smart\", Geometries.point(7, 8));\n        Entry<String, Point> e = Entries.entry(\"person\", Geometries.point(9, 10));\n        RTree<String, Point> tree = RTree.create();\n        tree = tree.add(a).add(b).add(c).add(d).add(e);\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        tree2 = tree2.delete(b);\n        assertEquals(Sets.newHashSet(a, c, d, e),\n                Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n    }\n\n    @Test\n    public void canRoundTripEmptyTree() throws IOException {\n        RTree<String, Point> tree = RTree.create();\n        Serializer<String, Point> serializer = Serializers.flatBuffers().utf8();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        byte[] array = bytes.toByteArray();\n        RTree<String, Point> tree2 = serializer.read(new ByteArrayInputStream(array), array.length,\n                InternalStructure.SINGLE_ARRAY);\n        assertTrue(tree2.isEmpty());\n    }\n\n    private static void checkRoundTripPoint(Serializer<String, Point> serializer)\n            throws IOException {\n        Entry<String, Point> a = Entries.entry(\"hello\", Geometries.point(1, 2));\n        Entry<String, Point> b = Entries.entry(\"there\", Geometries.point(3, 4));\n        check(serializer, a, b);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static <S extends Geometry> void check(Serializer<String, S> serializer,\n            Entry<String, S> a, Entry<String, S> b) throws IOException {\n        RTree<String, S> tree = RTree.create();\n        tree = tree.add(a).add(b);\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        serializer.write(tree, bytes);\n        bytes.close();\n        {\n            ByteArrayInputStream input = new ByteArrayInputStream(bytes.toByteArray());\n            RTree<String, S> tree2 = serializer.read(input, bytes.size(),\n                    InternalStructure.DEFAULT);\n            assertEquals(2, tree2.size());\n            assertEquals(Sets.newHashSet(a, b),\n                    Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n        }\n        {\n            ByteArrayInputStream input = new ByteArrayInputStream(bytes.toByteArray());\n            RTree<String, S> tree2 = serializer.read(input, bytes.size(),\n                    InternalStructure.SINGLE_ARRAY);\n            assertEquals(2, tree2.size());\n            assertEquals(Sets.newHashSet(a, b),\n                    Sets.newHashSet(tree2.entries().toList().toBlocking().single()));\n        }\n    }\n\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(Serializers.class);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/KryoSerializationTest.java.KryoSerializationTest", "name": "KryoSerializationTest", "file_path": "src/test/java/com/github/davidmoten/rtree/KryoSerializationTest.java", "superclasses": "", "methods": ["[void]testRTree()", "[void]testKryo()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    public static class Boo {\n\n        public final String name;\n\n        @SuppressWarnings(\"unused\")\n        private Boo() {\n            this(\"boo\");\n        }\n\n        public Boo(String name) {\n            this.name = name;\n        }\n    }", "definition": "    public static class Boo", "class_docstring": "", "name": "Boo", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "public final String name;", "docstring": "", "modifiers": "public final", "marker_annotations": [], "non_marker_annotations": ["public", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @SuppressWarnings(\"unused\")\n        private Boo() {\n            this(\"boo\");\n        }", "docstring": "", "attributes": {"modifiers": "@SuppressWarnings(\"unused\")\n        private", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "private"], "comments": [], "return_type": "", "classes": []}, "name": "Boo", "params": [], "body": "                      {\n            this(\"boo\");\n        }", "signature": "@SuppressWarnings(\"unused\")\n        private Boo()"}, {"syntax_pass": true, "original_string": "        public Boo(String name) {\n            this.name = name;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Boo", "params": [{"name": "name", "type": "String"}], "body": "                                {\n            this.name = name;\n        }", "signature": "public Boo(String name)"}]}], "class_docstring": "", "original_string": "public class KryoSerializationTest {\n\n    @Test\n    @Ignore\n    public void testRTree() {\n        Kryo kryo = new Kryo();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        Output output = new Output(bytes);\n        RTree<String, Point> tree = RTree.<String, Point> create()\n                .add(Entries.entry(\"thing\", Geometries.point(10, 20)))\n                .add(Entries.entry(\"monster\", Geometries.point(23, 45)));\n        kryo.writeObject(output, tree);\n        output.close();\n        Input input = new Input(new ByteArrayInputStream(bytes.toByteArray()));\n        @SuppressWarnings(\"unchecked\")\n        RTree<String, Point> tree2 = kryo.readObject(input, RTree.class);\n        assertEquals(2, (int) tree2.entries().count().toBlocking().single());\n    }\n\n    @Test\n    public void testKryo() {\n        Kryo kryo = new Kryo();\n        ByteArrayOutputStream bytes = new ByteArrayOutputStream();\n        Output output = new Output(bytes);\n        Boo b = new Boo(\"hello\");\n        kryo.register(Boo.class);\n        kryo.writeObject(output, b);\n        output.close();\n        Input input = new Input(new ByteArrayInputStream(bytes.toByteArray()));\n        Boo b2 = kryo.readObject(input, Boo.class);\n        assertEquals(\"hello\", b2.name);\n    }\n\n    public static class Boo {\n\n        public final String name;\n\n        @SuppressWarnings(\"unused\")\n        private Boo() {\n            this(\"boo\");\n        }\n\n        public Boo(String name) {\n            this.name = name;\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/ContextTest.java.ContextTest", "name": "ContextTest", "file_path": "src/test/java/com/github/davidmoten/rtree/ContextTest.java", "superclasses": "", "methods": ["[void]testContextIllegalMinChildren()", "[void]testContextIllegalMaxChildren()", "[void]testContextIllegalMinMaxChildren()", "[void]testContextLegalChildren()", "[void]testContextSelectorNullThrowsNPE()", "[void]testContextSplitterNullThrowsNPE()", "[void]testContextNodeFactoryNullThrowsNPE()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ContextTest {\n\n    @Test(expected = RuntimeException.class)\n    public void testContextIllegalMinChildren() {\n        new Context<Object, Geometry>(0, 4, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testContextIllegalMaxChildren() {\n        new Context<Object, Geometry>(1, 2, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testContextIllegalMinMaxChildren() {\n        new Context<Object, Geometry>(4, 3, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }\n\n    @Test\n    public void testContextLegalChildren() {\n        new Context<Object, Geometry>(2, 4, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), Factories.defaultFactory());\n    }\n\n    @Test(expected = NullPointerException.class)\n    public void testContextSelectorNullThrowsNPE() {\n        new Context<Object, Geometry>(2, 4, null, new SplitterQuadratic(),\n                Factories.defaultFactory());\n    }\n\n    @Test(expected = NullPointerException.class)\n    public void testContextSplitterNullThrowsNPE() {\n        new Context<Object, Geometry>(2, 4, new SelectorMinimalAreaIncrease(), null,\n                Factories.defaultFactory());\n    }\n\n    @Test(expected = NullPointerException.class)\n    public void testContextNodeFactoryNullThrowsNPE() {\n        new Context<Object, Geometry>(2, 4, new SelectorMinimalAreaIncrease(),\n                new SplitterQuadratic(), null);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/ImageSaverTest.java.ImageSaverTest", "name": "ImageSaverTest", "file_path": "src/test/java/com/github/davidmoten/rtree/ImageSaverTest.java", "superclasses": "", "methods": ["[void]testSaveImageToNonExistentDirectoryThrowsRuntimeException()", "[void]testRunThatThrows()", "[void]testRunThatDoesNotThrow()", "[void]testIsUtilClass()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ImageSaverTest {\n\n    @Test\n    public void testSaveImageToNonExistentDirectoryThrowsRuntimeException() {\n        Visualizer v = RTree.create().visualize(100, 100);\n        v.save(\"target/saved-image\");\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testRunThatThrows() {\n        ImageSaver.run(new Callable<Void>() {\n\n            @Override\n            public Void call() throws Exception {\n                throw new IOException();\n            }\n        });\n    }\n\n    @Test\n    public void testRunThatDoesNotThrow() {\n        final AtomicBoolean b = new AtomicBoolean();\n        ImageSaver.run(new Callable<Void>() {\n\n            @Override\n            public Void call() throws Exception {\n                b.set(true);\n                return null;\n            }\n        });\n        assertTrue(b.get());\n    }\n\n    @Test\n    public void testIsUtilClass() {\n        Asserts.assertIsUtilityClass(ImageSaver.class);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/FactoriesTest.java.FactoriesTest", "name": "FactoriesTest", "file_path": "src/test/java/com/github/davidmoten/rtree/FactoriesTest.java", "superclasses": "", "methods": ["[void]isUtilityClass()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class FactoriesTest {\n\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(Factories.class);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/SplitterRStarTest.java.SplitterRStarTest", "name": "SplitterRStarTest", "file_path": "src/test/java/com/github/davidmoten/rtree/SplitterRStarTest.java", "superclasses": "", "methods": ["[void]testGetPairs()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SplitterRStarTest {\n\n    @Test\n    public void testGetPairs() {\n\n        int minSize = 2;\n        List<HasGeometry> list = Lists.newArrayList();\n        list.add(Geometries.point(1, 1).mbr());\n        list.add(Geometries.point(2, 2).mbr());\n        list.add(Geometries.point(3, 3).mbr());\n        list.add(Geometries.point(4, 4).mbr());\n        list.add(Geometries.point(5, 5).mbr());\n        List<ListPair<HasGeometry>> pairs = SplitterRStar.getPairs(minSize, list);\n        assertEquals(2, pairs.size());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/HighPrecisionTest.java.HighPrecisionTest", "name": "HighPrecisionTest", "file_path": "src/test/java/com/github/davidmoten/rtree/HighPrecisionTest.java", "superclasses": "", "methods": ["[void]testForIssue72()", "[void]testHighPrecision()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class HighPrecisionTest {\n\n    @Test\n    public void testForIssue72() {\n        long x = 123456789L;\n        System.out.println(new BigDecimal(x).floatValue());\n        BigDecimal b = new BigDecimal(x);\n        System.out.println(b.round(FLOOR).floatValue());\n        System.out.println(b.round(CEILING).floatValue());\n    }\n\n    @Test\n    public void testHighPrecision() {\n        RTree<Integer, Rectangle> tree = RTree.create();\n        tree = tree.add(1, Geometries.rectangle(0, 0, 1, 1));\n        double x1 = 2.0000000001;\n        System.out.println((float) x1);\n        tree = tree.add(2, Geometries.rectangle(x1, 2, 3, 3));\n        tree.search(Geometries.rectangle((float) x1, 2.0, (float) x1, 2.0)) //\n                .test() //\n                .assertNoValues() //\n                .assertCompleted();\n        tree.search(Geometries.rectangle(x1, 2.0, x1, 2.0)) //\n                .test() //\n                .assertValueCount(1) //\n                .assertCompleted();\n    }\n\n    private static final MathContext FLOOR = new MathContext(7, RoundingMode.FLOOR);\n    private static final MathContext CEILING = new MathContext(7, RoundingMode.CEILING);\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final MathContext FLOOR = new MathContext(7, RoundingMode.FLOOR);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "MathContext", "name": "FLOOR = new MathContext(7, RoundingMode.FLOOR)", "syntax_pass": true}, {"attribute_expression": "private static final MathContext CEILING = new MathContext(7, RoundingMode.CEILING);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "MathContext", "name": "CEILING = new MathContext(7, RoundingMode.CEILING)", "syntax_pass": true}]}, {"uris": "src/test/java/com/github/davidmoten/rtree/BackpressureTest.java.BackpressureTest", "name": "BackpressureTest", "file_path": "src/test/java/com/github/davidmoten/rtree/BackpressureTest.java", "superclasses": "", "methods": ["[void]testConstructorIsPrivate()", "[void]testBackpressureSearch()", "[void]testBackpressureSearchNodeWithConditionThatAlwaysReturnsFalse()", "[void]testRequestZero()", "[void]testRequestZeroWhenUnsubscribed()", "[void]testBackpressureIterateWhenNodeHasMaxChildrenAndIsRoot()", "[void]testBackpressureRequestZero()", "[void]testBackpressureIterateWhenNodeHasMaxChildrenAndIsNotRoot()", "[void]testBackpressureIterateWhenConditionFailsAgainstNonLeafNode()", "[void]testBackpressureIterateWhenConditionFailsAgainstLeafNode()", "[void]testBackpressureFastPathNotInitiatedTwice()"], "method_uris": ["src/test/java/com/github/davidmoten/rtree/BackpressureTest.java.BackpressureTest.[Subscriber<Entry<Object, Rectangle>>]backpressureSubscriber(Set<Entry<Object, Rectangle>>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BackpressureTest {\n\n    @Test\n    public void testConstructorIsPrivate() {\n        Asserts.assertIsUtilityClass(Backpressure.class);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testBackpressureSearch() {\n        Subscriber<Object> sub = Mockito.mock(Subscriber.class);\n        ImmutableStack<NodePosition<Object, Geometry>> stack = ImmutableStack.empty();\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        Backpressure.search(condition, sub, stack, 1);\n        Mockito.verify(sub, Mockito.never()).onNext(Mockito.any());\n    }\n\n    @Test\n    public void testBackpressureSearchNodeWithConditionThatAlwaysReturnsFalse() {\n        RTree<Object, Rectangle> tree = RTree.maxChildren(3).<Object, Rectangle> create()\n                .add(e(1)).add(e(3)).add(e(5)).add(e(7));\n\n        Set<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.search(e(1).geometry()).subscribe(backpressureSubscriber(found));\n        assertEquals(1, found.size());\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testRequestZero() {\n        Subscriber<Object> sub = new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n\n            }\n        };\n        sub.add(new Subscription() {\n            volatile boolean subscribed = true;\n\n            @Override\n            public void unsubscribe() {\n                subscribed = false;\n            }\n\n            @Override\n            public boolean isUnsubscribed() {\n                return !subscribed;\n            }\n        });\n        Node<Object, Geometry> node = Mockito.mock(Node.class);\n        NodePosition<Object, Geometry> np = new NodePosition<Object, Geometry>(node, 1);\n        ImmutableStack<NodePosition<Object, Geometry>> stack = ImmutableStack\n                .<NodePosition<Object, Geometry>> empty().push(np);\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        ImmutableStack<NodePosition<Object, Geometry>> stack2 = Backpressure.search(condition, sub,\n                stack, 0);\n        assertTrue(stack2 == stack);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testRequestZeroWhenUnsubscribed() {\n        Subscriber<Object> sub = new Subscriber<Object>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Object t) {\n\n            }\n        };\n        sub.add(new Subscription() {\n\n            volatile boolean subscribed = true;\n\n            @Override\n            public void unsubscribe() {\n                subscribed = false;\n            }\n\n            @Override\n            public boolean isUnsubscribed() {\n                return !subscribed;\n            }\n        });\n        sub.unsubscribe();\n        Node<Object, Geometry> node = Mockito.mock(Node.class);\n        NodePosition<Object, Geometry> np = new NodePosition<Object, Geometry>(node, 1);\n        ImmutableStack<NodePosition<Object, Geometry>> stack = ImmutableStack\n                .<NodePosition<Object, Geometry>> empty().push(np);\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        ImmutableStack<NodePosition<Object, Geometry>> stack2 = Backpressure.search(condition, sub,\n                stack, 1);\n        assertTrue(stack2.isEmpty());\n    }\n\n    @Test\n    public void testBackpressureIterateWhenNodeHasMaxChildrenAndIsRoot() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        List<Entry<Object, Rectangle>> list = Arrays.asList(e1, e1, e1, e1);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }\n\n    @Test\n    public void testBackpressureRequestZero() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        List<Entry<Object, Rectangle>> list = Arrays.asList(e1, e1, e1, e1);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(new Subscriber<Entry<Object, Rectangle>>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Object, Rectangle> t) {\n                found.add(t);\n                request(0);\n            }\n        });\n        assertEquals(expected, found);\n    }\n\n    @Test\n    public void testBackpressureIterateWhenNodeHasMaxChildrenAndIsNotRoot() {\n        Entry<Object, Rectangle> e1 = RTreeTest.e(1);\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        for (int i = 1; i <= 17; i++)\n            list.add(e1);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }\n\n    @Test\n    public void testBackpressureIterateWhenConditionFailsAgainstNonLeafNode() {\n        Entry<Object, Rectangle> e1 = e(1);\n        List<Entry<Object, Rectangle>> list = new ArrayList<Entry<Object, Rectangle>>();\n        for (int i = 1; i <= 17; i++)\n            list.add(e1);\n        list.add(e(2));\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(list);\n        HashSet<Entry<Object, Rectangle>> expected = new HashSet<Entry<Object, Rectangle>>(list);\n        final HashSet<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.entries().subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }\n\n    @Test\n    public void testBackpressureIterateWhenConditionFailsAgainstLeafNode() {\n        Entry<Object, Rectangle> e3 = e(3);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(e(1)).add(e3);\n        Set<Entry<Object, Rectangle>> expected = Collections.singleton(e3);\n        final Set<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.search(e3.geometry()).subscribe(backpressureSubscriber(found));\n        assertEquals(expected, found);\n    }\n\n    @Test\n    public void testBackpressureFastPathNotInitiatedTwice() {\n        Entry<Object, Rectangle> e3 = e(3);\n        RTree<Object, Rectangle> tree = RTree.star().maxChildren(4).<Object, Rectangle> create()\n                .add(e(1)).add(e3);\n        Set<Entry<Object, Rectangle>> expected = Collections.singleton(e3);\n        final Set<Entry<Object, Rectangle>> found = new HashSet<Entry<Object, Rectangle>>();\n        tree.search(e3.geometry()).subscribe(new Subscriber<Entry<Object, Rectangle>>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Object, Rectangle> t) {\n                found.add(t);\n                request(Long.MAX_VALUE);\n            }\n        });\n        assertEquals(expected, found);\n    }\n\n    private static Subscriber<Entry<Object, Rectangle>> backpressureSubscriber(\n            final Set<Entry<Object, Rectangle>> found) {\n        return new Subscriber<Entry<Object, Rectangle>>() {\n\n            @Override\n            public void onStart() {\n                request(1);\n            }\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Object, Rectangle> t) {\n                found.add(t);\n                request(1);\n            }\n        };\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/OnSubscribeSearchTest.java.OnSubscribeSearchTest", "name": "OnSubscribeSearchTest", "file_path": "src/test/java/com/github/davidmoten/rtree/OnSubscribeSearchTest.java", "superclasses": "", "methods": ["[void]testSearchProducerThrowsExceptionFromRequestAll()", "[void]testSearchProducerThrowsExceptionFromRequestSome()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class OnSubscribeSearchTest {\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSearchProducerThrowsExceptionFromRequestAll() {\n        Node<Integer, Geometry> node = Mockito.mock(Node.class);\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        Subscriber<Entry<Integer, Geometry>> subscriber = Mockito.mock(Subscriber.class);\n        RuntimeException error = new RuntimeException();\n        Mockito.doThrow(error).when(node).searchWithoutBackpressure(condition, subscriber);\n        SearchProducer<Integer, Geometry> p = new OnSubscribeSearch.SearchProducer<Integer, Geometry>(\n                node, condition, subscriber);\n        p.request(Long.MAX_VALUE);\n        Mockito.verify(subscriber).onError(error);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    @Test\n    public void testSearchProducerThrowsExceptionFromRequestSome() {\n        Node<Integer, Point> node = new LeafDefault<Integer, Point>(Collections.singletonList(Entries.entry(\n                1, Geometries.point(1, 1))), null);\n\n        Func1<Geometry, Boolean> condition = Mockito.mock(Func1.class);\n        Subscriber<Entry<Integer, Point>> subscriber = new Subscriber<Entry<Integer, Point>>() {\n\n            @Override\n            public void onCompleted() {\n\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Entry<Integer, Point> t) {\n\n            }\n        };\n        SearchProducer<Integer, Point> p = new OnSubscribeSearch.SearchProducer<Integer, Point>(\n                node, condition, subscriber);\n        p.request(1);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/NodePositionTest.java.NodePositionTest", "name": "NodePositionTest", "file_path": "src/test/java/com/github/davidmoten/rtree/NodePositionTest.java", "superclasses": "", "methods": ["[void]testToString()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class NodePositionTest {\n\n    @Test\n    public void testToString() {\n        @SuppressWarnings(\"unchecked\")\n        Node<Object, Rectangle> node = Mockito.mock(Node.class);\n        assertTrue(new NodePosition<Object, Rectangle>(node, 1).toString()\n                .startsWith(\"NodePosition [\"));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/LeafTest.java.LeafTest", "name": "LeafTest", "file_path": "src/test/java/com/github/davidmoten/rtree/LeafTest.java", "superclasses": "", "methods": ["[void]testCannotHaveZeroChildren()", "[void]testMbr()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class LeafTest {\n\n    private static Context<Object, Rectangle> context = new Context<Object, Rectangle>(2, 4,\n            new SelectorMinimalAreaIncrease(), new SplitterQuadratic(),\n            Factories.<Object, Rectangle>defaultFactory());\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCannotHaveZeroChildren() {\n        new LeafDefault<Object, Rectangle>(new ArrayList<Entry<Object, Rectangle>>(), context);\n    }\n\n    @Test\n    public void testMbr() {\n        Rectangle r1 = Geometries.rectangle(0d, 1, 3, 5);\n        Rectangle r2 = Geometries.rectangle(1d, 2, 4, 6);\n        Rectangle r = new LeafDefault<Object, Rectangle>(\n                Arrays.asList(Entries.entry(new Object(), r1), Entries.entry(new Object(), r2)),\n                context).geometry().mbr();\n        assertEquals(r1.add(r2), r);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static Context<Object, Rectangle> context = new Context<Object, Rectangle>(2, 4,\n            new SelectorMinimalAreaIncrease(), new SplitterQuadratic(),\n            Factories.<Object, Rectangle>defaultFactory());", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "Context<Object, Rectangle>", "name": "context = new Context<Object, Rectangle>(2, 4,\n            new SelectorMinimalAreaIncrease(), new SplitterQuadratic(),\n            Factories.<Object, Rectangle>defaultFactory())", "syntax_pass": true}]}, {"uris": "src/test/java/com/github/davidmoten/rtree/NonLeafTest.java.NonLeafTest", "name": "NonLeafTest", "file_path": "src/test/java/com/github/davidmoten/rtree/NonLeafTest.java", "superclasses": "", "methods": ["[void]testNonLeafPrecondition()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class NonLeafTest {\n\n    @Test(expected=IllegalArgumentException.class)\n    public void testNonLeafPrecondition() {\n        new NonLeafDefault<Object,Geometry>(Collections.<Node<Object,Geometry>>emptyList(), null);\n    }\n    \n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/EntriesTest.java.EntriesTest", "name": "EntriesTest", "file_path": "src/test/java/com/github/davidmoten/rtree/EntriesTest.java", "superclasses": "", "methods": ["[void]testValue()", "[void]testEquality()", "[void]testEqualityWithGeometry()", "[void]testInequality()", "[void]testInequalityWithNull()", "[void]testIsUtilityClass()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class EntriesTest {\n\n    @Test\n    public void testValue() {\n        assertEquals(1, (int) Entries.entry(1, Geometries.point(0, 0)).value());\n    }\n\n    @Test\n    public void testEquality() {\n        assertEquals(Entries.entry(1, Geometries.point(0, 0)), Entries.entry(1, Geometries.point(0, 0)));\n    }\n\n    @Test\n    public void testEqualityWithGeometry() {\n        assertNotEquals(Entries.entry(1, Geometries.point(0, 0)),\n                Entries.entry(1, Geometries.point(0, 1)));\n    }\n\n    @Test\n    public void testInequality() {\n        assertNotEquals(Entries.entry(1, Geometries.point(0, 0)),\n                Entries.entry(2, Geometries.point(0, 0)));\n    }\n\n    @Test\n    public void testInequalityWithNull() {\n        assertFalse(Entries.entry(1, Geometries.point(0, 0)).equals(null));\n    }\n    \n    @Test\n    public void testIsUtilityClass() {\n        Asserts.assertIsUtilityClass(Entries.class);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/SerializerHelperTest.java.SerializerHelperTest", "name": "SerializerHelperTest", "file_path": "src/test/java/com/github/davidmoten/rtree/SerializerHelperTest.java", "superclasses": "", "methods": ["[void]assertIsUtilityClass()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SerializerHelperTest {\n    \n    @Test\n    public void assertIsUtilityClass() {\n        Asserts.assertIsUtilityClass(SerializerHelper.class);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java.SerializerFlatBuffersTest", "name": "SerializerFlatBuffersTest", "file_path": "src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java", "superclasses": "", "methods": ["[void]testSerializeRoundTripToFlatBuffersSingleArray()", "[void]testSerializeRoundTripToDefaultStructure()", "[void]testSerializeRoundTripToFlatBuffersSingleArrayBackpressure()", "[void]testSerializeRoundTripToDefaultStructureBackpressure()", "[void]testInputStreamNotAsLongAsExpected()", "[void]testInputStreamReturnsArrayInSmallChunks()"], "method_uris": ["src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java.SerializerFlatBuffersTest.[void]roundTrip(InternalStructure,boolean)", "src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java.SerializerFlatBuffersTest.[Serializer<Object, Point>]createSerializer()", "src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java.SerializerFlatBuffersTest.[void]serialize(RTree<Object, Point>,long,File,FileOutputStream,Serializer<Object, Point>)", "src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java.SerializerFlatBuffersTest.[void]deserialize(InternalStructure,File,Serializer<Object, Point>,boolean)", "src/test/java/com/github/davidmoten/rtree/fbs/SerializerFlatBuffersTest.java.SerializerFlatBuffersTest.[void]main(String[])"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SerializerFlatBuffersTest {\n\n    private static final byte[] EMPTY = new byte[] {};\n\n    @Test\n    public void testSerializeRoundTripToFlatBuffersSingleArray() throws Exception {\n        roundTrip(InternalStructure.SINGLE_ARRAY, false);\n    }\n\n    @Test\n    public void testSerializeRoundTripToDefaultStructure() throws Exception {\n        roundTrip(InternalStructure.DEFAULT, false);\n    }\n\n    @Test\n    public void testSerializeRoundTripToFlatBuffersSingleArrayBackpressure() throws Exception {\n        roundTrip(InternalStructure.SINGLE_ARRAY, true);\n    }\n\n    @Test\n    public void testSerializeRoundTripToDefaultStructureBackpressure() throws Exception {\n        roundTrip(InternalStructure.DEFAULT, true);\n    }\n\n    private void roundTrip(InternalStructure structure, boolean backpressure) throws Exception {\n        RTree<Object, Point> tree = RTree.star().maxChildren(10).create();\n        tree = tree.add(GreekEarthquakes.entries(Precision.SINGLE)).last().toBlocking().single();\n        long t = System.currentTimeMillis();\n        File file = new File(\"target/file\");\n        FileOutputStream os = new FileOutputStream(file);\n        Serializer<Object, Point> fbSerializer = createSerializer();\n\n        serialize(tree, t, file, os, fbSerializer);\n\n        deserialize(structure, file, fbSerializer, backpressure);\n    }\n\n    private static Serializer<Object, Point> createSerializer() {\n        Func1<Object, byte[]> serializer = new Func1<Object, byte[]>() {\n            @Override\n            public byte[] call(Object o) {\n                return EMPTY;\n            }\n        };\n        Func1<byte[], Object> deserializer = new Func1<byte[], Object>() {\n            @Override\n            public Object call(byte[] bytes) {\n                return null;\n            }\n        };\n        Serializer<Object, Point> fbSerializer = SerializerFlatBuffers.create(serializer,\n                deserializer);\n        return fbSerializer;\n    }\n\n    private static void serialize(RTree<Object, Point> tree, long t, File file, FileOutputStream os,\n            Serializer<Object, Point> fbSerializer) throws IOException {\n        fbSerializer.write(tree, os);\n        os.close();\n        System.out.println(\"written in \" + (System.currentTimeMillis() - t) + \"ms, \" + \"file size=\"\n                + file.length() / 1000000.0 + \"MB\");\n        System.out.println(\"bytes per entry=\" + file.length() / tree.size());\n    }\n\n    private static void deserialize(InternalStructure structure, File file,\n            Serializer<Object, Point> fbSerializer, boolean backpressure) throws Exception {\n        long t = System.currentTimeMillis();\n        InputStream is = new FileInputStream(file);\n        t = System.currentTimeMillis();\n        RTree<Object, Point> tr = fbSerializer.read(is, file.length(), structure);\n        System.out.println(tr.root().get());\n\n        System.out.println(\"read in \" + (System.currentTimeMillis() - t) + \"ms\");\n        Observable<Entry<Object, Point>> o = tr.search(Geometries.rectangle(40, 27.0, 40.5, 27.5));\n        if (backpressure)\n            o = o.take(10000);\n        int found = o.count().toBlocking().single();\n        System.out.println(\"found=\" + found);\n        assertEquals(22, found);\n        System.out.println(tr.size());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testInputStreamNotAsLongAsExpected() throws IOException {\n        SerializerFlatBuffers.readFully(new ByteArrayInputStream(new byte[10]), 12);\n    }\n\n    @Test\n    public void testInputStreamReturnsArrayInSmallChunks() throws IOException {\n        InputStream is = new InputStream() {\n\n            int i = 0;\n\n            @Override\n            public int read() throws IOException {\n                i += 1;\n                if (i == 1) {\n                    return 1;\n                } else if (i == 2) {\n                    throw new IOException();\n                } else {\n                    return 1;\n                }\n            }\n\n        };\n        byte[] b = SerializerFlatBuffers.readFully(is, 2);\n        assertEquals(2, b.length);\n        assertEquals(1, b[0]);\n        assertEquals(1, b[0]);\n    }\n\n    public static void main(String[] args) throws Exception {\n        // use this with jvisualvm and heap dump, find biggest objects to check\n        // memory usage of rtree\n        // deserialize(InternalStructure.FLATBUFFERS_SINGLE_ARRAY, new\n        // File(\"target/file\"),\n        // createSerializer());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final byte[] EMPTY = new byte[] {};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "byte[]", "name": "EMPTY = new byte[] {}", "syntax_pass": true}]}, {"uris": "src/test/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelperTest.java.FlatBuffersHelperTest", "name": "FlatBuffersHelperTest", "file_path": "src/test/java/com/github/davidmoten/rtree/fbs/FlatBuffersHelperTest.java", "superclasses": "", "methods": ["[void]isUtilityClass()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class FlatBuffersHelperTest {\n\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(FlatBuffersHelper.class);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/geometry/IntersectsTest.java.IntersectsTest", "name": "IntersectsTest", "file_path": "src/test/java/com/github/davidmoten/rtree/geometry/IntersectsTest.java", "superclasses": "", "methods": ["[void]testConstructorIsPrivate()", "[void]testRectangleIntersectsCircle()", "[void]testRectangleDoesNotIntersectCircle()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IntersectsTest {\n\n    @Test\n    public void testConstructorIsPrivate() {\n        Asserts.assertIsUtilityClass(Intersects.class);\n    }\n\n    @Test\n    public void testRectangleIntersectsCircle() {\n        assertTrue(\n                Intersects.rectangleIntersectsCircle.call(rectangle(0, 0, 0, 0), circle(0, 0, 1)));\n    }\n\n    @Test\n    public void testRectangleDoesNotIntersectCircle() {\n        assertFalse(Intersects.rectangleIntersectsCircle.call(rectangle(0, 0, 0, 0),\n                circle(100, 100, 1)));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/geometry/GeometriesTest.java.GeometriesTest", "name": "GeometriesTest", "file_path": "src/test/java/com/github/davidmoten/rtree/geometry/GeometriesTest.java", "superclasses": "", "methods": ["[void]testPrivateConstructorForCoverageOnly()", "[void]testNormalizeLongitude()", "[void]testNormalizeLongitude2()", "[void]testNormalizeLongitude3()", "[void]testNormalizeLongitude3_1()", "[void]testNormalizeLongitude3_2()", "[void]testNormalizeLongitude3_3()", "[void]testNormalizeLongitude3_4()", "[void]testNormalizeLongitude4()", "[void]testNormalizeLongitude5()", "[void]testNormalizeLongitude2Neg()", "[void]testNormalizeLongitude3Neg()", "[void]testNormalizeLongitude4Neg()", "[void]testNormalizeLongitude5Neg()", "[void]testRectangleLatLong()", "[void]testRectangleLatLong2()", "[void]testPointLatLong()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class GeometriesTest {\n\n    private static final double PRECISION = 0.0001;\n\n    @Test\n    public void testPrivateConstructorForCoverageOnly() {\n        Asserts.assertIsUtilityClass(Geometries.class);\n    }\n\n    @Test\n    public void testNormalizeLongitude() {\n        assertEquals(0, Geometries.normalizeLongitude(0), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude2() {\n        assertEquals(89, Geometries.normalizeLongitude(89), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3() {\n        assertEquals(179, Geometries.normalizeLongitude(179), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3_1() {\n        assertEquals(-180, Geometries.normalizeLongitude(180), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3_2() {\n        assertEquals(-180, Geometries.normalizeLongitude(-180), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3_3() {\n        assertEquals(-179, Geometries.normalizeLongitude(-179), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3_4() {\n        assertEquals(179, Geometries.normalizeLongitude(-181), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude4() {\n        assertEquals(-179, Geometries.normalizeLongitude(181), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude5() {\n        assertEquals(-179, Geometries.normalizeLongitude(541), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude2Neg() {\n        assertEquals(-89, Geometries.normalizeLongitude(-89), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude3Neg() {\n        assertEquals(-179, Geometries.normalizeLongitude(-179), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude4Neg() {\n        assertEquals(179, Geometries.normalizeLongitude(-181), PRECISION);\n    }\n\n    @Test\n    public void testNormalizeLongitude5Neg() {\n        assertEquals(179, Geometries.normalizeLongitude(-541), PRECISION);\n    }\n\n    @Test\n    public void testRectangleLatLong() {\n        Rectangle r = Geometries.rectangleGeographic(10, -10, 5, 10);\n        assertEquals(10, r.x1(), PRECISION);\n        assertEquals(365, r.x2(), PRECISION);\n        assertEquals(-10, r.y1(), PRECISION);\n        assertEquals(10, r.y2(), PRECISION);\n    }\n\n    @Test\n    public void testRectangleLatLong2() {\n        Rectangle r = Geometries.rectangleGeographic(5, -10, 10, 10);\n        assertEquals(5, r.x1(), PRECISION);\n        assertEquals(10, r.x2(), PRECISION);\n    }\n\n    @Test\n    public void testPointLatLong() {\n        Point point = Geometries.pointGeographic(181, 25);\n        assertEquals(-179, point.x(), PRECISION);\n        assertEquals(25, point.y(), PRECISION);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final double PRECISION = 0.0001;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "PRECISION = 0.0001", "syntax_pass": true}]}, {"uris": "src/test/java/com/github/davidmoten/rtree/geometry/RectangleTest.java.RectangleTest", "name": "RectangleTest", "file_path": "src/test/java/com/github/davidmoten/rtree/geometry/RectangleTest.java", "superclasses": "", "methods": ["[void]testDistanceToSelfIsZero()", "[void]testXParametersWrongOrderThrowsException()", "[void]testYParametersWrongOrderThrowsException()", "[void]testDistanceToOverlapIsZero()", "[void]testDistanceWhenSeparatedByXOnly()", "[void]testDistanceWhenSeparatedByXOnlyAndOverlapOnY()", "[void]testDistanceWhenSeparatedByDiagonally()", "[void]testInequalityWithNull()", "[void]testSimpleEquality()", "[void]testSimpleInEquality1()", "[void]testSimpleInEquality2()", "[void]testSimpleInEquality3()", "[void]testSimpleInEquality4()", "[void]testGeometry()", "[void]testIntersects()", "[void]testIntersectsNoRectangleContainsCornerOfAnother()", "[void]testIntersectsOneRectangleContainsTheOther()", "[void]testIntersectsOneRectangleReturnsTrueDespiteZeroArea()", "[void]testContains()", "[void]testContainsReturnsFalseWhenLessThanMinY()", "[void]testContainsReturnsFalseWhenGreaterThanMaxY()", "[void]testContainsReturnsFalseWhenGreaterThanMaxX()", "[void]testContainsReturnsFalseWhenLessThanMinX()", "[void]testIntersectionAreWhenEqual()", "[void]testIntersectionAreaWhenDontIntersect()", "[void]testIntersectionAreaCornerIntersect()", "[void]testIntersectionAreaTopIntersect()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RectangleTest {\n\n    private static final double PRECISION = 0.00001;\n\n    @Test\n    public void testDistanceToSelfIsZero() {\n        Rectangle r = rectangle(0, 0, 1, 1);\n        assertEquals(0, r.distance(r), PRECISION);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testXParametersWrongOrderThrowsException() {\n        rectangle(2, 0, 1, 1);\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testYParametersWrongOrderThrowsException() {\n        rectangle(0, 2, 1, 1);\n    }\n\n    @Test\n    public void testDistanceToOverlapIsZero() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(1, 1, 3, 3);\n\n        assertEquals(0, r.distance(r2), PRECISION);\n        assertEquals(0, r2.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testDistanceWhenSeparatedByXOnly() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(3, 0, 4, 2);\n\n        assertEquals(1, r.distance(r2), PRECISION);\n        assertEquals(1, r2.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testDistanceWhenSeparatedByXOnlyAndOverlapOnY() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(3, 1.5f, 4, 3.5f);\n\n        assertEquals(1, r.distance(r2), PRECISION);\n        assertEquals(1, r2.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testDistanceWhenSeparatedByDiagonally() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(3, 6, 10, 8);\n\n        assertEquals(Math.sqrt(26), r.distance(r2), PRECISION);\n        assertEquals(Math.sqrt(26), r2.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testInequalityWithNull() {\n        assertFalse(rectangle(0, 0, 1, 1).equals(null));\n    }\n\n    @Test\n    public void testSimpleEquality() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(0, 0, 2, 1);\n\n        assertTrue(r.equals(r2));\n    }\n\n    @Test\n    public void testSimpleInEquality1() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(0, 0, 2, 2);\n\n        assertFalse(r.equals(r2));\n    }\n\n    @Test\n    public void testSimpleInEquality2() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(1, 0, 2, 1);\n\n        assertFalse(r.equals(r2));\n    }\n\n    @Test\n    public void testSimpleInEquality3() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        Rectangle r2 = rectangle(0, 1, 2, 1);\n\n        assertFalse(r.equals(r2));\n    }\n\n    @Test\n    public void testSimpleInEquality4() {\n        Rectangle r = rectangle(0, 0, 2, 2);\n        Rectangle r2 = rectangle(0, 0, 1, 2);\n\n        assertFalse(r.equals(r2));\n    }\n\n    @Test\n    public void testGeometry() {\n        Rectangle r = rectangle(0, 0, 2, 1);\n        assertTrue(r.equals(r.geometry()));\n    }\n\n    @Test\n    public void testIntersects() {\n        Rectangle a = rectangle(14, 14, 86, 37);\n        Rectangle b = rectangle(13, 23, 50, 80);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }\n\n    @Test\n    public void testIntersectsNoRectangleContainsCornerOfAnother() {\n        Rectangle a = rectangle(10, 10, 50, 50);\n        Rectangle b = rectangle(28.0, 4.0, 34.0, 85.0);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }\n\n    @Test\n    public void testIntersectsOneRectangleContainsTheOther() {\n        Rectangle a = rectangle(10, 10, 50, 50);\n        Rectangle b = rectangle(20, 20, 40, 40);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }\n\n    @Test\n    public void testIntersectsOneRectangleReturnsTrueDespiteZeroArea() {\n        Rectangle a = rectangle(10, 50, 50, 50);\n        Rectangle b = rectangle(20, 20, 60, 60);\n        assertTrue(a.intersects(b));\n        assertTrue(b.intersects(a));\n    }\n    \n    @Test\n    public void testContains() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertTrue(r.contains(20, 30));\n    }\n\n    @Test\n    public void testContainsReturnsFalseWhenLessThanMinY() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(20, 19));\n    }\n\n    @Test\n    public void testContainsReturnsFalseWhenGreaterThanMaxY() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(20, 41));\n    }\n\n    @Test\n    public void testContainsReturnsFalseWhenGreaterThanMaxX() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(31, 30));\n    }\n\n    @Test\n    public void testContainsReturnsFalseWhenLessThanMinX() {\n        Rectangle r = rectangle(10, 20, 30, 40);\n        assertFalse(r.contains(9, 30));\n    }\n\n    @Test\n    public void testIntersectionAreWhenEqual() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(10, 10, 30, 20);\n        assertEquals(200f, a.intersectionArea(b), 0.0001);\n    }\n\n    @Test\n    public void testIntersectionAreaWhenDontIntersect() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(50, 50, 60, 60);\n        assertEquals(0f, a.intersectionArea(b), 0.0001);\n    }\n\n    @Test\n    public void testIntersectionAreaCornerIntersect() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(28, 17, 40, 40);\n        assertEquals(6f, a.intersectionArea(b), 0.0001);\n    }\n\n    @Test\n    public void testIntersectionAreaTopIntersect() {\n        Rectangle a = rectangle(10, 10, 30, 20);\n        Rectangle b = rectangle(8, 17, 40, 40);\n        assertEquals(60f, a.intersectionArea(b), 0.0001);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final double PRECISION = 0.00001;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "PRECISION = 0.00001", "syntax_pass": true}]}, {"uris": "src/test/java/com/github/davidmoten/rtree/geometry/CircleTest.java.CircleTest", "name": "CircleTest", "file_path": "src/test/java/com/github/davidmoten/rtree/geometry/CircleTest.java", "superclasses": "", "methods": ["[void]testCoordinates()", "[void]testDistance()", "[void]testMbr()", "[void]testEquality()", "[void]testInequalityRadius()", "[void]testInequalityX()", "[void]testInequalityY()", "[void]testInequalityWithNull()", "[void]testHashCode()", "[void]testDistanceIsZeroWhenIntersects()", "[void]testIntersects2()", "[void]testIntersects3()", "[void]testIntersectsReturnsTrue()", "[void]testIntersectsReturnsFalse()", "[void]testIntersects()", "[void]testDoNotIntersect()", "[void]testIntersectsPoint()", "[void]testDoesNotIntersectPoint()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CircleTest {\n    private static final double PRECISION = 0.000001;\n\n    @Test\n    public void testCoordinates() {\n        Circle circle = circle(1, 2, 3);\n        assertEquals(1, circle.x(), PRECISION);\n        assertEquals(2, circle.y(), PRECISION);\n    }\n\n    @Test\n    public void testDistance() {\n        Circle circle = circle(0, 0, 1);\n        Rectangle r = Geometries.rectangle(1, 1, 2, 2);\n        assertEquals(Math.sqrt(2) - 1, circle.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testMbr() {\n        Circle circle = circle(1, 2, 3);\n        Rectangle r = Geometries.rectangle(-2, -1, 4, 5);\n        assertEquals(r, circle.mbr());\n    }\n\n    @Test\n    public void testEquality() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(1, 2, 3);\n        assertEquals(circle1, circle2);\n    }\n\n    @Test\n    public void testInequalityRadius() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(1, 2, 4);\n        assertNotEquals(circle1, circle2);\n    }\n\n    @Test\n    public void testInequalityX() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(2, 2, 3);\n        assertNotEquals(circle1, circle2);\n    }\n\n    @Test\n    public void testInequalityY() {\n        Circle circle1 = circle(1, 2, 3);\n        Circle circle2 = circle(1, 3, 3);\n        assertNotEquals(circle1, circle2);\n    }\n\n    @Test\n    public void testInequalityWithNull() {\n        Circle circle = circle(1, 2, 3);\n        assertFalse(circle.equals(null));\n    }\n\n    @Test\n    public void testHashCode() {\n        Circle circle = circle(1, 2, 3);\n        assertEquals(1606448223, circle.hashCode());\n    }\n\n    @Test\n    public void testDistanceIsZeroWhenIntersects() {\n        Circle circle = circle(0, 0, 1);\n        assertTrue(circle.distance(Geometries.rectangle(0, 1, 0, 1)) == 0);\n    }\n\n    @Test\n    public void testIntersects2() {\n        Circle circle = circle(0, 0, 1);\n        assertTrue(circle.distance(Geometries.rectangle(0, 1.1, 0, 1.1)) != 0);\n    }\n\n    @Test\n    public void testIntersects3() {\n        Circle circle = circle(0, 0, 1);\n        assertTrue(circle.distance(Geometries.rectangle(1, 1, 1, 1)) != 0);\n    }\n\n    @Test\n    public void testIntersectsReturnsTrue() {\n        assertTrue(circle(0, 0, 1).intersects(Geometries.rectangle(0, 0, 1, 1)));\n    }\n\n    @Test\n    public void testIntersectsReturnsFalse() {\n        assertFalse(circle(0, 0, 1).intersects(Geometries.rectangle(10, 10, 11, 11)));\n    }\n\n    @Test\n    public void testIntersects() {\n        Circle a = circle(0, 0, 1);\n        Circle b = circle(0.1, 0.1, 1);\n        assertTrue(Intersects.circleIntersectsCircle.call(a, b));\n    }\n\n    @Test\n    public void testDoNotIntersect() {\n        Circle a = circle(0, 0, 1);\n        Circle b = circle(100, 100, 1);\n        assertFalse(Intersects.circleIntersectsCircle.call(a, b));\n    }\n\n    @Test\n    public void testIntersectsPoint() {\n        assertTrue(circle(0, 0, 1).intersects(Geometries.point(0, 0)));\n    }\n\n    @Test\n    public void testDoesNotIntersectPoint() {\n        assertFalse(circle(0, 0, 1).intersects(Geometries.point(100, 100)));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final double PRECISION = 0.000001;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "PRECISION = 0.000001", "syntax_pass": true}]}, {"uris": "src/test/java/com/github/davidmoten/rtree/geometry/PointTest.java.PointTest", "name": "PointTest", "file_path": "src/test/java/com/github/davidmoten/rtree/geometry/PointTest.java", "superclasses": "", "methods": ["[void]testCoordinates()", "[void]testDistanceToRectangle()", "[void]testDistanceToPoint()", "[void]testMbr()", "[void]testPointIntersectsItself()", "[void]testIntersectIsFalseWhenPointsDiffer()", "[void]testEquality()", "[void]testInequality()", "[void]testInequalityToNull()", "[void]testHashCode()", "[void]testDoesNotContain()", "[void]testContains()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PointTest {\n\n\tprivate static final double PRECISION = 0.000001;\n\n\t@Test\n\tpublic void testCoordinates() {\n\t\tPoint point = Geometries.point(1, 2);\n\t\tassertEquals(1, point.x(), PRECISION);\n\t\tassertEquals(2, point.y(), PRECISION);\n\t}\n\n\t@Test\n\tpublic void testDistanceToRectangle() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tRectangle r = Geometries.rectangle(4, 6, 4, 6);\n\t\tassertEquals(5, p1.distance(r), PRECISION);\n\t}\n\n\t@Test\n\tpublic void testDistanceToPoint() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(4, 6);\n\t\tassertEquals(5, p1.distance(p2), PRECISION);\n\t}\n\n\t@Test\n\tpublic void testMbr() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 2);\n\t\tassertEquals(p, p2);\n\t}\n\n\t@Test\n\tpublic void testPointIntersectsItself() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertTrue(p.distance(p.mbr()) == 0);\n\t}\n\n\t@Test\n\tpublic void testIntersectIsFalseWhenPointsDiffer() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 2.000001);\n\t\tassertFalse(p1.distance(p2.mbr()) == 0);\n\t}\n\n\t@Test\n\tpublic void testEquality() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 2);\n\t\tassertTrue(p1.equals(p2));\n\t}\n\n\t@Test\n\tpublic void testInequality() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tPoint p2 = Geometries.point(1, 3);\n\t\tassertFalse(p1.equals(p2));\n\t}\n\n\t@Test\n\tpublic void testInequalityToNull() {\n\t\tPoint p1 = Geometries.point(1, 2);\n\t\tassertFalse(p1.equals(null));\n\t}\n\n\t@Test\n\tpublic void testHashCode() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertEquals(-260045887, p.hashCode());\n\t}\n\n\t@Test\n\tpublic void testDoesNotContain() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertFalse(p.contains(1, 3));\n\t}\n\t\n\t@Test\n\tpublic void testContains() {\n\t\tPoint p = Geometries.point(1, 2);\n\t\tassertTrue(p.contains(1, 2));\n\t}\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final double PRECISION = 0.000001;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "PRECISION = 0.000001", "syntax_pass": true}]}, {"uris": "src/test/java/com/github/davidmoten/rtree/geometry/LineTest.java.LineTest", "name": "LineTest", "file_path": "src/test/java/com/github/davidmoten/rtree/geometry/LineTest.java", "superclasses": "", "methods": ["[void]testDoesIntersectOtherLine()", "[void]testDoesNotIntersectLine()", "[void]testDoesIntersectRectangle()", "[void]testDoesNotIntersectRectangle()", "[void]testLineIntersectsCircle()", "[void]testLineDoesNotIntersectCircle()", "[void]testLineDoesNotIntersectCircleEast()", "[void]testLineDoesIntersectCircleEast()", "[void]testLineDoesNotIntersectCircleWest()", "[void]testLineDoesIntersectCircleWest()", "[void]testLineDoesNotIntersectCircleNorth()", "[void]testLineDoesNotIntersectCircleSouth()", "[void]testLineDoesIntersectCircleSouth()", "[void]testLineMbr()", "[void]testLineSameXWithinCircle()", "[void]testLineIsPointWithinCircle()", "[void]testLineIsPointOutsideCircle()", "[void]testLineDistanceToRectangle()", "[void]testLineDistanceToRectangleIsZeroWhenOneEndIsInside()", "[void]testLineDistanceToRectangleIsZeroWhenOtherEndIsInside()", "[void]testLineDistanceToRectangleIsZeroWhenContainsWestEdge()", "[void]testLineDistanceToRectangleIsZeroWhenContainsNorthEdge()", "[void]testLineDistanceToRectangleIsZeroWhenContainsSouthEdge()", "[void]testLineDistanceToRectangleIsZeroWhenContainsEastEdge()", "[void]testLineDoesNotIntersectsPoint()", "[void]testLineDoesIntersectPoint()", "[void]testLineDoubleIntersectsWithHorizontalLine()", "[void]testLineFloatIntersectsWithHorizontalLine()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public final class LineTest {\n\n    private static final double PRECISION = 0.00001;\n\n    @Test\n    public void testDoesIntersectOtherLine() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Line b = Geometries.line(0, -1, 0, 1);\n        assertTrue(Intersects.lineIntersectsLine.call(a, b));\n    }\n\n    @Test\n    public void testDoesNotIntersectLine() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Line b = Geometries.line(1.1, -1, 1.1, 1);\n        assertFalse(Intersects.lineIntersectsLine.call(a, b));\n    }\n\n    @Test\n    public void testDoesIntersectRectangle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Rectangle b = Geometries.rectangle(0.2, -0.5, 0.8, 0.5);\n        assertTrue(Intersects.lineIntersectsRectangle.call(a, b));\n    }\n\n    @Test\n    public void testDoesNotIntersectRectangle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Rectangle b = Geometries.rectangle(1.2, -0.5, 1.8, 0.5);\n        assertFalse(Intersects.lineIntersectsRectangle.call(a, b));\n    }\n\n    @Test\n    public void testLineIntersectsCircle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 0.5, 1);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesNotIntersectCircle() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 0.5, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesNotIntersectCircleEast() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(1.5, 0, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesIntersectCircleEast() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(1.5, 0, 0.6);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesNotIntersectCircleWest() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(-1.5, 0, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesIntersectCircleWest() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(-1.5, 0, 0.6);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesNotIntersectCircleNorth() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 1.5, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesNotIntersectCircleSouth() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 1.5, 0.4);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDoesIntersectCircleSouth() {\n        Line a = Geometries.line(-1, 0, 1, 0);\n        Circle c = Geometries.circle(0, 1.5, 0.6);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineMbr() {\n        Line a = Geometries.line(-2, 3, 1, -1);\n        Rectangle mbr = a.mbr();\n        assertEquals(-2, mbr.x1(), PRECISION);\n        assertEquals(-1, mbr.y1(), PRECISION);\n        assertEquals(1, mbr.x2(), PRECISION);\n        assertEquals(3, mbr.y2(), PRECISION);\n    }\n\n    @Test\n    public void testLineSameXWithinCircle() {\n        Line a = Geometries.line(1, 2, 1, 4);\n        Circle c = Geometries.circle(1, 3, 2);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineIsPointWithinCircle() {\n        Line a = Geometries.line(1, 2, 1, 2);\n        Circle c = Geometries.circle(1, 3, 2);\n        assertTrue(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineIsPointOutsideCircle() {\n        Line a = Geometries.line(1, 10, 1, 10);\n        Circle c = Geometries.circle(1, 3, 2);\n        assertFalse(Intersects.lineIntersectsCircle.call(a, c));\n    }\n\n    @Test\n    public void testLineDistanceToRectangle() {\n        Line a = Geometries.line(1, 2, 1, 2);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(Math.sqrt(5), a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenOneEndIsInside() {\n        Line a = Geometries.line(1, 2, 4, 4);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenOtherEndIsInside() {\n        Line a = Geometries.line(4, 4, 1, 2);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsWestEdge() {\n        Line a = Geometries.line(3, 1, 3, 10);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsNorthEdge() {\n        Line a = Geometries.line(2, 7, 10, 7);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsSouthEdge() {\n        Line a = Geometries.line(2, 3, 10, 3);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDistanceToRectangleIsZeroWhenContainsEastEdge() {\n        Line a = Geometries.line(7, 1, 7, 10);\n        Rectangle r = Geometries.rectangle(3, 3, 7, 7);\n        assertEquals(0, a.distance(r), PRECISION);\n    }\n\n    @Test\n    public void testLineDoesNotIntersectsPoint() {\n        assertFalse(Geometries.line(1.5, 1.5, 2.6, 2.5).intersects(point(2, 2)));\n    }\n\n    @Test\n    public void testLineDoesIntersectPoint() {\n        assertTrue(Geometries.line(1.5, 1.5, 2.5, 2.5).intersects(point(2, 2)));\n    }\n    \n    @Test\n    public void testLineDoubleIntersectsWithHorizontalLine() {\n        {  // test expectation on Line2D.Double.intersectsLine which we depend on \n            Line2D.Double line = new Line2D.Double(35.0d, -25.0d, 45.0d, -25.0d);\n            assertTrue(line.intersectsLine(40.0d, -20.0d, 45.0d, -40.0d));\n        }\n        {\n            Line line = Geometries.line(40.0d, -20.0d, 45.0d, -40.0d);\n            Line horizontalLine = Geometries.line(35.0d, -25.0d, 45.0d, -25.0d);\n            \n            assertTrue(line.intersects(horizontalLine.mbr()));\n        }\n    }\n    \n    @Test\n    public void testLineFloatIntersectsWithHorizontalLine() {\n        {  // test expectation on Line2D.Double.intersectsLine which we depend on \n            Line2D.Float line = new Line2D.Float(35.0f, -25.0f, 45.0f, -25.0f);\n            assertTrue(line.intersectsLine(40.0f, -20.0f, 45.0f, -40.0f));\n        }\n        {\n            Line line = Geometries.line(40.0f, -20.0f, 45.0f, -40.0f);\n            Line horizontalLine = Geometries.line(35.0f, -25.0f, 45.0f, -25.0f);\n            \n            assertTrue(line.intersects(horizontalLine.mbr()));\n        }\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final double PRECISION = 0.00001;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "PRECISION = 0.00001", "syntax_pass": true}]}, {"uris": "src/test/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtilTest.java.GeometryUtilTest", "name": "GeometryUtilTest", "file_path": "src/test/java/com/github/davidmoten/rtree/geometry/internal/GeometryUtilTest.java", "superclasses": "", "methods": ["[void]isUtilityClass()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class GeometryUtilTest {\n    \n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(GeometryUtil.class);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/internal/RectangleUtilTest.java.RectangleUtilTest", "name": "RectangleUtilTest", "file_path": "src/test/java/com/github/davidmoten/rtree/internal/RectangleUtilTest.java", "superclasses": "", "methods": ["[void]isUtilityClass()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RectangleUtilTest {\n\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(RectangleUtil.class);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/internal/NonLeafHelperTest.java.NonLeafHelperTest", "name": "NonLeafHelperTest", "file_path": "src/test/java/com/github/davidmoten/rtree/internal/NonLeafHelperTest.java", "superclasses": "", "methods": ["[void]isUtilityClass()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class NonLeafHelperTest {\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(NonLeafHelper.class);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/internal/LeafHelperTest.java.LeafHelperTest", "name": "LeafHelperTest", "file_path": "src/test/java/com/github/davidmoten/rtree/internal/LeafHelperTest.java", "superclasses": "", "methods": ["[void]isUtilityClass()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class LeafHelperTest {\n\n    @Test\n    public void isUtilityClass() {\n        Asserts.assertIsUtilityClass(LeafHelper.class);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueueTest.java.BoundedPriorityQueueTest", "name": "BoundedPriorityQueueTest", "file_path": "src/test/java/com/github/davidmoten/rtree/internal/util/BoundedPriorityQueueTest.java", "superclasses": "", "methods": ["[void]emptyQueueAsListIsEmpty()", "[void]singleItemReturnsSingleItem()", "[void]twoItemsReturnsSingleItemWhenMaxIsOne()", "[void]twoItemsReturnsSingleItemWhenMaxIsOneInputOrderFlipped()", "[void]threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderFlipped()", "[void]threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderIncreasing()", "[void]threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed()", "[void]threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed2()", "[void]threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderFlipped()", "[void]threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderIncreasing()", "[void]threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderMixed()", "[void]threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderMixed2()", "[void]testInstantiateWithNegativeSizeThrowsIAE()", "[void]testInstantiateWithZeroSizeThrowsIAE()", "[void]testAddNullThrowsNPE()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BoundedPriorityQueueTest {\n\n    private static final Comparator<Integer> comparator = new Comparator<Integer>() {\n\n        @Override\n        public int compare(Integer o1, Integer o2) {\n            return o1.compareTo(o2);\n        }\n    };\n\n    @Test\n    public void emptyQueueAsListIsEmpty() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        assertTrue(q.asList().isEmpty());\n    }\n\n    @Test\n    public void singleItemReturnsSingleItem() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void twoItemsReturnsSingleItemWhenMaxIsOne() {\n        BoundedPriorityQueue<Integer> q = create(1, comparator);\n        q.add(1);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void twoItemsReturnsSingleItemWhenMaxIsOneInputOrderFlipped() {\n        BoundedPriorityQueue<Integer> q = create(1, comparator);\n        q.add(2);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderFlipped() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(3);\n        q.add(2);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderIncreasing() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(1);\n        q.add(2);\n        q.add(3);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(3);\n        q.add(1);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsTwoItemsWhenMaxIsOneInputOrderMixed2() {\n        BoundedPriorityQueue<Integer> q = create(2, comparator);\n        q.add(1);\n        q.add(3);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderFlipped() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(3);\n        q.add(2);\n        q.add(1);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderIncreasing() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(1);\n        q.add(2);\n        q.add(3);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderMixed() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(3);\n        q.add(1);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }\n\n    @Test\n    public void threeItemsReturnsThreeItemsWhenMaxIsOneInputOrderMixed2() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(1);\n        q.add(3);\n        q.add(2);\n        assertEquals(Sets.newHashSet(1, 2, 3), Sets.newHashSet(q.asList()));\n    }\n    \n    @Test(expected=IllegalArgumentException.class)\n    public void testInstantiateWithNegativeSizeThrowsIAE() {\n        create(-1, comparator);\n    }\n    \n    @Test(expected=IllegalArgumentException.class)\n    public void testInstantiateWithZeroSizeThrowsIAE() {\n        create(0, comparator);\n    }\n\n    @Test(expected=NullPointerException.class)\n    public void testAddNullThrowsNPE() {\n        BoundedPriorityQueue<Integer> q = create(10, comparator);\n        q.add(null);\n    }\n    \n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Comparator<Integer> comparator = new Comparator<Integer>() {\n\n        @Override\n        public int compare(Integer o1, Integer o2) {\n            return o1.compareTo(o2);\n        }\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Comparator<Integer>", "name": "comparator = new Comparator<Integer>() {\n\n        @Override\n        public int compare(Integer o1, Integer o2) {\n            return o1.compareTo(o2);\n        }\n    }", "syntax_pass": true}]}, {"uris": "src/test/java/com/github/davidmoten/rtree/internal/util/ObjectsHelperTest.java.ObjectsHelperTest", "name": "ObjectsHelperTest", "file_path": "src/test/java/com/github/davidmoten/rtree/internal/util/ObjectsHelperTest.java", "superclasses": "", "methods": ["[void]testAsClassIsAbsentIfNull()", "[void]testAsClassIsAbsentIfDifferentClass()", "[void]testAsClassIsPresentIfSameTypeAndNotNull()", "[void]coverPrivateConstructor()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ObjectsHelperTest {\n\n    @Test\n    public void testAsClassIsAbsentIfNull() {\n        assertFalse(ObjectsHelper.asClass(null, Integer.class).isPresent());\n    }\n\n    @Test\n    public void testAsClassIsAbsentIfDifferentClass() {\n        assertFalse(ObjectsHelper.asClass(1, String.class).isPresent());\n    }\n\n    @Test\n    public void testAsClassIsPresentIfSameTypeAndNotNull() {\n        assertTrue(ObjectsHelper.asClass(1, Integer.class).isPresent());\n    }\n\n    @Test\n    public void coverPrivateConstructor() {\n        ObjectsHelper.instantiateForTestCoveragePurposesOnly();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/com/github/davidmoten/rtree/internal/util/ImmutableStackTest.java.ImmutableStackTest", "name": "ImmutableStackTest", "file_path": "src/test/java/com/github/davidmoten/rtree/internal/util/ImmutableStackTest.java", "superclasses": "", "methods": ["[void]testNewStackIsEmpty()", "[void]testPopOnEmptyStackThrowsException()", "[void]testPeekOnEmptyStackThrowsException()", "[void]testRemoveThrowsException()", "[void]testStackIsEmptyAfterPushThenPop()", "[void]testPeekGivesLastPushed()", "[void]testPopPeekGivesSecondLastPushed()", "[void]testIteratorWhenEmpty()", "[void]testIteratorWhenHasOneItem()", "[void]testIteratorReturnsOneItem()", "[void]testIteratorReturnsLastPushedFirst()", "[void]testIteratorReturnsTwoItemsInOrderOfPop()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class ImmutableStackTest {\n\n    private final Object a = new Object();\n    private final Object b = new Object();\n\n    @Test\n    public void testNewStackIsEmpty() {\n        ImmutableStack<Object> s = ImmutableStack.empty();\n        assertTrue(s.isEmpty());\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testPopOnEmptyStackThrowsException() {\n        ImmutableStack.empty().pop();\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testPeekOnEmptyStackThrowsException() {\n        ImmutableStack.empty().peek();\n    }\n\n    @Test(expected = RuntimeException.class)\n    public void testRemoveThrowsException() {\n        ImmutableStack.empty().push(a).iterator().remove();\n    }\n\n    @Test\n    public void testStackIsEmptyAfterPushThenPop() {\n        assertTrue(ImmutableStack.empty().push(new Object()).pop().isEmpty());\n    }\n\n    @Test\n    public void testPeekGivesLastPushed() {\n        assertEquals(b, ImmutableStack.empty().push(a).push(b).peek());\n    }\n\n    @Test\n    public void testPopPeekGivesSecondLastPushed() {\n        assertEquals(a, ImmutableStack.empty().push(a).push(b).pop().peek());\n    }\n\n    @Test\n    public void testIteratorWhenEmpty() {\n        assertFalse(ImmutableStack.empty().iterator().hasNext());\n    }\n\n    @Test\n    public void testIteratorWhenHasOneItem() {\n        assertTrue(ImmutableStack.empty().push(a).iterator().hasNext());\n    }\n\n    @Test\n    public void testIteratorReturnsOneItem() {\n        assertEquals(a, ImmutableStack.empty().push(a).iterator().next());\n    }\n\n    @Test\n    public void testIteratorReturnsLastPushedFirst() {\n        assertEquals(b, ImmutableStack.empty().push(a).push(b).iterator().next());\n    }\n\n    @Test\n    public void testIteratorReturnsTwoItemsInOrderOfPop() {\n        Iterator<Object> it = ImmutableStack.empty().push(a).push(b).iterator();\n        assertEquals(b, it.next());\n        assertEquals(a, it.next());\n        assertFalse(it.hasNext());\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Object a = new Object();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "a = new Object()", "syntax_pass": true}, {"attribute_expression": "private final Object b = new Object();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "b = new Object()", "syntax_pass": true}]}, {"uris": "src/test/java/com/github/davidmoten/internal/operators/OperatorBoundedPriorityQueueTest.java.OperatorBoundedPriorityQueueTest", "name": "OperatorBoundedPriorityQueueTest", "file_path": "src/test/java/com/github/davidmoten/internal/operators/OperatorBoundedPriorityQueueTest.java", "superclasses": "", "methods": ["[void]testPriority()", "[void]testUnsubscribeAfterFirst()", "[void]testUnsubscribeAfterLastButBeforeCompletedCalled()", "[void]testError()", "[void]testErrorCalledJustAfterUnsubscribe()", "[void]testUnsubscribeCalledAfterFirst()", "[void]testOperatorShouldRequestMaxFromUpstream()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class OperatorBoundedPriorityQueueTest {\n\n    private static Comparator<Integer> integerComparator = (i1, i2) -> i1.compareTo(i2);\n\n    @Test\n    public void testPriority() {\n        List<Integer> list = Observable.range(1, 5)\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator)).toSortedList()\n                .toBlocking().single();\n        assertEquals(Arrays.asList(1, 2), list);\n    }\n\n    @Test\n    public void testUnsubscribeAfterFirst() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        Observable.range(1, 5)\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                // subscribe\n                .subscribe(new Subscriber<Integer>() {\n\n                    @Override\n                    public void onCompleted() {\n                        completed.set(true);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n                        unsubscribe();\n                    }\n                });\n        assertFalse(completed.get());\n    }\n\n    @Test\n    public void testUnsubscribeAfterLastButBeforeCompletedCalled() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        Observable.range(1, 5)\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                // subscribe\n                .subscribe(new Subscriber<Integer>() {\n\n                    int i = 0;\n\n                    @Override\n                    public void onCompleted() {\n                        completed.set(true);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n                        i++;\n                        if (i == 2)\n                            unsubscribe();\n                    }\n                });\n        assertFalse(completed.get());\n    }\n\n    @Test\n    public void testError() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        final AtomicBoolean error = new AtomicBoolean(false);\n        Observable.<Integer> error(new RuntimeException())\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(2, integerComparator))\n                // subscribe\n                .subscribe(new Subscriber<Integer>() {\n\n                    @Override\n                    public void onCompleted() {\n                        completed.set(true);\n                    }\n\n                    @Override\n                    public void onError(Throwable e) {\n                        error.set(true);\n                    }\n\n                    @Override\n                    public void onNext(Integer t) {\n\n                    }\n                });\n        assertFalse(completed.get());\n        assertTrue(error.get());\n    }\n\n    @Test\n    public void testErrorCalledJustAfterUnsubscribe() {\n        final AtomicBoolean error = new AtomicBoolean(false);\n        final Subscriber<Integer> subscriber = new Subscriber<Integer>() {\n\n            @Override\n            public void onCompleted() {\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                error.set(true);\n            }\n\n            @Override\n            public void onNext(Integer t) {\n            }\n        };\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(Subscriber<? super Integer> sub) {\n                sub.onNext(1);\n                subscriber.unsubscribe();\n                sub.onError(new RuntimeException());\n            }\n        })\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(1, integerComparator))\n                // subscribe\n                .subscribe(subscriber);\n        assertFalse(error.get());\n    }\n\n    @Test\n    public void testUnsubscribeCalledAfterFirst() {\n        final AtomicBoolean completed = new AtomicBoolean(false);\n        final AtomicBoolean next = new AtomicBoolean(false);\n        final Subscriber<Integer> subscriber = new Subscriber<Integer>() {\n\n            @Override\n            public void onCompleted() {\n                completed.set(true);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n            }\n\n            @Override\n            public void onNext(Integer t) {\n                next.set(true);\n            }\n        };\n        Observable.create(new OnSubscribe<Integer>() {\n\n            @Override\n            public void call(Subscriber<? super Integer> sub) {\n                sub.onNext(1);\n                subscriber.unsubscribe();\n                sub.onNext(2);\n                sub.onCompleted();\n            }\n        })\n                // go through priority queue\n                .lift(new OperatorBoundedPriorityQueue<Integer>(1, integerComparator))\n                // subscribe\n                .subscribe(subscriber);\n        assertFalse(completed.get());\n        assertFalse(next.get());\n    }\n\n    @Test(timeout = 3000)\n    public void testOperatorShouldRequestMaxFromUpstream() {\n        RTree<String, Line> tree = RTree.star().create();\n        for (int i = 0; i < 5; ++i) {\n            tree = tree.add(String.format(\"Hello %d\", i), Geometries.line(-i, -i, 5 + i, i));\n        }\n        tree.nearest(Geometries.point(2, 0.4), Double.MAX_VALUE, 1).toBlocking().single();\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static Comparator<Integer> integerComparator = (i1, i2) -> i1.compareTo(i2);", "docstring": "", "modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "type": "Comparator<Integer>", "name": "integerComparator = (i1, i2) -> i1.compareTo(i2)", "syntax_pass": true}]}]