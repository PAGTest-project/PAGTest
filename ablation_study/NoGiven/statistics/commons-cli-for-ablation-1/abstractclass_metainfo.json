[{"uris": "src/test/java/org/apache/commons/cli/AbstractParserTestCase.java.AbstractParserTestCase", "name": "AbstractParserTestCase", "file_path": "src/test/java/org/apache/commons/cli/AbstractParserTestCase.java", "superclasses": "", "methods": ["[CommandLine]parse(CommandLineParser,Options,String[],Properties)", "[void]setUp()", "[void]testAmbiguousArgParsing()"], "method_uris": ["src/test/java/org/apache/commons/cli/AbstractParserTestCase.java.AbstractParserTestCase.[CommandLine]parse(CommandLineParser,Options,String[],Properties)", "src/test/java/org/apache/commons/cli/AbstractParserTestCase.java.AbstractParserTestCase.[void]setUp()", "src/test/java/org/apache/commons/cli/AbstractParserTestCase.java.AbstractParserTestCase.[void]testAmbiguousArgParsing()"], "overrides": null, "attributes": [], "class_docstring": "\nAbstract test case testing common parser features.\n\nTODO Needs a rework using JUnit parameterized tests.\n", "original_string": "public abstract class AbstractParserTestCase {\n\n    protected CommandLineParser parser;\n\n    protected Options options;\n\n    @SuppressWarnings(\"deprecation\")\n    private CommandLine parse(final CommandLineParser parser, final Options options, final String[] args, final Properties properties) throws ParseException {\n        if (parser instanceof Parser) {\n            return ((Parser) parser).parse(options, args, properties);\n        }\n        if (parser instanceof DefaultParser) {\n            return ((DefaultParser) parser).parse(options, args, properties);\n        }\n        throw new UnsupportedOperationException(\"Default options not supported by this parser\");\n    }\n\n    @BeforeEach\n    public void setUp() {\n        //@formatter:off\n        options = new Options()\n            .addOption(\"a\", \"enable-a\", false, \"turn [a] on or off\")\n            .addOption(\"b\", \"bfile\", true, \"set the value of [b]\")\n            .addOption(\"c\", \"copt\", false, \"turn [c] on or off\");\n        //@formatter:on\n    }\n\n    public void testAmbiguousArgParsing() throws Exception {\n        final String[] args = { \"-=-\" };\n        final Options options = new Options();\n\n        assertThrows(UnrecognizedOptionException.class, () -> parser.parse(options, args));\n    }\n\n    @Test\n    public void testAmbiguousLongWithoutEqualSingleDash() throws Exception {\n        final String[] args = { \"-b\", \"-foobar\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasOptionalArg().create('f'));\n        options.addOption(OptionBuilder.withLongOpt(\"bar\").hasOptionalArg().create('b'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"b\"));\n        assertTrue(cl.hasOption(\"f\"));\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testAmbiguousLongWithoutEqualSingleDash2() throws Exception {\n        final String[] args = { \"-b\", \"-foobar\" };\n\n        final Options options = new Options();\n        options.addOption(Option.builder().longOpt(\"foo\").option(\"f\").optionalArg(true).build());\n        options.addOption(Option.builder().longOpt(\"bar\").option(\"b\").optionalArg(false).build());\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"b\"));\n        assertTrue(cl.hasOption(\"f\"));\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testAmbiguousPartialLongOption1() throws Exception {\n        final String[] args = { \"--ver\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"--ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testAmbiguousPartialLongOption2() throws Exception {\n        final String[] args = { \"-ver\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"-ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testAmbiguousPartialLongOption3() throws Exception {\n        final String[] args = { \"--ver=1\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"--ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testAmbiguousPartialLongOption4() throws Exception {\n        final String[] args = { \"-ver=1\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n\n        boolean caught = false;\n\n        try {\n            parser.parse(options, args);\n        } catch (final AmbiguousOptionException e) {\n            caught = true;\n            assertEquals(\"-ver\", e.getOption(), \"Partial option\");\n            assertNotNull(e.getMatchingOptions(), \"Matching options null\");\n            assertEquals(2, e.getMatchingOptions().size(), \"Matching options size\");\n        }\n\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testArgumentStartingWithHyphen() throws Exception {\n        final String[] args = { \"-b\", \"-foo\" };\n\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"-foo\", cl.getOptionValue(\"b\"));\n    }\n\n    @Test\n    public void testBursting() throws Exception {\n        final String[] args = { \"-acbtoast\", \"foo\", \"bar\" };\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm size of extra args\");\n    }\n\n    @Test\n    public void testDoubleDash1() throws Exception {\n        final String[] args = { \"--copt\", \"--\", \"-b\", \"toast\" };\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertFalse(cl.hasOption(\"b\"), \"Confirm -b is not set\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm 2 extra args: \" + cl.getArgList().size());\n    }\n\n    @Test\n    public void testDoubleDash2() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasArg().create('n'));\n        options.addOption(OptionBuilder.create('m'));\n\n        try {\n            parser.parse(options, new String[] { \"-n\", \"--\", \"-m\" });\n            fail(\"MissingArgumentException not thrown for option -n\");\n        } catch (final MissingArgumentException e) {\n            assertNotNull(e.getOption(), \"option null\");\n            assertEquals(\"n\", e.getOption().getOpt());\n        }\n    }\n\n    @Test\n    public void testLongOptionQuoteHandling() throws Exception {\n        final String[] args = { \"--bfile\", \"\\\"quoted string\\\"\" };\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile \\\"arg\\\" strips quotes\");\n    }\n\n    @Test\n    public void testLongOptionWithEqualsQuoteHandling() throws Exception {\n        final String[] args = { \"--bfile=\\\"quoted string\\\"\" };\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm --bfile=\\\"arg\\\" strips quotes\");\n    }\n\n    @Test\n    public void testLongWithEqualDoubleDash() throws Exception {\n        final String[] args = { \"--foo=bar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testLongWithEqualSingleDash() throws Exception {\n        final String[] args = { \"-foo=bar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testLongWithoutEqualDoubleDash() throws Exception {\n        final String[] args = { \"--foobar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args, true);\n        assertFalse(cl.hasOption(\"foo\")); // foo isn't expected to be recognized with a double dash\n    }\n\n    @Test\n    public void testLongWithoutEqualSingleDash() throws Exception {\n        final String[] args = { \"-foobar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testLongWithUnexpectedArgument1() throws Exception {\n        final String[] args = { \"--foo=bar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").create('f'));\n        try {\n            parser.parse(options, args);\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"--foo=bar\", e.getOption());\n            return;\n        }\n        fail(\"UnrecognizedOptionException not thrown\");\n    }\n\n    @Test\n    public void testLongWithUnexpectedArgument2() throws Exception {\n        final String[] args = { \"-foobar\" };\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").create('f'));\n        try {\n            parser.parse(options, args);\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-foobar\", e.getOption());\n            return;\n        }\n        fail(\"UnrecognizedOptionException not thrown\");\n    }\n\n    @Test\n    public void testMissingArg() throws Exception {\n        final String[] args = { \"-b\" };\n        boolean caught = false;\n        try {\n            parser.parse(options, args);\n        } catch (final MissingArgumentException e) {\n            caught = true;\n            assertEquals(\"b\", e.getOption().getOpt(), \"option missing an argument\");\n        }\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testMissingArgWithBursting() throws Exception {\n        final String[] args = { \"-acb\" };\n        boolean caught = false;\n        try {\n            parser.parse(options, args);\n        } catch (final MissingArgumentException e) {\n            caught = true;\n            assertEquals(\"b\", e.getOption().getOpt(), \"option missing an argument\");\n        }\n        assertTrue(caught, \"Confirm MissingArgumentException caught\");\n    }\n\n    @Test\n    public void testMissingRequiredGroup() throws Exception {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(OptionBuilder.create(\"a\"));\n        group.addOption(OptionBuilder.create(\"b\"));\n        group.setRequired(true);\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n        options.addOption(OptionBuilder.isRequired().create(\"c\"));\n\n        try {\n            parser.parse(options, new String[] { \"-c\" });\n            fail(\"MissingOptionException not thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(1, e.getMissingOptions().size());\n            assertTrue(e.getMissingOptions().get(0) instanceof OptionGroup);\n        } catch (final ParseException e) {\n            fail(\"Expected to catch MissingOptionException\");\n        }\n    }\n\n    @Test\n    public void testMissingRequiredOption() {\n        final String[] args = { \"-a\" };\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n\n        try {\n            parser.parse(options, args);\n            fail(\"exception should have been thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required option: b\", e.getMessage(), \"Incorrect exception message\");\n            assertTrue(e.getMissingOptions().contains(\"b\"));\n        } catch (final ParseException e) {\n            fail(\"expected to catch MissingOptionException\");\n        }\n    }\n\n    @Test\n    public void testMissingRequiredOptions() {\n        final String[] args = { \"-a\" };\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n        options.addOption(OptionBuilder.withLongOpt(\"cfile\").hasArg().isRequired().create('c'));\n\n        try {\n            parser.parse(options, args);\n            fail(\"exception should have been thrown\");\n        } catch (final MissingOptionException e) {\n            assertEquals(\"Missing required options: b, c\", e.getMessage(), \"Incorrect exception message\");\n            assertTrue(e.getMissingOptions().contains(\"b\"));\n            assertTrue(e.getMissingOptions().contains(\"c\"));\n        } catch (final ParseException e) {\n            fail(\"expected to catch MissingOptionException\");\n        }\n    }\n\n    @Test\n    public void testMultiple() throws Exception {\n        final String[] args = { \"-c\", \"foobar\", \"-b\", \"toast\" };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n\n        cl = parser.parse(options, cl.getArgs());\n\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testMultipleWithLong() throws Exception {\n        final String[] args = { \"--copt\", \"foobar\", \"--bfile\", \"toast\" };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n\n        cl = parser.parse(options, cl.getArgs());\n\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testMultipleWithNull() throws Exception {\n        final String[] args = { null, \"-c\", null, \"foobar\", null, \"-b\", null, \"toast\", null };\n\n        CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n\n        cl = parser.parse(options, cl.getArgs());\n\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testNegativeArgument() throws Exception {\n        final String[] args = { \"-b\", \"-1\" };\n\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"-1\", cl.getOptionValue(\"b\"));\n    }\n\n    @Test\n    public void testNegativeOption() throws Exception {\n        final String[] args = { \"-b\", \"-1\" };\n\n        options.addOption(\"1\", false, null);\n\n        final CommandLine cl = parser.parse(options, args);\n        assertEquals(\"-1\", cl.getOptionValue(\"b\"));\n    }\n\n    @Test\n    public void testOptionalArgsOptionBuilder() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n        final Properties properties = new Properties();\n\n        CommandLine cmd = parse(parser, options, new String[] { \"-i\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertNull(cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\", \"rock\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n        assertArrayEquals(new String[] { \"rock\" }, cmd.getArgs());\n    }\n\n    @Test\n    public void testOptionalArgsOptionDotBuilder() throws Exception {\n        final Options options = new Options();\n        options.addOption(Option.builder(\"i\").numberOfArgs(2).optionalArg(true).build());\n        final Properties properties = new Properties();\n\n        CommandLine cmd = parse(parser, options, new String[] { \"-i\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertNull(cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n\n        cmd = parse(parser, options, new String[] { \"-i\", \"paper\", \"scissors\", \"rock\" }, properties);\n        assertTrue(cmd.hasOption(\"i\"));\n        assertArrayEquals(new String[] { \"paper\", \"scissors\" }, cmd.getOptionValues(\"i\"));\n        assertArrayEquals(new String[] { \"rock\" }, cmd.getArgs());\n\n        options.addOption(Option.builder(\"j\").numberOfArgs(3).optionalArg(true).build());\n        cmd = parse(parser, options, new String[] { \"-j\" }, properties);\n    }\n\n    @Test\n    public void testOptionAndRequiredOption() throws Exception {\n        final String[] args = { \"-a\", \"-b\", \"file\" };\n\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"file\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm NO of extra args\");\n    }\n\n    @Test\n    public void testOptionGroup() throws Exception {\n        final OptionGroup group = new OptionGroup();\n        assertFalse(group.isSelected());\n        group.addOption(OptionBuilder.create(\"a\"));\n        group.addOption(OptionBuilder.create(\"b\"));\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        parser.parse(options, new String[] { \"-b\" });\n\n        assertTrue(group.isSelected());\n        assertEquals(\"b\", group.getSelected(), \"selected option\");\n    }\n\n    @Test\n    public void testOptionGroupLong() throws Exception {\n        final OptionGroup group = new OptionGroup();\n        group.addOption(OptionBuilder.withLongOpt(\"foo\").create());\n        group.addOption(OptionBuilder.withLongOpt(\"bar\").create());\n\n        final Options options = new Options();\n        options.addOptionGroup(group);\n\n        final CommandLine cl = parser.parse(options, new String[] { \"--bar\" });\n\n        assertTrue(cl.hasOption(\"bar\"));\n        assertTrue(group.isSelected());\n        assertEquals(\"bar\", group.getSelected(), \"selected option\");\n    }\n\n    @Test\n    public void testPartialLongOptionSingleDash() throws Exception {\n        final String[] args = { \"-ver\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.hasArg().create('v'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        assertTrue(cl.hasOption(\"version\"), \"Confirm --version is set\");\n        assertFalse(cl.hasOption(\"v\"), \"Confirm -v is not set\");\n    }\n\n    @Test\n    public void testPropertiesOption1() throws Exception {\n        final String[] args = { \"-Jsource=1.5\", \"-J\", \"target\", \"1.5\", \"foo\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withValueSeparator().hasArgs(2).create('J'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        final List<String> values = Arrays.asList(cl.getOptionValues(\"J\"));\n        assertNotNull(values, \"null values\");\n        assertEquals(4, values.size(), \"number of values\");\n        assertEquals(\"source\", values.get(0), \"value 1\");\n        assertEquals(\"1.5\", values.get(1), \"value 2\");\n        assertEquals(\"target\", values.get(2), \"value 3\");\n        assertEquals(\"1.5\", values.get(3), \"value 4\");\n\n        final List<?> argsleft = cl.getArgList();\n        assertEquals(1, argsleft.size(), \"Should be 1 arg left\");\n        assertEquals(\"foo\", argsleft.get(0), \"Expecting foo\");\n    }\n\n    @Test\n    public void testPropertiesOption2() throws Exception {\n        final String[] args = { \"-Dparam1\", \"-Dparam2=value2\", \"-D\" };\n\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withValueSeparator().hasOptionalArgs(2).create('D'));\n\n        final CommandLine cl = parser.parse(options, args);\n\n        final Properties props = cl.getOptionProperties(\"D\");\n        assertNotNull(props, \"null properties\");\n        assertEquals(2, props.size(), \"number of properties in \" + props);\n        assertEquals(\"true\", props.getProperty(\"param1\"), \"property 1\");\n        assertEquals(\"value2\", props.getProperty(\"param2\"), \"property 2\");\n\n        final List<?> argsleft = cl.getArgList();\n        assertEquals(0, argsleft.size(), \"Should be no arg left\");\n    }\n\n    @Test\n    public void testPropertyOptionFlags() throws Exception {\n        final Options options = new Options();\n        options.addOption(\"a\", false, \"toggle -a\");\n        options.addOption(\"c\", \"c\", false, \"toggle -c\");\n        options.addOption(OptionBuilder.hasOptionalArg().create('e'));\n\n        Properties properties = new Properties();\n        properties.setProperty(\"a\", \"true\");\n        properties.setProperty(\"c\", \"yes\");\n        properties.setProperty(\"e\", \"1\");\n\n        CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"a\"));\n        assertTrue(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\"));\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"false\");\n        properties.setProperty(\"c\", \"no\");\n        properties.setProperty(\"e\", \"0\");\n\n        cmd = parse(parser, options, null, properties);\n        assertFalse(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\")); // this option accepts an argument\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"TRUE\");\n        properties.setProperty(\"c\", \"nO\");\n        properties.setProperty(\"e\", \"TrUe\");\n\n        cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\"));\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"just a string\");\n        properties.setProperty(\"e\", \"\");\n\n        cmd = parse(parser, options, null, properties);\n        assertFalse(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"c\"));\n        assertTrue(cmd.hasOption(\"e\"));\n\n        properties = new Properties();\n        properties.setProperty(\"a\", \"0\");\n        properties.setProperty(\"c\", \"1\");\n\n        cmd = parse(parser, options, null, properties);\n        assertFalse(cmd.hasOption(\"a\"));\n        assertTrue(cmd.hasOption(\"c\"));\n    }\n\n    @Test\n    public void testPropertyOptionGroup() throws Exception {\n        final Options options = new Options();\n\n        final OptionGroup group1 = new OptionGroup();\n        group1.addOption(new Option(\"a\", null));\n        group1.addOption(new Option(\"b\", null));\n        options.addOptionGroup(group1);\n\n        final OptionGroup group2 = new OptionGroup();\n        group2.addOption(new Option(\"x\", null));\n        group2.addOption(new Option(\"y\", null));\n        options.addOptionGroup(group2);\n\n        final String[] args = { \"-a\" };\n\n        final Properties properties = new Properties();\n        properties.put(\"b\", \"true\");\n        properties.put(\"x\", \"true\");\n\n        final CommandLine cmd = parse(parser, options, args, properties);\n\n        assertTrue(cmd.hasOption(\"a\"));\n        assertFalse(cmd.hasOption(\"b\"));\n        assertTrue(cmd.hasOption(\"x\"));\n        assertFalse(cmd.hasOption(\"y\"));\n    }\n\n    @Test\n    public void testPropertyOptionMultipleValues() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasArgs().withValueSeparator(',').create('k'));\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"k\", \"one,two\");\n\n        final CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"k\"));\n        final String[] values = { \"one\", \"two\" };\n        assertArrayEquals(values, cmd.getOptionValues('k'));\n    }\n\n    @Test\n    public void testPropertyOptionRequired() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.isRequired().create(\"f\"));\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"f\", \"true\");\n\n        final CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"f\"));\n    }\n\n    @Test\n    public void testPropertyOptionSingularValue() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArgs(2).withLongOpt(\"hide\").create());\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"hide\", \"seek\");\n\n        final CommandLine cmd = parse(parser, options, null, properties);\n        assertTrue(cmd.hasOption(\"hide\"));\n        assertEquals(\"seek\", cmd.getOptionValue(\"hide\"));\n        assertFalse(cmd.hasOption(\"fake\"));\n    }\n\n    @Test\n    public void testPropertyOptionUnexpected() throws Exception {\n        final Options options = new Options();\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"f\", \"true\");\n\n        try {\n            parse(parser, options, null, properties);\n            fail(\"UnrecognizedOptionException expected\");\n        } catch (final UnrecognizedOptionException e) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testPropertyOverrideValues() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasOptionalArgs(2).create('i'));\n        options.addOption(OptionBuilder.hasOptionalArgs().create('j'));\n\n        final String[] args = { \"-j\", \"found\", \"-i\", \"ink\" };\n\n        final Properties properties = new Properties();\n        properties.setProperty(\"j\", \"seek\");\n\n        final CommandLine cmd = parse(parser, options, args, properties);\n        assertTrue(cmd.hasOption(\"j\"));\n        assertEquals(\"found\", cmd.getOptionValue(\"j\"));\n        assertTrue(cmd.hasOption(\"i\"));\n        assertEquals(\"ink\", cmd.getOptionValue(\"i\"));\n        assertFalse(cmd.hasOption(\"fake\"));\n    }\n\n    @Test\n    public void testReuseOptionsTwice() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.isRequired().create('v'));\n        // first parsing\n        parser.parse(options, new String[] { \"-v\" });\n        try {\n            // second parsing, with the same Options instance and an invalid command line\n            parser.parse(options, new String[0]);\n            fail(\"MissingOptionException not thrown\");\n        } catch (final MissingOptionException e) {\n            // expected\n        }\n    }\n\n    @Test\n    public void testShortOptionConcatenatedQuoteHandling() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-b\\\"quoted string\\\"\" });\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm -b\\\"arg\\\" strips quotes\");\n    }\n\n    @Test\n    public void testShortOptionQuoteHandling() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-b\", \"\\\"quoted string\\\"\" });\n        assertEquals(\"quoted string\", cl.getOptionValue(\"b\"), \"Confirm -b \\\"arg\\\" strips quotes\");\n    }\n\n    @Test\n    public void testShortWithEqual() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, new String[] { \"-f=bar\" });\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testShortWithoutEqual() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\n        final CommandLine cl = parser.parse(options, new String[] { \"-fbar\" });\n        assertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n    }\n\n    @Test\n    public void testShortWithUnexpectedArgument() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"foo\").create('f'));\n        try {\n            parser.parse(options, new String[] { \"-f=bar\" });\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-f=bar\", e.getOption());\n            return;\n        }\n        fail(\"UnrecognizedOptionException not thrown\");\n    }\n\n    @Test\n    public void testSimpleLong() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"--enable-a\", \"--bfile\", \"toast\", \"foo\", \"bar\" });\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(\"toast\", cl.getOptionValue(\"bfile\"), \"Confirm arg of --bfile\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm size of extra args\");\n    }\n\n    @Test\n    public void testSimpleShort() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-a\", \"-b\", \"toast\", \"foo\", \"bar\" });\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm size of extra args\");\n    }\n\n    @Test\n    public void testSingleDash() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"--copt\", \"-b\", \"-\", \"-a\", \"-\" });\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"-\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm 1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"-\", cl.getArgList().get(0), \"Confirm value of extra arg: \" + cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testStopAtExpectedArg() throws Exception {\n        final String[] args = { \"-b\", \"foo\" };\n        final CommandLine cl = parser.parse(options, args, true);\n        assertTrue(cl.hasOption('b'), \"Confirm -b is set\");\n        assertEquals(\"foo\", cl.getOptionValue('b'), \"Confirm -b is set\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm no extra args: \" + cl.getArgList().size());\n    }\n\n    @Test\n    public void testStopAtNonOptionLong() throws Exception {\n        final String[] args = { \"--zop==1\", \"-abtoast\", \"--b=bar\" };\n        final CommandLine cl = parser.parse(options, args, true);\n        assertFalse(cl.hasOption(\"a\"), \"Confirm -a is not set\");\n        assertFalse(cl.hasOption(\"b\"), \"Confirm -b is not set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n    }\n\n    @Test\n    public void testStopAtNonOptionShort() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-z\", \"-a\", \"-btoast\" }, true);\n        assertFalse(cl.hasOption(\"a\"), \"Confirm -a is not set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n    }\n\n    @Test\n    public void testStopAtUnexpectedArg() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-c\", \"foober\", \"-b\", \"toast\" }, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(3, cl.getArgList().size(), \"Confirm  3 extra args: \" + cl.getArgList().size());\n    }\n\n    @Test\n    public void testStopBursting() throws Exception {\n        final CommandLine cl = parser.parse(options, new String[] { \"-azc\" }, true);\n        assertTrue(cl.hasOption(\"a\"), \"Confirm -a is set\");\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertTrue(cl.getArgList().contains(\"zc\"));\n    }\n\n    @Test\n    public void testStopBursting2() throws Exception {\n        CommandLine cl = parser.parse(options, new String[] { \"-c\", \"foobar\", \"-btoast\" }, true);\n        assertTrue(cl.hasOption(\"c\"), \"Confirm -c is set\");\n        assertEquals(2, cl.getArgList().size(), \"Confirm  2 extra args: \" + cl.getArgList().size());\n        cl = parser.parse(options, cl.getArgs());\n        assertFalse(cl.hasOption(\"c\"), \"Confirm -c is not set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"toast\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertEquals(1, cl.getArgList().size(), \"Confirm  1 extra arg: \" + cl.getArgList().size());\n        assertEquals(\"foobar\", cl.getArgList().get(0), \"Confirm  value of extra arg: \" + cl.getArgList().get(0));\n    }\n\n    @Test\n    public void testUnambiguousPartialLongOption1() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"--ver\" });\n        assertTrue(cl.hasOption(\"version\"), \"Confirm --version is set\");\n    }\n\n    @Test\n    public void testUnambiguousPartialLongOption2() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"version\").create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"-ver\" });\n        assertTrue(cl.hasOption(\"version\"), \"Confirm --version is set\");\n    }\n\n    @Test\n    public void testUnambiguousPartialLongOption3() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"--ver=1\" });\n        assertTrue(cl.hasOption(\"verbose\"), \"Confirm --verbose is set\");\n        assertEquals(\"1\", cl.getOptionValue(\"verbose\"));\n    }\n\n    @Test\n    public void testUnambiguousPartialLongOption4() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.withLongOpt(\"verbose\").hasOptionalArg().create());\n        options.addOption(OptionBuilder.withLongOpt(\"help\").create());\n        final CommandLine cl = parser.parse(options, new String[] { \"-ver=1\" });\n        assertTrue(cl.hasOption(\"verbose\"), \"Confirm --verbose is set\");\n        assertEquals(\"1\", cl.getOptionValue(\"verbose\"));\n    }\n\n    @Test\n    public void testUnlimitedArgs() throws Exception {\n        final Options options = new Options();\n        options.addOption(OptionBuilder.hasArgs().create(\"e\"));\n        options.addOption(OptionBuilder.hasArgs().create(\"f\"));\n        final CommandLine cl = parser.parse(options, new String[] { \"-e\", \"one\", \"two\", \"-f\", \"alpha\" });\n        assertTrue(cl.hasOption(\"e\"), \"Confirm -e is set\");\n        assertEquals(2, cl.getOptionValues(\"e\").length, \"number of arg for -e\");\n        assertTrue(cl.hasOption(\"f\"), \"Confirm -f is set\");\n        assertEquals(1, cl.getOptionValues(\"f\").length, \"number of arg for -f\");\n    }\n\n    @Test\n    public void testUnrecognizedOption() throws Exception {\n        try {\n            parser.parse(options, new String[] { \"-a\", \"-d\", \"-b\", \"toast\", \"foo\", \"bar\" });\n            fail(\"UnrecognizedOptionException wasn't thrown\");\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-d\", e.getOption());\n        }\n    }\n\n    @Test\n    public void testUnrecognizedOptionWithBursting() throws Exception {\n        try {\n            parser.parse(options, new String[] { \"-adbtoast\", \"foo\", \"bar\" });\n            fail(\"UnrecognizedOptionException wasn't thrown\");\n        } catch (final UnrecognizedOptionException e) {\n            assertEquals(\"-adbtoast\", e.getOption());\n        }\n    }\n\n    @Test\n    public void testWithRequiredOption() throws Exception {\n        final String[] args = { \"-b\", \"file\" };\n        final Options options = new Options();\n        options.addOption(\"a\", \"enable-a\", false, null);\n        options.addOption(OptionBuilder.withLongOpt(\"bfile\").hasArg().isRequired().create('b'));\n        final CommandLine cl = parser.parse(options, args);\n        assertFalse(cl.hasOption(\"a\"), \"Confirm -a is NOT set\");\n        assertTrue(cl.hasOption(\"b\"), \"Confirm -b is set\");\n        assertEquals(\"file\", cl.getOptionValue(\"b\"), \"Confirm arg of -b\");\n        assertTrue(cl.getArgList().isEmpty(), \"Confirm NO of extra args\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "protected CommandLineParser parser;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "CommandLineParser", "name": "parser", "syntax_pass": true}, {"attribute_expression": "protected Options options;", "docstring": "", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}]}, {"uris": "src/main/java/org/apache/commons/cli/Parser.java.Parser", "name": "Parser", "file_path": "src/main/java/org/apache/commons/cli/Parser.java", "superclasses": "", "methods": ["[void]checkRequiredOptions()", "[String[]]flatten(Options,String[],boolean)", "[Options]getOptions()", "[List]getRequiredOptions()", "[CommandLine]parse(Options,String[])", "[CommandLine]parse(Options,String[],boolean)", "[CommandLine]parse(Options,String[],Properties)", "[CommandLine]parse(Options,String[],Properties,boolean)", "[void]processArgs(Option,ListIterator<String>)", "[void]processOption(String,ListIterator<String>)", "[void]processProperties(Properties)", "[void]setOptions(Options)", "[void]updateRequiredOptions(Option)"], "method_uris": ["src/main/java/org/apache/commons/cli/Parser.java.Parser.[void]checkRequiredOptions()", "src/main/java/org/apache/commons/cli/Parser.java.Parser.[String[]]flatten(Options,String[],boolean)", "src/main/java/org/apache/commons/cli/Parser.java.Parser.[Options]getOptions()", "src/main/java/org/apache/commons/cli/Parser.java.Parser.[List]getRequiredOptions()", "src/main/java/org/apache/commons/cli/Parser.java.Parser.[CommandLine]parse(Options,String[])", "src/main/java/org/apache/commons/cli/Parser.java.Parser.[CommandLine]parse(Options,String[],boolean)", "src/main/java/org/apache/commons/cli/Parser.java.Parser.[CommandLine]parse(Options,String[],Properties)", "src/main/java/org/apache/commons/cli/Parser.java.Parser.[CommandLine]parse(Options,String[],Properties,boolean)", "src/main/java/org/apache/commons/cli/Parser.java.Parser.[void]processArgs(Option,ListIterator<String>)", "src/main/java/org/apache/commons/cli/Parser.java.Parser.[void]processOption(String,ListIterator<String>)", "src/main/java/org/apache/commons/cli/Parser.java.Parser.[void]processProperties(Properties)", "src/main/java/org/apache/commons/cli/Parser.java.Parser.[void]setOptions(Options)", "src/main/java/org/apache/commons/cli/Parser.java.Parser.[void]updateRequiredOptions(Option)"], "overrides": null, "attributes": [], "class_docstring": "\n{@code Parser} creates {@link CommandLine}s.\n\n@deprecated since 1.3, the two-pass parsing with the flatten method is not enough flexible to handle complex cases\n", "original_string": "@Deprecated\npublic abstract class Parser implements CommandLineParser {\n    /** CommandLine instance */\n    protected CommandLine cmd;\n\n    /** Current Options */\n    private Options options;\n\n    /** List of required options strings */\n    private List requiredOptions;\n\n    /**\n     * Throws a {@link MissingOptionException} if all of the required options are not present.\n     *\n     * @throws MissingOptionException if any of the required Options are not present.\n     */\n    protected void checkRequiredOptions() throws MissingOptionException {\n        // if there are required options that have not been processed\n        if (!getRequiredOptions().isEmpty()) {\n            throw new MissingOptionException(getRequiredOptions());\n        }\n    }\n\n    /**\n     * Subclasses must implement this method to reduce the {@code arguments} that have been passed to the parse method.\n     *\n     * @param opts The Options to parse the arguments by.\n     * @param arguments The arguments that have to be flattened.\n     * @param stopAtNonOption specifies whether to stop flattening when a non option has been encountered\n     * @return a String array of the flattened arguments\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    protected abstract String[] flatten(Options opts, String[] arguments, boolean stopAtNonOption) throws ParseException;\n\n    /**\n     * Gets the options.\n     *\n     * @return the options.\n     */\n    protected Options getOptions() {\n        return options;\n    }\n\n    /**\n     * Gets the required options.\n     *\n     * @return the required options.\n     */\n    protected List getRequiredOptions() {\n        return requiredOptions;\n    }\n\n    /**\n     * Parses the specified {@code arguments} based on the specified {@link Options}.\n     *\n     * @param options the {@code Options}\n     * @param arguments the {@code arguments}\n     * @return the {@code CommandLine}\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     */\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments) throws ParseException {\n        return parse(options, arguments, null, false);\n    }\n\n    /**\n     * Parses the specified {@code arguments} based on the specified {@link Options}.\n     *\n     * @param options the {@code Options}\n     * @param arguments the {@code arguments}\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     * @return the {@code CommandLine}\n     * @throws ParseException if an error occurs when parsing the arguments.\n     */\n    @Override\n    public CommandLine parse(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException {\n        return parse(options, arguments, null, stopAtNonOption);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     * @since 1.1\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties) throws ParseException {\n        return parse(options, arguments, properties, false);\n    }\n\n    /**\n     * Parse the arguments according to the specified options and properties.\n     *\n     * @param options the specified Options\n     * @param arguments the command line arguments\n     * @param properties command line option name-value pairs\n     * @param stopAtNonOption if {@code true} an unrecognized argument stops the parsing and the remaining arguments\n     *        are added to the {@link CommandLine}s args list. If {@code false} an unrecognized argument triggers a\n     *        ParseException.\n     * @return the list of atomic option and value tokens\n     * @throws ParseException if there are any problems encountered while parsing the command line tokens.\n     * @since 1.1\n     */\n    public CommandLine parse(final Options options, final String[] arguments, final Properties properties, final boolean stopAtNonOption)\n            throws ParseException {\n        // clear out the data in options in case it's been used before (CLI-71)\n        for (final Option opt : options.helpOptions()) {\n            opt.clearValues();\n        }\n        // clear the data from the groups\n        for (final OptionGroup group : options.getOptionGroups()) {\n            group.setSelected(null);\n        }\n        // initialize members\n        setOptions(options);\n        cmd = CommandLine.builder().build();\n        boolean eatTheRest = false;\n        final List<String> tokenList = Arrays.asList(flatten(getOptions(), arguments == null ? new String[0] : arguments, stopAtNonOption));\n        final ListIterator<String> iterator = tokenList.listIterator();\n        // process each flattened token\n        while (iterator.hasNext()) {\n            final String token = iterator.next();\n            if (token != null) {\n                // the value is the double-dash\n                if (\"--\".equals(token)) {\n                    eatTheRest = true;\n                } else if (\"-\".equals(token)) {\n                    // the value is a single dash\n                    if (stopAtNonOption) {\n                        eatTheRest = true;\n                    } else {\n                        cmd.addArg(token);\n                    }\n                } else if (token.startsWith(\"-\")) {\n                    // the value is an option\n                    if (stopAtNonOption && !getOptions().hasOption(token)) {\n                        eatTheRest = true;\n                        cmd.addArg(token);\n                    } else {\n                        processOption(token, iterator);\n                    }\n                } else {\n                    // the value is an argument\n                    cmd.addArg(token);\n                    if (stopAtNonOption) {\n                        eatTheRest = true;\n                    }\n                }\n                // eat the remaining tokens\n                if (eatTheRest) {\n                    while (iterator.hasNext()) {\n                        final String str = iterator.next();\n                        // ensure only one double-dash is added\n                        if (!\"--\".equals(str)) {\n                            cmd.addArg(str);\n                        }\n                    }\n                }\n            }\n        }\n        processProperties(properties);\n        checkRequiredOptions();\n        return cmd;\n    }\n\n    /**\n     * Process the argument values for the specified Option {@code opt} using the values retrieved from the specified\n     * iterator {@code iter}.\n     *\n     * @param opt The current Option\n     * @param iter The iterator over the flattened command line Options.\n     * @throws ParseException if an argument value is required and it is has not been found.\n     */\n    public void processArgs(final Option opt, final ListIterator<String> iter) throws ParseException {\n        // loop until an option is found\n        while (iter.hasNext()) {\n            final String str = iter.next();\n            // found an Option, not an argument\n            if (getOptions().hasOption(str) && str.startsWith(\"-\")) {\n                iter.previous();\n                break;\n            }\n            // found a value\n            try {\n                opt.processValue(Util.stripLeadingAndTrailingQuotes(str));\n            } catch (final RuntimeException exp) {\n                iter.previous();\n                break;\n            }\n        }\n        if (opt.getValues() == null && !opt.hasOptionalArg()) {\n            throw new MissingArgumentException(opt);\n        }\n    }\n\n    /**\n     * Process the Option specified by {@code arg} using the values retrieved from the specified iterator\n     * {@code iter}.\n     *\n     * @param arg The String value representing an Option\n     * @param iter The iterator over the flattened command line arguments.\n     * @throws ParseException if {@code arg} does not represent an Option\n     */\n    protected void processOption(final String arg, final ListIterator<String> iter) throws ParseException {\n        final boolean hasOption = getOptions().hasOption(arg);\n        // if there is no option throw an UnrecognizedOptionException\n        if (!hasOption) {\n            throw new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n        }\n        // get the option represented by arg\n        final Option opt = (Option) getOptions().getOption(arg).clone();\n        // update the required options and groups\n        updateRequiredOptions(opt);\n        // if the option takes an argument value\n        if (opt.hasArg()) {\n            processArgs(opt, iter);\n        }\n        // set the option on the command line\n        cmd.addOption(opt);\n    }\n\n    /**\n     * Sets the values of Options using the values in {@code properties}.\n     *\n     * @param properties The value properties to be processed.\n     * @throws ParseException if there are any problems encountered while processing the properties.\n     */\n    protected void processProperties(final Properties properties) throws ParseException {\n        if (properties == null) {\n            return;\n        }\n        for (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();) {\n            final String option = e.nextElement().toString();\n            final Option opt = options.getOption(option);\n            if (opt == null) {\n                throw new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n            }\n            // if the option is part of a group, check if another option of the group has been selected\n            final OptionGroup group = options.getOptionGroup(opt);\n            final boolean selected = group != null && group.isSelected();\n            if (!cmd.hasOption(option) && !selected) {\n                // get the value from the properties instance\n                final String value = properties.getProperty(option);\n                if (opt.hasArg()) {\n                    if (Util.isEmpty(opt.getValues())) {\n                        try {\n                            opt.processValue(value);\n                        } catch (final RuntimeException exp) { // NOPMD\n                            // if we cannot add the value don't worry about it\n                        }\n                    }\n                } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) {\n                    // if the value is not yes, true or 1 then don't add the\n                    // option to the CommandLine\n                    continue;\n                }\n                cmd.addOption(opt);\n                updateRequiredOptions(opt);\n            }\n        }\n    }\n\n    /**\n     * Sets the options.\n     *\n     * @param options the options.\n     */\n    protected void setOptions(final Options options) {\n        this.options = options;\n        this.requiredOptions = new ArrayList<>(options.getRequiredOptions());\n    }\n\n    /**\n     * Removes the option or its group from the list of expected elements.\n     *\n     * @param opt\n     */\n    private void updateRequiredOptions(final Option opt) throws ParseException {\n        // if the option is a required option remove the option from\n        // the requiredOptions list\n        if (opt.isRequired()) {\n            getRequiredOptions().remove(opt.getKey());\n        }\n        // if the option is in an OptionGroup make that option the selected\n        // option of the group\n        if (getOptions().getOptionGroup(opt) != null) {\n            final OptionGroup group = getOptions().getOptionGroup(opt);\n            if (group.isRequired()) {\n                getRequiredOptions().remove(group);\n            }\n            group.setSelected(opt);\n        }\n    }\n\n}", "super_interfaces": ["CommandLineParser"], "fields": [{"attribute_expression": "protected CommandLine cmd;", "docstring": " CommandLine instance", "modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "type": "CommandLine", "name": "cmd", "syntax_pass": true}, {"attribute_expression": "private Options options;", "docstring": " Current Options", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Options", "name": "options", "syntax_pass": true}, {"attribute_expression": "private List requiredOptions;", "docstring": " List of required options strings", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "List", "name": "requiredOptions", "syntax_pass": true}]}]