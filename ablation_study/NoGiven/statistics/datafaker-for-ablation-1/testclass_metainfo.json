[{"uris": "src/test/java/net/datafaker/FakerConcurrencyModificationExceptionTest.java.FakerConcurrencyModificationExceptionTest", "name": "FakerConcurrencyModificationExceptionTest", "file_path": "src/test/java/net/datafaker/FakerConcurrencyModificationExceptionTest.java", "superclasses": "", "methods": ["[void]test1()", "[void]test2()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class FakerConcurrencyModificationExceptionTest {\n\n    private final BaseFaker faker = new BaseFaker();\n\n    @Test\n    void test1() {\n        faker.random().nextLong();\n    }\n\n    @Test\n    void test2() {\n        faker.random().nextLong();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final BaseFaker faker = new BaseFaker();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BaseFaker", "name": "faker = new BaseFaker()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/Issue759Test.java.Issue759Test", "name": "Issue759Test", "file_path": "src/test/java/net/datafaker/Issue759Test.java", "superclasses": "", "methods": ["[void]issue759Test()"], "method_uris": ["src/test/java/net/datafaker/Issue759Test.java.Issue759Test.[void]fakeSomeData(Faker)"], "overrides": null, "attributes": [{"original_string": "    private static class WorkerThread extends Thread {\n        private final Faker _faker;\n        private final int _maxIterations;\n        private final CountDownLatch _countDownLatch;\n\n        private WorkerThread(Faker faker, int maxIterations, CountDownLatch countDownLatch) {\n            _faker = faker;\n            _maxIterations = maxIterations;\n            _countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void run() {\n            for (int i = 0; i < _maxIterations; i++) {\n                fakeSomeData(_faker);\n                _countDownLatch.countDown();\n            }\n        }\n    }", "definition": "    private static class WorkerThread extends Thread", "class_docstring": "", "name": "WorkerThread", "super_interfaces": [], "superclasses": "Thread", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Faker _faker;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Faker", "name": "_faker", "syntax_pass": true}, {"attribute_expression": "private final int _maxIterations;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "_maxIterations", "syntax_pass": true}, {"attribute_expression": "private final CountDownLatch _countDownLatch;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CountDownLatch", "name": "_countDownLatch", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private WorkerThread(Faker faker, int maxIterations, CountDownLatch countDownLatch) {\n            _faker = faker;\n            _maxIterations = maxIterations;\n            _countDownLatch = countDownLatch;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "WorkerThread", "params": [{"name": "faker", "type": "Faker"}, {"name": "maxIterations", "type": "int"}, {"name": "countDownLatch", "type": "CountDownLatch"}], "body": "                                                                                            {\n            _faker = faker;\n            _maxIterations = maxIterations;\n            _countDownLatch = countDownLatch;\n        }", "signature": "private WorkerThread(Faker faker, int maxIterations, CountDownLatch countDownLatch)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void run() {\n            for (int i = 0; i < _maxIterations; i++) {\n                fakeSomeData(_faker);\n                _countDownLatch.countDown();\n            }\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "run", "params": [], "body": "                          {\n            for (int i = 0; i < _maxIterations; i++) {\n                fakeSomeData(_faker);\n                _countDownLatch.countDown();\n            }\n        }", "signature": "@Override\n        public void run()"}]}], "class_docstring": "", "original_string": "class Issue759Test {\n    private static class WorkerThread extends Thread {\n        private final Faker _faker;\n        private final int _maxIterations;\n        private final CountDownLatch _countDownLatch;\n\n        private WorkerThread(Faker faker, int maxIterations, CountDownLatch countDownLatch) {\n            _faker = faker;\n            _maxIterations = maxIterations;\n            _countDownLatch = countDownLatch;\n        }\n\n        @Override\n        public void run() {\n            for (int i = 0; i < _maxIterations; i++) {\n                fakeSomeData(_faker);\n                _countDownLatch.countDown();\n            }\n        }\n    }\n\n    public static void fakeSomeData(Faker faker) {\n        String state = faker.address().stateAbbr();\n        String zipCode = faker.address().zipCodeByState(state);\n        try {\n            String county = faker.address().countyByZipCode(zipCode);\n            assertThat(county).isNotEqualTo(zipCode);\n        } catch (RuntimeException expected) {\n            assertThat(expected).hasMessageStartingWith(\"County is not configured for postcode \" + zipCode);\n        }\n    }\n\n    @RepeatedTest(10)\n    void issue759Test() throws InterruptedException {\n        int numThreads = 5;\n        int iterationsPerThread = 20000;\n        CountDownLatch countDownLatch = new CountDownLatch(numThreads * iterationsPerThread);\n\n        Faker faker = new Faker();\n\n        WorkerThread[] threads = new WorkerThread[numThreads];\n        for (int i = 0; i < numThreads; i++) {\n            threads[i] = new WorkerThread(faker, iterationsPerThread, countDownLatch);\n        }\n\n        for (int i = 0; i < numThreads; i++) {\n            threads[i].start();\n        }\n\n        assertThat(countDownLatch.await(12, SECONDS))\n            .overridingErrorMessage(\"Test did not complete within 12 second\")\n            .isTrue();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/Issue1178Test.java.Issue1178Test", "name": "Issue1178Test", "file_path": "src/test/java/net/datafaker/Issue1178Test.java", "superclasses": "", "methods": ["[void]testExpressionEnglishFails()", "[void]testExpressionFails()", "[void]testExpressionUsFails()", "[void]testExpressionAUWorks()", "[void]testExpressionNLWorks()", "[void]testExpressionNLWithMiddleWorks()", "[void]testExpressionNLWithCity()", "[void]testExpressionNLWithFullAddress()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Issue1178Test {\n\n    @Test\n    void testExpressionEnglishFails() {\n        Faker faker = new Faker(Locale.ENGLISH);\n        assertThat(faker.expression(\"#{name.first_name}\")).isNotBlank();\n    }\n\n    @Test\n    void testExpressionFails() {\n        Faker faker = new Faker();\n        assertThat(faker.expression(\"#{name.first_name}\")).isNotBlank();\n    }\n\n    @Test\n    void testExpressionUsFails() {\n        Faker faker = new Faker(new Locale(\"en\", \"US\"));\n        assertThat(faker.expression(\"#{name.first_name}\")).isNotBlank();\n    }\n\n    @Test\n    void testExpressionAUWorks() {\n        Faker faker = new Faker(new Locale(\"en\", \"AU\"));\n        assertThat(faker.expression(\"#{name.first_name}\")).isNotBlank();\n    }\n\n    @Test\n    void testExpressionNLWorks() {\n        Faker faker = new Faker(new Locale(\"nl\", \"nl\"));\n        assertThat(faker.expression(\"#{name.first_name}\")).isNotBlank();\n    }\n\n\n    @Test\n    void testExpressionNLWithMiddleWorks() {\n        Faker faker = new Faker(new Locale(\"nl\", \"nl\"));\n        assertThat(faker.expression(\"#{name.name_with_middle}\")).isNotBlank();\n    }\n\n    @Test\n    void testExpressionNLWithCity() {\n        Faker faker = new Faker();\n        assertThat(faker.expression(\"#{address.city}\")).isNotBlank();\n    }\n\n    @Test\n    void testExpressionNLWithFullAddress() {\n        Faker faker = new Faker(new Locale(\"nl\", \"nl\"));\n        assertThat(faker.expression(\"#{address.full_address}\")).isNotBlank();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/FakerTest.java.FakerTest", "name": "FakerTest", "file_path": "src/test/java/net/datafaker/FakerTest.java", "superclasses": "AbstractFakerTest", "methods": ["[void]examplifyUppercaseLetters()", "[void]examplifyLowercaseLetters()", "[void]examplifyNumbers()", "[void]examplifyMixed()", "[void]examplifyWithSpacesAndSpecialCharacters()", "[void]bothifyShouldGenerateLettersAndNumbers()", "[void]letterifyShouldGenerateLetters()", "[void]letterifyShouldGenerateUpperCaseLetters()", "[void]letterifyShouldLeaveNonSpecialCharactersAlone()", "[void]numerifyShouldGenerateNumbers()", "[void]numerifyShouldGenerateNumbersNotStartingWithZero()", "[void]numerifyShouldGenerateNonZeroNumbers()", "[void]numerifyShouldLeaveNonSpecialCharactersAlone()", "[void]templatify()", "[void]testRegexify(String)", "[void]badExpressionTooManyArgs()", "[void]badExpressionTooFewArgs()", "[void]badExpressionCouldntCoerce()", "[void]expression()", "[void]jsonExpressionTest()", "[void]testLimitForCsvExpression(int)", "[void]numberBetweenRepeated()", "[void]regexifyShouldGenerateSameValueForFakerWithSameSeed()", "[void]resolveShouldReturnValueThatExists()", "[void]resolveShouldThrowExceptionWhenPropertyDoesntExist()", "[void]datafaker87(String)", "[void]fakerInstanceCanBeAcquiredViaUtilityMethods()", "[void]differentLocalesTest()", "[void]issue883Test()", "[void]doWithLocaleExceptionTest()", "[void]differentSeeds()", "[void]shouldNotApplyCachingToMethodsWithParameters()", "[void]testDeterministicAndNonDeterministicProvidersReturnValues()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FakerTest extends AbstractFakerTest {\n\n    @Test\n    void examplifyUppercaseLetters() {\n        assertThat(faker.examplify(\"ABC\")).matches(\"[A-Z]{3}\");\n    }\n\n    @Test\n    void examplifyLowercaseLetters() {\n        assertThat(faker.examplify(\"abc\")).matches(\"[a-z]{3}\");\n    }\n\n    @Test\n    void examplifyNumbers() {\n        assertThat(faker.examplify(\"489321\")).matches(\"[0-9]{6}\");\n    }\n\n    @Test\n    void examplifyMixed() {\n        assertThat(faker.examplify(\"abc123ABC1zzz\")).matches(\"[a-z]{3}[0-9]{3}[A-Z]{3}[0-9][a-z]{3}\");\n    }\n\n    @Test\n    void examplifyWithSpacesAndSpecialCharacters() {\n        assertThat(faker.examplify(\"The number 4!\")).matches(\"[A-Z][a-z]{2} [a-z]{6} [0-9]!\");\n    }\n\n    @Test\n    void bothifyShouldGenerateLettersAndNumbers() {\n        assertThat(faker.bothify(\"????##@gmail.com\")).matches(\"\\\\w{4}\\\\d{2}@gmail.com\");\n    }\n\n    @Test\n    void letterifyShouldGenerateLetters() {\n        assertThat(faker.bothify(\"????\")).matches(\"\\\\w{4}\");\n    }\n\n    @Test\n    void letterifyShouldGenerateUpperCaseLetters() {\n        assertThat(faker.bothify(\"????\", true)).matches(\"[A-Z]{4}\");\n    }\n\n    @Test\n    void letterifyShouldLeaveNonSpecialCharactersAlone() {\n        assertThat(faker.bothify(\"ABC????DEF\")).matches(\"ABC\\\\w{4}DEF\");\n    }\n\n    @Test\n    void numerifyShouldGenerateNumbers() {\n        assertThat(faker.numerify(\"####\")).matches(\"\\\\d{4}\");\n    }\n\n    @RepeatedTest(25)\n    void numerifyShouldGenerateNumbersNotStartingWithZero() {\n        assertThat(faker.numerify(\"\u00d8###\")).matches(\"[1-9]\\\\d{3}\");\n    }\n\n    @RepeatedTest(25)\n    void numerifyShouldGenerateNonZeroNumbers() {\n        assertThat(faker.numerify(\"\u00d8\u00d8\")).matches(\"[1-9]{2}\");\n    }\n\n    @Test\n    void numerifyShouldLeaveNonSpecialCharactersAlone() {\n        assertThat(faker.numerify(\"####123\")).matches(\"\\\\d{4}123\");\n    }\n\n    @Test\n    void templatify() {\n        assertThat(faker.templatify(\"12??34\", '?', \"\u0442\u0435\u0441\u0442\", \"test\", \"\u6d4b\u8bd5\u6d4b\u8bd5\")).hasSize(12);\n        assertThat(faker.templatify(\"12??34\",\n            Map.of('1', new String[]{\"\u0442\u0435\u0441\u0442\", \"test\", \"\u6d4b\u8bd5\u6d4b\u8bd5\"}))).hasSize(9);\n        assertThat(faker.templatify(\"12??34\",\n            Map.of('1', new String[]{\"\"}))).hasSize(5);\n    }\n\n    /*\n    Test case for issue https://github.com/datafaker-net/datafaker/issues/1091\n     */\n    @ParameterizedTest\n    @ValueSource(strings = {\n        \"\\\\d\",\n        \"\\\\w\",\n        \"[aeiou]{2,3}\",\n        \"[a-z]{2,3}\",\n        \"a{2,3}\",\n        \"a{2}\",\n        \"a*b+c?\",\n        \"[a-z1-9]\",\n        \"[a-z]{2,3}[0-9]{2,3}\",\n        \"(a|b){2,3}\",\n        \"[a-z]\",\n        \"(aeiou)\",\n        \"(a|b)\",\n        \"\\\\.\\\\*\\\\?\\\\+\",\n        \"^arn:.+:.+:.*:([0-9]{12}):(.+)$\",\n        \"\\\\s[\\\\s]\\\\d[\\\\d]\\\\w[\\\\w]\",\n    })\n    void testRegexify(String input) {\n        var faker = new Faker();\n        assertThat(faker.regexify(input)).matches(input);\n    }\n\n    @Test\n    void badExpressionTooManyArgs() {\n        assertThatThrownBy(() -> faker.expression(\"#{regexify 'a','a'}\"))\n            .isInstanceOf(RuntimeException.class);\n    }\n\n    @Test\n    void badExpressionTooFewArgs() {\n        assertThatThrownBy(() -> faker.expression(\"#{regexify}\"))\n            .isInstanceOf(RuntimeException.class);\n    }\n\n    @Test\n    void badExpressionCouldntCoerce() {\n        assertThatThrownBy(() -> faker.expression(\"#{number.number_between 'x','10'}\"))\n            .isInstanceOf(RuntimeException.class);\n    }\n\n    @Test\n    void expression() {\n        assertThat(faker.expression(\"#{options.option 'a','b','c','d'}\")).matches(\"([abcd])\");\n        assertThat(faker.expression(\"#{options.option ''''}\")).matches(\"(')\");\n        assertThat(faker.expression(\"#{options.option '12','345','89','54321'}\")).matches(\"(12|345|89|54321)\");\n        assertThat(faker.expression(\"#{regexify '(a|b){2,3}'}\")).matches(\"([ab]){2,3}\");\n        assertThat(faker.expression(\"#{regexify '\\\\.\\\\*\\\\?\\\\+'}\")).matches(\"\\\\.\\\\*\\\\?\\\\+\");\n        assertThat(faker.expression(\"#{bothify '????','true'}\")).matches(\"[A-Z]{4}\");\n        assertThat(faker.expression(\"#{bothify '????','false'}\")).matches(\"[a-z]{4}\");\n        assertThat(faker.expression(\"#{letterify '????','true'}\")).matches(\"[A-Z]{4}\");\n        assertThat(faker.expression(\"#{templatify '????','?','1','2','q','r'}\")).matches(\"([12qr]){4}\");\n        assertThat(faker.expression(\"#{Name.first_name} #{Name.first_name} #{Name.last_name}\")).matches(\"[a-zA-Z']+ [a-zA-Z']+ [a-zA-Z']+\");\n        assertThat(faker.expression(\"#{number.number_between '1','10'}\")).matches(\"[1-9]\");\n        assertThat(faker.expression(\"#{color.name}\")).matches(\"[a-z\\\\s]+\");\n        assertThat(faker.expression(\"#{date.past '15','SECONDS','dd/MM/yyyy hh:mm:ss'}\"))\n            .matches(\"[0-9]{2}/[0-9]{2}/[0-9]{4} [0-9]{2}:[0-9]{2}:[0-9]{2}\");\n        assertThat(faker.expression(\"#{date.birthday 'yy DDD hh:mm:ss'}\"))\n            .matches(\"[0-9]{2} [0-9]{3} [0-9]{2}:[0-9]{2}:[0-9]{2}\");\n    }\n\n    @Test\n    void jsonExpressionTest() {\n        assertThat(faker.expression(\"#{json 'person','#{json ''first_name'',''#{Name.first_name}'',''last_name'',''#{Name.last_name}''}','address','#{json ''country'',''#{Address.country}'',''city'',''#{Address.city}''}'}\"))\n            .contains(\"\\\"address\\\": {\\\"country\\\":\");\n\n        assertThat(\n            faker.expression(\"#{jsona '-1','person',\" +\n                \"'#{json ''first_name'',''#{Name.first_name}'',''last_name'',''#{Name.last_name}''}',\" +\n                \" '2','addesses',\" +\n                \"'#{json ''address'',\" +\n                \"''#{json ''''country'''',''''#{Address.country}'''',''''city'''',''''#{Address.city}''''}''}'}\"))\n            .contains(\"\\\"addesses\\\": [{\\\"address\\\": {\\\"country\\\": \");\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {0, 2, 3, 10, 20, 100})\n    void testLimitForCsvExpression(int limit) {\n        String csvFullExpression = faker.expression(\"#{csv ';','\\\"','false','\" + limit + \"','first_name','#{Name.first_name}','last_name','#{Name.last_name}'}\");\n        String csvShortExpression = faker.expression(\"#{csv '\" + limit + \"','first_name','#{Name.first_name}','last_name','#{Name.last_name}'}\");\n\n        int numberOfLinesFull = 0;\n        int numberOfLinesShort = 0;\n        for (int i = 0; i < csvFullExpression.length(); i++) {\n            if (csvFullExpression.regionMatches(i, System.lineSeparator(), 0, System.lineSeparator().length())) {\n                numberOfLinesFull++;\n            }\n        }\n\n        for (int i = 0; i < csvShortExpression.length(); i++) {\n            if (csvShortExpression.regionMatches(i, System.lineSeparator(), 0, System.lineSeparator().length())) {\n                numberOfLinesShort++;\n            }\n        }\n\n        assertThat(numberOfLinesFull).isEqualTo(limit);\n        assertThat(numberOfLinesShort).isEqualTo(limit + 1); // + header\n    }\n\n    @RepeatedTest(100)\n    void numberBetweenRepeated() {\n        assertThat(faker.expression(\"#{number.number_between '1','10'}\")).matches(\"[1-9]\");\n    }\n\n    @Test\n    void regexifyShouldGenerateSameValueForFakerWithSameSeed() {\n        long seed = 1L;\n        String regex = \"\\\\d\";\n\n        String firstResult = new Faker(new Random(seed)).regexify(regex);\n        String secondResult = new Faker(new Random(seed)).regexify(regex);\n\n        assertThat(secondResult).isEqualTo(firstResult);\n    }\n\n    @Test\n    void resolveShouldReturnValueThatExists() {\n        assertThat(faker.resolve(\"address.city_prefix\")).isNotEmpty();\n    }\n\n    @Test\n    void resolveShouldThrowExceptionWhenPropertyDoesntExist() {\n        assertThatThrownBy(() -> faker.resolve(\"address.nothing\"))\n            .isInstanceOf(RuntimeException.class);\n    }\n\n    /*\n    Test case for issue https://github.com/datafaker-net/datafaker/issues/87\n     */\n    @ParameterizedTest\n    @ValueSource(strings = {\"#{regexify '[a-z]{5}[A-Z]{5}'}\", \"#{Address.city}\"})\n    void datafaker87(String expression) {\n        int n = 10;\n        int counter = 0;\n        for (int i = 0; i < n; i++) {\n            String expression1 = faker.expression(expression);\n            String expression2 = faker.expression(expression);\n            if (expression1.equals(expression2)) {\n                counter++;\n            }\n        }\n\n        assertThat(counter).isLessThan(n);\n    }\n\n    @Test\n    void fakerInstanceCanBeAcquiredViaUtilityMethods() {\n        assertThat(new Faker()).isInstanceOf(BaseFaker.class);\n        assertThat(new Faker(Locale.CANADA)).isInstanceOf(BaseFaker.class);\n        assertThat(new Faker(new Random(1))).isInstanceOf(BaseFaker.class);\n        assertThat(new Faker(Locale.CHINA, new Random(2))).isInstanceOf(BaseFaker.class);\n    }\n\n    @Test\n    void differentLocalesTest() {\n        BaseFaker localFaker = new Faker();\n        Callable<String> stringCallable = () -> localFaker.name().firstName();\n        localFaker.doWith(stringCallable, new Locale(\"ru\", \"RU\"));\n        localFaker.doWith(stringCallable, Locale.GERMAN);\n        localFaker.doWith(stringCallable, Locale.SIMPLIFIED_CHINESE);\n        for (int i = 0; i < 10; i++) {\n            assertThat(localFaker.doWith(stringCallable, new Locale(\"ru\", \"RU\"))).matches(\"[\u0430-\u044f\u0410-\u042f\u0401\u0451 ]+\");\n        }\n    }\n\n    @Test\n    @Timeout(value = 3, unit = TimeUnit.MINUTES)\n    void issue883Test() throws InterruptedException {\n        for (int i = 0; i < 10_000; i++) {\n            Faker f = new Faker();\n            String s = f.ancient().god();\n            if (i % 1_000 == 0) {\n                Thread.sleep(10);\n            }\n        }\n    }\n\n    @Test\n    void doWithLocaleExceptionTest() {\n        BaseFaker localFaker = new BaseFaker();\n        assertThatThrownBy(\n            () -> localFaker.doWith(() -> {\n                throw new Exception(\"\u304a\u3063\u3068\");\n            }, Locale.JAPAN))\n            .isInstanceOf(RuntimeException.class);\n    }\n\n    @Test\n    void differentSeeds() {\n        BaseFaker localFaker = new Faker();\n        Callable<String> stringCallable = () -> localFaker.name().firstName();\n\n        assertThat(localFaker.doWith(stringCallable, 123))\n            .isEqualTo(localFaker.doWith(stringCallable, 123));\n        assertThat(localFaker.doWith(stringCallable, 987))\n            .isNotEqualTo(localFaker.doWith(stringCallable, 123))\n            .isEqualTo(localFaker.doWith(stringCallable, 987));\n\n        assertThatThrownBy(\n            () -> localFaker.doWith(() -> {\n                throw new Exception(\"Oops1\");\n            }, 123))\n            .isInstanceOf(RuntimeException.class);\n        assertThat(localFaker.doWith(stringCallable, Locale.CANADA, 123))\n            .isEqualTo(localFaker.doWith(stringCallable, Locale.CANADA, 123));\n        assertThat(localFaker.doWith(stringCallable, Locale.CANADA, 987))\n            .isNotEqualTo(localFaker.doWith(stringCallable, Locale.CANADA, 123))\n            .isEqualTo(localFaker.doWith(stringCallable, Locale.CANADA, 987));\n        assertThatThrownBy(\n            () -> localFaker.doWith(() -> {\n                throw new Exception(\"Oops2\");\n            }, Locale.ENGLISH, 123))\n            .isInstanceOf(RuntimeException.class);\n    }\n\n    @Test\n    void shouldNotApplyCachingToMethodsWithParameters() {\n        // Test for issue: https://github.com/datafaker-net/datafaker/issues/716.\n        // No exception should be thrown\n\n        // Warm up start\n        String flight1 = faker.expression(\"#{Aviation.flight}\");\n        assertThat(flight1).matches(\"[A-z0-9]{2}\\\\d{1,4}\");\n        // Warm up end\n\n        String flight2 = faker.expression(\"#{Aviation.flight 'ICAO'}\");\n        assertThat(flight2).matches(\"[A-z]{3}\\\\d{1,4}\");\n    }\n\n    @Test\n    void testDeterministicAndNonDeterministicProvidersReturnValues() {\n        final int numberOfTestsPerMethod = 100;\n        final Reflections reflections = new Reflections(\"net.datafaker.providers\");\n        final Set<Class<?>> classes = reflections.get(SubTypes.of(AbstractProvider.class).asClass());\n        for (var clazz : classes) {\n            final Collection<Method> methods = Arrays.stream(clazz.getDeclaredMethods())\n                .filter(m -> Modifier.isPublic(m.getModifiers()) && m.getParameterCount() == 0).collect(Collectors.toSet());\n            if (methods.isEmpty()) continue;\n            Constructor<AbstractProvider<?>> constructor = null;\n            final AbstractProvider<?> ap;\n            try {\n                final Set<Constructor<AbstractProvider<?>>> constructorsWith1Arg =\n                    Arrays.stream(clazz.getDeclaredConstructors())\n                        .filter(c -> c.getParameterCount() == 1).map(c -> (Constructor<AbstractProvider<?>>) c)\n                        .collect(Collectors.toSet());\n                for (var c : constructorsWith1Arg) {\n                    final Class<?>[] types = c.getParameterTypes();\n                    if (types[0].isAssignableFrom(Faker.class)) {\n                        constructor = c;\n                        break;\n                    }\n                }\n                assertThat(constructor).isNotNull();\n                constructor.setAccessible(true);\n                ap = constructor.newInstance(faker);\n            } catch (InvocationTargetException | InstantiationException |\n                     IllegalAccessException e) {\n                throw new RuntimeException(e);\n            }\n            for (Method m : methods) {\n                final var set = new HashSet<>();\n                try {\n                    int currentSize = 0;\n                    for (int i = 0; i < numberOfTestsPerMethod && currentSize <= 1; i++) {\n                        m.setAccessible(true);\n                        set.add(m.invoke(ap));\n                        currentSize = set.size();\n                    }\n                } catch (IllegalAccessException | InvocationTargetException e) {\n                    throw new RuntimeException(e);\n                }\n                if (m.isAnnotationPresent(Deterministic.class)) {\n                    assertThat(set)\n                        .as(\"Class: \" + ap.getClass().getName()\n                            + \", method: \" + m.getName() + \" should have the same return value\")\n                        .hasSize(1);\n                } else {\n                    assertThat(set)\n                        .as(\"Class: \" + ap.getClass().getName()\n                            + \", method: \" + m.getName() + \" should generate different return values\")\n                        .hasSizeGreaterThan(1);\n                }\n            }\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/sequence/FakeStreamTest.java.FakeStreamTest", "name": "FakeStreamTest", "file_path": "src/test/java/net/datafaker/sequence/FakeStreamTest.java", "superclasses": "AbstractFakerTest", "methods": ["[void]generateFiniteStream()", "[void]generateInfiniteStream()", "[void]generateStreamOfNames()", "[void]generateStreamOfDigits()", "[void]generateNullStream()", "[void]illegalNullRate(double)", "[void]generateStreamPassingSuppliersAsList()", "[void]generateStreamWithRepeatableFaker()", "[void]generateStreamWithDifferentObjects()", "[void]checkWrongArguments()", "[void]singletonTest()", "[void]isInfiniteTest()", "[void]toCsv()", "[void]toCsvFromInfiniteSequence()", "[void]toJson()", "[void]toJsonFromInfiniteSequence()", "[void]toNestedJson()", "[void]testIterator()", "[void]testIteratorInfinite()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FakeStreamTest extends AbstractFakerTest {\n\n    @Test\n    void generateFiniteStream() {\n        Stream<String> finiteNames = faker.<String>stream()\n            .suppliers(() -> faker.name().firstName(), () -> faker.name().lastName())\n            .minLen(3)\n            .maxLen(5)\n            .generate();\n        assertThat(finiteNames).hasSizeBetween(3, 5);\n    }\n\n    @Test\n    void generateInfiniteStream() {\n        Stream<String> infiniteNames = faker.stream(() -> faker.name().firstName())\n            .generate();\n        assertThat(infiniteNames.spliterator().estimateSize()).isEqualTo(Long.MAX_VALUE);\n    }\n\n    @Test\n    void generateStreamOfNames() {\n        Stream<String> names = faker.stream(() -> faker.name().firstName())\n            .len(5)\n            .generate();\n        names.forEach(name -> assertThat(name).matches(\"[a-zA-Z']+\"));\n    }\n\n    @Test\n    void generateStreamOfDigits() {\n        Stream<String> digitsInfinite = faker.stream(() -> faker.number().digit())\n            .generate();\n        digitsInfinite.limit(1_000).forEach(name -> assertThat(name).matches(\"\\\\d\"));\n    }\n\n    @Test\n    void generateNullStream() {\n        Stream<String> names = faker.<String>stream()\n            .suppliers(() -> faker.name().firstName(), () -> faker.name().lastName())\n            .nullRate(1d)\n            .len(10)\n            .generate();\n        names.forEach(name -> assertThat(name).isNull());\n    }\n\n    @ParameterizedTest\n    @ValueSource(doubles = {Long.MIN_VALUE, Integer.MIN_VALUE, -1, -0.3, 2, 3, Integer.MAX_VALUE, Double.MAX_VALUE})\n    void illegalNullRate(double nullRate) {\n        assertThatThrownBy(\n            () -> faker.stream()\n                .suppliers(() -> faker.name().firstName(), () -> faker.name().lastName())\n                .nullRate(nullRate)\n                .minLen(3)\n                .maxLen(5)\n                .generate())\n            .isInstanceOf(IllegalArgumentException.class)\n            .hasMessage(\"Null rate should be between 0 and 1 (received: \" + nullRate + \")\");\n    }\n\n    @Test\n    void generateStreamPassingSuppliersAsList() {\n        BaseFaker faker = new BaseFaker();\n        List<Supplier<String>> suppliers = List.of(() -> faker.name().firstName(), () -> faker.name().lastName());\n        Stream<String> stream = faker.stream(suppliers).len(3).generate();\n\n        assertThat(stream.collect(Collectors.toList())).hasSize(3);\n    }\n\n    @Test\n    void generateStreamWithRepeatableFaker() {\n        BaseFaker seededFaker = new BaseFaker(new Random(10L));\n\n        Stream<String> names = faker.<String>stream()\n            .faker(seededFaker)\n            .suppliers(() -> seededFaker.name().firstName(), () -> seededFaker.name().lastName())\n            .minLen(1)\n            .maxLen(20)\n            .generate();\n\n        List<String> namesList = names.collect(Collectors.toList());\n        assertThat(namesList).hasSize(14);\n        assertThat(namesList.get(0)).isEqualTo(\"Flor\");\n        assertThat(namesList.get(1)).isEqualTo(\"Brian\");\n    }\n\n    @Test\n    void generateStreamWithDifferentObjects() {\n        Stream<Object> objects = faker.stream()\n            .suppliers(() -> faker.name().firstName(), () -> faker.random().nextInt(100))\n            .maxLen(5)\n            .generate();\n\n        objects.forEach(object -> assertThat(object).isInstanceOfAny(Integer.class, String.class));\n    }\n\n    @Test\n    void checkWrongArguments() {\n        assertThatThrownBy(() ->\n            faker.stream()\n                .suppliers(() -> faker.name().firstName())\n                .minLen(10)\n                .maxLen(5)\n                .generate())\n            .isInstanceOf(IllegalArgumentException.class)\n            .hasMessage(\"Max length (5) must be not less than min length (10) and not negative\");\n    }\n\n    @RepeatedTest(10)\n    void singletonTest() {\n        int limit = 10;\n        assertThat(faker.stream()\n            .minLen(limit)\n            .maxLen(limit)\n            .suppliers(BloodPressure::new, Glucose::new, Temperature::new)\n            .build()\n            .singleton()\n        ).isNotNull();\n    }\n\n    @Test\n    void isInfiniteTest() {\n        FakeSequence<String> infiniteNames = faker.stream(() -> faker.name().firstName())\n            .build();\n        assertThat(infiniteNames.isInfinite()).isTrue();\n\n        FakeSequence<String> finiteNames = faker.stream(() -> faker.name().firstName())\n            .len(5)\n            .build();\n        assertThat(finiteNames.isInfinite()).isFalse();\n    }\n\n    @Test\n    void toCsv() {\n        String separator = \"$$$\";\n        int limit = 5;\n        FakeSequence<Data> stream = faker.<Data>stream()\n            .minLen(limit)\n            .maxLen(limit)\n            .suppliers(BloodPressure::new, Glucose::new, Temperature::new)\n            .build();\n\n        CsvTransformer<Data> csvTransformer = CsvTransformer\n            .<Data>builder().header(true).separator(separator).build();\n        String csv = csvTransformer.generate(stream,\n            Schema.of(\n                field(\"name\", Data::name),\n                field(\"value\", Data::value),\n                field(\"range\", Data::range),\n                field(\"unit\", Data::unit)));\n\n        int numberOfLines = 0;\n        int numberOfSeparator = 0;\n        for (int i = 0; i < csv.length(); i++) {\n            if (csv.regionMatches(i, System.lineSeparator(), 0, System.lineSeparator().length())) {\n                numberOfLines++;\n            } else if (csv.regionMatches(i, separator, 0, separator.length())) {\n                numberOfSeparator++;\n            }\n        }\n\n        assertThat(numberOfLines).isEqualTo(5);\n        assertThat(numberOfSeparator).isEqualTo(18); // number of lines * (number of columns - 1)\n    }\n\n    @Test\n    void toCsvFromInfiniteSequence() {\n        String separator = \"$$$\";\n        FakeSequence<Data> infiniteStream = faker.<Data>stream()\n            .suppliers(BloodPressure::new, Glucose::new, Temperature::new)\n            .build();\n\n        assertThatThrownBy(() ->\n            CsvTransformer.<Data>builder().separator(separator).build()\n                .generate(infiniteStream,\n                    Schema.of(\n                        field(\"name\", Data::name),\n                        field(\"value\", Data::value),\n                        field(\"range\", Data::range),\n                        field(\"unit\", Data::unit)))\n        ).isInstanceOf(IllegalArgumentException.class)\n            .hasMessage(\"The sequence should be finite of size: FakeStream{minLength=-1, maxLength=-1, nullRate=0.0}\");\n    }\n\n    @Test\n    void toJson() {\n        int limit = 10;\n        FakeSequence<Data> stream = faker.<Data>collection()\n            .minLen(limit)\n            .maxLen(limit)\n            .suppliers(BloodPressure::new, Glucose::new, Temperature::new)\n            .build();\n\n        JsonTransformer<Data> transformer = JsonTransformer.<Data>builder().build();\n\n        String json = transformer.generate(stream, Schema.of(\n            field(\"name\", Data::name),\n            field(\"value\", Data::value),\n            field(\"range\", Data::range),\n            field(\"unit\", Data::unit)\n        ));\n\n        int numberOfLines = 0;\n        for (int i = 0; i < json.length(); i++) {\n            if (json.regionMatches(i, \"},\", 0, \"},\".length())) {\n                numberOfLines++;\n            }\n        }\n\n        assertThat(limit - 1).isEqualTo(numberOfLines); // limit - 1 since for the last line there is no comma\n    }\n\n    @Test\n    void toJsonFromInfiniteSequence() {\n        FakeSequence<Data> infiniteStream = faker.<Data>stream()\n            .suppliers(BloodPressure::new, Glucose::new, Temperature::new)\n            .build();\n\n        assertThatThrownBy(() ->\n            JsonTransformer.<Data>builder().build()\n                .generate(infiniteStream,\n                    Schema.of(\n                        field(\"name\", Data::name),\n                        field(\"value\", Data::value),\n                        field(\"range\", Data::range),\n                        field(\"unit\", Data::unit)))\n        ).isInstanceOf(IllegalArgumentException.class)\n            .hasMessage(\"The sequence should be finite of size: FakeStream{minLength=-1, maxLength=-1, nullRate=0.0}\");\n    }\n\n    @Test\n    void toNestedJson() {\n        final int limit = 3;\n        JsonTransformer<Name> transformer = JsonTransformer.<Name>builder().build();\n\n        FakeSequence<CompositeField<Address, String>> secondaryAddresses =\n            faker.<CompositeField<Address, String>>collection()\n                .suppliers(() ->\n                    compositeField(null, new Field[]{\n                        field(\"country\", () -> faker.address().country()),\n                        field(\"city\", () -> faker.address().city()),\n                        field(\"zipcode\", () -> faker.address().zipCode()),\n                        field(\"streetAddress\", () -> faker.address().streetAddress())\n                    })\n                )\n                .maxLen(1)\n                .minLen(1)\n                .build();\n\n        String json = transformer.generate(\n            faker.<Name>stream()\n                .suppliers(faker::name)\n                .maxLen(limit)\n                .minLen(limit)\n                .build(),\n            Schema.<Name, Object>of(\n                compositeField(\"primaryAddress\", new Field[]{\n                    field(\"country\", () -> faker.address().country()),\n                    field(\"city\", () -> faker.address().city()),\n                    field(\"zipcode\", () -> faker.address().zipCode()),\n                    field(\"streetAddress\", () -> faker.address().streetAddress())\n                }),\n                field(\"secondaryAddresses\", secondaryAddresses::get),\n                field(\"phones\", name -> faker.<String>collection().suppliers(() -> faker.phoneNumber().phoneNumber()).maxLen(3).build().get())\n            ));\n\n        int numberOfLines = 0;\n        for (int i = 0; i < json.length(); i++) {\n            if (json.regionMatches(i, \"},\" + System.lineSeparator(), 0, (\"},\" + System.lineSeparator()).length())) {\n                numberOfLines++;\n            }\n        }\n        assertThat(numberOfLines).isEqualTo(limit - 1); // limit - 1 since for the last line there is no comma\n    }\n\n    @Test\n    void testIterator() {\n        int fakeSequenceSize = 100;\n        FakeSequence<String> digits = faker\n            .stream(() -> faker.number().digit())\n            .len(fakeSequenceSize)\n            .build();\n\n        int count = 0;\n        for (String digit : digits) {\n            assertThat(digit).matches(\"\\\\d\");\n            count++;\n        }\n\n        assertThat(count).isEqualTo(fakeSequenceSize);\n    }\n\n    @Test\n    void testIteratorInfinite() {\n        FakeSequence<String> digits = faker\n            .stream(() -> faker.number().digit())\n            .build();\n\n        assertThat(digits.isInfinite()).isTrue();\n\n        int count = 0;\n        int amountOfElementsToTake = 1_000;\n        for (String digit : digits) {\n            assertThat(digit).matches(\"\\\\d\");\n            count++;\n            if (count == amountOfElementsToTake) {\n                break;\n            }\n        }\n\n        assertThat(count).isEqualTo(amountOfElementsToTake);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/sequence/FakeCollectionTest.java.FakeCollectionTest", "name": "FakeCollectionTest", "file_path": "src/test/java/net/datafaker/sequence/FakeCollectionTest.java", "superclasses": "AbstractFakerTest", "methods": ["[void]generateCollection()", "[void]generateSequence()", "[void]generateSequenceOfDefaultSize()", "[void]generateEmptySequence()", "[void]isInfiniteTest()", "[void]generateSequence5()", "[void]generateNullCollection()", "[void]illegalNullRate(double)", "[void]generateCollectionPassingSuppliersAsList()", "[void]generateCollectionWithRepeatableFaker()", "[void]generateCollectionWithDifferentObjects()", "[void]checkWrongArguments()", "[void]toCsv()", "[void]toJson()", "[void]toNestedJson()", "[void]singletonTest()", "[void]testIterator()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FakeCollectionTest extends AbstractFakerTest {\n    @Test\n    void generateCollection() {\n        List<String> names = faker.<String>collection()\n            .suppliers(() -> faker.name().firstName(), () -> faker.name().lastName())\n            .minLen(3)\n            .maxLen(5).build().get();\n        assertThat(names).hasSizeBetween(3, 5);\n        for (String name : names) {\n            assertThat(name).matches(\"[a-zA-Z']+\");\n        }\n    }\n\n    @Test\n    void generateSequence() {\n        List<String> digits = faker\n            .collection(() -> faker.number().digit())\n            .len(3, 10).generate();\n        assertThat(digits).hasSizeBetween(3, 10);\n        for (String digit : digits) {\n            assertThat(digit).matches(\"\\\\d\");\n        }\n    }\n\n    @Test\n    void generateSequenceOfDefaultSize() {\n        List<String> digits = faker\n            .collection(() -> faker.number().digit())\n            .generate();\n        assertThat(digits).hasSize(10);\n\n        digits = faker\n            .collection(() -> faker.number().digit())\n            .maxLen(-175)\n            .generate();\n        assertThat(digits).hasSize(10);\n    }\n\n    @Test\n    void generateEmptySequence() {\n        List<Number> digits = faker\n            .collection(() -> faker.number().digit())\n            .maxLen(0)\n            .generate();\n        assertThat(digits).isEmpty();\n    }\n\n    @Test\n    void isInfiniteTest() {\n        FakeSequence<String> digits = faker\n            .collection(() -> faker.number().digit())\n            .build();\n        assertThat(digits.isInfinite()).isFalse();\n\n        digits = faker\n            .collection(() -> faker.number().digit())\n            .minLen(3)\n            .maxLen(5)\n            .build();\n        assertThat(digits.isInfinite()).isFalse();\n    }\n\n    @Test\n    void generateSequence5() {\n        List<String> digits = faker\n            .collection(() -> faker.number().digit())\n            .len(5).generate();\n        assertThat(digits).hasSize(5);\n        for (String digit : digits) {\n            assertThat(digit).matches(\"\\\\d\");\n        }\n    }\n\n    @Test\n    void generateNullCollection() {\n        List<String> names = faker.<String>collection()\n            .suppliers(() -> faker.name().firstName(), () -> faker.name().lastName())\n            .nullRate(1d)\n            .minLen(3)\n            .maxLen(5).build().get();\n        assertThat(names).hasSizeBetween(3, 5);\n        for (String name : names) {\n            assertThat(name).isNull();\n        }\n    }\n\n    @ParameterizedTest\n    @ValueSource(doubles = {Long.MIN_VALUE, Integer.MIN_VALUE, -1, -0.3, 2, 3, Integer.MAX_VALUE, Double.MAX_VALUE})\n    void illegalNullRate(double nullRate) {\n        assertThatThrownBy(\n            () -> faker.collection()\n                .suppliers(() -> faker.name().firstName(), () -> faker.name().lastName())\n                .nullRate(nullRate)\n                .minLen(3)\n                .maxLen(5).build().get())\n            .isInstanceOf(IllegalArgumentException.class)\n            .hasMessage(\"Null rate should be between 0 and 1 (received: \" + nullRate + \")\");\n    }\n\n    @Test\n    void generateCollectionPassingSuppliersAsList() {\n        BaseFaker seededFaker = new BaseFaker(new Random(10L));\n        List<Supplier<String>> suppliers = List.of(() -> faker.name().firstName(), () -> faker.name().lastName());\n\n        List<String> names = faker.collection(suppliers).faker(seededFaker).len(3).generate();\n        assertThat(names).hasSize(3);\n    }\n\n    @Test\n    void generateCollectionWithRepeatableFaker() {\n        BaseFaker seededFaker = new BaseFaker(new Random(10L));\n\n        List<String> names = faker.<String>collection()\n            .faker(seededFaker)\n            .suppliers(() -> seededFaker.name().firstName(), () -> seededFaker.name().lastName())\n            .minLen(1)\n            .maxLen(20).build().get();\n\n        assertThat(names).hasSize(14);\n        assertThat(names.get(0)).isEqualTo(\"Flor\");\n        assertThat(names.get(1)).isEqualTo(\"Brian\");\n    }\n\n    @Test\n    void generateCollectionWithDifferentObjects() {\n        List<Object> objects = faker.collection()\n            .suppliers(() -> faker.name().firstName(), () -> faker.random().nextInt(100))\n            .maxLen(5).build().get();\n        assertThat(objects).hasSize(5);\n        for (Object object : objects) {\n            assertThat(object).isInstanceOfAny(Integer.class, String.class);\n        }\n    }\n\n    @Test\n    void checkWrongArguments() {\n        assertThatThrownBy(() ->\n            faker.collection()\n                .suppliers(() -> faker.name().firstName())\n                .minLen(10)\n                .maxLen(5).build().get())\n            .isInstanceOf(IllegalArgumentException.class)\n            .hasMessage(\"Max length (5) must be not less than min length (10) and not negative\");\n    }\n\n    @Test\n    void toCsv() {\n        String separator = \"$$$\";\n        int limit = 5;\n        CsvTransformer<Data> csvTransformer = CsvTransformer.<Data>builder().header(true).separator(separator).build();\n        String csv = csvTransformer.generate(\n            faker.collection(BloodPressure::new, Glucose::new, Temperature::new)\n                .len(limit).generate(),\n            Schema.of(\n                field(\"name\", Data::name),\n                field(\"value\", Data::value),\n                field(\"range\", Data::range),\n                field(\"unit\", Data::unit)));\n        int numberOfLines = 0;\n        int numberOfSeparator = 0;\n        for (int i = 0; i < csv.length(); i++) {\n            if (csv.regionMatches(i, System.lineSeparator(), 0, System.lineSeparator().length())) {\n                numberOfLines++;\n            } else if (csv.regionMatches(i, separator, 0, separator.length())) {\n                numberOfSeparator++;\n            }\n        }\n        assertThat(limit).isEqualTo(numberOfLines);\n        assertThat((limit + 1) * (4 - 1)).isEqualTo(numberOfSeparator); // number of lines * (number of columns - 1)\n    }\n\n    @Test\n    void toJson() {\n        int limit = 10;\n\n        JsonTransformer<Data> transformer = JsonTransformer.<Data>builder().build();\n\n        String json = transformer.generate(\n            faker.<Data>collection().minLen(limit).maxLen(limit)\n                .suppliers(BloodPressure::new, Glucose::new, Temperature::new)\n                .build(), Schema.of(\n                field(\"name\", Data::name),\n                field(\"value\", Data::value),\n                field(\"range\", Data::range),\n                field(\"unit\", Data::unit)\n            ));\n\n        int numberOfLines = 0;\n        for (int i = 0; i < json.length(); i++) {\n            if (json.regionMatches(i, \"},\", 0, \"},\".length())) {\n                numberOfLines++;\n            }\n        }\n\n        assertThat(limit - 1).isEqualTo(numberOfLines); // limit - 1 since for the last line there is no comma\n    }\n\n    @Test\n    void toNestedJson() {\n        final int limit = 2;\n        JsonTransformer<Name> transformer = JsonTransformer.<Name>builder().build();\n\n        FakeSequence<CompositeField<Address, String>> secondaryAddresses =\n            faker.<CompositeField<Address, String>>collection()\n            .suppliers(() ->\n                compositeField(null, new Field[]{\n                    field(\"country\", () -> faker.address().country()),\n                    field(\"city\", () -> faker.address().city()),\n                    field(\"zipcode\", () -> faker.address().zipCode()),\n                    field(\"streetAddress\", () -> faker.address().streetAddress())\n                })\n            )\n            .maxLen(1)\n            .minLen(1)\n            .build();\n\n        String json = transformer.generate(\n            faker.<Name>collection().minLen(limit).maxLen(limit)\n                .suppliers(faker::name)\n                .build(),\n            Schema.of(\n                compositeField(\"primaryAddress\", new Field[]{\n                    field(\"country\", () -> faker.address().country()),\n                    field(\"city\", () -> faker.address().city()),\n                    field(\"zipcode\", () -> faker.address().zipCode()),\n                    field(\"streetAddress\", () -> faker.address().streetAddress())\n                }),\n                field(\"secondaryAddresses\", secondaryAddresses::get),\n                field(\"phones\", name -> faker.collection().suppliers(() -> faker.phoneNumber().phoneNumber()).maxLen(3).build().get())\n            ));\n\n\n        int numberOfLines = 0;\n        for (int i = 0; i < json.length(); i++) {\n            if (json.regionMatches(i, \"},\" + System.lineSeparator(), 0, (\"},\" + System.lineSeparator()).length())) {\n                numberOfLines++;\n            }\n        }\n        assertThat(numberOfLines).isEqualTo(limit - 1); // limit - 1 since for the last line there is no comma\n    }\n\n    @RepeatedTest(10)\n    void singletonTest() {\n        int limit = 10;\n        assertThat(faker.<Data>collection().minLen(limit).maxLen(limit)\n            .suppliers(BloodPressure::new, Glucose::new, Temperature::new)\n            .build().singleton()).isNotNull();\n    }\n\n    @Test\n    void testIterator() {\n        int fakeSequenceSize = 10;\n        FakeSequence<String> digits = faker\n            .collection(() -> faker.number().digit())\n            .len(fakeSequenceSize)\n            .build();\n\n        int count = 0;\n        for (String digit : digits) {\n            assertThat(digit).matches(\"\\\\d\");\n            count++;\n        }\n\n        assertThat(count).isEqualTo(fakeSequenceSize);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/HololiveTest.java.HololiveTest", "name": "HololiveTest", "file_path": "src/test/java/net/datafaker/providers/base/HololiveTest.java", "superclasses": "", "methods": ["[void]talent_jaLocale()"], "method_uris": ["src/test/java/net/datafaker/providers/base/HololiveTest.java.HololiveTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class HololiveTest extends BaseFakerTest<BaseFaker> {\n\n    private static final BaseFaker JA_FAKER = new BaseFaker(new Locale(\"ja\"));\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        Hololive hl = faker.hololive();\n        return List.of(TestSpec.of(hl::talent, \"hololive.talent\", \"^[A-Za-z '+-]+$\"));\n    }\n\n    @Test\n    void talent_jaLocale() {\n        assertThat(JA_FAKER.hololive().talent()).matches(\"^AZKi|[\\\\u3040-\\\\u30FF\\\\u4E00-\\\\u9FAF]+$\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final BaseFaker JA_FAKER = new BaseFaker(new Locale(\"ja\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "BaseFaker", "name": "JA_FAKER = new BaseFaker(new Locale(\"ja\"))", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/TextTest.java.TextTest", "name": "TextTest", "file_path": "src/test/java/net/datafaker/providers/base/TextTest.java", "superclasses": "", "methods": ["[void]textShouldContain3RULowerCaseAnd5CustomSpecialSymbols()", "[void]exceptionIfLengthIsShorterThanNumberOfRequiredSymbols()", "[void]everyTextShouldContainLowerCaseUpperCaseAndDigit()", "[void]testCharacter()", "[void]testUppercaseCharacter()", "[void]testLowercaseCharacter()", "[void]testFixedLengthText()", "[void]testDefaultLengthText()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class TextTest extends BaseFakerTest<BaseFaker> {\n\n    @Test\n    void textShouldContain3RULowerCaseAnd5CustomSpecialSymbols() {\n        final String ruLowerCase = \"\u0430\u0431\u0432\u0433\u0434\u0435\u0451\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f\";\n        final String customSpecialSymbols = \"!@#$%^&*;'][{}\";\n        final int ruCnt = 3;\n        final int specSmbCnt = 5;\n        final Text.TextRuleConfig config = Text.TextSymbolsBuilder.builder()\n            .len(faker.number().numberBetween(ruCnt + specSmbCnt, Math.max(ruCnt + specSmbCnt, 10)))\n            .with(ruLowerCase, ruCnt)\n            .with(customSpecialSymbols, specSmbCnt).build();\n\n        for (int i = 0; i < 10; i++) {\n            final String text = faker.text().text(config);\n            assertThat(text).matches(s -> {\n                int j = 0;\n                int curRuCnt = 0;\n                while (j < s.length() && curRuCnt < ruCnt) {\n                    if (ruLowerCase.indexOf(s.charAt(j++)) >= 0) curRuCnt++;\n                }\n                return curRuCnt >= ruCnt;\n            }).matches(s -> {\n                int j = 0;\n                int curSpecSmbCnt = 0;\n                while (j < s.length() && curSpecSmbCnt < specSmbCnt) {\n                    if (customSpecialSymbols.indexOf(s.charAt(j++)) >= 0) curSpecSmbCnt++;\n                }\n                return curSpecSmbCnt >= specSmbCnt;\n            });\n        }\n    }\n\n    @Test\n    void exceptionIfLengthIsShorterThanNumberOfRequiredSymbols() {\n        assertThatThrownBy(() ->\n            faker.text().text(Text.TextSymbolsBuilder.builder()\n                .len(1)\n                .with(EN_LOWERCASE, 1)\n                .with(EN_UPPERCASE, 1)\n                .with(DIGITS, 1)\n                .throwIfLengthSmall(true)\n                .build()))\n            .isInstanceOf(IllegalArgumentException.class);\n    }\n\n    @Test\n    void everyTextShouldContainLowerCaseUpperCaseAndDigit() {\n        int count = 0;\n        final Text.TextRuleConfig config = Text.TextSymbolsBuilder.builder()\n            .len(faker.number().numberBetween(6, 10))\n            .with(EN_LOWERCASE, 1)\n            .with(EN_UPPERCASE, 1)\n            .with(DIGITS, 1).build();\n        while (count++ < 1000) {\n            String text = faker.text().text(config);\n            assertThat(text).is(new Condition<>(pw -> {\n                    for (int i = 0; i < pw.length(); i++) {\n                        if (Character.isLowerCase(pw.charAt(i))) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }, \"contains lower case\"))\n                .is(new Condition<>(pw -> {\n                    for (int i = 0; i < pw.length(); i++) {\n                        if (Character.isUpperCase(pw.charAt(i))) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }, \"contains upper case\"))\n                .is(new Condition<>(pw -> {\n                    for (int i = 0; i < pw.length(); i++) {\n                        if (Character.isDigit(pw.charAt(i))) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }, \"contains upper case\"));\n        }\n    }\n\n    @Test\n    void testCharacter() {\n        final Pattern characterPattern = Pattern.compile(\"[A-Za-z]\");\n        for (int i = 0; i < 100; i++) {\n            Character character = faker.text().character();\n            assertThat(character.toString()).matches(characterPattern);\n        }\n    }\n\n    @RepeatedTest((100))\n    void testUppercaseCharacter() {\n        Character character = faker.text().uppercaseCharacter();\n        assertThat(character).isUpperCase();\n    }\n\n    @RepeatedTest((100))\n    void testLowercaseCharacter() {\n        Character character = faker.text().lowercaseCharacter();\n        assertThat(character).isLowerCase();\n    }\n\n    @Test\n    void testFixedLengthText() {\n        for (int i = 0; i < 100; i++) {\n            String text = faker.text().text(i);\n            assertThat(text).hasSize(i);\n        }\n    }\n\n    @Test\n    void testDefaultLengthText() {\n        for (int i = 0; i < 100; i++) {\n            String text = faker.text().text();\n            assertThat(text).hasSizeBetween(20, 80);\n        }\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/FamousLastWordsTest.java.FamousLastWordsTest", "name": "FamousLastWordsTest", "file_path": "src/test/java/net/datafaker/providers/base/FamousLastWordsTest.java", "superclasses": "", "methods": ["[void]testLastWords()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FamousLastWordsTest extends BaseFakerTest<BaseFaker> {\n\n    @RepeatedTest(1000)\n    void testLastWords() {\n        assertThat(faker.famousLastWords().lastWords()).matches(\"^[A-Za-z- .,'!?-\u2026]+$\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/CompanyTest.java.CompanyTest", "name": "CompanyTest", "file_path": "src/test/java/net/datafaker/providers/base/CompanyTest.java", "superclasses": "", "methods": ["[void]testName()", "[void]testBuzzword()", "[void]testCatchPhrase()", "[void]testBs()", "[void]testLogo()", "[void]testUrl()"], "method_uris": ["src/test/java/net/datafaker/providers/base/CompanyTest.java.CompanyTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class CompanyTest extends BaseFakerTest<BaseFaker> {\n\n    public static final Pattern URL_PATTERN = Pattern.compile(\"(([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])\\\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])\");\n    public static final Pattern PHRASE_PATTERN = Pattern.compile(\"(\\\\w+[ /-]?){1,9}\");\n    private final Company company = faker.company();\n\n    @Test\n    void testName() {\n        assertThat(company.name()).matches(\"[A-Za-z\\\\-&',. ]+\");\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(company::suffix, \"company.suffix\", \"[A-Za-z ]+\"),\n            TestSpec.of(company::industry, \"company.industry\", \"(\\\\w+([ ,&/-]{1,3})?){1,4}+\"),\n            TestSpec.of(company::profession, \"company.profession\"));\n    }\n\n    @Test\n    void testBuzzword() {\n        assertThat(company.buzzword()).matches(\"(\\\\w+[ /-]?){1,3}\");\n    }\n\n    @Test\n    void testCatchPhrase() {\n        assertThat(company.catchPhrase()).matches(PHRASE_PATTERN);\n    }\n\n    @Test\n    void testBs() {\n        assertThat(company.bs()).matches(PHRASE_PATTERN);\n    }\n\n    @Test\n    void testLogo() {\n        assertThat(company.logo()).matches(\"https://pigment.github.io/fake-logos/logos/medium/color/\\\\d+\\\\.png\");\n    }\n\n    @RepeatedTest(100)\n    void testUrl() {\n        assertThat(company.url()).matches(URL_PATTERN);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final Pattern URL_PATTERN = Pattern.compile(\"(([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])\\\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])\");", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Pattern", "name": "URL_PATTERN = Pattern.compile(\"(([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])\\\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])\")", "syntax_pass": true}, {"attribute_expression": "public static final Pattern PHRASE_PATTERN = Pattern.compile(\"(\\\\w+[ /-]?){1,9}\");", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Pattern", "name": "PHRASE_PATTERN = Pattern.compile(\"(\\\\w+[ /-]?){1,9}\")", "syntax_pass": true}, {"attribute_expression": "private final Company company = faker.company();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Company", "name": "company = faker.company()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/Internet_getPrivateIpV4AddressTest.java.Internet_getPrivateIpV4AddressTest", "name": "Internet_getPrivateIpV4AddressTest", "file_path": "src/test/java/net/datafaker/providers/base/Internet_getPrivateIpV4AddressTest.java", "superclasses": "", "methods": ["[void]testGetPrivateIpV4Address()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Internet_getPrivateIpV4AddressTest {\n\n    @Test\n    public void testGetPrivateIpV4Address() throws UnknownHostException {\n        // Given\n        Internet internet = new Internet(mock(BaseProviders.class));\n        RandomService randomService = mock(RandomService.class);\n        when(internet.faker.random()).thenReturn(randomService);\n\n        // When\n        when(randomService.nextInt(256)).thenReturn(1); // Ensure second, third, fourth octets are 1\n        when(randomService.nextInt(16)).thenReturn(0); // Ensure second octet for 172.x.x.x is 16\n\n        InetAddress result = internet.getPrivateIpV4Address();\n\n        // Then\n        byte[] address = result.getAddress();\n        assertTrue(address[0] == 10 || address[0] == 127 || address[0] == (byte) 169 || address[0] == (byte) 192 || address[0] == (byte) 172);\n        if (address[0] == (byte) 172) {\n            assertEquals(16, address[1]);\n        } else if (address[0] == (byte) 192) {\n            assertEquals(168, address[1]);\n        } else if (address[0] == (byte) 169) {\n            assertEquals(254, address[1]);\n        }\n        assertEquals(1, address[2]);\n        assertEquals(1, address[3]);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/GreekPhilosopherTest.java.GreekPhilosopherTest", "name": "GreekPhilosopherTest", "file_path": "src/test/java/net/datafaker/providers/base/GreekPhilosopherTest.java", "superclasses": "", "methods": ["[void]testName()", "[void]testQuote()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class GreekPhilosopherTest extends BaseFakerTest<BaseFaker> {\n\n    @RepeatedTest(10)\n    void testName() {\n        assertThat(faker.greekPhilosopher().name()).matches(\"^[a-zA-Z ]+$\");\n    }\n\n    @RepeatedTest(10)\n    void testQuote() {\n        assertThat(faker.greekPhilosopher().quote()).matches(\"^[a-zA-Z ,.']+$\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/SuperheroTest.java.SuperheroTest", "name": "SuperheroTest", "file_path": "src/test/java/net/datafaker/providers/base/SuperheroTest.java", "superclasses": "", "methods": ["[void]testName()"], "method_uris": ["src/test/java/net/datafaker/providers/base/SuperheroTest.java.SuperheroTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class SuperheroTest extends BaseFakerTest<BaseFaker> {\n\n    @Test\n    void testName() {\n        assertThat(faker.superhero().name()).matches(\"[A-Za-z' -/]+\");\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        Superhero superhero = faker.superhero();\n        return List.of(TestSpec.of(superhero::prefix, \"superhero.prefix\"),\n            TestSpec.of(superhero::suffix, \"superhero.suffix\"),\n            TestSpec.of(superhero::power, \"superhero.power\"),\n            TestSpec.of(superhero::descriptor, \"superhero.descriptor\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/BaseFaker_getProviderTest.java.BaseFaker_getProviderTest", "name": "BaseFaker_getProviderTest", "file_path": "src/test/java/net/datafaker/providers/base/BaseFaker_getProviderTest.java", "superclasses": "", "methods": ["[void]testGetProvider()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    static class TestProvider extends AbstractProvider<ProviderRegistration> {\n        protected TestProvider(ProviderRegistration faker) {\n            super(faker);\n        }\n    }", "definition": "    static class TestProvider extends AbstractProvider<ProviderRegistration>", "class_docstring": "", "name": "TestProvider", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        protected TestProvider(ProviderRegistration faker) {\n            super(faker);\n        }", "docstring": "", "attributes": {"modifiers": "protected", "marker_annotations": [], "non_marker_annotations": ["protected"], "comments": [], "return_type": "", "classes": []}, "name": "TestProvider", "params": [{"name": "faker", "type": "ProviderRegistration"}], "body": "                                                           {\n            super(faker);\n        }", "signature": "protected TestProvider(ProviderRegistration faker)"}]}], "class_docstring": "", "original_string": "class BaseFaker_getProviderTest {\n\n    @Test\n    void testGetProvider() {\n        // Given\n        BaseFaker baseFaker = new BaseFaker();\n        Class<TestProvider> clazz = TestProvider.class;\n        Function<ProviderRegistration, TestProvider> valueSupplier = mock(Function.class);\n        TestProvider expectedProvider = new TestProvider(baseFaker);\n        when(valueSupplier.apply(any())).thenReturn(expectedProvider);\n\n        // When\n        TestProvider actualProvider = baseFaker.getProvider(clazz, valueSupplier);\n\n        // Then\n        assertEquals(expectedProvider, actualProvider);\n        verify(valueSupplier).apply(baseFaker);\n    }\n\n    static class TestProvider extends AbstractProvider<ProviderRegistration> {\n        protected TestProvider(ProviderRegistration faker) {\n            super(faker);\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/LanguageCodeTest.java.LanguageCodeTest", "name": "LanguageCodeTest", "file_path": "src/test/java/net/datafaker/providers/base/LanguageCodeTest.java", "superclasses": "", "methods": ["[void]languageCodeISO639ShouldBe2LettersInLength()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class LanguageCodeTest extends BaseFakerTest<BaseFaker> {\n\n    @Test\n    void languageCodeISO639ShouldBe2LettersInLength() {\n        final LanguageCode languageCode = faker.languageCode();\n        assertThat(languageCode.iso639()).hasSize(2);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/BusinessTest.java.BusinessTest", "name": "BusinessTest", "file_path": "src/test/java/net/datafaker/providers/base/BusinessTest.java", "superclasses": "", "methods": ["[void]creditCardNumber()", "[void]creditCardExpiry()", "[void]securityCode()"], "method_uris": ["src/test/java/net/datafaker/providers/base/BusinessTest.java.BusinessTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class BusinessTest extends BaseFakerTest<BaseFaker> {\n\n    private final Business business = faker.business();\n\n    @Test\n    void creditCardNumber() {\n        assertThat(business.creditCardNumber()).isNotEmpty();\n    }\n\n    @Test\n    void creditCardExpiry() {\n        // Given / When\n        String date = business.creditCardExpiry();\n        // Then\n        assertThat(date).isNotEmpty();\n        assertThat(date).matches(\"\\\\d{4}-\\\\d{2}-\\\\d{2}\");\n    }\n\n    @Test\n    void securityCode() {\n        assertThat(business.securityCode()).isNotEmpty();\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(business::creditCardType, \"business.credit_card_types\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Business business = faker.business();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Business", "name": "business = faker.business()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/CNPJTest.java.CNPJTest", "name": "CNPJTest", "file_path": "src/test/java/net/datafaker/providers/base/CNPJTest.java", "superclasses": "", "methods": ["[void]isValidCNPJ()", "[void]isInvalidCNPJ()", "[void]valid_multiBranchIsTrue_shouldGenerateCNPJWithBranchNumberGreaterThan0001()", "[void]invalid_multiBranchIsTrue_shouldGenerateCNPJWithBranchNumberGreaterThan0001()", "[void]bug()", "[void]formattedCNPJ()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class CNPJTest extends BaseFakerTest<BaseFaker> {\n\n    /**\n     * A valid CNPJ is either a real number or a generated valid number.\n     */\n    @RepeatedTest(1000)\n    void isValidCNPJ() {\n        CNPJ cnpj = faker.cnpj();\n        assertThat(isCNPJValid(cnpj.valid())).describedAs(\"Current value \" + cnpj).isTrue();\n    }\n\n    /**\n     * A invalid CNPJ is that does not meet the requirements of the algorithm\n     */\n    @RepeatedTest(1000)\n    void isInvalidCNPJ() {\n        CNPJ cnpj = faker.cnpj();\n        assertThat(isCNPJValid(cnpj.invalid())).describedAs(\"Current value \" + cnpj).isFalse();\n    }\n\n    @Test\n    void valid_multiBranchIsTrue_shouldGenerateCNPJWithBranchNumberGreaterThan0001() {\n        final CNPJ cnpj1 = faker.cnpj();\n        String cnpj = cnpj1.valid(true, true);\n        String branch = cnpj.substring(11, 15);\n\n        // branches are allowed to be 0001 even in multibranch mode. In this case,\n        // we are giving the system 5 chances to generate something different than 0001.\n        for (int i = 0; \"0001\".equals(branch) && i < 5; i++) {\n            cnpj = cnpj1.valid(true, true);\n            branch = cnpj.substring(11, 15);\n        }\n\n        assertThat(parseInt(branch)).isGreaterThan(1);\n        assertThat(isCNPJValid(cnpj)).describedAs(\"Current value \" + cnpj).isTrue();\n    }\n\n    @RepeatedTest(1000)\n    void invalid_multiBranchIsTrue_shouldGenerateCNPJWithBranchNumberGreaterThan0001() {\n        final CNPJ cnpj1 = faker.cnpj();\n        String cnpj = cnpj1.invalid(true, true);\n        String branch = cnpj.substring(11, 15);\n\n        // branches are allowed to be 0001 even in multibranch mode. In this case,\n        // we are giving the system 5 chances to generate something different than 0001.\n        for (int i = 0; \"0001\".equals(branch) && i < 5 || \"0000\".equals(branch); i++) {\n            cnpj = cnpj1.invalid(true, true);\n            branch = cnpj.substring(11, 15);\n        }\n\n        assertThat(parseInt(branch)).describedAs(\"Branch \" + branch).isGreaterThan(1);\n        assertThat(isCNPJValid(cnpj)).describedAs(\"Current value \" + cnpj).isFalse();\n    }\n\n    @Test\n    void bug() {\n        isCNPJValid(\"57.615.644/1633-29\");\n    }\n\n\n    /**\n     * CNPJ has a main format. This test validate if the number is on the correct format\n     * Eg: 11.111.111/0001-11\n     */\n    @Test\n    void formattedCNPJ() {\n        final Pattern cnpjExpression = Pattern.compile(\"(^\\\\d{2}\\\\x2E\\\\d{3}\\\\x2E\\\\d{3}\\\\x2F\\\\d{4}\\\\x2D\\\\d{2}$)\");\n\n        final CNPJ cnpj = faker.cnpj();\n        assertThat(cnpj.valid()).matches(cnpjExpression);\n        assertThat(cnpj.valid(true)).matches(cnpjExpression);\n        assertThat(cnpj.invalid()).matches(cnpjExpression);\n        assertThat(cnpj.invalid(true)).matches(cnpjExpression);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/AnimalTest.java.AnimalTest", "name": "AnimalTest", "file_path": "src/test/java/net/datafaker/providers/base/AnimalTest.java", "superclasses": "", "methods": ["[void]scientificName()", "[void]genus()", "[void]species()"], "method_uris": ["src/test/java/net/datafaker/providers/base/AnimalTest.java.AnimalTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class AnimalTest extends BaseFakerTest<BaseFaker> {\n\n    private final Animal animal = faker.animal();\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(animal::name, \"creature.animal.name\"));\n    }\n\n    @RepeatedTest(100)\n    void scientificName() {\n        assertThat(animal.scientificName()).matches(\"[A-Z][a-z]+ [a-z]+\");\n    }\n\n    @RepeatedTest(100)\n    void genus() {\n        assertThat(animal.genus()).matches(\"[A-Z][a-z]+\");\n    }\n\n    @RepeatedTest(100)\n    void species() {\n        assertThat(animal.species()).matches(\"[a-z]+\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Animal animal = faker.animal();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Animal", "name": "animal = faker.animal()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/TireTest.java.TireTest", "name": "TireTest", "file_path": "src/test/java/net/datafaker/providers/base/TireTest.java", "superclasses": "", "methods": ["[void]testDefaultPrefixedCode()", "[void]testMiscPrefixedCode()"], "method_uris": ["src/test/java/net/datafaker/providers/base/TireTest.java.TireTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class TireTest extends BaseFakerTest<BaseFaker> {\n\n    private final static String CODE_PATTERN = \"\\\\d{3}/\\\\d{2,3}R\\\\d{2}\\\\.?\\\\d?\";\n    private final Tire tire = faker.tire();\n\n    @Test\n    void testDefaultPrefixedCode() {\n        assertThat(tire.code(true)).matches(\"P\" + CODE_PATTERN);\n        assertThat(tire.code(false)).matches(CODE_PATTERN);\n    }\n\n    @Test\n    void testMiscPrefixedCode() {\n        String prefix = \"misc\";\n        assertThat(tire.code(prefix)).matches(prefix + CODE_PATTERN);\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(tire::code, \"tire.code\", CODE_PATTERN),\n                TestSpec.of(tire::vehicleType, \"tire.vehicle_type\", \"[A-Z]{1,2}\"),\n                TestSpec.of(tire::width, \"tire.width\", \"\\\\d{3}\"),\n                TestSpec.of(tire::aspectRatio, \"tire.aspect_ratio\", \"\\\\d{2}\"),\n                TestSpec.of(tire::construction, \"tire.construction\"),\n                TestSpec.of(tire::rimSize, \"tire.rim_size\", \"\\\\d{2}\\\\.?\\\\d?\"),\n                TestSpec.of(tire::loadIndex, \"tire.load_index\", \"\\\\d{2,3}\"),\n                TestSpec.of(tire::speedrating, \"tire.speed_rating\", \"\\\\(?[A-Z][\\\\d)]?\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final static String CODE_PATTERN = \"\\\\d{3}/\\\\d{2,3}R\\\\d{2}\\\\.?\\\\d?\";", "docstring": "", "modifiers": "private final static", "marker_annotations": [], "non_marker_annotations": ["private", "final", "static"], "comments": [], "type": "String", "name": "CODE_PATTERN = \"\\\\d{3}/\\\\d{2,3}R\\\\d{2}\\\\.?\\\\d?\"", "syntax_pass": true}, {"attribute_expression": "private final Tire tire = faker.tire();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Tire", "name": "tire = faker.tire()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/ObjectMethodsTest.java.ObjectMethodsTest", "name": "ObjectMethodsTest", "file_path": "src/test/java/net/datafaker/providers/base/ObjectMethodsTest.java", "superclasses": "", "methods": ["[void]methodByName()", "[void]methodByReturnType()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    private static class Person {\n        public Age age() {\n            return new Age();\n        }\n        public PersonName name() {\n            return new PersonName();\n        }\n    }", "definition": "    private static class Person", "class_docstring": "", "name": "Person", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Age age() {\n            return new Age();\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Age", "classes": []}, "name": "age", "params": [], "body": "                         {\n            return new Age();\n        }", "signature": "public Age age()"}, {"syntax_pass": true, "original_string": "        public PersonName name() {\n            return new PersonName();\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "PersonName", "classes": []}, "name": "name", "params": [], "body": "                                 {\n            return new PersonName();\n        }", "signature": "public PersonName name()"}]}, {"original_string": "    private static class Age {\n        public int value() {\n            return 23;\n        }\n    }", "definition": "    private static class Age", "class_docstring": "", "name": "Age", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public int value() {\n            return 23;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "value", "params": [], "body": "                           {\n            return 23;\n        }", "signature": "public int value()"}]}, {"original_string": "    private static class PersonName {\n        public String firstName() {\n            return \"John\";\n        }\n        public CharSequence lastName() {\n            return \"Smith\";\n        }\n    }", "definition": "    private static class PersonName", "class_docstring": "", "name": "PersonName", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public String firstName() {\n            return \"John\";\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "firstName", "params": [], "body": "                                  {\n            return \"John\";\n        }", "signature": "public String firstName()"}, {"syntax_pass": true, "original_string": "        public CharSequence lastName() {\n            return \"Smith\";\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "CharSequence", "classes": []}, "name": "lastName", "params": [], "body": "                                       {\n            return \"Smith\";\n        }", "signature": "public CharSequence lastName()"}]}], "class_docstring": "", "original_string": "class ObjectMethodsTest {\n\n    private final Person person = new Person();\n    private final PersonName personName = new PersonName();\n\n    @Test\n    void methodByName() throws NoSuchMethodException {\n        assertThat(getMethodByName(person, \"age\")).isEqualTo(Person.class.getMethod(\"age\"));\n        assertThat(getMethodByName(person, \"name\")).isEqualTo(Person.class.getMethod(\"name\"));\n\n        assertThat(getMethodByName(personName, \"firstName\")).isEqualTo(PersonName.class.getMethod(\"firstName\"));\n        assertThat(getMethodByName(personName, \"lastName\")).isEqualTo(PersonName.class.getMethod(\"lastName\"));\n    }\n\n    @Test\n    void methodByReturnType() {\n        assertThat((Age) executeMethodByReturnType(person, \"Age\")).isInstanceOf(Age.class);\n        assertThat((PersonName) executeMethodByReturnType(person, \"PersonName\")).isInstanceOf(PersonName.class);\n        assertThat((String) executeMethodByReturnType(personName, \"String\")).isEqualTo(\"John\");\n        assertThat((CharSequence) executeMethodByReturnType(personName, \"CharSequence\")).isEqualTo(\"Smith\");\n    }\n\n    private static class Person {\n        public Age age() {\n            return new Age();\n        }\n        public PersonName name() {\n            return new PersonName();\n        }\n    }\n\n    private static class Age {\n        public int value() {\n            return 23;\n        }\n    }\n\n    private static class PersonName {\n        public String firstName() {\n            return \"John\";\n        }\n        public CharSequence lastName() {\n            return \"Smith\";\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Person person = new Person();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Person", "name": "person = new Person()", "syntax_pass": true}, {"attribute_expression": "private final PersonName personName = new PersonName();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PersonName", "name": "personName = new PersonName()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/BaseFakerTest.java.BaseFakerTest", "name": "BaseFakerTest", "file_path": "src/test/java/net/datafaker/providers/base/BaseFakerTest.java", "superclasses": "", "methods": ["[void]testProviderList(TestSpec,TestInfo)", "[void]testNoDuplications(TestSpec)"], "method_uris": ["src/test/java/net/datafaker/providers/base/BaseFakerTest.java.BaseFakerTest.[void]resetMocks()", "src/test/java/net/datafaker/providers/base/BaseFakerTest.java.BaseFakerTest.[T]getFaker()", "src/test/java/net/datafaker/providers/base/BaseFakerTest.java.BaseFakerTest.[List<String>]getBaseList(String)", "src/test/java/net/datafaker/providers/base/BaseFakerTest.java.BaseFakerTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [{"original_string": "    protected static class TestSpec {\n        private final Supplier<?> supplier;\n        private final String key;\n        private final boolean isDummy;\n        @SuppressWarnings(\"unused\")\n        private final String regex;\n\n        private TestSpec(Supplier<?> supplier, String key, String regex) {\n            this.supplier = supplier;\n            this.key = key;\n            this.isDummy = key == null || supplier == null;\n            this.regex = regex;\n        }\n\n        public static TestSpec of(Supplier<?> supplier, String key) {\n            return new TestSpec(supplier, key, \"\");\n        }\n\n        public static TestSpec of(Supplier<?> supplier, String key, String regex) {\n            return new TestSpec(supplier, key, regex);\n        }\n\n        @Override\n        public String toString() {\n            // The result of this toString will be used by IDE in test report\n            return \"Key: \" + key;\n        }\n    }", "definition": "    protected static class TestSpec", "class_docstring": "", "name": "TestSpec", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "protected static", "marker_annotations": [], "non_marker_annotations": ["protected", "static"], "comments": [], "fields": [{"attribute_expression": "private final Supplier<?> supplier;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Supplier<?>", "name": "supplier", "syntax_pass": true}, {"attribute_expression": "private final String key;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "key", "syntax_pass": true}, {"attribute_expression": "private final boolean isDummy;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "isDummy", "syntax_pass": true}, {"attribute_expression": "@SuppressWarnings(\"unused\")\n        private final String regex;", "docstring": "", "modifiers": "@SuppressWarnings(\"unused\")\n        private final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"unused\")", "private", "final"], "comments": [], "type": "String", "name": "regex", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private TestSpec(Supplier<?> supplier, String key, String regex) {\n            this.supplier = supplier;\n            this.key = key;\n            this.isDummy = key == null || supplier == null;\n            this.regex = regex;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "TestSpec", "params": [{"name": "supplier", "type": "Supplier<?>"}, {"name": "key", "type": "String"}, {"name": "regex", "type": "String"}], "body": "                                                                         {\n            this.supplier = supplier;\n            this.key = key;\n            this.isDummy = key == null || supplier == null;\n            this.regex = regex;\n        }", "signature": "private TestSpec(Supplier<?> supplier, String key, String regex)"}, {"syntax_pass": true, "original_string": "        public static TestSpec of(Supplier<?> supplier, String key) {\n            return new TestSpec(supplier, key, \"\");\n        }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "TestSpec", "classes": []}, "name": "of", "params": [{"name": "supplier", "type": "Supplier<?>"}, {"name": "key", "type": "String"}], "body": "                                                                    {\n            return new TestSpec(supplier, key, \"\");\n        }", "signature": "public static TestSpec of(Supplier<?> supplier, String key)"}, {"syntax_pass": true, "original_string": "        public static TestSpec of(Supplier<?> supplier, String key, String regex) {\n            return new TestSpec(supplier, key, regex);\n        }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "TestSpec", "classes": []}, "name": "of", "params": [{"name": "supplier", "type": "Supplier<?>"}, {"name": "key", "type": "String"}, {"name": "regex", "type": "String"}], "body": "                                                                                  {\n            return new TestSpec(supplier, key, regex);\n        }", "signature": "public static TestSpec of(Supplier<?> supplier, String key, String regex)"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            // The result of this toString will be used by IDE in test report\n            return \"Key: \" + key;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            // The result of this toString will be used by IDE in test report\n            return \"Key: \" + key;\n        }", "signature": "@Override\n        public String toString()"}]}], "class_docstring": "", "original_string": "@TestInstance(TestInstance.Lifecycle.PER_CLASS)\npublic class BaseFakerTest<T extends BaseFaker> {\n\n    private static final Logger LOG = Logger.getLogger(BaseFakerTest.class.getCanonicalName());\n    protected final T faker = getFaker();\n\n    @BeforeEach\n    @SuppressWarnings(\"EmptyTryBlock\")\n    final void resetMocks() throws Exception {\n        try (AutoCloseable ignored = MockitoAnnotations.openMocks(this)) {\n            // Need to reset all @Spy and @Mock fields\n            // because all test methods share the same test class instance due to @TestInstance(PER_CLASS)\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected T getFaker() {\n        return (T) new BaseFaker();\n    }\n\n    protected List<String> getBaseList(String key) {\n        return faker.fakeValuesService().fetchObject(key, faker.getContext());\n    }\n\n    @ParameterizedTest(name = \"{0}\")\n    @MethodSource(\"providerListTest\")\n    protected void testProviderList(TestSpec testSpec, TestInfo testInfo) {\n        if (testSpec.isDummy) {\n            // skip and log dummy\n            LOG.log(Level.WARNING, \"Dummy test for \" + testInfo.getTestClass().get());\n            return;\n        }\n        // Given\n        Set<String> actual = new HashSet<>(getBaseList(testSpec.key));\n        // When\n        String item = (String) testSpec.supplier.get();\n        // Then\n        assertThat(item).as(\"Check item isn't empty\").isNotEmpty();\n        String collection = \"\\\"\" + testSpec.key + \"\\\"\";\n        assertThat(actual).as(\"Check actual list isn't empty and contains the item for the key \" + collection).isNotEmpty()\n            .anyMatch(item::equals);\n        assertThat(actual).as(\"Actual should not have empty entries. \" + collection).noneMatch(single -> single.isBlank());\n        if (!testSpec.regex.isEmpty()) {\n            assertThat(item).as(\"Check item matches regex\").matches(Pattern.compile(testSpec.regex));\n        }\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"providerListTest\")\n    void testNoDuplications(TestSpec testSpec) {\n        if (testSpec.isDummy) {\n            return;\n        }\n\n        var terms = getBaseList(testSpec.key);\n\n        assertThat(new HashSet<>(terms))\n                .as(\"Check no duplications in \" + testSpec.key)\n                .hasSameSizeAs(terms);\n    }\n\n    protected Collection<TestSpec> providerListTest() {\n        // dummy test since parameterized test requires non-empty collection\n        return Set.of(new TestSpec(null, null, null));\n    }\n\n    protected static class TestSpec {\n        private final Supplier<?> supplier;\n        private final String key;\n        private final boolean isDummy;\n        @SuppressWarnings(\"unused\")\n        private final String regex;\n\n        private TestSpec(Supplier<?> supplier, String key, String regex) {\n            this.supplier = supplier;\n            this.key = key;\n            this.isDummy = key == null || supplier == null;\n            this.regex = regex;\n        }\n\n        public static TestSpec of(Supplier<?> supplier, String key) {\n            return new TestSpec(supplier, key, \"\");\n        }\n\n        public static TestSpec of(Supplier<?> supplier, String key, String regex) {\n            return new TestSpec(supplier, key, regex);\n        }\n\n        @Override\n        public String toString() {\n            // The result of this toString will be used by IDE in test report\n            return \"Key: \" + key;\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger LOG = Logger.getLogger(BaseFakerTest.class.getCanonicalName());", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "LOG = Logger.getLogger(BaseFakerTest.class.getCanonicalName())", "syntax_pass": true}, {"attribute_expression": "protected final T faker = getFaker();", "docstring": "", "modifiers": "protected final", "marker_annotations": [], "non_marker_annotations": ["protected", "final"], "comments": [], "type": "T", "name": "faker = getFaker()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/UniqueTest.java.UniqueTest", "name": "UniqueTest", "file_path": "src/test/java/net/datafaker/providers/base/UniqueTest.java", "superclasses": "", "methods": ["[void]fetchFromYaml_shouldReturnValuesInRandomOrderUsingRandomService()", "[void]fetchFromYaml_shouldThrowExceptionWhenAllPossibleValuesHaveBeenReturned()", "[void]fetchFromYaml_shouldReturnValuesBasedOnKeyAndLocale()", "[void]fetchFromYaml_shouldThrowExceptionWhenNoValuesFoundForKey()", "[void]fetchFromYaml_shouldThrowExceptionWhenNonListValueFoundForKey()", "[void]fetchFromYaml_shouldThrowExceptionWhenListOfListsFoundForKey()", "[void]fetchFromYaml_shouldNotInterfereWithValuesReturnedFromOtherFakers()", "[void]fetchFromYaml_shouldConvertIntegersToStrings()", "[void]fetchFromYaml_shouldConvertDecimalsToStrings()", "[void]fetchFromYaml_shouldConvertBooleansToStrings()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class UniqueTest {\n\n    private BaseFaker faker = new BaseFaker(new Locale(\"test\"));\n\n    private static final List<String> defaultValues = List.of(\n        \"firstValue\",\n        \"secondValue\",\n        \"thirdValue\",\n        \"fourthValue\",\n        \"fifthValue\"\n    );\n\n    @Test\n    void fetchFromYaml_shouldReturnValuesInRandomOrderUsingRandomService() {\n        String key = \"unique.values\";\n\n        RandomService randomService = Mockito.spy(new RandomService(new Random()));\n        doCallRealMethod().when(randomService).nextInt(anyInt(), anyInt());\n\n        faker = new BaseFaker(new Locale(\"test\"), randomService);\n\n        Set<String> results = new HashSet<>();\n\n        results.add(faker.unique().fetchFromYaml(key));\n        results.add(faker.unique().fetchFromYaml(key));\n        results.add(faker.unique().fetchFromYaml(key));\n        results.add(faker.unique().fetchFromYaml(key));\n        results.add(faker.unique().fetchFromYaml(key));\n\n        assertThat(results)\n            .hasSize(5)\n            .containsAll(defaultValues);\n\n        verify(randomService).nextInt(0, 4);\n        verify(randomService).nextInt(0, 3);\n        verify(randomService).nextInt(0, 2);\n        verify(randomService).nextInt(0, 1);\n        verify(randomService).nextInt(0, 0);\n        verifyNoMoreInteractions(randomService);\n    }\n\n    @Test\n    void fetchFromYaml_shouldThrowExceptionWhenAllPossibleValuesHaveBeenReturned() {\n        String key = \"unique.single-value\";\n\n        assertThat(faker.unique().fetchFromYaml(key)).isEqualTo(\"theOnlyValue\");\n        assertThatThrownBy(() -> faker.unique().fetchFromYaml(key))\n            .hasMessage(\"All possible values have been generated for key unique.single-value under locale test\");\n    }\n\n    @Test\n    void fetchFromYaml_shouldReturnValuesBasedOnKeyAndLocale() {\n        String firstKey = \"unique.first-same-locale-value\";\n        String secondKey = \"unique.second-same-locale-value\";\n\n        String expectedValue = \"theSameValue\";\n\n        assertThat(faker.unique().fetchFromYaml(firstKey)).isEqualTo(expectedValue);\n        assertThat(faker.unique().fetchFromYaml(secondKey)).isEqualTo(expectedValue);\n        faker.getContext().setCurrentLocale(new Locale(\"test_EE\"));\n        assertThat(faker.unique().fetchFromYaml(firstKey)).isEqualTo(expectedValue);\n        assertThat(faker.unique().fetchFromYaml(secondKey)).isEqualTo(expectedValue);\n    }\n\n    @Test\n    void fetchFromYaml_shouldThrowExceptionWhenNoValuesFoundForKey() {\n        assertThatThrownBy(() -> faker.unique().fetchFromYaml(\"unique.nonexistent-values\"))\n            .hasMessage(\"No values found for key unique.nonexistent-values\");\n    }\n\n    @Test\n    void fetchFromYaml_shouldThrowExceptionWhenNonListValueFoundForKey() {\n        assertThatThrownBy(() -> faker.unique().fetchFromYaml(\"unique\"))\n            .hasMessage(\"No values found for key unique\");\n    }\n\n    @Test\n    void fetchFromYaml_shouldThrowExceptionWhenListOfListsFoundForKey() {\n        assertThatThrownBy(() -> faker.unique().fetchFromYaml(\"unique.list-of-lists\"))\n            .hasMessage(\"No values found for key unique.list-of-lists\");\n    }\n\n    @Test\n    void fetchFromYaml_shouldNotInterfereWithValuesReturnedFromOtherFakers() {\n        String key = \"unique.values\";\n\n        for (int x = 0; x < defaultValues.size(); x++) {\n            faker.unique().fetchFromYaml(key);\n        }\n\n        String result = faker.unique().resolve(key);\n\n        assertThat(defaultValues).contains(result);\n    }\n\n    @Test\n    void fetchFromYaml_shouldConvertIntegersToStrings() {\n        assertThat(faker.unique().fetchFromYaml(\"unique.valid-integer\"))\n            .isEqualTo(\"123\");\n    }\n\n    @Test\n    void fetchFromYaml_shouldConvertDecimalsToStrings() {\n        assertThat(faker.unique().fetchFromYaml(\"unique.valid-decimal\"))\n            .isEqualTo(\"12.34\");\n    }\n\n    @Test\n    void fetchFromYaml_shouldConvertBooleansToStrings() {\n        assertThat(faker.unique().fetchFromYaml(\"unique.valid-boolean\"))\n            .isEqualTo(\"true\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private BaseFaker faker = new BaseFaker(new Locale(\"test\"));", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BaseFaker", "name": "faker = new BaseFaker(new Locale(\"test\"))", "syntax_pass": true}, {"attribute_expression": "private static final List<String> defaultValues = List.of(\n        \"firstValue\",\n        \"secondValue\",\n        \"thirdValue\",\n        \"fourthValue\",\n        \"fifthValue\"\n    );", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List<String>", "name": "defaultValues = List.of(\n        \"firstValue\",\n        \"secondValue\",\n        \"thirdValue\",\n        \"fourthValue\",\n        \"fifthValue\"\n    )", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/DateAndTime_birthdayTest.java.DateAndTime_birthdayTest", "name": "DateAndTime_birthdayTest", "file_path": "src/test/java/net/datafaker/providers/base/DateAndTime_birthdayTest.java", "superclasses": "", "methods": ["[void]testBirthdayWithEqualAges()", "[void]testBirthdayWithDifferentAges()", "[void]testBirthdayWithNegativeAges()"], "method_uris": ["src/test/java/net/datafaker/providers/base/DateAndTime_birthdayTest.java.DateAndTime_birthdayTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DateAndTime_birthdayTest {\n\n    private DateAndTime dateAndTime;\n\n    @BeforeEach\n    public void setUp() {\n        BaseFaker baseFaker = new BaseFaker();\n        dateAndTime = new DateAndTime(baseFaker);\n    }\n\n    @Test\n    public void testBirthdayWithEqualAges() {\n        int minAge = 30;\n        int maxAge = 30;\n        Timestamp result = dateAndTime.birthday(minAge, maxAge);\n        LocalDateTime expectedDateTime = LocalDateTime.of(LocalDate.now().minusYears(maxAge), LocalTime.MIDNIGHT);\n        Timestamp expectedTimestamp = Timestamp.valueOf(expectedDateTime);\n        assertTrue(result.equals(expectedTimestamp));\n    }\n\n    @Test\n    public void testBirthdayWithDifferentAges() {\n        int minAge = 18;\n        int maxAge = 65;\n        Timestamp result = dateAndTime.birthday(minAge, maxAge);\n        LocalDate from = LocalDate.now().minusYears(maxAge);\n        LocalDate to = LocalDate.now().minusYears(minAge);\n        LocalDate resultDate = result.toLocalDateTime().toLocalDate();\n        assertTrue(resultDate.isAfter(from) || resultDate.isEqual(from));\n        assertTrue(resultDate.isBefore(to) || resultDate.isEqual(to));\n    }\n\n    @Test\n    public void testBirthdayWithNegativeAges() {\n        int minAge = -5;\n        int maxAge = -1;\n        Timestamp result = dateAndTime.birthday(minAge, maxAge);\n        LocalDate from = LocalDate.now().minusYears(maxAge);\n        LocalDate to = LocalDate.now().minusYears(minAge);\n        LocalDate resultDate = result.toLocalDateTime().toLocalDate();\n        assertTrue(resultDate.isAfter(from) || resultDate.isEqual(from));\n        assertTrue(resultDate.isBefore(to) || resultDate.isEqual(to));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DateAndTime dateAndTime;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DateAndTime", "name": "dateAndTime", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/MusicTest.java.MusicTest", "name": "MusicTest", "file_path": "src/test/java/net/datafaker/providers/base/MusicTest.java", "superclasses": "", "methods": ["[void]key()", "[void]chord()", "[void]genre()"], "method_uris": ["src/test/java/net/datafaker/providers/base/MusicTest.java.MusicTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class MusicTest extends BaseFakerTest<BaseFaker> {\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        Music music = faker.music();\n        return List.of(TestSpec.of(music::instrument, \"music.instruments\", \"\\\\w+ ?\\\\w+\"));\n    }\n\n    @Test\n    void key() {\n        assertThat(faker.music().key()).matches(\"([A-Z])+([b#])?\");\n    }\n\n    @Test\n    void chord() {\n        assertThat(faker.music().chord()).matches(\"([A-Z])+([b#])?+(-?[a-zA-Z0-9]{0,4})\");\n    }\n\n    @RepeatedTest(100)\n    void genre() {\n        assertThat(faker.music().genre()).matches(\"[ -?\\\\w+]+\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/Locality_allSupportedLocalesTest.java.Locality_allSupportedLocalesTest", "name": "Locality_allSupportedLocalesTest", "file_path": "src/test/java/net/datafaker/providers/base/Locality_allSupportedLocalesTest.java", "superclasses": "", "methods": ["[void]testAllSupportedLocalesWithFileMasks()", "[void]testAllSupportedLocalesWithoutFileMasks()"], "method_uris": ["src/test/java/net/datafaker/providers/base/Locality_allSupportedLocalesTest.java.Locality_allSupportedLocalesTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Locality_allSupportedLocalesTest {\n    private Locality locality;\n\n    @BeforeEach\n    public void setUp() {\n        locality = new Locality(new Faker());\n    }\n\n    @Test\n    public void testAllSupportedLocalesWithFileMasks() {\n        Set<String> fileMasks = new HashSet<>();\n        List<String> expectedLocales = locality.allSupportedLocales();\n        List<String> actualLocales = locality.allSupportedLocales(fileMasks);\n        assertEquals(expectedLocales, actualLocales);\n    }\n\n    @Test\n    public void testAllSupportedLocalesWithoutFileMasks() {\n        List<String> expectedLocales = locality.allSupportedLocales();\n        List<String> actualLocales = locality.allSupportedLocales(null);\n        assertEquals(expectedLocales, actualLocales);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Locality locality;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Locality", "name": "locality", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/CompassTest.java.CompassTest", "name": "CompassTest", "file_path": "src/test/java/net/datafaker/providers/base/CompassTest.java", "superclasses": "", "methods": ["[void]compassDirectionWordWithCompassPoint(CompassPoint)", "[void]compassDirectionWordWithoutCompassPoint()", "[void]compassDirectionAbbreviationWithCompassPoint(CompassPoint)", "[void]compassDirectionAbbreviationWithoutCompassPoint()", "[void]compassAzimuthWithCompassPoint(CompassPoint)", "[void]compassAzimuthWithoutCompassPoint()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompassTest extends BaseFakerTest<BaseFaker> {\n\n    @ParameterizedTest\n    @EnumSource(CompassPoint.class)\n    void compassDirectionWordWithCompassPoint(CompassPoint compassPointOfDirection) {\n        assertThat(faker.compass().compassPoint(compassPointOfDirection).word()).isNotEmpty();\n    }\n\n    @Test\n    void compassDirectionWordWithoutCompassPoint() {\n        assertThat(faker.compass().word()).isNotEmpty();\n    }\n\n    @ParameterizedTest\n    @EnumSource(CompassPoint.class)\n    void compassDirectionAbbreviationWithCompassPoint(CompassPoint compassPointOfDirection) {\n        assertThat(faker.compass().compassPoint(compassPointOfDirection).abbreviation()).isNotEmpty();\n    }\n\n    @Test\n    void compassDirectionAbbreviationWithoutCompassPoint() {\n        assertThat(faker.compass().abbreviation()).isNotEmpty();\n    }\n\n    @ParameterizedTest\n    @EnumSource(CompassPoint.class)\n    void compassAzimuthWithCompassPoint(CompassPoint compassPointOfDirection) {\n        assertThat(faker.compass().compassPoint(compassPointOfDirection).azimuth()).isNotEmpty();\n    }\n\n    @Test\n    void compassAzimuthWithoutCompassPoint() {\n        assertThat(faker.compass().azimuth()).isNotEmpty();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/Company_urlTest.java.Company_urlTest", "name": "Company_urlTest", "file_path": "src/test/java/net/datafaker/providers/base/Company_urlTest.java", "superclasses": "", "methods": ["[void]testUrl()"], "method_uris": ["src/test/java/net/datafaker/providers/base/Company_urlTest.java.Company_urlTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Company_urlTest {\n    private Company company;\n\n    @BeforeEach\n    public void setUp() {\n        company = new Company(new BaseFaker());\n    }\n\n    @Test\n    void testUrl() {\n        String url = company.url();\n        assertTrue(url.startsWith(\"www.\"));\n        assertTrue(url.contains(\".\"));\n        assertTrue(url.matches(\"www\\\\.[a-zA-Z0-9-]+\\\\.[a-zA-Z]+\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Company company;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Company", "name": "company", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/CommerceTest.java.CommerceTest", "name": "CommerceTest", "file_path": "src/test/java/net/datafaker/providers/base/CommerceTest.java", "superclasses": "", "methods": ["[void]testDepartment()", "[void]testProductName()", "[void]testPrice()", "[void]testPriceMinMax()", "[void]testPromotionCode()", "[void]testPromotionCodeDigits()"], "method_uris": ["src/test/java/net/datafaker/providers/base/CommerceTest.java.CommerceTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class CommerceTest extends BaseFakerTest<BaseFaker> {\n\n    private final char decimalSeparator = new DecimalFormatSymbols(getFaker().getContext().getLocale()).getDecimalSeparator();\n\n    private static final String CAPITALIZED_WORD_REGEX = \"[A-Z][a-z]+\";\n\n    private static final String PROMOTION_CODE_REGEX = CAPITALIZED_WORD_REGEX + \"(-\" + CAPITALIZED_WORD_REGEX + \")*\";\n\n    private final Commerce commerce = faker.commerce();\n\n    @Test\n    void testDepartment() {\n        assertThat(commerce.department()).matches(\"(\\\\w+(, | & )?){1,3}\");\n    }\n\n    @Test\n    void testProductName() {\n        assertThat(commerce.productName()).matches(\"(\\\\w+ ?){3,4}\");\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(commerce::material, \"commerce.product_name.material\"),\n            TestSpec.of(commerce::brand, \"commerce.brand\"),\n            TestSpec.of(commerce::vendor, \"commerce.vendor\"));\n    }\n\n    @Test\n    void testPrice() {\n        assertThat(commerce.price()).matches(\"\\\\d{1,3}\\\\\" + decimalSeparator + \"\\\\d{2}\");\n    }\n\n    @Test\n    void testPriceMinMax() {\n        assertThat(commerce.price(100, 1000)).matches(\"\\\\d{3,4}\\\\\" + decimalSeparator + \"\\\\d{2}\");\n    }\n\n    @Test\n    void testPromotionCode() {\n        assertThat(commerce.promotionCode()).matches(PROMOTION_CODE_REGEX + PROMOTION_CODE_REGEX + \"\\\\d{6}\");\n    }\n\n    @Test\n    void testPromotionCodeDigits() {\n        assertThat(commerce.promotionCode(3)).matches(PROMOTION_CODE_REGEX + PROMOTION_CODE_REGEX + \"\\\\d{3}\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final char decimalSeparator = new DecimalFormatSymbols(getFaker().getContext().getLocale()).getDecimalSeparator();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "char", "name": "decimalSeparator = new DecimalFormatSymbols(getFaker().getContext().getLocale()).getDecimalSeparator()", "syntax_pass": true}, {"attribute_expression": "private static final String CAPITALIZED_WORD_REGEX = \"[A-Z][a-z]+\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "CAPITALIZED_WORD_REGEX = \"[A-Z][a-z]+\"", "syntax_pass": true}, {"attribute_expression": "private static final String PROMOTION_CODE_REGEX = CAPITALIZED_WORD_REGEX + \"(-\" + CAPITALIZED_WORD_REGEX + \")*\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PROMOTION_CODE_REGEX = CAPITALIZED_WORD_REGEX + \"(-\" + CAPITALIZED_WORD_REGEX + \")*\"", "syntax_pass": true}, {"attribute_expression": "private final Commerce commerce = faker.commerce();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Commerce", "name": "commerce = faker.commerce()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/SipTest.java.SipTest", "name": "SipTest", "file_path": "src/test/java/net/datafaker/providers/base/SipTest.java", "superclasses": "", "methods": ["[void]method_returnUpperCaseWithMinimum3Chars()", "[void]contentType_returnLowerCaseTwoWordsSepereatedBySlashMinimum3And4Chars()", "[void]messagingPort_return4DigitIntBetween1000And9999()", "[void]rtpPort_returnPositiveEvenInt()", "[void]provisionalResponseCode_return3DigitIntBetween100And199()", "[void]successResponse_Codereturn3DigitIntBetween200And299()", "[void]redirectResponseCode_Codereturn3DigitIntBetween300And399()", "[void]clientErrorResponseCode_Codereturn3DigitIntBetween400And499()", "[void]serverErrorResponseCode_Codereturn3DigitIntBetween500And599()", "[void]globalErrorResponseCode_Codereturn3DigitIntBetween600And699()", "[void]provisionalResponsePhrase_returnAnyNonDigitString()", "[void]successResponsePhrase_returnAnyNonDigitString()", "[void]redirectResponsePhrase_returnAnyNonDigitString()", "[void]clientErrorResponsePhrase_returnAnyNonDigitString()", "[void]serverErrorResponsePhrase_returnAnyNonDigitString()", "[void]globalErrorResponsePhrase_returnAnyNonDigitString()", "[void]bodyString_returnAValidSdpBodyString()", "[void]bodyBytes_isNotNull()", "[void]nameAddress_returnValidNameAddressString()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class SipTest extends BaseFakerTest<BaseFaker> {\n\n    Sip sip = faker.sip();\n\n    @Test\n    void method_returnUpperCaseWithMinimum3Chars() {\n        assertThat(sip.method()).matches(\"^[A-Z]{3,}$\");\n    }\n\n    @Test\n    void contentType_returnLowerCaseTwoWordsSepereatedBySlashMinimum3And4Chars() {\n        assertThat(sip.contentType()).matches(\"^[a-z]{4,}/+[a-z\\\\d-]{3,}$\");\n    }\n\n    @Test\n    void messagingPort_return4DigitIntBetween1000And9999() {\n        assertThat(sip.messagingPort()).isBetween(1000, 10000);\n    }\n\n    @Test\n    void rtpPort_returnPositiveEvenInt() {\n        int sut = sip.rtpPort();\n        assertThat(sut).isGreaterThanOrEqualTo(2);\n        assertThat(sut % 2).isZero();\n    }\n\n    @Test\n    void provisionalResponseCode_return3DigitIntBetween100And199() {\n        assertThat(sip.provisionalResponseCode()).isBetween(100, 200);\n    }\n\n    @Test\n    void successResponse_Codereturn3DigitIntBetween200And299() {\n        assertThat(sip.successResponseCode()).isBetween(200, 300);\n    }\n\n    @Test\n    void redirectResponseCode_Codereturn3DigitIntBetween300And399() {\n        assertThat(sip.redirectResponseCode()).isBetween(300, 400);\n    }\n\n    @Test\n    void clientErrorResponseCode_Codereturn3DigitIntBetween400And499() {\n        assertThat(sip.clientErrorResponseCode()).isBetween(400, 500);\n    }\n\n    @Test\n    void serverErrorResponseCode_Codereturn3DigitIntBetween500And599() {\n        assertThat(sip.serverErrorResponseCode()).isBetween(500, 600);\n    }\n\n    @Test\n    void globalErrorResponseCode_Codereturn3DigitIntBetween600And699() {\n        assertThat(sip.globalErrorResponseCode()).isBetween(600, 700);\n    }\n\n    @Test\n    void provisionalResponsePhrase_returnAnyNonDigitString() {\n        assertThat(sip.provisionalResponsePhrase()).matches(\"\\\\D+\");\n    }\n\n    @Test\n    void successResponsePhrase_returnAnyNonDigitString() {\n        assertThat(sip.successResponsePhrase()).matches(\"\\\\D+\");\n    }\n\n    @Test\n    void redirectResponsePhrase_returnAnyNonDigitString() {\n        assertThat(sip.redirectResponsePhrase()).matches(\"\\\\D+\");\n    }\n\n    @Test\n    void clientErrorResponsePhrase_returnAnyNonDigitString() {\n        assertThat(sip.clientErrorResponsePhrase()).matches(\"\\\\D+\");\n    }\n\n    @Test\n    void serverErrorResponsePhrase_returnAnyNonDigitString() {\n        assertThat(sip.serverErrorResponsePhrase()).matches(\"\\\\D+\");\n    }\n\n    @Test\n    void globalErrorResponsePhrase_returnAnyNonDigitString() {\n        assertThat(sip.globalErrorResponsePhrase()).matches(\"\\\\D+\");\n    }\n\n    @Test\n    void bodyString_returnAValidSdpBodyString() {\n        String[] sut = sip.bodyString().split(\"\\n\");\n\n        assertThat(sut).hasSize(7);\n\n        assertThat(sut[0]).isEqualTo(\"v=0\");\n\n        String[] secondLine = sut[1].split(\" \");\n        assertThat(secondLine[0]).startsWith(\"o=\");\n        assertThat(secondLine[1]).matches(\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\");\n        assertThat(secondLine[secondLine.length - 1]).matches(\"[a-z]+\\\\.\\\\w{2,4}\");\n\n        assertThat(sut[2]).isEqualTo(\"s=-\");\n\n        String[] fourthLine = sut[3].split(\" \");\n        assertThat(fourthLine[0]).isEqualTo(\"c=IN\");\n        assertThat(fourthLine[fourthLine.length - 1]).matches(\"^\\\\d{1,3}.\\\\d{1,3}.\\\\d{1,3}.\\\\d{1,3}$\");\n\n        assertThat(sut[4]).isEqualTo(\"t=0 0\");\n\n        String[] sixthLine = sut[5].split(\" \");\n        assertThat(sixthLine[0]).isEqualTo(\"m=audio\");\n        assertThat(Integer.parseInt(sixthLine[1])).isGreaterThanOrEqualTo(2);\n        assertThat(Integer.parseInt(sixthLine[1]) % 2).isZero();\n\n        assertThat(sut[6]).isEqualTo(\"a=rtpmap:0 PCMU/8000\");\n    }\n\n    @Test\n    void bodyBytes_isNotNull() {\n        byte[] sut = sip.bodyBytes();\n\n        assertThat(sut).isNotNull();\n    }\n\n    @Test\n    void nameAddress_returnValidNameAddressString() {\n        String[] sut = sip.nameAddress().split(\"@\");\n\n        assertThat(sut[0].split(\":\")[1]).matches(\"\\\\w+\");\n        assertThat(sut[1].split(\":\")[0]).matches(\"^\\\\d{1,3}.\\\\d{1,3}.\\\\d{1,3}.\\\\d{1,3}$\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "Sip sip = faker.sip();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Sip", "name": "sip = faker.sip()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/Internet_macAddressTest.java.Internet_macAddressTest", "name": "Internet_macAddressTest", "file_path": "src/test/java/net/datafaker/providers/base/Internet_macAddressTest.java", "superclasses": "", "methods": ["[void]testMacAddressWithNullPrefix()", "[void]testMacAddressWithEmptyPrefix()", "[void]testMacAddressWithValidPrefix()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Internet_macAddressTest {\n\n    private final BaseFaker faker = new BaseFaker();\n    private final Internet internet = new Internet(faker);\n\n    @Test\n    public void testMacAddressWithNullPrefix() {\n        String result = internet.macAddress(null);\n        assertEquals(17, result.length());\n        assertTrue(result.matches(\"^([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2})$\"));\n    }\n\n    @Test\n    public void testMacAddressWithEmptyPrefix() {\n        String result = internet.macAddress(\"\");\n        assertEquals(17, result.length());\n        assertTrue(result.matches(\"^([0-9A-Fa-f]{2}[:]){5}([0-9A-Fa-f]{2})$\"));\n    }\n\n    @Test\n    public void testMacAddressWithValidPrefix() {\n        String result = internet.macAddress(\"00:1A:2B\");\n        assertEquals(17, result.length());\n        assertTrue(result.startsWith(\"00:1A:2B\"));\n        assertTrue(result.matches(\"^00:1A:2B:([0-9A-Fa-f]{2}[:]){2}([0-9A-Fa-f]{2})$\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final BaseFaker faker = new BaseFaker();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BaseFaker", "name": "faker = new BaseFaker()", "syntax_pass": true}, {"attribute_expression": "private final Internet internet = new Internet(faker);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Internet", "name": "internet = new Internet(faker)", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/Vehicle_standardSpecsTest.java.Vehicle_standardSpecsTest", "name": "Vehicle_standardSpecsTest", "file_path": "src/test/java/net/datafaker/providers/base/Vehicle_standardSpecsTest.java", "superclasses": "", "methods": ["[void]testStandardSpecsMinMax()"], "method_uris": ["src/test/java/net/datafaker/providers/base/Vehicle_standardSpecsTest.java.Vehicle_standardSpecsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Vehicle_standardSpecsTest {\n\n    private Vehicle vehicle;\n    private BaseProviders faker;\n\n    @BeforeEach\n    public void setUp() {\n        faker = new Faker();\n        vehicle = new Vehicle(faker);\n    }\n\n    @RepeatedTest(10)\n    void testStandardSpecsMinMax() {\n        List<String> standardSpecs = vehicle.standardSpecs(11, 12);\n\n        assertThat(standardSpecs)\n            .hasSizeGreaterThanOrEqualTo(11)\n            .hasSizeLessThanOrEqualTo(12);\n\n        assertThat(standardSpecs.get(0)).isNotNull();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Vehicle vehicle;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Vehicle", "name": "vehicle", "syntax_pass": true}, {"attribute_expression": "private BaseProviders faker;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BaseProviders", "name": "faker", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/PhoneNumberTest.java.PhoneNumberTest", "name": "PhoneNumberTest", "file_path": "src/test/java/net/datafaker/providers/base/PhoneNumberTest.java", "superclasses": "", "methods": ["[void]testCellPhone_enUS()", "[void]testPhone_esMx()", "[void]testPhone_CA(Locale)", "[void]testAllPhoneNumberNational(Locale)", "[void]testAllPhoneNumberInternational(Locale)", "[void]testAllPhoneNumberMobile(Locale)", "[void]testAllPhoneNumberMobileInternational(Locale)", "[void]testCellPhone()", "[void]testPhoneNumber()", "[void]testExtension()", "[void]testSubscriberNumber()", "[void]testSubscriberNumberWithLength()", "[void]cellPhone_estonia()", "[void]phoneNumberNational_estonia()", "[void]phoneNumberInternational_estonia()", "[void]cellPhone_moldova()", "[void]phoneNumber_moldova()", "[void]phoneNumberInternational_moldova()"], "method_uris": ["src/test/java/net/datafaker/providers/base/PhoneNumberTest.java.PhoneNumberTest.[Stream<Arguments>]canadianLocales()", "src/test/java/net/datafaker/providers/base/PhoneNumberTest.java.PhoneNumberTest.[Phonenumber.PhoneNumber]parse(String,String)", "src/test/java/net/datafaker/providers/base/PhoneNumberTest.java.PhoneNumberTest.[Stream<Arguments>]locales()", "src/test/java/net/datafaker/providers/base/PhoneNumberTest.java.PhoneNumberTest.[Arguments]locale(String,String)", "src/test/java/net/datafaker/providers/base/PhoneNumberTest.java.PhoneNumberTest.[AbstractStringAssert<?>]assertThatPhone(String)", "src/test/java/net/datafaker/providers/base/PhoneNumberTest.java.PhoneNumberTest.[String]noSpaces(String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class PhoneNumberTest extends BaseFakerTest<BaseFaker> {\n    private static final Faker ESTONIAN = new Faker(new Locale(\"et\", \"EE\"));\n    private static final Faker MOLDOVAN = new Faker(new Locale(\"ro\", \"MD\"));\n    /**\n     * Number of phone numbers to generate during a test\n     */\n    private static final int COUNT = 100;\n\n    private final PhoneNumberUtil util = PhoneNumberUtil.getInstance();\n\n    @Test\n    void testCellPhone_enUS() {\n        final BaseFaker f = new BaseFaker(Locale.US);\n        String cellPhone = f.phoneNumber().cellPhone();\n        assertThat(cellPhone).matches(\"\\\\(?\\\\d+\\\\)?([- .]\\\\d+){1,3}\");\n    }\n\n    @RepeatedTest(COUNT)\n    void testPhone_esMx() {\n        final BaseFaker f = new BaseFaker(new Locale(\"es\", \"MX\"));\n        final PhoneNumber phoneNumber = f.phoneNumber();\n        assertThat(phoneNumber.cellPhone()).matches(\"(044 )?\\\\(?\\\\d+\\\\)?([- .]\\\\d+){1,3}\");\n        assertThat(phoneNumber.phoneNumber()).matches(\"\\\\(?\\\\d+\\\\)?([- .]\\\\d+){1,3}\");\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"canadianLocales\")\n    void testPhone_CA(Locale locale) {\n        String areaCode = \"263|354|382|403|587|780|825|236|250|368|428|604|672|778|204|431|506|\"\n            + \"709|782|902|226|249|289|343|365|416|437|519|548|613|647|705|807|905|367|\"\n            + \"418|438|450|468|474|514|579|581|584|683|742|753|819|873|306|639|867|879\";\n        Pattern canadianPhone = Pattern.compile(\"((\\\\+1)?(\\\\(?(%s)\\\\)?)|(%s))[- .]\\\\d{3}[- .]\\\\d{4}\".formatted(areaCode, areaCode));\n        PhoneNumber phoneNumber = new BaseFaker(locale).phoneNumber();\n        for (int i = 0; i < COUNT; i++) {\n            String phone = phoneNumber.cellPhone();\n            assertThat(phone).matches(canadianPhone);\n        }\n    }\n\n    private Stream<Arguments> canadianLocales() {\n        return Stream.of(\n            Arguments.of(Locale.CANADA),\n            Arguments.of(new Locale(\"ca\", \"CA\"))\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"locales\")\n    void testAllPhoneNumberNational(Locale locale) throws NumberParseException {\n        final BaseFaker faker = new BaseFaker(locale);\n        final PhoneNumber phoneNumberProvider = faker.phoneNumber();\n        for (int i = 0; i < COUNT; i++) {\n            String phoneNumber = phoneNumberProvider.phoneNumber();\n            Phonenumber.PhoneNumber proto = parse(phoneNumber, locale.getCountry());\n            assertThat(util.isValidNumberForRegion(proto, locale.getCountry()))\n                .as(() -> \"Invalid phone %s for locale %s\".formatted(phoneNumber, locale))\n                .isTrue();\n        }\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"locales\")\n    void testAllPhoneNumberInternational(Locale locale) throws NumberParseException {\n        final BaseFaker faker = new BaseFaker(locale);\n        final PhoneNumber phoneNumberProvider = faker.phoneNumber();\n        for (int i = 0; i < COUNT; i++) {\n            String phoneNumber = phoneNumberProvider.phoneNumberInternational();\n            Phonenumber.PhoneNumber proto = parse(phoneNumber, locale.getCountry());\n            assertThat(util.isValidNumberForRegion(proto, locale.getCountry()))\n                .as(() -> \"Invalid phone %s for locale %s\".formatted(phoneNumber, locale))\n                .isTrue();\n        }\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"locales\")\n    void testAllPhoneNumberMobile(Locale locale) throws NumberParseException {\n        final BaseFaker faker = new BaseFaker(locale);\n        final PhoneNumber phoneNumberProvider = faker.phoneNumber();\n        for (int i = 0; i < COUNT; i++) {\n            String phoneNumber = phoneNumberProvider.cellPhone();\n            Phonenumber.PhoneNumber proto = parse(phoneNumber, locale.getCountry());\n            assertThat(util.isValidNumberForRegion(proto, locale.getCountry()))\n                .as(() -> \"Invalid phone %s for locale %s\".formatted(phoneNumber, locale))\n                .isTrue();\n        }\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"locales\")\n    void testAllPhoneNumberMobileInternational(Locale locale) throws NumberParseException {\n        final BaseFaker faker = new BaseFaker(locale);\n        final PhoneNumber phoneNumberProvider = faker.phoneNumber();\n        for (int i = 0; i < COUNT; i++) {\n            String phoneNumber = phoneNumberProvider.cellPhoneInternational();\n            Phonenumber.PhoneNumber proto = parse(phoneNumber, locale.getCountry());\n            assertThat(util.isValidNumberForRegion(proto, locale.getCountry()))\n                .as(() -> \"Invalid phone %s for locale %s\".formatted(phoneNumber, locale))\n                .isTrue();\n        }\n    }\n\n    private Phonenumber.PhoneNumber parse(String generatedNumber, String countryCode) throws NumberParseException {\n        String normalizedNumber = \"IT\".equals(countryCode) || \"HU\".equals(countryCode) ? generatedNumber : generatedNumber.replaceFirst(\"^0(.+)\", \"$1\");\n        return util.parse(normalizedNumber, countryCode);\n    }\n\n    // `new Locale(\"en\", \"IND\")` in `new Locale(\"en\", \"IND\"), \"IN\")` is a Java's Locale\n\n    // `\"IN\"` in `new Locale(\"en\", \"IND\"), \"IN\")` is a PhoneNumberUtil's region\n    private static Stream<Arguments> locales() {\n        return Stream.of(\n            locale(\"en\", \"US\"),\n            locale(\"en\", \"GB\"),\n            locale(\"en\", \"AU\"),\n            locale(\"en\", \"CA\"),\n            locale(\"en\", \"MS\"),\n            locale(\"en\", \"NG\"),\n            locale(\"en\", \"NZ\"),\n            locale(\"et\", \"EE\"),\n            locale(\"bg\", \"BG\"),\n            locale(\"by\", \"BY\"),\n            locale(\"ca\", \"CA\"),\n            locale(\"cs\", \"CZ\"),\n            locale(\"de\", \"DE\"),\n            locale(\"de\", \"AT\"),\n            locale(\"de\", \"CH\"),\n            locale(\"en\", \"IN\"),\n            locale(\"en\", \"NP\"),\n            locale(\"en\", \"PK\"),\n            locale(\"hu\", \"HU\"),\n            locale(\"fi\", \"FI\"),\n            locale(\"ko\", \"KR\"),\n            locale(\"ja\", \"JP\"),\n            locale(\"lv\", \"LV\"),\n            locale(\"mk\", \"MK\"),\n            locale(\"ca\", \"IT\"),\n            locale(\"nl\", \"NL\"),\n            locale(\"pl\", \"PL\"),\n            locale(\"pt\", \"PT\"),\n            locale(\"ro\", \"MD\"),\n            locale(\"sq\", \"AL\"),\n            locale(\"zh\", \"CN\"),\n            locale(\"zh\", \"TW\"),\n            locale(\"uk\", \"UA\"),\n            locale(\"tr\", \"TR\"),\n            locale(\"en\", \"SG\"),\n            locale(\"en\", \"PH\"),\n            locale(\"en\", \"UG\"),\n            locale(\"en\", \"ZA\"),\n            locale(\"sv\", \"SE\"),\n            locale(\"th\", \"TH\"),\n            locale(\"sk\", \"SK\"),\n            locale(\"ru\", \"RU\"),\n            locale(\"pt\", \"BR\"),\n            locale(\"es\", \"AR\"),\n            locale(\"es\", \"MX\"),\n            locale(\"es\", \"PY\"),\n            locale(\"es\", \"ES\"),\n            locale(\"fr\", \"CA\"),\n            locale(\"fr\", \"FR\"),\n            locale(\"he\", \"IL\"),\n            locale(\"hr\", \"HR\"),\n            locale(\"hy\", \"AM\"),\n            locale(\"id\", \"ID\"),\n            locale(\"nb\", \"NO\"),\n            locale(\"no\", \"NO\"),\n            locale(\"da\", \"DK\"),\n            locale(\"vi\", \"VI\"),\n            locale(\"fr\", \"CH\")\n        );\n    }\n\n    private static Arguments locale(String language, String country) {\n        return Arguments.of(new Locale(language, country));\n    }\n\n    @Test\n    void testCellPhone() {\n        assertThat(faker.phoneNumber().cellPhone()).matches(\"\\\\(?\\\\d+\\\\)?([- .]\\\\d+){1,3}\");\n    }\n\n    @Test\n    void testPhoneNumber() {\n        assertThat(faker.phoneNumber().phoneNumber()).matches(\"\\\\(?\\\\d+\\\\)?([- .]x?\\\\d+){1,5}\");\n    }\n\n    @Test\n    void testExtension() {\n        assertThat(faker.phoneNumber().extension()).matches(\"\\\\d{4}\");\n    }\n\n    @Test\n    void testSubscriberNumber() {\n        assertThat(faker.phoneNumber().subscriberNumber()).matches(\"\\\\d{4}\");\n    }\n\n    @Test\n    void testSubscriberNumberWithLength() {\n        assertThat(faker.phoneNumber().subscriberNumber(10)).matches(\"\\\\d{10}\");\n    }\n\n    @RepeatedTest(COUNT)\n    void cellPhone_estonia() {\n        String cellPhone = noSpaces(ESTONIAN.phoneNumber().cellPhone());\n        assertThatPhone(cellPhone).matches(\"[358]\\\\d{6,7}\");\n    }\n\n    @RepeatedTest(COUNT)\n    void phoneNumberNational_estonia() {\n        String cellPhone = noSpaces(ESTONIAN.phoneNumber().phoneNumberNational());\n        assertThatPhone(cellPhone).matches(\"[34678]\\\\d{6,7}\");\n    }\n\n    @RepeatedTest(COUNT)\n    void phoneNumberInternational_estonia() {\n        String cellPhone = noSpaces(ESTONIAN.phoneNumber().phoneNumberInternational());\n        assertThatPhone(cellPhone).matches(\"\\\\+372[34678]\\\\d{6,7}\");\n    }\n\n    @RepeatedTest(10)\n    void cellPhone_moldova() {\n        String phone = noSpaces(MOLDOVAN.phoneNumber().cellPhone());\n        assertThatPhone(phone).matches(\"0[567]\\\\d{7}\");\n    }\n\n    @RepeatedTest(10)\n    void phoneNumber_moldova() {\n        String phone = noSpaces(MOLDOVAN.phoneNumber().phoneNumber());\n        assertThatPhone(phone).matches(\"0\\\\d{8}\");\n    }\n\n    @RepeatedTest(10)\n    void phoneNumberInternational_moldova() {\n        String phone = noSpaces(MOLDOVAN.phoneNumber().phoneNumberInternational());\n        assertThatPhone(phone).matches(\"\\\\+373\\\\d{8}\");\n    }\n\n    private static AbstractStringAssert<?> assertThatPhone(String phoneNumber) {\n        return assertThat(phoneNumber)\n            .as(() -> \"Phone: %s\".formatted(phoneNumber));\n    }\n\n    private static String noSpaces(String phone) {\n        return phone.replaceAll(\"\\\\s+\", \"\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Faker ESTONIAN = new Faker(new Locale(\"et\", \"EE\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "ESTONIAN = new Faker(new Locale(\"et\", \"EE\"))", "syntax_pass": true}, {"attribute_expression": "private static final Faker MOLDOVAN = new Faker(new Locale(\"ro\", \"MD\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "MOLDOVAN = new Faker(new Locale(\"ro\", \"MD\"))", "syntax_pass": true}, {"attribute_expression": "private static final int COUNT = 100;", "docstring": "\nNumber of phone numbers to generate during a test\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "COUNT = 100", "syntax_pass": true}, {"attribute_expression": "private final PhoneNumberUtil util = PhoneNumberUtil.getInstance();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PhoneNumberUtil", "name": "util = PhoneNumberUtil.getInstance()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/TwitterTest.java.TwitterTest", "name": "TwitterTest", "file_path": "src/test/java/net/datafaker/providers/base/TwitterTest.java", "superclasses": "", "methods": ["[void]testCreatedDateForward()", "[void]testCreatedDateBackward()", "[void]testShortTwitterIdLength()", "[void]testLongTwitterIdLength()", "[void]testTwitterIdLength()", "[void]testTwitterIdUnique()", "[void]testTextLength()", "[void]testTextKeyWords()", "[void]username()", "[void]userId()", "[void]linkTestRules()", "[void]linkTestKeyWords()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class TwitterTest extends BaseFakerTest<BaseFaker> {\n\n    private final Twitter twitter = getFaker().twitter();\n    @Test\n    void testCreatedDateForward() {\n        Date testDate = new Date();\n        Date constrainDate = new Date(testDate.getTime() + 3000000);\n        Date generated = twitter.createdTime(true, testDate, constrainDate);\n        boolean test = generated.after(testDate) && generated.before(constrainDate);\n        assertThat(test).isTrue();\n    }\n\n    @Test\n    void testCreatedDateBackward() {\n        Date testDate = new Date();\n        Date constrainDate = new Date(testDate.getTime() - 3000000);\n        Date generated = twitter.createdTime(false, testDate, constrainDate);\n        boolean test = generated.before(testDate) && generated.after(constrainDate);\n        assertThat(test).isTrue();\n    }\n\n    @Test\n    void testShortTwitterIdLength() {\n        int expectedLength = 6;\n        String generatedID = twitter.twitterId(expectedLength);\n        assertThat(generatedID).hasSize(expectedLength);\n    }\n\n    @RepeatedTest(100)\n    void testLongTwitterIdLength() {\n        int expectedLength = 25;\n        String generatedID = twitter.twitterId(expectedLength);\n        assertThat(generatedID).hasSize(expectedLength);\n    }\n\n    @Test\n    void testTwitterIdLength() {\n        int expectedLength = 15;\n        String generatedID = twitter.twitterId(expectedLength);\n        assertThat(generatedID).hasSize(expectedLength);\n    }\n\n    @Test\n    void testTwitterIdUnique() {\n        int expectedLength = 15;\n        String generatedIDOne = twitter.twitterId(expectedLength);\n        String generatedIDTwo = twitter.twitterId(expectedLength);\n        assertThat(generatedIDOne).isNotEqualTo(generatedIDTwo);\n    }\n\n    @Test\n    void testTextLength() {\n        int sentenceMaxLength = 15;\n        int wordMaxLength = 5;\n        String text = twitter.text(null, sentenceMaxLength, wordMaxLength);\n        String[] textwords = text.split(\" \");\n        assertThat(textwords).hasSizeLessThanOrEqualTo(sentenceMaxLength);\n    }\n\n    @Test\n    void testTextKeyWords() {\n        int sentenceMaxLength = 15;\n        int wordMaxLength = 5;\n        String[] keywords = {\"buy\", \"see\"};\n        String text = twitter.text(keywords, sentenceMaxLength, wordMaxLength);\n        String[] textwords = text.split(\" \");\n        boolean flag = true;\n        for (String keyword : keywords) {\n            boolean tmpFlag = false;\n            for (String textword : textwords) {\n                if (keyword.equals(textword)) {\n                    tmpFlag = true;\n                    break;\n                }\n            }\n            flag = tmpFlag;\n            if (!flag) {\n                break;\n            }\n        }\n        assertThat(flag).isTrue();\n    }\n\n    @Test\n    void username() {\n        final Pattern pattern = Pattern.compile(\"[a-zA-Z\\\\d_\\\\-\\u4e00-\\u9fa5]+\");\n        for (int i = 0; i < 10; i++) {\n            assertThat(twitter.userName()).matches(pattern);\n        }\n    }\n\n    @Test\n    void userId() {\n        Pattern pattern = Pattern.compile(\"\\\\d+\");\n        for (int i = 0; i < 10; i++) {\n            assertThat(twitter.userId()).matches(pattern);\n        }\n    }\n\n    @Test\n    void linkTestRules() {\n        final Pattern pattern = Pattern.compile(\"[A-Za-z\\\\d.:/]+\");\n        for (int i = 0; i < 10; i++) {\n            assertThat(twitter.getLink(\"John\", 6)).matches(pattern);\n        }\n    }\n\n    @Test\n    void linkTestKeyWords() {\n        for (int i = 0; i < 10; i++) {\n            assertThat(twitter.getLink(\"John\", 6)).contains(\"John\");\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Twitter twitter = getFaker().twitter();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Twitter", "name": "twitter = getFaker().twitter()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/TimeTest.java.TimeTest", "name": "TimeTest", "file_path": "src/test/java/net/datafaker/providers/base/TimeTest.java", "superclasses": "", "methods": ["[void]testFutureTime()", "[void]testFutureTimeWithMinimum()", "[void]testPastTimeWithMinimum()", "[void]testPastTime()", "[void]testBetween()", "[void]testBetweenWithSameLocalTime()", "[void]testBetweenThenLargerThanNow()", "[void]testBetweenWithMask()", "[void]futureWithMask()", "[void]pastWithMask()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class TimeTest extends BaseFakerTest<BaseFaker> {\n\n    private static final Pattern RE_TIME_BETWEEN = Pattern.compile(\"[0-2][0-9]:[0-5][0-9]:[0-5][0-9]\");\n    private static final long NANOSECONDS_IN_DAY = 24L * 60 * 60 * 1000 * 1000_000L;\n    private static final long NANOSECONDS_IN_MINUTE = 60 * 1000 * 1000_000L;\n\n    @Test\n    void testFutureTime() {\n        LocalTime now = LocalTime.now();\n        for (int i = 0; i < 1000; i++) {\n            long future = faker.time().future(1, ChronoUnit.SECONDS);\n            assertThat(LocalTime.ofNanoOfDay(future))\n                .isAfter(now)\n                .isBefore(now.plusSeconds(10));\n        }\n    }\n\n    @Test\n    void testFutureTimeWithMinimum() {\n        LocalTime now = LocalTime.now();\n        for (int i = 0; i < 1000; i++) {\n            long future = faker.time().future(5, 4, ChronoUnit.SECONDS);\n            assertThat(LocalTime.ofNanoOfDay(future))\n                .isAfter(now)\n                .isBefore(now.plusSeconds(10))\n                .isAfter(now.plusSeconds(1));\n        }\n    }\n\n    @Test\n    void testPastTimeWithMinimum() {\n        LocalTime now = LocalTime.now();\n        for (int i = 0; i < 1000; i++) {\n            long past = faker.time().past(5, 4, ChronoUnit.SECONDS);\n            assertThat(LocalTime.ofNanoOfDay(past))\n                .isBefore(now)\n                .isAfter(now.minusSeconds(6))\n                .isBefore(now.minusSeconds(2));\n        }\n    }\n\n    @Test\n    void testPastTime() {\n        LocalTime now = LocalTime.now();\n        long past = faker.time().past(100, ChronoUnit.SECONDS);\n        assertThat(LocalTime.ofNanoOfDay(past)).isBefore(now);\n    }\n\n    @Test\n    void testBetween() {\n        LocalTime now = LocalTime.now();\n        LocalTime then = now.plusSeconds(1);\n\n        for (int i = 0; i < 1000; i++) {\n            long time = faker.time().between(now, then);\n            assertThat(LocalTime.ofNanoOfDay(time))\n                .isBefore(then)\n                .isAfter(now);\n        }\n    }\n\n    @Test\n    void testBetweenWithSameLocalTime() {\n        LocalTime now = LocalTime.now();\n\n        long time = faker.time().between(now, now);\n        assertThat(LocalTime.ofNanoOfDay(time)).isEqualTo(now);\n    }\n\n    @Test\n    void testBetweenThenLargerThanNow() {\n        LocalTime now = LocalTime.now();\n        LocalTime then = now.plusSeconds(1);\n        assertThatThrownBy(() -> faker.time().between(then, now))\n            .isInstanceOf(IllegalArgumentException.class)\n            .hasMessage(\"Invalid time range: the upper bound time (%s) is before the lower bound (%s)\".formatted(now, then));\n    }\n\n    @RepeatedTest(10)\n    void testBetweenWithMask() {\n        String pattern = \"HH:mm:ss\";\n        LocalTime now = LocalTime.ofNanoOfDay((long) (Math.random() * (NANOSECONDS_IN_DAY - NANOSECONDS_IN_MINUTE - 1)));\n        LocalTime then = now.plusMinutes(1);\n\n        String result = faker.time().between(now, then, pattern);\n        assertThat(result).matches(RE_TIME_BETWEEN);\n        TemporalAccessor timeBetween = DateTimeFormatter.ofPattern(pattern).parse(result);\n        assertThat(timeBetween.query(LocalTime::from)).isAfter(now.minusSeconds(1));\n        assertThat(timeBetween.query(LocalTime::from)).isBefore(then.plusSeconds(1));\n    }\n\n    @Test\n    void futureWithMask() {\n        String pattern = \"mm:hh:ss\";\n        DateTimeFormatter.ofPattern(pattern).parse(faker.time().future(1, ChronoUnit.HOURS, pattern));\n        DateTimeFormatter.ofPattern(pattern).parse(faker.time().future(20, 1, ChronoUnit.HOURS, pattern));\n    }\n\n    @Test\n    void pastWithMask() {\n        String pattern = \"mm:hh:ss\";\n        DateTimeFormatter.ofPattern(pattern).parse(faker.time().past(1, ChronoUnit.MINUTES, pattern));\n        DateTimeFormatter.ofPattern(pattern).parse(faker.time().past(20, 1, ChronoUnit.MILLIS, pattern));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Pattern RE_TIME_BETWEEN = Pattern.compile(\"[0-2][0-9]:[0-5][0-9]:[0-5][0-9]\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "RE_TIME_BETWEEN = Pattern.compile(\"[0-2][0-9]:[0-5][0-9]:[0-5][0-9]\")", "syntax_pass": true}, {"attribute_expression": "private static final long NANOSECONDS_IN_DAY = 24L * 60 * 60 * 1000 * 1000_000L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "NANOSECONDS_IN_DAY = 24L * 60 * 60 * 1000 * 1000_000L", "syntax_pass": true}, {"attribute_expression": "private static final long NANOSECONDS_IN_MINUTE = 60 * 1000 * 1000_000L;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "long", "name": "NANOSECONDS_IN_MINUTE = 60 * 1000 * 1000_000L", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/MbtiTest.java.MbtiTest", "name": "MbtiTest", "file_path": "src/test/java/net/datafaker/providers/base/MbtiTest.java", "superclasses": "", "methods": ["[void]type()", "[void]name()", "[void]characteristic()", "[void]personage()", "[void]merit()", "[void]weakness()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class MbtiTest extends BaseFakerTest<BaseFaker> {\n\n    private final Mbti mbti = faker.mbti();\n\n    @Test\n    void type() {\n        assertThat(isNullOrEmpty(mbti.type())).isFalse();\n        assertThat(mbti.type()).matches(\"[A-Za-z,\\\\-.() ]+\");\n    }\n\n    @Test\n    void name() {\n        assertThat(isNullOrEmpty(mbti.name())).isFalse();\n        assertThat(mbti.name()).matches(\"[A-Za-z,\\\\-.();:'$ ]+\");\n    }\n\n    @Test\n    void characteristic() {\n        assertThat(isNullOrEmpty(mbti.characteristic())).isFalse();\n    }\n\n    @Test\n    void personage() {\n        assertThat(isNullOrEmpty(mbti.personage())).isFalse();\n        assertThat(mbti.personage()).matches(\"[A-Za-z,\\\\-.()';:$ ]+\");\n    }\n\n    @Test\n    void merit() {\n        assertThat(isNullOrEmpty(mbti.merit())).isFalse();\n    }\n\n    @Test\n    void weakness() {\n        assertThat(isNullOrEmpty(mbti.weakness())).isFalse();\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Mbti mbti = faker.mbti();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Mbti", "name": "mbti = faker.mbti()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/Number_numberBetweenTest.java.Number_numberBetweenTest", "name": "Number_numberBetweenTest", "file_path": "src/test/java/net/datafaker/providers/base/Number_numberBetweenTest.java", "superclasses": "", "methods": ["[void]testNumberBetween_MinEqualsMax()", "[void]testNumberBetween_MinLessThanMax()", "[void]testNumberBetween_MinGreaterThanMax()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Number_numberBetweenTest {\n\n    @Test\n    public void testNumberBetween_MinEqualsMax() {\n        BaseFaker faker = mock(BaseFaker.class);\n        Number number = new Number(faker);\n\n        int result = number.numberBetween(5, 5);\n\n        assertEquals(5, result);\n    }\n\n    @Test\n    public void testNumberBetween_MinLessThanMax() {\n        BaseFaker faker = mock(BaseFaker.class);\n        RandomService randomService = mock(RandomService.class);\n        when(faker.random()).thenReturn(randomService);\n        when(randomService.nextInt(anyInt())).thenReturn(3);\n        Number number = new Number(faker);\n\n        int result = number.numberBetween(2, 10);\n\n        assertEquals(5, result);\n    }\n\n    @Test\n    public void testNumberBetween_MinGreaterThanMax() {\n        BaseFaker faker = mock(BaseFaker.class);\n        RandomService randomService = mock(RandomService.class);\n        when(faker.random()).thenReturn(randomService);\n        when(randomService.nextInt(anyInt())).thenReturn(3);\n        Number number = new Number(faker);\n\n        int result = number.numberBetween(10, 2);\n\n        assertEquals(5, result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/DateAndTime_pastTest.java.DateAndTime_pastTest", "name": "DateAndTime_pastTest", "file_path": "src/test/java/net/datafaker/providers/base/DateAndTime_pastTest.java", "superclasses": "", "methods": ["[void]testPast()"], "method_uris": ["src/test/java/net/datafaker/providers/base/DateAndTime_pastTest.java.DateAndTime_pastTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DateAndTime_pastTest {\n\n    private DateAndTime dateAndTime;\n\n    @BeforeEach\n    public void setUp() {\n        BaseFaker baseFaker = new BaseFaker();\n        dateAndTime = new DateAndTime(baseFaker);\n    }\n\n    @Test\n    public void testPast() {\n        int atMost = 10;\n        TimeUnit unit = TimeUnit.DAYS;\n        Timestamp referenceDate = new Timestamp(System.currentTimeMillis());\n\n        Timestamp pastDate = dateAndTime.past(atMost, unit, referenceDate);\n\n        long upperBoundMillis = unit.toMillis(atMost);\n        long referenceMillis = referenceDate.getTime();\n        long pastMillis = pastDate.getTime();\n\n        assertTrue(pastMillis < referenceMillis);\n        assertTrue(referenceMillis - pastMillis <= upperBoundMillis);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DateAndTime dateAndTime;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DateAndTime", "name": "dateAndTime", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/FinancialTermsTest.java.FinancialTermsTest", "name": "FinancialTermsTest", "file_path": "src/test/java/net/datafaker/providers/base/FinancialTermsTest.java", "superclasses": "", "methods": ["[void]category(FinancialTerms.Category)", "[void]defaults()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FinancialTermsTest extends BaseFakerTest<BaseFaker> {\n\n    private final FinancialTerms financialTerms = faker.financialTerms();\n\n    @EnumSource(FinancialTerms.Category.class)\n    @ParameterizedTest\n    void category(FinancialTerms.Category category) {\n        assertThat(financialTerms.noun(category)).isNotBlank();\n        assertThat(financialTerms.verb(category)).isNotBlank();\n        assertThat(financialTerms.adjective(category)).isNotBlank();\n    }\n\n    @RepeatedTest(10)\n    void defaults() {\n        assertThat(financialTerms.noun()).isNotBlank();\n        assertThat(financialTerms.verb()).isNotBlank();\n        assertThat(financialTerms.adjective()).isNotBlank();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final FinancialTerms financialTerms = faker.financialTerms();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "FinancialTerms", "name": "financialTerms = faker.financialTerms()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/BaseFaker_getFakerTest.java.BaseFaker_getFakerTest", "name": "BaseFaker_getFakerTest", "file_path": "src/test/java/net/datafaker/providers/base/BaseFaker_getFakerTest.java", "superclasses": "", "methods": ["[void]testGetFaker()"], "method_uris": ["src/test/java/net/datafaker/providers/base/BaseFaker_getFakerTest.java.BaseFaker_getFakerTest.[void]setupEnvironment()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class BaseFaker_getFakerTest {\n\n    private BaseFaker baseFaker;\n\n    @BeforeEach\n    void setupEnvironment() {\n        baseFaker = new BaseFaker();\n    }\n\n    @Test\n    void testGetFaker() {\n        BaseFaker result = baseFaker.getFaker();\n        assertTrue(result instanceof BaseFaker);\n        assertEquals(baseFaker, result);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private BaseFaker baseFaker;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BaseFaker", "name": "baseFaker", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/EducatorTest.java.EducatorTest", "name": "EducatorTest", "file_path": "src/test/java/net/datafaker/providers/base/EducatorTest.java", "superclasses": "", "methods": ["[void]testUniversity()", "[void]testCourse()", "[void]testSubjectWithNumber()", "[void]testSecondarySchool()", "[void]testCampus()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class EducatorTest extends BaseFakerTest<BaseFaker> {\n\n    @Test\n    void testUniversity() {\n        assertThat(faker.educator().university()).matches(\"(\\\\w+ ?){2,3}\");\n    }\n\n    @Test\n    void testCourse() {\n        assertThat(faker.educator().course()).matches(\"(\\\\(?\\\\w+\\\\)? ?){3,6}\");\n    }\n\n    @RepeatedTest(10)\n    void testSubjectWithNumber() {\n        assertThat(faker.educator().subjectWithNumber()).matches(\"[a-zA-Z() ]+ [1-5][0-9]{2}\");\n    }\n\n    @Test\n    void testSecondarySchool() {\n        assertThat(faker.educator().secondarySchool()).matches(\"(\\\\w+ ?){2,3}\");\n    }\n\n    @Test\n    void testCampus() {\n        assertThat(faker.educator().campus()).matches(\"(\\\\w+ ?){1,2}\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/MoneyTest.java.MoneyTest", "name": "MoneyTest", "file_path": "src/test/java/net/datafaker/providers/base/MoneyTest.java", "superclasses": "", "methods": ["[void]testCurrency()", "[void]testCurrencyCode()", "[void]testNumericCode()", "[void]testCurrencySymbol()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class MoneyTest extends BaseFakerTest<BaseFaker> {\n\n    @Test\n    void testCurrency() {\n        assertThat(faker.money().currency()).isNotEmpty();\n    }\n\n    @Test\n    void testCurrencyCode() {\n        assertThat(faker.money().currencyCode()).isNotEmpty();\n    }\n\n    @Test\n    void testNumericCode() {\n        assertThat(faker.money().currencyNumericCode()).isNotEmpty();\n    }\n\n    @Test\n    void testCurrencySymbol() {\n        assertThat(faker.money().currencySymbol()).isNotEmpty();\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/Locality_displayNameTest.java.Locality_displayNameTest", "name": "Locality_displayNameTest", "file_path": "src/test/java/net/datafaker/providers/base/Locality_displayNameTest.java", "superclasses": "", "methods": ["[void]testDisplayNameWithLocaleString()", "[void]testDisplayNameWithLocaleStringWithoutReplacement()", "[void]testDisplayNameRandomness()"], "method_uris": ["src/test/java/net/datafaker/providers/base/Locality_displayNameTest.java.Locality_displayNameTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Locality_displayNameTest {\n    private Locality locality;\n    private Faker faker;\n\n    @BeforeEach\n    public void setUp() {\n        faker = new Faker();\n        locality = new Locality(faker);\n    }\n\n    @Test\n    void testDisplayNameWithLocaleString() {\n        String localeString = locality.localeString();\n        Locale locale = Locale.forLanguageTag(localeString);\n        String expectedDisplayLanguage = locale.getDisplayLanguage(Locale.ROOT);\n        String expectedDisplayCountry = locale.getDisplayCountry(Locale.ROOT);\n        String expectedDisplayName = expectedDisplayLanguage;\n        if (!expectedDisplayCountry.isEmpty()) {\n            expectedDisplayName += \" (\" + expectedDisplayCountry + \")\";\n        }\n\n        String actualDisplayName = locality.displayName();\n        assertNotNull(actualDisplayName);\n        assertFalse(actualDisplayName.isEmpty());\n    }\n\n    @Test\n    void testDisplayNameWithLocaleStringWithoutReplacement() {\n        String localeString = locality.localeStringWithoutReplacement();\n        Locale locale = Locale.forLanguageTag(localeString);\n        String expectedDisplayLanguage = locale.getDisplayLanguage(Locale.ROOT);\n        String expectedDisplayCountry = locale.getDisplayCountry(Locale.ROOT);\n        String expectedDisplayName = expectedDisplayLanguage;\n        if (!expectedDisplayCountry.isEmpty()) {\n            expectedDisplayName += \" (\" + expectedDisplayCountry + \")\";\n        }\n\n        String actualDisplayName = locality.displayName();\n        assertNotNull(actualDisplayName);\n        assertFalse(actualDisplayName.isEmpty());\n    }\n\n    @RepeatedTest(10)\n    void testDisplayNameRandomness() {\n        String displayName1 = locality.displayName();\n        String displayName2 = locality.displayName();\n        assertNotNull(displayName1);\n        assertNotNull(displayName2);\n        assertFalse(displayName1.isEmpty());\n        assertFalse(displayName2.isEmpty());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Locality locality;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Locality", "name": "locality", "syntax_pass": true}, {"attribute_expression": "private Faker faker;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Faker", "name": "faker", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/DateAndTime_futureTest.java.DateAndTime_futureTest", "name": "DateAndTime_futureTest", "file_path": "src/test/java/net/datafaker/providers/base/DateAndTime_futureTest.java", "superclasses": "", "methods": ["[void]testFutureWithDays()", "[void]testFutureWithHours()", "[void]testFutureWithMinutes()"], "method_uris": ["src/test/java/net/datafaker/providers/base/DateAndTime_futureTest.java.DateAndTime_futureTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DateAndTime_futureTest {\n\n    private DateAndTime dateAndTime;\n\n    @BeforeEach\n    public void setUp() {\n        BaseFaker baseFaker = new BaseFaker();\n        dateAndTime = new DateAndTime(baseFaker);\n    }\n\n    @Test\n    public void testFutureWithDays() {\n        int atMost = 10;\n        TimeUnit unit = TimeUnit.DAYS;\n        Timestamp referenceDate = new Timestamp(System.currentTimeMillis());\n\n        Timestamp futureDate = dateAndTime.future(atMost, unit, referenceDate);\n\n        long difference = futureDate.getTime() - referenceDate.getTime();\n        assertTrue(difference > 0 && difference < unit.toMillis(atMost));\n    }\n\n    @Test\n    public void testFutureWithHours() {\n        int atMost = 24;\n        TimeUnit unit = TimeUnit.HOURS;\n        Timestamp referenceDate = new Timestamp(System.currentTimeMillis());\n\n        Timestamp futureDate = dateAndTime.future(atMost, unit, referenceDate);\n\n        long difference = futureDate.getTime() - referenceDate.getTime();\n        assertTrue(difference > 0 && difference < unit.toMillis(atMost));\n    }\n\n    @Test\n    public void testFutureWithMinutes() {\n        int atMost = 60;\n        TimeUnit unit = TimeUnit.MINUTES;\n        Timestamp referenceDate = new Timestamp(System.currentTimeMillis());\n\n        Timestamp futureDate = dateAndTime.future(atMost, unit, referenceDate);\n\n        long difference = futureDate.getTime() - referenceDate.getTime();\n        assertTrue(difference > 0 && difference < unit.toMillis(atMost));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DateAndTime dateAndTime;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DateAndTime", "name": "dateAndTime", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/NationTest.java.NationTest", "name": "NationTest", "file_path": "src/test/java/net/datafaker/providers/base/NationTest.java", "superclasses": "", "methods": ["[void]nationality()", "[void]language()", "[void]capitalCity()", "[void]flag()", "[void]isoLanguage()", "[void]isoCountry()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class NationTest extends BaseFakerTest<BaseFaker> {\n\n    Nation nation = faker.nation();\n\n    @Test\n    void nationality() {\n        assertThat(nation.nationality()).matches(\"\\\\P{Cc}+\");\n    }\n\n    @Test\n    void language() {\n        assertThat(nation.language()).matches(\"[A-Za-z ]+\");\n    }\n\n    @Test\n    void capitalCity() {\n        assertThat(nation.capitalCity()).matches(\"[A-Za-z .'()-]+\");\n    }\n\n    @Test\n    void flag() {\n        String flag = nation.flag();\n\n        // all utf8 emoji flags are at least 4 characters long and start with the same char\n        assertThat(flag).hasSizeGreaterThanOrEqualTo(4);\n        assertThat(flag.charAt(0)).isEqualTo('\\uD83C');\n    }\n\n    @Test\n    void isoLanguage() {\n        assertThat(nation.isoLanguage()).matches(\"[a-z]{2}\");\n    }\n\n    @Test\n    void isoCountry() {\n        assertThat(nation.isoCountry()).matches(\"[A-Z]{2}\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "Nation nation = faker.nation();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Nation", "name": "nation = faker.nation()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/DomainTest.java.DomainTest", "name": "DomainTest", "file_path": "src/test/java/net/datafaker/providers/base/DomainTest.java", "superclasses": "", "methods": ["[void]testFirstLevelDomainNotNull()", "[void]testFirstLevelDomain()", "[void]testSecondLevelDomainNotNull()", "[void]testSecondLevelDomain()", "[void]testFullDomainNotNull()", "[void]testFullDomain()", "[void]testValidDomainNotNull()", "[void]testValidDomain()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class DomainTest extends BaseFakerTest<BaseFaker> {\n\n    @Test\n    void testFirstLevelDomainNotNull() {\n        String ret = faker.domain().firstLevelDomain(\"example\");\n        assert (ret != null);\n    }\n\n    @Test\n    void testFirstLevelDomain() {\n        String[] components = faker.domain().firstLevelDomain(\"example\").split(\"\\\\.\");\n        for (String str : components) {\n            assert (!str.isEmpty());\n        }\n    }\n\n    @Test\n    void testSecondLevelDomainNotNull() {\n        String ret = faker.domain().secondLevelDomain(\"example\");\n        assert (ret != null);\n    }\n\n    @Test\n    void testSecondLevelDomain() {\n        String[] components = faker.domain().secondLevelDomain(\"example\").split(\"\\\\.\");\n        for (String str : components) {\n            assert (!str.isEmpty());\n        }\n    }\n\n\n    @Test\n    void testFullDomainNotNull() {\n        String ret = faker.domain().fullDomain(\"example\");\n        assert (ret != null);\n    }\n\n    @Test\n    void testFullDomain() {\n        String[] components = faker.domain().fullDomain(\"example\").split(\"\\\\.\");\n        for (String str : components) {\n            assert (!str.isEmpty());\n        }\n    }\n\n    @RepeatedTest(10)\n    void testValidDomainNotNull() {\n        String ret = faker.domain().validDomain(\"example\");\n        assert (ret != null);\n    }\n\n    @Test\n    void testValidDomain() {\n        String[] components = faker.domain().validDomain(\"example\").split(\"\\\\.\");\n        for (String str : components) {\n            assert (!str.isEmpty());\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/DateAndTime_periodTest.java.DateAndTime_periodTest", "name": "DateAndTime_periodTest", "file_path": "src/test/java/net/datafaker/providers/base/DateAndTime_periodTest.java", "superclasses": "", "methods": ["[void]testPeriodValidRange()", "[void]testPeriodInvalidRange()", "[void]testPeriodEqualBounds()"], "method_uris": ["src/test/java/net/datafaker/providers/base/DateAndTime_periodTest.java.DateAndTime_periodTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DateAndTime_periodTest {\n    private DateAndTime dateAndTime;\n\n    @BeforeEach\n    public void setUp() {\n        dateAndTime = new DateAndTime(new BaseFaker());\n    }\n\n    @Test\n    public void testPeriodValidRange() {\n        Period min = Period.of(1, 2, 3);\n        Period max = Period.of(5, 6, 7);\n        Period result = dateAndTime.period(min, max);\n        assertTrue(result.getYears() >= min.getYears() && result.getYears() <= max.getYears());\n        assertTrue(result.getMonths() >= min.getMonths() && result.getMonths() <= max.getMonths());\n        assertTrue(result.getDays() >= min.getDays() && result.getDays() <= max.getDays());\n    }\n\n    @Test\n    public void testPeriodInvalidRange() {\n        Period min = Period.of(5, 6, 7);\n        Period max = Period.of(1, 2, 3);\n        assertThrows(IllegalArgumentException.class, () -> dateAndTime.period(min, max));\n    }\n\n    @Test\n    public void testPeriodEqualBounds() {\n        Period min = Period.of(3, 4, 5);\n        Period max = Period.of(3, 4, 5);\n        Period result = dateAndTime.period(min, max);\n        assertEquals(min, result);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DateAndTime dateAndTime;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DateAndTime", "name": "dateAndTime", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/InternetTest.java.InternetTest", "name": "InternetTest", "file_path": "src/test/java/net/datafaker/providers/base/InternetTest.java", "superclasses": "", "methods": ["[void]testUsername()", "[void]emailSubject()", "[void]testUsernameWithSpaces()", "[void]testEmailAddress()", "[void]testEmailAddressWithLocalPartParameter()", "[void]testSafeEmailAddress()", "[void]testSafeEmailAddressWithLocalPartParameter()", "[void]testEmailAddressDoesNotIncludeAccentsInTheLocalPart()", "[void]testSafeEmailAddressDoesNotIncludeAccentsInTheLocalPart()", "[void]testWebdomain()", "[void]testUrl()", "[void]testImage()", "[void]testDomainName()", "[void]testDomainWord()", "[void]testDomainSuffix()", "[void]testImageWithExplicitParams()", "[void]testHttpMethod()", "[void]testPassword()", "[void]testPasswordWithFixedLength()", "[void]testPasswordIncludeDigit()", "[void]testPasswordMinLengthMaxLength()", "[void]testPasswordMinLengthMaxLengthIncludeUpperCase()", "[void]testPasswordMinLengthMaxLengthIncludeUpperCaseIncludeSpecial()", "[void]testPort()", "[void]shouldGenerateAPasswordWithMinAndMaxLength()", "[void]testPasswordMinLengthMaxLengthIncludeUpperCaseIncludeSpecialIncludeDigit()", "[void]testMacAddress()", "[void]testIpV4Address()", "[void]testIpV4Cidr()", "[void]testPrivateIpV4Address()", "[void]testPublicIpV4Address()", "[void]testIpV6()", "[void]testIpV6Cidr()", "[void]testSlugWithParams()", "[void]testSlug()", "[void]testUuidv3ConstantRandomSeed()", "[void]testUuidv3()", "[void]testUuid()", "[void]testUuidv4()", "[void]testUuidv7()", "[void]testFarsiIDNs()", "[void]testUserAgent()", "[void]testBotUserAgent()", "[void]testSlugWithNull()"], "method_uris": ["src/test/java/net/datafaker/providers/base/InternetTest.java.InternetTest.[Condition<String>]getCharacterCondition(char,int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class InternetTest extends BaseFakerTest<BaseFaker> {\n\n    public static final Pattern IPV6_HOST_ADDRESS = Pattern.compile(\"[0-9a-fA-F]{1,4}(:([0-9a-fA-F]{1,4})){1,7}\");\n    @Spy\n    private BaseFaker mockedFaker;\n\n    @RepeatedTest(100)\n    void testUsername() {\n        assertThat(faker.internet().username()).matches(\"^(\\\\w+)\\\\.(\\\\w+)$\");\n    }\n\n    @RepeatedTest(10)\n    void emailSubject() {\n        assertThat(faker.internet().emailSubject()).isNotBlank();\n    }\n\n    @Test\n    void testUsernameWithSpaces() {\n        final Name name = Mockito.spy(new Name(mockedFaker));\n        doReturn(\"Compound Name\").when(name).firstName();\n        doReturn(name).when(mockedFaker).name();\n        assertThat(mockedFaker.internet().username()).matches(\"^(\\\\w+)\\\\.(\\\\w+)$\");\n    }\n\n    @Test\n    void testEmailAddress() {\n        String emailAddress = faker.internet().emailAddress();\n        assertThat(EmailValidator.getInstance().isValid(emailAddress)).isTrue();\n    }\n\n    @Test\n    void testEmailAddressWithLocalPartParameter() {\n        String emailAddress = faker.internet().emailAddress(\"john\");\n        assertThat(emailAddress).startsWith(\"john@\");\n        assertThat(EmailValidator.getInstance().isValid(emailAddress)).isTrue();\n    }\n\n    @Test\n    void testSafeEmailAddress() {\n        List<String> emails = new ArrayList<>();\n        for (int i = 0; i < 100; i++) {\n            String emailAddress = faker.internet().safeEmailAddress();\n            assertThat(EmailValidator.getInstance().isValid(emailAddress)).isTrue();\n            emails.add(emailAddress);\n        }\n        final String safeDomain = faker.internet().resolve(\"internet.safe_email\");\n\n        assertThat(emails.stream().filter(t -> t.endsWith(\"@\" + safeDomain)).collect(Collectors.toList()))\n            .isNotEmpty();\n    }\n\n    @Test\n    void testSafeEmailAddressWithLocalPartParameter() {\n        List<String> emails = new ArrayList<>();\n        for (int i = 0; i < 100; i++) {\n            String emailAddress = faker.internet().safeEmailAddress(\"john\");\n            assertThat(emailAddress).startsWith(\"john@\");\n            assertThat(EmailValidator.getInstance().isValid(emailAddress)).isTrue();\n            emails.add(emailAddress);\n        }\n        final String safeDomain = faker.internet().resolve(\"internet.safe_email\");\n\n        assertThat(emails.stream().filter(t -> t.endsWith(\"@\" + safeDomain)).collect(Collectors.toList()))\n            .isNotEmpty();\n    }\n\n    @Test\n    void testEmailAddressDoesNotIncludeAccentsInTheLocalPart() {\n        String emailAddress = faker.internet().emailAddress(\"\u00e1\u00e9\u00ed\u00f3\u00fa\");\n        assertThat(emailAddress).startsWith(\"aeiou@\");\n    }\n\n    @Test\n    void testSafeEmailAddressDoesNotIncludeAccentsInTheLocalPart() {\n        String emailAddress = faker.internet().safeEmailAddress(\"\u00e1\u00e9\u00ed\u00f3\u00fa\");\n        assertThat(emailAddress).startsWith(\"aeiou@\");\n    }\n\n    @Test\n    void testWebdomain() {\n        assertThat(faker.internet().webdomain()).matches(\"www\\\\.[\\\\w-]+\\\\.\\\\w+\");\n    }\n\n    @RepeatedTest(100)\n    void testUrl() {\n        // This test assumes that java.net.URL has better validation than we can come up with in\n        // regex.\n        String url = faker.internet().url();\n        assertDoesNotThrow(() -> new URL(url));\n    }\n\n    @Test\n    void testImage() {\n        String imageUrl = faker.internet().image();\n        assertThat(imageUrl).matches(\"^https://picsum\\\\.photos/\\\\d{1,4}/\\\\d{1,4}$\");\n    }\n\n    @Test\n    void testDomainName() {\n        assertThat(faker.internet().domainName()).matches(\"[a-z]+\\\\.\\\\w{2,4}\");\n    }\n\n    @Test\n    void testDomainWord() {\n        assertThat(faker.internet().domainWord()).matches(\"[a-z]+\");\n    }\n\n    @Test\n    void testDomainSuffix() {\n        assertThat(faker.internet().domainSuffix()).matches(\"\\\\w{2,4}\");\n    }\n\n    @Test\n    void testImageWithExplicitParams() {\n        String imageUrl = faker.internet().image(800, 600, \"lorem\");\n        assertThat(imageUrl).matches(\"^https://picsum\\\\.photos/seed/lorem/800/600$\");\n    }\n\n    @Test\n    void testHttpMethod() {\n        assertThat(faker.internet().httpMethod()).isNotEmpty();\n    }\n\n    @Test\n    void testPassword() {\n        assertThat(faker.internet().password()).matches(\"[a-z\\\\d]{8,16}\");\n    }\n\n    @Test\n    void testPasswordWithFixedLength() {\n        String password = new BaseFaker().internet().password(32, 32, true, true, true);\n        assertThat(password).hasSize(32);\n    }\n\n    @Test\n    void testPasswordIncludeDigit() {\n        assertThat(faker.internet().password()).matches(\"[a-z\\\\d]{8,16}\");\n        assertThat(faker.internet().password(false)).matches(\"[a-z]{8,16}\");\n    }\n\n    @Test\n    void testPasswordMinLengthMaxLength() {\n        assertThat(faker.internet().password(10, 25)).matches(\"[a-z\\\\d]{10,25}\");\n    }\n\n    @Test\n    void testPasswordMinLengthMaxLengthIncludeUpperCase() {\n        assertThat(faker.internet().password(1, 2, false)).matches(\"[a-z\\\\d]{1,2}\");\n        assertThat(faker.internet().password(10, 25, true)).matches(\"[a-zA-Z\\\\d]{10,25}\");\n    }\n\n    @Test\n    void testPasswordMinLengthMaxLengthIncludeUpperCaseIncludeSpecial() {\n        assertThat(faker.internet().password(10, 25, false, false)).matches(\"[a-z\\\\d]{10,25}\");\n        assertThat(faker.internet().password(10, 25, false, true)).matches(\"[a-z\\\\d!@#$%^&*]{10,25}\");\n        assertThat(faker.internet().password(10, 25, true, true)).matches(\"[a-zA-Z\\\\d!@#$%^&*]{10,25}\");\n    }\n\n    @RepeatedTest(100)\n    void testPort() {\n        assertThat(faker.internet().port()).isBetween(0, 65535);\n    }\n\n    @Test\n    void shouldGenerateAPasswordWithMinAndMaxLength() {\n        List<String> results = new ArrayList<>();\n        for (int i = 0; i < 300; i++) {\n            results.add(faker.internet().password(1, 10));\n        }\n\n        final List<String> min = results.stream().filter(x -> x.length() == 1).toList();\n        final List<String> max = results.stream().filter(x -> x.length() == 10).toList();\n\n        assertThat(min.size()).isPositive();\n        assertThat(max.size()).isPositive();\n    }\n\n    @Test\n    void testPasswordMinLengthMaxLengthIncludeUpperCaseIncludeSpecialIncludeDigit() {\n        assertThat(faker.internet().password(10, 25, false, false, false)).matches(\"[a-z]{10,25}\");\n        assertThat(faker.internet().password(10, 25, false, true, true)).matches(\"[a-z\\\\d!@#$%^&*]{10,25}\");\n        assertThat(faker.internet().password(10, 25, true, true, false)).matches(\"[a-zA-Z!@#$%^&*]{10,25}\");\n        assertThat(faker.internet().password(10, 25, true, true, true)).matches(\"[a-zA-Z\\\\d!@#$%^&*]{10,25}\");\n    }\n\n    private Condition<String> getCharacterCondition(char c, int expectedCnt) {\n        return new Condition<>(s -> {\n            int cnt = 0;\n            if (s.length() < expectedCnt) {\n                return false;\n            }\n            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i) == c) {\n                    cnt++;\n                }\n                if (cnt > expectedCnt) {\n                    return false;\n                }\n            }\n            return cnt == expectedCnt;\n        }, \"Expect \" + expectedCnt + \" colons\");\n    }\n\n    @Test\n    void testMacAddress() {\n        Condition<String> colon = getCharacterCondition(':', 5);\n        assertThat(faker.internet().macAddress()).is(colon);\n        assertThat(faker.internet().macAddress(\"\")).is(colon);\n\n        assertThat(faker.internet().macAddress(\"fa:fa:fa\"))\n            .startsWith(\"fa:fa:fa\")\n            .is(colon);\n\n        assertThat(faker.internet().macAddress(\"01:02\"))\n            .startsWith(\"01:02\")\n            .is(colon);\n\n        // loop through 1000 times just to 'run it through the wringer'\n        for (int i = 0; i < 1000; i++) {\n            assertThat(faker.internet().macAddress()).matches(\"[0-9a-fA-F]{2}(:([0-9a-fA-F]{1,4})){5}\");\n        }\n    }\n\n    @Test\n    void testIpV4Address() {\n        Condition<String> colon = getCharacterCondition('.', 3);\n        assertThat(faker.internet().ipV4Address()).is(colon);\n        for (int i = 0; i < 100; i++) {\n            final String[] octets = faker.internet().getIpV4Address().getHostAddress().split(\"\\\\.\");\n            assertThat(parseInt(octets[0])).isBetween(0, 255);\n            assertThat(parseInt(octets[1])).isBetween(0, 255);\n            assertThat(parseInt(octets[2])).isBetween(0, 255);\n            assertThat(parseInt(octets[3])).isBetween(0, 255);\n        }\n    }\n\n    @Test\n    void testIpV4Cidr() {\n        assertThat(faker.internet().ipV4Cidr())\n            .is(getCharacterCondition('.', 3))\n            .is(getCharacterCondition('/', 1));\n\n        for (int i = 0; i < 1000; i++) {\n            assertThat(parseInt(faker.internet().ipV4Cidr().split(\"/\")[1]))\n                .isBetween(1, 32);\n        }\n    }\n\n    @Test\n    void testPrivateIpV4Address() {\n        String tenDot = \"^10\\\\..+\";\n        String oneTwoSeven = \"^127\\\\..+\";\n        String oneSixNine = \"^169\\\\.254\\\\..+\";\n        String oneNineTwo = \"^192\\\\.168\\\\..+\";\n        String oneSevenTwo = \"^172\\\\.(16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)\\\\..+\";\n\n        for (int i = 0; i < 1000; i++) {\n            String addr = faker.internet().getPrivateIpV4Address().getHostAddress();\n            assertThat(addr).is(anyOf(\n                new Condition<>(s -> s.matches(tenDot), \"tenDot\"),\n                new Condition<>(s -> s.matches(oneTwoSeven), \"oneTwoSeven\"),\n                new Condition<>(s -> s.matches(oneSixNine), \"oneSixNine\"),\n                new Condition<>(s -> s.matches(oneNineTwo), \"oneNineTwo\"),\n                new Condition<>(s -> s.matches(oneSevenTwo), \"oneSevenTwo\")\n            ));\n        }\n    }\n\n    @Test\n    void testPublicIpV4Address() {\n        String tenDot = \"^10\\\\.\";\n        String oneTwoSeven = \"^127\\\\.\";\n        String oneSixNine = \"^169\\\\.254\";\n        String oneNineTwo = \"^192\\\\.168\\\\.\";\n        String oneSevenTwo = \"^172\\\\.(16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)\\\\.\";\n\n        for (int i = 0; i < 1000; i++) {\n            String addr = faker.internet().getPublicIpV4Address().getHostAddress();\n            assertThat(addr).doesNotMatch(tenDot)\n                .doesNotMatch(oneTwoSeven)\n                .doesNotMatch(oneSixNine)\n                .doesNotMatch(oneNineTwo)\n                .doesNotMatch(oneSevenTwo);\n        }\n    }\n\n    @Test\n    void testIpV6() {\n        assertThat(faker.internet().ipV6Address()).is(getCharacterCondition(':', 7));\n\n        for (int i = 0; i < 1000; i++) {\n            assertThat(faker.internet().getIpV6Address().getHostAddress()).matches(IPV6_HOST_ADDRESS);\n        }\n    }\n\n    @Test\n    void testIpV6Cidr() {\n        assertThat(faker.internet().ipV6Cidr())\n            .is(getCharacterCondition(':', 7))\n            .is(getCharacterCondition('/', 1));\n\n        for (int i = 0; i < 1000; i++) {\n            assertThat(parseInt(faker.internet().ipV6Cidr().split(\"/\")[1]))\n                .isBetween(1, 128);\n        }\n    }\n\n    @RepeatedTest(10)\n    void testSlugWithParams() {\n        assertThat(faker.internet().slug(List.of(\"a\", \"b\"), \"-\")).matches(\"[a-zA-Z]+-[a-zA-Z]+\");\n    }\n\n    @RepeatedTest(10)\n    void testSlug() {\n        assertThat(faker.internet().slug()).matches(\"[a-zA-Z]+_[a-zA-Z]+\");\n    }\n\n    @Test\n    void testUuidv3ConstantRandomSeed() {\n        final int randomSeed = 42;\n        // Two fakers, same random seed.\n        final BaseFaker faker1 = new BaseFaker(new Random(randomSeed));\n        final BaseFaker faker2 = new BaseFaker(new Random((randomSeed)));\n        // Keep it simple and without loops, three examples should suffice to act as the general case.\n        final String faker1Uuidv3First = faker1.internet().uuidv3();\n        final String faker1Uuidv3Second = faker1.internet().uuidv3();\n        final String faker1Uuidv3Third = faker1.internet().uuidv3();\n        final String faker2Uuidv3First = faker2.internet().uuidv3();\n        final String faker2Uuidv3Second = faker2.internet().uuidv3();\n        final String faker2Uuidv3Third = faker2.internet().uuidv3();\n        // Two different fakers with the same random seed should produce the same uuids.\n        assertThat(faker1Uuidv3First).isEqualTo(faker2Uuidv3First);\n        assertThat(faker1Uuidv3Second).isEqualTo(faker2Uuidv3Second);\n        assertThat(faker1Uuidv3Third).isEqualTo(faker2Uuidv3Third);\n    }\n\n    @RepeatedTest(10)\n    void testUuidv3() {\n        assertThat(faker.internet().uuidv3()).matches(\"^[0-9a-f]{8}-[0-9a-f]{4}-3[0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$\");\n    }\n\n    @RepeatedTest(10)\n    void testUuid() {\n        assertThat(faker.internet().uuid()).matches(\"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$\");\n    }\n\n    @RepeatedTest(10)\n    void testUuidv4() {\n        assertThat(faker.internet().uuidv4()).matches(\"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$\");\n    }\n\n    @RepeatedTest(10)\n    void testUuidv7() {\n        assertThat(faker.internet().uuidv7()).matches(\"^[0-9a-f]{8}-[0-9a-f]{4}-7[0-9a-f]{3}-[0-9a-f]{4}-[0-9a-f]{12}$\");\n    }\n\n    @RepeatedTest(100)\n    void testFarsiIDNs() {\n        // in this case, we're just making sure Farsi doesn't blow up.\n        // there have been issues with Farsi not being produced.\n        final BaseFaker f = new BaseFaker(new Locale(\"fa\"));\n        assertThat(f.internet().domainName()).isNotEmpty();\n        assertThat(f.internet().emailAddress()).isNotEmpty();\n        assertThat(f.internet().safeEmailAddress()).isNotEmpty();\n        assertThat(f.internet().webdomain()).isNotEmpty();\n    }\n\n    @Test\n    void testUserAgent() {\n        Internet.UserAgent[] agents = Internet.UserAgent.values();\n        for (Internet.UserAgent agent : agents) {\n            assertThat(faker.internet().userAgent(agent)).isNotEmpty();\n        }\n\n        //Test faker.internet().userAgentAny() for random user_agent retrieval.\n        assertThat(faker.internet().userAgent()).isNotEmpty();\n    }\n\n    @Test\n    void testBotUserAgent() {\n        Internet.BotUserAgent[] agents = Internet.BotUserAgent.values();\n        for (Internet.BotUserAgent agent : agents) {\n            assertThat(faker.internet().botUserAgent(agent)).isNotEmpty();\n        }\n\n        //Test faker.internet().userAgentAny() for random user_agent retrieval.\n        assertThat(faker.internet().botUserAgentAny()).isNotEmpty();\n    }\n\n    @Test\n    void testSlugWithNull() {\n        assertThat(faker.internet().slug(null, \"_\")).isNotNull();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final Pattern IPV6_HOST_ADDRESS = Pattern.compile(\"[0-9a-fA-F]{1,4}(:([0-9a-fA-F]{1,4})){1,7}\");", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Pattern", "name": "IPV6_HOST_ADDRESS = Pattern.compile(\"[0-9a-fA-F]{1,4}(:([0-9a-fA-F]{1,4})){1,7}\")", "syntax_pass": true}, {"attribute_expression": "@Spy\n    private BaseFaker mockedFaker;", "docstring": "", "modifiers": "@Spy\n    private", "marker_annotations": ["@Spy"], "non_marker_annotations": ["private"], "comments": [], "type": "BaseFaker", "name": "mockedFaker", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/NumberTest.java.NumberTest", "name": "NumberTest", "file_path": "src/test/java/net/datafaker/providers/base/NumberTest.java", "superclasses": "", "methods": ["[void]testRandomDigit()", "[void]testRandomDigitNotZero()", "[void]testRandomNumber()", "[void]testRandomNumberWithSingleDigitStrict()", "[void]testRandomNumberWithZeroDigitsStrict()", "[void]testRandomNumberWithGivenDigitsStrict()", "[void]testRandomDouble()", "[void]testNumberBetween()", "[void]testLongNumberBetweenRepeated()", "[void]testIntNumberBetweenRepeated()", "[void]testNumberBetweenOneAndThree()", "[void]testLongBetweenOneAndThree()", "[void]numberBetweenIntIntZeroMinMax()", "[void]numberBetweenLongLongZeroMinMax()", "[void]randomDoubleRandomizationQuality()", "[void]numberBetweenIntIntRandomizationQuality()", "[void]numberBetweenLongLongRandomizationQuality()", "[void]testRandomDoubleMaxEqualsMin()", "[void]testDigit()", "[void]testDigits()", "[void]testIntNumberBetweenQuality()", "[void]testLongNumberBetweenQuality()", "[void]testNumberBetweenContain()", "[void]testNumberBetweenBorder()", "[void]testPositive()", "[void]testNegative()"], "method_uris": ["src/test/java/net/datafaker/providers/base/NumberTest.java.NumberTest.[double]randomizationQualityTest(Function<Pair<Long, Long>, Double>)", "src/test/java/net/datafaker/providers/base/NumberTest.java.NumberTest.[double]uniquePercentageOfResults(long,Supplier<T>)", "src/test/java/net/datafaker/providers/base/NumberTest.java.NumberTest.[long]calculateNumbersToGet(long,long)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class NumberTest extends BaseFakerTest<BaseFaker> {\n\n    public static final int RANDOMIZATION_QUALITY_RANGE_END = 1000;\n    public static final int RANDOMIZATION_QUALITY_RANGE_STEP = 25;\n    private static final int RANDOMIZATION_QUALITY_RANGE_START = RANDOMIZATION_QUALITY_RANGE_STEP;\n    public static final int RANDOMIZATION_TESTS_MAX_NUMBERS_TO_GET = 1000;\n\n    private static final double INDIVIDUAL_RUN_GT_PERCENT_UNIQUE = 0.8;\n    final double percentRunsGtUniquePercentage = 0.90;\n\n    @Test\n    void testRandomDigit() {\n        Set<Integer> nums = new HashSet<>(10);\n        final Number number = faker.number();\n        for (int i = 0; i < 1000; ++i) {\n            int value = number.randomDigit();\n            assertThat(value).isLessThanOrEqualTo(9)\n                .isGreaterThanOrEqualTo(0);\n            nums.add(value);\n        }\n        assertThat(nums).contains(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n    }\n\n    @Test\n    void testRandomDigitNotZero() {\n        Set<Integer> nums = new HashSet<>(10);\n        final Number number = faker.number();\n        for (int i = 0; i < 1000; ++i) {\n            int value = number.randomDigitNotZero();\n            assertThat(value).isLessThanOrEqualTo(9)\n                .isGreaterThan(0);\n            nums.add(value);\n        }\n        assertThat(nums).contains(1, 2, 3, 4, 5, 6, 7, 8, 9);\n    }\n\n    @Test\n    void testRandomNumber() {\n        long value = faker.number().randomNumber();\n        assertThat(value).isLessThan(Long.MAX_VALUE);\n    }\n\n    @Test\n    void testRandomNumberWithSingleDigitStrict() {\n        final Number number = faker.number();\n        for (int i = 0; i < 100; ++i) {\n            long value = number.randomNumber(1, true);\n            assertThat(value).isLessThan(10L)\n                .isGreaterThanOrEqualTo(0L);\n        }\n    }\n\n    @Test\n    void testRandomNumberWithZeroDigitsStrict() {\n        final Number number = faker.number();\n        for (int i = 0; i < 100; ++i) {\n            long value = number.randomNumber(0, true);\n            assertThat(value).isZero();\n        }\n    }\n\n    @Test\n    void testRandomNumberWithGivenDigitsStrict() {\n        final Number number = faker.number();\n        for (int i = 1; i < 9; ++i) {\n            for (int x = 0; x < 100; ++x) {\n                long value = number.randomNumber(i, true);\n                String stringValue = String.valueOf(value);\n                assertThat(stringValue).hasSize(i);\n            }\n        }\n    }\n\n    @Test\n    void testRandomDouble() {\n        final Number number = faker.number();\n        for (int i = 1; i < 5; ++i) {\n            for (int x = 0; x < 100; ++x) {\n                double value = number.randomDouble(i, 1, 1000);\n                String strVal = BigDecimal.valueOf(value).stripTrailingZeros().toString();\n                final int dotIndex = strVal.indexOf('.');\n                if (dotIndex != -1 && strVal.indexOf('+') == -1) {\n                    assertThat(strVal.length() - dotIndex - 1).isLessThanOrEqualTo(i);\n                }\n            }\n        }\n    }\n\n    @Test\n    void testNumberBetween() {\n        Number number = faker.number();\n        for (int i = 1; i < 100; ++i) {\n            int v = number.numberBetween(0, i);\n            assertThat(v).isLessThanOrEqualTo(i)\n                .isGreaterThanOrEqualTo(0);\n        }\n\n        for (long i = 1L; i < 100L; ++i) {\n            long v = number.numberBetween(0, i);\n            assertThat(v).isLessThanOrEqualTo(i)\n                .isGreaterThanOrEqualTo(0L);\n        }\n\n        int min1 = 1;\n        long v1 = number.numberBetween(min1, 980000000L);\n        assertThat(v1).isGreaterThan(min1)\n            .isLessThan(980000000L);\n    }\n\n    @RepeatedTest(100)\n    void testLongNumberBetweenRepeated() {\n        long low = 1;\n        long high = 10;\n        long v = faker.number().numberBetween(low, high);\n        assertThat(v).isLessThan(high)\n            .isGreaterThanOrEqualTo(low);\n    }\n\n    @RepeatedTest(100)\n    void testIntNumberBetweenRepeated() {\n        int low = 1;\n        int high = 10;\n        int v = faker.number().numberBetween(low, high);\n        assertThat(v).isLessThan(high)\n            .isGreaterThanOrEqualTo(low);\n    }\n\n    @Test\n    void testNumberBetweenOneAndThree() {\n        Set<Integer> nums = new HashSet<>(3);\n        final int lowerLimit = 0;\n        final int upperLimit = 3;\n        final Number number = faker.number();\n        for (int i = 0; i < 1000; ++i) {\n            int value = number.numberBetween(lowerLimit, upperLimit);\n            assertThat(value).isLessThan(upperLimit)\n                .isGreaterThanOrEqualTo(lowerLimit);\n            nums.add(value);\n        }\n        assertThat(nums).contains(0, 1, 2);\n    }\n\n    @Test\n    void testLongBetweenOneAndThree() {\n        Set<Long> nums = new HashSet<>(3);\n        final long lowerLimit = 0;\n        final long upperLimit = 3;\n        final Number number = faker.number();\n        for (int i = 0; i < 1000; ++i) {\n            long value = number.numberBetween(lowerLimit, upperLimit);\n            assertThat(value).isLessThan(upperLimit)\n                .isGreaterThanOrEqualTo(lowerLimit);\n            nums.add(value);\n        }\n        assertThat(nums).contains(0L, 1L, 2L);\n    }\n\n    @Test\n    void numberBetweenIntIntZeroMinMax() {\n        assertThat(faker.number().numberBetween(0, 0))\n            .as(\"Calling numberBetween with min==max yields min, with 0\").isZero();\n        assertThat(faker.number().numberBetween(2, 2))\n            .as(\"Calling numberBetween with min==max yields min\")\n            .isEqualTo(2);\n    }\n\n    @Test\n    void numberBetweenLongLongZeroMinMax() {\n        assertThat(faker.number().numberBetween(0L, 0L))\n            .as(\"Calling numberBetween with min==max yields min, with 0\").isZero();\n        assertThat(faker.number().numberBetween(2L, 2L))\n            .as(\"Calling numberBetween with min==max yields min\")\n            .isEqualTo(2);\n    }\n\n    /**\n     * Given a number of min/max ranges\n     * for each min/max range, call {@link net.datafaker.providers.base.Number#randomDouble(int, int, int)} with min/max 'n' times\n     * calculate the uniqueness for that given min/max range.\n     * For all 'uniqueness' values\n     * verify the percentage of 'uniqueness' ratios over 80% is 90%.\n     * <p>\n     * This isn't perfect, but it ensures a pretty good degree of uniqueness in the random number generation.\n     */\n    @Test\n    void randomDoubleRandomizationQuality() {\n        Function<Pair<Long, Long>, Double> minMaxRangeToUniquePercentageFunction = minMax -> {\n            final int min = minMax.getLeft().intValue(), max = minMax.getRight().intValue();\n            long numbersToGet = calculateNumbersToGet(min, max);\n\n            return uniquePercentageOfResults(numbersToGet, () -> faker.number().randomDouble(0, min, max));\n        };\n\n        final double percentGreaterThan80Percent = randomizationQualityTest(minMaxRangeToUniquePercentageFunction);\n        assertThat(percentGreaterThan80Percent).isGreaterThanOrEqualTo(percentRunsGtUniquePercentage);\n\n        // this covers Issue # 121, the number of times the function is called with the MIN/MAX values here\n        // is RANDOMIZATION_TESTS_MAX_NUMBERS_TO_GET\n        final double extremeRunUniquePercent = minMaxRangeToUniquePercentageFunction.apply(Pair.of((long) Integer.MIN_VALUE, (long) Integer.MAX_VALUE));\n        assertThat(extremeRunUniquePercent).isGreaterThanOrEqualTo(INDIVIDUAL_RUN_GT_PERCENT_UNIQUE);\n    }\n\n    /**\n     * Given a number of min/max ranges\n     * for each min/max range, call numberBetween with min/max 'n' times\n     * calculate the uniqueness for that given min/max range.\n     * For all 'uniqueness' values\n     * verify the percentage of 'uniqueness' ratios over 80% is 90%.\n     * <p>\n     * This isn't perfect, but it ensures a pretty good degree of uniqueness in the random number generation.\n     */\n    @Test\n    void numberBetweenIntIntRandomizationQuality() {\n        Function<Pair<Long, Long>, Double> minMaxRangeToUniquePercentageFunction = minMax -> {\n            final int min = minMax.getLeft().intValue();\n            final int max = minMax.getRight().intValue();\n            long numbersToGet = calculateNumbersToGet(min, max);\n\n            return uniquePercentageOfResults(numbersToGet, () -> faker.number().numberBetween(min, max));\n        };\n\n        final double percentGreaterThan80Percent = randomizationQualityTest(minMaxRangeToUniquePercentageFunction);\n        assertThat(percentGreaterThan80Percent).isGreaterThanOrEqualTo(percentRunsGtUniquePercentage);\n\n        // this covers Issue # 121, the number of times the function is called with the MIN/MAX values here\n        // is RANDOMIZATION_TESTS_MAX_NUMBERS_TO_GET\n        final double extremeRunUniquePercent = minMaxRangeToUniquePercentageFunction.apply(Pair.of((long) Integer.MIN_VALUE, (long) Integer.MAX_VALUE));\n        assertThat(extremeRunUniquePercent).isGreaterThanOrEqualTo(INDIVIDUAL_RUN_GT_PERCENT_UNIQUE);\n    }\n\n    /**\n     * Given a number of min/max ranges\n     * for each min/max range, call {@link net.datafaker.providers.base.Number#numberBetween(long, long)}  with min/max 'n' times\n     * calculate the uniqueness for that given min/max range.\n     * For all 'uniqueness' values\n     * verify the percentage of 'uniqueness' ratios over 80% is 90%.\n     * <p>\n     * This isn't perfect, but it ensures a pretty good degree of uniqueness in the random number generation.\n     */\n    @Test\n    void numberBetweenLongLongRandomizationQuality() {\n        Function<Pair<Long, Long>, Double> minMaxRangeToUniquePercentageFunction = minMax -> {\n            final long min = minMax.getLeft(), max = minMax.getRight();\n            long numbersToGet = calculateNumbersToGet(min, max);\n\n            return uniquePercentageOfResults(numbersToGet, () -> faker.number().numberBetween(min, max));\n        };\n\n        final double percentGreaterThan80Percent = randomizationQualityTest(minMaxRangeToUniquePercentageFunction);\n        assertThat(percentGreaterThan80Percent).isGreaterThanOrEqualTo(percentRunsGtUniquePercentage);\n\n        // this covers Issue # 121, the number of times the function is called with the MIN/MAX values here\n        // is RANDOMIZATION_TESTS_MAX_NUMBERS_TO_GET.\n        final double extremeRunUniquePercent = minMaxRangeToUniquePercentageFunction.apply(Pair.of(Long.MIN_VALUE, Long.MAX_VALUE));\n        assertThat(extremeRunUniquePercent).isGreaterThanOrEqualTo(INDIVIDUAL_RUN_GT_PERCENT_UNIQUE);\n    }\n\n    @Test\n    void testRandomDoubleMaxEqualsMin() {\n        double actual = faker.number().randomDouble(1, 42, 42);\n\n        double expected = BigDecimal.valueOf(42).doubleValue();\n\n        assertThat(actual).isEqualTo(expected);\n    }\n\n    @Test\n    void testDigit() {\n        String digit = faker.number().digit();\n\n        assertThat(digit).matches(\"[0-9]\");\n    }\n\n    @Test\n    void testDigits() {\n        String digits = faker.number().digits(5);\n\n        assertThat(digits).matches(\"[0-9]{5}\");\n    }\n\n    /**\n     * Over the series of numbers identified from RANDOMIZATION_QUALITY_RANGE_START to\n     * RANDOMIZATION_QUALITY_RANGE_END, create a min/max range of -value/value and\n     * with of those min/max values, call <em>percentUniqueRunner</em>.\n     * <p>\n     * Collect the number of calls to <em>percentUniqueRunner</em> that were\n     * above the threshold and finally return that number divided by the total number of calls to\n     * <em>percentUniqueRunner</em>.\n     *\n     * @return percent of percentUniqueRunner's results greater than the threshold\n     */\n    private double randomizationQualityTest(final Function<Pair<Long, Long>, Double> percentUniqueRunner) {\n\n        final AtomicLong greaterThanThreshold = new AtomicLong();\n        final AtomicLong total = new AtomicLong();\n\n        for (long l = RANDOMIZATION_QUALITY_RANGE_START; l < RANDOMIZATION_QUALITY_RANGE_END; l += RANDOMIZATION_QUALITY_RANGE_STEP) {\n            final double percentUnique = percentUniqueRunner.apply(Pair.of(-l, l));\n            if (percentUnique > INDIVIDUAL_RUN_GT_PERCENT_UNIQUE) {\n                greaterThanThreshold.incrementAndGet();\n            }\n            total.incrementAndGet();\n        }\n\n        return (double) greaterThanThreshold.get() / (double) total.get();\n    }\n\n\n    /**\n     * Given a number of iterations, calls <em>callable</em> 'iterations' times and collects the results,\n     * then calculates the number of results that were unique and returns the percentage that where unique.\n     */\n    private <T> double uniquePercentageOfResults(long iterations, Supplier<T> callable) {\n            Set<T> values = new HashSet<>();\n            for (long i = 0; i < iterations; i++) {\n                values.add(callable.get());\n            }\n            return (double) values.size() / (double) iterations;\n    }\n\n    /**\n     * given a range, what is the number of values to get within that range for the randomization quality tests.\n     */\n    private long calculateNumbersToGet(long min, long max) {\n        long numbersToGet = Math.min(max / 4 - min / 4, RANDOMIZATION_TESTS_MAX_NUMBERS_TO_GET);\n        if (numbersToGet == 0) numbersToGet = RANDOMIZATION_TESTS_MAX_NUMBERS_TO_GET;\n        return numbersToGet;\n    }\n\n    @Test\n    void testIntNumberBetweenQuality() {\n        //test whether the fake number made by numberBetween(int min, int max)\n        // is not randomly and evenly distributed\n        // (The difference between the average is less than 10%)\n        Map<Integer, Integer> map = new HashMap<>();\n        Random random = new Random();\n        int testCase = 100000;\n\n        int min = Math.abs(random.nextInt());\n        int max = min + Math.max(1, Math.abs(random.nextInt(100)));\n        double mean = testCase / (double) (max - min);\n        final Number number = faker.number();\n        for (int j = 0; j < testCase; j++) {\n            int r = number.numberBetween(min, max);\n            map.merge(r, 1, Integer::sum);\n        }\n\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\n            int count = entry.getValue();\n            assertThat((mean - count) / mean).isLessThan(0.2);\n        }\n    }\n\n    @Test\n    void testLongNumberBetweenQuality() {\n        //test whether the fake number made by numberBetween(long min, long max)\n        // is not randomly and evenly distributed\n        // (The difference between the average is less than 10%)\n        Map<Long, Integer> map = new HashMap<>();\n        Random random = new Random();\n        int testCase = 100000;\n\n        long min = Math.abs(random.nextLong());\n        long max = min + Math.max(1, Math.abs(random.nextInt(200)));\n        double mean = testCase / (double) (max - min);\n        final Number number = faker.number();\n        for (int j = 0; j < testCase; j++) {\n            long r = number.numberBetween(min, max);\n            map.merge(r, 1, Integer::sum);\n        }\n\n        for (Map.Entry<Long, Integer> entry : map.entrySet()) {\n            int count = entry.getValue();\n            assertThat((mean - count) / mean).isLessThan(0.2);\n        }\n\n    }\n\n    @Test\n    void testNumberBetweenContain() {\n\n        Set<Integer> ints = new HashSet<>();\n        Set<Long> longs = new HashSet<>();\n        Random random = new Random();\n        int size = Math.abs(random.nextInt(100));\n\n        //test whether NumberBetween(int min, int max) can\n        // create all number between min and max(not included)\n        // and not use crossing the border\n        int minInt = Math.abs(random.nextInt());\n        int maxInt = minInt + size;\n        final Number number = faker.number();\n        for (int i = 0; i < 10000; ++i) {\n            int value = number.numberBetween(minInt, maxInt);\n            assertThat(value).isBetween(minInt, maxInt)\n                .isGreaterThanOrEqualTo(minInt);\n            ints.add(value);\n        }\n        assertThat(ints).hasSize(Math.max(1, size));\n\n        //test whether NumberBetween(long, long) can\n        // create all number between min and max(not included)\n        // and not use crossing the border\n        long minLong = Math.abs(random.nextLong());\n        long maxLong = minLong + size;\n        for (int i = 0; i < 10000; ++i) {\n            long value = number.numberBetween(minLong, maxLong);\n            assertThat(value).isBetween(minLong, maxLong)\n                .isGreaterThanOrEqualTo(minLong);\n            longs.add(value);\n        }\n        assertThat(longs).hasSize(Math.max(1, size));\n    }\n\n    @Test\n    void testNumberBetweenBorder() {\n\n        Random random = new Random();\n\n        //test whether NumberBetween(long, long) not use crossing the border\n        for (int i = 0; i <= 100; i++) {\n\n            //create long integer max and min\n            long size, min = 0, max = -1;\n            while (max < min) {\n                size = Math.abs(random.nextLong());\n                min = Math.abs(random.nextLong());\n                max = min + size;\n            }\n\n            final Number number = faker.number();\n            for (int j = 0; j < 100; j++) {\n                long value = number.numberBetween(min, max);\n                assertThat(value).isLessThan(max)\n                    .isGreaterThanOrEqualTo(min);\n            }\n        }\n    }\n\n    @RepeatedTest(10)\n    void testPositive() {\n        assertThat(faker.number().positive()).isGreaterThan(0);\n    }\n\n    @RepeatedTest(10)\n    void testNegative() {\n        assertThat(faker.number().negative()).isLessThan(0);\n\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final int RANDOMIZATION_QUALITY_RANGE_END = 1000;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "RANDOMIZATION_QUALITY_RANGE_END = 1000", "syntax_pass": true}, {"attribute_expression": "public static final int RANDOMIZATION_QUALITY_RANGE_STEP = 25;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "RANDOMIZATION_QUALITY_RANGE_STEP = 25", "syntax_pass": true}, {"attribute_expression": "private static final int RANDOMIZATION_QUALITY_RANGE_START = RANDOMIZATION_QUALITY_RANGE_STEP;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "RANDOMIZATION_QUALITY_RANGE_START = RANDOMIZATION_QUALITY_RANGE_STEP", "syntax_pass": true}, {"attribute_expression": "public static final int RANDOMIZATION_TESTS_MAX_NUMBERS_TO_GET = 1000;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "RANDOMIZATION_TESTS_MAX_NUMBERS_TO_GET = 1000", "syntax_pass": true}, {"attribute_expression": "private static final double INDIVIDUAL_RUN_GT_PERCENT_UNIQUE = 0.8;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "double", "name": "INDIVIDUAL_RUN_GT_PERCENT_UNIQUE = 0.8", "syntax_pass": true}, {"attribute_expression": "final double percentRunsGtUniquePercentage = 0.90;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "double", "name": "percentRunsGtUniquePercentage = 0.90", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/VerbTest.java.VerbTest", "name": "VerbTest", "file_path": "src/test/java/net/datafaker/providers/base/VerbTest.java", "superclasses": "", "methods": ["[void]testBase()", "[void]testPast()", "[void]testPastParticiple()", "[void]testSimplePresent()", "[void]testIngForm()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class VerbTest extends BaseFakerTest<BaseFaker> {\n\n    public static final String WORDS = \"[\\\\w-]+\";\n\n    @RepeatedTest(10)\n    void testBase() {\n        assertThat(faker.verb().base()).matches(WORDS);\n    }\n\n    @RepeatedTest(10)\n    void testPast() {\n        assertThat(faker.verb().past()).matches(WORDS);\n    }\n\n    @RepeatedTest(10)\n    void testPastParticiple() {\n        assertThat(faker.verb().pastParticiple()).matches(WORDS);\n    }\n\n    @RepeatedTest(10)\n    void testSimplePresent() {\n        assertThat(faker.verb().simplePresent()).matches(WORDS);\n    }\n\n    @RepeatedTest(10)\n    void testIngForm() {\n        assertThat(faker.verb().ingForm()).matches(WORDS);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final String WORDS = \"[\\\\w-]+\";", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "String", "name": "WORDS = \"[\\\\w-]+\"", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/DroneTest.java.DroneTest", "name": "DroneTest", "file_path": "src/test/java/net/datafaker/providers/base/DroneTest.java", "superclasses": "", "methods": ["[void]weight()", "[void]maxAscentSpeed()", "[void]maxDescentSpeed()", "[void]flightTime()", "[void]maxAltitude()", "[void]maxFlightDistance()", "[void]maxSpeed()", "[void]maxWindResistance()", "[void]maxAngularVelocity()", "[void]maxTiltAngle()", "[void]operatingTemperature()", "[void]batteryCapacity()", "[void]batteryVoltage()", "[void]batteryWeight()", "[void]chargingTemperature()", "[void]maxChargingPower()", "[void]maxResolution()"], "method_uris": ["src/test/java/net/datafaker/providers/base/DroneTest.java.DroneTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class DroneTest extends BaseFakerTest<BaseFaker> {\n\n    private final Drone drone = faker.drone();\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(drone::name, \"drone.name\"),\n                TestSpec.of(drone::batteryType, \"drone.battery_type\"),\n                TestSpec.of(drone::iso, \"drone.iso\"),\n                TestSpec.of(drone::photoFormat, \"drone.photo_format\"),\n                TestSpec.of(drone::videoFormat, \"drone.video_format\"),\n                TestSpec.of(drone::maxShutterSpeed, \"drone.max_shutter_speed\"),\n                TestSpec.of(drone::minShutterSpeed, \"drone.min_shutter_speed\"),\n                TestSpec.of(drone::shutterSpeedUnits, \"drone.shutter_speed_units\"));\n    }\n\n    @Test\n    void weight() {\n        assertThat(drone.weight()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void maxAscentSpeed() {\n        assertThat(drone.maxAscentSpeed()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void maxDescentSpeed() {\n        assertThat(drone.maxDescentSpeed()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void flightTime() {\n        assertThat(drone.flightTime()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void maxAltitude() {\n        assertThat(drone.maxAltitude()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void maxFlightDistance() {\n        assertThat(drone.maxFlightDistance()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void maxSpeed() {\n        assertThat(drone.maxSpeed()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void maxWindResistance() {\n        assertThat(drone.maxWindResistance()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void maxAngularVelocity() {\n        assertThat(drone.maxAngularVelocity()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void maxTiltAngle() {\n        assertThat(drone.maxTiltAngle()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void operatingTemperature() {\n        assertThat(drone.operatingTemperature()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void batteryCapacity() {\n        assertThat(drone.batteryCapacity()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void batteryVoltage() {\n        assertThat(drone.batteryVoltage()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void batteryWeight() {\n        assertThat(drone.batteryWeight()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void chargingTemperature() {\n        assertThat(drone.chargingTemperature()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void maxChargingPower() {\n        assertThat(drone.maxChargingPower()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n    @Test\n    void maxResolution() {\n        assertThat(drone.maxResolution()).isNotEmpty().doesNotContain(\"#\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Drone drone = faker.drone();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Drone", "name": "drone = faker.drone()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/InternetPasswordTest.java.InternetPasswordTest", "name": "InternetPasswordTest", "file_path": "src/test/java/net/datafaker/providers/base/InternetPasswordTest.java", "superclasses": "", "methods": ["[void]testPassword1000()", "[void]passwordSpecial()", "[void]passwordMix()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class InternetPasswordTest extends BaseFakerTest<BaseFaker> {\n\n    @Test\n    void testPassword1000() {\n        final Pattern specialCharacterPattern = Pattern.compile(\"[^a-zA-Z0-9]\");\n        final Pattern digitPattern = Pattern.compile(\"[0-9]\");\n        for (int i = 0; i < 1000; i++) {\n            String password = faker.internet().password(8, 16, true, true, true);\n            Matcher specialCharacterMatcher = specialCharacterPattern.matcher(password);\n            Matcher digitMatcher = digitPattern.matcher(password);\n\n            boolean isPasswordContainsSpecialCharacter = specialCharacterMatcher.find();\n            boolean isPasswordContainsDigit = digitMatcher.find();\n\n            assertThat(isPasswordContainsDigit).isTrue();\n            assertThat(isPasswordContainsSpecialCharacter).isTrue();\n        }\n    }\n\n    @Test\n    void passwordSpecial() {\n        boolean check = true;\n        for (int i = 0; i < 10; i++) {\n            String password = faker.internet().password(8, 16, true, true, true);\n            Pattern specialCharacterPattern = Pattern.compile(\"[^a-zA-Z0-9]\");\n            Matcher specialCharacterMatcher = specialCharacterPattern.matcher(password);\n            if (!specialCharacterMatcher.find()) {\n                check = false;\n                break;\n            }\n\n        }\n        assertThat(check).isTrue();\n    }\n\n    @Test\n    void passwordMix() {\n        boolean check = true;\n        for (int i = 0; i < 10; i++) {\n            String password = faker.internet().password(8, 16, true, true, true);\n            Pattern specialCharacterPattern = Pattern.compile(\"[^a-zA-Z0-9]\");\n            Matcher specialCharacterMatcher = specialCharacterPattern.matcher(password);\n            Pattern digitPattern = Pattern.compile(\"[0-9]\");\n            Matcher digitMatcher = digitPattern.matcher(password);\n            if (!specialCharacterMatcher.find()) {\n                check = false;\n                break;\n            }\n            if (!digitMatcher.find()) {\n                check = false;\n                break;\n            }\n        }\n        assertThat(check).isTrue();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/ImageTest.java.ImageTest", "name": "ImageTest", "file_path": "src/test/java/net/datafaker/providers/base/ImageTest.java", "superclasses": "", "methods": ["[void]bmp()", "[void]gif()", "[void]png()", "[void]jpg()", "[void]jpeg()", "[void]svg()", "[void]tiff()", "[void]base64(ImageType)", "[void]defaultBuilder()", "[void]customBase64builder()", "[void]tinyBase64builder()", "[void]largeBase64builder()", "[void]shouldErrorOnIllegalType()", "[void]shouldErrorOnNegativeWidth()", "[void]shouldErrorOnZeroWidth()", "[void]shouldErrorOnNegativeHeight()", "[void]shouldErrorOnZeroHeight()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ImageTest extends BaseFakerTest<BaseFaker> {\n\n    @Test\n    void bmp() {\n        assertThat(faker.image().base64BMP()).startsWith(\"data:image/bmp;base64,\");\n    }\n\n    @Test\n    void gif() {\n        assertThat(faker.image().base64GIF()).startsWith(\"data:image/gif;base64,\");\n    }\n\n    @Test\n    void png() {\n        assertThat(faker.image().base64PNG()).startsWith(\"data:image/png;base64,\");\n    }\n\n    @Test\n    void jpg() {\n        assertThat(faker.image().base64JPG()).startsWith(\"data:image/jpeg;base64,\");\n    }\n\n    @Test\n    void jpeg() {\n        assertThat(faker.image().base64JPEG()).startsWith(\"data:image/jpeg;base64,\");\n    }\n\n    @Test\n    void svg() {\n        assertThat(faker.image().base64SVG()).startsWith(\"data:image/svg+xml;base64,\");\n    }\n\n    @Test\n    void tiff() {\n        assertThat(faker.image().base64TIFF()).startsWith(\"data:image/tiff;base64,\");\n    }\n\n    @ParameterizedTest\n    @EnumSource(ImageType.class)\n    void base64(ImageType imageType) {\n        String base64Image = faker.image().base64(new Image.Base64ImageRuleConfig(imageType, 1000, 1000));\n\n        assertThat(base64Image)\n            .startsWith(\"data:\" + imageType.getMimeType() + \";base64,\");\n        assertThat(base64Image.substring(base64Image.indexOf(\",\") + 1))\n            .isNotBlank()\n            .isBase64();\n    }\n\n    @Test\n    void defaultBuilder() {\n        String image = faker.image().base64(Image.ImageBuilder.builder()\n            .build());\n        assertThat(image).startsWith(\"data:image/\");\n    }\n\n    @Test\n    void customBase64builder() {\n        String gif = faker.image().base64(Image.ImageBuilder.builder()\n            .type(ImageType.GIF)\n            .build());\n        assertThat(gif).startsWith(\"data:image/gif;base64,\");\n    }\n\n    @Test\n    void tinyBase64builder() {\n        String tiny = faker.image().base64(Image.ImageBuilder.builder()\n            .height(1)\n            .width(1)\n            .type(ImageType.PNG)\n            .build());\n\n        assertThat(tiny).startsWith(\"data:image/png;base64,\");\n    }\n\n    @Test\n    void largeBase64builder() {\n        String large = faker.image().base64(Image.ImageBuilder.builder()\n            .height(1000)\n            .width(2000)\n            .type(ImageType.BMP)\n            .build());\n        assertThat(large).startsWith(\"data:image/bmp;base64,\");\n    }\n\n    @Test\n    void shouldErrorOnIllegalType() {\n        assertThatIllegalArgumentException().isThrownBy(() -> Image.ImageBuilder.builder().type(null).build());\n    }\n\n    @Test\n    void shouldErrorOnNegativeWidth() {\n        assertThatIllegalArgumentException().isThrownBy(() -> Image.ImageBuilder.builder().width(-1).build());\n    }\n\n    @Test\n    void shouldErrorOnZeroWidth() {\n        assertThatIllegalArgumentException().isThrownBy(() -> Image.ImageBuilder.builder().width(0).build());\n    }\n\n    @Test\n    void shouldErrorOnNegativeHeight() {\n        assertThatIllegalArgumentException().isThrownBy(() -> Image.ImageBuilder.builder().height(-1).build());\n    }\n\n    @Test\n    void shouldErrorOnZeroHeight() {\n        assertThatIllegalArgumentException().isThrownBy(() -> Image.ImageBuilder.builder().height(0).build());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/ScienceTest.java.ScienceTest", "name": "ScienceTest", "file_path": "src/test/java/net/datafaker/providers/base/ScienceTest.java", "superclasses": "", "methods": ["[void]element()", "[void]elementSymbol()", "[void]scientist()", "[void]tool()", "[void]quark()", "[void]leptons()", "[void]bosons()"], "method_uris": ["src/test/java/net/datafaker/providers/base/ScienceTest.java.ScienceTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ScienceTest extends BaseFakerTest<BaseFaker> {\n\n    Science science = faker.science();\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(science::unit, \"science.unit\"));\n    }\n\n    @RepeatedTest(10)\n    void element() {\n        assertThat(science.element()).matches(\"[A-Za-z ]+\");\n    }\n\n    @RepeatedTest(10)\n    void elementSymbol() {\n        assertThat(science.elementSymbol()).matches(\"[A-Za-z]{1,2}\");\n    }\n\n    @RepeatedTest(10)\n    void scientist() {\n        assertThat(science.scientist()).matches(\"[A-Za-z. -]+\");\n    }\n\n    @RepeatedTest(10)\n    void tool() {\n        assertThat(science.tool()).matches(\"[0-9A-Za-z. -]+\");\n    }\n\n    @RepeatedTest(10)\n    void quark() {\n        assertThat(science.quark()).matches(\"[A-Za-z]+\");\n    }\n\n    @RepeatedTest(10)\n    void leptons() {\n        assertThat(science.leptons()).matches(\"[A-Za-z ]+\");\n    }\n\n    @RepeatedTest(10)\n    void bosons() {\n        assertThat(science.bosons()).matches(\"[A-Za-z ]+\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "Science science = faker.science();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Science", "name": "science = faker.science()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/Internet_getIpV6AddressTest.java.Internet_getIpV6AddressTest", "name": "Internet_getIpV6AddressTest", "file_path": "src/test/java/net/datafaker/providers/base/Internet_getIpV6AddressTest.java", "superclasses": "", "methods": ["[void]testGetIpV6Address()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Internet_getIpV6AddressTest {\n\n    @Test\n    public void testGetIpV6Address() throws UnknownHostException {\n        // Given\n        Internet internet = new Internet(mock(BaseProviders.class));\n        RandomService randomService = mock(RandomService.class);\n        when(internet.faker.random()).thenReturn(randomService);\n        when(randomService.hex(4, false)).thenReturn(\"abcd\", \"ef01\", \"2345\", \"6789\", \"abcd\", \"ef01\", \"2345\", \"6789\");\n\n        // When\n        InetAddress result = internet.getIpV6Address();\n\n        // Then\n        assertEquals(\"abcd:ef01:2345:6789:abcd:ef01:2345:6789\", result.getHostAddress());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/LocalityTest.java.LocalityTest", "name": "LocalityTest", "file_path": "src/test/java/net/datafaker/providers/base/LocalityTest.java", "superclasses": "", "methods": ["[void]allSupportedLocales()", "[void]displayName()", "[void]localeStringRandom()", "[void]localeStringWithRandom()", "[void]localeStringWithoutReplacement()", "[void]localeString()", "[void]localeWithoutReplacement()"], "method_uris": ["src/test/java/net/datafaker/providers/base/LocalityTest.java.LocalityTest.[List<String>]findAllSupportedLocales(File)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class LocalityTest extends BaseFakerTest<BaseFaker> {\n    private final BaseFaker f = new Faker();\n    private final Locality locality = f.locality();\n\n    /**\n     * Test to check that list of all locales support is loaded\n     */\n    @Test\n    void allSupportedLocales() {\n        // Check that directory of locale resources exists\n        File resourceDirectory = new File(\"./src/main/resources\");\n        assertThat(resourceDirectory).exists();\n\n        List<String> allLocales = locality.allSupportedLocales();\n        assertThat(allLocales).hasSize(87);\n        assertThat(allLocales)\n            .as(\"Somebody forgot to add the new locale to Locality.LOCALES\")\n            .containsExactlyInAnyOrderElementsOf(findAllSupportedLocales(resourceDirectory));\n    }\n\n    @Test\n    void displayName() {\n        assertThat(f.locality().displayName()).isNotEmpty();\n    }\n\n    /**\n     * Test to check Locality's localeStringWithRandom method is using the random number generator\n     * passed as an argument. This is checked with a Random object that has a fixed seed and\n     * should have deterministic results.\n     */\n    @Test\n    void localeStringRandom() {\n        // Check that we get the same locale when using pseudorandom number generator with a fixed seed\n        final long fixedSeed = 5;\n\n        Random random1 = new Random(fixedSeed);\n        String randomLocale1 = locality.localeStringWithRandom(random1);\n\n        Random random2 = new Random(fixedSeed);\n        String randomLocale2 = locality.localeStringWithRandom(random2);\n\n        assertThat(randomLocale1).isEqualTo(randomLocale2);\n    }\n\n    /**\n     * Test to check Locality's localeStringWithRandom method. It verifies that the randomly selected\n     * locale is within the set of all supported locales\n     */\n    @RepeatedTest(100)\n    void localeStringWithRandom() {\n        Random random = new Random();\n        String randomLocale = locality.localeStringWithRandom(random);\n        assertThat(locality.allSupportedLocales()).contains(randomLocale);\n    }\n\n    @Test\n    void localeStringWithoutReplacement() {\n        Random random = new Random();\n        // loop through all supported locales\n        for (int i = 0; i < 2; i++) {\n            Set<String> returnedLocales = IntStream.range(0, locality.allSupportedLocales().size())\n                .mapToObj(j -> locality.localeStringWithoutReplacement(random))\n                .collect(Collectors.toSet());\n\n            assertThat(locality.allSupportedLocales()).containsAll(returnedLocales);\n        }\n    }\n\n    @Test\n    void localeString() {\n        assertThat(locality.allSupportedLocales()).contains(locality.localeString());\n    }\n\n    @Test\n    void localeWithoutReplacement() {\n        assertThat(locality.localeStringWithoutReplacement()).isNotNull();\n    }\n\n    private List<String> findAllSupportedLocales(File resourceDirectory) {\n        File[] localeFiles = resourceDirectory.listFiles((dir, name) -> name.endsWith(\".yml\"));\n        assert localeFiles != null;\n        return Stream.of(localeFiles)\n            .peek(f -> assertThat(f).isFile())\n            .peek(f -> assertThat(f).isReadable())\n            .map(f -> f.getName().toLowerCase(ROOT).replace(\".yml\", \"\"))\n            .toList();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final BaseFaker f = new Faker();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BaseFaker", "name": "f = new Faker()", "syntax_pass": true}, {"attribute_expression": "private final Locality locality = f.locality();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Locality", "name": "locality = f.locality()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/BoolTest.java.BoolTest", "name": "BoolTest", "file_path": "src/test/java/net/datafaker/providers/base/BoolTest.java", "superclasses": "", "methods": ["[void]testBool()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class BoolTest extends BaseFakerTest<BaseFaker> {\n\n    @RepeatedTest(100)\n    void testBool() {\n        assertThat(faker.bool().bool()).isIn(true, false);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/CPFTest.java.CPFTest", "name": "CPFTest", "file_path": "src/test/java/net/datafaker/providers/base/CPFTest.java", "superclasses": "", "methods": ["[void]isValidCPF()", "[void]isInvalidCPF()", "[void]formattedCPF()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class CPFTest extends BaseFakerTest<BaseFaker> {\n\n    public static final Pattern CPF_EXPRESSION = Pattern.compile(\"(^\\\\d{3}\\\\x2E\\\\d{3}\\\\x2E\\\\d{3}\\\\x2D\\\\d{2}$)\");\n\n    /**\n     * A valid CPF is either a real number or a generated valid number.\n     */\n    @RepeatedTest(100)\n    void isValidCPF() {\n        assertThat(isCPFValid(faker.cpf().valid())).isTrue();\n    }\n\n    /**\n     * A invalid CPF is that dos not meet the requirements of the algorithm\n     */\n    @RepeatedTest(100)\n    void isInvalidCPF() {\n        assertThat(isCPFValid(faker.cpf().invalid())).isFalse();\n    }\n\n    /**\n     * CPF has a main format. This test validate if the number is on the correct format\n     * Eg: 111.111.111-11\n     */\n    @RepeatedTest(100)\n    void formattedCPF() {\n        assertThat(faker.cpf().valid()).matches(CPF_EXPRESSION);\n        assertThat(faker.cpf().valid(true)).matches(CPF_EXPRESSION);\n        assertThat(faker.cpf().invalid()).matches(CPF_EXPRESSION);\n        assertThat(faker.cpf().invalid(true)).matches(CPF_EXPRESSION);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final Pattern CPF_EXPRESSION = Pattern.compile(\"(^\\\\d{3}\\\\x2E\\\\d{3}\\\\x2E\\\\d{3}\\\\x2D\\\\d{2}$)\");", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "Pattern", "name": "CPF_EXPRESSION = Pattern.compile(\"(^\\\\d{3}\\\\x2E\\\\d{3}\\\\x2E\\\\d{3}\\\\x2D\\\\d{2}$)\")", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/Internet_getPublicIpV4AddressTest.java.Internet_getPublicIpV4AddressTest", "name": "Internet_getPublicIpV4AddressTest", "file_path": "src/test/java/net/datafaker/providers/base/Internet_getPublicIpV4AddressTest.java", "superclasses": "", "methods": ["[void]testGetPublicIpV4Address()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Internet_getPublicIpV4AddressTest {\n\n    @Test\n    public void testGetPublicIpV4Address() {\n        // Given\n        Internet internet = new Internet(mock(BaseProviders.class));\n        RandomService randomService = mock(RandomService.class);\n        when(internet.faker.random()).thenReturn(randomService);\n\n        // When\n        when(randomService.nextInt(256)).thenReturn(1, 2, 3, 4); // First call returns 1, second returns 2, etc.\n        when(randomService.nextInt(256)).thenReturn(5, 6, 7, 8); // Second iteration returns 5, 6, 7, 8\n\n        InetAddress result = internet.getPublicIpV4Address();\n\n        // Then\n        assertNotNull(result);\n        assertTrue(Arrays.binarySearch(new byte[]{10, 127, (byte) 169, (byte) 192, (byte) 172}, (byte) 5) < 0); // Ensure first octet is not private\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/RelationshipTest.java.RelationshipTest", "name": "RelationshipTest", "file_path": "src/test/java/net/datafaker/providers/base/RelationshipTest.java", "superclasses": "", "methods": ["[void]anyTest()", "[void]anyWithIllegalArgumentExceptionThrown()", "[void]anyWithInvocationTargetExceptionThrown()"], "method_uris": ["src/test/java/net/datafaker/providers/base/RelationshipTest.java.RelationshipTest.[void]beforeEach()", "src/test/java/net/datafaker/providers/base/RelationshipTest.java.RelationshipTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class RelationshipTest extends BaseFakerTest<BaseFaker> {\n\n    private final BaseFaker mockFaker = spy(new BaseFaker());\n    private final FakeValuesService fakeValuesService = mock();\n    private final Relationship relationship = new Relationship(mockFaker);\n\n    @BeforeEach\n    final void beforeEach() {\n        reset(mockFaker, fakeValuesService);\n    }\n\n    @RepeatedTest(100)\n    void anyTest() {\n        assertThat(relationship.any()).isNotEmpty();\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(relationship::direct, \"relationship.familial.direct\"),\n                TestSpec.of(relationship::extended, \"relationship.familial.extended\"),\n                TestSpec.of(relationship::inLaw, \"relationship.in_law\"),\n                TestSpec.of(relationship::spouse, \"relationship.spouse\"),\n                TestSpec.of(relationship::parent, \"relationship.parent\"),\n                TestSpec.of(relationship::sibling, \"relationship.sibling\"));\n    }\n\n    @Test\n    void anyWithIllegalArgumentExceptionThrown() {\n        when(mockFaker.fakeValuesService()).thenReturn(fakeValuesService);\n        when(fakeValuesService.resolve(any(), any(), any())).thenThrow(new IllegalArgumentException(\"Oops\"));\n\n        assertThatThrownBy(() -> relationship.any())\n            .isInstanceOf(IllegalArgumentException.class)\n            .hasMessage(\"Oops\");\n    }\n\n    @Test\n    void anyWithInvocationTargetExceptionThrown() {\n        when(mockFaker.fakeValuesService()).thenReturn(fakeValuesService);\n        when(fakeValuesService.resolve(any(), any(), any())).thenThrow(new NullPointerException(\"Oops\"));\n\n        assertThatThrownBy(() -> relationship.any())\n            .isInstanceOf(NullPointerException.class)\n            .hasMessage(\"Oops\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final BaseFaker mockFaker = spy(new BaseFaker());", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BaseFaker", "name": "mockFaker = spy(new BaseFaker())", "syntax_pass": true}, {"attribute_expression": "private final FakeValuesService fakeValuesService = mock();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "FakeValuesService", "name": "fakeValuesService = mock()", "syntax_pass": true}, {"attribute_expression": "private final Relationship relationship = new Relationship(mockFaker);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Relationship", "name": "relationship = new Relationship(mockFaker)", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/RandomFakerTest.java.RandomFakerTest", "name": "RandomFakerTest", "file_path": "src/test/java/net/datafaker/providers/base/RandomFakerTest.java", "superclasses": "", "methods": ["[void]testNumerifyRandomnessCanBeControlled()", "[void]testLetterifyRandomnessCanBeControlled()", "[void]testNameRandomnessCanBeControlled()", "[void]testEmailRandomnessCanBeControlled()"], "method_uris": ["src/test/java/net/datafaker/providers/base/RandomFakerTest.java.RandomFakerTest.[void]before()", "src/test/java/net/datafaker/providers/base/RandomFakerTest.java.RandomFakerTest.[void]resetRandomSeed()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class RandomFakerTest extends BaseFakerTest<BaseFaker> {\n\n    private static final int CONSTANT_SEED_VALUE = 10;\n    private BaseFaker faker;\n    private Random random;\n\n    @BeforeEach\n    final void before() {\n        random = new Random();\n        faker = new BaseFaker(random);\n    }\n\n    @Test\n    void testNumerifyRandomnessCanBeControlled() {\n        resetRandomSeed();\n        final String firstInvocation = faker.numerify(\"###\");\n\n        resetRandomSeed();\n        final String secondInvocation = faker.numerify(\"###\");\n        assertThat(firstInvocation).isEqualTo(secondInvocation);\n    }\n\n    @Test\n    void testLetterifyRandomnessCanBeControlled() {\n        resetRandomSeed();\n        final String firstInvocation = faker.letterify(\"???\");\n\n        resetRandomSeed();\n        final String secondInvocation = faker.letterify(\"???\");\n        assertThat(firstInvocation).isEqualTo(secondInvocation);\n    }\n\n    @Test\n    void testNameRandomnessCanBeControlled() {\n        resetRandomSeed();\n        final String firstInvocation = faker.name().name();\n\n        resetRandomSeed();\n        final String secondInvocation = faker.name().name();\n        assertThat(firstInvocation).isEqualTo(secondInvocation);\n    }\n\n    @Test\n    void testEmailRandomnessCanBeControlled() {\n        resetRandomSeed();\n        final String firstInvocation = faker.internet().emailAddress();\n\n        resetRandomSeed();\n        final String secondInvocation = faker.internet().emailAddress();\n        assertThat(firstInvocation).isEqualTo(secondInvocation);\n    }\n\n    private void resetRandomSeed() {\n        random.setSeed(CONSTANT_SEED_VALUE);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final int CONSTANT_SEED_VALUE = 10;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "CONSTANT_SEED_VALUE = 10", "syntax_pass": true}, {"attribute_expression": "private BaseFaker faker;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BaseFaker", "name": "faker", "syntax_pass": true}, {"attribute_expression": "private Random random;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Random", "name": "random", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/SlackEmojiTest.java.SlackEmojiTest", "name": "SlackEmojiTest", "file_path": "src/test/java/net/datafaker/providers/base/SlackEmojiTest.java", "superclasses": "", "methods": ["[void]people()", "[void]nature()", "[void]food_and_drink()", "[void]celebration()", "[void]activity()", "[void]travel_and_places()", "[void]objects_and_symbols()", "[void]custom()", "[void]emoji()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class SlackEmojiTest extends BaseFakerTest<BaseFaker> {\n\n    private static final String EMOTICON_REGEX = \":(?:[\\\\w-]+):\";\n    private final SlackEmoji slackEmoji = faker.slackEmoji();\n\n    @Test\n    void people() {\n        assertThat(slackEmoji.people()).matches(EMOTICON_REGEX);\n    }\n\n    @Test\n    void nature() {\n        assertThat(slackEmoji.nature()).matches(EMOTICON_REGEX);\n    }\n\n    @Test\n    void food_and_drink() {\n        assertThat(slackEmoji.foodAndDrink()).matches(EMOTICON_REGEX);\n    }\n\n    @Test\n    void celebration() {\n        assertThat(slackEmoji.celebration()).matches(EMOTICON_REGEX);\n    }\n\n    @Test\n    void activity() {\n        assertThat(slackEmoji.activity()).matches(EMOTICON_REGEX);\n    }\n\n    @Test\n    void travel_and_places() {\n        assertThat(slackEmoji.travelAndPlaces()).matches(EMOTICON_REGEX);\n    }\n\n    @Test\n    void objects_and_symbols() {\n        assertThat(slackEmoji.objectsAndSymbols()).matches(EMOTICON_REGEX);\n    }\n\n    @Test\n    void custom() {\n        assertThat(slackEmoji.custom()).matches(EMOTICON_REGEX);\n    }\n\n    @Test\n    void emoji() {\n        assertThat(slackEmoji.emoji()).matches(EMOTICON_REGEX);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String EMOTICON_REGEX = \":(?:[\\\\w-]+):\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "EMOTICON_REGEX = \":(?:[\\\\w-]+):\"", "syntax_pass": true}, {"attribute_expression": "private final SlackEmoji slackEmoji = faker.slackEmoji();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "SlackEmoji", "name": "slackEmoji = faker.slackEmoji()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/ComputerTest.java.ComputerTest", "name": "ComputerTest", "file_path": "src/test/java/net/datafaker/providers/base/ComputerTest.java", "superclasses": "", "methods": ["[void]testOperatingSystem()"], "method_uris": ["src/test/java/net/datafaker/providers/base/ComputerTest.java.ComputerTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ComputerTest extends BaseFakerTest<BaseFaker> {\n\n    Computer computer = faker.computer();\n\n    @Test\n    void testOperatingSystem() {\n        assertThat(computer.operatingSystem()).isNotEmpty();\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(computer::type, \"computer.type\"),\n                TestSpec.of(computer::platform, \"computer.platform\"),\n                TestSpec.of(computer::linux, \"computer.os.linux\"),\n                TestSpec.of(computer::macos, \"computer.os.macos\"),\n                TestSpec.of(computer::windows, \"computer.os.windows\"),\n                TestSpec.of(computer::brand, \"computer.brand\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "Computer computer = faker.computer();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Computer", "name": "computer = faker.computer()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/Number_randomDoubleTest.java.Number_randomDoubleTest", "name": "Number_randomDoubleTest", "file_path": "src/test/java/net/datafaker/providers/base/Number_randomDoubleTest.java", "superclasses": "", "methods": ["[void]testRandomDouble()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Number_randomDoubleTest {\n\n    @Test\n    public void testRandomDouble() {\n        // Given\n        BaseProviders faker = mock(BaseProviders.class);\n        RandomService randomService = mock(RandomService.class);\n        when(faker.random()).thenReturn(randomService);\n        when(randomService.nextDouble()).thenReturn(0.5);\n\n        Number number = new Number(faker);\n\n        // When\n        double result = number.randomDouble(2, 10, 20);\n\n        // Then\n        BigDecimal expected = new BigDecimal(15).setScale(2, RoundingMode.HALF_DOWN);\n        assertEquals(expected.doubleValue(), result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/AddressTest.java.AddressTest", "name": "AddressTest", "file_path": "src/test/java/net/datafaker/providers/base/AddressTest.java", "superclasses": "", "methods": ["[void]testLatinStreetName()", "[void]testCyrillicStreetName(String)", "[void]testStreetAddressStartsWithNumber()", "[void]testStreetAddressIsANumber()", "[void]testLatitude()", "[void]testLongitude()", "[void]testLocaleLatitude()", "[void]testLocaleLongitude()", "[void]testTimeZone()", "[void]testState()", "[void]testCity()", "[void]testCityName()", "[void]testCountry()", "[void]testCountryCode()", "[void]testStreetAddressIncludeSecondary()", "[void]testCityWithLocaleFranceAndSeed()", "[void]testFullAddress()", "[void]fullAddress_estonia()", "[void]testZipCodeByState()", "[void]testHungarianZipCodeByState()", "[void]testCountyByZipCode()", "[void]testCountyForWrongZipCode(String)", "[void]testStreetPrefix()", "[void]testStreetSuffix()", "[void]testCityPrefix()", "[void]testCitySuffix()", "[void]testMailbox()", "[void]testZipIsFiveChars()", "[void]testZipPlus4IsTenChars()", "[void]testZipPlus4IsNineDigits()", "[void]testLatLonEnUs()", "[void]testLatLonNl()", "[void]testLonLatEnUs()", "[void]testLonLatNl()", "[void]testLonLatRU()", "[void]testLatLonRU()", "[void]cyrillicStreetName(String)", "[void]dutchAddress()", "[void]belgianSAddress()", "[void]belgianZipcode()", "[void]australiaAddress()", "[void]testCityCnSuffix()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class AddressTest extends BaseFakerTest<BaseFaker> {\n\n    private final char decimalSeparator = new DecimalFormatSymbols(getFaker().getContext().getLocale()).getDecimalSeparator();\n    private static final Faker US_FAKER = new Faker(new Locale(\"en\", \"US\"));\n    private static final Faker NL_FAKER = new Faker(new Locale(\"nl\", \"NL\"));\n    private static final Faker BELGIAN_FAKER = new Faker(new Locale(\"nl\", \"BE\"));\n    private static final Faker RU_FAKER = new Faker(new Locale(\"ru\", \"RU\"));\n    private static final Faker AU_FAKER = new Faker(new Locale(\"en\", \"AU\"));\n    private static final Pattern CYRILLIC_LETTERS = Pattern.compile(\".*[\u0430-\u044f\u0410-\u042f].*\");\n\n    private static final Condition<String> IS_A_NUMBER = new Condition<>(s -> {\n        try {\n            Double.valueOf(s);\n        } catch (NumberFormatException ignore) {\n            return false;\n        }\n        return true;\n    }, \"Is a number\");\n\n    private static final BiFunction<String, String, Pattern> BI_LAT_LON_REGEX =\n        (decimalDelimiter, delimiter) ->\n            Pattern.compile(\"-?\\\\d{1,2}\" + decimalDelimiter + \"\\\\d{5,10}\" + delimiter + \"-?\\\\d{1,3}\" + decimalDelimiter + \"\\\\d{5,10}+\");\n\n    private static final BiFunction<String, String, Pattern> BI_LON_LAT_REGEX =\n        (decimalDelimiter, delimiter) ->\n            Pattern.compile(\"-?\\\\d{1,3}\" + decimalDelimiter + \"\\\\d{5,10}+\" + delimiter + \"-?\\\\d{1,2}\" + decimalDelimiter + \"\\\\d{5,10}\");\n\n    private final static Function<Locale, String> ESCAPED_DECIMAL_SEPARATOR = t -> \"\\\\\" + new DecimalFormatSymbols(t).getDecimalSeparator();\n\n    @ParameterizedTest\n    @ValueSource(strings = {\"en\", \"id\", \"ca\", \"cs\"})\n    void testLatinStreetName() {\n        final BaseFaker faker = new BaseFaker();\n        assertThat(faker.address().streetName()).isNotEmpty().doesNotMatch(CYRILLIC_LETTERS);\n    }\n\n    @ParameterizedTest\n    @ValueSource(strings = {\"be\", \"bg\", \"by\", \"mk\", \"ru\", \"ru_MD\", \"uk\"})\n    void testCyrillicStreetName(String cyrillicLocale) {\n        final BaseFaker localFaker = new BaseFaker(new Locale(cyrillicLocale));\n        assertThat(localFaker.address().streetName()).isNotEmpty().matches(CYRILLIC_LETTERS);\n    }\n\n    @Test\n    void testStreetAddressStartsWithNumber() {\n        final String streetAddressNumber = faker.address().streetAddress();\n        assertThat(streetAddressNumber).matches(\"[0-9]+ .+\");\n    }\n\n    @Test\n    void testStreetAddressIsANumber() {\n        final String streetAddressNumber = faker.address().streetAddressNumber();\n        assertThat(streetAddressNumber).matches(\"[0-9]+\");\n    }\n\n    @RepeatedTest(100)\n    void testLatitude() {\n        String latStr = faker.address().latitude().replace(decimalSeparator, '.');\n        assertThat(latStr).is(IS_A_NUMBER);\n        Double lat = Double.valueOf(latStr);\n        assertThat(lat).isBetween(-90.0, 90.0);\n    }\n\n    @RepeatedTest(100)\n    void testLongitude() {\n        String longStr = faker.address().longitude().replace(decimalSeparator, '.');\n        assertThat(longStr).is(IS_A_NUMBER);\n        Double lon = Double.valueOf(longStr);\n        assertThat(lon).isBetween(-180.0, 180.0);\n    }\n\n    @RepeatedTest(10)\n    void testLocaleLatitude() {\n        BaseFaker engFaker = new BaseFaker(Locale.ENGLISH);\n        String engLatStr = engFaker.address().latitude();\n        assertThat(engLatStr).matches(\"-?\\\\d{1,3}\\\\.\\\\d+\");\n    }\n\n    @RepeatedTest(10)\n    void testLocaleLongitude() {\n        BaseFaker engFaker = new BaseFaker(Locale.ENGLISH);\n        String engLatStr = engFaker.address().longitude();\n        assertThat(engLatStr).matches(\"-?\\\\d{1,3}\\\\.\\\\d+\");\n    }\n\n    @Test\n    void testTimeZone() {\n        assertThat(faker.address().timeZone()).matches(\"[A-Za-z_]+/[A-Za-z_]+[/A-Za-z_]*\");\n    }\n\n    @Test\n    void testState() {\n        assertThat(faker.address().state()).matches(\"[A-Za-z ]+\");\n    }\n\n    @Test\n    void testCity() {\n        assertThat(faker.address().city()).matches(\"[A-Za-z'() ]+\");\n    }\n\n    @Test\n    void testCityName() {\n        assertThat(faker.address().cityName()).matches(\"[A-Za-z'() ]+\");\n    }\n\n    @Test\n    void testCountry() {\n        assertThat(faker.address().country()).matches(\"[A-Za-z\\\\- &.,'()\\\\d]+\");\n    }\n\n    @Test\n    void testCountryCode() {\n        assertThat(faker.address().countryCode()).matches(\"[A-Za-z ]+\");\n    }\n\n    @Test\n    void testStreetAddressIncludeSecondary() {\n        assertThat(faker.address().streetAddress(true)).isNotEmpty();\n    }\n\n    @Test\n    void testCityWithLocaleFranceAndSeed() {\n        long seed = (long) (Long.MAX_VALUE * Math.random());\n        BaseFaker firstFaker = new BaseFaker(Locale.FRANCE, new Random(seed));\n        BaseFaker secondFaker = new BaseFaker(Locale.FRANCE, new Random(seed));\n        for (int i = 0; i < 100; i++) {\n            assertThat(firstFaker.address().city()).isEqualTo(secondFaker.address().city());\n        }\n    }\n\n    @Test\n    void testFullAddress() {\n        assertThat(faker.address().fullAddress()).isNotEmpty();\n    }\n\n    @Test\n    void fullAddress_estonia() {\n        BaseFaker f = new BaseFaker(new Locale(\"et\", \"EE\"));\n        assertThat(f.address().fullAddress()).isNotEmpty();\n    }\n\n    @Test\n    void testZipCodeByState() {\n        final BaseFaker localFaker = new BaseFaker(new Locale(\"en\", \"US\"));\n        assertThat(localFaker.address().zipCodeByState(localFaker.address().stateAbbr())).matches(\"[0-9]{5}\");\n    }\n\n    @Test\n    void testHungarianZipCodeByState() {\n        final BaseFaker localFaker = new BaseFaker(new Locale(\"hu\"));\n        assertThat(localFaker.address().zipCodeByState(localFaker.address().stateAbbr())).matches(\"[0-9]{4}\");\n    }\n\n    @Test\n    void testCountyByZipCode() {\n        final BaseFaker localFaker = new BaseFaker(new Locale(\"en\", \"US\"));\n        assertThat(localFaker.address().countyByZipCode(\"47732\")).isNotEmpty();\n    }\n\n    @ParameterizedTest\n    @NullSource\n    @ValueSource(strings = {\"1\", \"asd\", \"qwe\", \"wrong\"})\n    void testCountyForWrongZipCode(String zipCode) {\n        final BaseFaker localFaker = new BaseFaker(new Locale(\"en\", \"US\"));\n        assertThatThrownBy(() -> localFaker.address().countyByZipCode(zipCode))\n            .isInstanceOf(RuntimeException.class)\n            .hasMessage(\"County is not configured for postcode \" + zipCode);\n    }\n\n    @Test\n    void testStreetPrefix() {\n        assertThat(faker.address().streetPrefix()).isNotEmpty();\n    }\n\n    @Test\n    void testStreetSuffix() {\n        assertThat(faker.address().streetSuffix()).isNotEmpty();\n    }\n\n    @Test\n    void testCityPrefix() {\n        assertThat(faker.address().cityPrefix()).isNotEmpty();\n    }\n\n    @Test\n    void testCitySuffix() {\n        assertThat(faker.address().citySuffix()).isNotEmpty();\n    }\n\n    @RepeatedTest(10)\n    void testMailbox() {\n        assertThat(faker.address().mailBox()).matches(\"PO Box [0-9]{2,4}\");\n    }\n\n    @Test\n    void testZipIsFiveChars() {\n        final BaseFaker localFaker = new BaseFaker(new Locale(\"en\", \"US\"));\n        assertThat(localFaker.address().zipCode()).hasSize(5);\n    }\n\n    @Test\n    void testZipPlus4IsTenChars() {\n        final BaseFaker localFaker = new BaseFaker(new Locale(\"en\", \"US\"));\n        assertThat(localFaker.address().zipCodePlus4()).hasSize(10);  // includes dash\n    }\n\n    @Test\n    void testZipPlus4IsNineDigits() {\n        final BaseFaker localFaker = new BaseFaker(new Locale(\"en\", \"US\"));\n        final String[] zipCodeParts = localFaker.address().zipCodePlus4().split(\"-\");\n        assertThat(zipCodeParts[0]).matches(\"[0-9]{5}\");\n        assertThat(zipCodeParts[1]).matches(\"[0-9]{4}\");\n    }\n\n    @RepeatedTest(100)\n    void testLatLonEnUs() {\n        assertThat(US_FAKER.address().latLon())\n            .matches(BI_LAT_LON_REGEX.apply(ESCAPED_DECIMAL_SEPARATOR.apply(US_FAKER.getContext().getLocale()), \",\"));\n    }\n\n    @RepeatedTest(100)\n    void testLatLonNl() {\n        assertThat(NL_FAKER.address().latLon())\n            .matches(BI_LAT_LON_REGEX.apply(ESCAPED_DECIMAL_SEPARATOR.apply(NL_FAKER.getContext().getLocale()), \",\"));\n    }\n\n    @RepeatedTest(100)\n    void testLonLatEnUs() {\n        assertThat(US_FAKER.address().lonLat())\n            .matches(BI_LON_LAT_REGEX.apply(ESCAPED_DECIMAL_SEPARATOR.apply(US_FAKER.getContext().getLocale()), \",\"));\n    }\n\n    @RepeatedTest(100)\n    void testLonLatNl() {\n        assertThat(NL_FAKER.address().lonLat())\n            .matches(BI_LON_LAT_REGEX.apply(ESCAPED_DECIMAL_SEPARATOR.apply(NL_FAKER.getContext().getLocale()), \",\"));\n    }\n\n    @Test\n    void testLonLatRU() {\n        assertThat(RU_FAKER.address().lonLat(\";\"))\n            .matches(BI_LON_LAT_REGEX.apply(ESCAPED_DECIMAL_SEPARATOR.apply(RU_FAKER.getContext().getLocale()), \";\"));\n    }\n\n    @Test\n    void testLatLonRU() {\n        assertThat(RU_FAKER.address().latLon(\";\"))\n            .matches(BI_LAT_LON_REGEX.apply(ESCAPED_DECIMAL_SEPARATOR.apply(RU_FAKER.getContext().getLocale()), \";\"));\n    }\n\n    @ParameterizedTest\n    @ValueSource(strings = {\"bg\", \"ru\", \"uk\", \"by\"})\n    void cyrillicStreetName(String locale) {\n        BaseFaker localFaker = new BaseFaker(new Locale(locale));\n        assertThat(localFaker.address().streetName()).isNotEmpty().matches(CYRILLIC_LETTERS);\n    }\n\n    @RepeatedTest(100)\n    void dutchAddress() {\n        assertThat(NL_FAKER.address().stateAbbr()).matches(\"[A-Z]{2}\");\n        assertThat(NL_FAKER.address().fullAddress()).matches(\"[A-Z].+, [0-9]{4} [A-Z]{2}, [A-Z].+\");\n    }\n\n    @RepeatedTest(100)\n    void belgianSAddress() {\n        assertThat(BELGIAN_FAKER.address().stateAbbr()).matches(\"[A-Z]{3}\");\n        assertThat(BELGIAN_FAKER.address().fullAddress()).matches(\"[A-Z].+, [0-9]{4}, [A-Z].+\");\n    }\n\n    @RepeatedTest(100)\n    void belgianZipcode() {\n        assertThat(Integer.valueOf(BELGIAN_FAKER.address().zipCode())).isBetween(1000, 9992);\n    }\n\n    @RepeatedTest(100)\n    void australiaAddress() {\n        assertThat(AU_FAKER.address().fullAddress()).matches(\"(Unit|[0-9]).+, [A-Z].+, [A-Z]{2,3} [0-9]{4}\");\n    }\n    @RepeatedTest(100)\n    void testCityCnSuffix() {\n        assertThat(new Faker(Locale.CHINA).address().citySuffix()).matches(\"[\\\\u4e00-\\\\u9fa5]{1,7}(?:\u7701|\u81ea\u6cbb\u533a)\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final char decimalSeparator = new DecimalFormatSymbols(getFaker().getContext().getLocale()).getDecimalSeparator();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "char", "name": "decimalSeparator = new DecimalFormatSymbols(getFaker().getContext().getLocale()).getDecimalSeparator()", "syntax_pass": true}, {"attribute_expression": "private static final Faker US_FAKER = new Faker(new Locale(\"en\", \"US\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "US_FAKER = new Faker(new Locale(\"en\", \"US\"))", "syntax_pass": true}, {"attribute_expression": "private static final Faker NL_FAKER = new Faker(new Locale(\"nl\", \"NL\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "NL_FAKER = new Faker(new Locale(\"nl\", \"NL\"))", "syntax_pass": true}, {"attribute_expression": "private static final Faker BELGIAN_FAKER = new Faker(new Locale(\"nl\", \"BE\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "BELGIAN_FAKER = new Faker(new Locale(\"nl\", \"BE\"))", "syntax_pass": true}, {"attribute_expression": "private static final Faker RU_FAKER = new Faker(new Locale(\"ru\", \"RU\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "RU_FAKER = new Faker(new Locale(\"ru\", \"RU\"))", "syntax_pass": true}, {"attribute_expression": "private static final Faker AU_FAKER = new Faker(new Locale(\"en\", \"AU\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "AU_FAKER = new Faker(new Locale(\"en\", \"AU\"))", "syntax_pass": true}, {"attribute_expression": "private static final Pattern CYRILLIC_LETTERS = Pattern.compile(\".*[\u0430-\u044f\u0410-\u042f].*\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "CYRILLIC_LETTERS = Pattern.compile(\".*[\u0430-\u044f\u0410-\u042f].*\")", "syntax_pass": true}, {"attribute_expression": "private static final Condition<String> IS_A_NUMBER = new Condition<>(s -> {\n        try {\n            Double.valueOf(s);\n        } catch (NumberFormatException ignore) {\n            return false;\n        }\n        return true;\n    }, \"Is a number\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Condition<String>", "name": "IS_A_NUMBER = new Condition<>(s -> {\n        try {\n            Double.valueOf(s);\n        } catch (NumberFormatException ignore) {\n            return false;\n        }\n        return true;\n    }, \"Is a number\")", "syntax_pass": true}, {"attribute_expression": "private static final BiFunction<String, String, Pattern> BI_LAT_LON_REGEX =\n        (decimalDelimiter, delimiter) ->\n            Pattern.compile(\"-?\\\\d{1,2}\" + decimalDelimiter + \"\\\\d{5,10}\" + delimiter + \"-?\\\\d{1,3}\" + decimalDelimiter + \"\\\\d{5,10}+\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "BiFunction<String, String, Pattern>", "name": "BI_LAT_LON_REGEX =\n        (decimalDelimiter, delimiter) ->\n            Pattern.compile(\"-?\\\\d{1,2}\" + decimalDelimiter + \"\\\\d{5,10}\" + delimiter + \"-?\\\\d{1,3}\" + decimalDelimiter + \"\\\\d{5,10}+\")", "syntax_pass": true}, {"attribute_expression": "private static final BiFunction<String, String, Pattern> BI_LON_LAT_REGEX =\n        (decimalDelimiter, delimiter) ->\n            Pattern.compile(\"-?\\\\d{1,3}\" + decimalDelimiter + \"\\\\d{5,10}+\" + delimiter + \"-?\\\\d{1,2}\" + decimalDelimiter + \"\\\\d{5,10}\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "BiFunction<String, String, Pattern>", "name": "BI_LON_LAT_REGEX =\n        (decimalDelimiter, delimiter) ->\n            Pattern.compile(\"-?\\\\d{1,3}\" + decimalDelimiter + \"\\\\d{5,10}+\" + delimiter + \"-?\\\\d{1,2}\" + decimalDelimiter + \"\\\\d{5,10}\")", "syntax_pass": true}, {"attribute_expression": "private final static Function<Locale, String> ESCAPED_DECIMAL_SEPARATOR = t -> \"\\\\\" + new DecimalFormatSymbols(t).getDecimalSeparator();", "docstring": "", "modifiers": "private final static", "marker_annotations": [], "non_marker_annotations": ["private", "final", "static"], "comments": [], "type": "Function<Locale, String>", "name": "ESCAPED_DECIMAL_SEPARATOR = t -> \"\\\\\" + new DecimalFormatSymbols(t).getDecimalSeparator()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/ColorTest.java.ColorTest", "name": "ColorTest", "file_path": "src/test/java/net/datafaker/providers/base/ColorTest.java", "superclasses": "", "methods": ["[void]testHex()", "[void]testHexNoHashSign()"], "method_uris": ["src/test/java/net/datafaker/providers/base/ColorTest.java.ColorTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ColorTest extends BaseFakerTest<BaseFaker> {\n\n    private final Color color = faker.color();\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(color::name, \"color.name\", \"(\\\\w+ ?){1,2}\"));\n    }\n\n    @Test\n    void testHex() {\n        assertThat(color.hex()).matches(\"^#[0-9A-F]{6}$\");\n    }\n\n    @Test\n    void testHexNoHashSign() {\n        assertThat(color.hex(false)).matches(\"^[0-9A-F]{6}$\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Color color = faker.color();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Color", "name": "color = faker.color()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/LoremTest.java.LoremTest", "name": "LoremTest", "file_path": "src/test/java/net/datafaker/providers/base/LoremTest.java", "superclasses": "", "methods": ["[void]shouldCreateFixedLengthString()", "[void]testCharacter()", "[void]testCharacterIncludeUpperCase()", "[void]testCharactersShouldIncludeMinAndMaxLenght()", "[void]testCharacters()", "[void]testCharactersIncludeUpperCase()", "[void]testCharactersWithLength()", "[void]testCharactersWithLengthIncludeUppercase()", "[void]testCharactersMinimumMaximumLength()", "[void]testCharactersMinimumMaximumLengthEquals()", "[void]testCharactersMinimumMaximumLengthEqualsIncludingUppercaseAndIncludingDigit()", "[void]testCharactersFixedLengthIncludingUppercaseAndIncludingDigit()", "[void]testFixedNumberOfCharactersEmpty()", "[void]testCharactersMinimumMaximumLengthIncludeUppercase()", "[void]testCharactersMinimumMaximumLengthIncludeUppercaseIncludeDigit()", "[void]testSentence()", "[void]testSentenceWithWordCount()", "[void]testSentenceWithWordCountAndRandomWordsToAdd()", "[void]testSentenceFixedNumberOfWords()", "[void]testWords()", "[void]testMaxLengthSentence()", "[void]testMaxLengthWithEmptySentence()", "[void]testMaxLengthWithNegativeLengthSentence()", "[void]testSentences()", "[void]testSentencesWithCount()"], "method_uris": ["src/test/java/net/datafaker/providers/base/LoremTest.java.LoremTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class LoremTest extends BaseFakerTest<BaseFaker> {\n\n    private final Lorem lorem = faker.lorem();\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(\n                TestSpec.of(lorem::word, \"lorem.words\"),\n                TestSpec.of(lorem::supplemental, \"lorem.supplemental\")\n        );\n    }\n\n    @Test\n    void shouldCreateFixedLengthString() {\n        assertThat(lorem.fixedString(10)).hasSize(10);\n        assertThat(lorem.fixedString(50)).hasSize(50);\n        assertThat(lorem.fixedString(0)).isEmpty();\n        assertThat(lorem.fixedString(-1)).isEmpty();\n    }\n\n    @Test\n    void testCharacter() {\n        assertThat(String.valueOf(lorem.character())).matches(\"[a-z\\\\d]\");\n    }\n\n    @Test\n    void testCharacterIncludeUpperCase() {\n        assertThat(String.valueOf(lorem.character(false))).matches(\"[a-z\\\\d]\");\n        assertThat(String.valueOf(lorem.character(true))).matches(\"[a-zA-Z\\\\d]\");\n    }\n\n    @Test\n    void testCharactersShouldIncludeMinAndMaxLenght() {\n        List<String> results = new ArrayList<>();\n        for (int i = 0; i < 300; i++) {\n            results.add(lorem.characters(1, 10));\n        }\n\n        final List<String> min = results.stream().filter(x -> x.length() == 1).collect(Collectors.toList());\n        final List<String> max = results.stream().filter(x -> x.length() == 10).collect(Collectors.toList());\n\n        assertThat(min).isNotEmpty();\n        assertThat(max).isNotEmpty();\n    }\n\n    @Test\n    void testCharacters() {\n        assertThat(lorem.characters()).matches(\"[a-z\\\\d]{255}\");\n    }\n\n    @Test\n    void testCharactersIncludeUpperCase() {\n        assertThat(lorem.characters(false)).matches(\"[a-z\\\\d]{255}\");\n        assertThat(lorem.characters(true)).matches(\"[a-zA-Z\\\\d]{255}\");\n    }\n\n    @Test\n    void testCharactersWithLength() {\n        assertThat(lorem.characters(2)).matches(\"[a-z\\\\d]{2}\");\n        assertThat(lorem.characters(500)).matches(\"[a-z\\\\d]{500}\");\n        assertThat(lorem.characters(0)).isEmpty();\n        assertThat(lorem.characters(-1)).isEmpty();\n    }\n\n    @Test\n    void testCharactersWithLengthIncludeUppercase() {\n        assertThat(lorem.characters(2, false)).matches(\"[a-z\\\\d]{2}\");\n        assertThat(lorem.characters(500, false)).matches(\"[a-z\\\\d]{500}\");\n        assertThat(lorem.characters(2, true)).matches(\"[a-zA-Z\\\\d]{2}\");\n        assertThat(lorem.characters(500, true)).matches(\"[a-zA-Z\\\\d]{500}\");\n        assertThat(lorem.characters(0, false)).isEmpty();\n        assertThat(lorem.characters(-1, true)).isEmpty();\n    }\n\n    @Test\n    void testCharactersMinimumMaximumLength() {\n        assertThat(lorem.characters(1, 10)).matches(\"[a-z\\\\d]{1,10}\");\n    }\n\n    @RepeatedTest(10)\n    void testCharactersMinimumMaximumLengthEquals() {\n        assertThat(lorem.characters(5, 5)).matches(\"[a-z\\\\d]{5}\");\n    }\n\n    @RepeatedTest(10)\n    void testCharactersMinimumMaximumLengthEqualsIncludingUppercaseAndIncludingDigit() {\n        assertThat(lorem.characters(6, 10, true, true)).matches(\"[a-zA-Z\\\\d]{6,10}\");\n    }\n\n    @RepeatedTest(10)\n    void testCharactersFixedLengthIncludingUppercaseAndIncludingDigit() {\n        assertThat(lorem.characters(10, true, true)).matches(\"[a-zA-Z\\\\d]{10}\");\n    }\n\n    @Test\n    void testFixedNumberOfCharactersEmpty() {\n        assertThat(lorem.characters(-1)).isEmpty();\n        assertThat(lorem.characters(0)).isEmpty();\n\n        assertThat(lorem.characters(-1, true, true, true)).isEmpty();\n        assertThat(lorem.characters(0, false, false, false)).isEmpty();\n    }\n\n\n    @Test\n    void testCharactersMinimumMaximumLengthIncludeUppercase() {\n        assertThat(lorem.characters(1, 10, true)).matches(\"[a-zA-Z\\\\d]{1,10}\");\n    }\n\n    @Test\n    void testCharactersMinimumMaximumLengthIncludeUppercaseIncludeDigit() {\n        assertThat(lorem.characters(1, 10, false, false)).matches(\"[a-zA-Z]{1,10}\");\n        assertThat(lorem.characters(2, 10, true, true)).matches(\"[a-zA-Z\\\\d]{1,10}\");\n    }\n\n    @Test\n    void testSentence() {\n        String sentence = lorem.sentence();\n        String[] words = sentence.split(\" \");\n\n        assertThat(words.length).isBetween(3, 9);\n        assertThat(sentence).endsWith(\".\");\n    }\n\n    @Test\n    void testSentenceWithWordCount() {\n        String sentence = lorem.sentence(10);\n        String[] words = sentence.split(\" \");\n\n        assertThat(words.length).isBetween(9, 15);\n        assertThat(sentence).endsWith(\".\");\n    }\n\n    @RepeatedTest(10)\n    void testSentenceWithWordCountAndRandomWordsToAdd() {\n        assertThat(lorem.sentence(10, 10)).matches(\"(\\\\w+\\\\s?){10,20}\\\\.\");\n    }\n\n    @RepeatedTest(10)\n    void testSentenceFixedNumberOfWords() {\n        assertThat(lorem.sentence(10, 0)).matches(\"(\\\\w+\\\\s?){10}\\\\.\");\n    }\n\n    @Test\n    void testWords() {\n        assertThat(lorem.words()).isNotEmpty();\n    }\n\n    @RepeatedTest(10)\n    void testMaxLengthSentence() {\n        Random rand = new Random();\n        // Test different lengths over 10 runs\n        int length = Math.abs(rand.nextInt(10000));\n        String s = lorem.maxLengthSentence(length);\n        assertThat(s).hasSize(length);\n    }\n\n    @Test\n    void testMaxLengthWithEmptySentence() {\n        String s = lorem.maxLengthSentence(0);\n        assertThat(s).isEmpty();\n    }\n\n    @Test\n    void testMaxLengthWithNegativeLengthSentence() {\n        String s = lorem.maxLengthSentence(-1);\n        assertThat(s).isEmpty();\n    }\n\n    @RepeatedTest(10)\n    void testSentences() {\n        String paragraph = lorem.paragraph();\n        int matches = StringUtils.countMatches(paragraph, \".\");\n        assertThat(matches).isBetween(3, 6);\n    }\n\n    @RepeatedTest(10)\n    void testSentencesWithCount() {\n        String paragraph = lorem.paragraph(1);\n        int matches = StringUtils.countMatches(paragraph, \".\");\n        assertThat(matches).isBetween(1, 3);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Lorem lorem = faker.lorem();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Lorem", "name": "lorem = faker.lorem()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/NameTest.java.NameTest", "name": "NameTest", "file_path": "src/test/java/net/datafaker/providers/base/NameTest.java", "superclasses": "", "methods": ["[void]testName()", "[void]testNameWithMiddle()", "[void]testNameWithMiddleDoesNotHaveRepeatedName()", "[void]testFullName()", "[void]testFullNameArabic()", "[void]testFirstName()", "[void]testFemaleFirstName()", "[void]testMaleFirstName()", "[void]testLastName()", "[void]testPrefix()", "[void]testSuffix()", "[void]testTitle()", "[void]test()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class NameTest extends BaseFakerTest<BaseFaker> {\n\n    private final Name name = faker.name();\n\n    @Test\n    void testName() {\n        assertThat(name.name()).matches(\"([\\\\w']+\\\\.?( )?){2,4}\");\n    }\n\n    @Test\n    void testNameWithMiddle() {\n        assertThat(name.nameWithMiddle()).matches(\"([\\\\w']+\\\\.?( )?){3,}\");\n    }\n\n    @Test\n    void testNameWithMiddleDoesNotHaveRepeatedName() {\n        int theSameNameCnt = 0;\n        int total = 100;\n        for (int i = 0; i < total; i++) {\n            String nameWithMiddle = name.nameWithMiddle();\n            String[] splitNames = nameWithMiddle.split(\" \");\n            if (splitNames[0].equals(splitNames[1])) {\n                theSameNameCnt++;\n            }\n        }\n        assertThat(theSameNameCnt).isLessThan(total / 10);\n    }\n\n    @Test\n    void testFullName() {\n        assertThat(name.fullName()).matches(\"([\\\\w']+\\\\.?( )?){2,4}\");\n    }\n\n    @Test\n    void testFullNameArabic() {\n        BaseFaker localFaker = new BaseFaker(new Locale(\"ar\"));\n\n        for (int i = 0; i < 25; i++) {\n            assertThat(localFaker.name().fullName()).matches(\"^[\\\\u0600-\\\\u06FF\\\\u0750-\\\\u077F ]+$\");\n        }\n    }\n\n    @Test\n    void testFirstName() {\n        assertThat(name.firstName()).matches(\"\\\\w+\");\n    }\n\n    @RepeatedTest(10)\n    void testFemaleFirstName() {\n        assertThat(name.femaleFirstName()).matches(\"\\\\w+\");\n    }\n\n    @RepeatedTest(10)\n    void testMaleFirstName() {\n        assertThat(name.malefirstName()).matches(\"\\\\w+\");\n    }\n\n    @Test\n    void testLastName() {\n        assertThat(name.lastName()).matches(\"[A-Za-z']+\");\n    }\n\n    @Test\n    void testPrefix() {\n        assertThat(name.prefix()).matches(\"\\\\w+\\\\.?\");\n    }\n\n    @Test\n    void testSuffix() {\n        assertThat(name.suffix()).matches(\"\\\\w+\\\\.?\");\n    }\n\n    @Test\n    void testTitle() {\n        assertThat(name.title()).matches(\"(\\\\w+\\\\.?( )?){3}\");\n    }\n\n    @Test\n    void test() {\n        var faker = new BaseFaker(new Locale(\"id\"));\n        System.out.println(faker.name().name());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Name name = faker.name();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Name", "name": "name = faker.name()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/CountryTest.java.CountryTest", "name": "CountryTest", "file_path": "src/test/java/net/datafaker/providers/base/CountryTest.java", "superclasses": "", "methods": ["[void]testFlag()", "[void]testCurrency()", "[void]testCurrencyCode()"], "method_uris": ["src/test/java/net/datafaker/providers/base/CountryTest.java.CountryTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class CountryTest extends BaseFakerTest<BaseFaker> {\n\n    Country country = faker.country();\n\n    @RepeatedTest(10)\n    void testFlag() {\n        String flag = country.flag();\n        assertThat(flag).matches(\"^https://flags.fmcdn\\\\.net/data/flags/w580/[a-zA-Z0-9_]+\\\\.png$\");\n    }\n\n    @Test\n    void testCurrency() {\n        assertThat(faker.country().currency()).isNotEmpty();\n    }\n\n    @Test\n    void testCurrencyCode() {\n        assertThat(faker.country().currencyCode()).isNotEmpty();\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(country::countryCode2, \"country.code2\", \"[a-z]{2}\"),\n                TestSpec.of(country::countryCode3, \"country.code3\", \"[a-z]{3}\"),\n                TestSpec.of(country::capital, \"country.capital\", \"([\\\\p{L}0-9+,. '-])+\"),\n                TestSpec.of(country::name, \"country.name\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "Country country = faker.country();", "docstring": "", "modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "type": "Country", "name": "country = faker.country()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/VehicleTest.java.VehicleTest", "name": "VehicleTest", "file_path": "src/test/java/net/datafaker/providers/base/VehicleTest.java", "superclasses": "", "methods": ["[void]testVin()", "[void]testManufacturer()", "[void]testMake()", "[void]testModel()", "[void]testModelWithParams()", "[void]testMakeAndModel()", "[void]testStyle()", "[void]testColor()", "[void]testUpholsteryColor()", "[void]testUpholsteryFabric()", "[void]testUpholstery()", "[void]testTransmission()", "[void]testDriveType()", "[void]testFuelType()", "[void]testCarType()", "[void]testEngine()", "[void]testCarOptions()", "[void]testCarOptionsMinMax()", "[void]testStandardSpecsMinMax()", "[void]testStandardSpecs()", "[void]testDoor()", "[void]testLicensePlate()", "[void]testLicensePlateWithParam()", "[void]testLicensePlateWithParam_Canada()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class VehicleTest extends BaseFakerTest<BaseFaker> {\n\n    private static final String WORD_MATCH = \"\\\\w+\\\\.?\";\n    private static final String WORDS_MATCH = \"^[a-zA-Z\\\\d_/ -]*$\";\n    private static final String INTERNATIONAL_WORDS_MATCH = \"\\\\P{Cc}+\";\n\n    @RepeatedTest(10)\n    void testVin() {\n        assertThat(faker.vehicle().vin()).matches(Vehicle.VIN_REGEX);\n    }\n\n    @RepeatedTest(10)\n    void testManufacturer() {\n        assertThat(faker.vehicle().manufacturer()).matches(INTERNATIONAL_WORDS_MATCH);\n    }\n\n    @RepeatedTest(10)\n    void testMake() {\n        assertThat(faker.vehicle().make()).matches(INTERNATIONAL_WORDS_MATCH);\n    }\n\n    @RepeatedTest(10)\n    void testModel() {\n        assertThat(faker.vehicle().model()).matches(INTERNATIONAL_WORDS_MATCH);\n    }\n\n    @RepeatedTest(10)\n    void testModelWithParams() {\n        assertThat(faker.vehicle().model(\"Toyota\")).matches(INTERNATIONAL_WORDS_MATCH);\n    }\n\n    @RepeatedTest(10)\n    void testMakeAndModel() {\n        assertThat(faker.vehicle().makeAndModel()).matches(INTERNATIONAL_WORDS_MATCH);\n    }\n\n    @RepeatedTest(10)\n    void testStyle() {\n        assertThat(faker.vehicle().style()).matches(WORD_MATCH);\n    }\n\n    @RepeatedTest(10)\n    void testColor() {\n        assertThat(faker.vehicle().color()).matches(WORD_MATCH);\n    }\n\n    @RepeatedTest(10)\n    void testUpholsteryColor() {\n        assertThat(faker.vehicle().upholsteryColor()).matches(WORD_MATCH);\n    }\n\n    @RepeatedTest(10)\n    void testUpholsteryFabric() {\n        assertThat(faker.vehicle().upholsteryFabric()).matches(WORDS_MATCH);\n    }\n\n    @RepeatedTest(10)\n    void testUpholstery() {\n        assertThat(faker.vehicle().upholstery()).matches(WORDS_MATCH);\n    }\n\n    @RepeatedTest(10)\n    void testTransmission() {\n        assertThat(faker.vehicle().transmission()).matches(WORD_MATCH);\n    }\n\n    @RepeatedTest(10)\n    void testDriveType() {\n        assertThat(faker.vehicle().driveType()).matches(WORDS_MATCH);\n    }\n\n    @RepeatedTest(10)\n    void testFuelType() {\n        assertThat(faker.vehicle().fuelType()).matches(WORDS_MATCH);\n    }\n\n    @RepeatedTest(10)\n    void testCarType() {\n        assertThat(faker.vehicle().carType()).matches(WORDS_MATCH);\n    }\n\n    @RepeatedTest(10)\n    void testEngine() {\n        assertThat(faker.vehicle().engine()).matches(\"\\\\d Cylinder Engine\");\n    }\n\n    @RepeatedTest(10)\n    void testCarOptions() {\n        List<String> carOptions = faker.vehicle().carOptions();\n        assertThat(carOptions)\n            .hasSizeGreaterThanOrEqualTo(5)\n            .hasSizeLessThanOrEqualTo(10);\n    }\n\n    @RepeatedTest(10)\n    void testCarOptionsMinMax() {\n        List<String> carOptions = faker.vehicle().carOptions(11, 12);\n\n        assertThat(carOptions)\n            .hasSizeGreaterThanOrEqualTo(11)\n            .hasSizeLessThanOrEqualTo(12);\n\n        assertThat(carOptions.get(0)).isNotNull();\n    }\n\n    @RepeatedTest(10)\n    void testStandardSpecsMinMax() {\n        List<String> standardSpecs = faker.vehicle().standardSpecs(13, 14);\n\n        assertThat(standardSpecs)\n            .hasSizeGreaterThanOrEqualTo(13)\n            .hasSizeLessThanOrEqualTo(14);\n    }\n\n    @RepeatedTest(10)\n    void testStandardSpecs() {\n        List<String> standardSpecs = faker.vehicle().standardSpecs();\n\n        assertThat(standardSpecs)\n            .hasSizeGreaterThanOrEqualTo(5)\n            .hasSizeLessThanOrEqualTo(10);\n    }\n\n    @RepeatedTest(10)\n    void testDoor() {\n        assertThat(faker.vehicle().doors()).matches(\"\\\\d\");\n    }\n\n    @RepeatedTest(10)\n    void testLicensePlate() {\n        assertThat(faker.vehicle().licensePlate()).matches(WORDS_MATCH);\n    }\n\n    @RepeatedTest(10)\n    void testLicensePlateWithParam() {\n        assertThat(faker.vehicle().licensePlate(\"GA\")).matches(WORDS_MATCH);\n        assertThat(faker.vehicle().licensePlate(\"AL\")).matches(WORDS_MATCH);\n    }\n\n    @RepeatedTest(100)\n    void testLicensePlateWithParam_Canada() {\n        BaseFaker test = new BaseFaker(Locale.CANADA);\n        assertThat(test.vehicle().licensePlate(\"MB\")).matches(WORDS_MATCH);\n        assertThat(test.vehicle().licensePlate(\"ON\")).matches(WORDS_MATCH);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String WORD_MATCH = \"\\\\w+\\\\.?\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "WORD_MATCH = \"\\\\w+\\\\.?\"", "syntax_pass": true}, {"attribute_expression": "private static final String WORDS_MATCH = \"^[a-zA-Z\\\\d_/ -]*$\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "WORDS_MATCH = \"^[a-zA-Z\\\\d_/ -]*$\"", "syntax_pass": true}, {"attribute_expression": "private static final String INTERNATIONAL_WORDS_MATCH = \"\\\\P{Cc}+\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "INTERNATIONAL_WORDS_MATCH = \"\\\\P{Cc}+\"", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/TimeAndDateTest.java.TimeAndDateTest", "name": "TimeAndDateTest", "file_path": "src/test/java/net/datafaker/providers/base/TimeAndDateTest.java", "superclasses": "", "methods": ["[void]testFutureDate()", "[void]testFutureDateWithBounds()", "[void]testFutureDateWithMinimum()", "[void]testPastDateWithMinimum()", "[void]testPastDateWithReferenceDate()", "[void]testPastDate()", "[void]testPastDateWithBounds()", "[void]testBetween()", "[void]testBetweenWithMaskReturningString()", "[void]testBetweenThenLargerThanNow()", "[void]testBirthday()", "[void]testBirthdayWithAges()", "[void]birthdayWithMask()", "[void]futureWithMask()", "[void]pastWithMask()", "[void]periodTest()", "[void]durationTest(long,long,ChronoUnit)", "[void]durationTest(long,ChronoUnit)", "[void]maxLessThanMinPeriod(Period,Period)"], "method_uris": ["src/test/java/net/datafaker/providers/base/TimeAndDateTest.java.TimeAndDateTest.[Stream<Arguments>]generateDurationsWithMaxOnly()", "src/test/java/net/datafaker/providers/base/TimeAndDateTest.java.TimeAndDateTest.[Stream<Arguments>]generateDurationsWithMinMax()", "src/test/java/net/datafaker/providers/base/TimeAndDateTest.java.TimeAndDateTest.[Stream<Arguments>]generatePeriod()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class TimeAndDateTest extends BaseFakerTest<BaseFaker> {\n\n    private final TimeAndDate timeAndDate = faker.timeAndDate();\n\n    @RepeatedTest(100)\n    void testFutureDate() {\n        assertThat(timeAndDate.future()).isInTheFuture();\n    }\n\n    @RepeatedTest(100)\n    void testFutureDateWithBounds() {\n        Instant now = Instant.now();\n        Instant future = timeAndDate.future(1, TimeUnit.SECONDS, now);\n        assertThat(future).isBetween(now, now.plusSeconds(1));\n    }\n\n    @RepeatedTest(100)\n    void testFutureDateWithMinimum() {\n        Instant now = Instant.now();\n        Instant future = timeAndDate.future(5, 4, TimeUnit.SECONDS);\n        assertThat(future)\n            .isBetween(now.plusMillis(3500), now.plusMillis(5500));\n    }\n\n    @RepeatedTest(100)\n    void testPastDateWithMinimum() {\n        final long now = System.currentTimeMillis();\n        Instant past = timeAndDate.past(5, 4, TimeUnit.SECONDS);\n        assertThat(past.toEpochMilli()).isLessThan(now)\n            .isGreaterThan(now - 5500)\n            .isLessThan(now - 3500);\n    }\n\n    @RepeatedTest(100)\n    void testPastDateWithReferenceDate() {\n        Instant now = Instant.now();\n        Instant past = timeAndDate.past(1, TimeUnit.SECONDS, now);\n        assertThat(past.toEpochMilli())\n            .isLessThan(now.toEpochMilli())\n            .isGreaterThan(now.toEpochMilli() - 1000);\n    }\n\n    @RepeatedTest(100)\n    void testPastDate() {\n        assertThat(timeAndDate.past()).isInThePast();\n    }\n\n    @RepeatedTest(100)\n    void testPastDateWithBounds() {\n        Instant now = Instant.now();\n        Instant past = timeAndDate.past(100, TimeUnit.SECONDS);\n        assertThat(past.toEpochMilli()).isLessThan(now.toEpochMilli());\n    }\n\n    @RepeatedTest(100)\n    void testBetween() {\n        Instant now = Instant.now();\n        Instant then = Instant.now().plusMillis(1000);\n\n        Instant date = timeAndDate.between(now, then);\n        assertThat(date.toEpochMilli())\n            .isLessThan(then.toEpochMilli())\n            .isGreaterThanOrEqualTo(now.toEpochMilli());\n    }\n\n    @Test\n    void testBetweenWithMaskReturningString() {\n        Instant now = Instant.now();\n        Instant then = Instant.now().plusMillis(1000);\n\n        String pattern = \"YYYY MM.dd mm:hh:ss\";\n\n        DateTimeFormatter.ofPattern(pattern).parse(timeAndDate.between(now, then, pattern));\n    }\n\n    @Test\n    void testBetweenThenLargerThanNow() {\n        Instant now = Instant.now();\n        Instant then = Instant.now().plusMillis(1000);\n\n        assertThatThrownBy(() -> timeAndDate.between(then, now))\n            .isInstanceOf(IllegalArgumentException.class)\n            .hasMessage(\"Invalid date range: the upper bound date (%s) is before the lower bound (%s)\".formatted(now, then));\n    }\n\n    @RepeatedTest(100)\n    void testBirthday() {\n        final LocalDateTime now = LocalDateTime.now();\n        final LocalDate from = now.minusYears(TimeAndDate.DEFAULT_MIN_AGE).toLocalDate();\n        final LocalDate to = now.minusYears(TimeAndDate.DEFAULT_MAX_AGE).toLocalDate();\n        LocalDate birthday = timeAndDate.birthday();\n        assertThat(birthday).isBetween(to, from);\n    }\n\n    @RepeatedTest(100)\n    void testBirthdayWithAges() {\n        LocalDate nw = LocalDate.now();\n        final Number number = faker.number();\n        int minAge = number.numberBetween(1, 99);\n        int maxAge = number.numberBetween(minAge, 100);\n\n        LocalDate from = nw.minusYears(maxAge);\n        LocalDate to = nw.minusYears(minAge);\n\n        LocalDate birthday = timeAndDate.birthday(minAge, maxAge);\n\n        assertThat(birthday).isBetween(from, to);\n    }\n\n    @Test\n    void birthdayWithMask() {\n        String pattern = \"YYYY MM.dd\";\n        DateTimeFormatter.ofPattern(pattern).parse(timeAndDate.birthday(1, 50, pattern));\n    }\n\n    @Test\n    void futureWithMask() {\n        String pattern = \"YYYY MM.dd mm:hh:ss\";\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(pattern);\n        dateTimeFormatter.parse(timeAndDate.future(1, TimeUnit.HOURS, pattern));\n        dateTimeFormatter.parse(timeAndDate.future(20, 1, TimeUnit.HOURS, pattern));\n        dateTimeFormatter.parse(timeAndDate.future(20, TimeUnit.HOURS, Instant.now(), pattern));\n    }\n\n    @Test\n    void pastWithMask() {\n        String pattern = \"YYYY MM.dd mm:hh:ss\";\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(pattern);\n        dateTimeFormatter.parse(timeAndDate.past(1, TimeUnit.DAYS, pattern));\n        dateTimeFormatter.parse(timeAndDate.past(20, 1, TimeUnit.DAYS, pattern));\n        dateTimeFormatter.parse(timeAndDate.past(1, TimeUnit.DAYS, Instant.now(), pattern));\n    }\n\n    @Test\n    void periodTest() {\n        Period maxPeriod = Period.of(3, 2, 1);\n        Period minPeriod = Period.of(2, 1, 0);\n        Period period = timeAndDate.period(minPeriod, maxPeriod);\n\n        assertThat((period.getYears() * 12 + period.getMonths()) * 30 + period.getDays())\n            .isBetween((minPeriod.getYears() * 12 + minPeriod.getMonths()) * 30 + minPeriod.getDays(),\n                (maxPeriod.getYears() * 12 + maxPeriod.getMonths()) * 30 + maxPeriod.getDays());\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateDurationsWithMinMax\")\n    void durationTest(long minValue, long maxValue, ChronoUnit unit) {\n        Duration generated = timeAndDate.duration(minValue, maxValue, unit);\n        Duration min = Duration.of(minValue, unit);\n        Duration max = Duration.of(maxValue, unit);\n        assertThat(min)\n            .as(\"Duration must be equal or greater than min value\")\n            .isLessThanOrEqualTo(generated);\n        assertThat(max.compareTo(generated) > 0 || minValue >= maxValue && max.equals(generated))\n            .as(\"Duration must be lower than max value\").isTrue();\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateDurationsWithMaxOnly\")\n    void durationTest(long maxValue, ChronoUnit unit) {\n        Duration generated = timeAndDate.duration(maxValue, unit);\n        Duration max = Duration.of(maxValue, unit);\n        assertThat(max.compareTo(generated) > 0 || maxValue == 0)\n            .as(\"Duration must be lower than max value\")\n            .isTrue();\n    }\n\n\n    @ParameterizedTest\n    @MethodSource(\"generatePeriod\")\n    void maxLessThanMinPeriod(Period min, Period max) {\n        assertThatThrownBy(() -> timeAndDate.period(min, max))\n            .isInstanceOf(IllegalArgumentException.class);\n    }\n\n    private static Stream<Arguments> generateDurationsWithMaxOnly() {\n        return Stream.of(\n            Arguments.of(0, ChronoUnit.DAYS),\n            Arguments.of(100, ChronoUnit.DAYS),\n            Arguments.of(456, ChronoUnit.HOURS),\n            Arguments.of(43, ChronoUnit.MINUTES),\n            Arguments.of(78, ChronoUnit.SECONDS),\n            Arguments.of(786, ChronoUnit.MILLIS),\n            Arguments.of(786, ChronoUnit.MICROS),\n            Arguments.of(8729, ChronoUnit.NANOS)\n        );\n    }\n\n    private static Stream<Arguments> generateDurationsWithMinMax() {\n        return Stream.of(\n            Arguments.of(123, 123, ChronoUnit.DAYS),\n            Arguments.of(12, 123, ChronoUnit.HOURS),\n            Arguments.of(15, 400, ChronoUnit.MINUTES),\n            Arguments.of(65, 98, ChronoUnit.SECONDS),\n            Arguments.of(76, 100, ChronoUnit.MILLIS),\n            Arguments.of(879, 1030, ChronoUnit.MICROS),\n            Arguments.of(879, 1030, ChronoUnit.NANOS)\n        );\n    }\n\n    private static Stream<Arguments> generatePeriod() {\n        return Stream.of(\n            Arguments.of(Period.of(1, 1, 1), Period.of(0, 1, 1)),\n            Arguments.of(Period.of(1, 1, 3), Period.of(1, 1, 2)),\n            Arguments.of(Period.of(1, 2, 1), Period.of(1, 1, 1))\n        );\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final TimeAndDate timeAndDate = faker.timeAndDate();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TimeAndDate", "name": "timeAndDate = faker.timeAndDate()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/BaseFaker_doWithTest.java.BaseFaker_doWithTest", "name": "BaseFaker_doWithTest", "file_path": "src/test/java/net/datafaker/providers/base/BaseFaker_doWithTest.java", "superclasses": "", "methods": ["[void]testDoWithLocaleChange()", "[void]testDoWithRuntimeException()", "[void]testDoWithCheckedException()"], "method_uris": ["src/test/java/net/datafaker/providers/base/BaseFaker_doWithTest.java.BaseFaker_doWithTest.[void]before()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class BaseFaker_doWithTest {\n    private BaseFaker faker;\n    private Random random;\n\n    @BeforeEach\n    final void before() {\n        random = new Random();\n        faker = new BaseFaker(random);\n    }\n\n    @Test\n    void testDoWithLocaleChange() throws Exception {\n        Locale originalLocale = faker.getContext().getLocale();\n        Locale newLocale = Locale.FRANCE;\n        String expectedResult = \"Test Result\";\n\n        Callable<String> callable = () -> {\n            assertThat(faker.getContext().getLocale()).isEqualTo(newLocale);\n            return expectedResult;\n        };\n\n        String result = faker.doWith(callable, newLocale);\n        assertThat(result).isEqualTo(expectedResult);\n        assertThat(faker.getContext().getLocale()).isEqualTo(originalLocale);\n    }\n\n    @Test\n    void testDoWithRuntimeException() {\n        Locale newLocale = Locale.GERMANY;\n\n        Callable<String> callable = () -> {\n            throw new RuntimeException(\"Test Exception\");\n        };\n\n        assertThatThrownBy(() -> faker.doWith(callable, newLocale))\n            .isInstanceOf(RuntimeException.class)\n            .hasMessage(\"Test Exception\");\n    }\n\n    @Test\n    void testDoWithCheckedException() {\n        Locale newLocale = Locale.ITALY;\n\n        Callable<String> callable = () -> {\n            throw new Exception(\"Test Checked Exception\");\n        };\n\n        assertThatThrownBy(() -> faker.doWith(callable, newLocale))\n            .isInstanceOf(RuntimeException.class)\n            .hasCauseInstanceOf(Exception.class)\n            .hasMessageContaining(\"Test Checked Exception\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private BaseFaker faker;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BaseFaker", "name": "faker", "syntax_pass": true}, {"attribute_expression": "private Random random;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Random", "name": "random", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/Azure_subscriptionIdTest.java.Azure_subscriptionIdTest", "name": "Azure_subscriptionIdTest", "file_path": "src/test/java/net/datafaker/providers/base/Azure_subscriptionIdTest.java", "superclasses": "", "methods": ["[void]testSubscriptionId()", "[void]testTenantId()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Azure_subscriptionIdTest {\n\n    private final BaseFaker faker = new BaseFaker();\n    private final Azure azure = new Azure(faker);\n\n    @Test\n    void testSubscriptionId() {\n        assertThat(azure.subscriptionId()).matches(\"[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\");\n    }\n\n    @Test\n    void testTenantId() {\n        assertThat(azure.tenantId()).matches(\"[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final BaseFaker faker = new BaseFaker();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BaseFaker", "name": "faker = new BaseFaker()", "syntax_pass": true}, {"attribute_expression": "private final Azure azure = new Azure(faker);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Azure", "name": "azure = new Azure(faker)", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/Aviation_gateTest.java.Aviation_gateTest", "name": "Aviation_gateTest", "file_path": "src/test/java/net/datafaker/providers/base/Aviation_gateTest.java", "superclasses": "", "methods": ["[void]testGatePureNumeric()", "[void]testGateAlphanumeric()", "[void]testGateContextualDependency()", "[void]testGateFunctionalSimilarity()", "[void]testGateContextualSimilarity()"], "method_uris": ["src/test/java/net/datafaker/providers/base/Aviation_gateTest.java.Aviation_gateTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Aviation_gateTest {\n    private Aviation aviation;\n\n    @BeforeEach\n    public void setUp() {\n        aviation = new Aviation(new Faker());\n    }\n\n    @Test\n    void testGatePureNumeric() {\n        String gate = aviation.gate();\n        assertThat(gate).matches(\"\\\\d{1,3}\");\n    }\n\n    @Test\n    void testGateAlphanumeric() {\n        String gate = aviation.gate();\n        assertThat(gate).matches(\"[A-Z]\\\\d{1,3}\");\n    }\n\n    @Test\n    void testGateContextualDependency() {\n        String airport = aviation.airport();\n        String gate = aviation.gate();\n        assertThat(gate).isNotBlank();\n    }\n\n    @Test\n    void testGateFunctionalSimilarity() {\n        String flight = aviation.flight();\n        String gate = aviation.gate();\n        assertThat(gate).isNotBlank();\n    }\n\n    @Test\n    void testGateContextualSimilarity() {\n        String airline = aviation.airline();\n        String gate = aviation.gate();\n        assertThat(gate).isNotBlank();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Aviation aviation;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Aviation", "name": "aviation", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/Name_titleTest.java.Name_titleTest", "name": "Name_titleTest", "file_path": "src/test/java/net/datafaker/providers/base/Name_titleTest.java", "superclasses": "", "methods": ["[void]testTitle()"], "method_uris": ["src/test/java/net/datafaker/providers/base/Name_titleTest.java.Name_titleTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Name_titleTest {\n    private Name name;\n\n    @BeforeEach\n    public void setUp() {\n        BaseProviders baseProviders = new BaseFaker();\n        name = new Name(baseProviders);\n    }\n\n    @Test\n    void testTitle() {\n        String title = name.title();\n        assertThat(title).matches(\"([\\\\w']+\\\\.?( )?){3,}\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Name name;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Name", "name": "name", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/FinanceTest.java.FinanceTest", "name": "FinanceTest", "file_path": "src/test/java/net/datafaker/providers/base/FinanceTest.java", "superclasses": "", "methods": ["[void]creditCard()", "[void]nasdaqTicker()", "[void]nyseTicker()", "[void]bic()", "[void]iban()", "[void]ibanWithCountryCode()", "[void]ibanCountryCodes()", "[void]ibanWithAllCountryCodes()", "[void]creditCardWithType()", "[void]costaRicaIbanMustBeValid()", "[void]visaCard()", "[void]discoverCard()", "[void]usRoutingNumber()"], "method_uris": ["src/test/java/net/datafaker/providers/base/FinanceTest.java.FinanceTest.[void]assertCardLuhnDigit(String)", "src/test/java/net/datafaker/providers/base/FinanceTest.java.FinanceTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FinanceTest extends BaseFakerTest<BaseFaker> {\n\n    private final Finance finance = faker.finance();\n\n    @RepeatedTest(100)\n    void creditCard() {\n        final String creditCard = finance.creditCard();\n        assertCardLuhnDigit(creditCard);\n    }\n\n    private void assertCardLuhnDigit(String creditCard) {\n        final String creditCardStripped = creditCard.replace(\"-\", \"\");\n        assertThat(LuhnCheckDigit.LUHN_CHECK_DIGIT.isValid(creditCardStripped)).isTrue();\n    }\n\n    @RepeatedTest(10)\n    void nasdaqTicker() {\n        assertThat(finance.nasdaqTicker()).matches(\"[A-Z.-]+\");\n    }\n\n    @RepeatedTest(10)\n    void nyseTicker() {\n        assertThat(finance.nyseTicker()).matches(\"[A-Z.-]+\");\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(finance::stockMarket, \"finance.stock_market\"));\n    }\n\n    @Test\n    void bic() {\n        assertThat(finance.bic()).matches(\"([A-Z]){4}([A-Z]){2}([0-9A-Z]){2}([0-9A-Z]{3})?\");\n    }\n\n    @RepeatedTest(100)\n    void iban() {\n        assertThat(finance.iban()).matches(\"[A-Z]{2}\\\\p{Alnum}{13,30}\");\n    }\n\n    @Test\n    void ibanWithCountryCode() {\n        assertThat(finance.iban(\"DE\")).matches(\"DE\\\\d{20}\");\n    }\n\n    @Test\n    void ibanCountryCodes() {\n        assertThat(Finance.ibanSupportedCountries()).isNotEmpty().hasSizeGreaterThan(70);\n    }\n\n    @Test\n    void ibanWithAllCountryCodes() {\n        Set<String> ibanCountryCodes = Finance.ibanSupportedCountries();\n        for (String givenCountryCode : ibanCountryCodes) {\n            final String iban = finance.iban(givenCountryCode).toUpperCase(faker.getContext().getLocale());\n            assertThat(iban).isNotBlank();\n        }\n    }\n\n    @Test\n    void creditCardWithType() {\n        for (CreditCardType type : CreditCardType.values()) {\n            final String creditCard = finance.creditCard(type);\n            assertCardLuhnDigit(creditCard);\n        }\n    }\n\n    @Test\n    void costaRicaIbanMustBeValid() {\n        final String givenCountryCode = \"CR\";\n        final BaseFaker faker = new BaseFaker();\n        final String ibanFaker = finance.iban(givenCountryCode).toUpperCase(faker.getContext().getLocale());\n        assertThat(fr.marcwrobel.jbanking.iban.Iban.isValid(ibanFaker)).isTrue();\n    }\n\n    @RepeatedTest(100)\n    void visaCard() {\n        String creditCard = finance.creditCard(CreditCardType.VISA).replace(\"-\", \"\");\n        assertThat(creditCard).startsWith(\"4\").hasSize(16);\n    }\n\n    @RepeatedTest(100)\n    void discoverCard() {\n        String creditCard = finance.creditCard(CreditCardType.DISCOVER).replace(\"-\", \"\");\n        assertThat(creditCard).startsWith(\"6\").hasSize(16);\n    }\n\n    @RepeatedTest(100)\n    void usRoutingNumber() {\n        String rtn = finance.usRoutingNumber();\n        assertThat(rtn).matches(\"\\\\d{9}\");\n        int check = 0;\n        for (int index = 0; index < 3; index++) {\n            final int pos = index * 3;\n            check += Character.getNumericValue(rtn.charAt(pos)) * 3;\n            check += Character.getNumericValue(rtn.charAt(pos + 1)) * 7;\n            check += Character.getNumericValue(rtn.charAt(pos + 2));\n        }\n        assertThat(check % 10).isZero();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Finance finance = faker.finance();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Finance", "name": "finance = faker.finance()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/Color_hexTest.java.Color_hexTest", "name": "Color_hexTest", "file_path": "src/test/java/net/datafaker/providers/base/Color_hexTest.java", "superclasses": "", "methods": ["[void]testHexWithHashSign()", "[void]testHexWithoutHashSign()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Color_hexTest {\n\n    @Test\n    public void testHexWithHashSign() {\n        BaseProviders faker = mock(BaseProviders.class);\n        RandomService randomService = mock(RandomService.class);\n        when(faker.random()).thenReturn(randomService);\n        when(randomService.hex(6)).thenReturn(\"abcdef\");\n\n        Color color = new Color(faker);\n        String result = color.hex(true);\n        assertEquals(\"#abcdef\", result);\n    }\n\n    @Test\n    public void testHexWithoutHashSign() {\n        BaseProviders faker = mock(BaseProviders.class);\n        RandomService randomService = mock(RandomService.class);\n        when(faker.random()).thenReturn(randomService);\n        when(randomService.hex(6)).thenReturn(\"abcdef\");\n\n        Color color = new Color(faker);\n        String result = color.hex(false);\n        assertEquals(\"abcdef\", result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/PhoneNumberValidityFinderTest.java.PhoneNumberValidityFinderTest", "name": "PhoneNumberValidityFinderTest", "file_path": "src/test/java/net/datafaker/providers/base/PhoneNumberValidityFinderTest.java", "superclasses": "", "methods": ["[void]testAllCellPhoneForLocale()", "[void]testValidNumber()", "[void]testAllPhoneNumbers(Locale)"], "method_uris": ["src/test/java/net/datafaker/providers/base/PhoneNumberValidityFinderTest.java.PhoneNumberValidityFinderTest.[Phonenumber.PhoneNumber]parse(String,String)", "src/test/java/net/datafaker/providers/base/PhoneNumberValidityFinderTest.java.PhoneNumberValidityFinderTest.[Stream<Arguments>]allSupportedLocales()", "src/test/java/net/datafaker/providers/base/PhoneNumberValidityFinderTest.java.PhoneNumberValidityFinderTest.[Locale]createLocale(String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class PhoneNumberValidityFinderTest extends BaseFakerTest<BaseFaker> {\n    private static final int COUNT = 100;\n    private final PhoneNumberUtil util = PhoneNumberUtil.getInstance();\n\n    @RepeatedTest(COUNT)\n    void testAllCellPhoneForLocale() throws NumberParseException {\n        String language = \"en\";\n        String region = \"GB\";\n        BaseFaker localFaker = new BaseFaker(new Locale(language, region));\n\n        String generatedNumber = localFaker.phoneNumber().phoneNumber();\n        Phonenumber.PhoneNumber parsedNumber = util.parse(generatedNumber, region);\n\n        assertThat(util.isValidNumber(parsedNumber))\n            .as(() -> \"Generated phone number %s for region %s\".formatted(generatedNumber, region))\n            .isTrue();\n    }\n\n    @Test\n    void testValidNumber() throws NumberParseException {\n        String phoneNumber = \"0140 123456\";\n        String region = \"SE\";\n\n        Phonenumber.PhoneNumber parsedNumber = util.parse(phoneNumber, region);\n        assertThat(util.isValidNumber(parsedNumber)).isTrue();\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"allSupportedLocales\")\n    void testAllPhoneNumbers(Locale supportedLocale) throws NumberParseException {\n        BaseFaker f = new BaseFaker(supportedLocale);\n        PhoneNumber phoneNumberGenerator = f.phoneNumber();\n        for (int i = 0; i < COUNT; i++) {\n            String generatedNumber = phoneNumberGenerator.phoneNumber();\n            Phonenumber.PhoneNumber parsedNumber = parse(generatedNumber, phoneNumberGenerator.countryCodeIso2());\n\n            assertThat(util.isValidNumber(parsedNumber))\n                .as(() -> \"Generated phone number %s for locale %s (country: %s)\".formatted(generatedNumber, supportedLocale, phoneNumberGenerator.countryCodeIso2()))\n                .isTrue();\n        }\n    }\n\n    private Phonenumber.PhoneNumber parse(String generatedNumber, String countryCode) throws NumberParseException {\n        String normalizedNumber = \"IT\".equals(countryCode) || \"HU\".equals(countryCode) ? generatedNumber : generatedNumber.replaceFirst(\"^0(.+)\", \"$1\");\n        return util.parse(normalizedNumber, countryCode);\n    }\n\n    public Stream<Arguments> allSupportedLocales() {\n        return faker.locality().allSupportedLocales().stream()\n            .map(rawLocale -> Arguments.of(createLocale(rawLocale)));\n    }\n\n    private static Locale createLocale(String locale) {\n        if (locale.startsWith(\"_\")) {\n            return new Locale(\"en\", locale.substring(1).toUpperCase(ROOT));\n        }\n        if (locale.contains(\"-\")) {\n            String[] parts = locale.split(\"-\");\n            return new Locale(parts[0], parts[1]);\n        }\n        return new Locale(locale, \"\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final int COUNT = 100;", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "COUNT = 100", "syntax_pass": true}, {"attribute_expression": "private final PhoneNumberUtil util = PhoneNumberUtil.getInstance();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "PhoneNumberUtil", "name": "util = PhoneNumberUtil.getInstance()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/CodeTest.java.CodeTest", "name": "CodeTest", "file_path": "src/test/java/net/datafaker/providers/base/CodeTest.java", "superclasses": "", "methods": ["[void]isbn10DefaultIsNoSeparator()", "[void]isbn13DefaultIsNoSeparator()", "[void]testIsbn10()", "[void]testIsbn13()", "[void]testOverrides()", "[void]asin()", "[void]imei()", "[void]ean8()", "[void]gtin8()", "[void]ean13()", "[void]gtin13()", "[void]isbnGs1()", "[void]isbnGroup()", "[void]isbnRegistrant()"], "method_uris": ["src/test/java/net/datafaker/providers/base/CodeTest.java.CodeTest.[void]assertIsValidISBN10(String,ISBNValidator)", "src/test/java/net/datafaker/providers/base/CodeTest.java.CodeTest.[void]assertIsValidISBN13(String,ISBNValidator)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class CodeTest extends BaseFakerTest<BaseFaker> {\n\n    @RepeatedTest(100)\n    void isbn10DefaultIsNoSeparator() {\n        final BaseFaker faker = new BaseFaker();\n        String isbn10 = faker.code().isbn10();\n\n        final ISBNValidator isbnValidator = ISBNValidator.getInstance(false);\n        assertIsValidISBN10(isbn10, isbnValidator);\n        assertThat(isbn10).doesNotContain(\"-\");\n    }\n\n    @RepeatedTest(100)\n    void isbn13DefaultIsNoSeparator() {\n        final BaseFaker faker = new BaseFaker();\n        String isbn13 = faker.code().isbn13();\n\n        final ISBNValidator isbnValidator = ISBNValidator.getInstance(false);\n        assertIsValidISBN13(isbn13, isbnValidator);\n        assertThat(isbn13).doesNotContain(\"-\");\n    }\n\n    @RepeatedTest(100)\n    void testIsbn10() {\n        final BaseFaker faker = new BaseFaker();\n        final String isbn10NoSep = faker.code().isbn10(false);\n        final String isbn10Sep = faker.code().isbn10(true);\n        final ISBNValidator isbnValidator = ISBNValidator.getInstance(false);\n\n        assertThat(isbn10NoSep).hasSize(10);\n        assertIsValidISBN10(isbn10NoSep, isbnValidator);\n        assertThat(isbn10Sep).hasSize(13);\n        assertIsValidISBN10(isbn10Sep, isbnValidator);\n    }\n\n    @RepeatedTest(100)\n    void testIsbn13() {\n        final BaseFaker faker = new BaseFaker();\n        final String isbn13NoSep = faker.code().isbn13(false);\n        final String isbn13Sep = faker.code().isbn13(true);\n        final ISBNValidator isbnValidator = ISBNValidator.getInstance(false);\n\n        assertThat(isbn13NoSep).hasSize(13);\n        assertIsValidISBN13(isbn13NoSep, isbnValidator);\n\n        assertThat(isbn13Sep).hasSize(17);\n        assertIsValidISBN13(isbn13Sep, isbnValidator);\n    }\n\n    private void assertIsValidISBN10(String isbn10, ISBNValidator isbnValidator) {\n        assertThat(isbnValidator.isValidISBN10(isbn10)).describedAs(isbn10 + \" is valid\").isTrue();\n    }\n\n    private void assertIsValidISBN13(String isbn13, ISBNValidator isbnValidator) {\n        assertThat(isbnValidator.isValidISBN13(isbn13)).describedAs(isbn13 + \" is valid\").isTrue();\n    }\n\n    @RepeatedTest(100)\n    void testOverrides() {\n        BaseFaker faker = new BaseFaker(new Locale(\"test\"));\n\n        final String isbn10Sep = faker.code().isbn10(true);\n        final String isbn13Sep = faker.code().isbn13(true);\n\n        assertThat(isbn10Sep).matches(\"9971-\\\\d-\\\\d{4}-(\\\\d|X)\");\n\n        assertThat(isbn13Sep).matches(\"(333|444)-9971-\\\\d-\\\\d{4}-\\\\d\");\n    }\n\n    @Test\n    void asin() {\n        assertThat(faker.code().asin()).matches(\"B000([A-Z]|\\\\d){6}\");\n    }\n\n    @Test\n    void imei() {\n        String imei = faker.code().imei();\n\n        assertThat(imei).matches(\"\\\\A[\\\\d.:\\\\-\\\\s]+\\\\z\");\n        assertThat(LuhnCheckDigit.LUHN_CHECK_DIGIT.isValid(imei)).isTrue();\n    }\n\n    @Test\n    void ean8() {\n        assertThat(faker.code().ean8()).matches(\"\\\\d{8}\");\n    }\n\n    @Test\n    void gtin8() {\n        assertThat(faker.code().gtin8()).matches(\"\\\\d{8}\");\n    }\n\n    @Test\n    void ean13() {\n        String ean13 = faker.code().ean13();\n        assertThat(ean13).matches(\"\\\\d{13}\");\n        assertThat(EAN13CheckDigit.EAN13_CHECK_DIGIT.isValid(ean13)).isTrue();\n    }\n\n    @Test\n    void gtin13() {\n        String gtin13 = faker.code().gtin13();\n        assertThat(gtin13).matches(\"\\\\d{13}\");\n        assertThat(EAN13CheckDigit.EAN13_CHECK_DIGIT.isValid(gtin13)).isTrue();\n    }\n\n    @Test\n    void isbnGs1() {\n        String isbnGs1 = faker.code().isbnGs1();\n        assertThat(isbnGs1).matches(\"978|979\");\n    }\n\n    @Test\n    void isbnGroup() {\n        String isbnGroup = faker.code().isbnGroup();\n        assertThat(isbnGroup).matches(\"[01]\");\n    }\n\n    @RepeatedTest(100)\n    void isbnRegistrant() {\n        String isbnRegistrant = faker.code().isbnRegistrant();\n        assertThat(isbnRegistrant).matches(\"[0-9]{1,7}-[0-9]{1,6}\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/Number_randomNumberTest.java.Number_randomNumberTest", "name": "Number_randomNumberTest", "file_path": "src/test/java/net/datafaker/providers/base/Number_randomNumberTest.java", "superclasses": "", "methods": ["[void]testRandomNumber_numberOfDigitsLessThanOrEqualToZero()", "[void]testRandomNumber_strictTrue()", "[void]testRandomNumber_strictFalse()"], "method_uris": ["src/test/java/net/datafaker/providers/base/Number_randomNumberTest.java.Number_randomNumberTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Number_randomNumberTest {\n\n    private Number number;\n    private BaseFaker faker;\n\n    @BeforeEach\n    public void setUp() {\n        faker = Mockito.mock(BaseFaker.class);\n        when(faker.random()).thenReturn(Mockito.mock(RandomService.class));\n        number = new Number(faker);\n    }\n\n    @Test\n    public void testRandomNumber_numberOfDigitsLessThanOrEqualToZero() {\n        when(faker.random().nextInt(1)).thenReturn(0);\n        long result = number.randomNumber(0, true);\n        assertTrue(result == 0);\n    }\n\n    @Test\n    public void testRandomNumber_strictTrue() {\n        when(faker.random().nextLong(9000)).thenReturn(1234L);\n        long result = number.randomNumber(4, true);\n        assertTrue(result >= 1000 && result < 10000);\n    }\n\n    @Test\n    public void testRandomNumber_strictFalse() {\n        when(faker.random().nextLong(10000)).thenReturn(5678L);\n        long result = number.randomNumber(4, false);\n        assertTrue(result >= 0 && result < 10000);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Number number;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Number", "name": "number", "syntax_pass": true}, {"attribute_expression": "private BaseFaker faker;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BaseFaker", "name": "faker", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/AwsTest.java.AwsTest", "name": "AwsTest", "file_path": "src/test/java/net/datafaker/providers/base/AwsTest.java", "superclasses": "", "methods": ["[void]testAccountId()", "[void]testAcmARN()", "[void]testAlbARN()", "[void]testAlbTargetGroupARN()", "[void]testRoute53ZoneId()", "[void]testSecurityGroupId()", "[void]testSubnetId()", "[void]testVpcId()", "[void]testRegion()"], "method_uris": ["src/test/java/net/datafaker/providers/base/AwsTest.java.AwsTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class AwsTest extends BaseFakerTest<BaseFaker> {\n\n    @Test\n    void testAccountId() {\n        assertThat(faker.aws().accountId()).matches(\"^\\\\d{10}$\");\n    }\n\n    @Test\n    void testAcmARN() {\n        assertThat(faker.aws().acmARN()).matches(\"^arn:aws:acm:\\\\w+-\\\\w+-\\\\d:\\\\d{10}:certificate/[\\\\w\\\\-]+$\");\n    }\n\n    @Test\n    void testAlbARN() {\n        assertThat(faker.aws().albARN()).matches(\"^arn:aws:elasticloadbalancing:\\\\w+-\\\\w+-\\\\d:\\\\d{10}:loadbalancer/app/[\\\\w]+/\\\\w+$\");\n    }\n\n    @Test\n    void testAlbTargetGroupARN() {\n        assertThat(faker.aws().albTargetGroupARN()).matches(\"^arn:aws:elasticloadbalancing:\\\\w+-\\\\w+-\\\\d:\\\\d{10}:targetgroup/[\\\\w]+/\\\\w+$\");\n    }\n\n    @Test\n    void testRoute53ZoneId() {\n        assertThat(faker.aws().route53ZoneId()).matches(\"^\\\\w{21}$\");\n    }\n\n    @Test\n    void testSecurityGroupId() {\n        assertThat(faker.aws().securityGroupId()).matches(\"^sg-[0-9a-f]{17}$\");\n    }\n\n    @Test\n    void testSubnetId() {\n        assertThat(faker.aws().subnetId()).matches(\"^subnet-[0-9a-f]{17}$\");\n    }\n\n    @Test\n    void testVpcId() {\n        assertThat(faker.aws().vpcId()).matches(\"^vpc-[0-9a-f]{17}$\");\n    }\n\n    @Test\n    void testRegion() {\n        String region = faker.aws().region();\n        assertThat(region).matches(\"^[a-z]{2}-(south|east|north|west|northeast|central|southeast)-\\\\d$\");\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        Aws aws = faker.aws();\n        return List.of(TestSpec.of(aws::service, \"aws.services\"));\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/OptionsTest.java.OptionsTest", "name": "OptionsTest", "file_path": "src/test/java/net/datafaker/providers/base/OptionsTest.java", "superclasses": "", "methods": ["[void]testOptionWithArray()", "[void]testOptionWithVarargsString()", "[void]testOptionWithVarargs()", "[void]testSubset()", "[void]testSubsetWithDuplicate()", "[void]testEmptySubset()", "[void]testOptionWithEnum()", "[void]testNextArrayElement()", "[void]testNextListElement()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class OptionsTest extends BaseFakerTest<BaseFaker> {\n\n    private final String[] options = {\"A\", \"B\", \"C\"};\n    private final Options opt = faker.options();\n\n    @Test\n    void testOptionWithArray() {\n        assertThat(opt.option(options)).isIn((Object[]) options);\n    }\n\n    @Test\n    void testOptionWithVarargsString() {\n        assertThat(opt.option(\"A\", \"B\", \"C\")).isIn((Object[]) options);\n    }\n\n    @Test\n    void testOptionWithVarargs() {\n        Integer[] integerOptions = {1, 3, 4, 5};\n        assertThat(opt.option(1, 3, 4, 5)).isIn((Object[]) integerOptions);\n        Long[] longOptions = {1L, 3L, 4L, 5L};\n        assertThat(opt.option(longOptions)).isIn((Object[]) longOptions);\n        Short[] shortOptions = {1, 3, 4};\n        assertThat(opt.option(shortOptions)).isIn((Object[]) shortOptions);\n        Byte[] byteOptions = {(byte) 11, (byte) 13, (byte) 14};\n        assertThat(opt.option(byteOptions)).isIn((Object[]) byteOptions);\n        Double[] doubleOptions = {1.1d, 13d, 14.2d};\n        assertThat(opt.option(doubleOptions)).isIn((Object[]) doubleOptions);\n        Float[] floatOptions = {1.2f, 13f, 14.2f};\n        assertThat(opt.option(floatOptions)).isIn((Object[]) floatOptions);\n        BigInteger[] bigIntegerOptions = {BigInteger.ONE, BigInteger.TEN, BigInteger.ZERO};\n        assertThat(opt.option(bigIntegerOptions)).isIn((Object[]) bigIntegerOptions);\n        BigDecimal[] bigDecimalOptions = {BigDecimal.ONE, BigDecimal.TEN, BigDecimal.ZERO};\n        assertThat(opt.option(bigDecimalOptions)).isIn((Object[]) bigDecimalOptions);\n        Boolean[] booleanOptions = {true, false};\n        assertThat(opt.option(booleanOptions)).isIn((Object[]) booleanOptions);\n    }\n\n    @Test\n    void testSubset() {\n        Integer[] integerOptions = {1, 3, 4, 5};\n        assertThat(opt.subset(1, integerOptions))\n            .doesNotContainAnyElementsOf(List.of(2, 6))\n            .containsAnyElementsOf(List.of(integerOptions));\n        Long[] longOptions = {1L, 3L, 4L, 5L};\n        assertThat(opt.subset(1, longOptions))\n            .doesNotContainAnyElementsOf(List.of(2L, 6L))\n            .containsAnyElementsOf(List.of(longOptions));\n\n        assertThat(opt.subset(longOptions.length, longOptions))\n            .doesNotContainAnyElementsOf(List.of(2L, 6L))\n            .containsAnyElementsOf(List.of(longOptions)).hasSameSizeAs(longOptions);\n\n        assertThat(opt.subset(longOptions.length + 1, longOptions))\n            .doesNotContainAnyElementsOf(List.of(2L, 6L))\n            .containsAnyElementsOf(List.of(longOptions)).hasSameSizeAs(longOptions);\n\n        String[] strOptions = {\"1\", \"2\", \"3\"};\n        assertThat(opt.subset(strOptions.length + 1, strOptions))\n            .doesNotContainAnyElementsOf(List.of(\"q\", \"w\"))\n            .containsAnyElementsOf(List.of(strOptions)).hasSameSizeAs(strOptions);\n\n        assertThat(opt.subset(1, strOptions))\n            .doesNotContainAnyElementsOf(List.of(\"q\", \"w\"))\n            .containsAnyElementsOf(List.of(strOptions))\n            .hasSize(1);\n\n    }\n\n    @Test\n    void testSubsetWithDuplicate() {\n        Object[] array = {1, 1, 2, 2};\n        assertThat(opt.subset(5, array)).hasSize(2);\n        String[] strArray = {\"a\", \"s\", \"s\", \"a\"};\n        assertThat(opt.subset(Integer.MAX_VALUE, strArray)).hasSize(2);\n    }\n\n    @Test\n    void testEmptySubset() {\n        Object[] array = {1, 2, 3};\n        assertThat(opt.subset(0, array)).isEmpty();\n        assertThatThrownBy(() -> opt.subset(-1, array))\n            .isInstanceOf(IllegalArgumentException.class);\n        String[] strArray = {\"1\", \"2\", \"3\"};\n        assertThat(opt.subset(0, strArray)).isEmpty();\n        assertThatThrownBy(() -> opt.subset(-1, strArray)).isInstanceOf(IllegalArgumentException.class);\n    }\n\n    @Test\n    void testOptionWithEnum() {\n        assertThat(opt.option(Day.class)).isIn((Object[]) Day.values());\n    }\n\n    @Test\n    void testNextArrayElement() {\n        Integer[] array = {1, 2, 3, 5, 8, 13, 21};\n\n        for (int i = 1; i < 10; i++) {\n            assertThat(opt.nextElement(array)).isIn((Object[]) array);\n        }\n    }\n\n    @Test\n    void testNextListElement() {\n        List<Integer> list = List.of(1, 2, 3, 5, 8, 13, 21);\n        for (int i = 1; i < 10; i++) {\n            assertThat(opt.nextElement(list)).isIn(list);\n        }\n    }\n\n    enum Day {\n        MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final String[] options = {\"A\", \"B\", \"C\"};", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String[]", "name": "options = {\"A\", \"B\", \"C\"}", "syntax_pass": true}, {"attribute_expression": "private final Options opt = faker.options();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Options", "name": "opt = faker.options()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/TeamTest.java.TeamTest", "name": "TeamTest", "file_path": "src/test/java/net/datafaker/providers/base/TeamTest.java", "superclasses": "", "methods": ["[void]testName()", "[void]testState()", "[void]testStateWithZaLocale()"], "method_uris": ["src/test/java/net/datafaker/providers/base/TeamTest.java.TeamTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class TeamTest extends BaseFakerTest<BaseFaker> {\n\n    private final Team team = faker.team();\n\n    @Test\n    void testName() {\n        assertThat(team.name()).matches(\"(\\\\w+( )?){2,4}\");\n    }\n\n    @Test\n    void testState() {\n        assertThat(faker.team().state()).matches(\"(\\\\w+( )?){1,2}\");\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(team::creature, \"team.creature\"),\n            TestSpec.of(team::sport, \"team.sport\", \"(?:\\\\p{L}|\\\\s)+\"));\n    }\n\n    @Test\n    void testStateWithZaLocale() {\n        BaseFaker zaFaker = new BaseFaker(new Locale(\"en\", \"ZA\"));\n        assertThat(zaFaker.team().state()).isNotEmpty();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Team team = faker.team();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Team", "name": "team = faker.team()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/Twitter_createdTimeTest.java.Twitter_createdTimeTest", "name": "Twitter_createdTimeTest", "file_path": "src/test/java/net/datafaker/providers/base/Twitter_createdTimeTest.java", "superclasses": "", "methods": ["[void]testCreatedTimeForward()", "[void]testCreatedTimeBackward()"], "method_uris": ["src/test/java/net/datafaker/providers/base/Twitter_createdTimeTest.java.Twitter_createdTimeTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Twitter_createdTimeTest {\n\n    private Twitter twitter;\n    private RandomService randomService;\n\n    @BeforeEach\n    public void setUp() {\n        BaseProviders baseProviders = Mockito.mock(BaseProviders.class);\n        randomService = Mockito.mock(RandomService.class);\n        when(baseProviders.random()).thenReturn(randomService);\n        twitter = new Twitter(baseProviders);\n    }\n\n    @Test\n    public void testCreatedTimeForward() {\n        Date base = new Date(1000000L);\n        Date constraints = new Date(2000000L);\n        when(randomService.nextDouble()).thenReturn(0.5);\n\n        Date result = twitter.createdTime(true, base, constraints);\n\n        assertTrue(result.after(base) && result.before(constraints));\n    }\n\n    @Test\n    public void testCreatedTimeBackward() {\n        Date base = new Date(2000000L);\n        Date constraints = new Date(1000000L);\n        when(randomService.nextDouble()).thenReturn(0.5);\n\n        Date result = twitter.createdTime(false, base, constraints);\n\n        assertTrue(result.before(base) && result.after(constraints));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Twitter twitter;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Twitter", "name": "twitter", "syntax_pass": true}, {"attribute_expression": "private RandomService randomService;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RandomService", "name": "randomService", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/DurationTest.java.DurationTest", "name": "DurationTest", "file_path": "src/test/java/net/datafaker/providers/base/DurationTest.java", "superclasses": "", "methods": ["[void]testDurationSeconds()", "[void]testDurationMinutes()", "[void]testDurationHours()", "[void]testDurationDays()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class DurationTest extends BaseFakerTest<BaseFaker> {\n\n    @Test\n    void testDurationSeconds() {\n        final long maxSeconds = 55;\n        Duration randomDuration = faker.duration().atMostSeconds(maxSeconds);\n        Duration lowerBound = Duration.ofSeconds(0);\n        Duration upperBound = Duration.ofSeconds(maxSeconds);\n\n        assertThat(randomDuration).isBetween(lowerBound, upperBound);\n    }\n\n    @Test\n    void testDurationMinutes() {\n        final long maxMins = 45;\n        Duration randomDuration = faker.duration().atMostMinutes(maxMins);\n        Duration lowerBound = Duration.ofMinutes(0);\n        Duration upperBound = Duration.ofMinutes(maxMins);\n\n        assertThat(randomDuration).isBetween(lowerBound, upperBound);\n    }\n\n    @Test\n    void testDurationHours() {\n        final long maxHours = 35;\n        Duration randomDuration = faker.duration().atMostHours(maxHours);\n        Duration lowerBound = Duration.ofHours(0);\n        Duration upperBound = Duration.ofHours(maxHours);\n\n        assertThat(randomDuration).isBetween(lowerBound, upperBound);\n    }\n\n    @Test\n    void testDurationDays() {\n        final long maxDays = 40;\n        Duration randomDuration = faker.duration().atMostDays(maxDays);\n        Duration lowerBound = Duration.ofDays(0);\n        Duration upperBound = Duration.ofDays(maxDays);\n\n        assertThat(randomDuration).isBetween(lowerBound, upperBound);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/BarcodeTest.java.BarcodeTest", "name": "BarcodeTest", "file_path": "src/test/java/net/datafaker/providers/base/BarcodeTest.java", "superclasses": "", "methods": ["[void]type()", "[void]testEan13()", "[void]testGtin13()", "[void]testEan8()", "[void]testGtin8()", "[void]testGtin14Length()", "[void]testGtin12Length()", "[void]testGtin12CheckSum()", "[void]testGtin14CheckSum()", "[void]testEan8CheckSum()", "[void]testEan13CheckSum()"], "method_uris": ["src/test/java/net/datafaker/providers/base/BarcodeTest.java.BarcodeTest.[boolean]isBarcodeValid(long)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class BarcodeTest extends BaseFakerTest<BaseFaker> {\n\n    @Test\n    void type() {\n        assertThat(faker.barcode().type()).matches(\"(Code(128|39|93))|([EJ])AN(-\\\\d{1,2})*|Codabar|UCC|UPC(-([AE]))*|IS([BS])N|ITF|\" +\n            \"Ames\\\\sCode|NW-7|Monarch|Code\\\\s2\\\\sof\\\\s7|Rationalized|ANSI/AIM BC3-1995|USD-4|\" +\n            \"GS1 Databar|MSI Plessey\");\n    }\n\n    private static boolean isBarcodeValid(long barcode) {\n        char[] array = String.valueOf(barcode).toCharArray();\n        int sum = 0;\n        for (int i = 0; i < array.length; i++) {\n            int digit = Integer.parseInt(String.valueOf(array[i]));\n            if ((i + 1) % 2 == 0)\n                sum += digit;\n            else\n                sum = sum + (digit * 3);\n        }\n        return String.valueOf(sum).endsWith(\"0\");\n    }\n\n    @Test\n    void testEan13() {\n        assertThat(String.valueOf(faker.barcode().ean13())).matches(\"[0-9]{13}\");\n    }\n\n    @Test\n    void testGtin13() {\n        assertThat(String.valueOf(faker.barcode().gtin13())).matches(\"[0-9]{13}\");\n    }\n\n    @Test\n    void testEan8() {\n        assertThat(String.valueOf(faker.barcode().ean8())).matches(\"[0-9]{8}\");\n    }\n\n    @Test\n    void testGtin8() {\n        assertThat(String.valueOf(faker.barcode().gtin8())).matches(\"[0-9]{8}\");\n    }\n\n    @Test\n    void testGtin14Length() {\n        assertThat(String.valueOf(faker.barcode().gtin14())).matches(\"[0-9]{14}\");\n    }\n\n    @Test\n    void testGtin12Length() {\n        assertThat(String.valueOf(faker.barcode().gtin12())).matches(\"[0-9]{12}\");\n    }\n\n    @Test\n    void testGtin12CheckSum() {\n        long barcode = faker.barcode().gtin12();\n        assertThat(BarcodeTest.isBarcodeValid(barcode)).isTrue();\n    }\n\n    @Test\n    void testGtin14CheckSum() {\n        long barcode = faker.barcode().gtin14();\n        assertThat(BarcodeTest.isBarcodeValid(barcode)).isTrue();\n    }\n\n    @Test\n    void testEan8CheckSum() {\n        long barcode = faker.barcode().ean8();\n        assertThat(BarcodeTest.isBarcodeValid(barcode)).isTrue();\n    }\n\n    @Test\n    void testEan13CheckSum() {\n        long barcode = faker.barcode().ean13();\n        char[] array = String.valueOf(barcode).toCharArray();\n        int sum = 0;\n        for (int i = 0; i < array.length; i++) {\n            int digit = Integer.parseInt(String.valueOf(array[i]));\n            if ((i + 1) % 2 == 0)\n                sum = sum + digit * 3;\n            else\n                sum = sum + digit;\n        }\n\n        assertThat(String.valueOf(sum)).endsWith(\"0\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/Internet_slugTest.java.Internet_slugTest", "name": "Internet_slugTest", "file_path": "src/test/java/net/datafaker/providers/base/Internet_slugTest.java", "superclasses": "", "methods": ["[void]testSlugWithNonNullWordsAndGlue()", "[void]testSlugWithNullWordsAndNonNullGlue()", "[void]testSlugWithNonNullWordsAndNullGlue()", "[void]testSlugWithNullWordsAndNullGlue()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Internet_slugTest {\n\n    private final BaseFaker faker = new BaseFaker();\n\n    @Test\n    public void testSlugWithNonNullWordsAndGlue() {\n        Internet internet = new Internet(faker);\n        List<String> words = List.of(\"hello\", \"world\");\n        String glue = \"-\";\n        String expected = \"hello-world\";\n        String result = internet.slug(words, glue);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testSlugWithNullWordsAndNonNullGlue() {\n        Internet internet = new Internet(faker);\n        String glue = \"-\";\n        String result = internet.slug(null, glue);\n        assertEquals(2, result.split(glue).length);\n    }\n\n    @Test\n    public void testSlugWithNonNullWordsAndNullGlue() {\n        Internet internet = new Internet(faker);\n        List<String> words = List.of(\"hello\", \"world\");\n        String expected = \"hello_world\";\n        String result = internet.slug(words, null);\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void testSlugWithNullWordsAndNullGlue() {\n        Internet internet = new Internet(faker);\n        String result = internet.slug(null, null);\n        assertEquals(2, result.split(\"_\").length);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final BaseFaker faker = new BaseFaker();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BaseFaker", "name": "faker = new BaseFaker()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/DateAndTimeTest.java.DateAndTimeTest", "name": "DateAndTimeTest", "file_path": "src/test/java/net/datafaker/providers/base/DateAndTimeTest.java", "superclasses": "", "methods": ["[void]testFutureDate()", "[void]testFutureDateWithMinimum()", "[void]testPastDateWithMinimum()", "[void]testPastDateWithReferenceDate()", "[void]testPastDate()", "[void]testBetween()", "[void]testBetweenWithMaskReturningString()", "[void]testBetweenDateAsArgument()", "[void]testBetweenThenLargerThanNow()", "[void]testBirthday()", "[void]testBirthdayWithAges()", "[void]birthdayWithMask()", "[void]futureWithMask()", "[void]pastWithMask()", "[void]periodTest()", "[void]invalidDuration(String)", "[void]durationTest(long,long,ChronoUnit)", "[void]durationTest(long,ChronoUnit)", "[void]durationTest(long,long,String)", "[void]durationTest(long,String)", "[void]maxLessThanMinPeriod(Period,Period)"], "method_uris": ["src/test/java/net/datafaker/providers/base/DateAndTimeTest.java.DateAndTimeTest.[Stream<Arguments>]generateDurationsFromStringWithMaxOnly()", "src/test/java/net/datafaker/providers/base/DateAndTimeTest.java.DateAndTimeTest.[Stream<Arguments>]generateDurationsFromStringWithMinMax()", "src/test/java/net/datafaker/providers/base/DateAndTimeTest.java.DateAndTimeTest.[Stream<Arguments>]generateDurationsWithMaxOnly()", "src/test/java/net/datafaker/providers/base/DateAndTimeTest.java.DateAndTimeTest.[Stream<Arguments>]generateDurationsWithMinMax()", "src/test/java/net/datafaker/providers/base/DateAndTimeTest.java.DateAndTimeTest.[Stream<Arguments>]generatePeriod()"], "overrides": null, "attributes": [], "class_docstring": "\n@author pmiklos\n", "original_string": "class DateAndTimeTest extends BaseFakerTest<BaseFaker> {\n\n    @Test\n    void testFutureDate() {\n        Timestamp now = new Timestamp(System.currentTimeMillis());\n        DateAndTime date = faker.date();\n        for (int i = 0; i < 1000; i++) {\n            Date future = date.future(1, TimeUnit.SECONDS, now);\n            assertThat(future.getTime()).isGreaterThan(now.getTime())\n                .isLessThan(now.getTime() + 1000);\n        }\n    }\n\n    @Test\n    void testFutureDateWithMinimum() {\n        final Date now = new Date();\n        DateAndTime date = faker.date();\n        for (int i = 0; i < 1000; i++) {\n            Date future = date.future(5, 4, TimeUnit.SECONDS);\n            assertThat(future.getTime()).isGreaterThan(now.getTime())\n                .isLessThan(now.getTime() + 5500)\n                .isGreaterThan(now.getTime() + 3500);\n        }\n    }\n\n    @Test\n    void testPastDateWithMinimum() {\n        DateAndTime date = faker.date();\n        for (int i = 0; i < 1000; i++) {\n            final long now = System.currentTimeMillis();\n            Date past = date.past(5, 4, TimeUnit.SECONDS);\n            assertThat(past.getTime()).isLessThan(now)\n                .isGreaterThan(now - 5500)\n                .isLessThan(now - 3500);\n        }\n    }\n\n    @Test\n    void testPastDateWithReferenceDate() {\n        Date now = new Date();\n        DateAndTime date = faker.date();\n        for (int i = 0; i < 1000; i++) {\n            Date past = date.past(1, TimeUnit.SECONDS, now);\n            assertThat(past.getTime()).isLessThan(now.getTime())\n                .isGreaterThan(now.getTime() - 1000);\n        }\n    }\n\n    @Test\n    void testPastDate() {\n        Date now = new Date();\n        Date past = faker.date().past(100, TimeUnit.SECONDS);\n        assertThat(past.getTime()).isLessThan(now.getTime());\n    }\n\n    @Test\n    void testBetween() {\n        Timestamp now = new Timestamp(System.currentTimeMillis());\n        Timestamp then = new Timestamp(System.currentTimeMillis() + 1000);\n        DateAndTime dateAndTime = faker.date();\n        for (int i = 0; i < 1000; i++) {\n            Date date = dateAndTime.between(now, then);\n            assertThat(date.getTime()).isLessThan(then.getTime())\n                .isGreaterThanOrEqualTo(now.getTime());\n        }\n    }\n\n    @Test\n    void testBetweenWithMaskReturningString() {\n        Timestamp now = new Timestamp(System.currentTimeMillis());\n        Timestamp then = new Timestamp(System.currentTimeMillis() + 1000);\n        String pattern = \"YYYY MM.dd mm:hh:ss\";\n\n        DateTimeFormatter.ofPattern(pattern).parse(faker.date().between(now, then, pattern));\n    }\n\n    @Test\n    void testBetweenDateAsArgument() {\n        faker.date().between(new Date(), new Date());\n    }\n\n    @Test\n    void testBetweenThenLargerThanNow() {\n        Timestamp now = new Timestamp(System.currentTimeMillis());\n        Timestamp then = new Timestamp(System.currentTimeMillis() + 1000);\n        assertThatThrownBy(() -> faker.date().between(then, now))\n            .isInstanceOf(IllegalArgumentException.class)\n            .hasMessage(\"Invalid date range: the upper bound date (%s) is before the lower bound (%s)\".formatted(now, then));\n    }\n\n    @Test\n    void testBirthday() {\n        final LocalDateTime localDate = LocalDateTime.now();\n        final long to = localDate.minusYears(18).truncatedTo(ChronoUnit.DAYS).atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();\n        final long from = localDate.minusYears(65).truncatedTo(ChronoUnit.DAYS).atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();\n        final DateAndTime date = faker.date();\n        for (int i = 0; i < 5000; i++) {\n            Timestamp birthday = date.birthday();\n            assertThat(birthday.getTime()).isLessThan(to)\n                .isGreaterThanOrEqualTo(from);\n        }\n    }\n\n    @Test\n    void testBirthdayWithAges() {\n        LocalDateTime nw = LocalDateTime.of(LocalDate.now(), LocalTime.MIDNIGHT);\n        final Number number = faker.number();\n        final DateAndTime date = faker.date();\n        final ZoneRules rules = ZoneId.systemDefault().getRules();\n        for (int i = 0; i < 5000; i++) {\n            int minAge = number.numberBetween(1, 99);\n            int maxAge = number.numberBetween(minAge, 100);\n\n            LocalDateTime from = nw.minusYears(maxAge);\n            LocalDateTime to = nw.minusYears(minAge);\n\n            Timestamp birthday = date.birthday(minAge, maxAge);\n\n            assertThat(birthday)\n                .isBetween(Timestamp.from(from.toInstant(rules.getOffset(from))),\n                    Timestamp.from(to.toInstant(rules.getOffset(to))), true, true);\n        }\n    }\n\n    @Test\n    void birthdayWithMask() {\n        String pattern = \"YYYY MM.dd\";\n        DateTimeFormatter.ofPattern(pattern).parse(faker.date().birthday(1, 50, pattern));\n    }\n\n    @Test\n    void futureWithMask() {\n        String pattern = \"YYYY MM.dd mm:hh:ss\";\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(pattern);\n        DateAndTime date = faker.date();\n        dateTimeFormatter.parse(date.future(1, TimeUnit.HOURS, pattern));\n        dateTimeFormatter.parse(date.future(20, 1, TimeUnit.HOURS, pattern));\n        dateTimeFormatter.parse(date.future(20, TimeUnit.HOURS, new Date(), pattern));\n    }\n\n    @Test\n    void pastWithMask() {\n        String pattern = \"YYYY MM.dd mm:hh:ss\";\n        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(pattern);\n        DateAndTime date = faker.date();\n        dateTimeFormatter.parse(date.past(1, TimeUnit.DAYS, pattern));\n        dateTimeFormatter.parse(date.past(20, 1, TimeUnit.DAYS, pattern));\n        dateTimeFormatter.parse(date.past(1, TimeUnit.DAYS, new Date(), pattern));\n    }\n\n    @Test\n    void periodTest() {\n        Period maxPeriod = Period.of(3, 2, 1);\n        Period minPeriod = Period.of(2, 1, 0);\n        Period period = faker.date().period(minPeriod, maxPeriod);\n\n        assertThat((period.getYears() * 12 + period.getMonths()) * 30 + period.getDays())\n            .isBetween((minPeriod.getYears() * 12 + minPeriod.getMonths()) * 30 + minPeriod.getDays(),\n                (maxPeriod.getYears() * 12 + maxPeriod.getMonths()) * 30 + maxPeriod.getDays());\n    }\n\n    @ParameterizedTest\n    @ValueSource(strings = {\"null\", \"\", \"month\", \"year\", \"week\"})\n    void invalidDuration(String invalid) {\n        assertThatThrownBy(() -> faker.date().duration(faker.random().nextLong(), invalid))\n            .isInstanceOf(IllegalArgumentException.class);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateDurationsWithMinMax\")\n    void durationTest(long minValue, long maxValue, ChronoUnit unit) {\n        Duration generated = faker.date().duration(minValue, maxValue, unit);\n        Duration min = Duration.of(minValue, unit);\n        Duration max = Duration.of(maxValue, unit);\n        assertThat(min)\n            .as(\"Duration must be equal or greater than min value\")\n            .isLessThanOrEqualTo(generated);\n        assertThat(max.compareTo(generated) > 0 || minValue >= maxValue && max.equals(generated))\n            .as(\"Duration must be lower than max value\").isTrue();\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateDurationsWithMaxOnly\")\n    void durationTest(long maxValue, ChronoUnit unit) {\n        Duration generated = faker.date().duration(maxValue, unit);\n        Duration max = Duration.of(maxValue, unit);\n        assertThat(max.compareTo(generated) > 0 || maxValue == 0)\n            .as(\"Duration must be lower than max value\")\n            .isTrue();\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateDurationsFromStringWithMinMax\")\n    void durationTest(long minValue, long maxValue, String unit) {\n        Duration generated = faker.date().duration(minValue, maxValue, unit);\n        Duration min = Duration.of(minValue, DateAndTime.str2durationUnit(unit));\n        Duration max = Duration.of(maxValue, DateAndTime.str2durationUnit(unit));\n        assertThat(min).as(\"Duration must be equal or greater than min value\").isLessThanOrEqualTo(generated);\n        assertThat(max.compareTo(generated) > 0 || minValue >= maxValue && max.equals(generated))\n            .as(\"Duration must be lower than max value\")\n            .isTrue();\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateDurationsFromStringWithMaxOnly\")\n    void durationTest(long maxValue, String unit) {\n        Duration generated = faker.date().duration(maxValue, unit);\n        Duration max = Duration.of(maxValue, DateAndTime.str2durationUnit(unit));\n        assertThat(max.compareTo(generated) > 0 || maxValue == 0).as(\"Duration must be lower than max value\").isTrue();\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generatePeriod\")\n    void maxLessThanMinPeriod(Period min, Period max) {\n        assertThatThrownBy(() -> faker.date().period(min, max))\n            .isInstanceOf(IllegalArgumentException.class);\n    }\n\n    private static Stream<Arguments> generateDurationsFromStringWithMaxOnly() {\n        return Stream.of(\n            Arguments.of(0, \"days\"),\n            Arguments.of(100, \"days\"),\n            Arguments.of(123, \"DAY\"),\n            Arguments.of(456, \"HOUR\"),\n            Arguments.of(1234, \"hours\"),\n            Arguments.of(43, \"minutes\"),\n            Arguments.of(78, \"minute\"),\n            Arguments.of(56, \"seconds\"),\n            Arguments.of(34, \"second\"),\n            Arguments.of(786, \"millis\"),\n            Arguments.of(879, \"milli\"),\n            Arguments.of(8729, \"nano\"),\n            Arguments.of(8739, \"nanos\")\n        );\n    }\n\n    private static Stream<Arguments> generateDurationsFromStringWithMinMax() {\n        return Stream.of(\n            Arguments.of(123, 123, \"days\"),\n            Arguments.of(12, 123, \"days\"),\n            Arguments.of(21, 32, \"DAY\"),\n            Arguments.of(45, 100, \"HOUR\"),\n            Arguments.of(23, 100, \"hours\"),\n            Arguments.of(15, 400, \"minutes\"),\n            Arguments.of(14, 500, \"minute\"),\n            Arguments.of(32, 54, \"seconds\"),\n            Arguments.of(65, 98, \"second\"),\n            Arguments.of(76, 100, \"millis\"),\n            Arguments.of(87, 100, \"milli\"),\n            Arguments.of(76, 100, \"micros\"),\n            Arguments.of(87, 100, \"micro\"),\n            Arguments.of(874, 1300, \"nano\"),\n            Arguments.of(879, 1030, \"nanos\")\n        );\n    }\n\n    private static Stream<Arguments> generateDurationsWithMaxOnly() {\n        return Stream.of(\n            Arguments.of(0, ChronoUnit.DAYS),\n            Arguments.of(100, ChronoUnit.DAYS),\n            Arguments.of(456, ChronoUnit.HOURS),\n            Arguments.of(43, ChronoUnit.MINUTES),\n            Arguments.of(78, ChronoUnit.SECONDS),\n            Arguments.of(786, ChronoUnit.MILLIS),\n            Arguments.of(786, ChronoUnit.MICROS),\n            Arguments.of(8729, ChronoUnit.NANOS)\n        );\n    }\n\n    private static Stream<Arguments> generateDurationsWithMinMax() {\n        return Stream.of(\n            Arguments.of(123, 123, ChronoUnit.DAYS),\n            Arguments.of(12, 123, ChronoUnit.HOURS),\n            Arguments.of(15, 400, ChronoUnit.MINUTES),\n            Arguments.of(65, 98, ChronoUnit.SECONDS),\n            Arguments.of(76, 100, ChronoUnit.MILLIS),\n            Arguments.of(879, 1030, ChronoUnit.MICROS),\n            Arguments.of(879, 1030, ChronoUnit.NANOS)\n        );\n    }\n\n    private static Stream<Arguments> generatePeriod() {\n        return Stream.of(\n            Arguments.of(Period.of(1, 1, 1), Period.of(0, 1, 1)),\n            Arguments.of(Period.of(1, 1, 3), Period.of(1, 1, 2)),\n            Arguments.of(Period.of(1, 2, 1), Period.of(1, 1, 1))\n        );\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/RestaurantTest.java.RestaurantTest", "name": "RestaurantTest", "file_path": "src/test/java/net/datafaker/providers/base/RestaurantTest.java", "superclasses": "", "methods": ["[void]namePrefix()", "[void]name()"], "method_uris": ["src/test/java/net/datafaker/providers/base/RestaurantTest.java.RestaurantTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class RestaurantTest extends BaseFakerTest<BaseFaker> {\n\n    private final Restaurant restaurant = faker.restaurant();\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(restaurant::nameSuffix, \"restaurant.name_suffix\"),\n                TestSpec.of(restaurant::type, \"restaurant.type\"),\n                TestSpec.of(restaurant::description, \"restaurant.description\"),\n                TestSpec.of(restaurant::review, \"restaurant.review\"));\n    }\n\n    @RepeatedTest(100)\n    void namePrefix() {\n        assertThat(restaurant.namePrefix())\n            .isNotEmpty()\n            .doesNotContain(\"#\", \"?\") // make sure bothify is applied\n            .matches(\"[A-Z0-9].*\");   // and that bothify only uses uppercase characters\n    }\n\n    @RepeatedTest(100)\n    void name() {\n        assertThat(restaurant.name())\n            .isNotEmpty()\n            .doesNotContain(\"#\", \"?\") // make sure bothify is applied\n            .matches(\"[A-Z0-9].*\");   // and that bothify only uses uppercase characters\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Restaurant restaurant = faker.restaurant();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Restaurant", "name": "restaurant = faker.restaurant()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/WeatherTest.java.WeatherTest", "name": "WeatherTest", "file_path": "src/test/java/net/datafaker/providers/base/WeatherTest.java", "superclasses": "", "methods": ["[void]temperatureCelsius()", "[void]temperatureFahrenheit()", "[void]temperatureCelsiusInRange()", "[void]temperatureFahrenheitInRange()"], "method_uris": ["src/test/java/net/datafaker/providers/base/WeatherTest.java.WeatherTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class WeatherTest extends BaseFakerTest<BaseFaker> {\n\n    private final Weather weather = faker.weather();\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(weather::description, \"weather.description\"));\n    }\n\n    @Test\n    void temperatureCelsius() {\n        assertThat(weather.temperatureCelsius()).matches(\"-?\\\\d+\u00b0C\");\n    }\n\n    @Test\n    void temperatureFahrenheit() {\n        assertThat(weather.temperatureFahrenheit()).matches(\"-?\\\\d+\u00b0F\");\n    }\n\n    @Test\n    void temperatureCelsiusInRange() {\n        for (int i = 1; i < 100; i++) {\n            assertThat(weather.temperatureCelsius(-5, 5)).matches(\"-?[0-5]\u00b0C\");\n        }\n    }\n\n    @Test\n    void temperatureFahrenheitInRange() {\n        for (int i = 1; i < 100; i++) {\n            assertThat(weather.temperatureFahrenheit(-5, 5)).matches(\"-?[0-5]\u00b0F\");\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Weather weather = faker.weather();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Weather", "name": "weather = faker.weather()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/IdNumberTest.java.IdNumberTest", "name": "IdNumberTest", "file_path": "src/test/java/net/datafaker/providers/base/IdNumberTest.java", "superclasses": "", "methods": ["[void]testValid()", "[void]testInvalid()", "[void]testSsnValid()", "[void]testSsnInvalid()", "[void]testValidSwedishSsn()", "[void]testInvalidSwedishSsn()", "[void]southAfrica_valid()", "[void]southAfrica_invalid()", "[void]testSingaporeanFin()", "[void]testSingaporeanFinBefore2000()", "[void]testSingaporeanUin()", "[void]testSingaporeanUinBefore2000()", "[void]testPeselNumber()", "[void]estonianPersonalCode_valid()", "[void]estonianPersonalCode_invalid()", "[void]albanianPersonalCode_valid()", "[void]albanianPersonalCode_invalid()", "[void]moldovaPersonalCode_valid(String)", "[void]moldovaPersonalCode_invalid(String)", "[void]bulgarianPersonalCode_valid()", "[void]bulgarianPersonalCode_invalid()", "[void]macedonianPersonalCode_valid()", "[void]romanianPersonalCode_valid()", "[void]macedonianPersonalCode_invalid()", "[void]ukrainianUznr_valid()", "[void]ukrainianUznr_invalid()"], "method_uris": ["src/test/java/net/datafaker/providers/base/IdNumberTest.java.IdNumberTest.[AbstractStringAssert<?>]assertThatPin(String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class IdNumberTest extends BaseFakerTest<BaseFaker> {\n\n    private static final Faker SWEDISH = new Faker(new Locale(\"sv\", \"SE\"));\n    private static final Faker SOUTH_AFRICA = new Faker(new Locale(\"en\", \"ZA\"));\n    private static final Faker US = new Faker(new Locale(\"en\", \"US\"));\n    private static final Faker ESTONIAN = new Faker(new Locale(\"et\", \"EE\"));\n    private static final Faker ALBANIAN = new Faker(new Locale(\"sq\", \"AL\"));\n    private static final Faker BULGARIAN = new Faker(new Locale(\"bg\", \"BG\"));\n    private static final Faker MACEDONIAN = new Faker(new Locale(\"mk\", \"MK\"));\n    private static final Faker ROMANIAN = new Faker(new Locale(\"ro\", \"RO\"));\n    private static final Faker UKRAINIAN = new Faker(new Locale(\"uk\", \"UA\"));\n\n    private static final Pattern SWEDISH_ID_NUMBER_PATTERN = Pattern.compile(\"\\\\d{6}[-+]\\\\d{4}\");\n    private static final Pattern UKRAINIAN_UNZR_PATTERN = Pattern.compile(\"\\\\d{8}-\\\\d{5}\");\n    private static final Pattern SOUTH_AFRICA_ID_NUMBER_PATTERN = Pattern.compile(\"[0-9]{10}([01])8[0-9]\");\n\n    @Test\n    void testValid() {\n        assertThat(faker.idNumber().valid()).matches(\"[0-8]\\\\d{2}-\\\\d{2}-\\\\d{4}\");\n    }\n\n    @Test\n    void testInvalid() {\n        assertThat(faker.idNumber().invalid()).matches(\"[0-9]\\\\d{2}-\\\\d{2}-\\\\d{4}\");\n    }\n\n    @RepeatedTest(100)\n    void testSsnValid() {\n        assertThat(faker.idNumber().ssnValid()).matches(\"[0-8]\\\\d{2}-\\\\d{2}-\\\\d{4}\");\n        assertThat(US.idNumber().valid()).matches(\"[0-8]\\\\d{2}-\\\\d{2}-\\\\d{4}\");\n    }\n\n    @RepeatedTest(100)\n    void testSsnInvalid() {\n        String invalidSsn = US.idNumber().invalid();\n        if (!invalidSsn.startsWith(\"9\")) {\n            assertThat(invalidSsn).matches(\"[0-8]\\\\d{2}-\\\\d{2}-\\\\d{4}\");\n        }\n    }\n\n    @RepeatedTest(100)\n    void testValidSwedishSsn() {\n        String actual = SWEDISH.idNumber().valid();\n        assertThat(actual).matches(SWEDISH_ID_NUMBER_PATTERN);\n        assertThat(SwedenIdNumber.isValidSwedishSsn(actual)).isTrue();\n    }\n\n    @RepeatedTest(100)\n    void testInvalidSwedishSsn() {\n        String actual = SWEDISH.idNumber().invalid();\n        assertThat(actual).matches(SWEDISH_ID_NUMBER_PATTERN);\n        assertThat(SwedenIdNumber.isValidSwedishSsn(actual)).isFalse();\n    }\n\n    @RepeatedTest(100)\n    void southAfrica_valid() {\n        String actual = SOUTH_AFRICA.idNumber().valid();\n        assertThat(actual).matches(SOUTH_AFRICA_ID_NUMBER_PATTERN);\n        assertThat(SouthAfricanIdNumber.isValidEnZASsn(actual)).isTrue();\n    }\n\n    @RepeatedTest(100)\n    void southAfrica_invalid() {\n        assertThat(SOUTH_AFRICA.idNumber().invalid()).matches(SOUTH_AFRICA_ID_NUMBER_PATTERN);\n    }\n\n    @RepeatedTest(100)\n    void testSingaporeanFin() {\n        assertThat(faker.idNumber().singaporeanFin()).matches(\"G[0-9]{7}[A-Z]\");\n    }\n\n    @RepeatedTest(100)\n    void testSingaporeanFinBefore2000() {\n        assertThat(faker.idNumber().singaporeanFinBefore2000()).matches(\"F[0-9]{7}[A-Z]\");\n    }\n\n    @RepeatedTest(100)\n    void testSingaporeanUin() {\n        assertThat(faker.idNumber().singaporeanUin()).matches(\"T[0-9]{7}[A-Z]\");\n    }\n\n    @RepeatedTest(100)\n    void testSingaporeanUinBefore2000() {\n        assertThat(faker.idNumber().singaporeanUinBefore2000()).matches(\"S[0-9]{7}[A-Z]\");\n    }\n\n    @RepeatedTest(100)\n    void testPeselNumber() {\n        assertThat(faker.idNumber().peselNumber()).matches(\"[0-9]{11}\");\n    }\n\n    @RepeatedTest(100)\n    void estonianPersonalCode_valid() {\n        assertThatPin(ESTONIAN.idNumber().valid()).matches(\"[1-6][0-9]{10}\");\n    }\n\n    @RepeatedTest(100)\n    void estonianPersonalCode_invalid() {\n        assertThatPin(ESTONIAN.idNumber().invalid()).matches(\"[1-6][0-9]{10}\");\n    }\n\n    @RepeatedTest(100)\n    void albanianPersonalCode_valid() {\n        String pin = ALBANIAN.idNumber().valid();\n        assertThatPin(pin).matches(\"\\\\w\\\\d{8}\\\\w\");\n        assertThat(parseInt(pin.substring(2, 4)) % 50)\n            .as(() -> \"Valid PIN %s should have month number between 1..12 (for males) or 51..62 (for females)\".formatted(pin))\n            .isBetween(1, 12);\n    }\n\n    @RepeatedTest(100)\n    void albanianPersonalCode_invalid() {\n        String pin = ALBANIAN.idNumber().invalid();\n        assertThatPin(pin).matches(\"\\\\w\\\\d{8}\\\\w\");\n        assertThat(parseInt(pin.substring(2, 4)))\n            .as(() -> \"Invalid PIN %s should have month greater than (any month + 50)\".formatted(pin))\n            .isGreaterThan(62);\n    }\n\n    @ParameterizedTest\n    @ValueSource(strings = {\"en\", \"ro\", \"ru\"})\n    void moldovaPersonalCode_valid(String language) {\n        final var faker = new Faker(new Locale(language, \"MD\"));\n        for (int i = 0; i < 100; i++) {\n            String pin = faker.idNumber().valid();\n            assertThatPin(pin).matches(\"\\\\d{13}\");\n        }\n    }\n\n    @ParameterizedTest\n    @ValueSource(strings = {\"en\", \"ro\", \"ru\"})\n    void moldovaPersonalCode_invalid(String language) {\n        final var faker = new Faker(new Locale(language, \"MD\"));\n        for (int i = 0; i < 100; i++) {\n            String pin = faker.idNumber().invalid();\n            assertThatPin(pin).matches(\"\\\\d{13}\");\n        }\n    }\n\n    @RepeatedTest(100)\n    void bulgarianPersonalCode_valid() {\n        String pin = BULGARIAN.idNumber().valid();\n        assertThatPin(pin).matches(\"\\\\d{10}\");\n    }\n\n    @RepeatedTest(100)\n    void bulgarianPersonalCode_invalid() {\n        String pin = BULGARIAN.idNumber().invalid();\n        assertThatPin(pin).matches(\"\\\\d{10}\");\n    }\n\n    @RepeatedTest(100)\n    void macedonianPersonalCode_valid() {\n        String pin = MACEDONIAN.idNumber().valid();\n        assertThatPin(pin).matches(\"\\\\d{13}\");\n    }\n\n    @RepeatedTest(100)\n    void romanianPersonalCode_valid() {\n        String pin = ROMANIAN.idNumber().valid();\n        assertThatPin(pin).matches(\"\\\\d{13}\");\n    }\n\n    @RepeatedTest(100)\n    void macedonianPersonalCode_invalid() {\n        String pin = MACEDONIAN.idNumber().invalid();\n        assertThatPin(pin).matches(\"\\\\d{13}\");\n    }\n\n    @RepeatedTest(100)\n    void ukrainianUznr_valid() {\n        assertThatPin(UKRAINIAN.idNumber().valid()).matches(UKRAINIAN_UNZR_PATTERN);\n    }\n\n    @RepeatedTest(100)\n    void ukrainianUznr_invalid() {\n        assertThatPin(UKRAINIAN.idNumber().invalid()).matches(UKRAINIAN_UNZR_PATTERN);\n    }\n\n    private static AbstractStringAssert<?> assertThatPin(String pin) {\n        return assertThat(pin)\n            .as(() -> \"PIN: %s\".formatted(pin));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Faker SWEDISH = new Faker(new Locale(\"sv\", \"SE\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "SWEDISH = new Faker(new Locale(\"sv\", \"SE\"))", "syntax_pass": true}, {"attribute_expression": "private static final Faker SOUTH_AFRICA = new Faker(new Locale(\"en\", \"ZA\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "SOUTH_AFRICA = new Faker(new Locale(\"en\", \"ZA\"))", "syntax_pass": true}, {"attribute_expression": "private static final Faker US = new Faker(new Locale(\"en\", \"US\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "US = new Faker(new Locale(\"en\", \"US\"))", "syntax_pass": true}, {"attribute_expression": "private static final Faker ESTONIAN = new Faker(new Locale(\"et\", \"EE\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "ESTONIAN = new Faker(new Locale(\"et\", \"EE\"))", "syntax_pass": true}, {"attribute_expression": "private static final Faker ALBANIAN = new Faker(new Locale(\"sq\", \"AL\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "ALBANIAN = new Faker(new Locale(\"sq\", \"AL\"))", "syntax_pass": true}, {"attribute_expression": "private static final Faker BULGARIAN = new Faker(new Locale(\"bg\", \"BG\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "BULGARIAN = new Faker(new Locale(\"bg\", \"BG\"))", "syntax_pass": true}, {"attribute_expression": "private static final Faker MACEDONIAN = new Faker(new Locale(\"mk\", \"MK\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "MACEDONIAN = new Faker(new Locale(\"mk\", \"MK\"))", "syntax_pass": true}, {"attribute_expression": "private static final Faker ROMANIAN = new Faker(new Locale(\"ro\", \"RO\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "ROMANIAN = new Faker(new Locale(\"ro\", \"RO\"))", "syntax_pass": true}, {"attribute_expression": "private static final Faker UKRAINIAN = new Faker(new Locale(\"uk\", \"UA\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "UKRAINIAN = new Faker(new Locale(\"uk\", \"UA\"))", "syntax_pass": true}, {"attribute_expression": "private static final Pattern SWEDISH_ID_NUMBER_PATTERN = Pattern.compile(\"\\\\d{6}[-+]\\\\d{4}\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "SWEDISH_ID_NUMBER_PATTERN = Pattern.compile(\"\\\\d{6}[-+]\\\\d{4}\")", "syntax_pass": true}, {"attribute_expression": "private static final Pattern UKRAINIAN_UNZR_PATTERN = Pattern.compile(\"\\\\d{8}-\\\\d{5}\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "UKRAINIAN_UNZR_PATTERN = Pattern.compile(\"\\\\d{8}-\\\\d{5}\")", "syntax_pass": true}, {"attribute_expression": "private static final Pattern SOUTH_AFRICA_ID_NUMBER_PATTERN = Pattern.compile(\"[0-9]{10}([01])8[0-9]\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "SOUTH_AFRICA_ID_NUMBER_PATTERN = Pattern.compile(\"[0-9]{10}([01])8[0-9]\")", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/DrivingLicenseTest.java.DrivingLicenseTest", "name": "DrivingLicenseTest", "file_path": "src/test/java/net/datafaker/providers/base/DrivingLicenseTest.java", "superclasses": "", "methods": ["[void]drivingLicense(LicensePattern)"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DrivingLicenseTest extends BaseFakerTest<BaseFaker> {\n    private final DrivingLicense drivingLicense = getFaker().drivingLicense();\n\n    private enum LicensePattern {\n        AL(\"AL\", \"^\\\\d{6,8}$\"),\n        AK(\"AK\", \"^\\\\d{6,7}$\"),\n        AZ(\"AZ\", \"^([A-Z]?)\\\\d{8,9}$\"),\n        AR(\"AR\", \"^\\\\d{8,9}$\"),\n        CA(\"CA\", \"^[A-Z]\\\\d{7}$\"),\n        CO(\"CO\", \"(^[0-9]{9}$)|(^[A-Z]{1}[0-9]{3,6}$)|(^[A-Z]{2}[0-9]{2,5}$)\"),\n        CT(\"CT\", \"^\\\\d{9}$\"),\n        DE(\"DE\", \"^\\\\d{6,7}$\"),\n        DC(\"DC\", \"(^\\\\d{7}$)|(^\\\\d{9}$)\"),\n        FL(\"FL\", \"^[A-Z]\\\\d{12}$\"),\n        GA(\"GA\", \"^\\\\d{7,9}$\"),\n        HI(\"HI\", \"(^[A-Z]\\\\d{8}$)|(^\\\\d{9}$)\"),\n        ID(\"ID\", \"(^[A-Z]{2}\\\\d{6}[A-Z]$)|(^\\\\d{9}$)\"),\n        IL(\"IL\", \"^[A-Z]\\\\d{11,12}$\"),\n        IN(\"IN\", \"(^[A-Z]\\\\d{9}$)|(^\\\\d{9,10}$)\"),\n        IA(\"IA\", \"^(\\\\d{9}|(\\\\d{3}[A-Z]{2}\\\\d{4}))$\"),\n        KS(\"KS\", \"(^([A-Z]\\\\d){2}[A-Z]$)|(^[A-Z]\\\\d{8}$)|(^\\\\d{9}$)\"),\n        KY(\"KY\", \"(^[A-Z]\\\\d{8,9}$)|(^\\\\d{9}$)\"),\n        LA(\"LA\", \"^\\\\d{8,9}$\"),\n        MA(\"MA\", \"(^[A-Z]\\\\d{8}$)|(^\\\\d{9}$)\"),\n        MD(\"MD\", \"^[A-Z]\\\\d{12}$\"),\n        ME(\"ME\", \"(^\\\\d{7,8}$)|(^\\\\d{7}[A-Z]$)\"),\n        MI(\"MI\", \"(^[A-Z]\\\\d{10}$)|(^[A-Z]\\\\d{12}$)\"),\n        MN(\"MN\", \"^[A-Z]\\\\d{12}$\"),\n        MO(\"MO\", \"(^[A-Z]\\\\d{5,9}$)|(^[A-Z]\\\\d{6}R$)|(^\\\\d{3}[A-Z]\\\\d{6}$)|(^\\\\d{8}[A-Z]{2}$)|(^\\\\d{9}[A-Z]$)|(^\\\\d{9}$)\"),\n        MS(\"MS\", \"^\\\\d{9}$\"),\n        MT(\"MT\", \"(^[A-Z]\\\\d{8}$)|(^\\\\d{13}$)|(^\\\\d{14}$)|(^\\\\d{9}$)\"),\n        NC(\"NC\", \"^\\\\d{10,12}$\"),\n        ND(\"ND\", \"(^[A-Z]{3}\\\\d{6}$)|(^\\\\d{9}$)\"),\n        NE(\"NE\", \"^[A-Z]\\\\d{6,8}$\"),\n        NH(\"NH\", \"(^\\\\d{2}[A-Z]{3}\\\\d{5}$)\"),\n        NJ(\"NJ\", \"^[A-Z]\\\\d{14}$\"),\n        NM(\"NM\", \"^\\\\d{8,9}$\"),\n        NV(\"NV\", \"(^\\\\d{9,10}$)|(^\\\\d{12}$)|(^X\\\\d{8}$)\"),\n        NY(\"NY\", \"(^[A-Z]\\\\d{7}$)|(^[A-Z]\\\\d{18}$)|(^\\\\d{8}$)|(^\\\\d{9}$)|(^\\\\d{16}$)|(^[A-Z]{8}$)\"),\n        OH(\"OH\", \"(^[A-Z]\\\\d{8}$)|(^[A-Z]{2}\\\\d{7}$)|(^\\\\d{8}$)\"),\n        OK(\"OK\", \"(^[A-Z]\\\\d{9}$)|(^\\\\d{9}$)\"),\n        OR(\"OR\", \"^\\\\d{8,9}$\"),\n        PA(\"PA\", \"^\\\\d{8}$\"),\n        RI(\"RI\", \"^(\\\\d{7}$)|(^[A-Z]\\\\d{6}$)\"),\n        SC(\"SC\", \"^\\\\d{8,11}$\"),\n        SD(\"SD\", \"(^\\\\d{8,10}$)|(^\\\\d{12}$)\"),\n        TN(\"TN\", \"^\\\\d{7,9}$\"),\n        TX(\"TX\", \"^\\\\d{7,8}$\"),\n        UT(\"UT\", \"^\\\\d{9,10}$\"),\n        VA(\"VA\", \"(^[A-Z]\\\\d{8,11}$)|(^\\\\d{9}$)\"),\n        VT(\"VT\", \"(^\\\\d{8}$)|(^\\\\d{7}A$)\"),\n        WA(\"WA\", \"(^[A-Z]{7}\\\\d{5}$)|(^[A-Z]{8}\\\\d{4}$)|(^[A-Z]{9}\\\\d{3}$)|(^[A-Z]{10}\\\\d{2}$)|(^[A-Z]{11}\\\\d$)|(^[A-Z]{12}$)|(^[A-Z]{7}\\\\d[A-Z]\\\\d[A-Z]\\\\d$)|(^[A-Z]{7}\\\\d{2}[A-Z]{2}\\\\d$)\"),\n        WI(\"WI\", \"^[A-Z]\\\\d{13}$\"),\n        WV(\"WV\", \"(^\\\\d{7}$)|(^[A-Z]{1,2}\\\\d{5,6}$)\"),\n        WY(\"WY\", \"^\\\\d{9,10}$\");\n        private final String abbv;\n        private final Pattern pattern;\n\n        LicensePattern(String abbv, String regex) {\n            this.abbv = abbv;\n            this.pattern = Pattern.compile(regex);\n        }\n    }\n\n\n    @ParameterizedTest\n    @EnumSource(LicensePattern.class)\n    void drivingLicense(LicensePattern licensePattern) {\n        for (int i = 0; i < 100; i++) {\n            assertThat(drivingLicense.drivingLicense(licensePattern.abbv)).matches(licensePattern.pattern);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final DrivingLicense drivingLicense = getFaker().drivingLicense();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "DrivingLicense", "name": "drivingLicense = getFaker().drivingLicense()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/FileTest.java.FileTest", "name": "FileTest", "file_path": "src/test/java/net/datafaker/providers/base/FileTest.java", "superclasses": "", "methods": ["[void]testExtension()", "[void]testMimeTypeFormat()", "[void]testFileName()", "[void]testFileNameSpecifyExtension()", "[void]testFileNameSpecifyDir()", "[void]testFileNameSpecifySeparator()", "[void]testFileNameSpecifyName()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FileTest extends BaseFakerTest<BaseFaker> {\n\n    @RepeatedTest(10)\n    void testExtension() {\n        assertThat(faker.file().extension())\n            .matches(\"(flac|mp3|wav|bmp|gif|jpeg|jpg|png|tiff|css|csv|html|js|json|txt|mp4|avi|mov|webm|doc|docx|xls|xlsx|ppt|pptx|odt|ods|odp|pages|numbers|key|pdf)\");\n    }\n\n    @RepeatedTest(10)\n    void testMimeTypeFormat() {\n        assertThat(faker.file().mimeType()).matches(\".+/.+\");\n    }\n\n    @RepeatedTest(10)\n    void testFileName() {\n        assertThat(faker.file().fileName()).matches(\"([a-z\\\\-_]+)([\\\\\\\\/])([a-z\\\\-_]+)\\\\.([a-z0-9]+)\");\n    }\n\n    @Test\n    void testFileNameSpecifyExtension() {\n        assertThat(faker.file().fileName(null, null, \"txt\", null))\n            .matches(\"([a-z\\\\-_]+)([\\\\\\\\/])([a-z\\\\-_]+)\\\\.txt\");\n    }\n\n    @Test\n    void testFileNameSpecifyDir() {\n        assertThat(faker.file().fileName(\"my_dir\", null, null, null))\n            .matches(\"my_dir([\\\\\\\\/])([a-z\\\\-_]+)\\\\.([a-z0-9]+)\");\n    }\n\n    @Test\n    void testFileNameSpecifySeparator() {\n        assertThat(faker.file().fileName(null, null, null, \"\\\\\"))\n            .matches(\"([a-z\\\\-_]+)\\\\\\\\([a-z\\\\-_]+)\\\\.([a-z0-9]+)\");\n    }\n\n    @Test\n    void testFileNameSpecifyName() {\n        assertThat(faker.file().fileName(null, \"da_name\", null, null))\n            .matches(\"([a-z\\\\-_]+)([\\\\\\\\/])da_name\\\\.([a-z0-9]+)\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/HashingTest.java.HashingTest", "name": "HashingTest", "file_path": "src/test/java/net/datafaker/providers/base/HashingTest.java", "superclasses": "", "methods": ["[void]testMd2()", "[void]testMd5()", "[void]testSha1()", "[void]testSha256()", "[void]testSha384()", "[void]testSha512()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class HashingTest extends BaseFakerTest<BaseFaker> {\n\n    @Test\n    void testMd2() {\n        assertThat(faker.hashing().md2()).matches(\"\\\\b[a-fA-F\\\\d]{32}\\\\b\");\n    }\n\n    @Test\n    void testMd5() {\n        assertThat(faker.hashing().md5()).matches(\"\\\\b[a-fA-F\\\\d]{32}\\\\b\");\n    }\n\n    @Test\n    void testSha1() {\n        assertThat(faker.hashing().sha1()).matches(\"\\\\b[a-fA-F\\\\d]{40}\\\\b\");\n    }\n\n    @Test\n    void testSha256() {\n        assertThat(faker.hashing().sha256()).matches(\"\\\\b[a-fA-F\\\\d]{64}\\\\b\");\n    }\n\n    @Test\n    void testSha384() {\n        assertThat(faker.hashing().sha384()).matches(\"\\\\b[a-fA-F\\\\d]{96}\\\\b\");\n    }\n\n    @Test\n    void testSha512() {\n        assertThat(faker.hashing().sha512()).matches(\"\\\\b[a-fA-F\\\\d]{128}\\\\b\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/DateAndTime_betweenTest.java.DateAndTime_betweenTest", "name": "DateAndTime_betweenTest", "file_path": "src/test/java/net/datafaker/providers/base/DateAndTime_betweenTest.java", "superclasses": "", "methods": ["[void]testBetweenValidRange()", "[void]testBetweenEqualDates()", "[void]testBetweenInvalidRange()", "[void]testBetweenWithBirthdayDates()", "[void]testBetweenWithFutureDates()", "[void]testBetweenWithPastDates()"], "method_uris": ["src/test/java/net/datafaker/providers/base/DateAndTime_betweenTest.java.DateAndTime_betweenTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DateAndTime_betweenTest {\n    private DateAndTime dateAndTime;\n\n    @BeforeEach\n    public void setUp() {\n        BaseFaker faker = new BaseFaker();\n        dateAndTime = new DateAndTime(faker);\n    }\n\n    @Test\n    public void testBetweenValidRange() {\n        Timestamp from = new Timestamp(System.currentTimeMillis() - TimeUnit.DAYS.toMillis(1));\n        Timestamp to = new Timestamp(System.currentTimeMillis() + TimeUnit.DAYS.toMillis(1));\n\n        Timestamp result = dateAndTime.between(from, to);\n\n        assertTrue(result.getTime() >= from.getTime() && result.getTime() < to.getTime());\n    }\n\n    @Test\n    public void testBetweenEqualDates() {\n        Timestamp from = new Timestamp(System.currentTimeMillis());\n        Timestamp to = new Timestamp(System.currentTimeMillis());\n\n        Timestamp result = dateAndTime.between(from, to);\n\n        assertEquals(from, result);\n    }\n\n    @Test\n    public void testBetweenInvalidRange() {\n        Timestamp from = new Timestamp(System.currentTimeMillis() + TimeUnit.DAYS.toMillis(1));\n        Timestamp to = new Timestamp(System.currentTimeMillis() - TimeUnit.DAYS.toMillis(1));\n\n        assertThrows(IllegalArgumentException.class, () -> {\n            dateAndTime.between(from, to);\n        });\n    }\n\n    @Test\n    public void testBetweenWithBirthdayDates() {\n        Timestamp from = dateAndTime.birthday(18, 65);\n        Timestamp to = new Timestamp(System.currentTimeMillis());\n\n        Timestamp result = dateAndTime.between(from, to);\n\n        assertTrue(result.getTime() >= from.getTime() && result.getTime() < to.getTime());\n    }\n\n    @Test\n    public void testBetweenWithFutureDates() {\n        Timestamp from = new Timestamp(System.currentTimeMillis());\n        Timestamp to = dateAndTime.future(10, TimeUnit.DAYS);\n\n        Timestamp result = dateAndTime.between(from, to);\n\n        assertTrue(result.getTime() >= from.getTime() && result.getTime() < to.getTime());\n    }\n\n    @Test\n    public void testBetweenWithPastDates() {\n        Timestamp from = dateAndTime.past(10, TimeUnit.DAYS);\n        Timestamp to = new Timestamp(System.currentTimeMillis());\n\n        Timestamp result = dateAndTime.between(from, to);\n\n        assertTrue(result.getTime() >= from.getTime() && result.getTime() < to.getTime());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DateAndTime dateAndTime;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DateAndTime", "name": "dateAndTime", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/BookTest.java.BookTest", "name": "BookTest", "file_path": "src/test/java/net/datafaker/providers/base/BookTest.java", "superclasses": "", "methods": ["[void]testAuthor()"], "method_uris": ["src/test/java/net/datafaker/providers/base/BookTest.java.BookTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class BookTest extends BaseFakerTest<BaseFaker> {\n\n    private final Book book = faker.book();\n\n    @Test\n    void testAuthor() {\n        assertThat(book.author()).matches(\"([\\\\w']+\\\\.? ?){2,4}\");\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(() -> faker.book().title(), \"book.title\", \"([\\\\p{L}'\\\\-?]+[!,]? ?){2,9}\"),\n            TestSpec.of(() -> faker.book().publisher(), \"book.publisher\", \"([\\\\p{L}'&\\\\-]+[,.]? ?){1,5}\"),\n            TestSpec.of(() -> faker.book().genre(), \"book.genre\", \"([\\\\w/]+ ?){2,4}\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Book book = faker.book();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Book", "name": "book = faker.book()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/AzureTest.java.AzureTest", "name": "AzureTest", "file_path": "src/test/java/net/datafaker/providers/base/AzureTest.java", "superclasses": "", "methods": ["[void]testRegion()", "[void]testAccountId()", "[void]testTenantId()", "[void]testResourceGroup()", "[void]testManagementGroup()", "[void]testApplicationGateway()", "[void]testBastionHost()", "[void]testFirewall()", "[void]testLoadBalancer()", "[void]testNetworkSecurityGroup()", "[void]testVirtualNetwork()", "[void]testVirtualWan()", "[void]testAppServiceEnvironment()", "[void]testAppServicePlan()", "[void]testLoadTesting()", "[void]testStaticWebApp()", "[void]testVirtualMachine()", "[void]testStorageAccount()", "[void]testContainerRegistry()", "[void]testContainerApps()", "[void]testContainerAppsEnvironment()", "[void]testContainerInstance()", "[void]testCosmosDBDatabase()", "[void]testSqlDatabase()", "[void]testMysqlDatabase()", "[void]testPostgreSQLDatabase()", "[void]testServiceBus()", "[void]testServiceBusQueue()", "[void]testServiceBusTopic()", "[void]testKeyVault()", "[void]testLogAnalytics()", "[void]testSpringApps()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class AzureTest extends BaseFakerTest<BaseFaker> {\n\n    @Test\n    void testRegion() {\n        String region = faker.azure().region();\n        assertThat(region).matches(\"(eastus|eastus2|southcentralus|westus2|westus3|australiaeast|southeastasia|northeurope|swedencentral|uksouth|westeurope|centralus|southafricanorth|centralindia|eastasia|japaneast|koreacentral|canadacentral|francecentral|germanywestcentral|norwayeast|switzerlandnorth|uaenorth|brazilsouth|eastus2euap|qatarcentral|centralusstage|eastusstage|eastus2stage|northcentralusstage|southcentralusstage|westusstage|westus2stage|asia|asiapacific|australia|brazil|canada|europe|france|germany|global|india|japan|korea|norway|singapore|southafrica|switzerland|uae|uk|unitedstates|unitedstateseuap|eastasiastage|southeastasiastage|eastusstg|southcentralusstg|northcentralus|westus|jioindiawest|centraluseuap|westcentralus|southafricawest|australiacentral|australiacentral2|australiasoutheast|japanwest|jioindiacentral|koreasouth|southindia|westindia|canadaeast|francesouth|germanynorth|norwaywest|switzerlandwest|ukwest|uaecentral|brazilsoutheast)\");\n    }\n\n    @Test\n    void testAccountId() {\n        assertThat(faker.azure().subscriptionId()).matches(\"[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\");\n    }\n\n    @Test\n    void testTenantId() {\n        assertThat(faker.azure().tenantId()).matches(\"[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}\");\n    }\n\n    @Test\n    void testResourceGroup() {\n        assertThat(faker.azure().resourceGroup()).matches(\"^rg-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testManagementGroup() {\n        assertThat(faker.azure().managementGroup()).matches(\"^mg-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testApplicationGateway() {\n        assertThat(faker.azure().applicationGateway()).matches(\"^agw-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testBastionHost() {\n        assertThat(faker.azure().bastionHost()).matches(\"^bas-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testFirewall() {\n        assertThat(faker.azure().firewall()).matches(\"^afw-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testLoadBalancer() {\n        assertThat(faker.azure().loadBalancer()).matches(\"^lbi-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testNetworkSecurityGroup() {\n        assertThat(faker.azure().networkSecurityGroup()).matches(\"^nsg-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testVirtualNetwork() {\n        assertThat(faker.azure().virtualNetwork()).matches(\"^vnet-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testVirtualWan() {\n        assertThat(faker.azure().virtualWan()).matches(\"^vwan-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testAppServiceEnvironment() {\n        assertThat(faker.azure().appServiceEnvironment()).matches(\"^ase-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testAppServicePlan() {\n        assertThat(faker.azure().appServicePlan()).matches(\"^asp-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testLoadTesting() {\n        assertThat(faker.azure().loadTesting()).matches(\"^lt-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testStaticWebApp() {\n        assertThat(faker.azure().staticWebApp()).matches(\"^stapp-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testVirtualMachine() {\n        assertThat(faker.azure().virtualMachine()).matches(\"^vm-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testStorageAccount() {\n        assertThat(faker.azure().storageAccount()).matches(\"^st-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testContainerRegistry() {\n        assertThat(faker.azure().containerRegistry()).matches(\"^cr-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testContainerApps() {\n        assertThat(faker.azure().containerApps()).matches(\"^ca-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testContainerAppsEnvironment() {\n        assertThat(faker.azure().containerAppsEnvironment()).matches(\"^cae-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testContainerInstance() {\n        assertThat(faker.azure().containerInstance()).matches(\"^ci-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testCosmosDBDatabase() {\n        assertThat(faker.azure().cosmosDBDatabase()).matches(\"^cosmos-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testSqlDatabase() {\n        assertThat(faker.azure().sqlDatabase()).matches(\"^sql-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testMysqlDatabase() {\n        assertThat(faker.azure().mysqlDatabase()).matches(\"^mysql-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testPostgreSQLDatabase() {\n        assertThat(faker.azure().postgreSQLDatabase()).matches(\"^psql-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testServiceBus() {\n        assertThat(faker.azure().serviceBus()).matches(\"^sb-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testServiceBusQueue() {\n        assertThat(faker.azure().serviceBusQueue()).matches(\"^sbq-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testServiceBusTopic() {\n        assertThat(faker.azure().serviceBusTopic()).matches(\"^sbt-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testKeyVault() {\n        assertThat(faker.azure().keyVault()).matches(\"^kv-[0-9a-f]{16}$\");\n    }\n\n    @Test\n    void testLogAnalytics() {\n        assertThat(faker.azure().logAnalytics()).matches(\"^log-[0-9a-f]{16}$\");\n    }\n    \n    @Test\n    void testSpringApps() {\n        assertThat(faker.azure().springApps()).matches(\"^sa-[0-9a-f]{16}$\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/SpaceTest.java.SpaceTest", "name": "SpaceTest", "file_path": "src/test/java/net/datafaker/providers/base/SpaceTest.java", "superclasses": "", "methods": ["[void]distanceMeasurement()"], "method_uris": ["src/test/java/net/datafaker/providers/base/SpaceTest.java.SpaceTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class SpaceTest extends BaseFakerTest<BaseFaker> {\n\n    private static final String SPACE_REGEX = \"(?:\\\\w+ ?){2,3}\";\n    \n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        Space space = faker.space();\n        return List.of(TestSpec.of(space::planet, \"space.planet\", SPACE_REGEX),\n            TestSpec.of(space::moon, \"space.moon\", SPACE_REGEX),\n            TestSpec.of(space::galaxy, \"space.galaxy\", SPACE_REGEX),\n            TestSpec.of(space::nebula, \"space.nebula\", SPACE_REGEX),\n            TestSpec.of(space::starCluster, \"space.star_cluster\", \"(?:\\\\w+[ -]?){1,3}\"),\n            TestSpec.of(space::constellation, \"space.constellation\", SPACE_REGEX),\n            TestSpec.of(space::star, \"space.star\", \"(\\\\w+[ -]?){2,3}\"),\n            TestSpec.of(space::agency, \"space.agency\", \"(?:\\\\w+ ?){2,5}\"),\n            TestSpec.of(space::agencyAbbreviation, \"space.agency_abv\", SPACE_REGEX),\n            TestSpec.of(space::nasaSpaceCraft, \"space.nasa_space_craft\", SPACE_REGEX),\n            TestSpec.of(space::company, \"space.company\", \"(?:(?:\\\\w|')+ ?){2,4}\"),\n            TestSpec.of(space::meteorite, \"space.meteorite\", \"(?U)(?:[\\\\w()]+[ -\u2013]?){1,4}\"));\n    }\n\n    @Test\n    void distanceMeasurement() {\n        assertThat(faker.space().distanceMeasurement()).matches(\"(?:\\\\w+ ?){2,3}\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String SPACE_REGEX = \"(?:\\\\w+ ?){2,3}\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "SPACE_REGEX = \"(?:\\\\w+ ?){2,3}\"", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/UniversityTest.java.UniversityTest", "name": "UniversityTest", "file_path": "src/test/java/net/datafaker/providers/base/UniversityTest.java", "superclasses": "", "methods": ["[void]testName()"], "method_uris": ["src/test/java/net/datafaker/providers/base/UniversityTest.java.UniversityTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class UniversityTest extends BaseFakerTest<BaseFaker> {\n\n    private final University university = faker.university();\n\n    @Test\n    void testName() {\n        assertThat(university.name()).matches(\"[A-Za-z'() ]+\");\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(university::prefix, \"university.prefix\"),\n            TestSpec.of(university::suffix, \"university.suffix\"),\n            TestSpec.of(university::degree, \"university.degree\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final University university = faker.university();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "University", "name": "university = faker.university()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/AviationTest.java.AviationTest", "name": "AviationTest", "file_path": "src/test/java/net/datafaker/providers/base/AviationTest.java", "superclasses": "", "methods": ["[void]flight_ICAO()", "[void]flight_IATA()", "[void]flight_default()", "[void]aircraft()", "[void]gate()"], "method_uris": ["src/test/java/net/datafaker/providers/base/AviationTest.java.AviationTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class AviationTest extends BaseFakerTest<BaseFaker> {\n\n    private final Aviation aviation = faker.aviation();\n\n    @Test\n    void flight_ICAO() {\n        Pattern regex = Pattern.compile(\"[A-Z]{3}[0-9]+\");\n        assertThat(aviation.flight(\"ICAO\")).matches(regex);\n        assertThat(aviation.flight(\"icao\")).matches(regex);\n        assertThat(aviation.flight(\"Icao\")).matches(regex);\n        assertThat(aviation.flight(\"IcaO\")).matches(regex);\n    }\n\n    @Test\n    void flight_IATA() {\n        Pattern regex = Pattern.compile(\"[A-Z0-9]{2}\\\\d{1,4}\");\n        assertThat(aviation.flight(\"IATA\")).matches(regex);\n        assertThat(aviation.flight(\"iata\")).matches(regex);\n        assertThat(aviation.flight(\"test\")).matches(regex);\n        assertThat(aviation.flight(null)).matches(regex);\n    }\n\n    @Test\n    void flight_default() {\n        assertThat(aviation.flight()).matches(\"[A-Z0-9]{2}\\\\d{1,4}\");\n    }\n\n    @Test\n    void aircraft() {\n        assertThat(aviation.aircraft()).isNotEmpty();\n    }\n\n    @Test\n    void gate() {\n        assertThat(aviation.gate()).isNotEmpty();\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(aviation::airport, \"aviation.airport\", \"\\\\w{4}\"),\n            TestSpec.of(aviation::airportName, \"aviation.airport_name\"),\n            TestSpec.of(aviation::airplane, \"aviation.aircraft.airplane\"),\n            TestSpec.of(aviation::warplane, \"aviation.aircraft.warplane\"),\n            TestSpec.of(aviation::general, \"aviation.aircraft.general\"),\n            TestSpec.of(aviation::cargo, \"aviation.aircraft.cargo\"),\n            TestSpec.of(aviation::civilHelicopter, \"aviation.aircraft.civil_helicopter\"),\n            TestSpec.of(aviation::armyHelicopter, \"aviation.aircraft.army_helicopter\"),\n            TestSpec.of(aviation::METAR, \"aviation.metar\"),\n            TestSpec.of(aviation::manufacturer, \"aviation.manufacturer\"),\n            TestSpec.of(aviation::specialTypeDesignator, \"aviation.aircraft_type_special_designator\"),\n            TestSpec.of(aviation::engineType, \"aviation.engine_type\"),\n            TestSpec.of(aviation::flightStatus, \"aviation.flight_status\"),\n            TestSpec.of(aviation::airline, \"aviation.airline\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Aviation aviation = faker.aviation();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Aviation", "name": "aviation = faker.aviation()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/MedicalTest.java.MedicalTest", "name": "MedicalTest", "file_path": "src/test/java/net/datafaker/providers/base/MedicalTest.java", "superclasses": "", "methods": ["[void]testDiagnosisCodeUS()", "[void]testDiagnosisCodeAU()", "[void]testDiagnosisCodeNotAustraliaNorUS()", "[void]testProcedureCodes()"], "method_uris": ["src/test/java/net/datafaker/providers/base/MedicalTest.java.MedicalTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class MedicalTest extends BaseFakerTest<BaseFaker> {\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        Medical medical = faker.medical();\n        return List.of(TestSpec.of(medical::medicineName, \"medical.medicine_name\"),\n                TestSpec.of(medical::diseaseName, \"medical.disease_name\"),\n                TestSpec.of(medical::hospitalName, \"medical.hospital_name\"),\n                TestSpec.of(medical::symptoms, \"medical.symptoms\"),\n                TestSpec.of(medical::medicalProfession, \"medical.medical_professions\"));\n    }\n\n    @Test\n    void testDiagnosisCodeUS() {\n        // will use icd-10-cm - https://www.johndcook.com/blog/2019/05/05/regex_icd_codes/\n        BaseFaker faker = new BaseFaker(Locale.US);\n\n        for (int i = 0; i < 100; i++) { // Loading the US data is slow.\n            String actual = faker.medical().diagnosisCode();\n            assertThat(actual).matches(\"[A-TV-Z][0-9][0-9AB](\\\\.[0-9A-TV-Z]{0,4})?\");\n        }\n    }\n\n    @RepeatedTest(100)\n    void testDiagnosisCodeAU() {\n        // will use icd-10-am - https://ace.ihpa.gov.au/Downloads/Current/ICD-10-AM-ACHI-ACS%2011th%20Edition/Education/11th%20Edition%20PDF%20files/Coding-Exercise-Workbook-Eleventh-Edition%20V2-15%20Jun%202019.pdf\n        BaseFaker faker = new BaseFaker(new Locale(\"en\", \"au\"));\n\n        String actual = faker.medical().diagnosisCode();\n        assertThat(actual).matches(\"[A-Z][0-9]{1,2}\\\\.[0-9]{1,2}\");\n    }\n\n    @RepeatedTest(100)\n    void testDiagnosisCodeNotAustraliaNorUS() {\n        // will use icd-10 - variation of https://regexlib.com/REDetails.aspx?regexp_id=2276&AspxAutoDetectCookieSupport=1\n        BaseFaker faker = new BaseFaker(Locale.FRANCE);\n\n        String actual = faker.medical().diagnosisCode();\n        assertThat(actual).matches(\"^[A-Z][0-9]{1,2}(\\\\.[0-9])?$\");\n    }\n\n    @RepeatedTest(100)\n    void testProcedureCodes() {\n        // will use icd-10-pcs - https://regex101.com/library/nJ1wC4\n        String procedureCode = faker.medical().procedureCode();\n        assertThat(procedureCode).matches(\"^[a-hj-np-zA-HJ-NP-Z0-9]{7}$\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/PassportTest.java.PassportTest", "name": "PassportTest", "file_path": "src/test/java/net/datafaker/providers/base/PassportTest.java", "superclasses": "", "methods": ["[void]testDefaultLocale()", "[void]testValidDutch()", "[void]testValidChinese()", "[void]testValidUnitedStates()", "[void]testValidAustralia()", "[void]testValidCanada()", "[void]testValidUnitedKingdom()", "[void]testValidJapan()", "[void]testValidSpain()", "[void]testValidBulgaria()", "[void]testValidFinland()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class PassportTest extends BaseFakerTest<BaseFaker> {\n\n    @RepeatedTest(10)\n    void testDefaultLocale() {\n        assertThat(new BaseFaker().passport().valid())\n            .hasSize(9);\n    }\n\n    @RepeatedTest(10)\n    void testValidDutch() {\n        assertThat(new BaseFaker(new Locale(\"nl\", \"nl\")).passport().valid())\n            .hasSize(9)\n            .doesNotContain(\"O\")\n            .matches(\".*?\\\\d$\");\n    }\n\n    @RepeatedTest(10)\n    void testValidChinese() {\n        assertThat(new BaseFaker(new Locale(\"zh\", \"CN\")).passport().valid())\n            .hasSize(9);\n    }\n\n    @RepeatedTest(10)\n    void testValidUnitedStates() {\n        assertThat(new BaseFaker(new Locale(\"en\", \"US\")).passport().valid())\n            .hasSize(9);\n    }\n\n    @RepeatedTest(10)\n    void testValidAustralia() {\n        assertThat(new BaseFaker(new Locale(\"en\", \"AU\")).passport().valid())\n            .hasSize(8)\n            .matches(\"[A-Z][0-9]{7}\");\n    }\n\n    @RepeatedTest(10)\n    void testValidCanada() {\n        assertThat(new BaseFaker(new Locale(\"en\", \"CA\")).passport().valid())\n            .hasSize(8);\n    }\n\n    @RepeatedTest(10)\n    void testValidUnitedKingdom() {\n        assertThat(new BaseFaker(new Locale(\"en\", \"GB\")).passport().valid())\n            .hasSize(9);\n    }\n\n    @RepeatedTest(10)\n    void testValidJapan() {\n        assertThat(new BaseFaker(new Locale(\"ja\")).passport().valid())\n            .hasSize(9)\n            .matches(\"[MT][A-Z][0-9]{7}\");\n    }\n\n    @RepeatedTest(10)\n    void testValidSpain() {\n        assertThat(new BaseFaker(new Locale(\"es\")).passport().valid())\n            .matches(\"[A-z0-9]{2,3}[0-9]{6}\");\n    }\n\n    @RepeatedTest(10)\n    void testValidBulgaria() {\n        assertThat(new BaseFaker(new Locale(\"bg\")).passport().valid())\n            .hasSize(9);\n    }\n\n    @RepeatedTest(10)\n    void testValidFinland() {\n        assertThat(new BaseFaker(new Locale(\"fi\", \"FI\")).passport().valid())\n            .hasSize(9);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/DateAndTime_birthdayLocalDateTest.java.DateAndTime_birthdayLocalDateTest", "name": "DateAndTime_birthdayLocalDateTest", "file_path": "src/test/java/net/datafaker/providers/base/DateAndTime_birthdayLocalDateTest.java", "superclasses": "", "methods": ["[void]testBirthdayLocalDateMinAgeEqualsMaxAge()", "[void]testBirthdayLocalDateMinAgeLessThanMaxAge()", "[void]testBirthdayLocalDateNegativeAges()"], "method_uris": ["src/test/java/net/datafaker/providers/base/DateAndTime_birthdayLocalDateTest.java.DateAndTime_birthdayLocalDateTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DateAndTime_birthdayLocalDateTest {\n    private DateAndTime dateAndTime;\n\n    @BeforeEach\n    public void setUp() {\n        dateAndTime = new DateAndTime(new BaseFaker());\n    }\n\n    @Test\n    public void testBirthdayLocalDateMinAgeEqualsMaxAge() {\n        int minAge = 30;\n        int maxAge = 30;\n        LocalDate result = dateAndTime.birthdayLocalDate(minAge, maxAge);\n        LocalDate expected = LocalDate.now().minusYears(maxAge);\n        assertTrue(result.isEqual(expected));\n    }\n\n    @Test\n    public void testBirthdayLocalDateMinAgeLessThanMaxAge() {\n        int minAge = 18;\n        int maxAge = 65;\n        LocalDate result = dateAndTime.birthdayLocalDate(minAge, maxAge);\n        LocalDate from = LocalDate.now().minusYears(maxAge);\n        LocalDate to = LocalDate.now().minusYears(minAge);\n        assertTrue(result.isAfter(from) || result.isEqual(from));\n        assertTrue(result.isBefore(to) || result.isEqual(to));\n    }\n\n    @Test\n    public void testBirthdayLocalDateNegativeAges() {\n        int minAge = -5;\n        int maxAge = -1;\n        LocalDate result = dateAndTime.birthdayLocalDate(minAge, maxAge);\n        LocalDate from = LocalDate.now().minusYears(maxAge);\n        LocalDate to = LocalDate.now().minusYears(minAge);\n        assertTrue(result.isAfter(from) || result.isEqual(from));\n        assertTrue(result.isBefore(to) || result.isEqual(to));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private DateAndTime dateAndTime;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "DateAndTime", "name": "dateAndTime", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/Lorem_paragraphsTest.java.Lorem_paragraphsTest", "name": "Lorem_paragraphsTest", "file_path": "src/test/java/net/datafaker/providers/base/Lorem_paragraphsTest.java", "superclasses": "", "methods": ["[void]testParagraphs()", "[void]testParagraphsEmpty()"], "method_uris": ["src/test/java/net/datafaker/providers/base/Lorem_paragraphsTest.java.Lorem_paragraphsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Lorem_paragraphsTest {\n    private Lorem lorem;\n\n    @BeforeEach\n    public void setUp() {\n        BaseProviders baseProviders = new BaseFaker();\n        lorem = new Lorem(baseProviders);\n    }\n\n    @Test\n    public void testParagraphs() {\n        int paragraphCount = 5;\n        List<String> paragraphs = lorem.paragraphs(paragraphCount);\n\n        assertThat(paragraphs).hasSize(paragraphCount);\n        for (String paragraph : paragraphs) {\n            assertThat(paragraph).isNotBlank();\n            assertThat(paragraph).contains(\".\");\n        }\n    }\n\n    @Test\n    public void testParagraphsEmpty() {\n        int paragraphCount = 0;\n        List<String> paragraphs = lorem.paragraphs(paragraphCount);\n\n        assertThat(paragraphs).isEmpty();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Lorem lorem;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Lorem", "name": "lorem", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/CustomFakerTest.java.CustomFakerTest", "name": "CustomFakerTest", "file_path": "src/test/java/net/datafaker/providers/base/CustomFakerTest.java", "superclasses": "", "methods": ["[void]addNullExistingPath()", "[void]addNonExistingPath()", "[void]insectTest()", "[void]insectTestExpression()", "[void]insectAntTestExpressionFromFile()", "[void]insectBeeTestExpressionFromFile()", "[void]insectBeeTestExpressionFromFileWithoutExtraFaker()", "[void]insectTestWithoutExtraFaker()", "[void]testMultipleFakerContextsPerOneClassName()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    public static class MyCustomFaker extends BaseFaker {\n        public Insect insect() {\n            return getProvider(Insect.class, Insect::new);\n        }\n\n        public InsectFromFile insectFromFile() {\n            return getProvider(InsectFromFile.class, InsectFromFile::new);\n        }\n    }", "definition": "    public static class MyCustomFaker extends BaseFaker", "class_docstring": "", "name": "MyCustomFaker", "super_interfaces": [], "superclasses": "BaseFaker", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Insect insect() {\n            return getProvider(Insect.class, Insect::new);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "Insect", "classes": []}, "name": "insect", "params": [], "body": "                               {\n            return getProvider(Insect.class, Insect::new);\n        }", "signature": "public Insect insect()"}, {"syntax_pass": true, "original_string": "        public InsectFromFile insectFromFile() {\n            return getProvider(InsectFromFile.class, InsectFromFile::new);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "InsectFromFile", "classes": []}, "name": "insectFromFile", "params": [], "body": "                                               {\n            return getProvider(InsectFromFile.class, InsectFromFile::new);\n        }", "signature": "public InsectFromFile insectFromFile()"}]}, {"original_string": "    public static class Insect extends AbstractProvider<BaseProviders> {\n        private static final String[] INSECT_NAMES = {\"Ant\", \"Beetle\", \"Butterfly\", \"Wasp\"};\n\n        public Insect(BaseProviders faker) {\n            super(faker);\n        }\n\n        public String nextInsectName() {\n            return INSECT_NAMES[faker.random().nextInt(INSECT_NAMES.length)];\n        }\n    }", "definition": "    public static class Insect extends AbstractProvider<BaseProviders>", "class_docstring": "", "name": "Insect", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private static final String[] INSECT_NAMES = {\"Ant\", \"Beetle\", \"Butterfly\", \"Wasp\"};", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "INSECT_NAMES = {\"Ant\", \"Beetle\", \"Butterfly\", \"Wasp\"}", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public Insect(BaseProviders faker) {\n            super(faker);\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "Insect", "params": [{"name": "faker", "type": "BaseProviders"}], "body": "                                           {\n            super(faker);\n        }", "signature": "public Insect(BaseProviders faker)"}, {"syntax_pass": true, "original_string": "        public String nextInsectName() {\n            return INSECT_NAMES[faker.random().nextInt(INSECT_NAMES.length)];\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "nextInsectName", "params": [], "body": "                                       {\n            return INSECT_NAMES[faker.random().nextInt(INSECT_NAMES.length)];\n        }", "signature": "public String nextInsectName()"}]}, {"original_string": "    public static class InsectFromFile extends AbstractProvider<BaseProviders> {\n        private static final String KEY = \"insectsfromfile\";\n\n        public InsectFromFile(BaseProviders faker) {\n            super(faker);\n            faker.addPath(Locale.ENGLISH, Paths.get(\"src/test/ants.yml\"));\n            faker.addPath(Locale.ENGLISH, Paths.get(\"src/test/bees.yml\"));\n        }\n\n        public String ant() {\n            return resolve(KEY + \".ants\");\n        }\n\n        public String bee() {\n            return resolve(KEY + \".bees\");\n        }\n    }", "definition": "    public static class InsectFromFile extends AbstractProvider<BaseProviders>", "class_docstring": "", "name": "InsectFromFile", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private static final String KEY = \"insectsfromfile\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "KEY = \"insectsfromfile\"", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public InsectFromFile(BaseProviders faker) {\n            super(faker);\n            faker.addPath(Locale.ENGLISH, Paths.get(\"src/test/ants.yml\"));\n            faker.addPath(Locale.ENGLISH, Paths.get(\"src/test/bees.yml\"));\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "InsectFromFile", "params": [{"name": "faker", "type": "BaseProviders"}], "body": "                                                   {\n            super(faker);\n            faker.addPath(Locale.ENGLISH, Paths.get(\"src/test/ants.yml\"));\n            faker.addPath(Locale.ENGLISH, Paths.get(\"src/test/bees.yml\"));\n        }", "signature": "public InsectFromFile(BaseProviders faker)"}, {"syntax_pass": true, "original_string": "        public String ant() {\n            return resolve(KEY + \".ants\");\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "ant", "params": [], "body": "                            {\n            return resolve(KEY + \".ants\");\n        }", "signature": "public String ant()"}, {"syntax_pass": true, "original_string": "        public String bee() {\n            return resolve(KEY + \".bees\");\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "bee", "params": [], "body": "                            {\n            return resolve(KEY + \".bees\");\n        }", "signature": "public String bee()"}]}], "class_docstring": "\nThis is a demo of how to create a custom faker and register a custom faker in it.\n", "original_string": "class CustomFakerTest {\n    public static class MyCustomFaker extends BaseFaker {\n        public Insect insect() {\n            return getProvider(Insect.class, Insect::new);\n        }\n\n        public InsectFromFile insectFromFile() {\n            return getProvider(InsectFromFile.class, InsectFromFile::new);\n        }\n    }\n\n    public static class Insect extends AbstractProvider<BaseProviders> {\n        private static final String[] INSECT_NAMES = {\"Ant\", \"Beetle\", \"Butterfly\", \"Wasp\"};\n\n        public Insect(BaseProviders faker) {\n            super(faker);\n        }\n\n        public String nextInsectName() {\n            return INSECT_NAMES[faker.random().nextInt(INSECT_NAMES.length)];\n        }\n    }\n\n    public static class InsectFromFile extends AbstractProvider<BaseProviders> {\n        private static final String KEY = \"insectsfromfile\";\n\n        public InsectFromFile(BaseProviders faker) {\n            super(faker);\n            faker.addPath(Locale.ENGLISH, Paths.get(\"src/test/ants.yml\"));\n            faker.addPath(Locale.ENGLISH, Paths.get(\"src/test/bees.yml\"));\n        }\n\n        public String ant() {\n            return resolve(KEY + \".ants\");\n        }\n\n        public String bee() {\n            return resolve(KEY + \".bees\");\n        }\n    }\n\n    @Test\n    void addNullExistingPath() {\n        assertThatThrownBy(() -> new BaseFaker().addPath(Locale.ENGLISH, null))\n            .isInstanceOf(IllegalArgumentException.class);\n    }\n\n    @Test\n    void addNonExistingPath() {\n        assertThatThrownBy(() -> new BaseFaker().addPath(Locale.ENGLISH, Paths.get(\"non-existing-file\")))\n            .isInstanceOf(IllegalArgumentException.class);\n    }\n\n    @RepeatedTest(10)\n    void insectTest() {\n        MyCustomFaker myFaker = new MyCustomFaker();\n        assertThat(myFaker.insect().nextInsectName()).matches(\"[A-Za-z ]+\");\n    }\n\n    @RepeatedTest(10)\n    void insectTestExpression() {\n        MyCustomFaker myFaker = new MyCustomFaker();\n        assertThat(myFaker.expression(\"#{Insect.nextInsectName}\")).matches(\"[A-Za-z ]+\");\n    }\n\n    @RepeatedTest(10)\n    void insectAntTestExpressionFromFile() {\n        MyCustomFaker myFaker = new MyCustomFaker();\n        assertThat(myFaker.insectFromFile().ant()).matches(\"[A-Za-z ]+\");\n    }\n\n    @RepeatedTest(10)\n    void insectBeeTestExpressionFromFile() {\n        MyCustomFaker myFaker = new MyCustomFaker();\n        assertThat(myFaker.insectFromFile().bee()).endsWith(\"bee\");\n    }\n\n    @Test\n    void insectBeeTestExpressionFromFileWithoutExtraFaker() {\n        BaseFaker faker = new BaseFaker();\n        assertThat(BaseFaker.getProvider(InsectFromFile.class, InsectFromFile::new, faker).bee()).endsWith(\"bee\");\n    }\n\n    @Test\n    void insectTestWithoutExtraFaker() {\n        BaseFaker faker = new BaseFaker();\n        assertThat(BaseFaker.getProvider(Insect.class, Insect::new, faker).nextInsectName()).matches(\"[A-Za-z ]+\");\n    }\n\n    @Test\n    void testMultipleFakerContextsPerOneClassName() {\n        class InsectFaker extends BaseFaker {\n            public InsectFaker(Locale locale) {\n                super(locale);\n            }\n\n            public Insect insect() {\n                return getProvider(Insect.class, Insect::new);\n            }\n        }\n        BaseFaker faker1 = new InsectFaker(Locale.ENGLISH);\n        BaseFaker faker2 = new InsectFaker(Locale.GERMAN);\n\n        Insect insect1 = faker1.getProvider(\"Insect\");\n        Insect insect2 = faker2.getProvider(\"Insect\");\n        assertThat(insect1).isNotNull();\n        assertThat(insect2).isNotNull();\n        assertThat(insect1).isNotSameAs(insect2);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/base/Vehicle_carOptionsTest.java.Vehicle_carOptionsTest", "name": "Vehicle_carOptionsTest", "file_path": "src/test/java/net/datafaker/providers/base/Vehicle_carOptionsTest.java", "superclasses": "", "methods": ["[void]testCarOptionsWithMinMax()", "[void]testCarOptionsWithMinEqualToMax()", "[void]testCarOptionsWithMinGreaterThanMax()"], "method_uris": ["src/test/java/net/datafaker/providers/base/Vehicle_carOptionsTest.java.Vehicle_carOptionsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Vehicle_carOptionsTest {\n    private Vehicle vehicle;\n\n    @BeforeEach\n    public void setUp() {\n        vehicle = new Vehicle(new Faker());\n    }\n\n    @Test\n    public void testCarOptionsWithMinMax() {\n        int min = 5;\n        int max = 10;\n        List<String> options = vehicle.carOptions(min, max);\n        assertTrue(options.size() >= min && options.size() <= max);\n    }\n\n    @Test\n    public void testCarOptionsWithMinEqualToMax() {\n        int min = 7;\n        int max = 7;\n        List<String> options = vehicle.carOptions(min, max);\n        assertTrue(options.size() == min);\n    }\n\n    @Test\n    public void testCarOptionsWithMinGreaterThanMax() {\n        int min = 10;\n        int max = 5;\n        List<String> options = vehicle.carOptions(min, max);\n        assertTrue(options.size() >= 0 && options.size() <= min);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Vehicle vehicle;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Vehicle", "name": "vehicle", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/PlanetTest.java.PlanetTest", "name": "PlanetTest", "file_path": "src/test/java/net/datafaker/providers/base/PlanetTest.java", "superclasses": "", "methods": ["[void]shouldHaveNinePlanets()", "[void]shouldReturnCorrectJupiterMetadata()", "[void]shouldReturnCorrectMarsMetadata()", "[void]shouldReturnCorrectVenusMetadata()", "[void]shouldReturnCorrectUranusMetadata()", "[void]shouldReturnCorrectMercuryMetadata()", "[void]shouldReturnCorrectNeptuneMetadata()", "[void]shouldReturnCorrectEarthMetadata()", "[void]shouldReturnCorrectSaturnMetadata()", "[void]shouldReturnCorrectPlutoMetadata()"], "method_uris": ["src/test/java/net/datafaker/providers/base/PlanetTest.java.PlanetTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class PlanetTest extends BaseFakerTest<BaseFaker> {\n\n    private final Planet planet = faker.planet();\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(\n                TestSpec.of(planet::name, \"planet.name\"));\n    }\n\n    @Test\n    void shouldHaveNinePlanets() {\n        // PlanetName enum has 9 entries\n        assertThat(Planet.PlanetName.values()).hasSize(9);\n        // planet.yml has 9 names\n        assertThat(getBaseList(\"planet.name\")).hasSize(9);\n    }\n\n    @Test\n    void shouldReturnCorrectJupiterMetadata() {\n        String lengthOfDay = planet.lengthOfDay(JUPITER);\n        assertThat(lengthOfDay).isEqualTo(\"0d 9h 56m\");\n\n        String meanDistanceFromTheSun = planet.meanDistanceFromTheSun(JUPITER);\n        assertThat(meanDistanceFromTheSun).isEqualTo(\"778,412,010 km\");\n\n        String equatorialGravity = planet.equatorialGravity(JUPITER);\n        assertThat(equatorialGravity).isEqualTo(\"24.79 m/s^2\");\n\n        String mass = planet.mass(JUPITER);\n        assertThat(mass).isEqualTo(\"1.8987\u00d710^27 kg\");\n\n        String equatorialRadius = planet.equatorialRadius(JUPITER);\n        assertThat(equatorialRadius).isEqualTo(\"71,492 km\");\n    }\n\n    @Test\n    void shouldReturnCorrectMarsMetadata() {\n        String lengthOfDay = planet.lengthOfDay(MARS);\n        assertThat(lengthOfDay).isEqualTo(\"1d 0h 37m\");\n\n        String meanDistanceFromTheSun = planet.meanDistanceFromTheSun(MARS);\n        assertThat(meanDistanceFromTheSun).isEqualTo(\"227,936,640 km\");\n\n        String equatorialGravity = planet.equatorialGravity(MARS);\n        assertThat(equatorialGravity).isEqualTo(\"3.71 m/s^2\");\n\n        String mass = planet.mass(MARS);\n        assertThat(mass).isEqualTo(\"6.4191\u00d710^23 kg\");\n\n        String equatorialRadius = planet.equatorialRadius(MARS);\n        assertThat(equatorialRadius).isEqualTo(\"3,396.19 km\");\n    }\n\n    @Test\n    void shouldReturnCorrectVenusMetadata() {\n        String lengthOfDay = planet.lengthOfDay(VENUS);\n        assertThat(lengthOfDay).isEqualTo(\"243d 0h 0m\");\n\n        String meanDistanceFromTheSun = planet.meanDistanceFromTheSun(VENUS);\n        assertThat(meanDistanceFromTheSun).isEqualTo(\"108,208,930 km\");\n\n        String equatorialGravity = planet.equatorialGravity(VENUS);\n        assertThat(equatorialGravity).isEqualTo(\"8.87 m/s^2\");\n\n        String mass = planet.mass(VENUS);\n        assertThat(mass).isEqualTo(\"4.8690\u00d710^24 kg\");\n\n        String equatorialRadius = planet.equatorialRadius(VENUS);\n        assertThat(equatorialRadius).isEqualTo(\"6,051.8 km\");\n    }\n\n    @Test\n    void shouldReturnCorrectUranusMetadata() {\n        String lengthOfDay = planet.lengthOfDay(URANUS);\n        assertThat(lengthOfDay).isEqualTo(\"0d 17h 14m\");\n\n        String meanDistanceFromTheSun = planet.meanDistanceFromTheSun(URANUS);\n        assertThat(meanDistanceFromTheSun).isEqualTo(\"2,870,972,200 km\");\n\n        String equatorialGravity = planet.equatorialGravity(URANUS);\n        assertThat(equatorialGravity).isEqualTo(\"8.87 m/s^2\");\n\n        String mass = planet.mass(URANUS);\n        assertThat(mass).isEqualTo(\"8.6849\u00d710^25 kg\");\n\n        String equatorialRadius = planet.equatorialRadius(URANUS);\n        assertThat(equatorialRadius).isEqualTo(\"25,559 km\");\n    }\n\n    @Test\n    void shouldReturnCorrectMercuryMetadata() {\n        String lengthOfDay = planet.lengthOfDay(MERCURY);\n        assertThat(lengthOfDay).isEqualTo(\"59d 0h 0m\");\n\n        String meanDistanceFromTheSun = planet.meanDistanceFromTheSun(MERCURY);\n        assertThat(meanDistanceFromTheSun).isEqualTo(\"57,909,175 km\");\n\n        String equatorialGravity = planet.equatorialGravity(MERCURY);\n        assertThat(equatorialGravity).isEqualTo(\"3.70 m/s^2\");\n\n        String mass = planet.mass(MERCURY);\n        assertThat(mass).isEqualTo(\"3.302\u00d710^23 kg\");\n\n        String equatorialRadius = planet.equatorialRadius(MERCURY);\n        assertThat(equatorialRadius).isEqualTo(\"2,440.53 km\");\n    }\n\n    @Test\n    void shouldReturnCorrectNeptuneMetadata() {\n        String lengthOfDay = planet.lengthOfDay(NEPTUNE);\n        assertThat(lengthOfDay).isEqualTo(\"0d 16h 6m\");\n\n        String meanDistanceFromTheSun = planet.meanDistanceFromTheSun(NEPTUNE);\n        assertThat(meanDistanceFromTheSun).isEqualTo(\"4,498,252,900 km\");\n\n        String equatorialGravity = planet.equatorialGravity(NEPTUNE);\n        assertThat(equatorialGravity).isEqualTo(\"11.15 m/s^2\");\n\n        String mass = planet.mass(NEPTUNE);\n        assertThat(mass).isEqualTo(\"1.0244\u00d710^26 kg\");\n\n        String equatorialRadius = planet.equatorialRadius(NEPTUNE);\n        assertThat(equatorialRadius).isEqualTo(\"24,764 km\");\n    }\n\n    @Test\n    void shouldReturnCorrectEarthMetadata() {\n        String lengthOfDay = planet.lengthOfDay(EARTH);\n        assertThat(lengthOfDay).isEqualTo(\"24h\");\n\n        String meanDistanceFromTheSun = planet.meanDistanceFromTheSun(EARTH);\n        assertThat(meanDistanceFromTheSun).isEqualTo(\"149,597,890 km\");\n\n        String equatorialGravity = planet.equatorialGravity(EARTH);\n        assertThat(equatorialGravity).isEqualTo(\"9.8 m/s^2\");\n\n        String mass = planet.mass(EARTH);\n        assertThat(mass).isEqualTo(\"5.972\u00d710^24 kg\");\n\n        String equatorialRadius = planet.equatorialRadius(EARTH);\n        assertThat(equatorialRadius).isEqualTo(\"6,378.1366 km\");\n    }\n\n    @Test\n    void shouldReturnCorrectSaturnMetadata() {\n        String lengthOfDay = planet.lengthOfDay(SATURN);\n        assertThat(lengthOfDay).isEqualTo(\"0d 10h 34m\");\n\n        String meanDistanceFromTheSun = planet.meanDistanceFromTheSun(SATURN);\n        assertThat(meanDistanceFromTheSun).isEqualTo(\"1,426,725,400 km\");\n\n        String equatorialGravity = planet.equatorialGravity(SATURN);\n        assertThat(equatorialGravity).isEqualTo(\"10.44 m/s^2\");\n\n        String mass = planet.mass(SATURN);\n        assertThat(mass).isEqualTo(\"5.6851\u00d710^26 kg\");\n\n        String equatorialRadius = planet.equatorialRadius(SATURN);\n        assertThat(equatorialRadius).isEqualTo(\"60,268 km\");\n    }\n\n    @Test\n    void shouldReturnCorrectPlutoMetadata() {\n        String lengthOfDay = planet.lengthOfDay(PLUTO);\n        assertThat(lengthOfDay).isEqualTo(\"6d 9h 0m\");\n\n        String meanDistanceFromTheSun = planet.meanDistanceFromTheSun(PLUTO);\n        assertThat(meanDistanceFromTheSun).isEqualTo(\"5,906,380,000 km\");\n\n        String equatorialGravity = planet.equatorialGravity(PLUTO);\n        assertThat(equatorialGravity).isEqualTo(\"0.620 m/s^2\");\n\n        String mass = planet.mass(PLUTO);\n        assertThat(mass).isEqualTo(\"1.303x10^22 kg\");\n\n        String equatorialRadius = planet.equatorialRadius(PLUTO);\n        assertThat(equatorialRadius).isEqualTo(\"1,188.3 km\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Planet planet = faker.planet();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Planet", "name": "planet = faker.planet()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/Locality_localeStringWithRandomTest.java.Locality_localeStringWithRandomTest", "name": "Locality_localeStringWithRandomTest", "file_path": "src/test/java/net/datafaker/providers/base/Locality_localeStringWithRandomTest.java", "superclasses": "", "methods": ["[void]allSupportedLocales()", "[void]localeStringWithRandom()"], "method_uris": ["src/test/java/net/datafaker/providers/base/Locality_localeStringWithRandomTest.java.Locality_localeStringWithRandomTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Locality_localeStringWithRandomTest {\n    private Locality locality;\n    private Random random;\n\n    @BeforeEach\n    public void setUp() {\n        locality = new Locality(new net.datafaker.Faker());\n        random = new Random();\n    }\n\n    @Test\n    void allSupportedLocales() {\n        List<String> allLocales = locality.allSupportedLocales();\n        assertThat(allLocales).hasSize(87);\n    }\n\n    @RepeatedTest(10)\n    void localeStringWithRandom() {\n        String randomLocale = locality.localeStringWithRandom(random);\n        List<String> allLocales = locality.allSupportedLocales();\n        assertThat(allLocales).contains(randomLocale);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Locality locality;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Locality", "name": "locality", "syntax_pass": true}, {"attribute_expression": "private Random random;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Random", "name": "random", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/AppTest.java.AppTest", "name": "AppTest", "file_path": "src/test/java/net/datafaker/providers/base/AppTest.java", "superclasses": "", "methods": ["[void]testVersion()", "[void]testAuthor()"], "method_uris": ["src/test/java/net/datafaker/providers/base/AppTest.java.AppTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class AppTest extends BaseFakerTest<BaseFaker> {\n\n    private final App app = faker.app();\n\n    @Test\n    void testVersion() {\n        assertThat(app.version()).matches(\"\\\\d\\\\.(?:\\\\d){1,2}(?:\\\\.\\\\d)?\");\n    }\n\n    @Test\n    void testAuthor() {\n        assertThat(app.author()).matches(\"(?:[\\\\w']+[-&,.]? ?){2,9}\");\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(app::name, \"app.name\", \"([\\\\w-]+ ?)+\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final App app = faker.app();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "App", "name": "app = faker.app()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/ShakespeareTest.java.ShakespeareTest", "name": "ShakespeareTest", "file_path": "src/test/java/net/datafaker/providers/base/ShakespeareTest.java", "superclasses": "", "methods": ["[void]testHamletQuote()", "[void]testAsYouLikeItQuote()", "[void]testKingRichardIIIQuote()", "[void]testRomeoAndJulietQuote()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ShakespeareTest extends BaseFakerTest<BaseFaker> {\n\n    private final Shakespeare shakespeare = faker.shakespeare();\n\n    @Test\n    void testHamletQuote() {\n        assertThat(shakespeare.hamletQuote()).isNotEmpty();\n    }\n\n    @Test\n    void testAsYouLikeItQuote() {\n        assertThat(shakespeare.asYouLikeItQuote()).isNotEmpty();\n    }\n\n    @Test\n    void testKingRichardIIIQuote() {\n        assertThat(shakespeare.kingRichardIIIQuote()).isNotEmpty();\n    }\n\n    @Test\n    void testRomeoAndJulietQuote() {\n        assertThat(shakespeare.romeoAndJulietQuote()).isNotEmpty();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Shakespeare shakespeare = faker.shakespeare();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Shakespeare", "name": "shakespeare = faker.shakespeare()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/base/Number_digitsTest.java.Number_digitsTest", "name": "Number_digitsTest", "file_path": "src/test/java/net/datafaker/providers/base/Number_digitsTest.java", "superclasses": "", "methods": ["[void]testDigitsWithPositiveCount()", "[void]testDigitsWithZeroCount()", "[void]testDigitsWithNegativeCount()", "[void]testDigitsWithSingleDigit()"], "method_uris": ["src/test/java/net/datafaker/providers/base/Number_digitsTest.java.Number_digitsTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class Number_digitsTest {\n    private Number number;\n    private BaseProviders faker;\n\n    @BeforeEach\n    public void setUp() {\n        faker = new BaseFaker();\n        number = new Number(faker);\n    }\n\n    @Test\n    public void testDigitsWithPositiveCount() {\n        int count = 5;\n        String result = number.digits(count);\n        assertEquals(count, result.length());\n        for (char c : result.toCharArray()) {\n            assertTrue(Character.isDigit(c));\n        }\n    }\n\n    @Test\n    public void testDigitsWithZeroCount() {\n        int count = 0;\n        String result = number.digits(count);\n        assertEquals(count, result.length());\n    }\n\n    @Test\n    public void testDigitsWithNegativeCount() {\n        int count = -5;\n        String result = number.digits(Math.max(0, count));\n        assertEquals(0, result.length());\n    }\n\n    @Test\n    public void testDigitsWithSingleDigit() {\n        int count = 1;\n        String result = number.digits(count);\n        assertEquals(count, result.length());\n        assertTrue(Character.isDigit(result.charAt(0)));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Number number;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Number", "name": "number", "syntax_pass": true}, {"attribute_expression": "private BaseProviders faker;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "BaseProviders", "name": "faker", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/foods/TeaTest.java.TeaTest", "name": "TeaTest", "file_path": "src/test/java/net/datafaker/providers/foods/TeaTest.java", "superclasses": "FoodFakerTest", "methods": ["[void]testVariety()"], "method_uris": ["src/test/java/net/datafaker/providers/foods/TeaTest.java.TeaTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class TeaTest extends FoodFakerTest {\n\n    private final Tea tea = getFaker().tea();\n\n    @Test\n    void testVariety() {\n        assertThat(faker.tea().variety()).matches(\"^(?:[A-Z]['.\\\\-a-z]+[\\\\s-])*[A-Z]['.\\\\-a-z]+$\");\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(\n            TestSpec.of(tea::type, \"tea.type\")\n        );\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Tea tea = getFaker().tea();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Tea", "name": "tea = getFaker().tea()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/foods/HebrewFoodTest.java.HebrewFoodTest", "name": "HebrewFoodTest", "file_path": "src/test/java/net/datafaker/providers/foods/HebrewFoodTest.java", "superclasses": "FoodFakerTest", "methods": ["[void]measurement()"], "method_uris": ["src/test/java/net/datafaker/providers/foods/HebrewFoodTest.java.HebrewFoodTest.[void]before()", "src/test/java/net/datafaker/providers/foods/HebrewFoodTest.java.HebrewFoodTest.[FoodFaker]getFaker()", "src/test/java/net/datafaker/providers/foods/HebrewFoodTest.java.HebrewFoodTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class HebrewFoodTest extends FoodFakerTest {\n    private Food food = getFaker().food();\n\n    @BeforeEach\n    final void before() {\n        food = getFaker().food();\n    }\n\n    protected FoodFaker getFaker() {\n        return new FoodFaker(new Locale(\"he\"));\n    }\n\n    @Test\n    void measurement() {\n        assertThat(food.measurement()).matches(\"([A-Za-z1-9/ ]+){2}\");\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(\n            TestSpec.of(food::dish, \"food.dish\"),\n            TestSpec.of(food::fruit, \"food.fruits\"),\n            TestSpec.of(food::ingredient, \"food.ingredients\"),\n            TestSpec.of(food::spice, \"food.spices\"),\n            TestSpec.of(food::sushi, \"food.sushi\"),\n            TestSpec.of(food::vegetable, \"food.vegetables\")\n        );\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private Food food = getFaker().food();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Food", "name": "food = getFaker().food()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/foods/CoffeeTest.java.CoffeeTest", "name": "CoffeeTest", "file_path": "src/test/java/net/datafaker/providers/foods/CoffeeTest.java", "superclasses": "FoodFakerTest", "methods": ["[void]notes()", "[void]blendName()"], "method_uris": ["src/test/java/net/datafaker/providers/foods/CoffeeTest.java.CoffeeTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class CoffeeTest extends FoodFakerTest {\n\n    @Test\n    void notes() {\n        assertThat(faker.coffee().notes()).isNotEmpty();\n    }\n\n    @Test\n    void blendName() {\n        assertThat(faker.coffee().blendName()).isNotEmpty();\n    }\n\n    private final Coffee coffee = getFaker().coffee();\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(\n            TestSpec.of(coffee::body, \"coffee.body\"),\n            TestSpec.of(coffee::country, \"coffee.country\"),\n            TestSpec.of(coffee::descriptor, \"coffee.descriptor\"),\n            TestSpec.of(coffee::intensifier, \"coffee.intensifier\"),\n            TestSpec.of(coffee::name1, \"coffee.name_1\"),\n            TestSpec.of(coffee::name2, \"coffee.name_2\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.BRAZIL), \"coffee.regions.brazil\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.BURUNDI), \"coffee.regions.burundi\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.COLOMBIA), \"coffee.regions.colombia\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.COSTA_RICA), \"coffee.regions.costa_rica\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.EL_SALVADOR), \"coffee.regions.el_salvador\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.ETHIOPIA), \"coffee.regions.ethiopia\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.GUATEMALA), \"coffee.regions.guatemala\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.HONDURAS), \"coffee.regions.honduras\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.INDIA), \"coffee.regions.india\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.KENYA), \"coffee.regions.kenya\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.MEXICO), \"coffee.regions.mexico\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.NICARAGUA), \"coffee.regions.nicaragua\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.PANAMA), \"coffee.regions.panama\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.RWANDA), \"coffee.regions.rwanda\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.SUMATRA), \"coffee.regions.sumatra\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.TANZANIA), \"coffee.regions.tanzania\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.UGANDA), \"coffee.regions.uganda\"),\n            TestSpec.of(() -> coffee.region(Coffee.Country.YEMEN), \"coffee.regions.yemen\"),\n            TestSpec.of(coffee::variety, \"coffee.variety\")\n        );\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Coffee coffee = getFaker().coffee();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Coffee", "name": "coffee = getFaker().coffee()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/foods/FoodTest.java.FoodTest", "name": "FoodTest", "file_path": "src/test/java/net/datafaker/providers/foods/FoodTest.java", "superclasses": "FoodFakerTest", "methods": ["[void]measurement()"], "method_uris": ["src/test/java/net/datafaker/providers/foods/FoodTest.java.FoodTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FoodTest extends FoodFakerTest {\n\n    private final Food food = getFaker().food();\n\n    @Test\n    void measurement() {\n        assertThat(faker.food().measurement()).matches(\"([A-Za-z1-9/ ]+){2}\");\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(\n            TestSpec.of(food::allergen, \"food.allergens\"),\n            TestSpec.of(food::dish, \"food.dish\"),\n            TestSpec.of(food::fruit, \"food.fruits\"),\n            TestSpec.of(food::ingredient, \"food.ingredients\"),\n            TestSpec.of(food::spice, \"food.spices\"),\n            TestSpec.of(food::sushi, \"food.sushi\"),\n            TestSpec.of(food::vegetable, \"food.vegetables\")\n        );\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Food food = getFaker().food();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Food", "name": "food = getFaker().food()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/videogame/HearthstoneTest.java.HearthstoneTest", "name": "HearthstoneTest", "file_path": "src/test/java/net/datafaker/providers/videogame/HearthstoneTest.java", "superclasses": "VideoGameFakerTest", "methods": ["[void]battlegroundsScoreTest()", "[void]standardRankTest()", "[void]wildRankTest()"], "method_uris": ["src/test/java/net/datafaker/providers/videogame/HearthstoneTest.java.HearthstoneTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class HearthstoneTest extends VideoGameFakerTest {\n\n    @Test\n    void battlegroundsScoreTest() {\n        int score = faker.hearthstone().battlegroundsScore();\n        assertThat(score).isBetween(0, 16000);\n    }\n\n    @Test\n    void standardRankTest() {\n        String rank = faker.hearthstone().standardRank();\n        assertThat(rank).matches(\"[ A-Za-z0-9]+\");\n    }\n\n    @Test\n    void wildRankTest() {\n        String rank = faker.hearthstone().wildRank();\n        assertThat(rank).matches(\"[ A-Za-z0-9]+\");\n    }\n\n    private final Hearthstone hearthstone = getFaker().hearthstone();\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(\n            TestSpec.of(hearthstone::mainCharacter, \"games.hearthstone.characters\"),\n            TestSpec.of(hearthstone::mainPattern, \"games.hearthstone.patterns\"),\n            TestSpec.of(hearthstone::mainProfession, \"games.hearthstone.professions\")\n        );\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Hearthstone hearthstone = getFaker().hearthstone();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Hearthstone", "name": "hearthstone = getFaker().hearthstone()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/videogame/MinecraftTest.java.MinecraftTest", "name": "MinecraftTest", "file_path": "src/test/java/net/datafaker/providers/videogame/MinecraftTest.java", "superclasses": "VideoGameFakerTest", "methods": ["[void]testTileItemName()"], "method_uris": ["src/test/java/net/datafaker/providers/videogame/MinecraftTest.java.MinecraftTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class MinecraftTest extends VideoGameFakerTest {\n\n    @Test\n    void testTileItemName() {\n        assertThat(faker.minecraft().tileItemName()).matches(\"([\\\\w()']+\\\\.?( )?){2,5}\");\n    }\n\n    private final Minecraft minecraft = getFaker().minecraft();\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(\n            TestSpec.of(minecraft::animalName, \"minecraft.animal_name\"),\n            TestSpec.of(minecraft::entityName, \"minecraft.entity_name\"),\n            TestSpec.of(minecraft::itemName, \"minecraft.item_name\"),\n            TestSpec.of(minecraft::monsterName, \"minecraft.monster_name\"),\n            TestSpec.of(minecraft::tileName, \"minecraft.tile_name\")\n        );\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Minecraft minecraft = getFaker().minecraft();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Minecraft", "name": "minecraft = getFaker().minecraft()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/videogame/Dota2Test.java.Dota2Test", "name": "Dota2Test", "file_path": "src/test/java/net/datafaker/providers/videogame/Dota2Test.java", "superclasses": "VideoGameFakerTest", "methods": ["[void]dota2HeroQuote()"], "method_uris": ["src/test/java/net/datafaker/providers/videogame/Dota2Test.java.Dota2Test.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Dota2Test extends VideoGameFakerTest {\n\n    private final Dota2 dota2 = getFaker().dota2();\n\n    @Test\n    void dota2HeroQuote() {\n        for (int i = 0; i < 5; i++) {\n            String randomHero = dota2.hero();\n\n            String snakeCasedRandomHero = randomHero.replace(\" \", \"_\").toLowerCase(Locale.ENGLISH);\n\n            String randomHeroQuote = dota2.heroQuote(snakeCasedRandomHero);\n\n            assertThat(randomHeroQuote).isNotEmpty();\n        }\n    }\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(\n            TestSpec.of(dota2::faction, \"games.dota2.faction\"),\n            TestSpec.of(dota2::rank, \"games.dota2.rank\"),\n            TestSpec.of(dota2::attribute, \"games.dota2.attribute\"),\n            TestSpec.of(dota2::building, \"games.dota2.building\"),\n            TestSpec.of(dota2::hero, \"games.dota2.hero\"),\n            TestSpec.of(dota2::item, \"games.dota2.item\"),\n            TestSpec.of(dota2::neutralItem, \"games.dota2.neutral_item\"),\n            TestSpec.of(dota2::team, \"games.dota2.team\"),\n            TestSpec.of(dota2::tier, \"games.dota2.tier\"),\n            TestSpec.of(dota2::player, \"games.dota2.player\")\n        );\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Dota2 dota2 = getFaker().dota2();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Dota2", "name": "dota2 = getFaker().dota2()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/healthcare/MedicalProcedureTest.java.MedicalProcedureTest", "name": "MedicalProcedureTest", "file_path": "src/test/java/net/datafaker/providers/healthcare/MedicalProcedureTest.java", "superclasses": "HealthcareFakerTest", "methods": ["[void]testProcedureCodes()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class MedicalProcedureTest extends HealthcareFakerTest {\n\n    private final MedicalProcedure medicalProcedure = getFaker().medicalProcedure();\n\n    @RepeatedTest(100)\n    void testProcedureCodes() {\n        // will use icd-10-pcs - https://regex101.com/library/nJ1wC4\n        String procedureCode = medicalProcedure.icd10();\n        assertThat(procedureCode).matches(\"^[a-hj-np-zA-HJ-NP-Z0-9]{7}$\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final MedicalProcedure medicalProcedure = getFaker().medicalProcedure();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "MedicalProcedure", "name": "medicalProcedure = getFaker().medicalProcedure()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/healthcare/DiseaseTest.java.DiseaseTest", "name": "DiseaseTest", "file_path": "src/test/java/net/datafaker/providers/healthcare/DiseaseTest.java", "superclasses": "HealthcareFakerTest", "methods": ["[void]testAnyDisease()", "[void]testDiseaseCodes()"], "method_uris": ["src/test/java/net/datafaker/providers/healthcare/DiseaseTest.java.DiseaseTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class DiseaseTest extends HealthcareFakerTest {\n\n    private final Disease disease = faker.disease();\n\n    private final Set<String> allDiseases = Arrays.stream(Disease.DiseaseType.values())\n        .map((Disease.DiseaseType diseaseType) -> getBaseList(diseaseType.yamlKey))\n        .flatMap(Collection::stream)\n        .collect(Collectors.toSet());\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(TestSpec.of(disease::internalDisease, INTERNAL_DISEASE_KEY.yamlKey),\n            TestSpec.of(disease::neurology, NEUROLOGICAL_DISEASE_KEY.yamlKey),\n            TestSpec.of(disease::surgery, SURGICAL_DISEASE_KEY.yamlKey),\n            TestSpec.of(disease::paediatrics, PAEDIATRIC_DISEASE_KEY.yamlKey),\n            TestSpec.of(disease::gynecologyAndObstetrics, GYNECOLOGY_AND_OBSTETRICS_DISEASE_KEY.yamlKey),\n            TestSpec.of(disease::ophthalmologyAndOtorhinolaryngology, OPHTHALMOLOGY_AND_OTORHINOLARYNGOLOGY_DISEASE_KEY.yamlKey),\n            TestSpec.of(disease::dermatology, DERMATOLOGY_DISEASE_KEY.yamlKey));\n    }\n\n    @RepeatedTest(100)\n    void testAnyDisease() {\n        // when\n        String anyDisease = disease.anyDisease();\n\n        // then\n        assertThat(anyDisease).as(\"Any disease should use existing providers combined\")\n            .isNotBlank()\n            .isIn(allDiseases);\n    }\n\n    @RepeatedTest(100)\n    void testDiseaseCodes() {\n        String diseaseCode = disease.icd10();\n        assertThat(diseaseCode).matches(\"^[A-Z][0-9]{1,2}(\\\\.[0-9])?$\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Disease disease = faker.disease();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Disease", "name": "disease = faker.disease()", "syntax_pass": true}, {"attribute_expression": "private final Set<String> allDiseases = Arrays.stream(Disease.DiseaseType.values())\n        .map((Disease.DiseaseType diseaseType) -> getBaseList(diseaseType.yamlKey))\n        .flatMap(Collection::stream)\n        .collect(Collectors.toSet());", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Set<String>", "name": "allDiseases = Arrays.stream(Disease.DiseaseType.values())\n        .map((Disease.DiseaseType diseaseType) -> getBaseList(diseaseType.yamlKey))\n        .flatMap(Collection::stream)\n        .collect(Collectors.toSet())", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/entertainment/StarWarsTest.java.StarWarsTest", "name": "StarWarsTest", "file_path": "src/test/java/net/datafaker/providers/entertainment/StarWarsTest.java", "superclasses": "EntertainmentFakerTest", "methods": ["[void]callSign()", "[void]alternativeSpelling()"], "method_uris": ["src/test/java/net/datafaker/providers/entertainment/StarWarsTest.java.StarWarsTest.[Collection<TestSpec>]providerListTest()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class StarWarsTest extends EntertainmentFakerTest {\n\n    @Test\n    void callSign() {\n        assertThat(faker.starWars().callSign()).isNotEmpty().matches(\"\\\\w+\\\\s(Leader|\\\\d)$\");\n    }\n\n    @Test\n    void alternativeSpelling() {\n        assertThat(faker.starWars().alternateCharacterSpelling()).isNotEmpty();\n    }\n\n    private final StarWars starWars = getFaker().starWars();\n\n    @Override\n    protected Collection<TestSpec> providerListTest() {\n        return List.of(\n            TestSpec.of(starWars::character, \"star_wars.characters\"),\n            TestSpec.of(starWars::droids, \"star_wars.droids\"),\n            TestSpec.of(starWars::planets, \"star_wars.planets\"),\n            TestSpec.of(starWars::species, \"star_wars.species\"),\n            TestSpec.of(starWars::vehicles, \"star_wars.vehicles\"),\n            TestSpec.of(starWars::wookieWords, \"star_wars.wookiee_words\")\n        );\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final StarWars starWars = getFaker().starWars();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "StarWars", "name": "starWars = getFaker().starWars()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/providers/entertainment/AvatarTest.java.AvatarTest", "name": "AvatarTest", "file_path": "src/test/java/net/datafaker/providers/entertainment/AvatarTest.java", "superclasses": "EntertainmentFakerTest", "methods": ["[void]testAvatar()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class AvatarTest extends EntertainmentFakerTest {\n\n    @RepeatedTest(10)\n    void testAvatar() {\n        String avatar = getFaker().avatar().image();\n        assertThat(avatar).matches(\"^https://robohash.org/[a-z]{8}.png$\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/providers/entertainment/OscarMovieTest.java.OscarMovieTest", "name": "OscarMovieTest", "file_path": "src/test/java/net/datafaker/providers/entertainment/OscarMovieTest.java", "superclasses": "EntertainmentFakerTest", "methods": ["[void]actor()", "[void]movieName()", "[void]quote()", "[void]character()", "[void]releaseDate()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class OscarMovieTest extends EntertainmentFakerTest {\n\n    private final OscarMovie oscarMovie = getFaker().oscarMovie();\n\n    @RepeatedTest(100)\n    void actor() {\n        assertThat(oscarMovie.actor()).matches(\"\\\\P{Cc}+\");\n    }\n\n    @RepeatedTest(10)\n    void movieName() {\n        assertThat(isNullOrEmpty(oscarMovie.movieName())).isFalse();\n    }\n\n    @RepeatedTest(10)\n    void quote() {\n        assertThat(isNullOrEmpty(oscarMovie.quote())).isFalse();\n    }\n\n    @RepeatedTest(100)\n    void character() {\n        assertThat(oscarMovie.character()).matches(\"\\\\P{Cc}+\");\n    }\n\n    @RepeatedTest(100)\n    void releaseDate() {\n        assertThat(oscarMovie.releaseDate()).matches(\"[A-Za-z,0-9 ]+\");\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final OscarMovie oscarMovie = getFaker().oscarMovie();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OscarMovie", "name": "oscarMovie = getFaker().oscarMovie()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/integration/FakerIntegrationTest.java.FakerIntegrationTest", "name": "FakerIntegrationTest", "file_path": "src/test/java/net/datafaker/integration/FakerIntegrationTest.java", "superclasses": "", "methods": ["[void]testAllFakerMethodsThatReturnStrings(Locale,Random)", "[void]testExceptionsNotCoveredInAboveTest(Locale,Random)"], "method_uris": ["src/test/java/net/datafaker/integration/FakerIntegrationTest.java.FakerIntegrationTest.[Faker]init(Locale,Random)", "src/test/java/net/datafaker/integration/FakerIntegrationTest.java.FakerIntegrationTest.[void]testAllMethodsThatReturnStringsActuallyReturnStrings(AbstractProvider<?>)", "src/test/java/net/datafaker/integration/FakerIntegrationTest.java.FakerIntegrationTest.[boolean]isExcepted(Object,Method,Locale)", "src/test/java/net/datafaker/integration/FakerIntegrationTest.java.FakerIntegrationTest.[Stream<Arguments>]dataParameters()"], "overrides": null, "attributes": [{"original_string": "    private static class SkippedMethods {\n        private final Map<Class<?>, Set<String>> class2methodNames = new HashMap<>();\n\n        public static SkippedMethods of(Class<?> clazz, String... methodNames) {\n            SkippedMethods sm = new SkippedMethods();\n            sm.class2methodNames.putIfAbsent(clazz, new HashSet<>());\n            sm.class2methodNames.get(clazz).addAll(List.of(methodNames));\n            return sm;\n        }\n    }", "definition": "    private static class SkippedMethods", "class_docstring": "", "name": "SkippedMethods", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Map<Class<?>, Set<String>> class2methodNames = new HashMap<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<Class<?>, Set<String>>", "name": "class2methodNames = new HashMap<>()", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public static SkippedMethods of(Class<?> clazz, String... methodNames) {\n            SkippedMethods sm = new SkippedMethods();\n            sm.class2methodNames.putIfAbsent(clazz, new HashSet<>());\n            sm.class2methodNames.get(clazz).addAll(List.of(methodNames));\n            return sm;\n        }", "docstring": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "return_type": "SkippedMethods", "classes": []}, "name": "of", "params": [{"name": "clazz", "type": "Class<?>"}], "body": "                                                                               {\n            SkippedMethods sm = new SkippedMethods();\n            sm.class2methodNames.putIfAbsent(clazz, new HashSet<>());\n            sm.class2methodNames.get(clazz).addAll(List.of(methodNames));\n            return sm;\n        }", "signature": "public static SkippedMethods of(Class<?> clazz, String... methodNames)"}]}], "class_docstring": "\nThe purpose of these tests is to ensure that the Locales have been properly configured\nand that methods return values. The unit tests should ensure what the values returned\nare correct. These tests just ensure that the methods can be invoked.\n", "original_string": "class FakerIntegrationTest {\n    private static final Logger log = Logger.getLogger(FakerIntegrationTest.class.getName());\n\n    /**\n     * a collection of Locales -> Exceptions.\n     * In the case of 'pt', city_prefix is '' by design. This test fails because it's testing that all string returning\n     * methods return a non-blank string. But pt city_prefix is blank ,but the test shouldn't fail. So we add put\n     * exceptions like this into this collection.\n     */\n    private static final Map<Locale, SkippedMethods> exceptions = new HashMap<>();\n\n    static {\n        // 'it' has an empty suffix list, so it never returns a value\n        exceptions.put(new Locale(\"it\"), SkippedMethods.of(Name.class, \"suffix\"));\n        exceptions.put(new Locale(\"es\", \"mx\"), SkippedMethods.of(Address.class, \"cityPrefix\", \"citySuffix\"));\n        exceptions.put(new Locale(\"pt\"), SkippedMethods.of(Address.class, \"cityPrefix\", \"citySuffix\"));\n        exceptions.put(new Locale(\"uk\"), SkippedMethods.of(Address.class, \"cityPrefix\", \"citySuffix\", \"stateAbbr\", \"streetSuffix\"));\n        exceptions.put(new Locale(\"uk\", \"UA\"), SkippedMethods.of(Address.class, \"cityPrefix\", \"citySuffix\", \"stateAbbr\", \"streetSuffix\"));\n        exceptions.put(new Locale(\"id\"), SkippedMethods.of(App.class, \"author\"));\n        exceptions.put(new Locale(\"id\", \"ID\"), SkippedMethods.of(App.class, \"author\"));\n        exceptions.put(new Locale(\"pt\", \"BR\"), SkippedMethods.of(Address.class, \"cityPrefix\", \"citySuffix\"));\n        exceptions.put(new Locale(\"pt\", \"Br\", \"x2\"), SkippedMethods.of(Address.class, \"cityPrefix\", \"citySuffix\"));\n    }\n\n    private static class SkippedMethods {\n        private final Map<Class<?>, Set<String>> class2methodNames = new HashMap<>();\n\n        public static SkippedMethods of(Class<?> clazz, String... methodNames) {\n            SkippedMethods sm = new SkippedMethods();\n            sm.class2methodNames.putIfAbsent(clazz, new HashSet<>());\n            sm.class2methodNames.get(clazz).addAll(List.of(methodNames));\n            return sm;\n        }\n    }\n\n    private Faker init(Locale locale, Random random) {\n        if (locale != null && random != null) {\n            return new Faker(locale, random);\n        } else if (locale != null) {\n            return new Faker(locale);\n        } else if (random != null) {\n            return new Faker(random);\n        } else {\n            return new Faker();\n        }\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"dataParameters\")\n    void testAllFakerMethodsThatReturnStrings(Locale locale, Random random) throws Exception {\n        log.fine(() -> \"  (%s, %s)\".formatted(locale, random));\n        final Faker faker = init(locale, random);\n\n        Method[] methods = faker.getClass().getMethods();\n        for (Method provider : methods) {\n            if (AbstractProvider.class.isAssignableFrom(provider.getReturnType()) && provider.getParameterCount() == 0) {\n                log.fine(() -> \"    (%s), method: %s.%s()\".formatted(locale, provider.getDeclaringClass().getSimpleName(), provider.getName()));\n\n                AbstractProvider<?> providerImpl = (AbstractProvider<?>) provider.invoke(faker);\n                testAllMethodsThatReturnStringsActuallyReturnStrings(providerImpl);\n            }\n        }\n    }\n\n    private void testAllMethodsThatReturnStringsActuallyReturnStrings(AbstractProvider<?> provider) {\n        final Locale locale = provider.getFaker().getContext().getLocale();\n        @SuppressWarnings(\"unchecked\")\n        Set<Method> methodsThatReturnStrings = getAllMethods(provider.getClass(),\n            withModifier(Modifier.PUBLIC),\n            withReturnType(String.class),\n            withParametersCount(0));\n\n        for (Method method : methodsThatReturnStrings) {\n            if (isExcepted(provider, method, locale)) {\n                continue;\n            }\n            final Object returnValue;\n            try {\n                log.fine(() -> \"        (%s), method: %s.%s()\".formatted(locale, method.getDeclaringClass(), method.getName()));\n                returnValue = method.invoke(provider);\n            } catch (Exception e) {\n                throw new RuntimeException(\"Test for method %s and object %s was failed for locale %s [thread: %s]\".formatted(\n                    method, provider, locale, currentThread().getName()), e);\n            }\n            Supplier<String> description = () -> \"For method %s.%s(), value is '%s'\".formatted(provider.getClass().getSimpleName(), method.getName(), returnValue);\n            assertThat(returnValue).as(description).isInstanceOf(String.class);\n            assertThat((String) returnValue).as(description).isNotEmpty();\n        }\n    }\n\n    private boolean isExcepted(Object object, Method method, Locale locale) {\n        if (exceptions.containsKey(locale) && exceptions.get(locale).class2methodNames.containsKey(object.getClass())) {\n            return exceptions.get(locale).class2methodNames.get(object.getClass()).contains(method.getName());\n        }\n        return false;\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"dataParameters\")\n    void testExceptionsNotCoveredInAboveTest(Locale locale, Random random) {\n        final BaseFaker faker = init(locale, random);\n        assertThat(faker.bothify(\"####???\")).isNotNull();\n        assertThat(faker.letterify(\"????\")).isNotNull();\n        assertThat(faker.numerify(\"####\")).isNotNull();\n\n        assertThat(faker.lorem().paragraph(1)).isNotNull();\n        assertThat(faker.lorem().paragraphs(1)).isNotNull();\n\n        assertThat(faker.lorem().sentence(1)).isNotNull();\n        assertThat(faker.lorem().sentences(1)).isNotNull();\n\n        assertThat(faker.address().streetAddress()).isNotNull();\n\n        assertThat(faker.lorem().words()).isNotNull();\n        assertThat(faker.lorem().words(1)).isNotNull();\n    }\n\n    private static Stream<Arguments> dataParameters() {\n        List<Arguments> arguments = new ArrayList<>();\n        arguments.add(Arguments.of(Locale.ENGLISH, new Random()));\n        arguments.add(Arguments.of(new Locale(\"en\", \"US\"), new Random()));\n        arguments.add(Arguments.of(new Locale(\"en\", \"GB\"), new Random()));\n        arguments.add(Arguments.of(new Locale(\"pt\", \"BR\"), null));\n        arguments.add(Arguments.of(new Locale(\"pt\", \"br\"), null));\n        arguments.add(Arguments.of(new Locale(\"Pt\", \"br\"), null));\n        arguments.add(Arguments.of(new Locale(\"pt\", \"Br\", \"x2\"), null));\n        arguments.add(Arguments.of(null, new Random()));\n        arguments.add(Arguments.of(null, null));\n\n        String[] ymlFiles = new File(\"./src/main/resources\").list();\n        for (String ymlFileName : ymlFiles) {\n            if (ymlFileName.endsWith(\".yml\")) {\n                String locale = substringBefore(ymlFileName, \".\").replace(\"-\", \"_\");\n                arguments.add(Arguments.of(new Locale(locale), null));\n            }\n        }\n\n        return arguments.stream();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Logger log = Logger.getLogger(FakerIntegrationTest.class.getName());", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Logger", "name": "log = Logger.getLogger(FakerIntegrationTest.class.getName())", "syntax_pass": true}, {"attribute_expression": "private static final Map<Locale, SkippedMethods> exceptions = new HashMap<>();", "docstring": "\na collection of Locales -> Exceptions.\nIn the case of 'pt', city_prefix is '' by design. This test fails because it's testing that all string returning\nmethods return a non-blank string. But pt city_prefix is blank ,but the test shouldn't fail. So we add put\nexceptions like this into this collection.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Map<Locale, SkippedMethods>", "name": "exceptions = new HashMap<>()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/integration/UkLocalDirectivesTest.java.UkLocalDirectivesTest", "name": "UkLocalDirectivesTest", "file_path": "src/test/java/net/datafaker/integration/UkLocalDirectivesTest.java", "superclasses": "", "methods": ["[void]resolvesDirectivesOnlyInYmlFile()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nThe purpose of these tests is to ensure that the Locales have been properly configured\nand that methods return values. The unit tests should ensure what the values returned\nare correct. These tests just ensure that the methods can be invoked.\n", "original_string": "class UkLocalDirectivesTest {\n\n    /**\n     * uk is interesting in that it has feminine and masculine prefixes for street names.  the feminine\n     * and masculine prefixes are NOT methods on Address though as they only make sense for this locale (and possibly\n     * others).  This test shows we can resolve within the yml file without reaching out to any of the {@link BaseFaker}\n     * child objects.\n     */\n    @Test\n    void resolvesDirectivesOnlyInYmlFile() {\n        final Locale uk = new Locale(\"uk\");\n\n        final String streetName = new BaseFaker(uk).address().streetName();\n\n        final List<String> masc = List.of(\"\u043f\u0440.\", \"\u043f\u0440\u043e\u0441\u043f\u0435\u043a\u0442\", \"\u043f\u0440\u043e\u0432.\", \"\u043f\u0440\u043e\u0432\u0443\u043b\u043e\u043a\");\n        final List<String> fem = List.of(\"\u0432\u0443\u043b.\", \"\u0432\u0443\u043b\u0438\u0446\u044f\", \"\u043f\u043b.\", \"\u043f\u043b\u043e\u0449\u0430\");\n\n        boolean startsWithMascPrefix = false;\n        boolean startsWithFemPrefix = false;\n\n        for (String mascPrefix : masc) {\n            startsWithMascPrefix |= streetName.startsWith(mascPrefix);\n        }\n        for (String femPrefix : fem) {\n            startsWithFemPrefix |= streetName.startsWith(femPrefix);\n        }\n\n        assertThat(startsWithFemPrefix || startsWithMascPrefix)\n            .as(\"the streetname starts with a fem or masc prefix\")\n            .isTrue();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/integration/FakerRepeatabilityIntegrationTest.java.FakerRepeatabilityIntegrationTest", "name": "FakerRepeatabilityIntegrationTest", "file_path": "src/test/java/net/datafaker/integration/FakerRepeatabilityIntegrationTest.java", "superclasses": "", "methods": ["[void]shouldCreateRepeatableValues()", "[void]shouldCreateUniqueValues()"], "method_uris": ["src/test/java/net/datafaker/integration/FakerRepeatabilityIntegrationTest.java.FakerRepeatabilityIntegrationTest.[Map<String, String>]buildReport(Faker)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@Execution(ExecutionMode.SAME_THREAD)\npublic class FakerRepeatabilityIntegrationTest {\n\n    @Test\n    void shouldCreateRepeatableValues() throws InvocationTargetException, IllegalAccessException {\n\n        Faker faker1 = new Faker(new Random(0));\n        Faker faker2 = new Faker(new Random(0));\n\n        Map<String, String> report1 = buildReport(faker1);\n        Map<String, String> report2 = buildReport(faker2);\n\n        for (var entry1: report1.entrySet()) {\n            assertThat(report2).containsEntry(entry1.getKey(), entry1.getValue());\n        }\n\n        for (var entry2: report2.entrySet()) {\n            assertThat(report1).containsEntry(entry2.getKey(), entry2.getValue());\n        }\n    }\n\n    @Test\n    void shouldCreateUniqueValues() throws InvocationTargetException, IllegalAccessException {\n        Faker faker1 = new Faker();\n        Faker faker2 = new Faker();\n\n        Map<String, String> report1 = buildReport(faker1);\n        Map<String, String> report2 = buildReport(faker2);\n\n        MapDifference<String, String> difference = Maps.difference(report1, report2);\n\n        assertThat(difference.entriesDiffering()).hasSizeGreaterThan(difference.entriesInCommon().size());\n    }\n\n    private static Map<String, String> buildReport(Faker faker) throws IllegalAccessException, InvocationTargetException {\n        Map<String, String> result = new HashMap<>();\n\n        // Need to sort the methods since they are sometimes returned in a different order\n        Method[] methods = faker.getClass().getMethods();\n        List<Method> providerList = Arrays.asList(methods);\n        providerList.sort(Comparator.comparing(Method::getName));\n\n        for (Method provider : providerList) {\n\n            if (AbstractProvider.class.isAssignableFrom(provider.getReturnType()) && provider.getParameterCount() == 0) {\n                AbstractProvider providerImpl = (AbstractProvider) provider.invoke(faker);\n\n                Method[] generatorMethods = providerImpl.getClass().getDeclaredMethods();\n\n                List<Method> generatorMethodList = Arrays.asList(generatorMethods);\n                generatorMethodList.sort(Comparator.comparing(Method::getName));\n\n                for (Method generatorMethod : generatorMethodList) {\n\n                    if (!Instant.class.isAssignableFrom(generatorMethod.getReturnType()) &&\n                        !byte[].class.isAssignableFrom(generatorMethod.getReturnType())\n                        && generatorMethod.getParameterCount() == 0 && Modifier.isPublic(generatorMethod.getModifiers())) {\n                        result.put(provider.getName() + \".\" + generatorMethod.getName(), generatorMethod.invoke(providerImpl).toString());\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/integration/MostSpecificLocaleTest.java.MostSpecificLocaleTest", "name": "MostSpecificLocaleTest", "file_path": "src/test/java/net/datafaker/integration/MostSpecificLocaleTest.java", "superclasses": "", "methods": ["[void]resolvesTheMostSpecificLocale()"], "method_uris": ["src/test/java/net/datafaker/integration/MostSpecificLocaleTest.java.MostSpecificLocaleTest.[FakeValuesService]fakeValuesService(FakerContext)"], "overrides": null, "attributes": [], "class_docstring": "\nThe purpose of these tests is to ensure that the Locales have been properly configured\nand that methods return values. The unit tests should ensure what the values returned\nare correct. These tests just ensure that the methods can be invoked.\n", "original_string": "class MostSpecificLocaleTest {\n\n    private final FakerContext en = new FakerContext(new Locale(\"en\"), null);\n    private final FakerContext en_US = new FakerContext(new Locale(\"en\", \"US\"), null);\n\n    @Test\n    void resolvesTheMostSpecificLocale() {\n        List<String> enDefaultCountries = fakeValuesService(en).fetchObject(\"address.default_country\", en);\n        List<String> enUsDefaultCountries = fakeValuesService(en_US).fetchObject(\"address.default_country\", en_US);\n\n        assertThat(enDefaultCountries).hasSize(1);\n        assertThat(enUsDefaultCountries).hasSize(3);\n\n        assertThat(enDefaultCountries).as(\"the default country for en is not en_US\").isNotEqualTo(enUsDefaultCountries);\n    }\n\n    private static FakeValuesService fakeValuesService(FakerContext context) {\n        FakeValuesService service = new FakeValuesService();\n        service.updateFakeValuesInterfaceMap(context.getLocaleChain());\n        return service;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final FakerContext en = new FakerContext(new Locale(\"en\"), null);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "FakerContext", "name": "en = new FakerContext(new Locale(\"en\"), null)", "syntax_pass": true}, {"attribute_expression": "private final FakerContext en_US = new FakerContext(new Locale(\"en\", \"US\"), null);", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "FakerContext", "name": "en_US = new FakerContext(new Locale(\"en\", \"US\"), null)", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/integration/Issue194SlashFormatRegexTest.java.Issue194SlashFormatRegexTest", "name": "Issue194SlashFormatRegexTest", "file_path": "src/test/java/net/datafaker/integration/Issue194SlashFormatRegexTest.java", "superclasses": "", "methods": ["[void]enGBZipCodeReturnsProperRegexifiedValue()", "[void]enCAZipCodeReturnsProperRegexifiedValue()", "[void]viZipCodeReturnsProperRegexifiedValue()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class Issue194SlashFormatRegexTest {\n\n    @Test\n    void enGBZipCodeReturnsProperRegexifiedValue() {\n        final Locale uk = new Locale(\"en\", \"GB\");\n\n        final String postalCode = new BaseFaker(uk).address().zipCode();\n\n        assertThat(postalCode).matches(\"[A-PR-UWYZ]([A-HK-Y][0-9][ABEHMNPRVWXY0-9]?|[0-9][ABCDEFGHJKPSTUW0-9]?) [0-9][ABD-HJLNP-UW-Z]{2}\");\n    }\n\n    @Test\n    void enCAZipCodeReturnsProperRegexifiedValue() {\n        final Locale uk = new Locale(\"en\", \"CA\");\n\n        final String postalCode = new BaseFaker(uk).address().zipCode();\n\n        assertThat(postalCode).matches(\"[A-CEJ-NPR-TVXY][0-9][A-CEJ-NPR-TV-Z] ?[0-9][A-CEJ-NPR-TV-Z][0-9]\");\n    }\n\n    @Test\n    void viZipCodeReturnsProperRegexifiedValue() {\n        final Locale uk = new Locale(\"vi\");\n\n        final String postalCode = new BaseFaker(uk).address().zipCode();\n\n        assertThat(postalCode).matches(\"[A-PR-UWYZ0-9][A-HK-Y0-9][AEHMNPRTVXY0-9]?[ABEHMNPRVWXY0-9]? {1,2}[0-9][ABD-HJLN-UW-Z]{2}\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/formats/CsvTest.java.CsvTest", "name": "CsvTest", "file_path": "src/test/java/net/datafaker/formats/CsvTest.java", "superclasses": "AbstractFakerTest", "methods": ["[void]csvTestNew()", "[void]csvTestWithQuotesNew()", "[void]testCsvWithCommaNew()", "[void]testCsvWithDifferentObjects()", "[void]testCsvWithDifferentObjectsFunction()", "[void]testCsvWithDifferentObjectsFunctionStream()", "[void]testCsvWithInfiniteSequence()", "[void]testLimitForCsv(int)", "[void]testLimitForCsvNew(int)", "[void]testLimitForCollection(int)", "[void]testLimitForCollectionNew(int)", "[void]testInfiniteCsv()", "[void]testInfiniteCsvWithLimit()", "[void]supplierShouldBeDefinedInCaseOfNullInput()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class CsvTest extends AbstractFakerTest {\n\n    @Test\n    void csvTestNew() {\n        final BaseFaker faker = new BaseFaker();\n        String separator = \"@@@\";\n        int limit = 20;\n        Schema<String, String> schema =\n            Schema.of(\n                field(\"first_name\", () -> faker.name().firstName()),\n                field(\"last_name\", () -> faker.name().lastName()),\n                field(\"address\", () -> faker.address().streetAddress()));\n        CsvTransformer<String> transformer =\n            CsvTransformer.<String>builder().header(true).separator(separator).build();\n\n        String csv = transformer.generate(schema, limit);\n        int numberOfLines = 0;\n        int numberOfSeparator = 0;\n        for (int i = 0; i < csv.length(); i++) {\n            if (csv.regionMatches(i, LINE_SEPARATOR, 0, LINE_SEPARATOR.length())) {\n                numberOfLines++;\n            } else if (csv.regionMatches(i, separator, 0, separator.length())) {\n                numberOfSeparator++;\n            }\n        }\n\n        assertThat(limit).isEqualTo(numberOfLines);\n        assertThat((limit + 1) * 2)\n            .isEqualTo(numberOfSeparator); // number of lines * (number of columns - 1)*/\n    }\n\n    @Test\n    void csvTestWithQuotesNew() {\n        String separator = \"$$$\";\n        int limit = 20;\n        final BaseFaker faker = new BaseFaker();\n        Schema<String, String> schema =\n            Schema.of(\n                field(\"first_name\", () -> faker.expression(\"#{Name.first_name}\")),\n                field(\"last_name\", () -> faker.expression(\"#{Name.last_name}\")));\n        CsvTransformer<String> transformer =\n            CsvTransformer.<String>builder().header(true).separator(separator).build();\n\n        String csv = transformer.generate(schema, limit);\n        int numberOfLines = 0;\n        int numberOfSeparator = 0;\n        for (int i = 0; i < csv.length(); i++) {\n            if (csv.regionMatches(i, LINE_SEPARATOR, 0, LINE_SEPARATOR.length())) {\n                numberOfLines++;\n            } else if (csv.regionMatches(i, separator, 0, separator.length())) {\n                numberOfSeparator++;\n            }\n        }\n\n        assertThat(limit).isEqualTo(numberOfLines);\n        assertThat((limit + 1) * (schema.getFields().length - 1))\n            .isEqualTo(numberOfSeparator); // number of lines * (number of columns - 1)\n    }\n\n    @Test\n    void testCsvWithCommaNew() {\n        Schema<Object, ? extends CharSequence> schema =\n            Schema.of(field(\"values\", () -> \"1,2,3\"), field(\"title\", () -> \"The \\\"fabulous\\\" artist\"));\n        CsvTransformer<Object> transformer =\n            CsvTransformer.builder().header(true).separator(\",\").build();\n\n        String csv = transformer.generate(schema, 1);\n\n        String expected =\n            \"\\\"values\\\",\\\"title\\\"\" + LINE_SEPARATOR\n                + \"\\\"1,2,3\\\",\\\"The \\\"\\\"fabulous\\\"\\\" artist\\\"\";\n\n        assertThat(csv).isEqualTo(expected);\n    }\n\n    @Test\n    void testCsvWithDifferentObjects() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Object, ?> schema = Schema.of(\n            field(\"Number\", () -> faker.number().randomDigit()),\n            field(\"Bool\", () -> faker.bool().bool()),\n            field(\"String\", () -> faker.name().firstName()),\n            field(\"Text\", () -> \"The, \\\"fabulous\\\" artist'\")\n        );\n        CsvTransformer<Object> transformer =\n            CsvTransformer.builder().header(true).separator(\",\").build();\n\n        String csv = transformer.generate(schema, 4);\n\n        String expected =\n            \"\\\"Number\\\",\\\"Bool\\\",\\\"String\\\",\\\"Text\\\"\" + LINE_SEPARATOR\n                + \"3,false,\\\"Flor\\\",\\\"The, \\\"\\\"fabulous\\\"\\\" artist'\\\"\" + LINE_SEPARATOR\n                + \"6,true,\\\"Stephnie\\\",\\\"The, \\\"\\\"fabulous\\\"\\\" artist'\\\"\" + LINE_SEPARATOR\n                + \"1,false,\\\"Edythe\\\",\\\"The, \\\"\\\"fabulous\\\"\\\" artist'\\\"\" + LINE_SEPARATOR\n                + \"1,true,\\\"Dwight\\\",\\\"The, \\\"\\\"fabulous\\\"\\\" artist'\\\"\";\n\n        assertThat(csv).isEqualTo(expected);\n    }\n\n    @Test\n    void testCsvWithDifferentObjectsFunction() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Integer, ?> schema = Schema.of(\n            field(\"Number\", integer -> integer),\n            field(\"Password\", integer -> faker.internet().password(integer, integer))\n        );\n        CsvTransformer<Integer> transformer =\n            CsvTransformer.<Integer>builder().header(true).separator(\",\").build();\n\n        FakeSequence<Integer> fakeSequence = faker.<Integer>collection()\n            .suppliers(() -> faker.number().randomDigit())\n            .len(5)\n            .build();\n        String csv = transformer.generate(fakeSequence, schema);\n\n        String expected =\n            \"\\\"Number\\\",\\\"Password\\\"\" + LINE_SEPARATOR\n                + \"3,\\\"nf3\\\"\" + LINE_SEPARATOR\n                + \"6,\\\"4b0v69\\\"\" + LINE_SEPARATOR\n                + \"7,\\\"00827v2\\\"\" + LINE_SEPARATOR\n                + \"1,\\\"5\\\"\" + LINE_SEPARATOR\n                + \"3,\\\"p6x\\\"\";\n\n        assertThat(csv).isEqualTo(expected);\n    }\n\n    @Test\n    void testCsvWithDifferentObjectsFunctionStream() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Integer, ?> schema = Schema.of(\n            field(\"Number\", integer -> integer),\n            field(\"Password\", integer -> faker.internet().password(integer, integer))\n        );\n        CsvTransformer<Integer> transformer =\n            CsvTransformer.<Integer>builder().header(true).separator(\",\").build();\n\n        FakeSequence<Integer> fakeSequence = faker.<Integer>stream()\n            .suppliers(() -> faker.number().randomDigit())\n            .len(3)\n            .build();\n\n        String csv = transformer.generate(fakeSequence, schema);\n\n        String expected =\n            \"\\\"Number\\\",\\\"Password\\\"\" + LINE_SEPARATOR\n                + \"3,\\\"0p4\\\"\" + LINE_SEPARATOR\n                + \"8,\\\"714487nf\\\"\" + LINE_SEPARATOR\n                + \"5,\\\"0v691\\\"\";\n\n        assertThat(csv).isEqualTo(expected);\n    }\n\n    @Test\n    void testCsvWithInfiniteSequence() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n\n        Schema<Integer, ?> schema = Schema.of(\n            field(\"Number\", integer -> faker.number().digits(integer)),\n            field(\"String\", prefix -> prefix + \": \" + faker.name().firstName())\n        );\n        CsvTransformer<Integer> transformer =\n            CsvTransformer.<Integer>builder().header(true).separator(\",\").build();\n\n        FakeSequence<Integer> fakeSequence = faker.<Integer>stream()\n            .suppliers(() -> faker.number().randomDigit())\n            .build();\n        assertThatThrownBy(() -> transformer.generate(fakeSequence, schema))\n            .isInstanceOf(IllegalArgumentException.class)\n            .hasMessage(\"The sequence should be finite of size: FakeStream{minLength=-1, maxLength=-1, nullRate=0.0}\");\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {0, 2, 3, 10, 20, 100})\n    void testLimitForCsv(int limit) {\n        final BaseFaker faker = new BaseFaker();\n        String csv = CsvTransformer.<Name>builder().separator(\" : \").header(false).build()\n            .generate(faker.<Name>collection().suppliers(faker::name).maxLen(limit + 1).build(),\n                Schema.of(field(\"firstName\", Name::firstName), field(\"lastname\", Name::lastName)));\n\n        int numberOfLines = 0;\n        for (int i = 0; i < csv.length(); i++) {\n            if (csv.regionMatches(i, LINE_SEPARATOR, 0, LINE_SEPARATOR.length())) {\n                numberOfLines++;\n            }\n        }\n\n        assertThat(numberOfLines).isEqualTo(limit);\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {0, 2, 3, 10, 20, 100})\n    void testLimitForCsvNew(int limit) {\n        final BaseFaker faker = new BaseFaker();\n        Schema<Name, String> schema =\n            Schema.of(field(\"firstName\", Name::firstName), field(\"lastname\", Name::lastName));\n\n        CsvTransformer<Name> transformer =\n            CsvTransformer.<Name>builder().header(false).separator(\",\").build();\n        String csv =\n            transformer.generate(\n                faker.<Name>collection().suppliers(faker::name).maxLen(limit + 1).build(),\n                schema);\n\n        int numberOfLines = 0;\n        for (int i = 0; i < csv.length(); i++) {\n            if (csv.regionMatches(i, LINE_SEPARATOR, 0, LINE_SEPARATOR.length())) {\n                numberOfLines++;\n            }\n        }\n\n        assertThat(numberOfLines).isEqualTo(limit);\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {0, 2, 3, 10, 20})\n    void testLimitForCollection(int limit) {\n        final BaseFaker faker = new BaseFaker();\n        String csv = CsvTransformer.<Name>builder().header(false).build()\n            .generate(faker.<Name>collection().suppliers(faker::name).maxLen(limit).build(),\n                Schema.of(field(\"firstName\", Name::firstName), field(\"lastName\", Name::lastName)));\n\n        int numberOfLines = 0;\n        for (int i = 0; i < csv.length(); i++) {\n            if (csv.regionMatches(i, LINE_SEPARATOR, 0, LINE_SEPARATOR.length())) {\n                numberOfLines++;\n            }\n        }\n\n        assertThat(numberOfLines == 0 ? 0 : numberOfLines + 1).isEqualTo(limit);\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {0, 2, 3, 10, 20, 100})\n    void testLimitForCollectionNew(int limit) {\n        final BaseFaker faker = new BaseFaker();\n        Schema<Name, String> schema =\n            Schema.of(field(\"firstName\", Name::firstName), field(\"lastname\", Name::lastName));\n\n        CsvTransformer<Name> transformer =\n            CsvTransformer.<Name>builder().header(false).separator(\" : \").build();\n        String csv =\n            transformer.generate(\n                faker.<Name>collection().suppliers(faker::name).maxLen(limit + 1).build(),\n                schema);\n\n        int numberOfLines = 0;\n        for (int i = 0; i < csv.length(); i++) {\n            if (csv.regionMatches(i, LINE_SEPARATOR, 0, LINE_SEPARATOR.length())) {\n                numberOfLines++;\n            }\n        }\n\n        assertThat(numberOfLines).isEqualTo(limit);\n    }\n\n    @Test\n    void testInfiniteCsv() {\n        final BaseFaker faker = new BaseFaker();\n        FakeSequence<Name> infiniteSequence = faker.<Name>stream()\n            .suppliers(faker::name)\n            .build();\n\n        assertThatThrownBy(() ->\n            CsvTransformer.<Name>builder().separator(\" : \").header(false).build()\n                .generate(infiniteSequence,\n                    Schema.of(field(\"firstName\", Name::firstName), field(\"lastName\", Name::lastName)))\n        ).isInstanceOf(IllegalArgumentException.class)\n            .hasMessage(\"The sequence should be finite of size: FakeStream{minLength=-1, maxLength=-1, nullRate=0.0}\");\n    }\n\n    @Test\n    void testInfiniteCsvWithLimit() {\n        int limit = 10;\n        final BaseFaker faker = new BaseFaker();\n        FakeSequence<Name> infiniteSequence = faker.<Name>stream()\n            .suppliers(faker::name)\n            .len(limit)\n            .build();\n\n        String csv = CsvTransformer.<Name>builder().header(false).separator(\" : \").build()\n            .generate(infiniteSequence,\n                Schema.of(\n                    field(\"firstName\", Name::firstName),\n                    field(\"lastName\", Name::lastName)));\n\n        int numberOfLines = 0;\n        for (int i = 0; i < csv.length(); i++) {\n            if (csv.regionMatches(i, LINE_SEPARATOR, 0, LINE_SEPARATOR.length())) {\n                numberOfLines++;\n            }\n        }\n\n        assertThat(numberOfLines + 1).isEqualTo(limit);\n    }\n\n    @Test\n    void supplierShouldBeDefinedInCaseOfNullInput() {\n        Schema<Name, String> schema =\n            Schema.of(field(\"firstName\", Name::firstName), field(\"lastname\", Name::lastName));\n        assertThatThrownBy(() ->\n            CsvTransformer.<Name>builder()\n                .header(false).separator(\" : \")\n                .build()\n                .generate(schema, 1))\n            .isInstanceOf(IllegalArgumentException.class)\n            .hasMessageContaining(\"Input could be null only if suppliers are defined\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/formats/JsonTest.java.JsonTest", "name": "JsonTest", "file_path": "src/test/java/net/datafaker/formats/JsonTest.java", "superclasses": "", "methods": ["[void]testJsonStream()", "[void]testGenerateFromSchemaWithLimit()", "[void]testGenerateFromFakeSequenceCollectionWithoutComma()", "[void]testGenerateFromFakeSequenceCollection()", "[void]testGenerateFromFakeSequenceStream()", "[void]testGenerateFromInfiniteFakeSequence()", "[void]simpleJsonTestForJsonTransformer(Schema<String, String>,String)", "[void]outputArrayJsonTestForJsonTransformer(Schema<String, String>,String)", "[void]outputWithoutCommaForJsonTransformer(Schema<String, String>,String)", "[void]jsonWithDifferentFieldFormatsInOneObjectTest()", "[void]jsonObjectCollectionTest()", "[void]jsonCollectionOfCollectionsTest()"], "method_uris": ["src/test/java/net/datafaker/formats/JsonTest.java.JsonTest.[Stream<Arguments>]generateTestSchema()", "src/test/java/net/datafaker/formats/JsonTest.java.JsonTest.[Map.Entry<Supplier<String>, Supplier<Object>>]entry(Supplier<String>,Supplier<Object>)", "src/test/java/net/datafaker/formats/JsonTest.java.JsonTest.[Map<Supplier<String>, Supplier<Object>>]map()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class JsonTest {\n    @Test\n    void testJsonStream() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Object, ?> schema = Schema.of(\n            field(\"Text\", () -> faker.name().firstName()),\n            field(\"Bool\", () -> faker.bool().bool())\n        );\n\n        JsonTransformer<Object> transformer = JsonTransformer.builder().build();\n        Stream<CharSequence> json = transformer.generateStream(schema, 10);\n        String output = json.collect(Collectors.joining(LINE_SEPARATOR));\n        assertThat(output).isEqualTo(\"[\" + LINE_SEPARATOR +\n            \"{\\\"Text\\\": \\\"Willis\\\", \\\"Bool\\\": false},\" + LINE_SEPARATOR +\n            \"{\\\"Text\\\": \\\"Carlena\\\", \\\"Bool\\\": true},\" + LINE_SEPARATOR +\n            \"{\\\"Text\\\": \\\"Stephnie\\\", \\\"Bool\\\": true},\" + LINE_SEPARATOR +\n            \"{\\\"Text\\\": \\\"Rutha\\\", \\\"Bool\\\": true},\" + LINE_SEPARATOR +\n            \"{\\\"Text\\\": \\\"Armand\\\", \\\"Bool\\\": true},\" + LINE_SEPARATOR +\n            \"{\\\"Text\\\": \\\"Margot\\\", \\\"Bool\\\": false},\" + LINE_SEPARATOR +\n            \"{\\\"Text\\\": \\\"Patrick\\\", \\\"Bool\\\": false},\" + LINE_SEPARATOR +\n            \"{\\\"Text\\\": \\\"Alphonse\\\", \\\"Bool\\\": false},\" + LINE_SEPARATOR +\n            \"{\\\"Text\\\": \\\"Louisa\\\", \\\"Bool\\\": true},\" + LINE_SEPARATOR +\n            \"{\\\"Text\\\": \\\"Caryn\\\", \\\"Bool\\\": false}\" + LINE_SEPARATOR +\n            \"]\");\n    }\n\n    @Test\n    void testGenerateFromSchemaWithLimit() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Object, ?> schema = Schema.of(\n            field(\"Text\", () -> faker.name().firstName()),\n            field(\"Bool\", () -> faker.bool().bool())\n        );\n\n        JsonTransformer<Object> transformer = JsonTransformer.builder().build();\n        String json = transformer.generate(schema, 2);\n        String expected = \"[\" + LINE_SEPARATOR +\n            \"{\\\"Text\\\": \\\"Willis\\\", \\\"Bool\\\": false},\" + LINE_SEPARATOR +\n            \"{\\\"Text\\\": \\\"Carlena\\\", \\\"Bool\\\": true}\" + LINE_SEPARATOR +\n            \"]\";\n\n        assertThat(json).isEqualTo(expected);\n    }\n\n    @Test\n    void testGenerateFromFakeSequenceCollectionWithoutComma() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Integer, ?> schema = Schema.of(\n            field(\"Number\", integer -> integer),\n            field(\"Password\", integer -> faker.internet().password(integer, integer))\n        );\n\n        JsonTransformer<Integer> transformer = JsonTransformer.<Integer>builder().withCommaBetweenObjects(false).build();\n        FakeSequence<Integer> fakeSequence = faker.<Integer>collection()\n            .suppliers(() -> faker.number().randomDigit())\n            .len(5)\n            .build();\n\n        String json = transformer.generate(fakeSequence, schema);\n\n        String expected = \"[\" + LINE_SEPARATOR +\n            \"{\\\"Number\\\": 3, \\\"Password\\\": \\\"nf3\\\"}\" + LINE_SEPARATOR +\n            \"{\\\"Number\\\": 6, \\\"Password\\\": \\\"4b0v69\\\"}\" + LINE_SEPARATOR +\n            \"{\\\"Number\\\": 7, \\\"Password\\\": \\\"00827v2\\\"}\" + LINE_SEPARATOR +\n            \"{\\\"Number\\\": 1, \\\"Password\\\": \\\"5\\\"}\" + LINE_SEPARATOR +\n            \"{\\\"Number\\\": 3, \\\"Password\\\": \\\"p6x\\\"}\" + LINE_SEPARATOR +\n            \"]\";\n\n        assertThat(json).isEqualTo(expected);\n    }\n\n    @Test\n    void testGenerateFromFakeSequenceCollection() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Integer, ?> schema = Schema.of(\n            field(\"Number\", integer -> integer),\n            field(\"Password\", integer -> faker.internet().password(integer, integer))\n        );\n\n        JsonTransformer<Integer> transformer = JsonTransformer.<Integer>builder().build();\n        FakeSequence<Integer> fakeSequence = faker.<Integer>collection()\n            .suppliers(() -> faker.number().randomDigit())\n            .len(5)\n            .build();\n\n        String json = transformer.generate(fakeSequence, schema);\n\n        String expected = \"[\" + LINE_SEPARATOR +\n            \"{\\\"Number\\\": 3, \\\"Password\\\": \\\"nf3\\\"},\" + LINE_SEPARATOR +\n            \"{\\\"Number\\\": 6, \\\"Password\\\": \\\"4b0v69\\\"},\" + LINE_SEPARATOR +\n            \"{\\\"Number\\\": 7, \\\"Password\\\": \\\"00827v2\\\"},\" + LINE_SEPARATOR +\n            \"{\\\"Number\\\": 1, \\\"Password\\\": \\\"5\\\"},\" + LINE_SEPARATOR +\n            \"{\\\"Number\\\": 3, \\\"Password\\\": \\\"p6x\\\"}\" + LINE_SEPARATOR +\n            \"]\";\n\n        assertThat(json).isEqualTo(expected);\n    }\n\n    @Test\n    void testGenerateFromFakeSequenceStream() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Integer, ?> schema = Schema.of(\n            field(\"Number\", integer -> integer),\n            field(\"Password\", integer -> faker.internet().password(integer, integer))\n        );\n\n        JsonTransformer<Integer> transformer = JsonTransformer.<Integer>builder().withCommaBetweenObjects(false).build();\n        FakeSequence<Integer> fakeSequence = faker.<Integer>stream()\n            .suppliers(() -> faker.number().randomDigit())\n            .len(2)\n            .build();\n\n        String json = transformer.generate(fakeSequence, schema);\n\n        String expected = \"[\" + LINE_SEPARATOR +\n            \"{\\\"Number\\\": 3, \\\"Password\\\": \\\"0p4\\\"}\" + LINE_SEPARATOR +\n            \"{\\\"Number\\\": 8, \\\"Password\\\": \\\"714487nf\\\"}\" + LINE_SEPARATOR +\n            \"]\";\n\n        assertThat(json).isEqualTo(expected);\n    }\n\n    @Test\n    void testGenerateFromInfiniteFakeSequence() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Integer, ?> schema = Schema.of(\n            field(\"Number\", integer -> integer),\n            field(\"Password\", integer -> faker.internet().password(integer, integer))\n        );\n\n        JsonTransformer<Integer> transformer = JsonTransformer.<Integer>builder().build();\n        FakeSequence<Integer> fakeSequence = faker.<Integer>stream()\n            .suppliers(() -> faker.number().randomDigit())\n            .build();\n\n        assertThatThrownBy(() -> transformer.generate(fakeSequence, schema))\n            .isInstanceOf(IllegalArgumentException.class)\n            .hasMessage(\"The sequence should be finite of size: FakeStream{minLength=-1, maxLength=-1, nullRate=0.0}\");\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateTestSchema\")\n    void simpleJsonTestForJsonTransformer(Schema<String, String> schema, String expected) {\n        JsonTransformer<String> transformer = JsonTransformer.<String>builder().build();\n        assertThat(transformer.generate(schema, 1)).isEqualTo(expected);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateTestSchema\")\n    void outputArrayJsonTestForJsonTransformer(\n        Schema<String, String> schema, String expected) {\n        JsonTransformer<String> transformer = JsonTransformer.<String>builder().build();\n\n        assertThat(transformer.generate(schema, 2).replaceAll(System.lineSeparator(), \"\"))\n            .isEqualTo(\"[\" + expected + \",\" + expected + \"]\");\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateTestSchema\")\n    void outputWithoutCommaForJsonTransformer(\n        Schema<String, String> schema, String expected) {\n        JsonTransformer<String> transformer = JsonTransformer.<String>builder().withCommaBetweenObjects(false).build();\n\n        assertThat(transformer.generate(schema, 2).replaceAll(System.lineSeparator(), \"\"))\n            .isEqualTo(\"[\" + expected + expected + \"]\");\n    }\n\n    private static Stream<Arguments> generateTestSchema() {\n        return Stream.of(\n            of(Schema.of(), \"{}\"),\n            of(\n                Schema.of(compositeField(\"key\", new Field[]{field(\"key\", () -> \"value\")})),\n                \"{\\\"key\\\": {\\\"key\\\": \\\"value\\\"}}\"),\n            of(Schema.of(field(\"key\", () -> \"value\")), \"{\\\"key\\\": \\\"value\\\"}\"),\n            of(Schema.of(field(\"number\", () -> 123)), \"{\\\"number\\\": 123}\"),\n            of(Schema.of(field(\"number\", () -> 123.0)), \"{\\\"number\\\": 123.0}\"),\n            of(Schema.of(field(\"number\", () -> 123.123)), \"{\\\"number\\\": \\\"123.123\\\"}\"),\n            of(Schema.of(field(\"boolean\", () -> true)), \"{\\\"boolean\\\": true}\"),\n            of(Schema.of(field(\"nullValue\", () -> null)), \"{\\\"nullValue\\\": null}\"),\n            of(\n                Schema.of(field(\"array\", () -> new String[]{null, \"test\", \"123\"})),\n                \"{\\\"array\\\": [null, \\\"test\\\", \\\"123\\\"]}\"),\n            of(\n                Schema.of(field(\"array\", () -> new Integer[]{123, 456, 789})),\n                \"{\\\"array\\\": [123, 456, 789]}\"),\n            of(\n                Schema.of(field(\"array\", () -> new Object[]{\"test\", 456, true})),\n                \"{\\\"array\\\": [\\\"test\\\", 456, true]}\"),\n            of(Schema.of(field(\"emptyarray\", () -> new Long[]{})), \"{\\\"emptyarray\\\": []}\"),\n            of(Schema.of(field(\"emptyarray\", Collections::emptyList)), \"{\\\"emptyarray\\\": []}\"),\n            of(\n                Schema.of(field(\"es\\\"ca\\\"ped\", () -> \"va\\\"lu\\\"e\")),\n                \"{\\\"es\\\\\\\"ca\\\\\\\"ped\\\": \\\"va\\\\\\\"lu\\\\\\\"e\\\"}\"),\n            of(\n                Schema.of(\n                    field(\"key\", () -> \"value\"),\n                    compositeField(\"nested\", new Field[]{field(\"nestedkey\", () -> \"nestedvalue\")})),\n                \"{\\\"key\\\": \\\"value\\\", \\\"nested\\\": {\\\"nestedkey\\\": \\\"nestedvalue\\\"}}\"));\n    }\n\n    @Test\n    void jsonWithDifferentFieldFormatsInOneObjectTest() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        final int limit = 2;\n        JsonTransformer<Object> transformer = JsonTransformer.builder().build();\n\n        String json = transformer.generate(\n            faker.collection().minLen(limit).maxLen(limit)\n                .suppliers(faker::name)\n                .build(), Schema.<Object, Object>of(\n                field(\"text\", () -> faker.name().firstName()),\n                field(\"array\", () ->\n                    faker\n                        .collection()\n                        .suppliers(() -> faker.phoneNumber().phoneNumber())\n                        .maxLen(3)\n                        .generate()\n                )\n            ));\n\n        int numberOfLines = 0;\n        for (int i = 0; i < json.length(); i++) {\n            if (json.regionMatches(i, \"},\", 0, \"},\".length())) {\n                numberOfLines++;\n            }\n        }\n        assertThat(numberOfLines).isEqualTo(limit - 1);\n    }\n\n    @Test\n    void jsonObjectCollectionTest() {\n        JsonTransformer<Name> transformer = JsonTransformer.<Name>builder().build();\n\n        String json = transformer.generate(\n            Schema.of(\n                field(\"text\", () -> \"Mrs. Brian Braun\"),\n                field(\"objectCollection\", () -> List.of(\n                        compositeField(null, new Field[]{\n                                field(\"country\", () -> \"Denmark\"),\n                                field(\"city\", () -> \"Port Angel\")\n                            }\n                        ),\n                        compositeField(null, new Field[]{\n                                field(\"two\", () -> \"Denmark\"),\n                                field(\"one\", () -> \"Port Angel\")\n                            }\n                        )\n                    )\n                )\n            ), 1);\n        assertThat(json).isEqualTo(\"{\\\"text\\\": \\\"Mrs. Brian Braun\\\", \" +\n            \"\\\"objectCollection\\\": [{\\\"country\\\": \\\"Denmark\\\", \\\"city\\\": \\\"Port Angel\\\"}, {\\\"two\\\": \\\"Denmark\\\", \\\"one\\\": \\\"Port Angel\\\"}]}\");\n    }\n\n    @Test\n    void jsonCollectionOfCollectionsTest() {\n        JsonTransformer<Name> transformer = JsonTransformer.<Name>builder().build();\n\n        String json = transformer.generate(\n            Schema.of(\n                field(\"text\", () -> \"Mrs. Brian Braun\"),\n                field(\"objectCollection\", () -> List.of(\n                        List.of(\n                            List.of(\n                                compositeField(null, new Field[]{\n                                        field(\"country\", () -> \"Denmark\"),\n                                        field(\"city\", () -> \"Port Angel\")\n                                    }\n                                ),\n                                compositeField(null, new Field[]{\n                                        field(\"two\", () -> \"Denmark\"),\n                                        field(\"one\", () -> \"Port Angel\")\n                                    }\n                                )\n                            )\n                        )\n                    )\n                )\n            ), 1);\n        assertThat(json).isEqualTo(\"{\\\"text\\\": \\\"Mrs. Brian Braun\\\", \" +\n            \"\\\"objectCollection\\\": [[[{\\\"country\\\": \\\"Denmark\\\", \\\"city\\\": \\\"Port Angel\\\"}, {\\\"two\\\": \\\"Denmark\\\", \\\"one\\\": \\\"Port Angel\\\"}]]]}\");\n    }\n\n    private static Map.Entry<Supplier<String>, Supplier<Object>> entry(\n        Supplier<String> key, Supplier<Object> value) {\n        return new AbstractMap.SimpleEntry<>(key, value);\n    }\n\n    @SafeVarargs\n    private static Map<Supplier<String>, Supplier<Object>> map(\n        Map.Entry<Supplier<String>, Supplier<Object>>... entries) {\n        Map<Supplier<String>, Supplier<Object>> map = new LinkedHashMap<>();\n        for (Map.Entry<Supplier<String>, Supplier<Object>> entry : entries) {\n            map.put(entry.getKey(), entry.getValue());\n        }\n        return map;\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/formats/SqlTest.java.SqlTest", "name": "SqlTest", "file_path": "src/test/java/net/datafaker/formats/SqlTest.java", "superclasses": "", "methods": ["[void]generateFromFakeSequenceSeparated()", "[void]generateFromFakeSequenceBatch()", "[void]generateFromEmptySchema()", "[void]generateFromInfiniteFakeSequenceBatch()", "[void]testGenerateFromSchemaWithLimitSeparatedStatements()", "[void]testGenerateFromSchemaWithLimitBatchModeStatements()", "[void]testForceQuotedWithSqlIdentifiers()", "[void]simpleSqlTestForSqlTransformer(Schema<String, String>,String,String)", "[void]simpleSqlTestForSqlTransformerOracle(Schema<String, String>,String,String)", "[void]simpleSqlTestForSqlTransformerPostgres(Schema<String, String>,String,String)", "[void]simpleSqlTestForSqlTransformerMSSQL(Schema<String, String>,String,String)", "[void]simpleSqlTestForSqlTransformerMySQL(Schema<String, String>,String,String)", "[void]batchSqlTestForSqlTransformerPostgres()", "[void]sqlKeywordCaseCheck()", "[void]sqlKeywordCapitalCaseCheck()", "[void]batchSqlTestForSqlTransformerOracle()", "[void]batchSizeSqlTestForSqlTransformerOracle()", "[void]batchSizeSqlTestForSqlTransformerPostgres()", "[void]arrayAndMultisetSqlTestForSqlTransformerCalcite(Schema<String, String>,String,String)", "[void]batchTestForSqlTransformerSparkSql()", "[void]simpleSqlTestForSqlTransformerSparkSql(Schema<String, String>,String,String)", "[void]simpleStreamTestForSqlTransformerSparkSql(Schema<String, String>,String,String)", "[void]testSqlBatch()"], "method_uris": ["src/test/java/net/datafaker/formats/SqlTest.java.SqlTest.[Stream<Arguments>]generateTestSchema()", "src/test/java/net/datafaker/formats/SqlTest.java.SqlTest.[Stream<Arguments>]generateTestSchemaForOracle()", "src/test/java/net/datafaker/formats/SqlTest.java.SqlTest.[Stream<Arguments>]generateTestSchemaForPostgres()", "src/test/java/net/datafaker/formats/SqlTest.java.SqlTest.[Stream<Arguments>]generateTestSchemaForMSSQL()", "src/test/java/net/datafaker/formats/SqlTest.java.SqlTest.[Stream<Arguments>]generateTestSchemaForMySQL()", "src/test/java/net/datafaker/formats/SqlTest.java.SqlTest.[Stream<Arguments>]generateTestSchemaForCalcite()", "src/test/java/net/datafaker/formats/SqlTest.java.SqlTest.[Stream<Arguments>]generateTestSchemaForSparkSql()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class SqlTest {\n\n    @Test\n    void generateFromFakeSequenceSeparated() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Integer, ?> schema = Schema.of(\n            field(\"Number\", integer -> integer),\n            field(\"Password\", integer -> faker.internet().password(integer, integer))\n        );\n\n        SqlTransformer<Integer> transformer = SqlTransformer.<Integer>builder().build();\n        FakeSequence<Integer> fakeSequence = faker.<Integer>collection()\n            .suppliers(() -> faker.number().randomDigit())\n            .len(5)\n            .build();\n\n        String sql = transformer.generate(fakeSequence, schema);\n\n        String expected = \"INSERT INTO \\\"MyTable\\\" (\\\"Number\\\", \\\"Password\\\") VALUES (3, 'nf3');\" + LINE_SEPARATOR +\n            \"INSERT INTO \\\"MyTable\\\" (\\\"Number\\\", \\\"Password\\\") VALUES (6, '4b0v69');\" + LINE_SEPARATOR +\n            \"INSERT INTO \\\"MyTable\\\" (\\\"Number\\\", \\\"Password\\\") VALUES (7, '00827v2');\" + LINE_SEPARATOR +\n            \"INSERT INTO \\\"MyTable\\\" (\\\"Number\\\", \\\"Password\\\") VALUES (1, '5');\" + LINE_SEPARATOR +\n            \"INSERT INTO \\\"MyTable\\\" (\\\"Number\\\", \\\"Password\\\") VALUES (3, 'p6x');\";\n\n        assertThat(sql).isEqualTo(expected);\n    }\n\n    @Test\n    void generateFromFakeSequenceBatch() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Integer, ?> schema = Schema.of(\n            field(\"Number\", integer -> integer),\n            field(\"Password\", integer -> faker.internet().password(integer, integer))\n        );\n\n        SqlTransformer<Integer> transformer = SqlTransformer.<Integer>builder()\n            .batch()\n            .build();\n        FakeSequence<Integer> fakeSequence = faker.<Integer>collection()\n            .suppliers(() -> faker.number().randomDigit())\n            .len(5)\n            .build();\n\n        String sql = transformer.generate(fakeSequence, schema);\n\n        String expected =\n            \"INSERT INTO \\\"MyTable\\\" (\\\"Number\\\", \\\"Password\\\")\" + LINE_SEPARATOR +\n                \"VALUES (3, 'nf3'),\" + LINE_SEPARATOR +\n                \"       (6, '4b0v69'),\" + LINE_SEPARATOR +\n                \"       (7, '00827v2'),\" + LINE_SEPARATOR +\n                \"       (1, '5'),\" + LINE_SEPARATOR +\n                \"       (3, 'p6x');\";\n\n        assertThat(sql).isEqualTo(expected);\n    }\n\n    @Test\n    void generateFromEmptySchema() {\n        BaseFaker faker = new BaseFaker();\n        Schema<Integer, Object> schema = Schema.of();\n\n        SqlTransformer<Integer> transformer = SqlTransformer.<Integer>builder()\n            .build();\n\n        FakeSequence<Integer> fakeSequence = faker.<Integer>stream()\n            .suppliers(() -> faker.number().randomDigit())\n            .build();\n\n        assertThat(transformer.generate(fakeSequence, schema)).isEmpty();\n    }\n\n    @Test\n    void generateFromInfiniteFakeSequenceBatch() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Integer, ?> schema = Schema.of(\n            field(\"Number\", integer -> integer),\n            field(\"Password\", integer -> faker.internet().password(integer, integer))\n        );\n\n        SqlTransformer<Integer> transformer = SqlTransformer.<Integer>builder()\n            .batch()\n            .build();\n        FakeSequence<Integer> fakeSequence = faker.<Integer>stream()\n            .suppliers(() -> faker.number().randomDigit())\n            .build();\n\n        assertThatThrownBy(() -> transformer.generate(fakeSequence, schema))\n            .isInstanceOf(IllegalArgumentException.class)\n            .hasMessage(\"The sequence should be finite of size: FakeStream{minLength=-1, maxLength=-1, nullRate=0.0}\");\n    }\n\n    @Test\n    void testGenerateFromSchemaWithLimitSeparatedStatements() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Object, ?> schema = Schema.of(\n            field(\"Text\", () -> faker.name().firstName()),\n            field(\"Bool\", () -> faker.bool().bool())\n        );\n\n        SqlTransformer<Object> transformer = SqlTransformer.builder().build();\n        String sql = transformer.generate(schema, 2);\n\n        String expected =\n            \"INSERT INTO \\\"MyTable\\\" (\\\"Text\\\", \\\"Bool\\\") VALUES ('Willis', false);\" + LINE_SEPARATOR +\n            \"INSERT INTO \\\"MyTable\\\" (\\\"Text\\\", \\\"Bool\\\") VALUES ('Carlena', true);\";\n\n        assertThat(sql).isEqualTo(expected);\n    }\n\n    @Test\n    void testGenerateFromSchemaWithLimitBatchModeStatements() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Object, ?> schema = Schema.of(\n            field(\"Text\", () -> faker.name().firstName()),\n            field(\"Bool\", () -> faker.bool().bool())\n        );\n\n        SqlTransformer<Object> transformer = SqlTransformer.builder()\n            .batch()\n            .build();\n        String sql = transformer.generate(schema, 2);\n\n        String expected =\n            \"INSERT INTO \\\"MyTable\\\" (\\\"Text\\\", \\\"Bool\\\")\" + LINE_SEPARATOR +\n            \"VALUES ('Willis', false),\" + LINE_SEPARATOR +\n            \"       ('Carlena', true);\";\n\n        assertThat(sql).isEqualTo(expected);\n    }\n\n    @Test\n    void testForceQuotedWithSqlIdentifiers() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Object, ?> schema = Schema.of(\n            field(\"TEXT\", () -> faker.name().firstName()),\n            field(\"BOOL\", () -> faker.bool().bool()));\n\n        SqlTransformer<Object> forceQuotedTransformer = SqlTransformer.builder()\n            .tableName(\"MY_TABLE\")\n            .forceUseSqlQuoteIdentifier()\n            .batch()\n            .build();\n        String sql = forceQuotedTransformer.generate(schema, 2);\n\n        String expected = \"INSERT INTO \\\"MY_TABLE\\\" (\\\"TEXT\\\", \\\"BOOL\\\")\" + LINE_SEPARATOR +\n            \"VALUES ('Willis', false),\" + LINE_SEPARATOR +\n            \"       ('Carlena', true);\";\n\n        assertThat(sql).isEqualTo(expected);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateTestSchema\")\n    void simpleSqlTestForSqlTransformer(Schema<String, String> schema, String tableSchemaName, String expected) {\n        SqlTransformer<String> transformer =\n            SqlTransformer.<String>builder()\n                .sqlQuoteIdentifier(\"`\").schemaName(tableSchemaName).tableName(\"MY_TABLE\").build();\n        assertThat(transformer.generate(schema, 1)).isEqualTo(expected);\n    }\n\n    private static Stream<Arguments> generateTestSchema() {\n        return Stream.of(\n            of(Schema.of(), null, \"\"),\n            of(Schema.of(field(\"key\", () -> \"value\")), \"\", \"INSERT INTO MY_TABLE (`key`) VALUES ('value');\"),\n            of(Schema.of(field(\"number\", () -> 123)), \"\", \"INSERT INTO MY_TABLE (`number`) VALUES (123);\"),\n            of(Schema.of(field(\"number\", () -> 123.0)), null, \"INSERT INTO MY_TABLE (`number`) VALUES (123.0);\"),\n            of(Schema.of(field(\"number\", () -> 123.123)), null, \"INSERT INTO MY_TABLE (`number`) VALUES (123.123);\"),\n            of(Schema.of(field(\"boolean\", () -> true)), \"\", \"INSERT INTO MY_TABLE (`boolean`) VALUES (true);\"),\n            of(Schema.of(field(\"nullValue\", () -> null)), null, \"INSERT INTO MY_TABLE (`nullValue`) VALUES (null);\"),\n            of(Schema.of(field(\"nullValue\", () -> null)), \"My.SCHEMA\", \"INSERT INTO `My.SCHEMA`.MY_TABLE (`nullValue`) VALUES (null);\"),\n            of(Schema.of(field(\"nullValue\", () -> null)), \"MY_SCHEMA\", \"INSERT INTO MY_SCHEMA.MY_TABLE (`nullValue`) VALUES (null);\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateTestSchemaForOracle\")\n    void simpleSqlTestForSqlTransformerOracle(Schema<String, String> schema, String tableSchemaName, String expected) {\n        SqlTransformer<String> transformer =\n            SqlTransformer.<String>builder()\n                .schemaName(tableSchemaName).dialect(SqlDialect.ORACLE).build();\n        assertThat(transformer.generate(schema, 1)).isEqualTo(expected);\n    }\n\n    private static Stream<Arguments> generateTestSchemaForOracle() {\n        return Stream.of(\n            of(Schema.of(), null, \"\"),\n            of(Schema.of(field(\"key\", () -> \"value\")), \"\", \"INSERT INTO \\\"MyTable\\\" (\\\"key\\\") VALUES ('value');\"),\n            of(Schema.of(field(\"number\", () -> 123)), null, \"INSERT INTO \\\"MyTable\\\" (\\\"number\\\") VALUES (123);\"),\n            of(Schema.of(field(\"number\", () -> 123.0)), null, \"INSERT INTO \\\"MyTable\\\" (\\\"number\\\") VALUES (123.0);\"),\n            of(Schema.of(field(\"number\", () -> 123.123)), \"\", \"INSERT INTO \\\"MyTable\\\" (\\\"number\\\") VALUES (123.123);\"),\n            of(Schema.of(field(\"boolean\", () -> true)), null, \"INSERT INTO \\\"MyTable\\\" (\\\"boolean\\\") VALUES (true);\"),\n            of(Schema.of(field(\"nullValue\", () -> null)), null, \"INSERT INTO \\\"MyTable\\\" (\\\"nullValue\\\") VALUES (null);\"),\n            of(Schema.of(field(\"nullValue\", () -> null)), \"MySchema\", \"INSERT INTO \\\"MySchema\\\".\\\"MyTable\\\" (\\\"nullValue\\\") VALUES (null);\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateTestSchemaForPostgres\")\n    void simpleSqlTestForSqlTransformerPostgres(Schema<String, String> schema, String tableSchemaName, String expected) {\n        SqlTransformer<String> transformer =\n            SqlTransformer.<String>builder()\n                .schemaName(tableSchemaName).dialect(SqlDialect.POSTGRES).build();\n        assertThat(transformer.generate(schema, 1)).isEqualTo(expected);\n    }\n\n    private static Stream<Arguments> generateTestSchemaForPostgres() {\n        return Stream.of(\n            of(Schema.of(), null, \"\"),\n            of(Schema.of(field(\"key\", () -> \"value\")), \"\", \"INSERT INTO \\\"MyTable\\\" (\\\"key\\\") VALUES ('value');\"),\n            of(Schema.of(field(\"number\", () -> 123)), null, \"INSERT INTO \\\"MyTable\\\" (\\\"number\\\") VALUES (123);\"),\n            of(Schema.of(field(\"number\", () -> 123.0)), null, \"INSERT INTO \\\"MyTable\\\" (\\\"number\\\") VALUES (123.0);\"),\n            of(Schema.of(field(\"number\", () -> 123.123)), \"\", \"INSERT INTO \\\"MyTable\\\" (\\\"number\\\") VALUES (123.123);\"),\n            of(Schema.of(field(\"boolean\", () -> true)), null, \"INSERT INTO \\\"MyTable\\\" (\\\"boolean\\\") VALUES (true);\"),\n            of(Schema.of(field(\"nullValue\", () -> null)), null, \"INSERT INTO \\\"MyTable\\\" (\\\"nullValue\\\") VALUES (null);\"),\n            of(Schema.of(field(\"nullValue\", () -> null)), \"MySchema\", \"INSERT INTO \\\"MySchema\\\".\\\"MyTable\\\" (\\\"nullValue\\\") VALUES (null);\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateTestSchemaForMSSQL\")\n    void simpleSqlTestForSqlTransformerMSSQL(Schema<String, String> schema, String tableSchemaName, String expected) {\n        SqlTransformer<String> transformer =\n            SqlTransformer.<String>builder()\n                .schemaName(tableSchemaName).dialect(SqlDialect.MSSQL).build();\n        assertThat(transformer.generate(schema, 1)).isEqualTo(expected);\n    }\n\n    private static Stream<Arguments> generateTestSchemaForMSSQL() {\n        return Stream.of(\n            of(Schema.of(), null, \"\"),\n            of(Schema.of(field(\"key\", () -> \"value\")), \"\", \"INSERT INTO [MyTable] ([key]) VALUES ('value');\"),\n            of(Schema.of(field(\"number\", () -> 123)), null, \"INSERT INTO [MyTable] ([number]) VALUES (123);\"),\n            of(Schema.of(field(\"number\", () -> 123.0)), null, \"INSERT INTO [MyTable] ([number]) VALUES (123.0);\"),\n            of(Schema.of(field(\"number\", () -> 123.123)), \"\", \"INSERT INTO [MyTable] ([number]) VALUES (123.123);\"),\n            of(Schema.of(field(\"boolean\", () -> true)), \"\", \"INSERT INTO [MyTable] ([boolean]) VALUES (true);\"),\n            of(Schema.of(field(\"nullValue\", () -> null)), null, \"INSERT INTO [MyTable] ([nullValue]) VALUES (null);\"),\n            of(Schema.of(field(\"nullValue\", () -> null)), \"MySchema\", \"INSERT INTO [MySchema].[MyTable] ([nullValue]) VALUES (null);\"));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateTestSchemaForMySQL\")\n    void simpleSqlTestForSqlTransformerMySQL(Schema<String, String> schema, String tableSchemaName, String expected) {\n        SqlTransformer<String> transformer =\n            SqlTransformer.<String>builder()\n                .schemaName(tableSchemaName).dialect(SqlDialect.MYSQL).build();\n        assertThat(transformer.generate(schema, 1)).isEqualTo(expected);\n    }\n\n    private static Stream<Arguments> generateTestSchemaForMySQL() {\n        return Stream.of(\n            of(Schema.of(), null, \"\"),\n            of(Schema.of(field(\"key\", () -> \"value\")), \"\", \"INSERT INTO MyTable (key) VALUES ('value');\"),\n            of(Schema.of(field(\"number\", () -> 123)), \"\", \"INSERT INTO MyTable (number) VALUES (123);\"),\n            of(Schema.of(field(\"number\", () -> 123.0)), null, \"INSERT INTO MyTable (number) VALUES (123.0);\"),\n            of(Schema.of(field(\"number\", () -> 123.123)), null, \"INSERT INTO MyTable (number) VALUES (123.123);\"),\n            of(Schema.of(field(\"boolean\", () -> true)), null, \"INSERT INTO MyTable (boolean) VALUES (true);\"),\n            of(Schema.of(field(\"nullValue\", () -> null)), null, \"INSERT INTO MyTable (nullValue) VALUES (null);\"),\n            of(Schema.of(field(\"nullValue\", () -> null)), \"MySchema\", \"INSERT INTO MySchema.MyTable (nullValue) VALUES (null);\"));\n    }\n\n    @Test\n    void batchSqlTestForSqlTransformerPostgres() {\n        Faker faker = new Faker();\n        Schema<String, String> schema =\n            Schema.of(field(\"firstName\", () -> faker.name().firstName()),\n                field(\"lastName\", () -> faker.name().lastName()));\n        SqlTransformer<String> transformer =\n            SqlTransformer.<String>builder()\n                .batch()\n                .dialect(SqlDialect.POSTGRES)\n                .build();\n        final int limit = 5;\n        String output = transformer.generate(schema, limit);\n        assertThat(output.split(LINE_SEPARATOR)).hasSize(limit + 1);\n    }\n\n    @Test\n    void sqlKeywordCaseCheck() {\n        Faker faker = new Faker();\n        Schema<String, String> schema =\n            Schema.of(field(\"firstName\", () -> faker.name().firstName()),\n                field(\"lastName\", () -> faker.name().lastName()));\n        SqlTransformer<String> transformer =\n            SqlTransformer.<String>builder()\n                .keywordCase(SqlTransformer.Case.LOWERCASE)\n                .dialect(SqlDialect.POSTGRES).build();\n        final int limit = 1;\n        assertThat(transformer.generate(schema, limit))\n            .contains(\"insert into \")\n            .doesNotContain(\"INSERT INTO \")\n            .contains(\"values \")\n            .doesNotContain(\"VALUES\");\n    }\n\n    @Test\n    void sqlKeywordCapitalCaseCheck() {\n        Faker faker = new Faker();\n        Schema<String, String> schema =\n            Schema.of(field(\"firstName\", () -> faker.name().firstName()),\n                field(\"lastName\", () -> faker.name().lastName()));\n        SqlTransformer<String> transformer =\n            SqlTransformer.<String>builder()\n                .keywordCase(SqlTransformer.Case.CAPITAL)\n                .dialect(SqlDialect.POSTGRES).build();\n        final int limit = 1;\n        assertThat(transformer.generate(schema, limit))\n            .contains(\"Insert Into \")\n            .doesNotContain(\"INSERT INTO \")\n            .doesNotContain(\"insert into\")\n            .contains(\"Values \")\n            .doesNotContain(\"VALUES\")\n            .doesNotContain(\"values\");\n    }\n\n    @Test\n    void batchSqlTestForSqlTransformerOracle() {\n        Faker faker = new Faker();\n        Schema<String, String> schema =\n            Schema.of(field(\"firstName\", () -> faker.name().firstName()),\n                field(\"lastName\", () -> faker.name().lastName()));\n        SqlTransformer<String> transformerUpper =\n            SqlTransformer.<String>builder()\n                .batch()\n                .dialect(SqlDialect.ORACLE).build();\n        final int limit = 5;\n        String output = transformerUpper.generate(schema, limit);\n        assertThat(output.split(LINE_SEPARATOR)).hasSize(limit + 2);\n        assertThat(output)\n            .contains(\"INSERT ALL\")\n            .contains(\"INTO\")\n            .doesNotContain(\"INSERT INTO\")\n            .contains(\"SELECT 1 FROM dual;\");\n        SqlTransformer<String> transformerLower =\n            SqlTransformer.<String>builder()\n                .batch()\n                .keywordCase(SqlTransformer.Case.LOWERCASE)\n                .dialect(SqlDialect.ORACLE).build();\n        output = transformerLower.generate(schema, limit);\n        assertThat(output.split(LINE_SEPARATOR)).hasSize(limit + 2);\n        assertThat(output)\n            .contains(\"insert all\")\n            .contains(\"into\")\n            .doesNotContain(\"insert into\")\n            .contains(\"select 1 from dual;\");\n    }\n\n    @Test\n    void batchSizeSqlTestForSqlTransformerOracle() {\n        Faker faker = new Faker();\n        Schema<String, String> schema =\n            Schema.of(field(\"firstName\", () -> faker.name().firstName()),\n                field(\"lastName\", () -> faker.name().lastName()));\n        SqlTransformer<String> transformerUpper =\n            SqlTransformer.<String>builder()\n                .batch(2)\n                .dialect(SqlDialect.ORACLE).build();\n        final int limit = 5;\n        String output = transformerUpper.generate(schema, limit);\n        assertThat(output.split(\"INSERT ALL\")).hasSize(4);\n        assertThat(output.split(\"SELECT 1 FROM dual\")).hasSize(4);\n    }\n\n    @Test\n    void batchSizeSqlTestForSqlTransformerPostgres() {\n        Faker faker = new Faker();\n        Schema<String, String> schema =\n            Schema.of(field(\"firstName\", () -> faker.name().firstName()),\n                field(\"lastName\", () -> faker.name().lastName()));\n        SqlTransformer<String> transformerUpper =\n            SqlTransformer.<String>builder()\n                .batch(2)\n                .dialect(SqlDialect.POSTGRES).build();\n        final int limit = 5;\n        String output = transformerUpper.generate(schema, limit);\n        assertThat(output.split(\"INSERT INTO\")).hasSize(4);\n        assertThat(output.split(\"VALUES \")).hasSize(4);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateTestSchemaForCalcite\")\n    void arrayAndMultisetSqlTestForSqlTransformerCalcite(Schema<String, String> schema, String tableSchemaName, String expected) {\n        SqlTransformer<String> transformer =\n            SqlTransformer.<String>builder()\n                .schemaName(tableSchemaName).dialect(SqlDialect.CALCITE).build();\n        assertThat(transformer.generate(schema, 1)).isEqualTo(expected);\n    }\n\n    private static Stream<Arguments> generateTestSchemaForCalcite() {\n        return Stream.of(\n            of(Schema.of(), null, \"\"),\n            of(Schema.of(field(\"ints\", () -> new int[]{1, 2, 3})), \"\", \"INSERT INTO \\\"MyTable\\\" (\\\"ints\\\") VALUES (ARRAY[1, 2, 3]);\"),\n            of(Schema.of(field(\"longs\", () -> new long[]{23L, 45L})), null, \"INSERT INTO \\\"MyTable\\\" (\\\"longs\\\") VALUES (ARRAY[23, 45]);\"),\n            of(Schema.of(field(\"bytes\", () -> new byte[]{1, 0})), null, \"INSERT INTO \\\"MyTable\\\" (\\\"bytes\\\") VALUES (ARRAY[1, 0]);\"),\n            of(Schema.of(field(\"shorts\", () -> new short[]{1, 0, 3})), null, \"INSERT INTO \\\"MyTable\\\" (\\\"shorts\\\") VALUES (ARRAY[1, 0, 3]);\"),\n            of(Schema.of(field(\"booleans\", () -> new boolean[]{true, false})), null, \"INSERT INTO \\\"MyTable\\\" (\\\"booleans\\\") VALUES (ARRAY[true, false]);\"),\n            of(Schema.of(field(\"floats\", () -> new float[]{1f, 0f, 3f})), null, \"INSERT INTO \\\"MyTable\\\" (\\\"floats\\\") VALUES (ARRAY[1.0, 0.0, 3.0]);\"),\n            of(Schema.of(field(\"doubles\", () -> new double[]{1d, 5d, 3d})), null, \"INSERT INTO \\\"MyTable\\\" (\\\"doubles\\\") VALUES (ARRAY[1.0, 5.0, 3.0]);\"),\n            of(Schema.of(field(\"names\", () -> new String[]{\"hello\", \"world\"})),\n                null, \"INSERT INTO \\\"MyTable\\\" (\\\"names\\\") VALUES (ARRAY['hello', 'world']);\"),\n            of(Schema.of(field(\"names_list\", () -> List.of(\"hello\", \"hello\"))),\n                \"\", \"INSERT INTO \\\"MyTable\\\" (\\\"names_list\\\") VALUES (MULTISET['hello', 'hello']);\"),\n            of(Schema.of(field(\"names_multiset\", () -> Set.of(\"hello\"))),\n                \"\", \"INSERT INTO \\\"MyTable\\\" (\\\"names_multiset\\\") VALUES (MULTISET['hello']);\"),\n            of(Schema.of(field(\"ints_ints\", () -> new int[][]{new int[]{1}, null, new int[] {3, 4, 5}})),\n                \"\", \"INSERT INTO \\\"MyTable\\\" (\\\"ints_ints\\\") VALUES (ARRAY[ARRAY[1], NULL, ARRAY[3, 4, 5]]);\"),\n            of(Schema.of(field(\"ints_ints\", () -> new int[][]{new int[]{1}, new int[]{2}, new int[] {3, 4, 5}})),\n                \"\", \"INSERT INTO \\\"MyTable\\\" (\\\"ints_ints\\\") VALUES (ARRAY[ARRAY[1], ARRAY[2], ARRAY[3, 4, 5]]);\"),\n            of(Schema.of(field(\"multiset\", () -> Set.of(Set.of(Set.of(\"value\"))))),\n                \"\", \"INSERT INTO \\\"MyTable\\\" (\\\"multiset\\\") VALUES (MULTISET[MULTISET[MULTISET['value']]]);\"),\n            of(Schema.of(field(\"multiset_array\", () -> Set.of(new int[]{1, 2}))),\n                \"\", \"INSERT INTO \\\"MyTable\\\" (\\\"multiset_array\\\") VALUES (MULTISET[ARRAY[1, 2]]);\"),\n            of(Schema.of(field(\"array_multiset\", () -> new Object[]{Set.of(\"value\")})),\n                \"\", \"INSERT INTO \\\"MyTable\\\" (\\\"array_multiset\\\") VALUES (ARRAY[MULTISET['value']]);\"),\n            of(Schema.of(compositeField(\"row\", new Field[]{field(\"name\", () -> \"2\")})),\n                null, \"INSERT INTO \\\"MyTable\\\" (\\\"row\\\") VALUES (ROW('2'));\"),\n            of(Schema.of(compositeField(\"row_row\",\n                    new Field[]{field(\"name1\", () -> \"1\"), compositeField(\"row\", new Field[]{field(\"name\", () -> \"2\")})})),\n                    null, \"INSERT INTO \\\"MyTable\\\" (\\\"row_row\\\") VALUES (ROW('1', ROW('2')));\"),\n            of(Schema.of(compositeField(\"row_array\",\n                    new Field[]{field(\"name1\", () -> \"1\"),\n                        compositeField(\"row\", new Field[]{field(\"name\", () -> new int[]{1, 2, 3})})})),\n                null, \"INSERT INTO \\\"MyTable\\\" (\\\"row_array\\\") VALUES (ROW('1', ROW(ARRAY[1, 2, 3])));\")\n        );\n    }\n\n    @Test\n    void batchTestForSqlTransformerSparkSql() {\n        int batchSize =  5;\n        int records = 20;\n        Faker faker = new Faker();\n\n        SqlTransformer<String> transformer =\n            SqlTransformer.<String>builder()\n                .dialect(SqlDialect.SPARKSQL)\n                .batch(batchSize)\n                .build();\n\n        String generation =\n            transformer\n                .generate(\n                    Schema.of(\n                        field(\"name\", () -> faker.cat().name()),\n                        field(\"breed\", () -> faker.cat().breed())\n                    ), records\n                );\n\n        assertThat(generation.split(\"INSERT INTO\")).hasSize((records / batchSize) + 1);\n        assertThat(generation.split(\"VALUES\")).hasSize((records / batchSize) + 1);\n        assertThat(generation.split(\";\")).hasSize((records / batchSize));\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateTestSchemaForSparkSql\")\n    void simpleSqlTestForSqlTransformerSparkSql(Schema<String, String> schema, String tableSchemaName, String expected) {\n        SqlTransformer<String> transformer =\n            SqlTransformer.<String>builder()\n                .schemaName(tableSchemaName)\n                .dialect(SqlDialect.SPARKSQL)\n                .build();\n\n        assertThat(transformer.generate(schema, 1)).isEqualTo(expected);\n    }\n\n    private static Stream<Arguments> generateTestSchemaForSparkSql() {\n\n        /*\n         * Maps must be ordered in order to have deterministic SQL statement.\n         */\n        Supplier<Map<String, String>> supplySmallMap =\n            () -> new TreeMap<>(Map.of(\"k1\", \"v1\"));\n\n        Supplier<Map<String, Object>> supplyBigMap =\n            () -> new TreeMap<>(Map.of(\"k1\", supplySmallMap.get(), \"k2\",  supplySmallMap.get()));\n\n        return Stream.of(\n            of(Schema.of(), null, \"\"),\n            of(Schema.of(field(\"bytes\", () -> new byte[]{1, 0})), null,\n                \"INSERT INTO `MyTable` (`bytes`) VALUES (ARRAY(1, 0));\"),\n            of(Schema.of(field(\"booleans\", () -> new boolean[]{true, false})), null,\n                \"INSERT INTO `MyTable` (`booleans`) VALUES (ARRAY(true, false));\"),\n            of(Schema.of(field(\"ints\", () -> new int[]{1, 2, 3})), \"\",\n                \"INSERT INTO `MyTable` (`ints`) VALUES (ARRAY(1, 2, 3));\"),\n            of(Schema.of(field(\"longs\", () -> new long[]{23L, 45L})), null,\n                \"INSERT INTO `MyTable` (`longs`) VALUES (ARRAY(23, 45));\"),\n            of(Schema.of(field(\"empty_map\", Map::of)), null,\n                \"INSERT INTO `MyTable` (`empty_map`) VALUES (MAP());\"),\n            of(Schema.of(field(\"maps\", supplyBigMap)), null,\n                \"INSERT INTO `MyTable` (`maps`) VALUES (MAP('k1', MAP('k1', 'v1'), 'k2', MAP('k1', 'v1')));\"),\n            of(Schema.of(\n                compositeField(\"struct_array\", new Field[]{field(\"name1\", () -> \"1\"), compositeField(\"struct\", new Field[]{field(\"name\", () -> new int[]{1, 2, 3})})})), null,\n                \"INSERT INTO `MyTable` (`struct_array`) VALUES (NAMED_STRUCT('name1', '1', 'struct', NAMED_STRUCT('name', ARRAY(1, 2, 3))));\"),\n            of(Schema.of(\n                compositeField(\"struct_struct\", new Field[]{field(\"name1\", () -> \"1\"), compositeField(\"struct\", new Field[]{field(\"name\", () -> \"2\")})})), null,\n                \"INSERT INTO `MyTable` (`struct_struct`) VALUES (NAMED_STRUCT('name1', '1', 'struct', NAMED_STRUCT('name', '2')));\")\n        );\n    }\n\n\n    @ParameterizedTest\n    @MethodSource(\"generateTestSchemaForSparkSql\")\n    void simpleStreamTestForSqlTransformerSparkSql(Schema<String, String> schema, String tableSchemaName, String expected) {\n        SqlTransformer<String> transformer =\n            SqlTransformer\n                .<String>builder()\n                .schemaName(tableSchemaName)\n                .dialect(SqlDialect.SPARKSQL).build();\n\n        String sql =\n            transformer\n                .generateStream(schema, 1)\n                .collect(Collectors.joining(LINE_SEPARATOR));\n\n        assertThat(sql).isEqualTo(expected);\n    }\n\n    @Test\n    void testSqlBatch() {\n        BaseFaker faker = new BaseFaker(new Random(10L));\n        Schema<Integer, ?> schema = Schema.of(\n            field(\"Number\", () -> faker.number().digit()),\n            field(\"Password\", () -> faker.internet().uuidv3())\n        );\n\n        SqlTransformer<Integer> transformer =\n            SqlTransformer\n                .<Integer>builder()\n                .batch(3)\n                .build();\n\n        String sql =\n            transformer\n                .generateStream(schema, 4)\n                .collect(Collectors.joining(LINE_SEPARATOR));\n\n        String expected =\n            \"INSERT INTO \\\"MyTable\\\" (\\\"Number\\\", \\\"Password\\\")\" + LINE_SEPARATOR +\n                \"VALUES ('6', '09fd4007-40ba-39df-8cb1-65926bf7b8a9'),\" + LINE_SEPARATOR +\n                \"       ('8', '96c19757-1f18-3051-9acb-f56f0b5555ae'),\" + LINE_SEPARATOR +\n                \"       ('2', '8a4a0365-cd39-33c1-a52a-279b1076cf2d');\" + LINE_SEPARATOR +\n                \"INSERT INTO \\\"MyTable\\\" (\\\"Number\\\", \\\"Password\\\")\" + LINE_SEPARATOR +\n                \"VALUES ('6', 'e807efdd-b6db-319d-8342-a044274d3417');\";\n\n        assertThat(sql).isEqualTo(expected);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/formats/XmlTest.java.XmlTest", "name": "XmlTest", "file_path": "src/test/java/net/datafaker/formats/XmlTest.java", "superclasses": "", "methods": ["[void]xmlSchemaTest(Schema<String, String>,String)", "[void]xmlPrettySchemaTest(Schema<String, String>,String)", "[void]generateFromFakeSequence()", "[void]generateXMLWithThreeNestedLevels()", "[void]generateXMLWithThreeNestedLevelsAndAttributes()"], "method_uris": ["src/test/java/net/datafaker/formats/XmlTest.java.XmlTest.[Stream<Arguments>]generateTestXmlSchema()", "src/test/java/net/datafaker/formats/XmlTest.java.XmlTest.[Stream<Arguments>]generateTestXmlPrettySchema()", "src/test/java/net/datafaker/formats/XmlTest.java.XmlTest.[int]getNumberOfLines(String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class XmlTest {\n\n    @ParameterizedTest\n    @MethodSource(\"generateTestXmlSchema\")\n    void xmlSchemaTest(Schema<String, String> schema, String expected) {\n        XmlTransformer<String> xmlTransformer = new XmlTransformer.XmlTransformerBuilder<String>().build();\n        assertThat(xmlTransformer.generate(schema, 1)).isEqualTo(expected);\n    }\n\n    private static Stream<Arguments> generateTestXmlSchema() {\n        return Stream.of(\n            of(Schema.of(field(\"root\", Collections::emptyList)), \"<root/>\"),\n            of(Schema.of((field(\"root\", () -> \"value\"))), \"<root>value</root>\"),\n            of(Schema.of(\n                    compositeField(\"root\",\n                        new Field[]{field(\"attribute1\", () -> \"value1\"), field(\"attribute2\", () -> \"value2\")})),\n                \"<root attribute1=\\\"value1\\\" attribute2=\\\"value2\\\"/>\"),\n            of(Schema.of(\n                    compositeField(\"root\",\n                        new Field[]{field(\"attribute1\", () -> \"value1\"), field(\"attribute2\", () -> \"value2\"), field(null, () -> \"value\"),})),\n                \"<root attribute1=\\\"value1\\\" attribute2=\\\"value2\\\">value</root>\"),\n            of(Schema.of(\n                    compositeField(\"root\",\n                        new Field[]{field(\"attribute1\", () -> \"value1\"), field(\"attribute2\", () -> \"value2\"),\n                            field(null, () -> List.of(field(\"child\", () -> \"value\")))})),\n                \"<root attribute1=\\\"value1\\\" attribute2=\\\"value2\\\"><child>value</child></root>\"),\n            of(Schema.of(field(\"root\", () -> \"<> value\\\"\")), \"<root>&lt;&gt; value&quot;</root>\")\n        );\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"generateTestXmlPrettySchema\")\n    void xmlPrettySchemaTest(Schema<String, String> schema, String expected) {\n        XmlTransformer<String> xmlTransformer = new XmlTransformer.XmlTransformerBuilder<String>().pretty(true).build();\n        assertThat(xmlTransformer.generate(schema, 1)).isEqualTo(expected);\n    }\n\n    private static Stream<Arguments> generateTestXmlPrettySchema() {\n        return Stream.of(\n            of(Schema.of(field(\"root\", Collections::emptyList)), \"<root/>\"),\n            of(Schema.of((field(\"root\", () -> \"value\"))), \"<root>value</root>\"),\n            of(Schema.of(\n                    compositeField(\"root\",\n                        new Field[]{field(\"attribute1\", () -> \"value1\"), field(\"attribute2\", () -> \"value2\")})),\n                \"<root attribute1=\\\"value1\\\" attribute2=\\\"value2\\\"/>\"),\n            of(Schema.of(\n                    compositeField(\"root\",\n                        new Field[]{field(\"attribute1\", () -> \"value1\"), field(\"attribute2\", () -> \"value2\"), field(null, () -> \"value\"),})),\n                \"<root attribute1=\\\"value1\\\" attribute2=\\\"value2\\\">value</root>\"),\n            of(Schema.of(\n                    compositeField(\"root\",\n                        new Field[]{field(\"attribute1\", () -> \"value1\"), field(\"attribute2\", () -> \"value2\"),\n                            field(null, () -> List.of(field(\"child\", () -> \"value\")))})),\n                \"<root attribute1=\\\"value1\\\" attribute2=\\\"value2\\\">\" + System.lineSeparator() + \"    <child>value</child>\" + System.lineSeparator() + \"</root>\"),\n            of(Schema.of(field(\"root\", () -> \"<> value\\\"\")), \"<root>&lt;&gt; value&quot;</root>\")\n        );\n    }\n\n    @Test\n    void generateFromFakeSequence() {\n        final BaseFaker faker = new BaseFaker();\n\n        Schema<Name, List<SimpleField<Name, String>>> schema = Schema.of(\n            field(\"root\",\n                () -> List.of(\n                    field(\"firstName\", Name::firstName),\n                    field(\"lastName\", Name::lastName))));\n\n        XmlTransformer<Name> transformer = new XmlTransformer.XmlTransformerBuilder<Name>().pretty(true).build();\n        String xml = transformer.generate(\n            faker.<Name>collection().suppliers(faker::name).maxLen(1).build(),\n            schema);\n\n        int numberOfLines = getNumberOfLines(xml);\n        assertThat(numberOfLines).isEqualTo(4);\n    }\n\n    @Test\n    void generateXMLWithThreeNestedLevels() {\n        final BaseFaker faker = new BaseFaker();\n\n        FakeStream<?> address = (FakeStream<SimpleField<String, List<Object>>>)\n            faker.<SimpleField<String, List<Object>>>stream()\n                .suppliers(() ->\n                    field(\"address\",\n                        () -> List.of(\n                            field(\"country\", () -> faker.address().country()),\n                            field(\"city\", () -> faker.address().city()),\n                            field(\"streetAddress\", () -> faker.address().streetAddress()))))\n                .maxLen(3).build();\n\n        FakeStream<?> persons = (FakeStream<SimpleField<Object, List<Object>>>)\n            faker.<SimpleField<Object, List<Object>>>stream()\n                .suppliers(() ->\n                    field(\"person\",\n                        () -> List.of(\n                            field(\"firstname\", () -> faker.name().firstName()),\n                            field(\"lastname\", () -> faker.name().lastName()),\n                            field(\"addresses\", () -> address.get().collect(Collectors.toList())))))\n                .maxLen(3).build();\n\n\n        XmlTransformer<Object> xmlTransformer = new XmlTransformer.XmlTransformerBuilder<>().pretty(true).build();\n        String xml = xmlTransformer.generate(Schema.of(field(\"persons\", () -> persons.get().collect(Collectors.toList()))), 1).toString();\n        assertThat(xml).isNotEmpty();\n        int numberOfLines = getNumberOfLines(xml);\n        assertThat(numberOfLines).isEqualTo(65);\n    }\n\n    @Test\n    void generateXMLWithThreeNestedLevelsAndAttributes() {\n        final BaseFaker faker = new BaseFaker();\n        FakeStream<Object> address =\n            (FakeStream<Object>) faker.stream()\n                .suppliers(() ->\n                    compositeField(\"address\",\n                        new Field[]{\n                            field(\"country\", () -> faker.address().country()),\n                            field(\"city\", () -> faker.address().city()),\n                            field(\"streetAddress\", () -> faker.address().streetAddress())}))\n                .maxLen(3).build();\n\n        FakeStream<Object> persons =\n            (FakeStream<Object>) faker.stream()\n                .suppliers(() ->\n                    compositeField(\"person\",\n                        new Field[]{\n                            field(\"firstname\", () -> faker.name().firstName()),\n                            field(\"lastname\", () -> faker.name().lastName()),\n                            field(null, () -> List.of(field(\"addresses\", () -> address.get().collect(Collectors.toList()))))}))\n                .maxLen(3).build();\n\n        XmlTransformer<Object> xmlTransformer = new XmlTransformer.XmlTransformerBuilder<>().pretty(true).build();\n        String xml = xmlTransformer.generate(Schema.of(field(\"persons\", () -> persons.get().collect(Collectors.toList()))), 1).toString();\n        assertThat(xml).isNotEmpty();\n        int numberOfLines = getNumberOfLines(xml);\n        assertThat(numberOfLines).isEqualTo(23);\n    }\n\n    private static int getNumberOfLines(String xml) {\n        int numberOfLines = 1;\n        for (int i = 0; i < xml.length(); i++) {\n            if (xml.regionMatches(i, System.lineSeparator(), 0, System.lineSeparator().length())) {\n                numberOfLines++;\n            }\n        }\n        return numberOfLines;\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/formats/YamlTest.java.YamlTest", "name": "YamlTest", "file_path": "src/test/java/net/datafaker/formats/YamlTest.java", "superclasses": "", "methods": ["[void]simpleYamlTest(Schema<String, String>,String)", "[void]generateFromFakeSequence(int)", "[void]generateFromFakeSequenceWithCollection(int)"], "method_uris": ["src/test/java/net/datafaker/formats/YamlTest.java.YamlTest.[Stream<Arguments>]generateTestSchema()", "src/test/java/net/datafaker/formats/YamlTest.java.YamlTest.[Map<Supplier<String>, Supplier<Object>>]map()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class YamlTest {\n\n    @ParameterizedTest\n    @MethodSource(\"generateTestSchema\")\n    void simpleYamlTest(Schema<String, String> schema, String expected) {\n        YamlTransformer<String> yamlTransformer = new YamlTransformer<>();\n        assertThat(yamlTransformer.generate(schema, 1)).isEqualTo(expected);\n    }\n\n    private static Stream<Arguments> generateTestSchema() {\n        return Stream.of(\n            of(Schema.of(), \"\"),\n            of(Schema.of(field(\"key\", () -> \"value\")), \"key: value\" + System.lineSeparator()),\n            of(Schema.of(field(\"number\", () -> 123)), \"number: 123\" + System.lineSeparator()),\n            of(Schema.of(field(\"number\", () -> BigDecimal.valueOf(123.0))), \"number: 123.0\" + System.lineSeparator()),\n            of(Schema.of(field(\"number\", () -> BigDecimal.valueOf(123.123))), \"number: 123.123\" + System.lineSeparator()),\n            of(Schema.of(field(\"boolean\", () -> true)), \"boolean: true\" + System.lineSeparator()),\n            of(Schema.of(field(\"nullValue\", () -> null)), \"nullValue: null\" + System.lineSeparator()),\n            of(Schema.of(field(\"array\", () -> new String[]{null, \"test\", \"123\"})),\n                \"array:\" + System.lineSeparator()\n                    + \"  - null\" + System.lineSeparator()\n                    + \"  - test\" + System.lineSeparator()\n                    + \"  - 123\" + System.lineSeparator()),\n            of(Schema.of(field(\"array\", () -> new Integer[]{123, 456, 789})),\n                \"array:\" + System.lineSeparator()\n                    + \"  - 123\" + System.lineSeparator()\n                    + \"  - 456\" + System.lineSeparator()\n                    + \"  - 789\" + System.lineSeparator()),\n            of(Schema.of(field(\"array\", () -> new Object[]{\"test\", 456, true})),\n                \"array:\" + System.lineSeparator()\n                    + \"  - test\" + System.lineSeparator()\n                    + \"  - 456\" + System.lineSeparator()\n                    + \"  - true\" + System.lineSeparator()),\n            of(Schema.of(field(\"emptyarray\", () -> new Long[]{})), \"emptyarray:\" + System.lineSeparator()),\n            of(Schema.of(field(\"emptyarray\", Collections::emptyList)), \"emptyarray:\" + System.lineSeparator()),\n            of(Schema.of(field(\"key\", () -> \"value\"),\n                    field(\"nested\", () -> Schema.of(field(\"nestedkey\", () -> \"nestedvalue\")))),\n                \"key: value\" + System.lineSeparator() + \"nested:\" + System.lineSeparator() + \"  nestedkey: nestedvalue\" + System.lineSeparator()),\n            of(Schema.of(field(\"key\", () -> \"value\"),\n                    field(\"nested\",\n                        () -> Schema.of(field(\"nestedkey\", () -> \"nestedvalue\"),\n                            field(\"nested2\", () -> Schema.of(field(\"nestedkey2\", () -> \"nestedvalue2\")))))),\n                \"key: value\" + System.lineSeparator()\n                    + \"nested:\" + System.lineSeparator() + \"  nestedkey: nestedvalue\" + System.lineSeparator()\n                    + \"  nested2:\" + System.lineSeparator()\n                    + \"    nestedkey2: nestedvalue2\" + System.lineSeparator())\n        );\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {1, 4, 8})\n    void generateFromFakeSequence(int limit) {\n        final BaseFaker faker = new BaseFaker();\n        Schema<Name, String> schema = Schema.of(field(\"firstName\", Name::firstName));\n\n        YamlTransformer<Name> transformer = new YamlTransformer<>();\n        String yaml =\n            transformer.generate(\n                faker.<Name>collection().suppliers(faker::name).maxLen(limit).build(),\n                schema);\n\n        int numberOfLines = 0;\n        for (int i = 0; i < yaml.length(); i++) {\n            if (yaml.regionMatches(i, System.lineSeparator(), 0, System.lineSeparator().length())) {\n                numberOfLines++;\n            }\n        }\n\n        assertThat(numberOfLines).isEqualTo((limit * (schema.getFields().length + 1)) - 1);\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {1, 4, 8})\n    void generateFromFakeSequenceWithCollection(int limit) {\n        final BaseFaker faker = new BaseFaker();\n        Schema<Name, List<String>> schema = Schema.of(field(\"firstNames\", name -> IntStream.rangeClosed(1, limit)\n            .mapToObj(it -> name.firstName()).collect(Collectors.toList())));\n\n        YamlTransformer<Name> transformer = new YamlTransformer<>();\n        String yaml =\n            transformer.generate(\n                faker.<Name>collection().suppliers(faker::name).maxLen(1).build(),\n                schema);\n\n        int numberOfLines = 0;\n        for (int i = 0; i < yaml.length(); i++) {\n            if (yaml.regionMatches(i, System.lineSeparator(), 0, System.lineSeparator().length())) {\n                numberOfLines++;\n            }\n        }\n\n        assertThat(numberOfLines).isEqualTo(limit + 1);\n    }\n\n    @SafeVarargs\n    private static Map<Supplier<String>, Supplier<Object>> map(Map.Entry<Supplier<String>, Supplier<Object>>... entries) {\n        Map<Supplier<String>, Supplier<Object>> map = new LinkedHashMap<>();\n        for (Map.Entry<Supplier<String>, Supplier<Object>> entry : entries) {\n            map.put(entry.getKey(), entry.getValue());\n        }\n        return map;\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/annotations/FakeAnnotationTest.java.FakeAnnotationTest", "name": "FakeAnnotationTest", "file_path": "src/test/java/net/datafaker/annotations/FakeAnnotationTest.java", "superclasses": "", "methods": ["[void]shouldGenerateEntityWithDefaultSchema()", "[void]shouldGenerateEntityFromJavaRecordWithDefaultSchema()", "[void]shouldGenerateEntityWithCustomSchema()", "[void]shouldGenerateEntityFromJavaRecordWithCustomSchema()", "[void]shouldGenerateEntityWithCustomSchemaWhenClassTemplateWithoutAnnotation()", "[void]shouldGenerateEntityFromJavaRecordWithCustomSchemaWhenClassTemplateWithoutAnnotation()", "[void]shouldGenerateEntityFromJavaRecordWithComplexSchemaWhenClassTemplateWithoutAnnotation()", "[void]shouldGenerateEntityWithDefaultSchemaAndInDefaultSchemaInCurrentClass()", "[void]shouldGenerateEntityWithDefaultSchemaAndInDefaultSchemaInCurrentClass2()", "[void]shouldGenerateEntityFromJavaRecordWithDefaultSchemaAndInDefaultSchemaInCurrentClass()"], "method_uris": ["src/test/java/net/datafaker/annotations/FakeAnnotationTest.java.FakeAnnotationTest.[Schema<Object, ?>]defaultSchema()", "src/test/java/net/datafaker/annotations/FakeAnnotationTest.java.FakeAnnotationTest.[Schema<Object, ?>]customSchema()", "src/test/java/net/datafaker/annotations/FakeAnnotationTest.java.FakeAnnotationTest.[Schema<Object, ?>]complexSchema()"], "overrides": null, "attributes": [{"original_string": "    @FakeForSchema(\"defaultSchema\")\n    public static class DefaultPerson {\n\n        private String name;\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof DefaultPerson that)) return false;\n\n            return Objects.equals(name, that.name);\n        }\n\n        @Override\n        public int hashCode() {\n            return name != null ? name.hashCode() : 0;\n        }\n    }", "definition": "    @FakeForSchema(\"defaultSchema\")\n    public static class DefaultPerson", "class_docstring": "", "name": "DefaultPerson", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "@FakeForSchema(\"defaultSchema\")\n    public static", "marker_annotations": [], "non_marker_annotations": ["@FakeForSchema(\"defaultSchema\")", "public", "static"], "comments": [], "fields": [{"attribute_expression": "private String name;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof DefaultPerson that)) return false;\n\n            return Objects.equals(name, that.name);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                        {\n            if (this == o) return true;\n            if (!(o instanceof DefaultPerson that)) return false;\n\n            return Objects.equals(name, that.name);\n        }", "signature": "@Override\n        public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return name != null ? name.hashCode() : 0;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return name != null ? name.hashCode() : 0;\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    public static class SimplePerson {\n\n        private String name;\n    }", "definition": "    public static class SimplePerson", "class_docstring": "", "name": "SimplePerson", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private String name;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}], "class_docstring": "", "original_string": "public class FakeAnnotationTest {\n\n    @Test\n    void shouldGenerateEntityWithDefaultSchema() {\n        var person = Faker.populate(Person.class);\n\n        assertThat(person).isNotNull();\n        assertThat(person.getName()).isEqualTo(\"Dr Alexis No\u00ebl\");\n    }\n\n    @Test\n    void shouldGenerateEntityFromJavaRecordWithDefaultSchema() {\n        var person = Faker.populate(PersonJavaRecord.class);\n\n        assertThat(person).isNotNull();\n        assertThat(person.name()).isEqualTo(\"Dr Alexis No\u00ebl\");\n    }\n\n    @Test\n    void shouldGenerateEntityWithCustomSchema() {\n        var person = Faker.populate(Person.class, customSchema());\n\n        assertThat(person).isNotNull();\n        assertThat(person.getName()).isEqualTo(\"Aztar Ivy\");\n    }\n\n    @Test\n    void shouldGenerateEntityFromJavaRecordWithCustomSchema() {\n        var person = Faker.populate(PersonJavaRecord.class, customSchema());\n\n        assertThat(person).isNotNull();\n        assertThat(person.name()).isEqualTo(\"Aztar Ivy\");\n    }\n\n    @Test\n    void shouldGenerateEntityWithCustomSchemaWhenClassTemplateWithoutAnnotation() {\n        var person = Faker.populate(SimplePerson.class, customSchema());\n\n        assertThat(person).isNotNull();\n        assertThat(person.name).isEqualTo(\"Aztar Ivy\");\n    }\n\n    @Test\n    void shouldGenerateEntityFromJavaRecordWithCustomSchemaWhenClassTemplateWithoutAnnotation() {\n        var person = Faker.populate(SimplePersonJavaRecord.class, customSchema());\n\n        assertThat(person).isNotNull();\n        assertThat(person.name).isEqualTo(\"Aztar Ivy\");\n    }\n\n    @Test\n    void shouldGenerateEntityFromJavaRecordWithComplexSchemaWhenClassTemplateWithoutAnnotation() {\n        var person = Faker.populate(ComplexPersonJavaRecord.class, complexSchema());\n\n        assertThat(person).isNotNull();\n        assertThat(person.name()).isEqualTo(\"Aztar Ivy\");\n        assertThat(person.address()).isEqualTo(\"Am Buttermarkt 46b, Dannerheim, BE 32422\");\n        assertThat(person.color()).isEqualTo(\"rot\");\n    }\n\n    @Test\n    void shouldGenerateEntityWithDefaultSchemaAndInDefaultSchemaInCurrentClass() {\n        var person = Faker.populate(DefaultPerson.class);\n\n        assertThat(person).isNotNull();\n        assertThat(person.name).isNotNull();\n    }\n\n    @Test\n    void shouldGenerateEntityWithDefaultSchemaAndInDefaultSchemaInCurrentClass2() {\n        final int expectedSize = 5;\n        final Schema schema = customSchema();\n        List<DefaultPerson> list = new FakeCollection.Builder<DefaultPerson>()\n            .suppliers(() -> Faker.populate(DefaultPerson.class, schema))\n            .len(expectedSize)\n            .generate();\n\n        assertThat(new HashSet<>(list)).hasSize(expectedSize);\n    }\n\n    @Test\n    void shouldGenerateEntityFromJavaRecordWithDefaultSchemaAndInDefaultSchemaInCurrentClass() {\n        var person = Faker.populate(DefaultPersonJavaRecord.class);\n\n        assertThat(person).isNotNull();\n        assertThat(person.name).isNotNull();\n    }\n\n    public static Schema<Object, ?> defaultSchema() {\n        var faker = new Faker(Locale.forLanguageTag(\"fr-en\"), new RandomService(new Random(1)));\n        return Schema.of(field(\"name\", () -> faker.name().fullName()));\n    }\n\n    public static Schema<Object, ?> customSchema() {\n        var faker = new Faker(Locale.forLanguageTag(\"de-en\"), new RandomService(new Random(1)));\n        return Schema.of(field(\"name\", () -> faker.superhero().name()));\n    }\n\n    public static Schema<Object, ?> complexSchema() {\n        var faker = new Faker(Locale.forLanguageTag(\"de-en\"), new RandomService(new Random(1)));\n        return Schema.of(\n            field(\"name\", () -> faker.superhero().name()),\n            field(\"address\", () -> faker.address().fullAddress()),\n            field(\"color\", () -> faker.color().name())\n        );\n    }\n\n    @FakeForSchema(\"defaultSchema\")\n    public static class DefaultPerson {\n\n        private String name;\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (!(o instanceof DefaultPerson that)) return false;\n\n            return Objects.equals(name, that.name);\n        }\n\n        @Override\n        public int hashCode() {\n            return name != null ? name.hashCode() : 0;\n        }\n    }\n\n    public static class SimplePerson {\n\n        private String name;\n    }\n\n    @FakeForSchema(\"defaultSchema\")\n    public record DefaultPersonJavaRecord(String name) { }\n\n    public record SimplePersonJavaRecord(String name) { }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/idnumbers/MexicanIdNumberTest.java.MexicanIdNumberTest", "name": "MexicanIdNumberTest", "file_path": "src/test/java/net/datafaker/idnumbers/MexicanIdNumberTest.java", "superclasses": "", "methods": ["[void]valid()", "[void]validEsMXSsn()", "[void]invalid()", "[void]invalidEsMXSsn()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class MexicanIdNumberTest {\n\n    private static final Pattern REGEX = Pattern.compile(\n        \"[A-Z]{4}\\\\d{6}[HM][A-Z]{5}[A-Z,0-9]\\\\d\");\n    private static final Faker faker = new Faker(new Locale(\"es\", \"MX\"));\n    private final IdNumber idNumber = faker.idNumber();\n\n    @RepeatedTest(100)\n    void valid() {\n        assertThat(idNumber.valid()).matches(REGEX);\n    }\n\n    @RepeatedTest(100)\n    void validEsMXSsn() {\n        assertThat(idNumber.validEsMXSsn()).matches(REGEX);\n    }\n\n    @RepeatedTest(100)\n    void invalid() {\n        assertThat(idNumber.invalid()).matches(REGEX);\n    }\n\n    @RepeatedTest(100)\n    void invalidEsMXSsn() {\n        assertThat(idNumber.invalidEsMXSsn()).matches(REGEX);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Pattern REGEX = Pattern.compile(\n        \"[A-Z]{4}\\\\d{6}[HM][A-Z]{5}[A-Z,0-9]\\\\d\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "REGEX = Pattern.compile(\n        \"[A-Z]{4}\\\\d{6}[HM][A-Z]{5}[A-Z,0-9]\\\\d\")", "syntax_pass": true}, {"attribute_expression": "private static final Faker faker = new Faker(new Locale(\"es\", \"MX\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "faker = new Faker(new Locale(\"es\", \"MX\"))", "syntax_pass": true}, {"attribute_expression": "private final IdNumber idNumber = faker.idNumber();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "IdNumber", "name": "idNumber = faker.idNumber()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/idnumbers/SouthAfricanIdNumberTest.java.SouthAfricanIdNumberTest", "name": "SouthAfricanIdNumberTest", "file_path": "src/test/java/net/datafaker/idnumbers/SouthAfricanIdNumberTest.java", "superclasses": "", "methods": ["[void]testExistSsn()", "[void]testFakerSsn()", "[void]testSsnFormat()", "[void]sequentialNumber_forMales()", "[void]sequentialNumber_forFemales()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "\nThis file was used to test the issue #566 by SE_CHWJ\n", "original_string": "class SouthAfricanIdNumberTest {\n\n    @Test\n    void testExistSsn() {\n        assertThat(isValidEnZASsn(\"9202204720085\")).isFalse();\n        assertThat(isValidEnZASsn(\"foo2204720082\")).isFalse();\n        assertThat(isValidEnZASsn(\"9232454720082\")).isFalse();\n\n        assertThat(isValidEnZASsn(\"9202204720083\")).isTrue();\n        assertThat(isValidEnZASsn(\"8801235111088\")).isTrue();\n    }\n\n    @RepeatedTest(100)\n    void testFakerSsn() {\n        final BaseFaker f = new BaseFaker(new Locale(\"en\", \"ZA\"));\n        final IdNumber idNumber = f.idNumber();\n        assertThat(isValidEnZASsn(idNumber.valid())).isTrue();\n        assertThat(isValidEnZASsn(idNumber.invalid())).isFalse();\n    }\n\n    @RepeatedTest(100)\n    void testSsnFormat() {\n        final BaseFaker f = new BaseFaker(new Locale(\"en\", \"ZA\"));\n        assertThat(f.idNumber().valid()).matches(\"\\\\d{10}[01]8\\\\d\");\n        assertThat(f.idNumber().invalid()).matches(\"\\\\d{10}[01]8\\\\d\");\n    }\n\n    @RepeatedTest(100)\n    void sequentialNumber_forMales() {\n        BaseFaker f = new BaseFaker(new Locale(\"en\", \"ZA\"));\n        String sequentialNumber = sequentialNumber(f, MALE);\n\n        assertThat(sequentialNumber).matches(\"\\\\d{4}\");\n        assertThat(parseInt(sequentialNumber)).isGreaterThanOrEqualTo(5000);\n    }\n\n    @RepeatedTest(100)\n    void sequentialNumber_forFemales() {\n        BaseFaker f = new BaseFaker(new Locale(\"en\", \"ZA\"));\n        String sequentialNumber = sequentialNumber(f, FEMALE);\n\n        assertThat(sequentialNumber).matches(\"\\\\d{4}\");\n        assertThat(parseInt(sequentialNumber)).isLessThan(5000);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/idnumbers/SouthKoreanIdNumberTest.java.SouthKoreanIdNumberTest", "name": "SouthKoreanIdNumberTest", "file_path": "src/test/java/net/datafaker/idnumbers/SouthKoreanIdNumberTest.java", "superclasses": "", "methods": ["[void]testValidKoKrRrn()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class SouthKoreanIdNumberTest {\n\n    private static final DateTimeFormatter YYMMDD = DateTimeFormatter.ofPattern(\"yyMMdd\");\n    private static final Pattern D_6_D_7 = Pattern.compile(\"\\\\d{6}-\\\\d{7}\");\n\n    @RepeatedTest(100)\n    void testValidKoKrRrn() {\n        Faker f = new Faker(new Locale(\"en\", \"KR\"));\n        String rrn = f.idNumber().valid();\n\n        // Check if contains other character than digit\n        assertThat(rrn).matches(D_6_D_7);\n        // Check date\n        LocalDate date = LocalDate.parse(rrn.substring(0, 6), YYMMDD);\n        int currentYear = LocalDate.now().getYear();\n        assertThat(date.getYear()).isBetween(currentYear - 80, currentYear + 80);\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final DateTimeFormatter YYMMDD = DateTimeFormatter.ofPattern(\"yyMMdd\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "DateTimeFormatter", "name": "YYMMDD = DateTimeFormatter.ofPattern(\"yyMMdd\")", "syntax_pass": true}, {"attribute_expression": "private static final Pattern D_6_D_7 = Pattern.compile(\"\\\\d{6}-\\\\d{7}\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "D_6_D_7 = Pattern.compile(\"\\\\d{6}-\\\\d{7}\")", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/idnumbers/BulgarianIdNumberTest.java.BulgarianIdNumberTest", "name": "BulgarianIdNumberTest", "file_path": "src/test/java/net/datafaker/idnumbers/BulgarianIdNumberTest.java", "superclasses": "", "methods": ["[void]checksum()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class BulgarianIdNumberTest {\n    private final BulgarianIdNumber generator = new BulgarianIdNumber();\n\n    @Test\n    void checksum() {\n        assertThat(generator.checksum(\"803205603\")).isEqualTo(1);\n        assertThat(generator.checksum(\"800101000\")).isEqualTo(8);\n        assertThat(generator.checksum(\"750102001\")).isEqualTo(8);\n        assertThat(generator.checksum(\"820630876\")).isEqualTo(0);\n        assertThat(generator.checksum(\"560628204\")).isEqualTo(7);\n        assertThat(generator.checksum(\"752316926\")).isEqualTo(3);\n        assertThat(generator.checksum(\"755201000\")).isEqualTo(5);\n        assertThat(generator.checksum(\"754201103\")).isEqualTo(0);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final BulgarianIdNumber generator = new BulgarianIdNumber();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BulgarianIdNumber", "name": "generator = new BulgarianIdNumber()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/idnumbers/MoldovanIdNumberTest.java.MoldovanIdNumberTest", "name": "MoldovanIdNumberTest", "file_path": "src/test/java/net/datafaker/idnumbers/MoldovanIdNumberTest.java", "superclasses": "", "methods": ["[void]valid()", "[void]checksum()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class MoldovanIdNumberTest {\n    private final MoldovanIdNumber generator = new MoldovanIdNumber();\n    private final Faker faker = new Faker();\n\n    @RepeatedTest(100)\n    void valid() {\n        String pin = generator.generateValid(faker);\n        assertThat(pin.length())\n            .as(() -> \"Presumably valid PIN: '%s'\".formatted(pin))\n            .isEqualTo(13);\n        assertThat(pin)\n            .as(() -> \"Presumably valid PIN: '%s'\".formatted(pin))\n            .matches(\"\\\\d{13}\");\n    }\n\n    @Test\n    void checksum() {\n        assertThat(generator.checksum(\"293270095431\")).isEqualTo('9');\n        assertThat(generator.checksum(\"201403700084\")).isEqualTo('3');\n        assertThat(generator.checksum(\"099220624701\")).isEqualTo('8');\n        assertThat(generator.checksum(\"200504212980\")).isEqualTo('9');\n        assertThat(generator.checksum(\"200504401269\")).isEqualTo('3');\n        assertThat(generator.checksum(\"200201100696\")).isEqualTo('1');\n        assertThat(generator.checksum(\"200403612722\")).isEqualTo('9');\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final MoldovanIdNumber generator = new MoldovanIdNumber();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "MoldovanIdNumber", "name": "generator = new MoldovanIdNumber()", "syntax_pass": true}, {"attribute_expression": "private final Faker faker = new Faker();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Faker", "name": "faker = new Faker()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/idnumbers/PortugueseIdNumber_generateInvalidTest.java.PortugueseIdNumber_generateInvalidTest", "name": "PortugueseIdNumber_generateInvalidTest", "file_path": "src/test/java/net/datafaker/idnumbers/PortugueseIdNumber_generateInvalidTest.java", "superclasses": "", "methods": ["[void]testGenerateInvalid()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class PortugueseIdNumber_generateInvalidTest {\n\n    @Test\n    public void testGenerateInvalid() {\n        // Given\n        BaseProviders faker = Mockito.mock(BaseProviders.class);\n        Number numberMock = Mockito.mock(Number.class);\n        when(faker.number()).thenReturn(numberMock);\n        when(numberMock.digits(8)).thenReturn(\"12345678\");\n        PortugueseIdNumber portugueseIdNumber = new PortugueseIdNumber();\n\n        // When\n        String result = portugueseIdNumber.generateInvalid(faker);\n\n        // Then\n        assertEquals(\"1234567814\", result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/idnumbers/EstonianIdNumberTest.java.EstonianIdNumberTest", "name": "EstonianIdNumberTest", "file_path": "src/test/java/net/datafaker/idnumbers/EstonianIdNumberTest.java", "superclasses": "", "methods": ["[void]checksum()", "[void]firstDigit_18xx(int)", "[void]firstDigit_19xx(int)", "[void]firstDigit_20xx(int)", "[void]firstDigit_21xx(int)"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class EstonianIdNumberTest {\n    /**\n     * Samples from <a href=\"https://et.wikipedia.org/wiki/Isikukood\">...</a>\n     */\n    @Test\n    void checksum() {\n        assertThat(EstonianIdNumber.checksum(\"3760503029\")).isEqualTo(9);\n        assertThat(EstonianIdNumber.checksum(\"3450123421\")).isEqualTo(5);\n        assertThat(EstonianIdNumber.checksum(\"4940313652\")).isEqualTo(6);\n        assertThat(EstonianIdNumber.checksum(\"5110712176\")).isEqualTo(0);\n        assertThat(EstonianIdNumber.checksum(\"6110712176\")).isEqualTo(0);\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {1800, 1801, 1802, 1888, 1898, 1899})\n    void firstDigit_18xx(int year) {\n        assertThat(firstDigit(year, MALE)).isEqualTo(1);\n        assertThat(firstDigit(year, FEMALE)).isEqualTo(2);\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {1900, 1901, 1902, 1988, 1998, 1999})\n    void firstDigit_19xx(int year) {\n        assertThat(firstDigit(year, MALE)).isEqualTo(3);\n        assertThat(firstDigit(year, FEMALE)).isEqualTo(4);\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {2000, 2001, 2002, 2088, 2098, 2099})\n    void firstDigit_20xx(int year) {\n        assertThat(firstDigit(year, MALE)).isEqualTo(5);\n        assertThat(firstDigit(year, FEMALE)).isEqualTo(6);\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {2100, 2101, 2102, 2188, 2198, 2199})\n    void firstDigit_21xx(int year) {\n        assertThat(firstDigit(year, MALE)).isEqualTo(7);\n        assertThat(firstDigit(year, FEMALE)).isEqualTo(8);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/idnumbers/RomanianIdNumberTest.java.RomanianIdNumberTest", "name": "RomanianIdNumberTest", "file_path": "src/test/java/net/datafaker/idnumbers/RomanianIdNumberTest.java", "superclasses": "", "methods": ["[void]sample()", "[void]firstDigit_18xx()", "[void]firstDigit_19xx()", "[void]firstDigit_20xx()", "[void]dateOfBirth()", "[void]countyCode()", "[void]sequenceNumber()", "[void]checksum()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class RomanianIdNumberTest {\n    private static final Pattern RE_TWO_DIGITS = Pattern.compile(\"\\\\d{2}\");\n    private static final Pattern RE_THREE_DIGITS = Pattern.compile(\"\\\\d{3}\");\n    private static final Pattern RE_THIRTEEN_DIGITS = Pattern.compile(\"\\\\d{13}\");\n\n    private final RomanianIdNumber impl = new RomanianIdNumber();\n    private final Faker faker = new Faker();\n\n    @RepeatedTest(100)\n    void sample() {\n        assertThat(impl.generateValid(faker)).matches(RE_THIRTEEN_DIGITS);\n    }\n\n    @Test\n    void firstDigit_18xx() {\n        for (int year = 1800; year <= 1899; year++) {\n            assertThat(impl.firstCharacter(LocalDate.of(year, 1, 1), MALE)).isEqualTo(3);\n            assertThat(impl.firstCharacter(LocalDate.of(year, 1, 1), FEMALE)).isEqualTo(4);\n        }\n    }\n\n    @Test\n    void firstDigit_19xx() {\n        for (int year = 1900; year <= 1999; year++) {\n            assertThat(impl.firstCharacter(LocalDate.of(year, 1, 1), MALE)).isEqualTo(1);\n            assertThat(impl.firstCharacter(LocalDate.of(year, 1, 1), FEMALE)).isEqualTo(2);\n        }\n    }\n\n    @Test\n    void firstDigit_20xx() {\n        for (int year = 2000; year <= 2099; year++) {\n            assertThat(impl.firstCharacter(LocalDate.of(year, 1, 1), MALE)).isEqualTo(5);\n            assertThat(impl.firstCharacter(LocalDate.of(year, 1, 1), FEMALE)).isEqualTo(6);\n        }\n    }\n\n    @Test\n    void dateOfBirth() {\n        assertThat(impl.dateOfBirth(LocalDate.of(1990, 1, 1))).isEqualTo(\"900101\");\n        assertThat(impl.dateOfBirth(LocalDate.of(1234, 12, 31))).isEqualTo(\"341231\");\n    }\n\n    @Test\n    void countyCode() {\n        Set<String> allCodes = new HashSet<>(48);\n        for (int i = 0; i < 10_000; i++) {\n            String countyCode = impl.countyCode(faker);\n            assertThat(countyCode).matches(RE_TWO_DIGITS);\n            allCodes.add(countyCode);\n        }\n\n        assertThat(allCodes).hasSize(48);\n        assertThat(allCodes).contains(\"01\");\n        assertThat(allCodes).contains(\"09\");\n        assertThat(allCodes).contains(\"10\");\n        assertThat(allCodes).contains(\"11\");\n        assertThat(allCodes).contains(\"19\");\n        assertThat(allCodes).contains(\"20\");\n        assertThat(allCodes).contains(\"21\");\n        assertThat(allCodes).contains(\"45\");\n        assertThat(allCodes).contains(\"46\");\n        assertThat(allCodes).contains(\"51\");\n        assertThat(allCodes).contains(\"52\");\n        assertThat(allCodes).doesNotContain(\"53\");\n        assertThat(allCodes).doesNotContain(\"47\");\n        assertThat(allCodes).doesNotContain(\"49\");\n        assertThat(allCodes).doesNotContain(\"50\");\n    }\n\n    @RepeatedTest(10)\n    void sequenceNumber() {\n        assertThat(impl.sequenceNumber(faker)).matches(RE_THREE_DIGITS);\n    }\n\n    @Test\n    void checksum() {\n        assertThat(impl.checksum(\"198081945678\")).isEqualTo(1);\n        assertThat(impl.checksum(\"293052637289\")).isEqualTo(4);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Pattern RE_TWO_DIGITS = Pattern.compile(\"\\\\d{2}\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "RE_TWO_DIGITS = Pattern.compile(\"\\\\d{2}\")", "syntax_pass": true}, {"attribute_expression": "private static final Pattern RE_THREE_DIGITS = Pattern.compile(\"\\\\d{3}\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "RE_THREE_DIGITS = Pattern.compile(\"\\\\d{3}\")", "syntax_pass": true}, {"attribute_expression": "private static final Pattern RE_THIRTEEN_DIGITS = Pattern.compile(\"\\\\d{13}\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "RE_THIRTEEN_DIGITS = Pattern.compile(\"\\\\d{13}\")", "syntax_pass": true}, {"attribute_expression": "private final RomanianIdNumber impl = new RomanianIdNumber();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "RomanianIdNumber", "name": "impl = new RomanianIdNumber()", "syntax_pass": true}, {"attribute_expression": "private final Faker faker = new Faker();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Faker", "name": "faker = new Faker()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/idnumbers/MacedonianIdNumberTest.java.MacedonianIdNumberTest", "name": "MacedonianIdNumberTest", "file_path": "src/test/java/net/datafaker/idnumbers/MacedonianIdNumberTest.java", "superclasses": "", "methods": ["[void]checksum()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class MacedonianIdNumberTest {\n    private final MacedonianIdNumber generator = new MacedonianIdNumber();\n\n    @Test\n    void checksum() {\n        assertThat(generator.checksum(\"010100650000\")).isEqualTo(6);\n        assertThat(generator.checksum(\"923456789012\")).isEqualTo(4);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final MacedonianIdNumber generator = new MacedonianIdNumber();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "MacedonianIdNumber", "name": "generator = new MacedonianIdNumber()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/idnumbers/PolishIdNumberTest.java.PolishIdNumberTest", "name": "PolishIdNumberTest", "file_path": "src/test/java/net/datafaker/idnumbers/PolishIdNumberTest.java", "superclasses": "", "methods": ["[void]testGenderedPesel(Gender)", "[void]testCenturiesPesel(int)", "[void]testInvalidCenturiesPesel(int)", "[void]testNullGender()"], "method_uris": ["src/test/java/net/datafaker/idnumbers/PolishIdNumberTest.java.PolishIdNumberTest.[void]assertBasics(String)", "src/test/java/net/datafaker/idnumbers/PolishIdNumberTest.java.PolishIdNumberTest.[void]assertBirthDate(LocalDate,String)", "src/test/java/net/datafaker/idnumbers/PolishIdNumberTest.java.PolishIdNumberTest.[void]assertGender(Gender,String)", "src/test/java/net/datafaker/idnumbers/PolishIdNumberTest.java.PolishIdNumberTest.[void]assertControlDigit(String)", "src/test/java/net/datafaker/idnumbers/PolishIdNumberTest.java.PolishIdNumberTest.[int]toNumber(char,char)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class PolishIdNumberTest {\n\n    public static final int PESEL_EXPECTED_LENGTH = 11;\n\n    private static final Faker faker = new Faker(new Locale(\"pl\", \"PL\"));\n    private static final PolishIdNumber peselNumber = new PolishIdNumber();\n\n    @ParameterizedTest\n    @EnumSource(value = Gender.class, names = {\"MALE\", \"FEMALE\"})\n    void testGenderedPesel(Gender givenGender) {\n        /*\n         * Given\n         */\n        final LocalDate givenBirthDate = new BaseFaker().timeAndDate().birthday(0, 100);\n        /*\n         * When\n         */\n        final String gotPesel = peselNumber.get(faker, givenBirthDate, givenGender);\n\n        /*\n         * Then\n         */\n        assertBasics(gotPesel);\n        assertBirthDate(givenBirthDate, gotPesel);\n        assertGender(givenGender, gotPesel);\n        assertControlDigit(gotPesel);\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {1850, 1950, 2050, 2150, 2250})\n    void testCenturiesPesel(int givenBirthYear) {\n        /*\n         * Given\n         */\n        final LocalDate givenBirthDate = LocalDate.of(givenBirthYear, 6, 28);\n\n        /*\n         * When\n         */\n        final String gotPesel = peselNumber.get(faker, givenBirthDate, Gender.ANY);\n\n        /*\n         * Then\n         */\n        assertBasics(gotPesel);\n        assertBirthDate(givenBirthDate, gotPesel);\n        assertControlDigit(gotPesel);\n    }\n\n    @ParameterizedTest\n    @ValueSource(ints = {1799, 2300})\n    void testInvalidCenturiesPesel(int givenBirthYear) {\n        /*\n         * Given\n         */\n        final LocalDate givenBirthDate = LocalDate.of(givenBirthYear, 6, 28);\n\n        /*\n         * When\n         */\n        assertThatThrownBy(() -> peselNumber.get(faker, givenBirthDate, Gender.ANY))\n            .isInstanceOf(IllegalArgumentException.class);\n    }\n\n    @Test\n    void testNullGender() {\n        /*\n         * Given\n         */\n        final LocalDate givenBirthDate = LocalDate.now();\n\n        /*\n         * When\n         */\n        final String gotPesel = peselNumber.get(faker, givenBirthDate, null);\n\n        /*\n         * Then\n         */\n        assertBasics(gotPesel);\n        assertBirthDate(givenBirthDate, gotPesel);\n        assertControlDigit(gotPesel);\n    }\n\n    private void assertBasics(String gotPesel) {\n        assertThat(gotPesel).hasSize(PESEL_EXPECTED_LENGTH);\n        assertThat(gotPesel.chars().allMatch(Character::isDigit)).isTrue();\n    }\n\n    private void assertBirthDate(LocalDate givenBirthDate, String gotPesel) {\n        final int gotYear = toNumber(gotPesel.charAt(0), gotPesel.charAt(1));\n        assertThat(givenBirthDate.getYear() % 100).isEqualTo(gotYear);\n\n        final int gotMonth = toNumber(gotPesel.charAt(2), gotPesel.charAt(3));\n\n        final int givenYear = givenBirthDate.getYear();\n\n        if (givenYear < 1800) {\n            fail(\"Year is before 1800. Test case is broken.\");\n        } else if (givenYear < 1900) {\n            assertThat(givenBirthDate.getMonthValue() + 80).isEqualTo(gotMonth);\n        } else if (givenYear < 2000) {\n            assertThat(givenBirthDate.getMonthValue()).isEqualTo(gotMonth);\n        } else if (givenYear < 2100) {\n            assertThat(givenBirthDate.getMonthValue() + 20).isEqualTo(gotMonth);\n        } else if (givenYear < 2200) {\n            assertThat(givenBirthDate.getMonthValue() + 40).isEqualTo(gotMonth);\n        } else if (givenYear < 2300) {\n            assertThat(givenBirthDate.getMonthValue() + 60).isEqualTo(gotMonth);\n        } else {\n            throw new IllegalArgumentException(\"Year %s is after 2300. Test case is broken.\".formatted(givenYear));\n        }\n\n        final int gotDay = toNumber(gotPesel.charAt(4), gotPesel.charAt(5));\n        assertThat(givenBirthDate.getDayOfMonth()).isEqualTo(gotDay);\n    }\n\n    private void assertGender(Gender givenGender, String gotPesel) {\n        final int gotGenderDigit = gotPesel.charAt(9) - '0';\n        switch (givenGender) {\n            case FEMALE:\n                assertThat(gotGenderDigit % 2).isZero();\n                break;\n            case MALE:\n                assertThat(gotGenderDigit % 2).isOne();\n                break;\n            case ANY:\n            default:\n                break;\n        }\n    }\n\n    private void assertControlDigit(String gotPesel) {\n        final int gotSum = (gotPesel.charAt(0) + gotPesel.charAt(4) + gotPesel.charAt(8) + gotPesel.charAt(10)\n            + 3 * (gotPesel.charAt(1) + gotPesel.charAt(5) + gotPesel.charAt(9))\n            + 7 * (gotPesel.charAt(2) + gotPesel.charAt(6)) + 9 * (gotPesel.charAt(3) + gotPesel.charAt(7))) % 10;\n        assertThat(gotSum).isZero();\n    }\n\n    private int toNumber(char digit2, char digit1) {\n        return (digit2 - '0') * 10 + digit1 - '0';\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "public static final int PESEL_EXPECTED_LENGTH = 11;", "docstring": "", "modifiers": "public static final", "marker_annotations": [], "non_marker_annotations": ["public", "static", "final"], "comments": [], "type": "int", "name": "PESEL_EXPECTED_LENGTH = 11", "syntax_pass": true}, {"attribute_expression": "private static final Faker faker = new Faker(new Locale(\"pl\", \"PL\"));", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Faker", "name": "faker = new Faker(new Locale(\"pl\", \"PL\"))", "syntax_pass": true}, {"attribute_expression": "private static final PolishIdNumber peselNumber = new PolishIdNumber();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "PolishIdNumber", "name": "peselNumber = new PolishIdNumber()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/idnumbers/UtilsTest.java.UtilsTest", "name": "UtilsTest", "file_path": "src/test/java/net/datafaker/idnumbers/UtilsTest.java", "superclasses": "", "methods": ["[void]digit_parsesGivenCharToNumber()", "[void]digitAt_parsesGivenCharToNumber()", "[void]multiply_digits()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class UtilsTest {\n    @Test\n    void digit_parsesGivenCharToNumber() {\n        assertThat(digit('0')).isEqualTo(0);\n        assertThat(digit('1')).isEqualTo(1);\n        assertThat(digit('2')).isEqualTo(2);\n        assertThat(digit('8')).isEqualTo(8);\n        assertThat(digit('9')).isEqualTo(9);\n    }\n\n    @Test\n    void digitAt_parsesGivenCharToNumber() {\n        assertThat(digitAt(\"12345\", 0)).isEqualTo(1);\n        assertThat(digitAt(\"12345\", 1)).isEqualTo(2);\n        assertThat(digitAt(\"12345\", 2)).isEqualTo(3);\n        assertThat(digitAt(\"12345\", 3)).isEqualTo(4);\n        assertThat(digitAt(\"12345\", 4)).isEqualTo(5);\n    }\n\n    @Test\n    void multiply_digits() {\n        assertThat(multiply(\"1\", new int[]{1})).isEqualTo(1);\n        assertThat(multiply(\"1\", new int[]{2})).isEqualTo(2);\n        assertThat(multiply(\"23\", new int[]{4, 5})).isEqualTo(2 * 4 + 3 * 5);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/idnumbers/ChineseIdNumberTest.java.ChineseIdNumberTest", "name": "ChineseIdNumberTest", "file_path": "src/test/java/net/datafaker/idnumbers/ChineseIdNumberTest.java", "superclasses": "AbstractFakerTest", "methods": ["[void]testValidChineseIdNumber()", "[void]testChecksumOfChineseIdNumber(String)", "[void]testValidZhCnIdNumber()"], "method_uris": ["src/test/java/net/datafaker/idnumbers/ChineseIdNumberTest.java.ChineseIdNumberTest.[void]assertThatSsnNumberValid(int,String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class ChineseIdNumberTest extends AbstractFakerTest {\n    private final BaseFaker faker = new BaseFaker(new Locale(\"zh\", \"CN\"));\n\n    @RepeatedTest(10)\n    void testValidChineseIdNumber() {\n        String idNumber = faker.idNumber().valid();\n        final int length = idNumber.length();\n        assertThatSsnNumberValid(length, idNumber);\n    }\n\n    @ParameterizedTest\n    @CsvSource({\n        \"420302198411073380\",\n        \"310104196302135471\",\n        \"330109197812225952\",\n        \"130303200202132943\",\n        \"370405198908011564\",\n        \"350403198610147315\",\n        \"640106198409178736\",\n        \"469002199907068677\",\n        \"440307199907065608\",\n        \"150301196606308919\",\n        \"21030319900605273X\"\n    })\n    void testChecksumOfChineseIdNumber(String idNumber) {\n        String first17Digit = idNumber.substring(0, idNumber.length() - 1);\n        assertThat(ChineseIdNumber.idNumber(first17Digit.toCharArray())).isEqualTo(idNumber);\n    }\n\n    @RepeatedTest(100)\n    void testValidZhCnIdNumber() {\n        ChineseIdNumber id = new ChineseIdNumber();\n        String idNumber = id.generateValid(faker);\n        assertThatSsnNumberValid(idNumber.length(), idNumber);\n    }\n\n    private static void assertThatSsnNumberValid(int idNumber, String idNumber1) {\n        boolean isSatisfied = idNumber == 18;\n        for (int j = 0; j < idNumber; j++) {\n            char ch = idNumber1.charAt(j);\n            if (j != idNumber - 1) {\n                if (ch > '9' || ch < '0') {\n                    isSatisfied = false;\n                    break;\n                }\n            } else {\n                if ((ch > '9' || ch < '0') && ch != 'X') {\n                    isSatisfied = false;\n                    break;\n                }\n            }\n        }\n        assertThat(isSatisfied).isTrue();\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final BaseFaker faker = new BaseFaker(new Locale(\"zh\", \"CN\"));", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BaseFaker", "name": "faker = new BaseFaker(new Locale(\"zh\", \"CN\"))", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/idnumbers/PortugueseIdNumberTest.java.PortugueseIdNumberTest", "name": "PortugueseIdNumberTest", "file_path": "src/test/java/net/datafaker/idnumbers/PortugueseIdNumberTest.java", "superclasses": "AbstractFakerTest", "methods": ["[void]testInvalid()", "[void]testValid()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class PortugueseIdNumberTest extends AbstractFakerTest {\n    private final Faker ptFaker = new Faker(new Locale(\"pt\", \"PT\"));\n\n    @RepeatedTest(100)\n    void testInvalid() {\n        assertThat(ptFaker.idNumber().invalid()).matches(\"[0-9]{9,10}\");\n    }\n\n    @RepeatedTest(100)\n    void testValid() {\n        assertThat(ptFaker.idNumber().valid()).matches(\"[0-9]{9,10}\");\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Faker ptFaker = new Faker(new Locale(\"pt\", \"PT\"));", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Faker", "name": "ptFaker = new Faker(new Locale(\"pt\", \"PT\"))", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/idnumbers/AmericanIdNumber_generateValidTest.java.AmericanIdNumber_generateValidTest", "name": "AmericanIdNumber_generateValidTest", "file_path": "src/test/java/net/datafaker/idnumbers/AmericanIdNumber_generateValidTest.java", "superclasses": "", "methods": ["[void]testGenerateValid()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class AmericanIdNumber_generateValidTest {\n\n    @Test\n    public void testGenerateValid() {\n        // Given\n        BaseProviders f = Mockito.mock(BaseProviders.class);\n        AmericanIdNumber americanIdNumber = new AmericanIdNumber();\n\n        // When\n        when(f.regexify(\"[0-8]\\\\d{2}-\\\\d{2}-\\\\d{4}\")).thenReturn(\"123-45-6789\");\n\n        // Then\n        String result = americanIdNumber.generateValid(f);\n        assertTrue(Pattern.compile(\"[0-8]\\\\d{2}-\\\\d{2}-\\\\d{4}\").matcher(result).matches());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/idnumbers/SwedishIdNumberTest.java.SwedishIdNumberTest", "name": "SwedishIdNumberTest", "file_path": "src/test/java/net/datafaker/idnumbers/SwedishIdNumberTest.java", "superclasses": "", "methods": ["[void]validSwedishSsn()", "[void]invalidSwedishSsn()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class SwedishIdNumberTest {\n\n    @Test\n    void validSwedishSsn() {\n        assertThat(SwedenIdNumber.isValidSwedishSsn(\"670919-9530\")).isTrue();\n        assertThat(SwedenIdNumber.isValidSwedishSsn(\"811228-9874\")).isTrue();\n    }\n\n    @Test\n    void invalidSwedishSsn() {\n        assertThat(SwedenIdNumber.isValidSwedishSsn(\"8112289873\")).isFalse();\n        assertThat(SwedenIdNumber.isValidSwedishSsn(\"foo228-9873\")).isFalse();\n        assertThat(SwedenIdNumber.isValidSwedishSsn(\"811228-9873\")).isFalse();\n        assertThat(SwedenIdNumber.isValidSwedishSsn(\"811228-9875\")).isFalse();\n        assertThat(SwedenIdNumber.isValidSwedishSsn(\"811200-9874\")).isFalse();\n        assertThat(SwedenIdNumber.isValidSwedishSsn(\"810028-9874\")).isFalse();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/idnumbers/AlbanianIdNumberTest.java.AlbanianIdNumberTest", "name": "AlbanianIdNumberTest", "file_path": "src/test/java/net/datafaker/idnumbers/AlbanianIdNumberTest.java", "superclasses": "", "methods": ["[void]valid()", "[void]invalid()", "[void]yy()", "[void]mm()", "[void]dd()", "[void]checksum()", "[void]checksumOfFirstChar()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class AlbanianIdNumberTest {\n    private final AlbanianIdNumber generator = new AlbanianIdNumber();\n    private final Faker faker = new Faker();\n\n    @RepeatedTest(100)\n    void valid() {\n        String pin = generator.generateValid(faker);\n        assertThat(pin.length()).isEqualTo(10);\n    }\n\n    @RepeatedTest(100)\n    void invalid() {\n        String pin = generator.generateInvalid(faker);\n        assertThat(pin.length()).isEqualTo(10);\n        assertThat(parseInt(pin.substring(2, 4)))\n            .as(() -> \"Presumably invalid PIN: '%s'\".formatted(pin))\n            .isGreaterThan(92);\n    }\n\n    @Test\n    void yy() {\n        assertThat(generator.yy(1806)).isEqualTo(\"06\");\n        assertThat(generator.yy(1812)).isEqualTo(\"12\");\n        assertThat(generator.yy(1829)).isEqualTo(\"29\");\n        assertThat(generator.yy(1880)).isEqualTo(\"80\");\n        assertThat(generator.yy(1888)).isEqualTo(\"88\");\n        assertThat(generator.yy(1900)).isEqualTo(\"A0\");\n        assertThat(generator.yy(1911)).isEqualTo(\"B1\");\n        assertThat(generator.yy(1929)).isEqualTo(\"C9\");\n        assertThat(generator.yy(1981)).isEqualTo(\"I1\");\n        assertThat(generator.yy(2003)).isEqualTo(\"K3\");\n        assertThat(generator.yy(2016)).isEqualTo(\"L6\");\n        assertThat(generator.yy(2099)).isEqualTo(\"T9\");\n    }\n\n    @Test\n    void mm() {\n        assertThat(generator.mm(1, MALE)).isEqualTo(\"01\");\n        assertThat(generator.mm(2, MALE)).isEqualTo(\"02\");\n        assertThat(generator.mm(9, MALE)).isEqualTo(\"09\");\n        assertThat(generator.mm(12, MALE)).isEqualTo(\"12\");\n        assertThat(generator.mm(1, FEMALE)).isEqualTo(\"51\");\n        assertThat(generator.mm(2, FEMALE)).isEqualTo(\"52\");\n        assertThat(generator.mm(8, FEMALE)).isEqualTo(\"58\");\n        assertThat(generator.mm(12, FEMALE)).isEqualTo(\"62\");\n    }\n\n    @Test\n    void dd() {\n        assertThat(generator.dd(1)).isEqualTo(\"01\");\n        assertThat(generator.dd(9)).isEqualTo(\"09\");\n        assertThat(generator.dd(10)).isEqualTo(\"10\");\n        assertThat(generator.dd(31)).isEqualTo(\"31\");\n    }\n\n    @Test\n    void checksum() {\n        assertThat(generator.checksum(\"J11024000\")).isEqualTo('R');\n        assertThat(generator.checksum(\"J45405000\")).isEqualTo('O');\n        assertThat(generator.checksum(\"J00923000\")).isEqualTo('N');\n        assertThat(generator.checksum(\"I05101999\")).isEqualTo('I');\n    }\n\n    @Test\n    void checksumOfFirstChar() {\n        assertThat(generator.checksumOfFirstChar('0')).isEqualTo(0);\n        assertThat(generator.checksumOfFirstChar('1')).isEqualTo(1);\n        assertThat(generator.checksumOfFirstChar('3')).isEqualTo(3);\n        assertThat(generator.checksumOfFirstChar('9')).isEqualTo(9);\n        assertThat(generator.checksumOfFirstChar('A')).isEqualTo(1);\n        assertThat(generator.checksumOfFirstChar('B')).isEqualTo(2);\n        assertThat(generator.checksumOfFirstChar('V')).isEqualTo(22);\n        assertThat(generator.checksumOfFirstChar('W')).isEqualTo(0);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final AlbanianIdNumber generator = new AlbanianIdNumber();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "AlbanianIdNumber", "name": "generator = new AlbanianIdNumber()", "syntax_pass": true}, {"attribute_expression": "private final Faker faker = new Faker();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Faker", "name": "faker = new Faker()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/idnumbers/RomanianIdNumber_generateInvalidTest.java.RomanianIdNumber_generateInvalidTest", "name": "RomanianIdNumber_generateInvalidTest", "file_path": "src/test/java/net/datafaker/idnumbers/RomanianIdNumber_generateInvalidTest.java", "superclasses": "", "methods": ["[void]testGenerateInvalid()"], "method_uris": ["src/test/java/net/datafaker/idnumbers/RomanianIdNumber_generateInvalidTest.java.RomanianIdNumber_generateInvalidTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RomanianIdNumber_generateInvalidTest {\n    private RomanianIdNumber impl;\n    private Faker faker;\n\n    @BeforeEach\n    public void setUp() {\n        impl = new RomanianIdNumber();\n        faker = new Faker();\n    }\n\n    @Test\n    public void testGenerateInvalid() {\n        String invalidIdNumber = impl.generateInvalid(faker);\n        String basePart = invalidIdNumber.substring(0, invalidIdNumber.length() - 1);\n        int expectedChecksum = (impl.checksum(basePart) + 1) % 10;\n        int actualChecksum = Character.getNumericValue(invalidIdNumber.charAt(invalidIdNumber.length() - 1));\n        assertEquals(expectedChecksum, actualChecksum);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private RomanianIdNumber impl;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RomanianIdNumber", "name": "impl", "syntax_pass": true}, {"attribute_expression": "private Faker faker;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Faker", "name": "faker", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/idnumbers/AlbanianIdNumber_generateInvalidTest.java.AlbanianIdNumber_generateInvalidTest", "name": "AlbanianIdNumber_generateInvalidTest", "file_path": "src/test/java/net/datafaker/idnumbers/AlbanianIdNumber_generateInvalidTest.java", "superclasses": "", "methods": ["[void]testGenerateInvalid()"], "method_uris": ["src/test/java/net/datafaker/idnumbers/AlbanianIdNumber_generateInvalidTest.java.AlbanianIdNumber_generateInvalidTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class AlbanianIdNumber_generateInvalidTest {\n    private AlbanianIdNumber generator;\n    private Faker faker;\n\n    @BeforeEach\n    public void setUp() {\n        generator = new AlbanianIdNumber();\n        faker = new Faker();\n    }\n\n    @Test\n    public void testGenerateInvalid() {\n        String validPin = generator.generateValid(faker);\n        String invalidPin = generator.generateInvalid(faker);\n\n        // Assert that the invalid PIN is different from the valid PIN\n        assertNotEquals(validPin, invalidPin);\n\n        // Assert that the invalid PIN has an invalid month part\n        int invalidMonth = Integer.parseInt(invalidPin.substring(2, 4));\n        assertTrue(invalidMonth >= 93 && invalidMonth <= 99);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private AlbanianIdNumber generator;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "AlbanianIdNumber", "name": "generator", "syntax_pass": true}, {"attribute_expression": "private Faker faker;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Faker", "name": "faker", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/idnumbers/SwedenIdNumber_isValidSwedishSsnTest.java.SwedenIdNumber_isValidSwedishSsnTest", "name": "SwedenIdNumber_isValidSwedishSsnTest", "file_path": "src/test/java/net/datafaker/idnumbers/SwedenIdNumber_isValidSwedishSsnTest.java", "superclasses": "", "methods": ["[void]testIsValidSwedishSsn_ValidSsn()", "[void]testIsValidSwedishSsn_InvalidLength()", "[void]testIsValidSwedishSsn_InvalidDate()", "[void]testIsValidSwedishSsn_InvalidChecksum()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class SwedenIdNumber_isValidSwedishSsnTest {\n\n    @Test\n    void testIsValidSwedishSsn_ValidSsn() {\n        // Given\n        String validSsn = \"811228-9874\"; // A valid Swedish SSN\n\n        // When\n        boolean result = SwedenIdNumber.isValidSwedishSsn(validSsn);\n\n        // Then\n        assertTrue(result);\n    }\n\n    @Test\n    void testIsValidSwedishSsn_InvalidLength() {\n        // Given\n        String invalidLengthSsn = \"811228-987\"; // Invalid length\n\n        // When\n        boolean result = SwedenIdNumber.isValidSwedishSsn(invalidLengthSsn);\n\n        // Then\n        assertFalse(result);\n    }\n\n    @Test\n    void testIsValidSwedishSsn_InvalidDate() {\n        // Given\n        String invalidDateSsn = \"811328-9874\"; // Invalid date (month 13)\n\n        // When\n        boolean result = SwedenIdNumber.isValidSwedishSsn(invalidDateSsn);\n\n        // Then\n        assertFalse(result);\n    }\n\n    @Test\n    void testIsValidSwedishSsn_InvalidChecksum() {\n        // Given\n        String invalidChecksumSsn = \"811228-9875\"; // Invalid checksum\n\n        // When\n        boolean result = SwedenIdNumber.isValidSwedishSsn(invalidChecksumSsn);\n\n        // Then\n        assertFalse(result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/idnumbers/SingaporeIdNumberTest.java.SingaporeIdNumberTest", "name": "SingaporeIdNumberTest", "file_path": "src/test/java/net/datafaker/idnumbers/SingaporeIdNumberTest.java", "superclasses": "", "methods": ["[void]centuryPrefix_forCitizens()", "[void]centuryPrefix_forForeigner()", "[void]randomBirthDate_20th_century()", "[void]randomBirthDate_21th_century()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class SingaporeIdNumberTest {\n    @Test\n    void centuryPrefix_forCitizens() {\n        assertThat(centuryPrefixCitizen(LocalDate.parse(\"1999-12-31\"))).as(\"19xx = S\").isEqualTo('S');\n        assertThat(centuryPrefixCitizen(LocalDate.parse(\"2000-12-31\"))).as(\"20xx = T\").isEqualTo('T');\n        assertThat(centuryPrefixCitizen(LocalDate.parse(\"2001-01-01\"))).as(\"20xx = T\").isEqualTo('T');\n        assertThat(centuryPrefixCitizen(LocalDate.parse(\"2101-01-01\"))).as(\"21xx = U\").isEqualTo('U');\n        assertThat(centuryPrefixCitizen(LocalDate.parse(\"2201-01-01\"))).as(\"22xx = V\").isEqualTo('V');\n    }\n\n    @Test\n    void centuryPrefix_forForeigner() {\n        assertThat(centuryPrefixForeigner(LocalDate.parse(\"1999-12-31\"))).as(\"19xx = F\").isEqualTo('F');\n        assertThat(centuryPrefixForeigner(LocalDate.parse(\"2000-12-31\"))).as(\"20xx = G\").isEqualTo('G');\n        assertThat(centuryPrefixForeigner(LocalDate.parse(\"2001-01-01\"))).as(\"20xx = G\").isEqualTo('G');\n        assertThat(centuryPrefixForeigner(LocalDate.parse(\"2101-01-01\"))).as(\"21xx = H\").isEqualTo('H');\n        assertThat(centuryPrefixForeigner(LocalDate.parse(\"2201-01-01\"))).as(\"22xx = I\").isEqualTo('I');\n    }\n\n    @Test\n    void randomBirthDate_20th_century() {\n        Faker faker = new Faker();\n        for (int i = 0; i < 100; i++) {\n            assertThat(randomBirthDate(faker, SINGAPOREAN_TWENTIETH_CENTURY).getYear() / 100).isEqualTo(19);\n            assertThat(randomBirthDate(faker, FOREIGNER_TWENTIETH_CENTURY).getYear() / 100).isEqualTo(19);\n        }\n    }\n\n    @Test\n    void randomBirthDate_21th_century() {\n        Faker faker = new Faker();\n        for (int i = 0; i < 100; i++) {\n            assertThat(randomBirthDate(faker, SINGAPOREAN_TWENTY_FIRST_CENTURY).getYear() / 100).isEqualTo(20);\n            assertThat(randomBirthDate(faker, FOREIGNER_TWENTY_FIRST_CENTURY).getYear() / 100).isEqualTo(20);\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/idnumbers/UkrainianIdNumberTest.java.UkrainianIdNumberTest", "name": "UkrainianIdNumberTest", "file_path": "src/test/java/net/datafaker/idnumbers/UkrainianIdNumberTest.java", "superclasses": "", "methods": ["[void]valid()", "[void]invalid()"], "method_uris": ["src/test/java/net/datafaker/idnumbers/UkrainianIdNumberTest.java.UkrainianIdNumberTest.[boolean]isUnzrValid(String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class UkrainianIdNumberTest {\n    private final BaseFaker faker = new BaseFaker();\n    private final UkrainianIdNumber ukrainianIdNumber = new UkrainianIdNumber();\n\n    @Test\n    void valid() {\n        IdNumber.IdNumberRequest request = new IdNumber.IdNumberRequest(1, 65, ANY);\n        PersonIdNumber person = ukrainianIdNumber.generateValid(faker, request);\n        String unzr = person.idNumber();\n        LocalDate bod = person.birthDate();\n\n        assertEquals(bod.getYear(), Integer.parseInt(unzr.substring(0, 4)));\n        assertEquals(bod.getMonthValue(), Integer.parseInt(unzr.substring(4, 6)));\n        assertEquals(bod.getDayOfMonth(), Integer.parseInt(unzr.substring(6, 8)));\n        assertTrue(isUnzrValid(unzr));\n    }\n\n    @Test\n    void invalid() {\n        String number = ukrainianIdNumber.generateInvalid(faker);\n        assertFalse(isUnzrValid(number));\n    }\n\n    private boolean isUnzrValid(String unzr) {\n        int[] digits = unzr.replace(\"-\", \"\")\n            .chars()\n            .map(Character::getNumericValue)\n            .toArray();\n\n        int checksum = digits[0] * 7 + digits[1] * 3 + digits[2] + digits[3] * 7 + digits[4] * 3 + digits[5] +\n            digits[6] * 7 + digits[7] * 3 + digits[8] + digits[9] * 7 + digits[10] * 3 + digits[11];\n        return checksum % 10 == digits[12];\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final BaseFaker faker = new BaseFaker();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "BaseFaker", "name": "faker = new BaseFaker()", "syntax_pass": true}, {"attribute_expression": "private final UkrainianIdNumber ukrainianIdNumber = new UkrainianIdNumber();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "UkrainianIdNumber", "name": "ukrainianIdNumber = new UkrainianIdNumber()", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/idnumbers/pt/br/DocumentFormatterUtil_cpfTest.java.DocumentFormatterUtil_cpfTest", "name": "DocumentFormatterUtil_cpfTest", "file_path": "src/test/java/net/datafaker/idnumbers/pt/br/DocumentFormatterUtil_cpfTest.java", "superclasses": "", "methods": ["[void]testCpfFormatting()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DocumentFormatterUtil_cpfTest {\n\n    @Test\n    public void testCpfFormatting() {\n        String input = \"12345678909\";\n        String expected = \"123.456.789-09\";\n        String result = DocumentFormatterUtil.cpf(input);\n        assertEquals(expected, result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/idnumbers/pt/br/DocumentFormatterUtil_unmaskTest.java.DocumentFormatterUtil_unmaskTest", "name": "DocumentFormatterUtil_unmaskTest", "file_path": "src/test/java/net/datafaker/idnumbers/pt/br/DocumentFormatterUtil_unmaskTest.java", "superclasses": "", "methods": ["[void]testUnmask()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DocumentFormatterUtil_unmaskTest {\n\n    @Test\n    public void testUnmask() {\n        // Given\n        String input = \"12.345.678/0001-90\";\n        String expected = \"12345678000190\";\n\n        // When\n        String result = DocumentFormatterUtil.unmask(input);\n\n        // Then\n        assertEquals(expected, result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/idnumbers/pt/br/DocumentFormatterUtil_cnpjTest.java.DocumentFormatterUtil_cnpjTest", "name": "DocumentFormatterUtil_cnpjTest", "file_path": "src/test/java/net/datafaker/idnumbers/pt/br/DocumentFormatterUtil_cnpjTest.java", "superclasses": "", "methods": ["[void]testCnpjFormatting()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class DocumentFormatterUtil_cnpjTest {\n\n    @Test\n    public void testCnpjFormatting() {\n        // Given\n        String input = \"12345678000190\";\n        String expected = \"12.345.678/0001-90\";\n\n        // When\n        String result = DocumentFormatterUtil.cnpj(input);\n\n        // Then\n        assertEquals(expected, result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/idnumbers/pt/br/IdNumberGeneratorPtBrUtil_digitTest.java.IdNumberGeneratorPtBrUtil_digitTest", "name": "IdNumberGeneratorPtBrUtil_digitTest", "file_path": "src/test/java/net/datafaker/idnumbers/pt/br/IdNumberGeneratorPtBrUtil_digitTest.java", "superclasses": "", "methods": ["[void]testDigitRemainderZero()", "[void]testDigitRemainderOne()", "[void]testDigitRemainderGreaterThanOne()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class IdNumberGeneratorPtBrUtil_digitTest {\n\n    @Test\n    public void testDigitRemainderZero() {\n        assertEquals(0, IdNumberGeneratorPtBrUtil.digit(0));\n    }\n\n    @Test\n    public void testDigitRemainderOne() {\n        assertEquals(0, IdNumberGeneratorPtBrUtil.digit(1));\n    }\n\n    @Test\n    public void testDigitRemainderGreaterThanOne() {\n        assertEquals(9, IdNumberGeneratorPtBrUtil.digit(2));\n        assertEquals(8, IdNumberGeneratorPtBrUtil.digit(3));\n        assertEquals(7, IdNumberGeneratorPtBrUtil.digit(4));\n        assertEquals(6, IdNumberGeneratorPtBrUtil.digit(5));\n        assertEquals(5, IdNumberGeneratorPtBrUtil.digit(6));\n        assertEquals(4, IdNumberGeneratorPtBrUtil.digit(7));\n        assertEquals(3, IdNumberGeneratorPtBrUtil.digit(8));\n        assertEquals(2, IdNumberGeneratorPtBrUtil.digit(9));\n        assertEquals(1, IdNumberGeneratorPtBrUtil.digit(10));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/service/FakeValues_equalsTest.java.FakeValues_equalsTest", "name": "FakeValues_equalsTest", "file_path": "src/test/java/net/datafaker/service/FakeValues_equalsTest.java", "superclasses": "", "methods": ["[void]testEquals_SameInstance()", "[void]testEquals_DifferentInstanceSameContext()", "[void]testEquals_DifferentContext()", "[void]testEquals_DifferentType()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FakeValues_equalsTest {\n\n    @Test\n    void testEquals_SameInstance() {\n        FakeValuesContext context = FakeValuesContext.of(Locale.ENGLISH);\n        FakeValues fakeValues = FakeValues.of(context);\n        assertTrue(fakeValues.equals(fakeValues));\n    }\n\n    @Test\n    void testEquals_DifferentInstanceSameContext() {\n        FakeValuesContext context = FakeValuesContext.of(Locale.ENGLISH);\n        FakeValues fakeValues1 = FakeValues.of(context);\n        FakeValues fakeValues2 = FakeValues.of(context);\n        assertTrue(fakeValues1.equals(fakeValues2));\n    }\n\n    @Test\n    void testEquals_DifferentContext() {\n        FakeValuesContext context1 = FakeValuesContext.of(Locale.ENGLISH);\n        FakeValuesContext context2 = FakeValuesContext.of(Locale.FRENCH);\n        FakeValues fakeValues1 = FakeValues.of(context1);\n        FakeValues fakeValues2 = FakeValues.of(context2);\n        assertFalse(fakeValues1.equals(fakeValues2));\n    }\n\n    @Test\n    void testEquals_DifferentType() {\n        FakeValuesContext context = FakeValuesContext.of(Locale.ENGLISH);\n        FakeValues fakeValues = FakeValues.of(context);\n        assertFalse(fakeValues.equals(\"Not a FakeValues instance\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/service/FakeValuesTest.java.FakeValuesTest", "name": "FakeValuesTest", "file_path": "src/test/java/net/datafaker/service/FakeValuesTest.java", "superclasses": "", "methods": ["[void]getAValueReturnsAValue()", "[void]getAValueDoesNotReturnAValue()", "[void]getAValueWithANonEnglishFile()", "[void]getAValueForHebrewLocale()", "[void]correctPathForHebrewLanguage()", "[void]incorrectPathForHebrewLanguage()", "[void]correctLocale()", "[void]getAValueFromALocaleThatCantBeLoaded()", "[void]checkEquals(FakeValues,FakeValues,boolean)"], "method_uris": ["src/test/java/net/datafaker/service/FakeValuesTest.java.FakeValuesTest.[void]before()", "src/test/java/net/datafaker/service/FakeValuesTest.java.FakeValuesTest.[Stream<Arguments>]fakeValuesProvider()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FakeValuesTest {\n\n    private static final String PATH = \"address\";\n    private FakeValues fakeValues;\n\n    @BeforeEach\n    void before() {\n        fakeValues = FakeValues.of(FakeValuesContext.of(Locale.ENGLISH, \"address.yml\", PATH));\n    }\n\n/*\n    Test case for for https://github.com/datafaker-net/datafaker/issues/574\n    To test it need to change net.datafaker.service.FakeValues.loadValues to something from private\n    Powermock can not test it because it requires JUnit4\n    @Test\n    void testLoadValues() {\n        FakeValues fv = Mockito.spy(new FakeValues(Locale.ENGLISH));\n        ExecutorService service = new ForkJoinPool(2);\n        CountDownLatch latch = new CountDownLatch(2);\n        service.submit(() -> {\n            latch.countDown();\n            try {\n                latch.await(10, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            fv.get(\"key\");\n        });\n        service.submit(() -> {\n            latch.countDown();\n            try {\n                latch.await(10, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n            fv.get(\"key\");\n        });\n        service.shutdown();\n        try {\n            service.awaitTermination(10, TimeUnit.SECONDS);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        verify(fv, times(1)).loadValues();\n    }\n*/\n\n    @Test\n    void getAValueReturnsAValue() {\n        assertThat(fakeValues.get(PATH)).isNotNull();\n    }\n\n    @Test\n    void getAValueDoesNotReturnAValue() {\n        assertThat(fakeValues.get(\"dog\")).isNull();\n    }\n\n    @Test\n    void getAValueWithANonEnglishFile() {\n        FakeValues frenchFakeValues = FakeValues.of(FakeValuesContext.of(Locale.FRENCH));\n        assertThat(frenchFakeValues.get(PATH)).isNotNull();\n    }\n\n    @Test\n    void getAValueForHebrewLocale() {\n        FakeValues hebrew = FakeValues.of(FakeValuesContext.of(new Locale(\"iw\")));\n        assertThat(hebrew.get(PATH)).isNotNull();\n    }\n\n    @Test\n    void correctPathForHebrewLanguage() {\n        FakeValues hebrew = FakeValues.of(FakeValuesContext.of(new Locale(\"iw\")));\n        assertThat(hebrew.getPaths()).containsExactly(\"he\");\n    }\n\n    @Test\n    void incorrectPathForHebrewLanguage() {\n        FakeValues hebrew = FakeValues.of(FakeValuesContext.of(new Locale(\"iw\")));\n        assertThat(hebrew.getPaths()).doesNotContain(\"iw\");\n    }\n\n    @Test\n    void correctLocale() {\n        FakeValues fv = FakeValues.of(FakeValuesContext.of(new Locale(\"uk\")));\n        assertThat(fv.getLocale()).isEqualTo(new Locale(\"uk\"));\n    }\n\n    @Test\n    void getAValueFromALocaleThatCantBeLoaded() {\n        FakeValues fakeValues = FakeValues.of(FakeValuesContext.of(new Locale(\"nothing\")));\n        assertThat(fakeValues.get(PATH)).isNull();\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"fakeValuesProvider\")\n    void checkEquals(FakeValues fv1, FakeValues fv2, boolean equals) {\n        if (equals) {\n            assertThat(fv1).isEqualTo(fv2);\n        } else {\n            assertThat(fv1).isNotEqualTo(fv2);\n        }\n    }\n\n    static Stream<Arguments> fakeValuesProvider() throws MalformedURLException {\n        Path tmp = Paths.get(\"tmp\");\n        return Stream.of(\n            of(FakeValues.of(FakeValuesContext.of(Locale.CANADA)), FakeValues.of(FakeValuesContext.of(Locale.CANADA)), true),\n            of(null, FakeValues.of(FakeValuesContext.of(Locale.CANADA)), false),\n            of(FakeValues.of(FakeValuesContext.of(Locale.CANADA)), null, false),\n            of(FakeValues.of(FakeValuesContext.of(Locale.CANADA)), null, false),\n            of(FakeValues.of(FakeValuesContext.of(Locale.ENGLISH)), FakeValues.of(FakeValuesContext.of(Locale.ENGLISH, \"filepath\", \"path\")), false),\n            of(FakeValues.of(FakeValuesContext.of(Locale.ENGLISH, \"filepath\", null)), FakeValues.of(FakeValuesContext.of(Locale.ENGLISH, \"filepath\", \"path\")), false),\n            of(FakeValues.of(FakeValuesContext.of(Locale.ENGLISH, \"filepath\", \"path\")), FakeValues.of(FakeValuesContext.of(Locale.ENGLISH, \"filepath\", \"path\")), true),\n            of(FakeValues.of(FakeValuesContext.of(Locale.ENGLISH, \"filepath\", \"path\", tmp.toUri().toURL())), FakeValues.of(FakeValuesContext.of(Locale.ENGLISH, \"filepath\", \"path\", tmp.toUri().toURL())), true),\n            of(FakeValues.of(FakeValuesContext.of(Locale.ENGLISH, \"filepath\", \"path\", Paths.get(\"tmp2\").toUri().toURL())), FakeValues.of(FakeValuesContext.of(Locale.ENGLISH, \"filepath\", \"path\", tmp.toUri().toURL())), false)\n        );\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final String PATH = \"address\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "PATH = \"address\"", "syntax_pass": true}, {"attribute_expression": "private FakeValues fakeValues;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "FakeValues", "name": "fakeValues", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/service/FakeValuesService_safeFetchTest.java.FakeValuesService_safeFetchTest", "name": "FakeValuesService_safeFetchTest", "file_path": "src/test/java/net/datafaker/service/FakeValuesService_safeFetchTest.java", "superclasses": "", "methods": ["[void]testSafeFetchWithNullObject()", "[void]testSafeFetchWithSingleString()", "[void]testSafeFetchWithListOfStrings()", "[void]testSafeFetchWithSlashDelimitedRegex()"], "method_uris": ["src/test/java/net/datafaker/service/FakeValuesService_safeFetchTest.java.FakeValuesService_safeFetchTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class FakeValuesService_safeFetchTest {\n\n    private FakeValuesService fakeValuesService;\n    private FakerContext context;\n\n    @BeforeEach\n    public void setUp() {\n        context = new FakerContext(Locale.ENGLISH, new RandomService());\n        fakeValuesService = new FakeValuesService() {\n            @Override\n            public <T> T fetchObject(String key, FakerContext context) {\n                if (\"key\".equals(key)) {\n                    return (T) \"singleString\";\n                } else if (\"listKey\".equals(key)) {\n                    return (T) List.of(\"value1\", \"value2\", \"value3\");\n                } else if (\"regexKey\".equals(key)) {\n                    return (T) \"/[a-z]/\";\n                }\n                return null;\n            }\n        };\n    }\n\n    @Test\n    public void testSafeFetchWithNullObject() {\n        String result = fakeValuesService.safeFetch(\"nonexistentKey\", context, \"defaultIfNull\");\n        assertEquals(\"defaultIfNull\", result);\n    }\n\n    @Test\n    public void testSafeFetchWithSingleString() {\n        String result = fakeValuesService.safeFetch(\"key\", context, \"defaultIfNull\");\n        assertEquals(\"singleString\", result);\n    }\n\n    @Test\n    public void testSafeFetchWithListOfStrings() {\n        String result = fakeValuesService.safeFetch(\"listKey\", context, \"defaultIfNull\");\n        assertTrue(List.of(\"value1\", \"value2\", \"value3\").contains(result));\n    }\n\n    @Test\n    public void testSafeFetchWithSlashDelimitedRegex() {\n        String result = fakeValuesService.safeFetch(\"regexKey\", context, \"defaultIfNull\");\n        assertEquals(\"#{regexify '%s'}\".formatted(\"[a-z]\"), result);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private FakeValuesService fakeValuesService;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "FakeValuesService", "name": "fakeValuesService", "syntax_pass": true}, {"attribute_expression": "private FakerContext context;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "FakerContext", "name": "context", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/service/FakeValuesService_csvTest.java.FakeValuesService_csvTest", "name": "FakeValuesService_csvTest", "file_path": "src/test/java/net/datafaker/service/FakeValuesService_csvTest.java", "superclasses": "", "methods": ["[void]testCsv_evenColumns()", "[void]testCsv_oddColumns()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class FakeValuesService_csvTest {\n\n    @Test\n    public void testCsv_evenColumns() {\n        FakeValuesService fakeValuesService = new FakeValuesService();\n        String result = fakeValuesService.csv(\",\", '\"', true, 10, \"name\", \"John\", \"age\", \"30\");\n        assertNotNull(result);\n    }\n\n    @Test\n    public void testCsv_oddColumns() {\n        FakeValuesService fakeValuesService = new FakeValuesService();\n        IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -> {\n            fakeValuesService.csv(\",\", '\"', true, 10, \"name\", \"John\", \"age\");\n        });\n        assertTrue(exception.getMessage().contains(\"Total number of column names and column values should be even\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/service/FakeValuesGroupingTest.java.FakeValuesGroupingTest", "name": "FakeValuesGroupingTest", "file_path": "src/test/java/net/datafaker/service/FakeValuesGroupingTest.java", "superclasses": "", "methods": ["[void]handlesOneFakeValue()", "[void]handlesMultipleFakeValues()"], "method_uris": ["src/test/java/net/datafaker/service/FakeValuesGroupingTest.java.FakeValuesGroupingTest.[void]before()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FakeValuesGroupingTest {\n\n    private FakeValuesGrouping fakeValuesGrouping;\n    private FakeValues addressValues;\n\n    @BeforeEach\n    void before() {\n        fakeValuesGrouping = new FakeValuesGrouping();\n        addressValues = FakeValues.of(FakeValuesContext.of(Locale.ENGLISH, \"address.yml\", \"address\"));\n        fakeValuesGrouping.add(addressValues);\n    }\n\n    @Test\n    void handlesOneFakeValue() {\n        assertThat(fakeValuesGrouping.get(\"address\")).isEqualTo(addressValues.get(\"address\"))\n            .isNotNull();\n    }\n\n    @Test\n    void handlesMultipleFakeValues() {\n        FakeValues catValues = FakeValues.of(FakeValuesContext.of(Locale.ENGLISH, \"cat.yml\", \"creature\"));\n        fakeValuesGrouping.add(catValues);\n\n        assertThat(fakeValuesGrouping.get(\"address\")).isEqualTo(addressValues.get(\"address\"))\n            .isNotNull();\n\n        assertThat(fakeValuesGrouping.get(\"creature\")).isEqualTo(catValues.get(\"creature\"))\n            .isNotNull();\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private FakeValuesGrouping fakeValuesGrouping;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "FakeValuesGrouping", "name": "fakeValuesGrouping", "syntax_pass": true}, {"attribute_expression": "private FakeValues addressValues;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "FakeValues", "name": "addressValues", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/service/FakerContext_setCurrentLocaleTest.java.FakerContext_setCurrentLocaleTest", "name": "FakerContext_setCurrentLocaleTest", "file_path": "src/test/java/net/datafaker/service/FakerContext_setCurrentLocaleTest.java", "superclasses": "", "methods": ["[void]testSetCurrentLocale_NewLocale()", "[void]testSetCurrentLocale_ExistingLocale()"], "method_uris": ["src/test/java/net/datafaker/service/FakerContext_setCurrentLocaleTest.java.FakerContext_setCurrentLocaleTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class FakerContext_setCurrentLocaleTest {\n\n    private FakerContext fakerContext;\n\n    @BeforeEach\n    public void setUp() {\n        fakerContext = new FakerContext(Locale.US, null);\n    }\n\n    @Test\n    public void testSetCurrentLocale_NewLocale() {\n        // Given\n        Locale newLocale = Locale.FRANCE;\n\n        // When\n        fakerContext.setCurrentLocale(newLocale);\n\n        // Then\n        assertEquals(newLocale, fakerContext.getLocale());\n        assertNotNull(fakerContext.getLocaleChain());\n    }\n\n    @Test\n    public void testSetCurrentLocale_ExistingLocale() {\n        // Given\n        Locale existingLocale = Locale.US;\n\n        // When\n        fakerContext.setCurrentLocale(existingLocale);\n\n        // Then\n        assertEquals(existingLocale, fakerContext.getLocale());\n        assertNotNull(fakerContext.getLocaleChain());\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private FakerContext fakerContext;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "FakerContext", "name": "fakerContext", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/service/RandomService_hashCodeTest.java.RandomService_hashCodeTest", "name": "RandomService_hashCodeTest", "file_path": "src/test/java/net/datafaker/service/RandomService_hashCodeTest.java", "superclasses": "", "methods": ["[void]testHashCodeWithSharedRandom()", "[void]testHashCodeWithCustomRandom()", "[void]testHashCodeWithNullRandom()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RandomService_hashCodeTest {\n\n    @Test\n    public void testHashCodeWithSharedRandom() {\n        RandomService randomService = new RandomService();\n        assertEquals(1, randomService.hashCode());\n    }\n\n    @Test\n    public void testHashCodeWithCustomRandom() {\n        Random customRandom = new Random();\n        RandomService randomService = new RandomService(customRandom);\n        assertEquals(customRandom.hashCode(), randomService.hashCode());\n    }\n\n    @Test\n    public void testHashCodeWithNullRandom() {\n        RandomService randomService = new RandomService(null);\n        assertEquals(1, randomService.hashCode());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/service/RandomServiceTest.java.RandomServiceTest", "name": "RandomServiceTest", "file_path": "src/test/java/net/datafaker/service/RandomServiceTest.java", "superclasses": "AbstractFakerTest", "methods": ["[void]testPositiveBoundariesOnly(RandomService)", "[void]testLongWithinBoundary(RandomService)", "[void]testLongMaxBoundary(RandomService)", "[void]testIntInRange(RandomService)", "[void]nextInt_returnsValueWithinGivenRange()", "[void]predictableRandomRange()", "[void]testDoubleInRange(RandomService)", "[void]testLongInRange(RandomService)", "[void]testHex(RandomService)", "[void]testDefaultHex(RandomService)"], "method_uris": ["src/test/java/net/datafaker/service/RandomServiceTest.java.RandomServiceTest.[Stream<Arguments>]randomServiceProvider()"], "overrides": null, "attributes": [], "class_docstring": "\n@author pmiklos\n", "original_string": "class RandomServiceTest extends AbstractFakerTest {\n\n    @ParameterizedTest\n    @MethodSource(\"randomServiceProvider\")\n    void testPositiveBoundariesOnly(RandomService randomService) {\n        assertThatThrownBy(() -> randomService.nextLong(0L))\n            .isInstanceOf(IllegalArgumentException.class);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"randomServiceProvider\")\n    void testLongWithinBoundary(RandomService randomService) {\n        assertThat(randomService.nextLong(1)).isZero();\n\n        for (int i = 1; i < 10; i++) {\n            assertThat(randomService.nextLong(2)).isLessThan(2L);\n        }\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"randomServiceProvider\")\n    void testLongMaxBoundary(RandomService randomService) {\n        assertThat(randomService.nextLong(Long.MAX_VALUE)).isStrictlyBetween(0L, Long.MAX_VALUE);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"randomServiceProvider\")\n    void testIntInRange(RandomService randomService) {\n        final Condition<Integer> lessThanOrEqual = new Condition<>(t -> t <= 5, \"should be less than or equal 5\");\n        final Condition<Integer> greaterThanOrEqual = new Condition<>(t -> t >= -5, \"should be greater than or equal -5\");\n        for (int i = 1; i < 100; i++) {\n            assertThat(randomService.nextInt(-5, 5))\n                .is(allOf(lessThanOrEqual, greaterThanOrEqual));\n        }\n    }\n\n    @Test\n    void nextInt_returnsValueWithinGivenRange() {\n        RandomService randomService = new RandomService();\n        for (int i = 0; i < 10_000; i++) {\n            assertThat(randomService.nextInt(2, 6))\n                .isGreaterThanOrEqualTo(2)\n                .isLessThanOrEqualTo(6);\n        }\n    }\n\n    @Test\n    void predictableRandomRange() {\n        RandomService randomService = new RandomService(new Random(10));\n\n        int i1 = randomService.nextInt();\n        int i2 = randomService.nextInt(100);\n        int i3 = randomService.nextInt(0, 100);\n\n        float f1 = randomService.nextFloat();\n\n        long l1 = randomService.nextLong();\n        long l2 = randomService.nextLong(100);\n        long l3 = randomService.nextLong(100, 1000);\n\n        boolean b = randomService.nextBoolean();\n\n        assertThat(i1).isEqualTo(-1157793070);\n        assertThat(i2).isEqualTo(80);\n        assertThat(i3).isEqualTo(35);\n\n        assertThat(f1).isEqualTo(0.41291267F);\n\n        assertThat(l1).isEqualTo(1092083446069765248L);\n        assertThat(l2).isOne();\n        assertThat(l3).isEqualTo(836L);\n\n        assertThat(b).isFalse();\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"randomServiceProvider\")\n    void testDoubleInRange(RandomService randomService) {\n        final Condition<Double> lessThanOrEqual = new Condition<>(t -> t <= 5d, \"should be less than or equal 5\");\n        final Condition<Double> greaterThanOrEqual = new Condition<>(t -> t >= -5d, \"should be greater than or equal -5\");\n        for (int i = 1; i < 100; i++) {\n            assertThat(randomService.nextDouble(-5, 5)).is(allOf(lessThanOrEqual, greaterThanOrEqual));\n        }\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"randomServiceProvider\")\n    void testLongInRange(RandomService randomService) {\n        final Condition<Long> lessThanOrEqual = new Condition<>(t -> t <= 5_000_000_000L, \"should be less than or equal 5_000_000_000L\");\n        final Condition<Long> greaterThanOrEqual = new Condition<>(t -> t >= -5_000_000_000L, \"should be greater than or equal -5_000_000_000L\");\n        for (int i = 1; i < 1_000; i++) {\n            assertThat(randomService.nextLong(-5_000_000_000L, 5_000_000_000L)).is(allOf(lessThanOrEqual, greaterThanOrEqual));\n        }\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"randomServiceProvider\")\n    void testHex(RandomService randomService) {\n        assertThat(randomService.hex(8)).matches(\"^[0-9A-F]{8}$\");\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"randomServiceProvider\")\n    void testDefaultHex(RandomService randomService) {\n        assertThat(randomService.hex()).matches(\"^[0-9A-F]{8}$\");\n    }\n\n    private static Stream<Arguments> randomServiceProvider() {\n        return Stream.of(\n            Arguments.of(new RandomService(), new RandomService(new Random()))\n        );\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/service/RandomService_hexTest.java.RandomService_hexTest", "name": "RandomService_hexTest", "file_path": "src/test/java/net/datafaker/service/RandomService_hexTest.java", "superclasses": "", "methods": ["[void]testHexWithLengthZero()", "[void]testHexWithPositiveLengthUppercase()", "[void]testHexWithPositiveLengthLowercase()", "[void]testHexWithRandomLengthUppercase()", "[void]testHexWithRandomLengthLowercase()"], "method_uris": ["src/test/java/net/datafaker/service/RandomService_hexTest.java.RandomService_hexTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RandomService_hexTest {\n    private RandomService randomService;\n\n    @BeforeEach\n    public void setUp() {\n        randomService = new RandomService();\n    }\n\n    @Test\n    public void testHexWithLengthZero() {\n        assertEquals(\"\", randomService.hex(0, true));\n        assertEquals(\"\", randomService.hex(0, false));\n    }\n\n    @Test\n    public void testHexWithPositiveLengthUppercase() {\n        String hexString = randomService.hex(10, true);\n        assertEquals(10, hexString.length());\n        assertTrue(hexString.matches(\"^[0-9A-F]{10}$\"));\n    }\n\n    @Test\n    public void testHexWithPositiveLengthLowercase() {\n        String hexString = randomService.hex(10, false);\n        assertEquals(10, hexString.length());\n        assertTrue(hexString.matches(\"^[0-9a-f]{10}$\"));\n    }\n\n    @Test\n    public void testHexWithRandomLengthUppercase() {\n        int length = randomService.nextInt(1, 100);\n        String hexString = randomService.hex(length, true);\n        assertEquals(length, hexString.length());\n        assertTrue(hexString.matches(\"^[0-9A-F]{\" + length + \"}$\"));\n    }\n\n    @Test\n    public void testHexWithRandomLengthLowercase() {\n        int length = randomService.nextInt(1, 100);\n        String hexString = randomService.hex(length, false);\n        assertEquals(length, hexString.length());\n        assertTrue(hexString.matches(\"^[0-9a-f]{\" + length + \"}$\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private RandomService randomService;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RandomService", "name": "randomService", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/service/FakerContext_hashCodeTest.java.FakerContext_hashCodeTest", "name": "FakerContext_hashCodeTest", "file_path": "src/test/java/net/datafaker/service/FakerContext_hashCodeTest.java", "superclasses": "", "methods": ["[void]testHashCodeWithNonNulls()", "[void]testHashCodeWithNulls()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class FakerContext_hashCodeTest {\n\n    @Test\n    public void testHashCodeWithNonNulls() {\n        RandomService randomService = new RandomService();\n        FakerContext context = new FakerContext(Locale.US, randomService);\n        int expectedHashCode = context.getSingletonLocale().hashCode() * 31 + randomService.hashCode();\n        assertEquals(expectedHashCode, context.hashCode());\n    }\n\n    @Test\n    public void testHashCodeWithNulls() {\n        FakerContext context = new FakerContext(Locale.US, null);\n        int expectedHashCode = context.getSingletonLocale().hashCode() * 31;\n        assertEquals(expectedHashCode, context.hashCode());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/service/FakeValuesContext_equalsTest.java.FakeValuesContext_equalsTest", "name": "FakeValuesContext_equalsTest", "file_path": "src/test/java/net/datafaker/service/FakeValuesContext_equalsTest.java", "superclasses": "", "methods": ["[void]testEquals_SameInstance()", "[void]testEquals_DifferentClass()", "[void]testEquals_Null()", "[void]testEquals_DifferentLocale()", "[void]testEquals_DifferentFilename()", "[void]testEquals_DifferentPath()", "[void]testEquals_DifferentUrl()", "[void]testEquals_AllFieldsEqual()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FakeValuesContext_equalsTest {\n\n    @Test\n    void testEquals_SameInstance() {\n        FakeValuesContext context = FakeValuesContext.of(Locale.US);\n        assertTrue(context.equals(context));\n    }\n\n    @Test\n    void testEquals_DifferentClass() {\n        FakeValuesContext context = FakeValuesContext.of(Locale.US);\n        assertFalse(context.equals(new Object()));\n    }\n\n    @Test\n    void testEquals_Null() {\n        FakeValuesContext context = FakeValuesContext.of(Locale.US);\n        assertFalse(context.equals(null));\n    }\n\n    @Test\n    void testEquals_DifferentLocale() {\n        FakeValuesContext context1 = FakeValuesContext.of(Locale.US);\n        FakeValuesContext context2 = FakeValuesContext.of(Locale.UK);\n        assertFalse(context1.equals(context2));\n    }\n\n    @Test\n    void testEquals_DifferentFilename() {\n        FakeValuesContext context1 = FakeValuesContext.of(Locale.US, \"file1\", \"path1\");\n        FakeValuesContext context2 = FakeValuesContext.of(Locale.US, \"file2\", \"path1\");\n        assertFalse(context1.equals(context2));\n    }\n\n    @Test\n    void testEquals_DifferentPath() {\n        FakeValuesContext context1 = FakeValuesContext.of(Locale.US, \"file1\", \"path1\");\n        FakeValuesContext context2 = FakeValuesContext.of(Locale.US, \"file1\", \"path2\");\n        assertFalse(context1.equals(context2));\n    }\n\n    @Test\n    void testEquals_DifferentUrl() throws Exception {\n        URL url1 = new URL(\"http://example.com/1\");\n        URL url2 = new URL(\"http://example.com/2\");\n        FakeValuesContext context1 = FakeValuesContext.of(Locale.US, \"file1\", \"path1\", url1);\n        FakeValuesContext context2 = FakeValuesContext.of(Locale.US, \"file1\", \"path1\", url2);\n        assertFalse(context1.equals(context2));\n    }\n\n    @Test\n    void testEquals_AllFieldsEqual() throws Exception {\n        URL url = new URL(\"http://example.com\");\n        FakeValuesContext context1 = FakeValuesContext.of(Locale.US, \"file1\", \"path1\", url);\n        FakeValuesContext context2 = FakeValuesContext.of(Locale.US, \"file1\", \"path1\", url);\n        assertTrue(context1.equals(context2));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/service/FakeValuesServiceTest.java.FakeValuesServiceTest", "name": "FakeValuesServiceTest", "file_path": "src/test/java/net/datafaker/service/FakeValuesServiceTest.java", "superclasses": "AbstractFakerTest", "methods": ["[void]fetchStringShouldReturnValue()", "[void]fetchShouldReturnValue()", "[void]fetchObjectShouldReturnValue()", "[void]safeFetchShouldReturnValueInList()", "[void]safeFetchShouldReturnSimpleList()", "[void]safeFetchShouldReturnEmptyStringWhenPropertyDoesntExist()", "[void]bothify2Args()", "[void]regexifyDirective()", "[void]regexifySlashFormatDirective()", "[void]regexifyDirective2()", "[void]resolveKeyToPropertyWithAPropertyWithoutAnObject()", "[void]resolveKeyToPropertyWithAList()", "[void]testLocaleChain()", "[void]testLocaleChainEnglish()", "[void]testLocaleChainLanguageOnly()", "[void]testLocalesChainGetter()", "[void]testLocalesChainGetterRu()", "[void]testFakerContextSetLocale()", "[void]testFakerContextSetRandomService()", "[void]checkFakerContextEquality(FakerContext,FakerContext,boolean)", "[void]expressionWithInvalidFakerObject()", "[void]expressionWithValidFakerObjectButInvalidMethod()", "[void]expressionWithValidFakerObjectValidMethodInvalidArgs()", "[void]futureDateExpression()", "[void]pastDateExpression()", "[void]expressionWithSingleEnumArg()", "[void]expressionWithFourArguments()", "[void]fileExpressionTestFailure(String)", "[void]fileNoExpressionTest()", "[void]fileExpressionTest()", "[void]expressionCompletelyUnresolvable()", "[void]resolveUsingTheSameKeyTwice()"], "method_uris": ["src/test/java/net/datafaker/service/FakeValuesServiceTest.java.FakeValuesServiceTest.[void]before()", "src/test/java/net/datafaker/service/FakeValuesServiceTest.java.FakeValuesServiceTest.[Stream<Arguments>]fakerContexts()", "src/test/java/net/datafaker/service/FakeValuesServiceTest.java.FakeValuesServiceTest.[void]expressionShouldFailWithContaining(String,String)"], "overrides": null, "attributes": [{"original_string": "    public static class DummyService {\n        public String firstName() {\n            return \"John\";\n        }\n\n        public String lastName() {\n            return \"Smith\";\n        }\n\n        public String hello() {\n            return \"Hello\";\n        }\n    }", "definition": "    public static class DummyService", "class_docstring": "", "name": "DummyService", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public String firstName() {\n            return \"John\";\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "firstName", "params": [], "body": "                                  {\n            return \"John\";\n        }", "signature": "public String firstName()"}, {"syntax_pass": true, "original_string": "        public String lastName() {\n            return \"Smith\";\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "lastName", "params": [], "body": "                                 {\n            return \"Smith\";\n        }", "signature": "public String lastName()"}, {"syntax_pass": true, "original_string": "        public String hello() {\n            return \"Hello\";\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "hello", "params": [], "body": "                              {\n            return \"Hello\";\n        }", "signature": "public String hello()"}]}], "class_docstring": "", "original_string": "class FakeValuesServiceTest extends AbstractFakerTest {\n\n    private static final DateTimeFormatter DATE_TIME_FORMATTER =\n        new DateTimeFormatterBuilder().appendPattern(\"yyyy-MM-dd HH:mm:ss\")\n            .appendFraction(ChronoField.MILLI_OF_SECOND, 0, 3, true).toFormatter();\n\n    @Spy\n    private BaseFaker mockedFaker;\n\n    @Mock\n    private RandomService randomService;\n\n    @Spy\n    private FakeValuesService fakeValuesService;\n    private FakerContext context;\n\n    @BeforeEach\n    final void before() {\n        // always return the first element\n        when(randomService.nextInt(anyInt())).thenReturn(0);\n        context = new FakerContext(new Locale(\"test\"), randomService);\n        when(mockedFaker.getContext()).thenReturn(context);\n        fakeValuesService.updateFakeValuesInterfaceMap(context.getLocaleChain());\n    }\n\n    @Test\n    void fetchStringShouldReturnValue() {\n        assertThat(fakeValuesService.fetchString(\"property.dummy\", mockedFaker.getContext())).isEqualTo(\"x\");\n    }\n\n    @Test\n    void fetchShouldReturnValue() {\n        assertThat(fakeValuesService.fetch(\"property.dummy\", mockedFaker.getContext())).isEqualTo(\"x\");\n    }\n\n    @Test\n    void fetchObjectShouldReturnValue() {\n        List<String> dummy = fakeValuesService.fetchObject(\"property.dummy\", mockedFaker.getContext());\n        assertThat(dummy).isEqualTo(List.of(\"x\", \"y\", \"z\"));\n    }\n\n    @Test\n    void safeFetchShouldReturnValueInList() {\n        doReturn(0).when(randomService).nextInt(anyInt());\n        assertThat(fakeValuesService.safeFetch(\"property.dummy\", mockedFaker.getContext(), null)).isEqualTo(\"x\");\n    }\n\n    @Test\n    void safeFetchShouldReturnSimpleList() {\n        assertThat(fakeValuesService.safeFetch(\"property.simple\", mockedFaker.getContext(), null)).isEqualTo(\"hello\");\n    }\n\n    @Test\n    void safeFetchShouldReturnEmptyStringWhenPropertyDoesntExist() {\n        assertThat(fakeValuesService.safeFetch(\"property.dummy2\", mockedFaker.getContext(), \"\")).isEmpty();\n    }\n\n    @Test\n    void bothify2Args() {\n        final DummyService dummy = mock(DummyService.class);\n\n        BaseFaker f = new BaseFaker();\n\n        String value = fakeValuesService.resolve(\"property.bothify_2\", dummy, f, context);\n        assertThat(value).matches(\"[A-Z]{2}\\\\d{2}\");\n    }\n\n    @Test\n    void regexifyDirective() {\n        final DummyService dummy = mock(DummyService.class);\n\n        String value = fakeValuesService.resolve(\"property.regexify1\", dummy, mockedFaker, mockedFaker.getContext());\n        assertThat(value).isIn(\"55\", \"44\", \"45\", \"54\");\n        verify(mockedFaker).regexify(\"[45]{2}\");\n    }\n\n    @Test\n    void regexifySlashFormatDirective() {\n        final DummyService dummy = mock(DummyService.class);\n\n        String value = fakeValuesService.resolve(\"property.regexify_slash_format\", dummy, mockedFaker, mockedFaker.getContext());\n        assertThat(value).isIn(\"55\", \"44\", \"45\", \"54\");\n        verify(mockedFaker).regexify(\"[45]{2}\");\n    }\n\n    @Test\n    void regexifyDirective2() {\n        final DummyService dummy = mock(DummyService.class);\n\n        String value = fakeValuesService.resolve(\"property.regexify_cell\", dummy, mockedFaker, mockedFaker.getContext());\n        assertThat(value).isIn(\"479\", \"459\");\n        verify(mockedFaker).regexify(\"4[57]9\");\n    }\n\n    @Test\n    void resolveKeyToPropertyWithAPropertyWithoutAnObject() {\n        // #{hello} -> DummyService.hello\n\n        // given\n        final DummyService dummy = mock(DummyService.class);\n        doReturn(\"Yo!\").when(dummy).hello();\n\n        // when\n        final String actual = fakeValuesService.resolve(\"property.simpleResolution\", dummy, mockedFaker, mockedFaker.getContext());\n\n        // then\n        assertThat(actual).isEqualTo(\"Yo!\");\n        verify(dummy).hello();\n    }\n\n    @Test\n    void resolveKeyToPropertyWithAList() {\n        // property.resolutionWithList -> #{hello}\n        // #{hello} -> DummyService.hello\n        class Property extends AbstractProvider<BaseProviders> {\n            private Property(BaseProviders faker) {\n                super(faker);\n                ClassLoader classLoader = getClass().getClassLoader();\n                URL resource = classLoader.getResource(\"test.yml\");\n                faker.addUrl(new Locale(\"test\"), resource);\n            }\n\n            public String hello() {\n                return \"Yo!\";\n            }\n\n            public String hello2() {\n                return \"Yo2!\";\n            }\n\n            public String resolutionWithList() {\n                return resolve(\"property.resolutionWithList\");\n            }\n        }\n        class PropertyFaker extends BaseFaker {\n            private PropertyFaker() {\n                super(new Locale(\"test\"));\n            }\n\n            public Property property() {\n                return getProvider(Property.class, Property::new);\n            }\n        }\n        var testFaker = new PropertyFaker();\n        Property provider = testFaker.getProvider(\"Property\");\n        String actual = provider.resolutionWithList();\n        assertThat(actual).startsWith(\"Yo\");\n    }\n\n    @Test\n    void testLocaleChain() {\n        final List<SingletonLocale> chain = context.localeChain(Locale.SIMPLIFIED_CHINESE);\n\n        assertThat(chain).map(SingletonLocale::getLocale).contains(Locale.SIMPLIFIED_CHINESE, Locale.CHINESE, Locale.ENGLISH);\n    }\n\n    @Test\n    void testLocaleChainEnglish() {\n        final List<SingletonLocale> chain = new FakerContext(Locale.ENGLISH, null).localeChain(Locale.ENGLISH);\n\n        assertThat(chain).map(SingletonLocale::getLocale).contains(Locale.ENGLISH);\n    }\n\n    @Test\n    void testLocaleChainLanguageOnly() {\n        final List<SingletonLocale> chain = new FakerContext(Locale.CHINESE, null).localeChain(Locale.CHINESE);\n\n        assertThat(chain).map(SingletonLocale::getLocale).contains(Locale.CHINESE, Locale.ENGLISH);\n    }\n\n    @Test\n    void testLocalesChainGetter() {\n        final List<SingletonLocale> chain = context.getLocaleChain();\n\n        assertThat(chain).map(SingletonLocale::getLocale).contains(new Locale(\"test\"), Locale.ENGLISH);\n    }\n\n    @Test\n    void testLocalesChainGetterRu() {\n        final FakerContext FVS = new FakerContext(new Locale(\"ru\"), randomService);\n        final List<SingletonLocale> processedChain = FVS.localeChain(new Locale(\"ru\"));\n        final List<SingletonLocale> chain = FVS.getLocaleChain();\n\n        assertThat(chain).isEqualTo(processedChain);\n    }\n\n    @Test\n    void testFakerContextSetLocale() {\n        final FakerContext fakerContext = new FakerContext(new Locale(\"en\"), randomService);\n        fakerContext.setLocale(new Locale(\"uk\"));\n        assertThat(fakerContext.getLocale()).isEqualTo(new Locale(\"uk\"));\n    }\n\n    @Test\n    void testFakerContextSetRandomService() {\n        final FakerContext fakerContext = new FakerContext(Locale.US, randomService);\n        fakerContext.setRandomService(new RandomService());\n        assertThat(fakerContext.getRandomService()).usingRecursiveComparison().isEqualTo(new RandomService());\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"fakerContexts\")\n    void checkFakerContextEquality(FakerContext fc1, FakerContext fc2, boolean equals) {\n        if (equals) {\n            assertThat(fc1).usingRecursiveComparison().isEqualTo(fc2);\n        } else {\n            assertThat(fc1).usingRecursiveComparison().isNotEqualTo(fc2);\n        }\n    }\n\n    static Stream<Arguments> fakerContexts() {\n        return Stream.of(\n            Arguments.of(new FakerContext(new Locale(\"en\"), new RandomService()), new FakerContext(new Locale(\"uk\"), new RandomService()), false),\n            Arguments.of(new FakerContext(new Locale(\"en\"), new RandomService()), null, false),\n            Arguments.of(new FakerContext(Locale.US, new RandomService()), new FakerContext(Locale.US, new RandomService()), true)\n        );\n    }\n\n    @Test\n    void expressionWithInvalidFakerObject() {\n        expressionShouldFailWithContaining(\"#{ObjectNotOnFaker.methodName}\",\n            \"Unable to resolve #{ObjectNotOnFaker.methodName} directive\");\n    }\n\n    @Test\n    void expressionWithValidFakerObjectButInvalidMethod() {\n        expressionShouldFailWithContaining(\"#{Name.nonExistentMethod}\",\n            \"Unable to resolve #{Name.nonExistentMethod} directive\");\n    }\n\n    /**\n     * Two things are important here:\n     * 1) the message in the exception should be USEFUL\n     * 2) a {@link RuntimeException} should be thrown.\n     * <p>\n     * if the message changes, it's ok to update the test provided\n     * the two conditions above are still true.\n     */\n    @Test\n    void expressionWithValidFakerObjectValidMethodInvalidArgs() {\n        expressionShouldFailWithContaining(\"#{Number.number_between 'x','y'}\",\n            \"Unable to resolve #{Number.number_between 'x','y'} directive\");\n    }\n\n    @RepeatedTest(100)\n    void futureDateExpression() {\n        LocalDateTime now = LocalDateTime.now(OffsetDateTime.now(ZoneId.systemDefault()).getOffset());\n        LocalDateTime nowPlus10Days = now.plusDays(10);\n        String expression = fakeValuesService.expression(\"#{date.future '10','TimeUnit.DAYS'}\", faker, context);\n        LocalDateTime date = LocalDateTime.parse(expression, DATE_TIME_FORMATTER);\n        assertThat(date).isStrictlyBetween(now, nowPlus10Days);\n    }\n\n    @RepeatedTest(100)\n    void pastDateExpression() {\n        LocalDateTime now = LocalDateTime.now(OffsetDateTime.now(ZoneId.systemDefault()).getOffset());\n        LocalDateTime nowMinus5Hours = now.minusHours(5);\n        String expression = fakeValuesService.expression(\"#{date.past '4','TimeUnit.HOURS'}\", faker, context);\n        LocalDateTime date = LocalDateTime.parse(expression, DATE_TIME_FORMATTER);\n        assertThat(date).isStrictlyBetween(nowMinus5Hours, now);\n    }\n\n    @Test\n    void expressionWithSingleEnumArg() {\n        // https://github.com/datafaker-net/datafaker/issues/1274\n        String masterCard = fakeValuesService.expression(\"#{finance.creditCard 'CreditCardType.MASTERCARD'}\", faker, context);\n        assertThat(LuhnCheckDigit.LUHN_CHECK_DIGIT.isValid(masterCard.replace(\"-\", \"\"))).isTrue();\n    }\n\n    @Test\n    void expressionWithFourArguments() {\n        assertThat(fakeValuesService.expression(\"#{Internet.password '5','8','true','true'}\", faker, context))\n            .matches(\"[\\\\w\\\\d!%#$@_^&*]{5,8}\");\n    }\n\n    @ParameterizedTest\n    @ValueSource(strings = {\"src/test/test.txt_null\", \"qwerty\", \"src\"})\n    void fileExpressionTestFailure(String filename) {\n        assertThatThrownBy(() -> fakeValuesService.fileExpression(Paths.get(filename), faker, faker.getContext()))\n            .isInstanceOf(RuntimeException.class);\n    }\n\n    @Test\n    void fileNoExpressionTest() throws IOException {\n        Path tmpPath = Files.createTempFile(\"tmp\", \"file\");\n        assertThat(String.join(\"\", Files.readAllLines(tmpPath)))\n            .isEqualTo(fakeValuesService.fileExpression(tmpPath, faker, faker.getContext()));\n    }\n\n    @Test\n    void fileExpressionTest() throws IOException {\n        Path path = Paths.get(\"src/test/test.txt\");\n        assertThat(String.join(System.lineSeparator(), Files.readAllLines(path)))\n            .isNotEqualTo(fakeValuesService.fileExpression(path, faker, context));\n    }\n\n    /**\n     * Two things are important here:\n     * 1) the message in the exception should be USEFUL\n     * 2) a {@link RuntimeException} should be thrown.\n     * <p>\n     * if the message changes, it's ok to update the test provided\n     * the two conditions above are still true.\n     */\n    @Test\n    void expressionCompletelyUnresolvable() {\n        expressionShouldFailWithContaining(\"#{x}\", \"Unable to resolve #{x} directive\");\n    }\n\n    private void expressionShouldFailWithContaining(String expression, String errorMessagePattern) {\n        assertThatThrownBy(() -> fakeValuesService.expression(expression, faker, context))\n            .isInstanceOf(RuntimeException.class)\n            .hasMessageContaining(errorMessagePattern);\n    }\n\n    @Test\n    void resolveUsingTheSameKeyTwice() {\n        // #{hello} -> DummyService.hello\n\n        // given\n        final DummyService dummy = mock(DummyService.class);\n        when(dummy.hello()).thenReturn(\"1\").thenReturn(\"2\");\n\n        // when\n        final String actual = fakeValuesService.resolve(\"property.sameResolution\", dummy, mockedFaker, mockedFaker.getContext());\n\n        // then\n        assertThat(actual).isEqualTo(\"1 2\");\n    }\n\n    public static class DummyService {\n        public String firstName() {\n            return \"John\";\n        }\n\n        public String lastName() {\n            return \"Smith\";\n        }\n\n        public String hello() {\n            return \"Hello\";\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final DateTimeFormatter DATE_TIME_FORMATTER =\n        new DateTimeFormatterBuilder().appendPattern(\"yyyy-MM-dd HH:mm:ss\")\n            .appendFraction(ChronoField.MILLI_OF_SECOND, 0, 3, true).toFormatter();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "DateTimeFormatter", "name": "DATE_TIME_FORMATTER =\n        new DateTimeFormatterBuilder().appendPattern(\"yyyy-MM-dd HH:mm:ss\")\n            .appendFraction(ChronoField.MILLI_OF_SECOND, 0, 3, true).toFormatter()", "syntax_pass": true}, {"attribute_expression": "@Spy\n    private BaseFaker mockedFaker;", "docstring": "", "modifiers": "@Spy\n    private", "marker_annotations": ["@Spy"], "non_marker_annotations": ["private"], "comments": [], "type": "BaseFaker", "name": "mockedFaker", "syntax_pass": true}, {"attribute_expression": "@Mock\n    private RandomService randomService;", "docstring": "", "modifiers": "@Mock\n    private", "marker_annotations": ["@Mock"], "non_marker_annotations": ["private"], "comments": [], "type": "RandomService", "name": "randomService", "syntax_pass": true}, {"attribute_expression": "@Spy\n    private FakeValuesService fakeValuesService;", "docstring": "", "modifiers": "@Spy\n    private", "marker_annotations": ["@Spy"], "non_marker_annotations": ["private"], "comments": [], "type": "FakeValuesService", "name": "fakeValuesService", "syntax_pass": true}, {"attribute_expression": "private FakerContext context;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "FakerContext", "name": "context", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/service/RandomService_nextLongTest.java.RandomService_nextLongTest", "name": "RandomService_nextLongTest", "file_path": "src/test/java/net/datafaker/service/RandomService_nextLongTest.java", "superclasses": "", "methods": ["[void]testNextLongWithPositiveBound()", "[void]testNextLongWithBoundOne()", "[void]testNextLongWithNegativeBound()", "[void]testNextLongWithZeroBound()", "[void]testLongWithinBoundary(RandomService)"], "method_uris": ["src/test/java/net/datafaker/service/RandomService_nextLongTest.java.RandomService_nextLongTest.[void]setUp()", "src/test/java/net/datafaker/service/RandomService_nextLongTest.java.RandomService_nextLongTest.[Stream<Arguments>]randomServiceProvider()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class RandomService_nextLongTest {\n\n    private RandomService randomService;\n\n    @BeforeEach\n    public void setUp() {\n        randomService = new RandomService();\n    }\n\n    @Test\n    void testNextLongWithPositiveBound() {\n        long bound = 10L;\n        long result = randomService.nextLong(bound);\n        assertThat(result).isGreaterThanOrEqualTo(0L).isLessThan(bound);\n    }\n\n    @Test\n    void testNextLongWithBoundOne() {\n        long bound = 1L;\n        long result = randomService.nextLong(bound);\n        assertThat(result).isEqualTo(0L);\n    }\n\n    @Test\n    void testNextLongWithNegativeBound() {\n        long bound = -10L;\n        assertThatThrownBy(() -> randomService.nextLong(bound))\n                .isInstanceOf(IllegalArgumentException.class)\n                .hasMessage(\"bound must be positive: \" + bound);\n    }\n\n    @Test\n    void testNextLongWithZeroBound() {\n        long bound = 0L;\n        assertThatThrownBy(() -> randomService.nextLong(bound))\n                .isInstanceOf(IllegalArgumentException.class)\n                .hasMessage(\"bound must be positive: \" + bound);\n    }\n\n    @ParameterizedTest\n    @MethodSource(\"randomServiceProvider\")\n    void testLongWithinBoundary(RandomService randomService) {\n        assertThat(randomService.nextLong(1)).isZero();\n\n        for (int i = 1; i < 10; i++) {\n            assertThat(randomService.nextLong(2)).isLessThan(2L);\n        }\n    }\n\n    private static Stream<Arguments> randomServiceProvider() {\n        return Stream.of(\n                Arguments.of(new RandomService(new Random())),\n                Arguments.of(new RandomService())\n        );\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private RandomService randomService;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "RandomService", "name": "randomService", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/service/FakeValuesService_primitiveToWrapperTest.java.FakeValuesService_primitiveToWrapperTest", "name": "FakeValuesService_primitiveToWrapperTest", "file_path": "src/test/java/net/datafaker/service/FakeValuesService_primitiveToWrapperTest.java", "superclasses": "", "methods": ["[void]testPrimitiveToWrapper_Primitive()", "[void]testPrimitiveToWrapper_NonPrimitive()", "[void]testPrimitiveToWrapper_Null()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FakeValuesService_primitiveToWrapperTest {\n\n    @Test\n    void testPrimitiveToWrapper_Primitive() {\n        Class<?> result = FakeValuesService.primitiveToWrapper(int.class);\n        assertEquals(Integer.class, result);\n    }\n\n    @Test\n    void testPrimitiveToWrapper_NonPrimitive() {\n        Class<?> result = FakeValuesService.primitiveToWrapper(String.class);\n        assertEquals(String.class, result);\n    }\n\n    @Test\n    void testPrimitiveToWrapper_Null() {\n        Class<?> result = FakeValuesService.primitiveToWrapper(null);\n        assertNull(result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/service/files/EnFileTest.java.EnFileTest", "name": "EnFileTest", "file_path": "src/test/java/net/datafaker/service/files/EnFileTest.java", "superclasses": "", "methods": ["[void]fileNameConvention()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class EnFileTest {\n\n    /**\n     * To adhere to conventions, please use lowercase names only.\n     */\n    @Test\n    void fileNameConvention() {\n        assertThat(EnFile.getFiles()).allSatisfy(e -> assertThat(e.getFile()).isLowerCase());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/internal/helper/CopyOnWriteMap_updateNestedValueTest.java.CopyOnWriteMap_updateNestedValueTest", "name": "CopyOnWriteMap_updateNestedValueTest", "file_path": "src/test/java/net/datafaker/internal/helper/CopyOnWriteMap_updateNestedValueTest.java", "superclasses": "", "methods": ["[void]testUpdateNestedValue_KeyExists()", "[void]testUpdateNestedValue_KeyDoesNotExist()"], "method_uris": ["src/test/java/net/datafaker/internal/helper/CopyOnWriteMap_updateNestedValueTest.java.CopyOnWriteMap_updateNestedValueTest.[void]setUp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CopyOnWriteMap_updateNestedValueTest {\n\n    private CopyOnWriteMap<String, Map<String, Integer>> map;\n\n    @BeforeEach\n    public void setUp() {\n        map = new CopyOnWriteMap<>(HashMap::new);\n    }\n\n    @Test\n    public void testUpdateNestedValue_KeyExists() {\n        // Given\n        Map<String, Integer> nestedMap = new HashMap<>();\n        nestedMap.put(\"key2\", 1);\n        map.put(\"key1\", nestedMap);\n\n        // When\n        map.updateNestedValue(\"key1\", HashMap::new, \"key2\", 2);\n\n        // Then\n        assertEquals(2, map.get(\"key1\").get(\"key2\"));\n    }\n\n    @Test\n    public void testUpdateNestedValue_KeyDoesNotExist() {\n        // Given\n        Supplier<Map<String, Integer>> nestedMapSupplier = HashMap::new;\n\n        // When\n        map.updateNestedValue(\"key1\", nestedMapSupplier, \"key2\", 1);\n\n        // Then\n        assertTrue(map.containsKey(\"key1\"));\n        assertEquals(1, map.get(\"key1\").get(\"key2\"));\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private CopyOnWriteMap<String, Map<String, Integer>> map;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "CopyOnWriteMap<String, Map<String, Integer>>", "name": "map", "syntax_pass": true}]}, {"uris": "src/test/java/net/datafaker/internal/helper/CopyOnWriteMap_removeTest.java.CopyOnWriteMap_removeTest", "name": "CopyOnWriteMap_removeTest", "file_path": "src/test/java/net/datafaker/internal/helper/CopyOnWriteMap_removeTest.java", "superclasses": "", "methods": ["[void]testRemove()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CopyOnWriteMap_removeTest {\n\n    @Test\n    public void testRemove() {\n        // Given\n        Supplier<Map<String, String>> mapSupplier = HashMap::new;\n        CopyOnWriteMap<String, String> copyOnWriteMap = new CopyOnWriteMap<>(mapSupplier);\n        copyOnWriteMap.put(\"key1\", \"value1\");\n        copyOnWriteMap.put(\"key2\", \"value2\");\n\n        // When\n        String removedValue = copyOnWriteMap.remove(\"key1\");\n\n        // Then\n        assertEquals(\"value1\", removedValue);\n        assertFalse(copyOnWriteMap.containsKey(\"key1\"));\n        assertEquals(1, copyOnWriteMap.size());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/internal/helper/LazyEvaluated_getTest.java.LazyEvaluated_getTest", "name": "LazyEvaluated_getTest", "file_path": "src/test/java/net/datafaker/internal/helper/LazyEvaluated_getTest.java", "superclasses": "", "methods": ["[void]testGet_ValueNotInitialized()", "[void]testGet_ValueAlreadyInitialized()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class LazyEvaluated_getTest {\n\n    @Test\n    public void testGet_ValueNotInitialized() {\n        // Given\n        Supplier<String> mockSupplier = mock(Supplier.class);\n        when(mockSupplier.get()).thenReturn(\"initializedValue\");\n        LazyEvaluated<String> lazyEvaluated = new LazyEvaluated<>(mockSupplier);\n\n        // When\n        String result = lazyEvaluated.get();\n\n        // Then\n        assertEquals(\"initializedValue\", result);\n        verify(mockSupplier, times(1)).get();\n    }\n\n    @Test\n    public void testGet_ValueAlreadyInitialized() {\n        // Given\n        Supplier<String> mockSupplier = mock(Supplier.class);\n        when(mockSupplier.get()).thenReturn(\"initializedValue\");\n        LazyEvaluated<String> lazyEvaluated = new LazyEvaluated<>(mockSupplier);\n        lazyEvaluated.get(); // Initialize the value\n\n        // When\n        String result = lazyEvaluated.get();\n\n        // Then\n        assertEquals(\"initializedValue\", result);\n        verify(mockSupplier, times(1)).get(); // Ensure supplier.get() is called only once\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/internal/helper/WordUtilsTest.java.WordUtilsTest", "name": "WordUtilsTest", "file_path": "src/test/java/net/datafaker/internal/helper/WordUtilsTest.java", "superclasses": "", "methods": ["[void]capitalizeWord()", "[void]capitalizeNull()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class WordUtilsTest {\n\n    @Test\n    void capitalizeWord() {\n        assertThat(WordUtils.capitalize(\"w\")).isEqualTo(\"W\");\n        assertThat(WordUtils.capitalize(\"W\")).isEqualTo(\"W\");\n\n        assertThat(WordUtils.capitalize(\"word\")).isEqualTo(\"Word\");\n        assertThat(WordUtils.capitalize(\"Word\")).isEqualTo(\"Word\");\n        assertThat(WordUtils.capitalize(\"WORD\")).isEqualTo(\"WORD\");\n        assertThat(WordUtils.capitalize(\"wORD\")).isEqualTo(\"WORD\");\n    }\n\n    @Test\n    void capitalizeNull() {\n        assertThat(WordUtils.capitalize(null)).isNull();\n        assertThat(WordUtils.capitalize(\"\")).isEmpty();\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/internal/helper/CopyOnWriteMap_putAllTest.java.CopyOnWriteMap_putAllTest", "name": "CopyOnWriteMap_putAllTest", "file_path": "src/test/java/net/datafaker/internal/helper/CopyOnWriteMap_putAllTest.java", "superclasses": "", "methods": ["[void]testPutAll()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CopyOnWriteMap_putAllTest {\n\n    @Test\n    public void testPutAll() {\n        // Given\n        Supplier<Map<String, Integer>> mapSupplier = () -> new HashMap<>();\n        CopyOnWriteMap<String, Integer> copyOnWriteMap = new CopyOnWriteMap<>(mapSupplier);\n        Map<String, Integer> initialMap = new HashMap<>();\n        initialMap.put(\"key1\", 1);\n        initialMap.put(\"key2\", 2);\n        copyOnWriteMap.putAll(initialMap);\n\n        Map<String, Integer> newMap = new HashMap<>();\n        newMap.put(\"key3\", 3);\n        newMap.put(\"key4\", 4);\n\n        // When\n        copyOnWriteMap.putAll(newMap);\n\n        // Then\n        assertEquals(4, copyOnWriteMap.size());\n        assertTrue(copyOnWriteMap.containsKey(\"key1\"));\n        assertTrue(copyOnWriteMap.containsKey(\"key2\"));\n        assertTrue(copyOnWriteMap.containsKey(\"key3\"));\n        assertTrue(copyOnWriteMap.containsKey(\"key4\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/internal/helper/FakerIDNTest.java.FakerIDNTest", "name": "FakerIDNTest", "file_path": "src/test/java/net/datafaker/internal/helper/FakerIDNTest.java", "superclasses": "", "methods": ["[void]toASCIINoError()", "[void]toASCIIResultIsEmptyException()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class FakerIDNTest {\n\n    @Test\n    void toASCIINoError() {\n        assertThat(FakerIDN.toASCII(\"hello\")).isEqualTo(\"hello\");\n    }\n\n    @Test\n    void toASCIIResultIsEmptyException() { // http://\u023abby.com\n        assertThatThrownBy(() -> FakerIDN.toASCII(\"\u023a\"))\n            .isInstanceOf(RuntimeException.class);\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/internal/helper/CopyOnWriteMap_putTest.java.CopyOnWriteMap_putTest", "name": "CopyOnWriteMap_putTest", "file_path": "src/test/java/net/datafaker/internal/helper/CopyOnWriteMap_putTest.java", "superclasses": "", "methods": ["[void]testPut()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CopyOnWriteMap_putTest {\n\n    @Test\n    public void testPut() {\n        // Given\n        Supplier<Map<String, String>> mapSupplier = () -> new HashMap<>();\n        CopyOnWriteMap<String, String> copyOnWriteMap = new CopyOnWriteMap<>(mapSupplier);\n        Map<String, String> initialMap = new HashMap<>();\n        initialMap.put(\"key1\", \"value1\");\n        copyOnWriteMap.putAll(initialMap);\n\n        // When\n        String result = copyOnWriteMap.put(\"key2\", \"value2\");\n\n        // Then\n        assertNull(result); // Since \"key2\" did not exist before, result should be null\n        assertEquals(\"value2\", copyOnWriteMap.get(\"key2\")); // Verify the new key-value pair is added\n        assertEquals(2, copyOnWriteMap.size()); // Verify the size of the map has increased by 1\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/internal/helper/WordUtils_capitalizeTest.java.WordUtils_capitalizeTest", "name": "WordUtils_capitalizeTest", "file_path": "src/test/java/net/datafaker/internal/helper/WordUtils_capitalizeTest.java", "superclasses": "", "methods": ["[void]testCapitalize_nullInput()", "[void]testCapitalize_emptyInput()", "[void]testCapitalize_alreadyCapitalized()", "[void]testCapitalize_needsCapitalization()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class WordUtils_capitalizeTest {\n\n    @Test\n    public void testCapitalize_nullInput() {\n        assertNull(WordUtils.capitalize(null));\n    }\n\n    @Test\n    public void testCapitalize_emptyInput() {\n        assertEquals(\"\", WordUtils.capitalize(\"\"));\n    }\n\n    @Test\n    public void testCapitalize_alreadyCapitalized() {\n        assertEquals(\"Hello\", WordUtils.capitalize(\"Hello\"));\n    }\n\n    @Test\n    public void testCapitalize_needsCapitalization() {\n        assertEquals(\"World\", WordUtils.capitalize(\"world\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/internal/helper/JavaNamesTest.java.JavaNamesTest", "name": "JavaNamesTest", "file_path": "src/test/java/net/datafaker/internal/helper/JavaNamesTest.java", "superclasses": "", "methods": ["[void]singleWord()", "[void]emptyString()", "[void]nullString()", "[void]wordWithDigit()", "[void]wordStartingWithDigit()", "[void]singleCharacter()", "[void]singleCharacterUnderscore()", "[void]onlyUnderscores()", "[void]multipleWordsSeparatedByUnderscores()", "[void]multipleUnderscoresInRow()", "[void]upperFirstCharacterWithoutUnderscores()", "[void]upperFirstCharacterWithUnderscores()", "[void]endingWithUnderscore()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class JavaNamesTest {\n    @Test\n    void singleWord() {\n        assertThat(toJavaNames(\"variety\", false)).isEqualTo(\"Variety\");\n        assertThat(toJavaNames(\"variety\", true)).isEqualTo(\"variety\");\n    }\n\n    @Test\n    void emptyString() {\n        assertThat(toJavaNames(\"\", false)).isEqualTo(\"\");\n        assertThat(toJavaNames(\"\", true)).isEqualTo(\"\");\n    }\n\n    @Test\n    void nullString() {\n        assertThat(toJavaNames(null, false)).isNull();\n        assertThat(toJavaNames(null, true)).isNull();\n    }\n\n    @Test\n    void wordWithDigit() {\n        assertThat(toJavaNames(\"dota2\", false)).isEqualTo(\"Dota2\");\n        assertThat(toJavaNames(\"dota2\", true)).isEqualTo(\"dota2\");\n    }\n\n    @Test\n    void wordStartingWithDigit() {\n        assertThat(toJavaNames(\"1love\", false)).isEqualTo(\"1love\");\n        assertThat(toJavaNames(\"1love\", true)).isEqualTo(\"1love\");\n    }\n\n    @Test\n    void singleCharacter() {\n        assertThat(toJavaNames(\"x\", false)).isEqualTo(\"X\");\n        assertThat(toJavaNames(\"x\", true)).isEqualTo(\"x\");\n    }\n\n    @Test\n    void singleCharacterUnderscore() {\n        assertThat(toJavaNames(\"_\", false)).isEqualTo(\"\");\n        assertThat(toJavaNames(\"_\", true)).isEqualTo(\"\");\n    }\n\n    @Test\n    void onlyUnderscores() {\n        assertThat(toJavaNames(\"__\", false)).isEqualTo(\"\");\n        assertThat(toJavaNames(\"___\", true)).isEqualTo(\"\");\n    }\n\n    @Test\n    void multipleWordsSeparatedByUnderscores() {\n        assertThat(toJavaNames(\"big_bang_theory\", false)).isEqualTo(\"BigBangTheory\");\n        assertThat(toJavaNames(\"big_bang_theory\", true)).isEqualTo(\"bigBangTheory\");\n    }\n\n    @Test\n    void multipleUnderscoresInRow() {\n        assertThat(toJavaNames(\"big__bang___theory\", false)).isEqualTo(\"BigBangTheory\");\n        assertThat(toJavaNames(\"big__bang___theory\", true)).isEqualTo(\"bigBangTheory\");\n    }\n\n    @Test\n    void upperFirstCharacterWithoutUnderscores() {\n        assertThat(toJavaNames(\"A2013\", false)).isEqualTo(\"A2013\");\n        assertThat(toJavaNames(\"A2013\", true)).isEqualTo(\"a2013\");\n    }\n\n    @Test\n    void upperFirstCharacterWithUnderscores() {\n        assertThat(toJavaNames(\"IATA_airline\", false)).isEqualTo(\"IATAAirline\");\n        assertThat(toJavaNames(\"IATA_airline\", true)).isEqualTo(\"iATAAirline\");\n    }\n\n    @Test\n    void endingWithUnderscore() {\n        assertThat(toJavaNames(\"name_\", false)).isEqualTo(\"Name\");\n        assertThat(toJavaNames(\"name_\", true)).isEqualTo(\"name\");\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/transformations/SimpleField_transformTest.java.SimpleField_transformTest", "name": "SimpleField_transformTest", "file_path": "src/test/java/net/datafaker/transformations/SimpleField_transformTest.java", "superclasses": "", "methods": ["[void]testTransformWithTransformFunction()", "[void]testTransformWithSupplier()", "[void]testTransformWithNullInputAndNoSupplier()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class SimpleField_transformTest {\n\n    @Test\n    void testTransformWithTransformFunction() {\n        Function<String, Integer> transform = Integer::parseInt;\n        SimpleField<String, Integer> field = new SimpleField<>(\"test\", transform);\n\n        assertEquals(42, field.transform(\"42\"));\n    }\n\n    @Test\n    void testTransformWithSupplier() {\n        Supplier<Integer> supplier = () -> 42;\n        SimpleField<String, Integer> field = new SimpleField<>(\"test\", supplier);\n\n        assertEquals(42, field.transform(null));\n    }\n\n    @Test\n    void testTransformWithNullInputAndNoSupplier() {\n        Function<String, Integer> transform = Integer::parseInt;\n        SimpleField<String, Integer> field = new SimpleField<>(\"test\", transform);\n\n        assertThrows(IllegalArgumentException.class, () -> field.transform(null));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/transformations/CompositeField_hashCodeTest.java.CompositeField_hashCodeTest", "name": "CompositeField_hashCodeTest", "file_path": "src/test/java/net/datafaker/transformations/CompositeField_hashCodeTest.java", "superclasses": "", "methods": ["[void]testHashCodeWithNonNullName()", "[void]testHashCodeWithNullName()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CompositeField_hashCodeTest {\n\n    @Test\n    public void testHashCodeWithNonNullName() {\n        CompositeField<AbstractProvider<?>, Object> compositeField = new CompositeField<>(\"testName\", null);\n        int expectedHashCode = \"testName\".hashCode();\n        assertEquals(expectedHashCode, compositeField.hashCode());\n    }\n\n    @Test\n    public void testHashCodeWithNullName() {\n        CompositeField<AbstractProvider<?>, Object> compositeField = new CompositeField<>(null, null);\n        int expectedHashCode = 0;\n        assertEquals(expectedHashCode, compositeField.hashCode());\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/transformations/YamlTransformer_applyTest.java.YamlTransformer_applyTest", "name": "YamlTransformer_applyTest", "file_path": "src/test/java/net/datafaker/transformations/YamlTransformer_applyTest.java", "superclasses": "", "methods": ["[void]testApplyWithEmptyFields()", "[void]testApplyWithNonEmptyFields()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class YamlTransformer_applyTest {\n\n    @Test\n    void testApplyWithEmptyFields() {\n        YamlTransformer<Object> transformer = new YamlTransformer<>();\n        Schema<Object, ?> schema = Schema.of();\n        CharSequence result = transformer.apply(new Object(), schema);\n        assertEquals(\"\", result);\n    }\n\n    @Test\n    void testApplyWithNonEmptyFields() {\n        YamlTransformer<Object> transformer = new YamlTransformer<>();\n        Field<Object, ?> field = new Field<>() {\n            @Override\n            public String getName() {\n                return \"testField\";\n            }\n\n            @Override\n            public Object transform(Object input) {\n                return \"testValue\";\n            }\n        };\n        Schema<Object, ?> schema = Schema.of(field);\n        CharSequence result = transformer.apply(new Object(), schema);\n        assertTrue(result.toString().contains(\"testField: testValue\"));\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/transformations/CsvTransformer_getStartStreamTest.java.CsvTransformer_getStartStreamTest", "name": "CsvTransformer_getStartStreamTest", "file_path": "src/test/java/net/datafaker/transformations/CsvTransformer_getStartStreamTest.java", "superclasses": "", "methods": ["[void]testGetStartStream()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class CsvTransformer_getStartStreamTest {\n\n    @Test\n    public void testGetStartStream() {\n        CsvTransformer<Object> transformer = CsvTransformer.builder().header(false).build();\n        String result = transformer.getStartStream(null);\n        assertEquals(\"\", result);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/transformations/JavaObjectTransformerTest.java.JavaObjectTransformerTest", "name": "JavaObjectTransformerTest", "file_path": "src/test/java/net/datafaker/transformations/JavaObjectTransformerTest.java", "superclasses": "AbstractFakerTest", "methods": ["[void]javaObjectTest()", "[void]javaRecordTest()", "[void]javaStreamingTest()", "[void]javaEmptyStreamTest()", "[void]javaCollectionTest()"], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    public static class Person {\n        private String firstName;\n        private String lastName;\n        private Date birthDate;\n        private Instant registrationDate;\n        private int id;\n    }", "definition": "    public static class Person", "class_docstring": "", "name": "Person", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "public static", "marker_annotations": [], "non_marker_annotations": ["public", "static"], "comments": [], "fields": [{"attribute_expression": "private String firstName;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "firstName", "syntax_pass": true}, {"attribute_expression": "private String lastName;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "lastName", "syntax_pass": true}, {"attribute_expression": "private Date birthDate;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Date", "name": "birthDate", "syntax_pass": true}, {"attribute_expression": "private Instant registrationDate;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Instant", "name": "registrationDate", "syntax_pass": true}, {"attribute_expression": "private int id;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "id", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": []}], "class_docstring": "", "original_string": "public class JavaObjectTransformerTest extends AbstractFakerTest {\n\n    public static class Person {\n        private String firstName;\n        private String lastName;\n        private Date birthDate;\n        private Instant registrationDate;\n        private int id;\n    }\n\n    public record Client(String firstName, String lastName, String phoneNumber, Instant registrationDate, int id) { }\n\n    @Test\n    void javaObjectTest() {\n        JavaObjectTransformer jTransformer = new JavaObjectTransformer();\n        Schema<Object, ?> schema = Schema.of(\n            field(\"firstName\", () -> faker.name().firstName()),\n            field(\"lastName\", () -> faker.name().lastName()),\n            field(\"birthDate\", () -> faker.date().birthday()),\n            field(\"registrationDate\", () -> faker.timeAndDate().past()),\n            field(\"id\", () -> faker.number().positive()));\n\n        Collection<Person> persons = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            Person person = (Person) jTransformer.apply(Person.class, schema);\n            assertThat(person.birthDate).isNotNull();\n            assertThat(person.lastName).isNotNull();\n            assertThat(person.firstName).isNotNull();\n            assertThat(person.registrationDate).isNotNull();\n            persons.add(person);\n        }\n        assertThat(persons).hasSize(10);\n    }\n\n    @Test\n    void javaRecordTest() {\n        JavaObjectTransformer jTransformer = new JavaObjectTransformer();\n        Schema<Object, ?> schema = Schema.of(\n            field(\"firstName\", () -> faker.name().firstName()),\n            field(\"lastName\", () -> faker.name().lastName()),\n            field(\"phoneNumber\", () -> faker.phoneNumber().phoneNumberInternational()),\n            field(\"registrationDate\", () -> faker.timeAndDate().past()),\n            field(\"id\", () -> faker.number().positive()));\n\n        Collection<Client> clients = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            Client client = (Client) jTransformer.apply(Client.class, schema);\n            assertThat(client.firstName()).isNotNull();\n            assertThat(client.lastName()).isNotNull();\n            assertThat(client.phoneNumber()).isNotNull();\n            assertThat(client.registrationDate()).isNotNull();\n            clients.add(client);\n        }\n        assertThat(clients).hasSize(10);\n    }\n\n    @Test\n    void javaStreamingTest() {\n        JavaObjectTransformer jTransformer = (new JavaObjectTransformer()).from(Person.class);\n        Schema<Object, ?> schema = Schema.of(\n            field(\"firstName\", () -> faker.name().firstName()),\n            field(\"lastName\", () -> faker.name().lastName()),\n            field(\"birthDate\", () -> faker.date().birthday()),\n            field(\"registrationDate\", () -> faker.timeAndDate().past())\n            );\n\n        Collection<Person> persons = new ArrayList<>();\n        jTransformer\n            .generateStream(schema, 10)\n            .map(object -> (Person) object)\n            .forEach(person -> {\n                assertThat(person.birthDate).isNotNull();\n                assertThat(person.lastName).isNotNull();\n                assertThat(person.firstName).isNotNull();\n                assertThat(person.registrationDate).isNotNull();\n                persons.add((Person)person);\n            });\n\n        assertThat(persons).hasSize(10);\n    }\n\n    @Test\n    void javaEmptyStreamTest() {\n        JavaObjectTransformer jTransformer = (new JavaObjectTransformer());\n        Schema<Object, ?> schema = Schema.of(\n            field(\"firstName\", () -> faker.name().firstName()),\n            field(\"lastName\", () -> faker.name().lastName()),\n            field(\"birthDate\", () -> faker.date().birthday()),\n            field(\"registrationDate\", () -> faker.timeAndDate().past())\n        );\n\n        assertThat(jTransformer.generateStream(schema, 10).count()).isEqualTo(0);\n    }\n\n    @Test\n    void javaCollectionTest() {\n        JavaObjectTransformer jTransformer = (new JavaObjectTransformer()).from(Person.class);\n        Schema<Object, ?> schema = Schema.of(\n            field(\"firstName\", () -> faker.name().firstName()),\n            field(\"lastName\", () -> faker.name().lastName()),\n            field(\"birthDate\", () -> faker.date().birthday()),\n            field(\"registrationDate\", () -> faker.timeAndDate().past())\n        );\n\n        Collection<Person> persons = new ArrayList<>();\n        jTransformer\n            .generate(schema, 10)\n            .stream()\n            .map(object -> (Person) object)\n            .forEach(person -> {\n                assertThat(person.birthDate).isNotNull();\n                assertThat(person.lastName).isNotNull();\n                assertThat(person.firstName).isNotNull();\n                assertThat(person.registrationDate).isNotNull();\n                persons.add((Person)person);\n            });\n\n        assertThat(persons).hasSize(10);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/test/java/net/datafaker/transformations/sql/SqlTransformer_generateStreamTest.java.SqlTransformer_generateStreamTest", "name": "SqlTransformer_generateStreamTest", "file_path": "src/test/java/net/datafaker/transformations/sql/SqlTransformer_generateStreamTest.java", "superclasses": "", "methods": ["[void]testGenerateStreamWithEmptySchema()", "[void]testGenerateStreamWithoutBatchMode()", "[void]testGenerateStreamWithBatchMode()"], "method_uris": [], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "public class SqlTransformer_generateStreamTest {\n\n    @Test\n    public void testGenerateStreamWithEmptySchema() {\n        SqlTransformer<Object> transformer = SqlTransformer.<Object>builder().build();\n        Schema<Object, ?> schema = Schema.of();\n        Stream<CharSequence> result = transformer.generateStream(schema, 10);\n        assertTrue(result.findAny().isEmpty());\n    }\n\n    @Test\n    public void testGenerateStreamWithoutBatchMode() {\n        SqlTransformer<Object> transformer = SqlTransformer.<Object>builder().build();\n        Schema<Object, ?> schema = Schema.of(new SimpleField<>(\"field1\", (Object o) -> o.toString()));\n        Stream<CharSequence> result = transformer.generateStream(schema, 2);\n        assertEquals(2, result.count());\n    }\n\n    @Test\n    public void testGenerateStreamWithBatchMode() {\n        SqlTransformer<Object> transformer = SqlTransformer.<Object>builder().batch(2).build();\n        Schema<Object, ?> schema = Schema.of(new SimpleField<>(\"field1\", (Object o) -> o.toString()));\n        Stream<CharSequence> result = transformer.generateStream(schema, 3);\n        assertEquals(2, result.count());\n    }\n}", "super_interfaces": [], "fields": []}]