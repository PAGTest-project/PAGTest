[{"uris": "src/test/java/io/cucumber/cucumberexpressions/CustomMatchers.java.CustomMatchers", "name": "CustomMatchers", "file_path": "src/test/java/io/cucumber/cucumberexpressions/CustomMatchers.java", "superclasses": "", "methods": ["[Matcher<Iterable<?>>]equalOrCloseTo(List<?>)"], "method_uris": ["src/test/java/io/cucumber/cucumberexpressions/CustomMatchers.java.CustomMatchers.[Matcher<Iterable<?>>]equalOrCloseTo(List<?>)"], "overrides": null, "attributes": [{"original_string": "    private static class EqualOrCloseTo<T> extends BaseMatcher<T> {\n        private final Object expectedValue;\n\n        public EqualOrCloseTo(Object expectedValue) {\n            this.expectedValue = expectedValue;\n        }\n\n        @Override\n        public boolean matches(Object actual) {\n            if(actual instanceof BigDecimal) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof BigInteger) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof Double || actual instanceof Float) {\n                return new IsCloseTo(((Double)this.expectedValue), 0.0001).matches(((Number)actual).doubleValue());\n            } else if(actual instanceof Byte) {\n                return new IsEqual(((Integer)this.expectedValue).byteValue()).matches(actual);\n            } else if(actual instanceof Short) {\n                return new IsEqual(((Integer)this.expectedValue).shortValue()).matches(actual);\n            } else if(actual instanceof Number || actual instanceof String || actual == null) {\n                return new IsEqual(this.expectedValue).matches(actual);\n            }\n            throw new RuntimeException(\"Unsupported type: \" + actual.getClass());\n        }\n\n        @Override\n        public void describeTo(Description description) {\n            description.appendValue(expectedValue);\n        }\n    }", "definition": "    private static class EqualOrCloseTo<T> extends BaseMatcher<T>", "class_docstring": "", "name": "EqualOrCloseTo", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final Object expectedValue;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Object", "name": "expectedValue", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        public EqualOrCloseTo(Object expectedValue) {\n            this.expectedValue = expectedValue;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "", "classes": []}, "name": "EqualOrCloseTo", "params": [{"name": "expectedValue", "type": "Object"}], "body": "                                                    {\n            this.expectedValue = expectedValue;\n        }", "signature": "public EqualOrCloseTo(Object expectedValue)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean matches(Object actual) {\n            if(actual instanceof BigDecimal) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof BigInteger) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof Double || actual instanceof Float) {\n                return new IsCloseTo(((Double)this.expectedValue), 0.0001).matches(((Number)actual).doubleValue());\n            } else if(actual instanceof Byte) {\n                return new IsEqual(((Integer)this.expectedValue).byteValue()).matches(actual);\n            } else if(actual instanceof Short) {\n                return new IsEqual(((Integer)this.expectedValue).shortValue()).matches(actual);\n            } else if(actual instanceof Number || actual instanceof String || actual == null) {\n                return new IsEqual(this.expectedValue).matches(actual);\n            }\n            throw new RuntimeException(\"Unsupported type: \" + actual.getClass());\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "matches", "params": [{"name": "actual", "type": "Object"}], "body": "                                              {\n            if(actual instanceof BigDecimal) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof BigInteger) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof Double || actual instanceof Float) {\n                return new IsCloseTo(((Double)this.expectedValue), 0.0001).matches(((Number)actual).doubleValue());\n            } else if(actual instanceof Byte) {\n                return new IsEqual(((Integer)this.expectedValue).byteValue()).matches(actual);\n            } else if(actual instanceof Short) {\n                return new IsEqual(((Integer)this.expectedValue).shortValue()).matches(actual);\n            } else if(actual instanceof Number || actual instanceof String || actual == null) {\n                return new IsEqual(this.expectedValue).matches(actual);\n            }\n            throw new RuntimeException(\"Unsupported type: \" + actual.getClass());\n        }", "signature": "@Override\n        public boolean matches(Object actual)"}, {"syntax_pass": true, "original_string": "        @Override\n        public void describeTo(Description description) {\n            description.appendValue(expectedValue);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "void", "classes": []}, "name": "describeTo", "params": [{"name": "description", "type": "Description"}], "body": "                                                        {\n            description.appendValue(expectedValue);\n        }", "signature": "@Override\n        public void describeTo(Description description)"}]}], "class_docstring": "", "original_string": "public class CustomMatchers {\n    public static Matcher<Iterable<?>> equalOrCloseTo(List<?> list) {\n        if (list == null || list.isEmpty()) return equalTo(list);\n        List<Matcher<?>> matchers = list.stream().map(EqualOrCloseTo::new).collect(Collectors.toList());\n        return new IsIterableContainingInOrder(matchers);\n    }\n\n    private static class EqualOrCloseTo<T> extends BaseMatcher<T> {\n        private final Object expectedValue;\n\n        public EqualOrCloseTo(Object expectedValue) {\n            this.expectedValue = expectedValue;\n        }\n\n        @Override\n        public boolean matches(Object actual) {\n            if(actual instanceof BigDecimal) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof BigInteger) {\n                return new IsEqual(this.expectedValue).matches(actual.toString());\n            } else if(actual instanceof Double || actual instanceof Float) {\n                return new IsCloseTo(((Double)this.expectedValue), 0.0001).matches(((Number)actual).doubleValue());\n            } else if(actual instanceof Byte) {\n                return new IsEqual(((Integer)this.expectedValue).byteValue()).matches(actual);\n            } else if(actual instanceof Short) {\n                return new IsEqual(((Integer)this.expectedValue).shortValue()).matches(actual);\n            } else if(actual instanceof Number || actual instanceof String || actual == null) {\n                return new IsEqual(this.expectedValue).matches(actual);\n            }\n            throw new RuntimeException(\"Unsupported type: \" + actual.getClass());\n        }\n\n        @Override\n        public void describeTo(Description description) {\n            description.appendValue(expectedValue);\n        }\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher", "name": "ParameterTypeMatcher", "file_path": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java", "superclasses": "", "methods": ["[]ParameterTypeMatcher(ParameterType<?>,Matcher,String)", "[boolean]isWhitespaceOrPunctuationOrSymbol(char)", "[boolean]advanceToAndFind(int)", "[boolean]groupHasWordBoundaryOnBothSides()", "[boolean]groupHasLeftWordBoundary()", "[boolean]groupHasRightWordBoundary()", "[int]start()", "[String]group()", "[int]compareTo(ParameterTypeMatcher)", "[ParameterType<?>]getParameterType()", "[String]toString()"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[]ParameterTypeMatcher(ParameterType<?>,Matcher,String)", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[boolean]isWhitespaceOrPunctuationOrSymbol(char)", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[boolean]advanceToAndFind(int)", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[boolean]groupHasWordBoundaryOnBothSides()", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[boolean]groupHasLeftWordBoundary()", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[boolean]groupHasRightWordBoundary()", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[int]start()", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[String]group()", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[int]compareTo(ParameterTypeMatcher)", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[ParameterType<?>]getParameterType()", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeMatcher.java.ParameterTypeMatcher.[String]toString()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class ParameterTypeMatcher implements Comparable<ParameterTypeMatcher> {\n    private final ParameterType<?> parameterType;\n    private final Matcher matcher;\n    private final String text;\n\n    ParameterTypeMatcher(ParameterType<?> parameterType, Matcher matcher, String text) {\n        this.parameterType = parameterType;\n        this.matcher = matcher;\n        this.text = text;\n    }\n\n    private static boolean isWhitespaceOrPunctuationOrSymbol(char c) {\n        return Pattern.matches(\"[\\\\p{Z}\\\\p{P}\\\\p{S}]\", new String(new char[] { c }));\n    }\n\n    boolean advanceToAndFind(int newMatchPos) {\n        // Unlike js, ruby and go, the matcher is stateful\n        // so we can't use the immutable semantics.\n        matcher.region(newMatchPos, text.length());\n        while (matcher.find()) {\n            if (group().isEmpty()) {\n                continue;\n            }\n            if (groupHasWordBoundaryOnBothSides()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean groupHasWordBoundaryOnBothSides() {\n        return groupHasLeftWordBoundary() && groupHasRightWordBoundary();\n    }\n\n    private boolean groupHasLeftWordBoundary() {\n        if (matcher.start() > 0) {\n            char before = text.charAt(matcher.start() - 1);\n            return isWhitespaceOrPunctuationOrSymbol(before);\n        }\n        return true;\n    }\n\n    private boolean groupHasRightWordBoundary() {\n        if (matcher.end() < text.length()) {\n            char after = text.charAt(matcher.end());\n            return isWhitespaceOrPunctuationOrSymbol(after);\n        }\n        return true;\n    }\n\n    int start() {\n        return matcher.start();\n    }\n\n    String group() {\n        return matcher.group();\n    }\n\n    @Override\n    public int compareTo(ParameterTypeMatcher o) {\n        int posComparison = Integer.compare(start(), o.start());\n        if (posComparison != 0) return posComparison;\n        int lengthComparison = Integer.compare(o.group().length(), group().length());\n        if (lengthComparison != 0) return lengthComparison;\n        int weightComparison = Integer.compare(o.parameterType.weight(), parameterType.weight());\n        if (weightComparison != 0) return weightComparison;\n        return 0;\n    }\n\n    ParameterType<?> getParameterType() {\n        return parameterType;\n    }\n\n    public String toString() {\n        return parameterType.getType().toString();\n    }\n}", "super_interfaces": ["Comparable<ParameterTypeMatcher>"], "fields": [{"attribute_expression": "private final ParameterType<?> parameterType;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterType<?>", "name": "parameterType", "syntax_pass": true}, {"attribute_expression": "private final Matcher matcher;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Matcher", "name": "matcher", "syntax_pass": true}, {"attribute_expression": "private final String text;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "text", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java.UndefinedParameterTypeException", "name": "UndefinedParameterTypeException", "file_path": "src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java", "superclasses": "CucumberExpressionException", "methods": ["[]UndefinedParameterTypeException(String,String)", "[String]getUndefinedParameterTypeName()", "[CucumberExpressionException]createUndefinedParameterType(Node,String,String)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java.UndefinedParameterTypeException.[]UndefinedParameterTypeException(String,String)", "src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java.UndefinedParameterTypeException.[String]getUndefinedParameterTypeName()", "src/main/java/io/cucumber/cucumberexpressions/UndefinedParameterTypeException.java.UndefinedParameterTypeException.[CucumberExpressionException]createUndefinedParameterType(Node,String,String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@API(status = API.Status.STABLE)\npublic final class UndefinedParameterTypeException extends CucumberExpressionException {\n    private final String undefinedParameterTypeName;\n\n    UndefinedParameterTypeException(String message, String undefinedParameterTypeName) {\n        super(message);\n        this.undefinedParameterTypeName = undefinedParameterTypeName;\n    }\n\n    public String getUndefinedParameterTypeName() {\n        return undefinedParameterTypeName;\n    }\n\n    static CucumberExpressionException createUndefinedParameterType(Node node, String expression, String undefinedParameterTypeName) {\n        return new UndefinedParameterTypeException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"Undefined parameter type '\" +undefinedParameterTypeName+ \"'\",\n                \"Please register a ParameterType for '\"+undefinedParameterTypeName+\"'\"), undefinedParameterTypeName);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final String undefinedParameterTypeName;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "undefinedParameterTypeName", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType", "name": "ParameterType", "file_path": "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java", "superclasses": "", "methods": ["[void]checkParameterTypeName(String)", "[boolean]isValidParameterTypeName(String)", "[ParameterType<Object>]createAnonymousParameterType(String)", "[ParameterType<E>]fromEnum(Class<E>)", "[]ParameterType(String,List<String>,Type,CaptureGroupTransformer<T>,boolean,boolean,boolean,boolean)", "[]ParameterType(String,List<String>,Type,CaptureGroupTransformer<T>,boolean,boolean,boolean)", "[]ParameterType(String,List<String>,Type,CaptureGroupTransformer<T>,boolean,boolean)", "[]ParameterType(String,List<String>,Class<T>,CaptureGroupTransformer<T>,boolean,boolean)", "[]ParameterType(String,String,Class<T>,CaptureGroupTransformer<T>,boolean,boolean)", "[]ParameterType(String,List<String>,Class<T>,CaptureGroupTransformer<T>)", "[]ParameterType(String,String,Class<T>,CaptureGroupTransformer<T>)", "[]ParameterType(String,List<String>,Type,Transformer<T>,boolean,boolean,boolean)", "[]ParameterType(String,List<String>,Type,Transformer<T>,boolean,boolean)", "[]ParameterType(String,List<String>,Class<T>,Transformer<T>,boolean,boolean,boolean)", "[]ParameterType(String,List<String>,Class<T>,Transformer<T>,boolean,boolean)", "[]ParameterType(String,String,Class<T>,Transformer<T>,boolean,boolean,boolean)", "[]ParameterType(String,String,Class<T>,Transformer<T>,boolean,boolean)", "[]ParameterType(String,List<String>,Class<T>,Transformer<T>)", "[]ParameterType(String,String,Class<T>,Transformer<T>)", "[String]getName()", "[Type]getType()", "[List<String>]getRegexps()", "[boolean]preferForRegexpMatch()", "[boolean]useForSnippets()", "[boolean]isAnonymous()", "[boolean]useRegexpMatchAsStrongTypeHint()", "[ParameterType<Object>]deAnonymize(Type,Transformer<Object>)", "[T]transform(List<String>)", "[int]compareTo(ParameterType<?>)", "[int]weight()"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[void]checkParameterTypeName(String)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[boolean]isValidParameterTypeName(String)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[ParameterType<Object>]createAnonymousParameterType(String)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[ParameterType<E>]fromEnum(Class<E>)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Type,CaptureGroupTransformer<T>,boolean,boolean,boolean,boolean)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Type,CaptureGroupTransformer<T>,boolean,boolean,boolean)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Type,CaptureGroupTransformer<T>,boolean,boolean)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Class<T>,CaptureGroupTransformer<T>,boolean,boolean)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,String,Class<T>,CaptureGroupTransformer<T>,boolean,boolean)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Class<T>,CaptureGroupTransformer<T>)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,String,Class<T>,CaptureGroupTransformer<T>)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Type,Transformer<T>,boolean,boolean,boolean)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Type,Transformer<T>,boolean,boolean)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Class<T>,Transformer<T>,boolean,boolean,boolean)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Class<T>,Transformer<T>,boolean,boolean)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,String,Class<T>,Transformer<T>,boolean,boolean,boolean)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,String,Class<T>,Transformer<T>,boolean,boolean)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,List<String>,Class<T>,Transformer<T>)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[]ParameterType(String,String,Class<T>,Transformer<T>)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[String]getName()", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[Type]getType()", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[List<String>]getRegexps()", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[boolean]preferForRegexpMatch()", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[boolean]useForSnippets()", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[boolean]isAnonymous()", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[boolean]useRegexpMatchAsStrongTypeHint()", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[ParameterType<Object>]deAnonymize(Type,Transformer<Object>)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[T]transform(List<String>)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[int]compareTo(ParameterType<?>)", "src/main/java/io/cucumber/cucumberexpressions/ParameterType.java.ParameterType.[int]weight()"], "overrides": null, "attributes": [{"original_string": "    private static final class TransformerAdaptor<T> implements CaptureGroupTransformer<T> {\n\n        private final Transformer<T> transformer;\n\n        private TransformerAdaptor(Transformer<T> transformer) {\n            if (transformer == null)\n                throw new NullPointerException(\"transformer cannot be null\");\n            this.transformer = transformer;\n        }\n\n        @Override\n        public T transform(String[] args) throws Throwable {\n            return transformer.transform(args[0]);\n        }\n\n    }", "definition": "    private static final class TransformerAdaptor<T> implements CaptureGroupTransformer<T>", "class_docstring": "", "name": "TransformerAdaptor", "super_interfaces": ["CaptureGroupTransformer<T>"], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Transformer<T> transformer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Transformer<T>", "name": "transformer", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private TransformerAdaptor(Transformer<T> transformer) {\n            if (transformer == null)\n                throw new NullPointerException(\"transformer cannot be null\");\n            this.transformer = transformer;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "TransformerAdaptor", "params": [{"name": "transformer", "type": "Transformer<T>"}], "body": "                                                               {\n            if (transformer == null)\n                throw new NullPointerException(\"transformer cannot be null\");\n            this.transformer = transformer;\n        }", "signature": "private TransformerAdaptor(Transformer<T> transformer)"}, {"syntax_pass": true, "original_string": "        @Override\n        public T transform(String[] args) throws Throwable {\n            return transformer.transform(args[0]);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "T", "classes": []}, "name": "transform", "params": [{"name": "args", "type": "String[]"}], "body": "                                                           {\n            return transformer.transform(args[0]);\n        }", "signature": "@Override\n        public T transform(String[] args)"}]}], "class_docstring": "", "original_string": "@API(status = API.Status.STABLE)\npublic final class ParameterType<T> implements Comparable<ParameterType<?>> {\n    @SuppressWarnings(\"RegExpRedundantEscape\") // Android can't parse unescaped braces\n    private static final Pattern ILLEGAL_PARAMETER_NAME_PATTERN = Pattern.compile(\"([{}()\\\\\\\\/])\");\n    private static final Pattern UNESCAPE_PATTERN = Pattern.compile(\"(\\\\\\\\([\\\\[$.|?*+\\\\]]))\");\n\n    private final String name;\n    private final Type type;\n    private final List<String> regexps;\n    private final boolean preferForRegexpMatch;\n    private final boolean useForSnippets;\n    private final CaptureGroupTransformer<T> transformer;\n    private final boolean anonymous;\n    private final boolean useRegexpMatchAsStrongTypeHint;\n\n    static void checkParameterTypeName(String name) {\n        if (!isValidParameterTypeName(name)) {\n            throw CucumberExpressionException.createInvalidParameterTypeName(name);\n        }\n    }\n\n    static boolean isValidParameterTypeName(String name) {\n        String unescapedTypeName = UNESCAPE_PATTERN.matcher(name).replaceAll(\"$2\");\n        Matcher matcher = ILLEGAL_PARAMETER_NAME_PATTERN.matcher(unescapedTypeName);\n        return !matcher.find();\n    }\n\n    static ParameterType<Object> createAnonymousParameterType(String regexp) {\n        return new ParameterType<>(\"\", singletonList(regexp), Object.class, new CaptureGroupTransformer<Object>() {\n\n            public Object transform(String[] arg) {\n                throw new UnsupportedOperationException(\"Anonymous transform must be deanonymized before use\");\n            }\n        }, false, true, false, true);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static <E extends Enum> ParameterType<E> fromEnum(final Class<E> enumClass) {\n        Enum[] enumConstants = enumClass.getEnumConstants();\n        StringBuilder regexpBuilder = new StringBuilder();\n        for (int i = 0; i < enumConstants.length; i++) {\n            if (i > 0)\n                regexpBuilder.append(\"|\");\n            regexpBuilder.append(enumConstants[i].name());\n        }\n        return new ParameterType<>(\n                enumClass.getSimpleName(),\n                regexpBuilder.toString(),\n                enumClass,\n                (String arg) -> (E) Enum.valueOf(enumClass, arg)\n        );\n    }\n\n    private ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint,\n            boolean anonymous) {\n        if (regexps == null)\n            throw new NullPointerException(\"regexps cannot be null\");\n        if (type == null)\n            throw new NullPointerException(\"type cannot be null\");\n        if (transformer == null)\n            throw new NullPointerException(\"transformer cannot be null\");\n        if (name != null)\n            checkParameterTypeName(name);\n        this.name = name;\n        this.regexps = regexps;\n        this.type = type;\n        this.transformer = transformer;\n        this.useForSnippets = useForSnippets;\n        this.preferForRegexpMatch = preferForRegexpMatch;\n        this.anonymous = anonymous;\n        this.useRegexpMatchAsStrongTypeHint = useRegexpMatchAsStrongTypeHint;\n    }\n\n    public ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, regexps, type, transformer, useForSnippets, preferForRegexpMatch, useRegexpMatchAsStrongTypeHint,\n                false);\n    }\n\n    public ParameterType(String name, List<String> regexps, Type type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        // Unless explicitly set useRegexpMatchAsStrongTypeHint is true.\n        //\n        // Reasoning:\n        // 1. Pure cucumber expression users will not notice this in either scenario.\n        // 2. Pure regular expression users will benefit because BuiltInParameterTransformer can now seamlessly\n        //    transform any captured values. (For all built in types useRegexpMatchAsStrongTypeHint is explicitly set to\n        //    false.)\n        // 2. Regular expression users that define a default transformer have little need to define parameter types. The\n        //    default transformer should be sufficiently powerful to meet their needs and will often allow users to add\n        //    custom creation methods e.g. Jacksons @JsonFactory.\n        // 3. Users who mix regular and cucumber expressions may run into conflicts when a registered cucumber expression\n        //    and unregistered happens to collide. However this was the situation before this flag was added.\n        // 4. Regular expression users who define custom parameter types do so with the expectation that the parameter\n        //    will be matched. Subverting this expectation when the method signature does not match may result in a\n        //    parameter transformer that is unable to convert to the desired type. Leaving the user puzzled as to why\n        //    his transform was ignored.\n        this(name, regexps, type, transformer, useForSnippets, preferForRegexpMatch, true);\n    }\n\n    public ParameterType(String name, List<String> regexps, Class<T> type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch);\n    }\n\n    public ParameterType(String name, String regexp, Class<T> type, CaptureGroupTransformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch);\n    }\n\n    public ParameterType(String name, List<String> regexps, Class<T> type, CaptureGroupTransformer<T> transformer) {\n        this(name, regexps, type, transformer, true, false);\n    }\n\n    public ParameterType(String name, String regexp, Class<T> type, CaptureGroupTransformer<T> transformer) {\n        this(name, singletonList(regexp), type, transformer, true, false);\n    }\n\n    public ParameterType(String name, List<String> regexps, Type type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, regexps, type, new TransformerAdaptor<>(transformer), useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }\n\n    public ParameterType(String name, List<String> regexps, Type type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, regexps, type, new TransformerAdaptor<>(transformer), useForSnippets, preferForRegexpMatch);\n    }\n\n    public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }\n\n    public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer,\n            boolean useForSnippets, boolean preferForRegexpMatch) {\n        this(name, regexps, (Type) type, transformer, useForSnippets, preferForRegexpMatch);\n    }\n\n    public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer, boolean useForSnippets,\n            boolean preferForRegexpMatch, boolean useRegexpMatchAsStrongTypeHint) {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch,\n                useRegexpMatchAsStrongTypeHint);\n    }\n\n    public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer, boolean useForSnippets,\n            boolean preferForRegexpMatch) {\n        this(name, singletonList(regexp), type, transformer, useForSnippets, preferForRegexpMatch);\n    }\n\n    public ParameterType(String name, List<String> regexps, Class<T> type, Transformer<T> transformer) {\n        this(name, regexps, type, transformer, true, false);\n    }\n\n    public ParameterType(String name, String regexp, Class<T> type, Transformer<T> transformer) {\n        this(name, singletonList(regexp), type, transformer, true, false);\n    }\n\n    /**\n     * This is used in the type name in typed expressions\n     *\n     * @return human readable type name\n     */\n    public String getName() {\n        return name;\n    }\n\n    /**\n     * Returns the type of the parameter type - typically the type\n     * the transform transforms to. This can be used in conjunction with\n     * GeneratedExpression (snippets) to generate snippets for statically typed\n     * languages. Not used for anything else.\n     *\n     * @return the type of the parameter type\n     */\n    public Type getType() {\n        return type;\n    }\n\n    public List<String> getRegexps() {\n        return regexps;\n    }\n\n    /**\n     * Indicates whether or not this is a preferential parameter type when matching text\n     * against a {@link RegularExpression}. In case there are multiple parameter types\n     * with a regexp identical to the capture group's regexp, a preferential parameter type will\n     * win. If there are more than 1 preferential ones, an error will be thrown.\n     *\n     * @return true if this is a preferential type\n     */\n    public boolean preferForRegexpMatch() {\n        return preferForRegexpMatch;\n    }\n\n    /**\n     * Indicates whether or not this is a parameter type should be used for generating\n     * {@link GeneratedExpression}s from text. Typically, parameter types with greedy regexps\n     * should return false.\n     *\n     * @return true is this parameter type is used for expression generation\n     */\n    public boolean useForSnippets() {\n        return useForSnippets;\n    }\n\n    boolean isAnonymous() {\n        return anonymous;\n    }\n\n    /**\n     * Indicates whether or not this parameter provides a strong type hint when considering a\n     * regular expression match. If so, the type hint provided by the method arguments  will be\n     * ignored. If not, when both type hints are in agreement, this parameter types transformer\n     * will be used. Otherwise parameter transformation for a regular expression match will be\n     * handled by {@link ParameterTypeRegistry#getDefaultParameterTransformer()}.\n     *\n     * @return true if this parameter type provides a type hint when considering a regular\n     * expression match\n     */\n    public boolean useRegexpMatchAsStrongTypeHint() {\n        return useRegexpMatchAsStrongTypeHint;\n    }\n\n    ParameterType<Object> deAnonymize(Type type, Transformer<Object> transformer) {\n        return new ParameterType<>(\"anonymous\", regexps, type, new TransformerAdaptor<>(transformer), useForSnippets,\n                preferForRegexpMatch, useRegexpMatchAsStrongTypeHint, anonymous);\n    }\n\n    T transform(List<String> groupValues) {\n        if (transformer instanceof TransformerAdaptor) {\n            if (groupValues.size() > 1) {\n                if (isAnonymous()) {\n                    throw new CucumberExpressionException(String.format(\"\" +\n                            \"Anonymous ParameterType has multiple capture groups %s. \" +\n                            \"You can only use a single capture group in an anonymous ParameterType.\", regexps));\n                }\n                throw new CucumberExpressionException(String.format(\"\" +\n                        \"ParameterType {%s} was registered with a Transformer but has multiple capture groups %s. \" +\n                        \"Did you mean to use a CaptureGroupTransformer?\", name, regexps));\n            }\n        }\n\n        try {\n            String[] groupValueArray = groupValues.toArray(new String[0]);\n            return transformer.transform(groupValueArray);\n        } catch (CucumberExpressionException e) {\n            throw e;\n        } catch (Throwable throwable) {\n            throw new CucumberExpressionException(\n                    String.format(\"ParameterType {%s} failed to transform %s to %s\", name, groupValues, type),\n                    throwable);\n        }\n    }\n\n    @Override\n    public int compareTo(ParameterType<?> o) {\n        if (preferForRegexpMatch() && !o.preferForRegexpMatch())\n            return -1;\n        if (o.preferForRegexpMatch() && !preferForRegexpMatch())\n            return 1;\n        String name = getName() != null ? getName() : \"\";\n        String otherName = o.getName() != null ? o.getName() : \"\";\n        return name.compareTo(otherName);\n    }\n\n    public int weight() {\n        if (this.type.equals(Integer.class) || this.type.equals(Integer.TYPE)) {\n            return 1000;\n        }\n        return 0;\n    }\n\n    private static final class TransformerAdaptor<T> implements CaptureGroupTransformer<T> {\n\n        private final Transformer<T> transformer;\n\n        private TransformerAdaptor(Transformer<T> transformer) {\n            if (transformer == null)\n                throw new NullPointerException(\"transformer cannot be null\");\n            this.transformer = transformer;\n        }\n\n        @Override\n        public T transform(String[] args) throws Throwable {\n            return transformer.transform(args[0]);\n        }\n\n    }\n\n}", "super_interfaces": ["Comparable<ParameterType<?>>"], "fields": [{"attribute_expression": "@SuppressWarnings(\"RegExpRedundantEscape\") // Android can't parse unescaped braces\n    private static final Pattern ILLEGAL_PARAMETER_NAME_PATTERN = Pattern.compile(\"([{}()\\\\\\\\/])\");", "docstring": "", "modifiers": "@SuppressWarnings(\"RegExpRedundantEscape\") // Android can't parse unescaped braces\n    private static final", "marker_annotations": [], "non_marker_annotations": ["@SuppressWarnings(\"RegExpRedundantEscape\")", "private", "static", "final"], "comments": ["// Android can't parse unescaped braces"], "type": "Pattern", "name": "ILLEGAL_PARAMETER_NAME_PATTERN = Pattern.compile(\"([{}()\\\\\\\\/])\")", "syntax_pass": true}, {"attribute_expression": "private static final Pattern UNESCAPE_PATTERN = Pattern.compile(\"(\\\\\\\\([\\\\[$.|?*+\\\\]]))\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "UNESCAPE_PATTERN = Pattern.compile(\"(\\\\\\\\([\\\\[$.|?*+\\\\]]))\")", "syntax_pass": true}, {"attribute_expression": "private final String name;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "name", "syntax_pass": true}, {"attribute_expression": "private final Type type;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}, {"attribute_expression": "private final List<String> regexps;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<String>", "name": "regexps", "syntax_pass": true}, {"attribute_expression": "private final boolean preferForRegexpMatch;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "preferForRegexpMatch", "syntax_pass": true}, {"attribute_expression": "private final boolean useForSnippets;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "useForSnippets", "syntax_pass": true}, {"attribute_expression": "private final CaptureGroupTransformer<T> transformer;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "CaptureGroupTransformer<T>", "name": "transformer", "syntax_pass": true}, {"attribute_expression": "private final boolean anonymous;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "anonymous", "syntax_pass": true}, {"attribute_expression": "private final boolean useRegexpMatchAsStrongTypeHint;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "boolean", "name": "useRegexpMatchAsStrongTypeHint", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/RegexpUtils.java.RegexpUtils", "name": "RegexpUtils", "file_path": "src/main/java/io/cucumber/cucumberexpressions/RegexpUtils.java", "superclasses": "", "methods": ["[String]escapeRegex(String)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/RegexpUtils.java.RegexpUtils.[String]escapeRegex(String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "class RegexpUtils {\n    /**\n     * List of characters to be escaped.\n     * The last char is '}' with index 125, so we need only 126 characters.\n     */\n    private static final boolean[] CHAR_TO_ESCAPE = new boolean[126];\n\n    static {\n        CHAR_TO_ESCAPE['^'] = true;\n        CHAR_TO_ESCAPE['$'] = true;\n        CHAR_TO_ESCAPE['['] = true;\n        CHAR_TO_ESCAPE[']'] = true;\n        CHAR_TO_ESCAPE['('] = true;\n        CHAR_TO_ESCAPE[')'] = true;\n        CHAR_TO_ESCAPE['{'] = true;\n        CHAR_TO_ESCAPE['}'] = true;\n        CHAR_TO_ESCAPE['.'] = true;\n        CHAR_TO_ESCAPE['|'] = true;\n        CHAR_TO_ESCAPE['?'] = true;\n        CHAR_TO_ESCAPE['*'] = true;\n        CHAR_TO_ESCAPE['+'] = true;\n        CHAR_TO_ESCAPE['\\\\'] = true;\n    }\n\n    /**\n     * Escapes the regexp characters (the ones from \"^$(){}[].+*?\\\")\n     * from the given text, so that they are not considered as regexp\n     * characters.\n     *\n     * @param text the non-null input text\n     * @return the input text with escaped regexp characters\n     */\n    public static String escapeRegex(String text) {\n        /*\n        Note on performance: this code has been benchmarked for\n        escaping frequencies of 100%, 50%, 20%, 10%, 1%, 0.1%.\n        Amongst 4 other variants (including Pattern matching),\n        this variant is the faster on all escaping frequencies.\n        */\n        int length = text.length();\n        StringBuilder sb = null; // lazy initialization\n        int blockStart = 0;\n        int maxChar = CHAR_TO_ESCAPE.length;\n        for (int i = 0; i < length; i++) {\n            char currentChar = text.charAt(i);\n            if (currentChar < maxChar && CHAR_TO_ESCAPE[currentChar]) {\n                if (sb == null) {\n                    sb = new StringBuilder(length * 2);\n                }\n                if (blockStart < i) {\n                    // flush previous block\n                    sb.append(text, blockStart, i);\n                }\n                sb.append('\\\\');\n                sb.append(currentChar);\n                blockStart = i + 1;\n            }\n        }\n        if (sb != null) {\n            // finalizing character escaping\n            if (blockStart < length) {\n                // flush remaining characters\n                sb.append(text, blockStart, length);\n            }\n            return sb.toString();\n        }\n        return text;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final boolean[] CHAR_TO_ESCAPE = new boolean[126];", "docstring": "\nList of characters to be escaped.\nThe last char is '}' with index 125, so we need only 126 characters.\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "boolean[]", "name": "CHAR_TO_ESCAPE = new boolean[126]", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group", "name": "Group", "file_path": "src/main/java/io/cucumber/cucumberexpressions/Group.java", "superclasses": "", "methods": ["[]Group(String,int,int,List<Group>)", "[String]getValue()", "[int]getStart()", "[int]getEnd()", "[List<Group>]getChildren()", "[List<String>]getValues()", "[Collection<Group>]parse(Pattern)", "[List<Group>]toGroups(List<GroupBuilder>)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[]Group(String,int,int,List<Group>)", "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[String]getValue()", "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[int]getStart()", "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[int]getEnd()", "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[List<Group>]getChildren()", "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[List<String>]getValues()", "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[Collection<Group>]parse(Pattern)", "src/main/java/io/cucumber/cucumberexpressions/Group.java.Group.[List<Group>]toGroups(List<GroupBuilder>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@API(status = API.Status.STABLE)\npublic class Group {\n    private final List<Group> children;\n    private final String value;\n    private final int start;\n    private final int end;\n\n    Group(String value, int start, int end, List<Group> children) {\n        this.value = value;\n        this.start = start;\n        this.end = end;\n        this.children = children;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public int getStart() {\n        return start;\n    }\n\n    public int getEnd() {\n        return end;\n    }\n\n    public List<Group> getChildren() {\n        return children;\n    }\n\n    public List<String> getValues() {\n        List<Group> groups = getChildren().isEmpty() ? singletonList(this) : getChildren();\n        return groups.stream()\n                .map(Group::getValue)\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * Parse a {@link Pattern} into collection of {@link Group}s\n     * \n     * @param expression the expression to decompose\n     * @return A collection of {@link Group}s, possibly empty but never\n     *         <code>null</code>\n     */\n    public static Collection<Group> parse(Pattern expression) {\n        GroupBuilder builder = TreeRegexp.createGroupBuilder(expression);\n        return toGroups(builder.getChildren());\n    }\n\n    private static List<Group> toGroups(List<GroupBuilder> children) {\n        List<Group> list = new ArrayList<>();\n        if (children != null) {\n            for (GroupBuilder child : children) {\n                list.add(new Group(child.getSource(), child.getStartIndex(), child.getEndIndex(),\n                        toGroups(child.getChildren())));\n            }\n        }\n        return list;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final List<Group> children;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Group>", "name": "children", "syntax_pass": true}, {"attribute_expression": "private final String value;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "value", "syntax_pass": true}, {"attribute_expression": "private final int start;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "start", "syntax_pass": true}, {"attribute_expression": "private final int end;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "end", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp", "name": "TreeRegexp", "file_path": "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java", "superclasses": "", "methods": ["[]TreeRegexp(String)", "[]TreeRegexp(Pattern)", "[GroupBuilder]createGroupBuilder(Pattern)", "[boolean]isNonCapturingGroup(String,int)", "[Pattern]pattern()", "[Group]match(CharSequence)", "[GroupBuilder]getGroupBuilder()"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp.[]TreeRegexp(String)", "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp.[]TreeRegexp(Pattern)", "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp.[GroupBuilder]createGroupBuilder(Pattern)", "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp.[boolean]isNonCapturingGroup(String,int)", "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp.[Pattern]pattern()", "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp.[Group]match(CharSequence)", "src/main/java/io/cucumber/cucumberexpressions/TreeRegexp.java.TreeRegexp.[GroupBuilder]getGroupBuilder()"], "overrides": null, "attributes": [], "class_docstring": "\nTreeRegexp represents matches as a tree of {@link Group}\nreflecting the nested structure of capture groups in the original\nregexp.\n", "original_string": "final class TreeRegexp {\n    private final Pattern pattern;\n    private final GroupBuilder groupBuilder;\n\n    TreeRegexp(String regexp) {\n        this(PatternCompilerProvider.getCompiler().compile(regexp, Pattern.UNICODE_CHARACTER_CLASS));\n    }\n\n    TreeRegexp(Pattern pattern) {\n        this.pattern = pattern;\n        this.groupBuilder = createGroupBuilder(pattern);\n    }\n\n    static GroupBuilder createGroupBuilder(Pattern pattern) {\n        String source = pattern.pattern();\n        Deque<GroupBuilder> stack = new ArrayDeque<>(singleton(new GroupBuilder(0)));\n        boolean escaping = false;\n        boolean charClass = false;\n\n        for (int i = 0; i < source.length(); i++) {\n            char c = source.charAt(i);\n            if (c == '[' && !escaping) {\n                charClass = true;\n            } else if (c == ']' && !escaping) {\n                charClass = false;\n            } else if (c == '(' && !escaping && !charClass) {\n                boolean nonCapturing = isNonCapturingGroup(source, i);\n                GroupBuilder groupBuilder = new GroupBuilder(i);\n                if (nonCapturing) {\n                    groupBuilder.setNonCapturing();\n                }\n                stack.push(groupBuilder);\n            } else if (c == ')' && !escaping && !charClass) {\n                GroupBuilder gb = stack.pop();\n                if (gb.isCapturing()) {\n                    gb.setSource(source.substring(gb.getStartIndex() + 1, i));\n                    stack.peek().add(gb);\n                } else {\n                    gb.moveChildrenTo(stack.peek());\n                }\n                gb.setEndIndex(i);\n            }\n            escaping = c == '\\\\' && !escaping;\n        }\n        return stack.pop();\n    }\n\n    private static boolean isNonCapturingGroup(String source, int i) {\n        // Regex is valid. Bounds check not required.\n        if (source.charAt(i+1) != '?') {\n            // (X)\n            return false;\n        }\n        if (source.charAt(i+2) != '<') {\n            // (?:X)\n            // (?idmsuxU-idmsuxU)\n            // (?idmsux-idmsux:X)\n            // (?=X)\n            // (?!X)\n            // (?>X)\n            return true;\n        }\n        // (?<=X) or (?<!X) else (?<name>X)\n        return source.charAt(i + 3) == '=' || source.charAt(i + 3) == '!';\n    }\n\n    Pattern pattern() {\n        return pattern;\n    }\n\n    Group match(CharSequence s) {\n        final Matcher matcher = pattern.matcher(s);\n        if (!matcher.matches())\n            return null;\n        return groupBuilder.build(matcher, IntStream.rangeClosed(0, matcher.groupCount()).iterator());\n    }\n\n    public GroupBuilder getGroupBuilder() {\n        return groupBuilder;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Pattern pattern;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Pattern", "name": "pattern", "syntax_pass": true}, {"attribute_expression": "private final GroupBuilder groupBuilder;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "GroupBuilder", "name": "groupBuilder", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/DuplicateTypeNameException.java.DuplicateTypeNameException", "name": "DuplicateTypeNameException", "file_path": "src/main/java/io/cucumber/cucumberexpressions/DuplicateTypeNameException.java", "superclasses": "CucumberExpressionException", "methods": ["[]DuplicateTypeNameException(String)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/DuplicateTypeNameException.java.DuplicateTypeNameException.[]DuplicateTypeNameException(String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@API(status = API.Status.STABLE)\npublic class DuplicateTypeNameException extends CucumberExpressionException {\n    DuplicateTypeNameException(String message) {\n        super(message);\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument", "name": "Argument", "file_path": "src/main/java/io/cucumber/cucumberexpressions/Argument.java", "superclasses": "", "methods": ["[List<Argument<?>>]build(Group,List<ParameterType<?>>)", "[]Argument(Group,ParameterType<T>)", "[Group]getGroup()", "[T]getValue()", "[Type]getType()", "[ParameterType<T>]getParameterType()"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument.[List<Argument<?>>]build(Group,List<ParameterType<?>>)", "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument.[]Argument(Group,ParameterType<T>)", "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument.[Group]getGroup()", "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument.[T]getValue()", "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument.[Type]getType()", "src/main/java/io/cucumber/cucumberexpressions/Argument.java.Argument.[ParameterType<T>]getParameterType()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@API(status = API.Status.STABLE)\npublic final class Argument<T> {\n    private final ParameterType<T> parameterType;\n    private final Group group;\n\n    static List<Argument<?>> build(Group group, List<ParameterType<?>> parameterTypes) {\n        List<Group> argGroups = group.getChildren();\n\n        if (argGroups.size() != parameterTypes.size()) {\n            // This requires regex injection through a Cucumber expression.\n            // Regex injection should be be possible any more.\n            throw new IllegalArgumentException(String.format(\"Group has %s capture groups, but there were %s parameter types\", argGroups.size(), parameterTypes.size()));\n        }\n        List<Argument<?>> args = new ArrayList<>(argGroups.size());\n        for (int i = 0; i < parameterTypes.size(); i++) {\n            Group argGroup = argGroups.get(i);\n            ParameterType<?> parameterType = parameterTypes.get(i);\n            args.add(new Argument<>(argGroup, parameterType));\n        }\n\n        return args;\n    }\n\n    private Argument(Group group, ParameterType<T> parameterType) {\n        this.group = group;\n        this.parameterType = parameterType;\n    }\n\n    public Group getGroup() {\n        return group;\n    }\n\n    public T getValue() {\n        return parameterType.transform(group.getValues());\n    }\n\n    public Type getType() {\n        return parameterType.getType();\n    }\n\n    public ParameterType<T> getParameterType() {\n        return parameterType;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final ParameterType<T> parameterType;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterType<T>", "name": "parameterType", "syntax_pass": true}, {"attribute_expression": "private final Group group;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Group", "name": "group", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java.CombinatorialGeneratedExpressionFactory", "name": "CombinatorialGeneratedExpressionFactory", "file_path": "src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java", "superclasses": "", "methods": ["[]CombinatorialGeneratedExpressionFactory(String,List<List<ParameterType<?>>>)", "[List<GeneratedExpression>]generateExpressions()", "[void]generatePermutations(List<GeneratedExpression>,Deque<ParameterType<?>>)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java.CombinatorialGeneratedExpressionFactory.[]CombinatorialGeneratedExpressionFactory(String,List<List<ParameterType<?>>>)", "src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java.CombinatorialGeneratedExpressionFactory.[List<GeneratedExpression>]generateExpressions()", "src/main/java/io/cucumber/cucumberexpressions/CombinatorialGeneratedExpressionFactory.java.CombinatorialGeneratedExpressionFactory.[void]generatePermutations(List<GeneratedExpression>,Deque<ParameterType<?>>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class CombinatorialGeneratedExpressionFactory {\n    // 256 generated expressions ought to be enough for anybody\n    private static final int MAX_EXPRESSIONS = 256;\n    private final String expressionTemplate;\n    private final List<List<ParameterType<?>>> parameterTypeCombinations;\n\n    CombinatorialGeneratedExpressionFactory(\n            String expressionTemplate,\n            List<List<ParameterType<?>>> parameterTypeCombinations) {\n\n        this.expressionTemplate = expressionTemplate;\n        this.parameterTypeCombinations = parameterTypeCombinations;\n    }\n\n    List<GeneratedExpression> generateExpressions() {\n        List<GeneratedExpression> generatedExpressions = new ArrayList<>();\n        ArrayDeque<ParameterType<?>> permutation = new ArrayDeque<>(parameterTypeCombinations.size());\n        generatePermutations(generatedExpressions, permutation);\n        return generatedExpressions;\n    }\n\n    private void generatePermutations(\n            List<GeneratedExpression> generatedExpressions,\n            Deque<ParameterType<?>> permutation\n    ) {\n        if (generatedExpressions.size() >= MAX_EXPRESSIONS) {\n            return;\n        }\n\n        if (permutation.size() == parameterTypeCombinations.size()) {\n            ArrayList<ParameterType<?>> permutationCopy = new ArrayList<>(permutation);\n            generatedExpressions.add(new GeneratedExpression(expressionTemplate, permutationCopy));\n            return;\n        }\n\n        List<ParameterType<?>> parameterTypes = parameterTypeCombinations.get(permutation.size());\n        for (ParameterType<?> parameterType : parameterTypes) {\n            // Avoid recursion if no elements can be added.\n            if (generatedExpressions.size() >= MAX_EXPRESSIONS) {\n                return;\n            }\n            permutation.addLast(parameterType);\n            generatePermutations(generatedExpressions, permutation);\n            permutation.removeLast();\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final int MAX_EXPRESSIONS = 256;", "docstring": " 256 generated expressions ought to be enough for anybody", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "int", "name": "MAX_EXPRESSIONS = 256", "syntax_pass": true}, {"attribute_expression": "private final String expressionTemplate;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "expressionTemplate", "syntax_pass": true}, {"attribute_expression": "private final List<List<ParameterType<?>>> parameterTypeCombinations;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<List<ParameterType<?>>>", "name": "parameterTypeCombinations", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator", "name": "CucumberExpressionGenerator", "file_path": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java", "superclasses": "", "methods": ["[]CucumberExpressionGenerator(ParameterTypeRegistry)", "[List<GeneratedExpression>]generateExpressions(String)", "[String]escape(String)", "[List<ParameterTypeMatcher>]createParameterTypeMatchers(String)", "[List<ParameterTypeMatcher>]createParameterTypeMatchers(ParameterType<?>,String)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator.[]CucumberExpressionGenerator(ParameterTypeRegistry)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator.[List<GeneratedExpression>]generateExpressions(String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator.[String]escape(String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator.[List<ParameterTypeMatcher>]createParameterTypeMatchers(String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionGenerator.java.CucumberExpressionGenerator.[List<ParameterTypeMatcher>]createParameterTypeMatchers(ParameterType<?>,String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@API(status = API.Status.STABLE)\npublic final class CucumberExpressionGenerator {\n    private final ParameterTypeRegistry parameterTypeRegistry;\n\n    public CucumberExpressionGenerator(ParameterTypeRegistry parameterTypeRegistry) {\n        this.parameterTypeRegistry = parameterTypeRegistry;\n    }\n\n    public List<GeneratedExpression> generateExpressions(String text) {\n        List<List<ParameterType<?>>> parameterTypeCombinations = new ArrayList<>();\n        List<ParameterTypeMatcher> parameterTypeMatchers = createParameterTypeMatchers(text);\n        StringBuilder expressionTemplate = new StringBuilder();\n        int pos = 0;\n        while (true) {\n            List<ParameterTypeMatcher> matchingParameterTypeMatchers = new ArrayList<>();\n\n            for (ParameterTypeMatcher parameterTypeMatcher : parameterTypeMatchers) {\n                if (parameterTypeMatcher.advanceToAndFind(pos)) {\n                    matchingParameterTypeMatchers.add(parameterTypeMatcher);\n                }\n            }\n\n            if (!matchingParameterTypeMatchers.isEmpty()) {\n                Collections.sort(matchingParameterTypeMatchers);\n\n                // Find all the best parameter type matchers, they are all candidates.\n                ParameterTypeMatcher bestParameterTypeMatcher = matchingParameterTypeMatchers.get(0);\n                List<ParameterTypeMatcher> bestParameterTypeMatchers = new ArrayList<>();\n                for (ParameterTypeMatcher m : matchingParameterTypeMatchers) {\n                    if (m.compareTo(bestParameterTypeMatcher) == 0) {\n                        bestParameterTypeMatchers.add(m);\n                    }\n                }\n\n                // Build a list of parameter types without duplicates. The reason there\n                // might be duplicates is that some parameter types have more than one regexp,\n                // which means multiple ParameterTypeMatcher objects will have a reference to the\n                // same ParameterType.\n                // We're sorting the list so preferential parameter types are listed first.\n                // Users are most likely to want these, so they should be listed at the top.\n                Set<ParameterType<?>> set = new HashSet<>();\n                for (ParameterTypeMatcher parameterTypeMatcher : bestParameterTypeMatchers) {\n                    ParameterType<?> parameterType = parameterTypeMatcher.getParameterType();\n                    set.add(parameterType);\n                }\n                SortedSet<ParameterType<?>> parameterTypes = new TreeSet<>(set);\n\n                parameterTypeCombinations.add(new ArrayList<>(parameterTypes));\n\n                expressionTemplate\n                        .append(escape(text.substring(pos, bestParameterTypeMatcher.start())))\n                        .append(\"{%s}\");\n                pos = bestParameterTypeMatcher.start() + bestParameterTypeMatcher.group().length();\n            } else {\n                break;\n            }\n\n            if (pos >= text.length()) {\n                break;\n            }\n        }\n        expressionTemplate.append(escape(text.substring(pos)));\n        return new CombinatorialGeneratedExpressionFactory(expressionTemplate.toString(), parameterTypeCombinations).generateExpressions();\n    }\n\n    private String escape(String s) {\n        return s.replaceAll(\"%\", \"%%\") // Escape for String.format\n                .replaceAll(\"\\\\(\", \"\\\\\\\\(\")\n                .replaceAll(\"\\\\{\", \"\\\\\\\\{\")\n                .replaceAll(\"/\", \"\\\\\\\\/\");\n    }\n\n    private List<ParameterTypeMatcher> createParameterTypeMatchers(String text) {\n        Collection<ParameterType<?>> parameterTypes = parameterTypeRegistry.getParameterTypes();\n        List<ParameterTypeMatcher> parameterTypeMatchers = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            if (parameterType.useForSnippets()) {\n                parameterTypeMatchers.addAll(createParameterTypeMatchers(parameterType, text));\n            }\n        }\n        return parameterTypeMatchers;\n    }\n\n    private static List<ParameterTypeMatcher> createParameterTypeMatchers(ParameterType<?> parameterType, String text) {\n        List<ParameterTypeMatcher> result = new ArrayList<>();\n        List<String> captureGroupRegexps = parameterType.getRegexps();\n        for (String captureGroupRegexp : captureGroupRegexps) {\n            Pattern regexp = Pattern.compile(\"(\" + captureGroupRegexp + \")\");\n            Matcher matcher = regexp.matcher(text);\n            result.add(new ParameterTypeMatcher(parameterType, matcher, text));\n        }\n        return result;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException", "name": "AmbiguousParameterTypeException", "file_path": "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java", "superclasses": "CucumberExpressionException", "methods": ["[]AmbiguousParameterTypeException(String,Pattern,SortedSet<ParameterType<?>>,List<GeneratedExpression>)", "[String]parameterTypeNames(SortedSet<ParameterType<?>>)", "[String]expressions(List<GeneratedExpression>)", "[String]join(List<String>)", "[Pattern]getRegexp()", "[String]getParameterTypeRegexp()", "[SortedSet<ParameterType<?>>]getParameterTypes()", "[List<GeneratedExpression>]getGeneratedExpressions()"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[]AmbiguousParameterTypeException(String,Pattern,SortedSet<ParameterType<?>>,List<GeneratedExpression>)", "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[String]parameterTypeNames(SortedSet<ParameterType<?>>)", "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[String]expressions(List<GeneratedExpression>)", "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[String]join(List<String>)", "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[Pattern]getRegexp()", "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[String]getParameterTypeRegexp()", "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[SortedSet<ParameterType<?>>]getParameterTypes()", "src/main/java/io/cucumber/cucumberexpressions/AmbiguousParameterTypeException.java.AmbiguousParameterTypeException.[List<GeneratedExpression>]getGeneratedExpressions()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@API(status = API.Status.STABLE)\npublic final class AmbiguousParameterTypeException extends CucumberExpressionException {\n    private final Pattern regexp;\n    private final String parameterTypeRegexp;\n    private final SortedSet<ParameterType<?>> parameterTypes;\n    private final List<GeneratedExpression> generatedExpressions;\n\n    AmbiguousParameterTypeException(String parameterTypeRegexp, Pattern expressionRegexp, SortedSet<ParameterType<?>> parameterTypes, List<GeneratedExpression> generatedExpressions) {\n        super(String.format(\"Your Regular Expression /%s/\\n\" +\n                        \"matches multiple parameter types with regexp /%s/:\\n\" +\n                        \"   %s\\n\" +\n                        \"\\n\" +\n                        \"I couldn't decide which one to use. You have two options:\\n\" +\n                        \"\\n\" +\n                        \"1) Use a Cucumber Expression instead of a Regular Expression. Try one of these:\\n\" +\n                        \"   %s\\n\" +\n                        \"\\n\" +\n                        \"2) Make one of the parameter types preferential and continue to use a Regular Expression.\\n\" +\n                        \"\\n\",\n                expressionRegexp.pattern(),\n                parameterTypeRegexp,\n                parameterTypeNames(parameterTypes),\n                expressions(generatedExpressions)\n        ));\n        this.regexp = expressionRegexp;\n        this.parameterTypeRegexp = parameterTypeRegexp;\n        this.parameterTypes = parameterTypes;\n        this.generatedExpressions = generatedExpressions;\n    }\n\n    private static String parameterTypeNames(SortedSet<ParameterType<?>> parameterTypes) {\n\n        List<String> parameterNames = new ArrayList<>();\n        for (ParameterType<?> p : parameterTypes) {\n            String s = \"{\" + p.getName() + \"}\";\n            parameterNames.add(s);\n        }\n        return join(parameterNames);\n    }\n\n    private static String expressions(List<GeneratedExpression> generatedExpressions) {\n        List<String> sources = new ArrayList<>();\n        for (GeneratedExpression generatedExpression : generatedExpressions) {\n            String source = generatedExpression.getSource();\n            sources.add(source);\n        }\n        return join(sources);\n    }\n\n    private static String join(List<String> strings) {\n        StringBuilder builder = new StringBuilder();\n        boolean first = true;\n        for (String element : strings) {\n            if (first) {\n                first = false;\n            } else {\n                builder.append(\"\\n   \");\n            }\n            builder.append(element);\n        }\n\n        return builder.toString();\n    }\n\n    public Pattern getRegexp() {\n        return regexp;\n    }\n\n    public String getParameterTypeRegexp() {\n        return parameterTypeRegexp;\n    }\n\n    public SortedSet<ParameterType<?>> getParameterTypes() {\n        return parameterTypes;\n    }\n\n    public List<GeneratedExpression> getGeneratedExpressions() {\n        return generatedExpressions;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final Pattern regexp;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Pattern", "name": "regexp", "syntax_pass": true}, {"attribute_expression": "private final String parameterTypeRegexp;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "parameterTypeRegexp", "syntax_pass": true}, {"attribute_expression": "private final SortedSet<ParameterType<?>> parameterTypes;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "SortedSet<ParameterType<?>>", "name": "parameterTypes", "syntax_pass": true}, {"attribute_expression": "private final List<GeneratedExpression> generatedExpressions;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<GeneratedExpression>", "name": "generatedExpressions", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizer.java.CucumberExpressionTokenizer", "name": "CucumberExpressionTokenizer", "file_path": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizer.java", "superclasses": "", "methods": ["[List<Token>]tokenize(String)", "[Iterable<Token>]tokenizeImpl(String)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizer.java.CucumberExpressionTokenizer.[List<Token>]tokenize(String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionTokenizer.java.CucumberExpressionTokenizer.[Iterable<Token>]tokenizeImpl(String)"], "overrides": null, "attributes": [{"original_string": "    private static class TokenIterator implements Iterator<Token> {\n\n        private final String expression;\n        private final OfInt codePoints;\n\n        private StringBuilder buffer = new StringBuilder();\n        private Type previousTokenType = null;\n        private Type currentTokenType = Type.START_OF_LINE;\n        private boolean treatAsText;\n        private int bufferStartIndex;\n        private int escaped;\n\n        TokenIterator(String expression) {\n            this.expression = expression;\n            this.codePoints = expression.codePoints().iterator();\n        }\n\n        private Token convertBufferToToken(Type tokenType) {\n            int escapeTokens = 0;\n            if (tokenType == Type.TEXT) {\n                escapeTokens = escaped;\n                escaped = 0;\n            }\n            int consumedIndex = bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escapeTokens;\n            Token t = new Token(buffer.toString(), tokenType, bufferStartIndex, consumedIndex);\n            buffer = new StringBuilder();\n            this.bufferStartIndex = consumedIndex;\n            return t;\n        }\n\n        private void advanceTokenTypes() {\n            previousTokenType = currentTokenType;\n            currentTokenType = null;\n        }\n\n        private Type tokenTypeOf(Integer token, boolean treatAsText) {\n            if (!treatAsText) {\n                return Token.typeOf(token);\n            }\n            if (Token.canEscape(token)) {\n                return Type.TEXT;\n            }\n            throw createCantEscape(expression, bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escaped);\n        }\n\n        private boolean shouldContinueTokenType(Type previousTokenType,\n                Type currentTokenType) {\n            return currentTokenType == previousTokenType\n                    && (currentTokenType == Type.WHITE_SPACE || currentTokenType == Type.TEXT);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return previousTokenType != Type.END_OF_LINE;\n        }\n\n        @Override\n        public Token next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            if (currentTokenType == Type.START_OF_LINE) {\n                Token token = convertBufferToToken(currentTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            while (codePoints.hasNext()) {\n                int codePoint = codePoints.nextInt();\n                if (!treatAsText && Token.isEscapeCharacter(codePoint)) {\n                    escaped++;\n                    treatAsText = true;\n                    continue;\n                }\n                currentTokenType = tokenTypeOf(codePoint, treatAsText);\n                treatAsText = false;\n\n                if (previousTokenType == Type.START_OF_LINE ||\n                        shouldContinueTokenType(previousTokenType, currentTokenType)) {\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                } else {\n                    Token t = convertBufferToToken(previousTokenType);\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                    return t;\n                }\n            }\n\n            if (buffer.length() > 0) {\n                Token token = convertBufferToToken(previousTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            currentTokenType = Type.END_OF_LINE;\n            if (treatAsText) {\n                throw createTheEndOfLineCanNotBeEscaped(expression);\n            }\n            Token token = convertBufferToToken(currentTokenType);\n            advanceTokenTypes();\n            return token;\n        }\n\n    }", "definition": "    private static class TokenIterator implements Iterator<Token>", "class_docstring": "", "name": "TokenIterator", "super_interfaces": ["Iterator<Token>"], "superclasses": "", "attributes": {"modifiers": "private static", "marker_annotations": [], "non_marker_annotations": ["private", "static"], "comments": [], "fields": [{"attribute_expression": "private final String expression;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "expression", "syntax_pass": true}, {"attribute_expression": "private final OfInt codePoints;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "OfInt", "name": "codePoints", "syntax_pass": true}, {"attribute_expression": "private StringBuilder buffer = new StringBuilder();", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "StringBuilder", "name": "buffer = new StringBuilder()", "syntax_pass": true}, {"attribute_expression": "private Type previousTokenType = null;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Type", "name": "previousTokenType = null", "syntax_pass": true}, {"attribute_expression": "private Type currentTokenType = Type.START_OF_LINE;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "Type", "name": "currentTokenType = Type.START_OF_LINE", "syntax_pass": true}, {"attribute_expression": "private boolean treatAsText;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "treatAsText", "syntax_pass": true}, {"attribute_expression": "private int bufferStartIndex;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "bufferStartIndex", "syntax_pass": true}, {"attribute_expression": "private int escaped;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "escaped", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        TokenIterator(String expression) {\n            this.expression = expression;\n            this.codePoints = expression.codePoints().iterator();\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "TokenIterator", "params": [{"name": "expression", "type": "String"}], "body": "                                         {\n            this.expression = expression;\n            this.codePoints = expression.codePoints().iterator();\n        }", "signature": "TokenIterator(String expression)"}, {"syntax_pass": true, "original_string": "        private Token convertBufferToToken(Type tokenType) {\n            int escapeTokens = 0;\n            if (tokenType == Type.TEXT) {\n                escapeTokens = escaped;\n                escaped = 0;\n            }\n            int consumedIndex = bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escapeTokens;\n            Token t = new Token(buffer.toString(), tokenType, bufferStartIndex, consumedIndex);\n            buffer = new StringBuilder();\n            this.bufferStartIndex = consumedIndex;\n            return t;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Token", "classes": []}, "name": "convertBufferToToken", "params": [{"name": "tokenType", "type": "Type"}], "body": "                                                           {\n            int escapeTokens = 0;\n            if (tokenType == Type.TEXT) {\n                escapeTokens = escaped;\n                escaped = 0;\n            }\n            int consumedIndex = bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escapeTokens;\n            Token t = new Token(buffer.toString(), tokenType, bufferStartIndex, consumedIndex);\n            buffer = new StringBuilder();\n            this.bufferStartIndex = consumedIndex;\n            return t;\n        }", "signature": "private Token convertBufferToToken(Type tokenType)"}, {"syntax_pass": true, "original_string": "        private void advanceTokenTypes() {\n            previousTokenType = currentTokenType;\n            currentTokenType = null;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "void", "classes": []}, "name": "advanceTokenTypes", "params": [], "body": "                                         {\n            previousTokenType = currentTokenType;\n            currentTokenType = null;\n        }", "signature": "private void advanceTokenTypes()"}, {"syntax_pass": true, "original_string": "        private Type tokenTypeOf(Integer token, boolean treatAsText) {\n            if (!treatAsText) {\n                return Token.typeOf(token);\n            }\n            if (Token.canEscape(token)) {\n                return Type.TEXT;\n            }\n            throw createCantEscape(expression, bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escaped);\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "Type", "classes": []}, "name": "tokenTypeOf", "params": [{"name": "token", "type": "Integer"}, {"name": "treatAsText", "type": "boolean"}], "body": "                                                                     {\n            if (!treatAsText) {\n                return Token.typeOf(token);\n            }\n            if (Token.canEscape(token)) {\n                return Type.TEXT;\n            }\n            throw createCantEscape(expression, bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escaped);\n        }", "signature": "private Type tokenTypeOf(Integer token, boolean treatAsText)"}, {"syntax_pass": true, "original_string": "        private boolean shouldContinueTokenType(Type previousTokenType,\n                Type currentTokenType) {\n            return currentTokenType == previousTokenType\n                    && (currentTokenType == Type.WHITE_SPACE || currentTokenType == Type.TEXT);\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "boolean", "classes": []}, "name": "shouldContinueTokenType", "params": [{"name": "previousTokenType", "type": "Type"}, {"name": "currentTokenType", "type": "Type"}], "body": "                                       {\n            return currentTokenType == previousTokenType\n                    && (currentTokenType == Type.WHITE_SPACE || currentTokenType == Type.TEXT);\n        }", "signature": "private boolean shouldContinueTokenType(Type previousTokenType,\n                Type currentTokenType)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean hasNext() {\n            return previousTokenType != Type.END_OF_LINE;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "hasNext", "params": [], "body": "                                 {\n            return previousTokenType != Type.END_OF_LINE;\n        }", "signature": "@Override\n        public boolean hasNext()"}, {"syntax_pass": true, "original_string": "        @Override\n        public Token next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            if (currentTokenType == Type.START_OF_LINE) {\n                Token token = convertBufferToToken(currentTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            while (codePoints.hasNext()) {\n                int codePoint = codePoints.nextInt();\n                if (!treatAsText && Token.isEscapeCharacter(codePoint)) {\n                    escaped++;\n                    treatAsText = true;\n                    continue;\n                }\n                currentTokenType = tokenTypeOf(codePoint, treatAsText);\n                treatAsText = false;\n\n                if (previousTokenType == Type.START_OF_LINE ||\n                        shouldContinueTokenType(previousTokenType, currentTokenType)) {\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                } else {\n                    Token t = convertBufferToToken(previousTokenType);\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                    return t;\n                }\n            }\n\n            if (buffer.length() > 0) {\n                Token token = convertBufferToToken(previousTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            currentTokenType = Type.END_OF_LINE;\n            if (treatAsText) {\n                throw createTheEndOfLineCanNotBeEscaped(expression);\n            }\n            Token token = convertBufferToToken(currentTokenType);\n            advanceTokenTypes();\n            return token;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "Token", "classes": []}, "name": "next", "params": [], "body": "                            {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            if (currentTokenType == Type.START_OF_LINE) {\n                Token token = convertBufferToToken(currentTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            while (codePoints.hasNext()) {\n                int codePoint = codePoints.nextInt();\n                if (!treatAsText && Token.isEscapeCharacter(codePoint)) {\n                    escaped++;\n                    treatAsText = true;\n                    continue;\n                }\n                currentTokenType = tokenTypeOf(codePoint, treatAsText);\n                treatAsText = false;\n\n                if (previousTokenType == Type.START_OF_LINE ||\n                        shouldContinueTokenType(previousTokenType, currentTokenType)) {\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                } else {\n                    Token t = convertBufferToToken(previousTokenType);\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                    return t;\n                }\n            }\n\n            if (buffer.length() > 0) {\n                Token token = convertBufferToToken(previousTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            currentTokenType = Type.END_OF_LINE;\n            if (treatAsText) {\n                throw createTheEndOfLineCanNotBeEscaped(expression);\n            }\n            Token token = convertBufferToToken(currentTokenType);\n            advanceTokenTypes();\n            return token;\n        }", "signature": "@Override\n        public Token next()"}]}], "class_docstring": "", "original_string": "final class CucumberExpressionTokenizer {\n\n    List<Token> tokenize(String expression) {\n        List<Token> tokens = new ArrayList<>();\n        tokenizeImpl(expression).forEach(tokens::add);\n        return tokens;\n    }\n\n    private Iterable<Token> tokenizeImpl(String expression) {\n        return () -> new TokenIterator(expression);\n    }\n\n    private static class TokenIterator implements Iterator<Token> {\n\n        private final String expression;\n        private final OfInt codePoints;\n\n        private StringBuilder buffer = new StringBuilder();\n        private Type previousTokenType = null;\n        private Type currentTokenType = Type.START_OF_LINE;\n        private boolean treatAsText;\n        private int bufferStartIndex;\n        private int escaped;\n\n        TokenIterator(String expression) {\n            this.expression = expression;\n            this.codePoints = expression.codePoints().iterator();\n        }\n\n        private Token convertBufferToToken(Type tokenType) {\n            int escapeTokens = 0;\n            if (tokenType == Type.TEXT) {\n                escapeTokens = escaped;\n                escaped = 0;\n            }\n            int consumedIndex = bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escapeTokens;\n            Token t = new Token(buffer.toString(), tokenType, bufferStartIndex, consumedIndex);\n            buffer = new StringBuilder();\n            this.bufferStartIndex = consumedIndex;\n            return t;\n        }\n\n        private void advanceTokenTypes() {\n            previousTokenType = currentTokenType;\n            currentTokenType = null;\n        }\n\n        private Type tokenTypeOf(Integer token, boolean treatAsText) {\n            if (!treatAsText) {\n                return Token.typeOf(token);\n            }\n            if (Token.canEscape(token)) {\n                return Type.TEXT;\n            }\n            throw createCantEscape(expression, bufferStartIndex + buffer.codePointCount(0, buffer.length()) + escaped);\n        }\n\n        private boolean shouldContinueTokenType(Type previousTokenType,\n                Type currentTokenType) {\n            return currentTokenType == previousTokenType\n                    && (currentTokenType == Type.WHITE_SPACE || currentTokenType == Type.TEXT);\n        }\n\n        @Override\n        public boolean hasNext() {\n            return previousTokenType != Type.END_OF_LINE;\n        }\n\n        @Override\n        public Token next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            if (currentTokenType == Type.START_OF_LINE) {\n                Token token = convertBufferToToken(currentTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            while (codePoints.hasNext()) {\n                int codePoint = codePoints.nextInt();\n                if (!treatAsText && Token.isEscapeCharacter(codePoint)) {\n                    escaped++;\n                    treatAsText = true;\n                    continue;\n                }\n                currentTokenType = tokenTypeOf(codePoint, treatAsText);\n                treatAsText = false;\n\n                if (previousTokenType == Type.START_OF_LINE ||\n                        shouldContinueTokenType(previousTokenType, currentTokenType)) {\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                } else {\n                    Token t = convertBufferToToken(previousTokenType);\n                    advanceTokenTypes();\n                    buffer.appendCodePoint(codePoint);\n                    return t;\n                }\n            }\n\n            if (buffer.length() > 0) {\n                Token token = convertBufferToToken(previousTokenType);\n                advanceTokenTypes();\n                return token;\n            }\n\n            currentTokenType = Type.END_OF_LINE;\n            if (treatAsText) {\n                throw createTheEndOfLineCanNotBeEscaped(expression);\n            }\n            Token token = convertBufferToToken(currentTokenType);\n            advanceTokenTypes();\n            return token;\n        }\n\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java.RegularExpression", "name": "RegularExpression", "file_path": "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java", "superclasses": "", "methods": ["[]RegularExpression(Pattern,ParameterTypeRegistry)", "[List<Argument<?>>]match(String)", "[Pattern]getRegexp()", "[String]getSource()"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java.RegularExpression.[]RegularExpression(Pattern,ParameterTypeRegistry)", "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java.RegularExpression.[List<Argument<?>>]match(String)", "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java.RegularExpression.[Pattern]getRegexp()", "src/main/java/io/cucumber/cucumberexpressions/RegularExpression.java.RegularExpression.[String]getSource()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@API(status = API.Status.STABLE)\npublic final class RegularExpression implements Expression {\n    private final Pattern expressionRegexp;\n    private final ParameterTypeRegistry parameterTypeRegistry;\n    private final TreeRegexp treeRegexp;\n\n    /**\n     * Creates a new instance. Use this when the transform types are not known in advance,\n     * and should be determined by the regular expression's capture groups. Use this with\n     * dynamically typed languages.\n     *\n     * @param expressionRegexp      the regular expression to use\n     * @param parameterTypeRegistry used to look up parameter types\n     */\n    RegularExpression(Pattern expressionRegexp, ParameterTypeRegistry parameterTypeRegistry) {\n        this.expressionRegexp = expressionRegexp;\n        this.parameterTypeRegistry = parameterTypeRegistry;\n        this.treeRegexp = new TreeRegexp(expressionRegexp);\n    }\n\n    @Override\n    public List<Argument<?>> match(String text, Type... typeHints) {\n        final Group group = treeRegexp.match(text);\n        if (group == null) {\n            return null;\n        }\n\n        final ParameterByTypeTransformer defaultTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n        final List<ParameterType<?>> parameterTypes = new ArrayList<>();\n        int typeHintIndex = 0;\n        for (GroupBuilder groupBuilder : treeRegexp.getGroupBuilder().getChildren()) {\n            final String parameterTypeRegexp = groupBuilder.getSource();\n            boolean hasTypeHint = typeHintIndex < typeHints.length;\n            final Type typeHint = hasTypeHint ? typeHints[typeHintIndex++] : String.class;\n\n            ParameterType<?> parameterType = parameterTypeRegistry.lookupByRegexp(parameterTypeRegexp, expressionRegexp, text);\n\n            // When there is a conflict between the type hint from the regular expression and the method\n            // prefer the parameter type associated with the regular expression. This ensures we will\n            // use the internal/user registered parameter transformer rather then the default.\n            //\n            // Unless the parameter type indicates it is the stronger type hint.\n            if (parameterType != null && hasTypeHint && !parameterType.useRegexpMatchAsStrongTypeHint()) {\n                if (!parameterType.getType().equals(typeHint)) {\n                    parameterType = null;\n                }\n            }\n\n            if (parameterType == null) {\n                parameterType = createAnonymousParameterType(parameterTypeRegexp);\n            }\n\n            // Either from createAnonymousParameterType or lookupByRegexp\n            if (parameterType.isAnonymous()) {\n                parameterType = parameterType.deAnonymize(typeHint, arg -> defaultTransformer.transform(arg, typeHint));\n            }\n\n            parameterTypes.add(parameterType);\n        }\n\n        return Argument.build(group, parameterTypes);\n    }\n\n    @Override\n    public Pattern getRegexp() {\n        return expressionRegexp;\n    }\n\n    @Override\n    public String getSource() {\n        return expressionRegexp.pattern();\n    }\n}", "super_interfaces": ["Expression"], "fields": [{"attribute_expression": "private final Pattern expressionRegexp;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Pattern", "name": "expressionRegexp", "syntax_pass": true}, {"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry", "syntax_pass": true}, {"attribute_expression": "private final TreeRegexp treeRegexp;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TreeRegexp", "name": "treeRegexp", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbols.java.KeyboardFriendlyDecimalFormatSymbols", "name": "KeyboardFriendlyDecimalFormatSymbols", "file_path": "src/main/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbols.java", "superclasses": "", "methods": ["[DecimalFormatSymbols]getInstance(Locale)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/KeyboardFriendlyDecimalFormatSymbols.java.KeyboardFriendlyDecimalFormatSymbols.[DecimalFormatSymbols]getInstance(Locale)"], "overrides": null, "attributes": [], "class_docstring": "\nA set of localized decimal symbols that can be written on a regular keyboard.\n<p>\nNote quite complete, feel free to make a suggestion.\n", "original_string": "class KeyboardFriendlyDecimalFormatSymbols {\n\n    static DecimalFormatSymbols getInstance(Locale locale) {\n        DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n\n        // Replace the minus sign with minus-hyphen as available on most keyboards.\n        if (symbols.getMinusSign() == '\\u2212') {\n            symbols.setMinusSign('-');\n        }\n\n        if (symbols.getDecimalSeparator() == '.') {\n            // For locales that use the period as the decimal separator\n            // always use the comma for thousands. The alternatives are\n            // not available on a keyboard\n            symbols.setGroupingSeparator(',');\n        } else if (symbols.getDecimalSeparator() == ',') {\n            // For locales that use the comma as the decimal separator\n            // always use the period for thousands. The alternatives are\n            // not available on a keyboard\n            symbols.setGroupingSeparator('.');\n        }\n        return symbols;\n    }\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException", "name": "CucumberExpressionException", "file_path": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java", "superclasses": "RuntimeException", "methods": ["[]CucumberExpressionException(String)", "[]CucumberExpressionException(String,Throwable)", "[CucumberExpressionException]createMissingEndToken(String,Type,Type,Token)", "[CucumberExpressionException]createAlternationNotAllowedInOptional(String,Token)", "[CucumberExpressionException]createTheEndOfLineCanNotBeEscaped(String)", "[CucumberExpressionException]createAlternativeMayNotBeEmpty(Node,String)", "[CucumberExpressionException]createParameterIsNotAllowedInOptional(Node,String)", "[CucumberExpressionException]createOptionalIsNotAllowedInOptional(Node,String)", "[CucumberExpressionException]createOptionalMayNotBeEmpty(Node,String)", "[CucumberExpressionException]createAlternativeMayNotExclusivelyContainOptionals(Node,String)", "[String]thisCucumberExpressionHasAProblemAt(int)", "[CucumberExpressionException]createCantEscape(String,int)", "[CucumberExpressionException]createInvalidParameterTypeName(String)", "[CucumberExpressionException]createInvalidParameterTypeName(Token,String)", "[String]message(int,String,String,String,String)", "[String]pointAt(Located)", "[String]pointAt(int)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[]CucumberExpressionException(String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[]CucumberExpressionException(String,Throwable)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createMissingEndToken(String,Type,Type,Token)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createAlternationNotAllowedInOptional(String,Token)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createTheEndOfLineCanNotBeEscaped(String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createAlternativeMayNotBeEmpty(Node,String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createParameterIsNotAllowedInOptional(Node,String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createOptionalIsNotAllowedInOptional(Node,String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createOptionalMayNotBeEmpty(Node,String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createAlternativeMayNotExclusivelyContainOptionals(Node,String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[String]thisCucumberExpressionHasAProblemAt(int)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createCantEscape(String,int)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createInvalidParameterTypeName(String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[CucumberExpressionException]createInvalidParameterTypeName(Token,String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[String]message(int,String,String,String,String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[String]pointAt(Located)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionException.java.CucumberExpressionException.[String]pointAt(int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@API(status = API.Status.STABLE)\npublic class CucumberExpressionException extends RuntimeException {\n\n    CucumberExpressionException(String message) {\n        super(message);\n    }\n\n    CucumberExpressionException(String message, Throwable cause) {\n        super(message, cause);\n    }\n\n    static CucumberExpressionException createMissingEndToken(String expression, Type beginToken, Type endToken,\n            Token current) {\n        return new CucumberExpressionException(message(\n                current.start(),\n                expression,\n                pointAt(current),\n                \"The '\" + beginToken.symbol() + \"' does not have a matching '\" + endToken.symbol() + \"'\",\n                \"If you did not intend to use \" + beginToken.purpose() + \" you can use '\\\\\" + beginToken\n                        .symbol() + \"' to escape the \" + beginToken.purpose()));\n    }\n\n    static CucumberExpressionException createAlternationNotAllowedInOptional(String expression, Token current) {\n        return new CucumberExpressionException(message(\n                current.start,\n                expression,\n                pointAt(current),\n                \"An alternation can not be used inside an optional\",\n                \"If you did not mean to use an alternation you can use '\\\\/' to escape the '/'. Otherwise rephrase your expression or consider using a regular expression instead.\"\n        ));\n    }\n\n    static CucumberExpressionException createTheEndOfLineCanNotBeEscaped(String expression) {\n        int index = expression.codePointCount(0, expression.length()) - 1;\n        return new CucumberExpressionException(message(\n                index,\n                expression,\n                pointAt(index),\n                \"The end of line can not be escaped\",\n                \"You can use '\\\\\\\\' to escape the '\\\\'\"\n        ));\n    }\n\n    static CucumberExpressionException createAlternativeMayNotBeEmpty(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"Alternative may not be empty\",\n                \"If you did not mean to use an alternative you can use '\\\\/' to escape the '/'\"));\n    }\n\n    static CucumberExpressionException createParameterIsNotAllowedInOptional(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional may not contain a parameter type\",\n                \"If you did not mean to use an parameter type you can use '\\\\{' to escape the '{'\"));\n    }\n    static CucumberExpressionException createOptionalIsNotAllowedInOptional(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional may not contain an other optional\",\n                \"If you did not mean to use an optional type you can use '\\\\(' to escape the '('. For more complicated expressions consider using a regular expression instead.\"));\n    }\n\n    static CucumberExpressionException createOptionalMayNotBeEmpty(Node node, String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An optional must contain some text\",\n                \"If you did not mean to use an optional you can use '\\\\(' to escape the '('\"));\n    }\n\n    static CucumberExpressionException createAlternativeMayNotExclusivelyContainOptionals(Node node,\n            String expression) {\n        return new CucumberExpressionException(message(\n                node.start(),\n                expression,\n                pointAt(node),\n                \"An alternative may not exclusively contain optionals\",\n                \"If you did not mean to use an optional you can use '\\\\(' to escape the '('\"));\n    }\n\n    private static String thisCucumberExpressionHasAProblemAt(int index) {\n        return \"This Cucumber Expression has a problem at column \" + (index + 1) + \":\" + \"\\n\";\n    }\n\n    static CucumberExpressionException createCantEscape(String expression, int index) {\n        return new CucumberExpressionException(message(\n                index,\n                expression,\n                pointAt(index),\n                \"Only the characters '{', '}', '(', ')', '\\\\', '/' and whitespace can be escaped\",\n                \"If you did mean to use an '\\\\' you can use '\\\\\\\\' to escape it\"));\n    }\n\n    static CucumberExpressionException createInvalidParameterTypeName(String name) {\n        return new CucumberExpressionException(\n                \"Illegal character in parameter name {\" + name + \"}. Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\");\n    }\n\n    /**\n     * Not very clear, but this message has to be language independent\n     * Other languages have dedicated syntax for writing down regular expressions\n     * <p>\n     * In java a regular expression has to start with {@code ^} and end with\n     * {@code $} to be recognized as one by Cucumber.\n     *\n     * @see ExpressionFactory\n     */\n    static CucumberExpressionException createInvalidParameterTypeName(Token token, String expression) {\n        return new CucumberExpressionException(message(\n                token.start(),\n                expression,\n                pointAt(token),\n                \"Parameter names may not contain '{', '}', '(', ')', '\\\\' or '/'\",\n                \"Did you mean to use a regular expression?\"));\n    }\n\n    static String message(int index, String expression, String pointer, String problem,\n            String solution) {\n        return thisCucumberExpressionHasAProblemAt(index) +\n                \"\\n\" +\n                expression + \"\\n\" +\n                pointer + \"\\n\" +\n                problem + \".\\n\" +\n                solution;\n    }\n\n    static String pointAt(Located node) {\n        StringBuilder pointer = new StringBuilder(pointAt(node.start()));\n        if (node.start() + 1 < node.end()) {\n            for (int i = node.start() + 1; i < node.end() - 1; i++) {\n                pointer.append(\"-\");\n            }\n            pointer.append(\"^\");\n        }\n        return pointer.toString();\n    }\n\n    private static String pointAt(int index) {\n        StringBuilder pointer = new StringBuilder();\n        for (int i = 0; i < index; i++) {\n            pointer.append(\" \");\n        }\n        pointer.append(\"^\");\n        return pointer.toString();\n    }\n\n}", "super_interfaces": [], "fields": []}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/Ast.java.Ast", "name": "Ast", "file_path": "src/main/java/io/cucumber/cucumberexpressions/Ast.java", "superclasses": "", "methods": [], "method_uris": [], "overrides": null, "attributes": [{"original_string": "    static final class Node implements Located {\n\n        private final Type type;\n        private final List<Node> nodes;\n        private final String token;\n        private final int start;\n        private final int end;\n\n        Node(Type type, int start, int end, String token) {\n            this(type, start, end, null, token);\n        }\n\n        Node(Type type, int start, int end, List<Node> nodes) {\n            this(type, start, end, nodes, null);\n        }\n\n        private Node(Type type, int start, int end, List<Node> nodes, String token) {\n            this.type = requireNonNull(type);\n            this.nodes = nodes;\n            this.token = token;\n            this.start = start;\n            this.end = end;\n        }\n\n        enum Type {\n            TEXT_NODE,\n            OPTIONAL_NODE,\n            ALTERNATION_NODE,\n            ALTERNATIVE_NODE,\n            PARAMETER_NODE,\n            EXPRESSION_NODE\n        }\n\n        public int start() {\n            return start;\n        }\n\n        public int end() {\n            return end;\n        }\n\n        List<Node> nodes() {\n            return nodes;\n        }\n\n        Type type() {\n            return type;\n        }\n\n        String text() {\n            if (nodes == null)\n                return token;\n\n            return nodes().stream()\n                    .map(Node::text)\n                    .collect(joining());\n        }\n\n        @Override\n        public String toString() {\n            return toString(0).toString();\n        }\n\n        private StringBuilder toString(int depth) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < depth; i++) {\n                sb.append(\"  \");\n            }\n            sb.append(\"{\")\n                    .append(\"\\\"type\\\": \\\"\").append(type)\n                    .append(\"\\\", \\\"start\\\": \")\n                    .append(start)\n                    .append(\", \\\"end\\\": \")\n                    .append(end);\n\n            if (token != null) {\n                sb.append(\", \\\"token\\\": \\\"\").append(token.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\")).append(\"\\\"\");\n            }\n\n            if (nodes != null) {\n                sb.append(\", \\\"nodes\\\": \");\n                if (!nodes.isEmpty()) {\n                StringBuilder padding = new StringBuilder();\n                for (int i = 0; i < depth; i++) {\n                    padding.append(\"  \");\n                }\n                sb.append(nodes.stream()\n                        .map(node -> node.toString(depth + 1))\n                        .collect(joining(\",\\n\", \"[\\n\", \"\\n\" +padding + \"]\")));\n\n                } else {\n                    sb.append(\"[]\");\n                }\n            }\n            sb.append(\"}\");\n            return sb;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Node node = (Node) o;\n            return start == node.start &&\n                    end == node.end &&\n                    type == node.type &&\n                    Objects.equals(nodes, node.nodes) &&\n                    Objects.equals(token, node.token);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(type, nodes, token, start, end);\n        }\n\n    }", "definition": "    static final class Node implements Located", "class_docstring": "", "name": "Node", "super_interfaces": ["Located"], "superclasses": "", "attributes": {"modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "fields": [{"attribute_expression": "private final Type type;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Type", "name": "type", "syntax_pass": true}, {"attribute_expression": "private final List<Node> nodes;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<Node>", "name": "nodes", "syntax_pass": true}, {"attribute_expression": "private final String token;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "token", "syntax_pass": true}, {"attribute_expression": "private final int start;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "start", "syntax_pass": true}, {"attribute_expression": "private final int end;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "int", "name": "end", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Node(Type type, int start, int end, String token) {\n            this(type, start, end, null, token);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Node", "params": [{"name": "type", "type": "Type"}, {"name": "start", "type": "int"}, {"name": "end", "type": "int"}, {"name": "token", "type": "String"}], "body": "                                                          {\n            this(type, start, end, null, token);\n        }", "signature": "Node(Type type, int start, int end, String token)"}, {"syntax_pass": true, "original_string": "        Node(Type type, int start, int end, List<Node> nodes) {\n            this(type, start, end, nodes, null);\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Node", "params": [{"name": "type", "type": "Type"}, {"name": "start", "type": "int"}, {"name": "end", "type": "int"}, {"name": "nodes", "type": "List<Node>"}], "body": "                                                              {\n            this(type, start, end, nodes, null);\n        }", "signature": "Node(Type type, int start, int end, List<Node> nodes)"}, {"syntax_pass": true, "original_string": "        private Node(Type type, int start, int end, List<Node> nodes, String token) {\n            this.type = requireNonNull(type);\n            this.nodes = nodes;\n            this.token = token;\n            this.start = start;\n            this.end = end;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Node", "params": [{"name": "type", "type": "Type"}, {"name": "start", "type": "int"}, {"name": "end", "type": "int"}, {"name": "nodes", "type": "List<Node>"}, {"name": "token", "type": "String"}], "body": "                                                                                    {\n            this.type = requireNonNull(type);\n            this.nodes = nodes;\n            this.token = token;\n            this.start = start;\n            this.end = end;\n        }", "signature": "private Node(Type type, int start, int end, List<Node> nodes, String token)"}, {"syntax_pass": true, "original_string": "        public int start() {\n            return start;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "start", "params": [], "body": "                           {\n            return start;\n        }", "signature": "public int start()"}, {"syntax_pass": true, "original_string": "        public int end() {\n            return end;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "end", "params": [], "body": "                         {\n            return end;\n        }", "signature": "public int end()"}, {"syntax_pass": true, "original_string": "        List<Node> nodes() {\n            return nodes;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "List<Node>", "classes": []}, "name": "nodes", "params": [], "body": "                           {\n            return nodes;\n        }", "signature": "List<Node> nodes()"}, {"syntax_pass": true, "original_string": "        Type type() {\n            return type;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "Type", "classes": []}, "name": "type", "params": [], "body": "                    {\n            return type;\n        }", "signature": "Type type()"}, {"syntax_pass": true, "original_string": "        String text() {\n            if (nodes == null)\n                return token;\n\n            return nodes().stream()\n                    .map(Node::text)\n                    .collect(joining());\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "String", "classes": []}, "name": "text", "params": [], "body": "                      {\n            if (nodes == null)\n                return token;\n\n            return nodes().stream()\n                    .map(Node::text)\n                    .collect(joining());\n        }", "signature": "String text()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return toString(0).toString();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return toString(0).toString();\n        }", "signature": "@Override\n        public String toString()"}, {"syntax_pass": true, "original_string": "        private StringBuilder toString(int depth) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < depth; i++) {\n                sb.append(\"  \");\n            }\n            sb.append(\"{\")\n                    .append(\"\\\"type\\\": \\\"\").append(type)\n                    .append(\"\\\", \\\"start\\\": \")\n                    .append(start)\n                    .append(\", \\\"end\\\": \")\n                    .append(end);\n\n            if (token != null) {\n                sb.append(\", \\\"token\\\": \\\"\").append(token.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\")).append(\"\\\"\");\n            }\n\n            if (nodes != null) {\n                sb.append(\", \\\"nodes\\\": \");\n                if (!nodes.isEmpty()) {\n                StringBuilder padding = new StringBuilder();\n                for (int i = 0; i < depth; i++) {\n                    padding.append(\"  \");\n                }\n                sb.append(nodes.stream()\n                        .map(node -> node.toString(depth + 1))\n                        .collect(joining(\",\\n\", \"[\\n\", \"\\n\" +padding + \"]\")));\n\n                } else {\n                    sb.append(\"[]\");\n                }\n            }\n            sb.append(\"}\");\n            return sb;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "StringBuilder", "classes": []}, "name": "toString", "params": [{"name": "depth", "type": "int"}], "body": "                                                  {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < depth; i++) {\n                sb.append(\"  \");\n            }\n            sb.append(\"{\")\n                    .append(\"\\\"type\\\": \\\"\").append(type)\n                    .append(\"\\\", \\\"start\\\": \")\n                    .append(start)\n                    .append(\", \\\"end\\\": \")\n                    .append(end);\n\n            if (token != null) {\n                sb.append(\", \\\"token\\\": \\\"\").append(token.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\")).append(\"\\\"\");\n            }\n\n            if (nodes != null) {\n                sb.append(\", \\\"nodes\\\": \");\n                if (!nodes.isEmpty()) {\n                StringBuilder padding = new StringBuilder();\n                for (int i = 0; i < depth; i++) {\n                    padding.append(\"  \");\n                }\n                sb.append(nodes.stream()\n                        .map(node -> node.toString(depth + 1))\n                        .collect(joining(\",\\n\", \"[\\n\", \"\\n\" +padding + \"]\")));\n\n                } else {\n                    sb.append(\"[]\");\n                }\n            }\n            sb.append(\"}\");\n            return sb;\n        }", "signature": "private StringBuilder toString(int depth)"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Node node = (Node) o;\n            return start == node.start &&\n                    end == node.end &&\n                    type == node.type &&\n                    Objects.equals(nodes, node.nodes) &&\n                    Objects.equals(token, node.token);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                        {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Node node = (Node) o;\n            return start == node.start &&\n                    end == node.end &&\n                    type == node.type &&\n                    Objects.equals(nodes, node.nodes) &&\n                    Objects.equals(token, node.token);\n        }", "signature": "@Override\n        public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return Objects.hash(type, nodes, token, start, end);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return Objects.hash(type, nodes, token, start, end);\n        }", "signature": "@Override\n        public int hashCode()"}]}, {"original_string": "    static final class Token implements Located {\n\n        final String text;\n        final Token.Type type;\n        final int start;\n        final int end;\n\n        Token(String text, Token.Type type, int start, int end) {\n            this.text = requireNonNull(text);\n            this.type = requireNonNull(type);\n            this.start = start;\n            this.end = end;\n        }\n\n        static boolean canEscape(Integer token) {\n            if (Character.isWhitespace(token)) {\n                return true;\n            }\n            switch (token) {\n                case (int) escapeCharacter:\n                case (int) alternationCharacter:\n                case (int) beginParameterCharacter:\n                case (int) endParameterCharacter:\n                case (int) beginOptionalCharacter:\n                case (int) endOptionalCharacter:\n                    return true;\n            }\n            return false;\n        }\n\n        static Type typeOf(Integer token) {\n            if (Character.isWhitespace(token)) {\n                return Type.WHITE_SPACE;\n            }\n            switch (token) {\n                case (int) alternationCharacter:\n                    return Type.ALTERNATION;\n                case (int) beginParameterCharacter:\n                    return Type.BEGIN_PARAMETER;\n                case (int) endParameterCharacter:\n                    return Type.END_PARAMETER;\n                case (int) beginOptionalCharacter:\n                    return Type.BEGIN_OPTIONAL;\n                case (int) endOptionalCharacter:\n                    return Type.END_OPTIONAL;\n            }\n            return Type.TEXT;\n        }\n\n        static boolean isEscapeCharacter(int token) {\n            return token == escapeCharacter;\n        }\n\n        public int start() {\n            return start;\n        }\n\n        public int end() {\n            return end;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Token token = (Token) o;\n            return start == token.start &&\n                    end == token.end &&\n                    text.equals(token.text) &&\n                    type == token.type;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(start, end, text, type);\n        }\n\n        @Override\n        public String toString() {\n            return new StringJoiner(\", \", \"\" + \"{\", \"}\")\n                    .add(\"\\\"type\\\": \\\"\" + type + \"\\\"\")\n                    .add(\"\\\"start\\\": \" + start + \"\")\n                    .add(\"\\\"end\\\": \" + end + \"\")\n                    .add(\"\\\"text\\\": \\\"\" + text + \"\\\"\")\n                    .toString();\n        }\n\n        enum Type {\n            START_OF_LINE,\n            END_OF_LINE,\n            WHITE_SPACE,\n            BEGIN_OPTIONAL(\"\" + beginOptionalCharacter, \"optional text\"),\n            END_OPTIONAL(\"\" + endOptionalCharacter, \"optional text\"),\n            BEGIN_PARAMETER(\"\" + beginParameterCharacter, \"a parameter\"),\n            END_PARAMETER(\"\" + endParameterCharacter, \"a parameter\"),\n            ALTERNATION(\"\" + alternationCharacter, \"alternation\"),\n            TEXT;\n\n            private final String symbol;\n            private final String purpose;\n\n            Type() {\n                this(null, null);\n            }\n\n            Type(String symbol, String purpose) {\n                this.symbol = symbol;\n                this.purpose = purpose;\n            }\n\n            String purpose() {\n                return requireNonNull(purpose, name() + \" does not have a purpose\");\n            }\n\n            String symbol() {\n                return requireNonNull(symbol, name() + \" does not have a symbol\");\n            }\n        }\n\n    }", "definition": "    static final class Token implements Located", "class_docstring": "", "name": "Token", "super_interfaces": ["Located"], "superclasses": "", "attributes": {"modifiers": "static final", "marker_annotations": [], "non_marker_annotations": ["static", "final"], "comments": [], "fields": [{"attribute_expression": "final String text;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "String", "name": "text", "syntax_pass": true}, {"attribute_expression": "final Token.Type type;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "Token.Type", "name": "type", "syntax_pass": true}, {"attribute_expression": "final int start;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "start", "syntax_pass": true}, {"attribute_expression": "final int end;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "end", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        Token(String text, Token.Type type, int start, int end) {\n            this.text = requireNonNull(text);\n            this.type = requireNonNull(type);\n            this.start = start;\n            this.end = end;\n        }", "docstring": "", "attributes": {"modifiers": "", "marker_annotations": [], "non_marker_annotations": [], "comments": [], "return_type": "", "classes": []}, "name": "Token", "params": [{"name": "text", "type": "String"}, {"name": "type", "type": "Token.Type"}, {"name": "start", "type": "int"}, {"name": "end", "type": "int"}], "body": "                                                                {\n            this.text = requireNonNull(text);\n            this.type = requireNonNull(type);\n            this.start = start;\n            this.end = end;\n        }", "signature": "Token(String text, Token.Type type, int start, int end)"}, {"syntax_pass": true, "original_string": "        static boolean canEscape(Integer token) {\n            if (Character.isWhitespace(token)) {\n                return true;\n            }\n            switch (token) {\n                case (int) escapeCharacter:\n                case (int) alternationCharacter:\n                case (int) beginParameterCharacter:\n                case (int) endParameterCharacter:\n                case (int) beginOptionalCharacter:\n                case (int) endOptionalCharacter:\n                    return true;\n            }\n            return false;\n        }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "canEscape", "params": [{"name": "token", "type": "Integer"}], "body": "                                                {\n            if (Character.isWhitespace(token)) {\n                return true;\n            }\n            switch (token) {\n                case (int) escapeCharacter:\n                case (int) alternationCharacter:\n                case (int) beginParameterCharacter:\n                case (int) endParameterCharacter:\n                case (int) beginOptionalCharacter:\n                case (int) endOptionalCharacter:\n                    return true;\n            }\n            return false;\n        }", "signature": "static boolean canEscape(Integer token)"}, {"syntax_pass": true, "original_string": "        static Type typeOf(Integer token) {\n            if (Character.isWhitespace(token)) {\n                return Type.WHITE_SPACE;\n            }\n            switch (token) {\n                case (int) alternationCharacter:\n                    return Type.ALTERNATION;\n                case (int) beginParameterCharacter:\n                    return Type.BEGIN_PARAMETER;\n                case (int) endParameterCharacter:\n                    return Type.END_PARAMETER;\n                case (int) beginOptionalCharacter:\n                    return Type.BEGIN_OPTIONAL;\n                case (int) endOptionalCharacter:\n                    return Type.END_OPTIONAL;\n            }\n            return Type.TEXT;\n        }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "Type", "classes": []}, "name": "typeOf", "params": [{"name": "token", "type": "Integer"}], "body": "                                          {\n            if (Character.isWhitespace(token)) {\n                return Type.WHITE_SPACE;\n            }\n            switch (token) {\n                case (int) alternationCharacter:\n                    return Type.ALTERNATION;\n                case (int) beginParameterCharacter:\n                    return Type.BEGIN_PARAMETER;\n                case (int) endParameterCharacter:\n                    return Type.END_PARAMETER;\n                case (int) beginOptionalCharacter:\n                    return Type.BEGIN_OPTIONAL;\n                case (int) endOptionalCharacter:\n                    return Type.END_OPTIONAL;\n            }\n            return Type.TEXT;\n        }", "signature": "static Type typeOf(Integer token)"}, {"syntax_pass": true, "original_string": "        static boolean isEscapeCharacter(int token) {\n            return token == escapeCharacter;\n        }", "docstring": "", "attributes": {"modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "return_type": "boolean", "classes": []}, "name": "isEscapeCharacter", "params": [{"name": "token", "type": "int"}], "body": "                                                    {\n            return token == escapeCharacter;\n        }", "signature": "static boolean isEscapeCharacter(int token)"}, {"syntax_pass": true, "original_string": "        public int start() {\n            return start;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "start", "params": [], "body": "                           {\n            return start;\n        }", "signature": "public int start()"}, {"syntax_pass": true, "original_string": "        public int end() {\n            return end;\n        }", "docstring": "", "attributes": {"modifiers": "public", "marker_annotations": [], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "end", "params": [], "body": "                         {\n            return end;\n        }", "signature": "public int end()"}, {"syntax_pass": true, "original_string": "        @Override\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Token token = (Token) o;\n            return start == token.start &&\n                    end == token.end &&\n                    text.equals(token.text) &&\n                    type == token.type;\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "boolean", "classes": []}, "name": "equals", "params": [{"name": "o", "type": "Object"}], "body": "                                        {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Token token = (Token) o;\n            return start == token.start &&\n                    end == token.end &&\n                    text.equals(token.text) &&\n                    type == token.type;\n        }", "signature": "@Override\n        public boolean equals(Object o)"}, {"syntax_pass": true, "original_string": "        @Override\n        public int hashCode() {\n            return Objects.hash(start, end, text, type);\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "int", "classes": []}, "name": "hashCode", "params": [], "body": "                              {\n            return Objects.hash(start, end, text, type);\n        }", "signature": "@Override\n        public int hashCode()"}, {"syntax_pass": true, "original_string": "        @Override\n        public String toString() {\n            return new StringJoiner(\", \", \"\" + \"{\", \"}\")\n                    .add(\"\\\"type\\\": \\\"\" + type + \"\\\"\")\n                    .add(\"\\\"start\\\": \" + start + \"\")\n                    .add(\"\\\"end\\\": \" + end + \"\")\n                    .add(\"\\\"text\\\": \\\"\" + text + \"\\\"\")\n                    .toString();\n        }", "docstring": "", "attributes": {"modifiers": "@Override\n        public", "marker_annotations": ["@Override"], "non_marker_annotations": ["public"], "comments": [], "return_type": "String", "classes": []}, "name": "toString", "params": [], "body": "                                 {\n            return new StringJoiner(\", \", \"\" + \"{\", \"}\")\n                    .add(\"\\\"type\\\": \\\"\" + type + \"\\\"\")\n                    .add(\"\\\"start\\\": \" + start + \"\")\n                    .add(\"\\\"end\\\": \" + end + \"\")\n                    .add(\"\\\"text\\\": \\\"\" + text + \"\\\"\")\n                    .toString();\n        }", "signature": "@Override\n        public String toString()"}]}], "class_docstring": "", "original_string": "final class Ast {\n\n    private static final char escapeCharacter = '\\\\';\n    private static final char alternationCharacter = '/';\n    private static final char beginParameterCharacter = '{';\n    private static final char endParameterCharacter = '}';\n    private static final char beginOptionalCharacter = '(';\n    private static final char endOptionalCharacter = ')';\n\n    interface Located {\n        int start();\n\n        int end();\n\n    }\n\n    static final class Node implements Located {\n\n        private final Type type;\n        private final List<Node> nodes;\n        private final String token;\n        private final int start;\n        private final int end;\n\n        Node(Type type, int start, int end, String token) {\n            this(type, start, end, null, token);\n        }\n\n        Node(Type type, int start, int end, List<Node> nodes) {\n            this(type, start, end, nodes, null);\n        }\n\n        private Node(Type type, int start, int end, List<Node> nodes, String token) {\n            this.type = requireNonNull(type);\n            this.nodes = nodes;\n            this.token = token;\n            this.start = start;\n            this.end = end;\n        }\n\n        enum Type {\n            TEXT_NODE,\n            OPTIONAL_NODE,\n            ALTERNATION_NODE,\n            ALTERNATIVE_NODE,\n            PARAMETER_NODE,\n            EXPRESSION_NODE\n        }\n\n        public int start() {\n            return start;\n        }\n\n        public int end() {\n            return end;\n        }\n\n        List<Node> nodes() {\n            return nodes;\n        }\n\n        Type type() {\n            return type;\n        }\n\n        String text() {\n            if (nodes == null)\n                return token;\n\n            return nodes().stream()\n                    .map(Node::text)\n                    .collect(joining());\n        }\n\n        @Override\n        public String toString() {\n            return toString(0).toString();\n        }\n\n        private StringBuilder toString(int depth) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < depth; i++) {\n                sb.append(\"  \");\n            }\n            sb.append(\"{\")\n                    .append(\"\\\"type\\\": \\\"\").append(type)\n                    .append(\"\\\", \\\"start\\\": \")\n                    .append(start)\n                    .append(\", \\\"end\\\": \")\n                    .append(end);\n\n            if (token != null) {\n                sb.append(\", \\\"token\\\": \\\"\").append(token.replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\")).append(\"\\\"\");\n            }\n\n            if (nodes != null) {\n                sb.append(\", \\\"nodes\\\": \");\n                if (!nodes.isEmpty()) {\n                StringBuilder padding = new StringBuilder();\n                for (int i = 0; i < depth; i++) {\n                    padding.append(\"  \");\n                }\n                sb.append(nodes.stream()\n                        .map(node -> node.toString(depth + 1))\n                        .collect(joining(\",\\n\", \"[\\n\", \"\\n\" +padding + \"]\")));\n\n                } else {\n                    sb.append(\"[]\");\n                }\n            }\n            sb.append(\"}\");\n            return sb;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Node node = (Node) o;\n            return start == node.start &&\n                    end == node.end &&\n                    type == node.type &&\n                    Objects.equals(nodes, node.nodes) &&\n                    Objects.equals(token, node.token);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(type, nodes, token, start, end);\n        }\n\n    }\n\n    static final class Token implements Located {\n\n        final String text;\n        final Token.Type type;\n        final int start;\n        final int end;\n\n        Token(String text, Token.Type type, int start, int end) {\n            this.text = requireNonNull(text);\n            this.type = requireNonNull(type);\n            this.start = start;\n            this.end = end;\n        }\n\n        static boolean canEscape(Integer token) {\n            if (Character.isWhitespace(token)) {\n                return true;\n            }\n            switch (token) {\n                case (int) escapeCharacter:\n                case (int) alternationCharacter:\n                case (int) beginParameterCharacter:\n                case (int) endParameterCharacter:\n                case (int) beginOptionalCharacter:\n                case (int) endOptionalCharacter:\n                    return true;\n            }\n            return false;\n        }\n\n        static Type typeOf(Integer token) {\n            if (Character.isWhitespace(token)) {\n                return Type.WHITE_SPACE;\n            }\n            switch (token) {\n                case (int) alternationCharacter:\n                    return Type.ALTERNATION;\n                case (int) beginParameterCharacter:\n                    return Type.BEGIN_PARAMETER;\n                case (int) endParameterCharacter:\n                    return Type.END_PARAMETER;\n                case (int) beginOptionalCharacter:\n                    return Type.BEGIN_OPTIONAL;\n                case (int) endOptionalCharacter:\n                    return Type.END_OPTIONAL;\n            }\n            return Type.TEXT;\n        }\n\n        static boolean isEscapeCharacter(int token) {\n            return token == escapeCharacter;\n        }\n\n        public int start() {\n            return start;\n        }\n\n        public int end() {\n            return end;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o)\n                return true;\n            if (o == null || getClass() != o.getClass())\n                return false;\n            Token token = (Token) o;\n            return start == token.start &&\n                    end == token.end &&\n                    text.equals(token.text) &&\n                    type == token.type;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(start, end, text, type);\n        }\n\n        @Override\n        public String toString() {\n            return new StringJoiner(\", \", \"\" + \"{\", \"}\")\n                    .add(\"\\\"type\\\": \\\"\" + type + \"\\\"\")\n                    .add(\"\\\"start\\\": \" + start + \"\")\n                    .add(\"\\\"end\\\": \" + end + \"\")\n                    .add(\"\\\"text\\\": \\\"\" + text + \"\\\"\")\n                    .toString();\n        }\n\n        enum Type {\n            START_OF_LINE,\n            END_OF_LINE,\n            WHITE_SPACE,\n            BEGIN_OPTIONAL(\"\" + beginOptionalCharacter, \"optional text\"),\n            END_OPTIONAL(\"\" + endOptionalCharacter, \"optional text\"),\n            BEGIN_PARAMETER(\"\" + beginParameterCharacter, \"a parameter\"),\n            END_PARAMETER(\"\" + endParameterCharacter, \"a parameter\"),\n            ALTERNATION(\"\" + alternationCharacter, \"alternation\"),\n            TEXT;\n\n            private final String symbol;\n            private final String purpose;\n\n            Type() {\n                this(null, null);\n            }\n\n            Type(String symbol, String purpose) {\n                this.symbol = symbol;\n                this.purpose = purpose;\n            }\n\n            String purpose() {\n                return requireNonNull(purpose, name() + \" does not have a purpose\");\n            }\n\n            String symbol() {\n                return requireNonNull(symbol, name() + \" does not have a symbol\");\n            }\n        }\n\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final char escapeCharacter = '\\\\';", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "escapeCharacter = '\\\\'", "syntax_pass": true}, {"attribute_expression": "private static final char alternationCharacter = '/';", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "alternationCharacter = '/'", "syntax_pass": true}, {"attribute_expression": "private static final char beginParameterCharacter = '{';", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "beginParameterCharacter = '{'", "syntax_pass": true}, {"attribute_expression": "private static final char endParameterCharacter = '}';", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "endParameterCharacter = '}'", "syntax_pass": true}, {"attribute_expression": "private static final char beginOptionalCharacter = '(';", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "beginOptionalCharacter = '('", "syntax_pass": true}, {"attribute_expression": "private static final char endOptionalCharacter = ')';", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "char", "name": "endOptionalCharacter = ')'", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser", "name": "CucumberExpressionParser", "file_path": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java", "superclasses": "", "methods": ["[Node]parse(String)", "[Parser]parseBetween(Node.Type,Type,Type,List<Parser>)", "[Result]parseTokensUntil(String,List<Parser>,List<Token>,int)", "[Result]parseToken(String,List<Parser>,List<Token>,int)", "[boolean]lookingAtAny(List<Token>,int)", "[boolean]lookingAt(List<Token>,int,Type)", "[List<Node>]splitAlternatives(int,int,List<Node>)", "[List<Node>]createAlternativeNodes(int,int,List<Node>,List<List<Node>>)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[Node]parse(String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[Parser]parseBetween(Node.Type,Type,Type,List<Parser>)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[Result]parseTokensUntil(String,List<Parser>,List<Token>,int)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[Result]parseToken(String,List<Parser>,List<Token>,int)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[boolean]lookingAtAny(List<Token>,int)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[boolean]lookingAt(List<Token>,int,Type)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[List<Node>]splitAlternatives(int,int,List<Node>)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpressionParser.java.CucumberExpressionParser.[List<Node>]createAlternativeNodes(int,int,List<Node>,List<List<Node>>)"], "overrides": null, "attributes": [{"original_string": "    private static final class Result {\n        final int consumed;\n        final List<Node> ast;\n\n        private Result(int consumed, Node... ast) {\n            this(consumed, Arrays.asList(ast));\n        }\n\n        private Result(int consumed, List<Node> ast) {\n            this.consumed = consumed;\n            this.ast = ast;\n        }\n\n    }", "definition": "    private static final class Result", "class_docstring": "", "name": "Result", "super_interfaces": [], "superclasses": "", "attributes": {"modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "fields": [{"attribute_expression": "final int consumed;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "int", "name": "consumed", "syntax_pass": true}, {"attribute_expression": "final List<Node> ast;", "docstring": "", "modifiers": "final", "marker_annotations": [], "non_marker_annotations": ["final"], "comments": [], "type": "List<Node>", "name": "ast", "syntax_pass": true}], "classes": []}, "syntax_pass": true, "methods": [{"syntax_pass": true, "original_string": "        private Result(int consumed, Node... ast) {\n            this(consumed, Arrays.asList(ast));\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Result", "params": [{"name": "consumed", "type": "int"}], "body": "                                                  {\n            this(consumed, Arrays.asList(ast));\n        }", "signature": "private Result(int consumed, Node... ast)"}, {"syntax_pass": true, "original_string": "        private Result(int consumed, List<Node> ast) {\n            this.consumed = consumed;\n            this.ast = ast;\n        }", "docstring": "", "attributes": {"modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "return_type": "", "classes": []}, "name": "Result", "params": [{"name": "consumed", "type": "int"}, {"name": "ast", "type": "List<Node>"}], "body": "                                                     {\n            this.consumed = consumed;\n            this.ast = ast;\n        }", "signature": "private Result(int consumed, List<Node> ast)"}]}], "class_docstring": "", "original_string": "final class CucumberExpressionParser {\n\n    /*\n     * text := whitespace | ')' | '}' | .\n     */\n    private static final Parser textParser = (expression, tokens, current) -> {\n        Token token = tokens.get(current);\n        switch (token.type) {\n            case WHITE_SPACE:\n            case TEXT:\n            case END_PARAMETER:\n            case END_OPTIONAL:\n                return new Result(1, new Node(TEXT_NODE, token.start(), token.end(), token.text));\n            case ALTERNATION:\n                throw createAlternationNotAllowedInOptional(expression, token);\n            case BEGIN_PARAMETER:\n            case START_OF_LINE:\n            case END_OF_LINE:\n            case BEGIN_OPTIONAL:\n            default:\n                // If configured correctly this will never happen\n                return new Result(0);\n        }\n    };\n\n    /*\n     * name := whitespace | .\n     */\n    private static final Parser nameParser = (expression, tokens, current) -> {\n        Token token = tokens.get(current);\n        switch (token.type) {\n            case WHITE_SPACE:\n            case TEXT:\n                return new Result(1, new Node(TEXT_NODE, token.start(), token.end(), token.text));\n            case BEGIN_OPTIONAL:\n            case END_OPTIONAL:\n            case BEGIN_PARAMETER:\n            case END_PARAMETER:\n            case ALTERNATION:\n                throw createInvalidParameterTypeName(token, expression);\n            case START_OF_LINE:\n            case END_OF_LINE:\n            default:\n                // If configured correctly this will never happen\n                return new Result(0);\n        }\n    };\n\n    /*\n     * parameter := '{' + name* + '}'\n     */\n    private static final Parser parameterParser = parseBetween(\n            PARAMETER_NODE,\n            BEGIN_PARAMETER,\n            END_PARAMETER,\n            singletonList(nameParser)\n    );\n\n    /*\n     * optional := '(' + option* + ')'\n     * option := optional | parameter | text\n     */\n    private static final Parser optionalParser;\n    static {\n        List<Parser> parsers = new ArrayList<>();\n        optionalParser = parseBetween(\n                OPTIONAL_NODE,\n                BEGIN_OPTIONAL,\n                END_OPTIONAL,\n                parsers\n        );\n        parsers.addAll(asList(optionalParser, parameterParser, textParser));\n    }\n\n    /*\n     * alternation := alternative* + ( '/' + alternative* )+\n     */\n    private static final Parser alternativeSeparator = (expression, tokens, current) -> {\n        if (!lookingAt(tokens, current, ALTERNATION)) {\n            return new Result(0);\n        }\n        Token token = tokens.get(current);\n        return new Result(1, new Node(ALTERNATIVE_NODE, token.start(), token.end(), token.text));\n    };\n\n    private static final List<Parser> alternativeParsers = asList(\n            alternativeSeparator,\n            optionalParser,\n            parameterParser,\n            textParser\n    );\n\n    /*\n     * alternation := (?<=left-boundary) + alternative* + ( '/' + alternative* )+ + (?=right-boundary)\n     * left-boundary := whitespace | } | ^\n     * right-boundary := whitespace | { | $\n     * alternative: = optional | parameter | text\n     */\n    private static final Parser alternationParser = (expression, tokens, current) -> {\n        int previous = current - 1;\n        if (!lookingAtAny(tokens, previous, START_OF_LINE, WHITE_SPACE, END_PARAMETER)) {\n            return new Result(0);\n        }\n\n        Result result = parseTokensUntil(expression, alternativeParsers, tokens, current, WHITE_SPACE, END_OF_LINE, BEGIN_PARAMETER);\n        int subCurrent = current + result.consumed;\n        if (result.ast.stream().noneMatch(astNode -> astNode.type() == ALTERNATIVE_NODE)) {\n            return new Result(0);\n        }\n\n        int start = tokens.get(current).start();\n        int end = tokens.get(subCurrent).start();\n        // Does not consume right hand boundary token\n        return new Result(result.consumed,\n                new Node(ALTERNATION_NODE, start, end, splitAlternatives(start, end, result.ast)));\n    };\n\n    /*\n     * cucumber-expression :=  ( alternation | optional | parameter | text )*\n     */\n    private static final Parser cucumberExpressionParser = parseBetween(\n            EXPRESSION_NODE,\n            START_OF_LINE,\n            END_OF_LINE,\n            asList(\n                    alternationParser,\n                    optionalParser,\n                    parameterParser,\n                    textParser\n            )\n    );\n\n    Node parse(String expression) {\n        CucumberExpressionTokenizer tokenizer = new CucumberExpressionTokenizer();\n        List<Token> tokens = tokenizer.tokenize(expression);\n        Result result = cucumberExpressionParser.parse(expression, tokens, 0);\n        return result.ast.get(0);\n    }\n\n    private interface Parser {\n        Result parse(String expression, List<Token> tokens, int current);\n\n    }\n\n    private static final class Result {\n        final int consumed;\n        final List<Node> ast;\n\n        private Result(int consumed, Node... ast) {\n            this(consumed, Arrays.asList(ast));\n        }\n\n        private Result(int consumed, List<Node> ast) {\n            this.consumed = consumed;\n            this.ast = ast;\n        }\n\n    }\n\n    private static Parser parseBetween(\n            Node.Type type,\n            Type beginToken,\n            Type endToken,\n            List<Parser> parsers) {\n        return (expression, tokens, current) -> {\n            if (!lookingAt(tokens, current, beginToken)) {\n                return new Result(0);\n            }\n            int subCurrent = current + 1;\n            Result result = parseTokensUntil(expression, parsers, tokens, subCurrent, endToken, END_OF_LINE);\n            subCurrent += result.consumed;\n\n            // endToken not found\n            if (!lookingAt(tokens, subCurrent, endToken)) {\n                throw createMissingEndToken(expression, beginToken, endToken, tokens.get(current));\n            }\n            // consumes endToken\n            int start = tokens.get(current).start();\n            int end = tokens.get(subCurrent).end();\n            return new Result(subCurrent + 1 - current, new Node(type, start, end, result.ast));\n        };\n    }\n\n    private static Result parseTokensUntil(\n            String expression,\n            List<Parser> parsers,\n            List<Token> tokens,\n            int startAt,\n            Type... endTokens) {\n        int current = startAt;\n        int size = tokens.size();\n        List<Node> ast = new ArrayList<>();\n        while (current < size) {\n            if (lookingAtAny(tokens, current, endTokens)) {\n                break;\n            }\n\n            Result result = parseToken(expression, parsers, tokens, current);\n            if (result.consumed == 0) {\n                // If configured correctly this will never happen\n                // Keep to avoid infinite loops\n                throw new IllegalStateException(\"No eligible parsers for \" + tokens);\n            }\n            current += result.consumed;\n            ast.addAll(result.ast);\n        }\n        return new Result(current - startAt, ast);\n    }\n\n    private static Result parseToken(String expression, List<Parser> parsers,\n            List<Token> tokens,\n            int startAt) {\n        for (Parser parser : parsers) {\n            Result result = parser.parse(expression, tokens, startAt);\n            if (result.consumed != 0) {\n                return result;\n            }\n        }\n        // If configured correctly this will never happen\n        throw new IllegalStateException(\"No eligible parsers for \" + tokens);\n    }\n\n    private static boolean lookingAtAny(List<Token> tokens, int at, Type... tokenTypes) {\n        for (Type tokeType : tokenTypes) {\n            if (lookingAt(tokens, at, tokeType)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean lookingAt(List<Token> tokens, int at, Type token) {\n        if (at < 0) {\n            // If configured correctly this will never happen\n            // Keep for completeness\n            return token == START_OF_LINE;\n        }\n        if (at >= tokens.size()) {\n            return token == END_OF_LINE;\n        }\n        return tokens.get(at).type == token;\n    }\n\n    private static List<Node> splitAlternatives(int start, int end, List<Node> alternation) {\n        List<Node> separators = new ArrayList<>();\n        List<List<Node>> alternatives = new ArrayList<>();\n        List<Node> alternative = new ArrayList<>();\n        for (Node n : alternation) {\n            if (ALTERNATIVE_NODE.equals(n.type())) {\n                separators.add(n);\n                alternatives.add(alternative);\n                alternative = new ArrayList<>();\n            } else {\n                alternative.add(n);\n            }\n        }\n        alternatives.add(alternative);\n\n        return createAlternativeNodes(start, end, separators, alternatives);\n    }\n\n    private static List<Node> createAlternativeNodes(int start, int end, List<Node> separators, List<List<Node>> alternatives) {\n        List<Node> nodes = new ArrayList<>();\n        for (int i = 0; i < alternatives.size(); i++) {\n            List<Node> n = alternatives.get(i);\n            if (i == 0) {\n                Node rightSeparator = separators.get(i);\n                nodes.add(new Node(ALTERNATIVE_NODE, start, rightSeparator.start(), n));\n            } else if (i == alternatives.size() - 1) {\n                Node leftSeparator = separators.get(i - 1);\n                nodes.add(new Node(ALTERNATIVE_NODE, leftSeparator.end(), end, n));\n            } else {\n                Node leftSeparator = separators.get(i - 1);\n                Node rightSeparator = separators.get(i);\n                nodes.add(new Node(ALTERNATIVE_NODE, leftSeparator.end(), rightSeparator.start(), n));\n            }\n        }\n        return nodes;\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Parser textParser = (expression, tokens, current) -> {\n        Token token = tokens.get(current);\n        switch (token.type) {\n            case WHITE_SPACE:\n            case TEXT:\n            case END_PARAMETER:\n            case END_OPTIONAL:\n                return new Result(1, new Node(TEXT_NODE, token.start(), token.end(), token.text));\n            case ALTERNATION:\n                throw createAlternationNotAllowedInOptional(expression, token);\n            case BEGIN_PARAMETER:\n            case START_OF_LINE:\n            case END_OF_LINE:\n            case BEGIN_OPTIONAL:\n            default:\n                // If configured correctly this will never happen\n                return new Result(0);\n        }\n    };", "docstring": "\ntext := whitespace | ')' | '}' | .\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Parser", "name": "textParser = (expression, tokens, current) -> {\n        Token token = tokens.get(current);\n        switch (token.type) {\n            case WHITE_SPACE:\n            case TEXT:\n            case END_PARAMETER:\n            case END_OPTIONAL:\n                return new Result(1, new Node(TEXT_NODE, token.start(), token.end(), token.text));\n            case ALTERNATION:\n                throw createAlternationNotAllowedInOptional(expression, token);\n            case BEGIN_PARAMETER:\n            case START_OF_LINE:\n            case END_OF_LINE:\n            case BEGIN_OPTIONAL:\n            default:\n                // If configured correctly this will never happen\n                return new Result(0);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "private static final Parser nameParser = (expression, tokens, current) -> {\n        Token token = tokens.get(current);\n        switch (token.type) {\n            case WHITE_SPACE:\n            case TEXT:\n                return new Result(1, new Node(TEXT_NODE, token.start(), token.end(), token.text));\n            case BEGIN_OPTIONAL:\n            case END_OPTIONAL:\n            case BEGIN_PARAMETER:\n            case END_PARAMETER:\n            case ALTERNATION:\n                throw createInvalidParameterTypeName(token, expression);\n            case START_OF_LINE:\n            case END_OF_LINE:\n            default:\n                // If configured correctly this will never happen\n                return new Result(0);\n        }\n    };", "docstring": "\nname := whitespace | .\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Parser", "name": "nameParser = (expression, tokens, current) -> {\n        Token token = tokens.get(current);\n        switch (token.type) {\n            case WHITE_SPACE:\n            case TEXT:\n                return new Result(1, new Node(TEXT_NODE, token.start(), token.end(), token.text));\n            case BEGIN_OPTIONAL:\n            case END_OPTIONAL:\n            case BEGIN_PARAMETER:\n            case END_PARAMETER:\n            case ALTERNATION:\n                throw createInvalidParameterTypeName(token, expression);\n            case START_OF_LINE:\n            case END_OF_LINE:\n            default:\n                // If configured correctly this will never happen\n                return new Result(0);\n        }\n    }", "syntax_pass": true}, {"attribute_expression": "private static final Parser parameterParser = parseBetween(\n            PARAMETER_NODE,\n            BEGIN_PARAMETER,\n            END_PARAMETER,\n            singletonList(nameParser)\n    );", "docstring": "\nparameter := '{' + name* + '}'\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Parser", "name": "parameterParser = parseBetween(\n            PARAMETER_NODE,\n            BEGIN_PARAMETER,\n            END_PARAMETER,\n            singletonList(nameParser)\n    )", "syntax_pass": true}, {"attribute_expression": "private static final Parser optionalParser;", "docstring": "\noptional := '(' + option* + ')'\noption := optional | parameter | text\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Parser", "name": "optionalParser", "syntax_pass": true}, {"attribute_expression": "private static final Parser alternativeSeparator = (expression, tokens, current) -> {\n        if (!lookingAt(tokens, current, ALTERNATION)) {\n            return new Result(0);\n        }\n        Token token = tokens.get(current);\n        return new Result(1, new Node(ALTERNATIVE_NODE, token.start(), token.end(), token.text));\n    };", "docstring": "\nalternation := alternative* + ( '/' + alternative* )+\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Parser", "name": "alternativeSeparator = (expression, tokens, current) -> {\n        if (!lookingAt(tokens, current, ALTERNATION)) {\n            return new Result(0);\n        }\n        Token token = tokens.get(current);\n        return new Result(1, new Node(ALTERNATIVE_NODE, token.start(), token.end(), token.text));\n    }", "syntax_pass": true}, {"attribute_expression": "private static final List<Parser> alternativeParsers = asList(\n            alternativeSeparator,\n            optionalParser,\n            parameterParser,\n            textParser\n    );", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List<Parser>", "name": "alternativeParsers = asList(\n            alternativeSeparator,\n            optionalParser,\n            parameterParser,\n            textParser\n    )", "syntax_pass": true}, {"attribute_expression": "private static final Parser alternationParser = (expression, tokens, current) -> {\n        int previous = current - 1;\n        if (!lookingAtAny(tokens, previous, START_OF_LINE, WHITE_SPACE, END_PARAMETER)) {\n            return new Result(0);\n        }\n\n        Result result = parseTokensUntil(expression, alternativeParsers, tokens, current, WHITE_SPACE, END_OF_LINE, BEGIN_PARAMETER);\n        int subCurrent = current + result.consumed;\n        if (result.ast.stream().noneMatch(astNode -> astNode.type() == ALTERNATIVE_NODE)) {\n            return new Result(0);\n        }\n\n        int start = tokens.get(current).start();\n        int end = tokens.get(subCurrent).start();\n        // Does not consume right hand boundary token\n        return new Result(result.consumed,\n                new Node(ALTERNATION_NODE, start, end, splitAlternatives(start, end, result.ast)));\n    };", "docstring": "\nalternation := (?<=left-boundary) + alternative* + ( '/' + alternative* )+ + (?=right-boundary)\nleft-boundary := whitespace | } | ^\nright-boundary := whitespace | { | $\nalternative: = optional | parameter | text\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Parser", "name": "alternationParser = (expression, tokens, current) -> {\n        int previous = current - 1;\n        if (!lookingAtAny(tokens, previous, START_OF_LINE, WHITE_SPACE, END_PARAMETER)) {\n            return new Result(0);\n        }\n\n        Result result = parseTokensUntil(expression, alternativeParsers, tokens, current, WHITE_SPACE, END_OF_LINE, BEGIN_PARAMETER);\n        int subCurrent = current + result.consumed;\n        if (result.ast.stream().noneMatch(astNode -> astNode.type() == ALTERNATIVE_NODE)) {\n            return new Result(0);\n        }\n\n        int start = tokens.get(current).start();\n        int end = tokens.get(subCurrent).start();\n        // Does not consume right hand boundary token\n        return new Result(result.consumed,\n                new Node(ALTERNATION_NODE, start, end, splitAlternatives(start, end, result.ast)));\n    }", "syntax_pass": true}, {"attribute_expression": "private static final Parser cucumberExpressionParser = parseBetween(\n            EXPRESSION_NODE,\n            START_OF_LINE,\n            END_OF_LINE,\n            asList(\n                    alternationParser,\n                    optionalParser,\n                    parameterParser,\n                    textParser\n            )\n    );", "docstring": "\ncucumber-expression :=  ( alternation | optional | parameter | text )*\n", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Parser", "name": "cucumberExpressionParser = parseBetween(\n            EXPRESSION_NODE,\n            START_OF_LINE,\n            END_OF_LINE,\n            asList(\n                    alternationParser,\n                    optionalParser,\n                    parameterParser,\n                    textParser\n            )\n    )", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer", "name": "BuiltInParameterTransformer", "file_path": "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java", "superclasses": "", "methods": ["[]BuiltInParameterTransformer(Locale)", "[Object]transform(String,Type)", "[Object]doTransform(String,Type,Type)", "[Type]getOptionalGenericType(Type)", "[IllegalArgumentException]createIllegalArgumentException(String,Type)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer.[]BuiltInParameterTransformer(Locale)", "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer.[Object]transform(String,Type)", "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer.[Object]doTransform(String,Type,Type)", "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer.[Type]getOptionalGenericType(Type)", "src/main/java/io/cucumber/cucumberexpressions/BuiltInParameterTransformer.java.BuiltInParameterTransformer.[IllegalArgumentException]createIllegalArgumentException(String,Type)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class BuiltInParameterTransformer implements ParameterByTypeTransformer {\n\n    private final NumberParser numberParser;\n\n    BuiltInParameterTransformer(Locale locale) {\n        this.numberParser = new NumberParser(locale);\n    }\n\n    @Override\n    public Object transform(String fromValue, Type toValueType) {\n        return doTransform(fromValue, toValueType, toValueType);\n    }\n\n    private Object doTransform(String fromValue, Type toValueType, Type originalToValueType) {\n        Type optionalValueType;\n        if ((optionalValueType = getOptionalGenericType(toValueType)) != null) {\n            Object wrappedValue = doTransform(fromValue, optionalValueType, originalToValueType);\n            return Optional.ofNullable(wrappedValue);\n        }\n\n        if (!(toValueType instanceof Class)) {\n            throw createIllegalArgumentException(fromValue, originalToValueType);\n        }\n\n        Class<?> toValueClass = (Class<?>) requireNonNull(toValueType);\n        if (fromValue == null) {\n            return null;\n        }\n\n        if (String.class.equals(toValueClass) || Object.class.equals(toValueClass)) {\n            return fromValue;\n        }\n\n        if (Character.class.equals(toValueClass) || char.class.equals(toValueClass)) {\n            if(fromValue.length() == 1) {\n                return fromValue.charAt(0);\n            }\n        }\n\n        if (BigInteger.class.equals(toValueClass)) {\n            return new BigInteger(fromValue);\n        }\n\n        if (BigDecimal.class.equals(toValueClass) || Number.class.equals(toValueClass)) {\n            return numberParser.parseBigDecimal(fromValue);\n        }\n\n        if (Byte.class.equals(toValueClass) || byte.class.equals(toValueClass)) {\n            return Byte.decode(fromValue);\n        }\n\n        if (Short.class.equals(toValueClass) || short.class.equals(toValueClass)) {\n            return Short.decode(fromValue);\n        }\n\n        if (Integer.class.equals(toValueClass) || int.class.equals(toValueClass)) {\n            return Integer.decode(fromValue);\n        }\n\n        if (Long.class.equals(toValueClass) || long.class.equals(toValueClass)) {\n            return Long.decode(fromValue);\n        }\n\n        if (Float.class.equals(toValueClass) || float.class.equals(toValueClass)) {\n            return numberParser.parseFloat(fromValue);\n        }\n\n        if (Double.class.equals(toValueClass) || double.class.equals(toValueClass)) {\n            return numberParser.parseDouble(fromValue);\n        }\n\n        if (Boolean.class.equals(toValueClass) || boolean.class.equals(toValueClass)) {\n            return Boolean.parseBoolean(fromValue);\n        }\n\n        if (toValueClass.isEnum()) {\n            @SuppressWarnings(\"unchecked\")\n            Class<? extends Enum<?>> enumClass = (Class<? extends Enum<?>>) toValueClass;\n            for (Enum<?> enumConstant : enumClass.getEnumConstants()) {\n                if (enumConstant.name().equals(fromValue)) {\n                    return enumConstant;\n                }\n            }\n            throw new CucumberExpressionException(\"Can't transform '\" + fromValue + \"' to \" + originalToValueType + \". \" +\n                    \"Not an enum constant\");\n        }\n\n        throw createIllegalArgumentException(fromValue, originalToValueType);\n    }\n\n    private Type getOptionalGenericType(Type type) {\n        if (Optional.class.equals(type)) {\n            return Object.class;\n        }\n\n        if (!(type instanceof ParameterizedType)) {\n            return null;\n        }\n\n        ParameterizedType parameterizedType = (ParameterizedType) type;\n        if (Optional.class.equals(parameterizedType.getRawType())) {\n            return parameterizedType.getActualTypeArguments()[0];\n        }\n\n        return null;\n    }\n\n    private IllegalArgumentException createIllegalArgumentException(String fromValue, Type toValueType) {\n        return new IllegalArgumentException(\n                \"Can't transform '\" + fromValue + \"' to \" + toValueType + \"\\n\" +\n                        \"BuiltInParameterTransformer only supports a limited number of class types\\n\" +\n                        \"Consider using a different object mapper or register a parameter type for \" + toValueType\n        );\n    }\n\n}", "super_interfaces": ["ParameterByTypeTransformer"], "fields": [{"attribute_expression": "private final NumberParser numberParser;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NumberParser", "name": "numberParser", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser", "name": "NumberParser", "file_path": "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java", "superclasses": "", "methods": ["[]NumberParser(Locale)", "[double]parseDouble(String)", "[float]parseFloat(String)", "[BigDecimal]parseBigDecimal(String)", "[Number]parse(String)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser.[]NumberParser(Locale)", "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser.[double]parseDouble(String)", "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser.[float]parseFloat(String)", "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser.[BigDecimal]parseBigDecimal(String)", "src/main/java/io/cucumber/cucumberexpressions/NumberParser.java.NumberParser.[Number]parse(String)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class NumberParser {\n    private final NumberFormat numberFormat;\n\n    NumberParser(Locale locale) {\n        numberFormat = DecimalFormat.getNumberInstance(locale);\n        if (numberFormat instanceof DecimalFormat) {\n            DecimalFormat decimalFormat = (DecimalFormat) numberFormat;\n            decimalFormat.setParseBigDecimal(true);\n            DecimalFormatSymbols symbols = KeyboardFriendlyDecimalFormatSymbols.getInstance(locale);\n            decimalFormat.setDecimalFormatSymbols(symbols);\n        }\n    }\n\n    double parseDouble(String s) {\n        return parse(s).doubleValue();\n    }\n\n    float parseFloat(String s) {\n        return parse(s).floatValue();\n    }\n\n    BigDecimal parseBigDecimal(String s) {\n        if (numberFormat instanceof DecimalFormat) {\n            return (BigDecimal) parse(s);\n        }\n        // Fall back to default big decimal format\n        // if the locale does not have a DecimalFormat\n        return new BigDecimal(s);\n    }\n\n    private Number parse(String s) {\n        try {\n            return numberFormat.parse(s);\n        } catch (ParseException e) {\n            throw new CucumberExpressionException(\"Failed to parse number\", e);\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final NumberFormat numberFormat;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "NumberFormat", "name": "numberFormat", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry", "name": "ParameterTypeRegistry", "file_path": "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java", "superclasses": "", "methods": ["[]ParameterTypeRegistry(Locale)", "[]ParameterTypeRegistry(ParameterByTypeTransformer,Locale)", "[void]defineParameterType(ParameterType<?>)", "[ParameterByTypeTransformer]getDefaultParameterTransformer()", "[void]setDefaultParameterTransformer(ParameterByTypeTransformer)", "[ParameterType<T>]lookupByTypeName(String)", "[ParameterType<T>]lookupByRegexp(String,Pattern,String)", "[Collection<ParameterType<?>>]getParameterTypes()"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[]ParameterTypeRegistry(Locale)", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[]ParameterTypeRegistry(ParameterByTypeTransformer,Locale)", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[void]defineParameterType(ParameterType<?>)", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[ParameterByTypeTransformer]getDefaultParameterTransformer()", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[void]setDefaultParameterTransformer(ParameterByTypeTransformer)", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[ParameterType<T>]lookupByTypeName(String)", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[ParameterType<T>]lookupByRegexp(String,Pattern,String)", "src/main/java/io/cucumber/cucumberexpressions/ParameterTypeRegistry.java.ParameterTypeRegistry.[Collection<ParameterType<?>>]getParameterTypes()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@API(status = API.Status.STABLE)\npublic final class ParameterTypeRegistry {\n    // Pattern.compile(...).pattern() is not necessary, but it helps us take advantage of the IntelliJ's regexp validation,\n    // which detects unneeded escapes.\n    private static final List<String> INTEGER_REGEXPS = asList(\n            Pattern.compile(\"-?\\\\d+\").pattern(),\n            Pattern.compile(\"\\\\d+\").pattern()\n    );\n    private static final String SIGN = \"[-+]?\";\n    private static final String MUST_CONTAIN_NUMBER = \"(?=.*\\\\d.*)\";\n    private static final String SCIENTIFIC_NUMBER = \"(?:\\\\d+[{expnt}]-?\\\\d+)?\";\n    private static final String DECIMAL_FRACTION = \"(?:[{decimal}](?=\\\\d.*))?\\\\d*\";\n    private static final String INTEGER = \"(?:\\\\d+(?:[{group}]?\\\\d+)*)*\";\n    private static final String FLOAT_REGEXPS =\n            Pattern.compile(MUST_CONTAIN_NUMBER + SIGN + INTEGER + DECIMAL_FRACTION + SCIENTIFIC_NUMBER).pattern();\n    private static final List<String> WORD_REGEXPS = singletonList(\n            Pattern.compile(\"[^\\\\s]+\").pattern()\n    );\n    private static final List<String> STRING_REGEXPS = asList(\n            Pattern.compile(\"\\\"([^\\\"\\\\\\\\]*(\\\\\\\\.[^\\\"\\\\\\\\]*)*)\\\"\").pattern(),\n            Pattern.compile(\"'([^'\\\\\\\\]*(\\\\\\\\.[^'\\\\\\\\]*)*)'\").pattern()\n    );\n    private static final String ANONYMOUS_REGEX = Pattern.compile(\".*\").pattern();\n    private final Map<String, ParameterType<?>> parameterTypeByName = new HashMap<>();\n    private final Map<String, SortedSet<ParameterType<?>>> parameterTypesByRegexp = new HashMap<>();\n    /**\n     * To maintain consistency with `datatable` we don't use the mutable default\n     * transformer to handle build in in conversions yet.\n     */\n    private final ParameterByTypeTransformer internalParameterTransformer;\n    private ParameterByTypeTransformer defaultParameterTransformer;\n\n    public ParameterTypeRegistry(Locale locale) {\n        this(new BuiltInParameterTransformer(locale), locale);\n    }\n\n    private ParameterTypeRegistry(ParameterByTypeTransformer defaultParameterTransformer, Locale locale) {\n        this.internalParameterTransformer = defaultParameterTransformer;\n        this.defaultParameterTransformer = defaultParameterTransformer;\n\n        DecimalFormatSymbols numberFormat = KeyboardFriendlyDecimalFormatSymbols.getInstance(locale);\n\n        List<String> localizedFloatRegexp = singletonList(FLOAT_REGEXPS\n                .replace(\"{decimal}\", \"\" + numberFormat.getDecimalSeparator())\n                .replace(\"{group}\", \"\" + numberFormat.getGroupingSeparator())\n                .replace(\"{expnt}\", \"\" + numberFormat.getExponentSeparator())\n        );\n\n        defineParameterType(new ParameterType<>(\"biginteger\", INTEGER_REGEXPS, BigInteger.class, new Transformer<BigInteger>() {\n            @Override\n            public BigInteger transform(String arg) throws Throwable {\n                return (BigInteger) internalParameterTransformer.transform(arg, BigInteger.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"bigdecimal\", localizedFloatRegexp, BigDecimal.class, new Transformer<BigDecimal>() {\n            @Override\n            public BigDecimal transform(String arg) throws Throwable {\n                return (BigDecimal) internalParameterTransformer.transform(arg, BigDecimal.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"byte\", INTEGER_REGEXPS, Byte.class, new Transformer<Byte>() {\n            @Override\n            public Byte transform(String arg) throws Throwable {\n                return (Byte) internalParameterTransformer.transform(arg, Byte.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"short\", INTEGER_REGEXPS, Short.class, new Transformer<Short>() {\n            @Override\n            public Short transform(String arg) throws Throwable {\n                return (Short) internalParameterTransformer.transform(arg, Short.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"int\", INTEGER_REGEXPS, Integer.class, new Transformer<Integer>() {\n            @Override\n            public Integer transform(String arg) throws Throwable {\n                return (Integer) internalParameterTransformer.transform(arg, Integer.class);\n            }\n        }, true, true, false));\n        defineParameterType(new ParameterType<>(\"long\", INTEGER_REGEXPS, Long.class, new Transformer<Long>() {\n            @Override\n            public Long transform(String arg) throws Throwable {\n                return (Long) internalParameterTransformer.transform(arg, Long.class);\n            }\n        }, false, false));\n        defineParameterType(new ParameterType<>(\"float\", localizedFloatRegexp, Float.class, new Transformer<Float>() {\n            @Override\n            public Float transform(String arg) throws Throwable {\n                return (Float) internalParameterTransformer.transform(arg, Float.class);\n            }\n        }, false, false));\n        defineParameterType(new ParameterType<>(\"double\", localizedFloatRegexp, Double.class, new Transformer<Double>() {\n            @Override\n            public Double transform(String arg) throws Throwable {\n                return (Double) internalParameterTransformer.transform(arg, Double.class);\n            }\n        }, true, true, false));\n        defineParameterType(new ParameterType<>(\"word\", WORD_REGEXPS, String.class, new Transformer<String>() {\n            @Override\n            public String transform(String arg) throws Throwable {\n                return (String) internalParameterTransformer.transform(arg, String.class);\n            }\n        }, false, false, false));\n        defineParameterType(new ParameterType<>(\"string\", STRING_REGEXPS, String.class, new CaptureGroupTransformer<String>() {\n            @Override\n            public String transform(String... args) throws Throwable {\n                String arg = args[0] != null ? args[0] : args[1];\n                return (String) internalParameterTransformer.transform(arg\n                                .replaceAll(\"\\\\\\\\\\\"\", \"\\\"\")\n                                .replaceAll(\"\\\\\\\\'\", \"'\"),\n                        String.class);\n            }\n        }, true, false, false));\n\n        defineParameterType(createAnonymousParameterType(ANONYMOUS_REGEX));\n    }\n\n    public void defineParameterType(ParameterType<?> parameterType) {\n        if (parameterType.getName() != null) {\n            if (parameterTypeByName.containsKey(parameterType.getName())) {\n                if (parameterType.getName().isEmpty()) {\n                    throw new DuplicateTypeNameException(\"The anonymous parameter type has already been defined\");\n                }\n                throw new DuplicateTypeNameException(String.format(\"There is already a parameter type with name %s\", parameterType.getName()));\n            }\n            parameterTypeByName.put(parameterType.getName(), parameterType);\n        }\n\n        for (String parameterTypeRegexp : parameterType.getRegexps()) {\n            if (!parameterTypesByRegexp.containsKey(parameterTypeRegexp)) {\n                parameterTypesByRegexp.put(parameterTypeRegexp, new TreeSet<ParameterType<?>>());\n            }\n            SortedSet<ParameterType<?>> parameterTypes = parameterTypesByRegexp.get(parameterTypeRegexp);\n            if (!parameterTypes.isEmpty() && parameterTypes.first().preferForRegexpMatch() && parameterType.preferForRegexpMatch()) {\n                throw new CucumberExpressionException(String.format(\n                        \"There can only be one preferential parameter type per regexp. \" +\n                                \"The regexp /%s/ is used for two preferential parameter types, {%s} and {%s}\",\n                        parameterTypeRegexp, parameterTypes.first().getName(), parameterType.getName()\n                ));\n            }\n            parameterTypes.add(parameterType);\n        }\n    }\n\n    ParameterByTypeTransformer getDefaultParameterTransformer() {\n        return defaultParameterTransformer;\n    }\n\n    public void setDefaultParameterTransformer(ParameterByTypeTransformer defaultParameterTransformer) {\n        this.defaultParameterTransformer = defaultParameterTransformer;\n    }\n\n    <T> ParameterType<T> lookupByTypeName(String typeName) {\n        return (ParameterType<T>) parameterTypeByName.get(typeName);\n    }\n\n    <T> ParameterType<T> lookupByRegexp(String parameterTypeRegexp, Pattern expressionRegexp, String text) {\n        SortedSet<ParameterType<?>> parameterTypes = parameterTypesByRegexp.get(parameterTypeRegexp);\n        if (parameterTypes == null) return null;\n        if (parameterTypes.size() > 1 && !parameterTypes.first().preferForRegexpMatch()) {\n            // We don't do this check on insertion because we only want to restrict\n            // ambiguity when we look up by Regexp. Users of CucumberExpression should\n            // not be restricted.\n            List<GeneratedExpression> generatedExpressions = new CucumberExpressionGenerator(this).generateExpressions(text);\n            throw new AmbiguousParameterTypeException(parameterTypeRegexp, expressionRegexp, parameterTypes, generatedExpressions);\n        }\n        return (ParameterType<T>) parameterTypes.first();\n    }\n\n    Collection<ParameterType<?>> getParameterTypes() {\n        return parameterTypeByName.values();\n    }\n\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final List<String> INTEGER_REGEXPS = asList(\n            Pattern.compile(\"-?\\\\d+\").pattern(),\n            Pattern.compile(\"\\\\d+\").pattern()\n    );", "docstring": " which detects unneeded escapes.", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List<String>", "name": "INTEGER_REGEXPS = asList(\n            Pattern.compile(\"-?\\\\d+\").pattern(),\n            Pattern.compile(\"\\\\d+\").pattern()\n    )", "syntax_pass": true}, {"attribute_expression": "private static final String SIGN = \"[-+]?\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "SIGN = \"[-+]?\"", "syntax_pass": true}, {"attribute_expression": "private static final String MUST_CONTAIN_NUMBER = \"(?=.*\\\\d.*)\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "MUST_CONTAIN_NUMBER = \"(?=.*\\\\d.*)\"", "syntax_pass": true}, {"attribute_expression": "private static final String SCIENTIFIC_NUMBER = \"(?:\\\\d+[{expnt}]-?\\\\d+)?\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "SCIENTIFIC_NUMBER = \"(?:\\\\d+[{expnt}]-?\\\\d+)?\"", "syntax_pass": true}, {"attribute_expression": "private static final String DECIMAL_FRACTION = \"(?:[{decimal}](?=\\\\d.*))?\\\\d*\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "DECIMAL_FRACTION = \"(?:[{decimal}](?=\\\\d.*))?\\\\d*\"", "syntax_pass": true}, {"attribute_expression": "private static final String INTEGER = \"(?:\\\\d+(?:[{group}]?\\\\d+)*)*\";", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "INTEGER = \"(?:\\\\d+(?:[{group}]?\\\\d+)*)*\"", "syntax_pass": true}, {"attribute_expression": "private static final String FLOAT_REGEXPS =\n            Pattern.compile(MUST_CONTAIN_NUMBER + SIGN + INTEGER + DECIMAL_FRACTION + SCIENTIFIC_NUMBER).pattern();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "FLOAT_REGEXPS =\n            Pattern.compile(MUST_CONTAIN_NUMBER + SIGN + INTEGER + DECIMAL_FRACTION + SCIENTIFIC_NUMBER).pattern()", "syntax_pass": true}, {"attribute_expression": "private static final List<String> WORD_REGEXPS = singletonList(\n            Pattern.compile(\"[^\\\\s]+\").pattern()\n    );", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List<String>", "name": "WORD_REGEXPS = singletonList(\n            Pattern.compile(\"[^\\\\s]+\").pattern()\n    )", "syntax_pass": true}, {"attribute_expression": "private static final List<String> STRING_REGEXPS = asList(\n            Pattern.compile(\"\\\"([^\\\"\\\\\\\\]*(\\\\\\\\.[^\\\"\\\\\\\\]*)*)\\\"\").pattern(),\n            Pattern.compile(\"'([^'\\\\\\\\]*(\\\\\\\\.[^'\\\\\\\\]*)*)'\").pattern()\n    );", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "List<String>", "name": "STRING_REGEXPS = asList(\n            Pattern.compile(\"\\\"([^\\\"\\\\\\\\]*(\\\\\\\\.[^\\\"\\\\\\\\]*)*)\\\"\").pattern(),\n            Pattern.compile(\"'([^'\\\\\\\\]*(\\\\\\\\.[^'\\\\\\\\]*)*)'\").pattern()\n    )", "syntax_pass": true}, {"attribute_expression": "private static final String ANONYMOUS_REGEX = Pattern.compile(\".*\").pattern();", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String", "name": "ANONYMOUS_REGEX = Pattern.compile(\".*\").pattern()", "syntax_pass": true}, {"attribute_expression": "private final Map<String, ParameterType<?>> parameterTypeByName = new HashMap<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, ParameterType<?>>", "name": "parameterTypeByName = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final Map<String, SortedSet<ParameterType<?>>> parameterTypesByRegexp = new HashMap<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "Map<String, SortedSet<ParameterType<?>>>", "name": "parameterTypesByRegexp = new HashMap<>()", "syntax_pass": true}, {"attribute_expression": "private final ParameterByTypeTransformer internalParameterTransformer;", "docstring": "\nTo maintain consistency with `datatable` we don't use the mutable default\ntransformer to handle build in in conversions yet.\n", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterByTypeTransformer", "name": "internalParameterTransformer", "syntax_pass": true}, {"attribute_expression": "private ParameterByTypeTransformer defaultParameterTransformer;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "ParameterByTypeTransformer", "name": "defaultParameterTransformer", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java.ExpressionFactory", "name": "ExpressionFactory", "file_path": "src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java", "superclasses": "", "methods": ["[]ExpressionFactory(ParameterTypeRegistry)", "[Expression]createExpression(String)", "[RegularExpression]createRegularExpressionWithAnchors(String)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java.ExpressionFactory.[]ExpressionFactory(ParameterTypeRegistry)", "src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java.ExpressionFactory.[Expression]createExpression(String)", "src/main/java/io/cucumber/cucumberexpressions/ExpressionFactory.java.ExpressionFactory.[RegularExpression]createRegularExpressionWithAnchors(String)"], "overrides": null, "attributes": [], "class_docstring": "\nCreates a {@link CucumberExpression} or {@link RegularExpression} from a {@link String}\nusing heuristics. This is particularly useful for languages that don't have a\nliteral syntax for regular expressions. In Java, a regular expression has to be represented as a String.\n\n A string that starts with `^` and/or ends with `$` (or written in script style, i.e. starting with `/` \n and ending with `/`) is considered a regular expression.\n Everything else is considered a Cucumber expression.\n", "original_string": "@API(status = API.Status.STABLE)\npublic final class ExpressionFactory {\n\n    private static final Pattern PARAMETER_PATTERN = Pattern.compile(\"((?:\\\\\\\\){0,2})\\\\{([^}]*)\\\\}\");\n\n    private final ParameterTypeRegistry parameterTypeRegistry;\n\n    public ExpressionFactory(ParameterTypeRegistry parameterTypeRegistry) {\n        this.parameterTypeRegistry = parameterTypeRegistry;\n    }\n\n    public Expression createExpression(String expressionString) {\n        /* This method is called often (typically about number_of_steps x\n         * nbr_test_scenarios), thus performance is more important than\n         * readability here.\n         * Consequently, we check the first and last expressionString\n         * characters to determine whether we need to create a\n         * RegularExpression or a CucumberExpression (because character\n         * matching is faster than startsWith/endsWith and regexp matching).\n         */\n        int length = expressionString.length();\n        if (length == 0) {\n            return new CucumberExpression(expressionString, this.parameterTypeRegistry);\n        }\n\n        int lastCharIndex = length - 1;\n        char firstChar = expressionString.charAt(0);\n        char lastChar = expressionString.charAt(lastCharIndex);\n\n        if (firstChar == '^' || lastChar == '$') {\n            return this.createRegularExpressionWithAnchors(expressionString);\n        } else if (firstChar == '/' && lastChar == '/') {\n            return new RegularExpression(Pattern.compile(expressionString.substring(1, lastCharIndex)), this.parameterTypeRegistry);\n        }\n\n        return new CucumberExpression(expressionString, this.parameterTypeRegistry);\n    }\n\n    private RegularExpression createRegularExpressionWithAnchors(String expressionString) {\n        try {\n            return new RegularExpression(Pattern.compile(expressionString), parameterTypeRegistry);\n        } catch (PatternSyntaxException e) {\n            if (PARAMETER_PATTERN.matcher(expressionString).find()) {\n                throw new CucumberExpressionException(\"You cannot use anchors (^ or $) in Cucumber Expressions. Please remove them from \" + expressionString, e);\n            }\n            throw e;\n        }\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Pattern PARAMETER_PATTERN = Pattern.compile(\"((?:\\\\\\\\){0,2})\\\\{([^}]*)\\\\}\");", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Pattern", "name": "PARAMETER_PATTERN = Pattern.compile(\"((?:\\\\\\\\){0,2})\\\\{([^}]*)\\\\}\")", "syntax_pass": true}, {"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/DefaultPatternCompiler.java.DefaultPatternCompiler", "name": "DefaultPatternCompiler", "file_path": "src/main/java/io/cucumber/cucumberexpressions/DefaultPatternCompiler.java", "superclasses": "", "methods": ["[Pattern]compile(String,int)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/DefaultPatternCompiler.java.DefaultPatternCompiler.[Pattern]compile(String,int)"], "overrides": null, "attributes": [], "class_docstring": "\nDefault {@link PatternCompiler}\n", "original_string": "final class DefaultPatternCompiler implements PatternCompiler {\n\n    @Override\n    public Pattern compile(String regexp, int flags) {\n        return Pattern.compile(regexp, flags);\n    }\n}", "super_interfaces": ["PatternCompiler"], "fields": []}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression", "name": "CucumberExpression", "file_path": "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java", "superclasses": "", "methods": ["[]CucumberExpression(String,ParameterTypeRegistry)", "[String]rewriteToRegex(Node)", "[String]rewriteOptional(Node)", "[String]rewriteAlternation(Node)", "[String]rewriteAlternative(Node)", "[String]rewriteParameter(Node)", "[String]rewriteExpression(Node)", "[void]assertNotEmpty(Node,Function<Node, CucumberExpressionException>)", "[void]assertNoParameters(Node,Function<Node, CucumberExpressionException>)", "[void]assertNoOptionals(Node,Function<Node, CucumberExpressionException>)", "[void]assertNoNodeOfType(Node.Type,Node,Function<Node, CucumberExpressionException>)", "[List<Argument<?>>]match(String)", "[String]getSource()", "[Pattern]getRegexp()"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[]CucumberExpression(String,ParameterTypeRegistry)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[String]rewriteToRegex(Node)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[String]rewriteOptional(Node)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[String]rewriteAlternation(Node)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[String]rewriteAlternative(Node)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[String]rewriteParameter(Node)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[String]rewriteExpression(Node)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[void]assertNotEmpty(Node,Function<Node, CucumberExpressionException>)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[void]assertNoParameters(Node,Function<Node, CucumberExpressionException>)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[void]assertNoOptionals(Node,Function<Node, CucumberExpressionException>)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[void]assertNoNodeOfType(Node.Type,Node,Function<Node, CucumberExpressionException>)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[List<Argument<?>>]match(String)", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[String]getSource()", "src/main/java/io/cucumber/cucumberexpressions/CucumberExpression.java.CucumberExpression.[Pattern]getRegexp()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@API(status = API.Status.STABLE)\npublic final class CucumberExpression implements Expression {\n    private final List<ParameterType<?>> parameterTypes = new ArrayList<>();\n    private final String source;\n    private final TreeRegexp treeRegexp;\n    private final ParameterTypeRegistry parameterTypeRegistry;\n\n    CucumberExpression(String expression, ParameterTypeRegistry parameterTypeRegistry) {\n        this.source = expression;\n        this.parameterTypeRegistry = parameterTypeRegistry;\n\n        CucumberExpressionParser parser = new CucumberExpressionParser();\n        Node ast = parser.parse(expression);\n        String pattern = rewriteToRegex(ast);\n        treeRegexp = new TreeRegexp(pattern);\n    }\n\n    private String rewriteToRegex(Node node) {\n        switch (node.type()) {\n            case TEXT_NODE:\n                return escapeRegex(node.text());\n            case OPTIONAL_NODE:\n                return rewriteOptional(node);\n            case ALTERNATION_NODE:\n                return rewriteAlternation(node);\n            case ALTERNATIVE_NODE:\n                return rewriteAlternative(node);\n            case PARAMETER_NODE:\n                return rewriteParameter(node);\n            case EXPRESSION_NODE:\n                return rewriteExpression(node);\n            default:\n                // Can't happen as long as the switch case is exhaustive\n                throw new IllegalArgumentException(node.type().name());\n        }\n    }\n\n    private String rewriteOptional(Node node) {\n        assertNoParameters(node, astNode -> createParameterIsNotAllowedInOptional(astNode, source));\n        assertNoOptionals(node, astNode -> createOptionalIsNotAllowedInOptional(astNode, source));\n        assertNotEmpty(node, astNode -> createOptionalMayNotBeEmpty(astNode, source));\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"\", \"(?:\", \")?\"));\n    }\n\n    private String rewriteAlternation(Node node) {\n        // Make sure the alternative parts aren't empty and don't contain parameter types\n        for (Node alternative : node.nodes()) {\n            if (alternative.nodes().isEmpty()) {\n                throw createAlternativeMayNotBeEmpty(alternative, source);\n            }\n            assertNotEmpty(alternative, astNode -> createAlternativeMayNotExclusivelyContainOptionals(astNode, source));\n        }\n        return node.nodes()\n                .stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"|\", \"(?:\", \")\"));\n    }\n\n    private String rewriteAlternative(Node node) {\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining());\n    }\n\n    private String rewriteParameter(Node node) {\n        String name = node.text();\n        ParameterType<?> parameterType = parameterTypeRegistry.lookupByTypeName(name);\n        if (parameterType == null) {\n            throw createUndefinedParameterType(node, source, name);\n        }\n        parameterTypes.add(parameterType);\n        List<String> regexps = parameterType.getRegexps();\n        if (regexps.size() == 1) {\n            return \"(\" + regexps.get(0) + \")\";\n        }\n        return regexps.stream()\n                .collect(joining(\")|(?:\", \"((?:\", \"))\"));\n    }\n\n\n    private String rewriteExpression(Node node) {\n        return node.nodes().stream()\n                .map(this::rewriteToRegex)\n                .collect(joining(\"\", \"^\", \"$\"));\n    }\n\n    private void assertNotEmpty(Node node,\n            Function<Node, CucumberExpressionException> createNodeWasNotEmptyException) {\n        node.nodes()\n                .stream()\n                .filter(astNode -> TEXT_NODE.equals(astNode.type()))\n                .findFirst()\n                .orElseThrow(() -> createNodeWasNotEmptyException.apply(node));\n    }\n\n    private void assertNoParameters(Node node,\n            Function<Node, CucumberExpressionException> createNodeContainedAParameterException) {\n        assertNoNodeOfType(PARAMETER_NODE, node, createNodeContainedAParameterException);\n    }\n\n    private void assertNoOptionals(Node node,\n            Function<Node, CucumberExpressionException> createNodeContainedAnOptionalException) {\n        assertNoNodeOfType(OPTIONAL_NODE, node, createNodeContainedAnOptionalException);\n    }\n\n    private void assertNoNodeOfType(Node.Type nodeType, Node node,\n            Function<Node, CucumberExpressionException> createException) {\n        node.nodes()\n                .stream()\n                .filter(astNode -> nodeType.equals(astNode.type()))\n                .map(createException)\n                .findFirst()\n                .ifPresent(exception -> {\n                    throw exception;\n                });\n    }\n\n\n    @Override\n    public List<Argument<?>> match(String text, Type... typeHints) {\n        final Group group = treeRegexp.match(text);\n        if (group == null) {\n            return null;\n        }\n\n        List<ParameterType<?>> parameterTypes = new ArrayList<>(this.parameterTypes);\n        for (int i = 0; i < parameterTypes.size(); i++) {\n            ParameterType<?> parameterType = parameterTypes.get(i);\n            Type type = i < typeHints.length ? typeHints[i] : String.class;\n            if (parameterType.isAnonymous()) {\n                ParameterByTypeTransformer defaultTransformer = parameterTypeRegistry.getDefaultParameterTransformer();\n                parameterTypes.set(i, parameterType.deAnonymize(type, arg -> defaultTransformer.transform(arg, type)));\n            }\n        }\n\n        return Argument.build(group, parameterTypes);\n    }\n\n    @Override\n    public String getSource() {\n        return source;\n    }\n\n    @Override\n    public Pattern getRegexp() {\n        return treeRegexp.pattern();\n    }\n\n}", "super_interfaces": ["Expression"], "fields": [{"attribute_expression": "private final List<ParameterType<?>> parameterTypes = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<ParameterType<?>>", "name": "parameterTypes = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private final String source;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "source", "syntax_pass": true}, {"attribute_expression": "private final TreeRegexp treeRegexp;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "TreeRegexp", "name": "treeRegexp", "syntax_pass": true}, {"attribute_expression": "private final ParameterTypeRegistry parameterTypeRegistry;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "ParameterTypeRegistry", "name": "parameterTypeRegistry", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder", "name": "GroupBuilder", "file_path": "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java", "superclasses": "", "methods": ["[]GroupBuilder(int)", "[void]add(GroupBuilder)", "[Group]build(Matcher,Iterator<Integer>)", "[void]setNonCapturing()", "[boolean]isCapturing()", "[void]moveChildrenTo(GroupBuilder)", "[List<GroupBuilder>]getChildren()", "[String]getSource()", "[void]setSource(String)", "[int]getStartIndex()", "[int]getEndIndex()", "[void]setEndIndex(int)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[]GroupBuilder(int)", "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[void]add(GroupBuilder)", "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[Group]build(Matcher,Iterator<Integer>)", "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[void]setNonCapturing()", "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[boolean]isCapturing()", "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[void]moveChildrenTo(GroupBuilder)", "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[List<GroupBuilder>]getChildren()", "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[String]getSource()", "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[void]setSource(String)", "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[int]getStartIndex()", "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[int]getEndIndex()", "src/main/java/io/cucumber/cucumberexpressions/GroupBuilder.java.GroupBuilder.[void]setEndIndex(int)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class GroupBuilder {\n    private final List<GroupBuilder> groupBuilders = new ArrayList<>();\n    private boolean capturing = true;\n    private String source;\n    private int startIndex;\n    private int endIndex;\n\n    GroupBuilder(int startIndex) {\n        this.startIndex = startIndex;\n    }\n\n    void add(GroupBuilder groupBuilder) {\n        groupBuilders.add(groupBuilder);\n    }\n\n    Group build(Matcher matcher, Iterator<Integer> groupIndices) {\n        int groupIndex = groupIndices.next();\n        List<Group> children = new ArrayList<>(groupBuilders.size());\n        for (GroupBuilder childGroupBuilder : groupBuilders) {\n            children.add(childGroupBuilder.build(matcher, groupIndices));\n        }\n        return new Group(matcher.group(groupIndex), matcher.start(groupIndex), matcher.end(groupIndex), children);\n    }\n\n    void setNonCapturing() {\n        this.capturing = false;\n    }\n\n    boolean isCapturing() {\n        return capturing;\n    }\n\n    void moveChildrenTo(GroupBuilder groupBuilder) {\n        for (GroupBuilder child : groupBuilders) {\n            groupBuilder.add(child);\n        }\n    }\n\n    List<GroupBuilder> getChildren() {\n        return groupBuilders;\n    }\n\n    String getSource() {\n        return source;\n    }\n\n    void setSource(String source) {\n        this.source = source;\n    }\n\n    int getStartIndex() {\n        return startIndex;\n    }\n\n    int getEndIndex() {\n        return endIndex;\n    }\n\n    void setEndIndex(int endIndex) {\n        this.endIndex = endIndex;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private final List<GroupBuilder> groupBuilders = new ArrayList<>();", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<GroupBuilder>", "name": "groupBuilders = new ArrayList<>()", "syntax_pass": true}, {"attribute_expression": "private boolean capturing = true;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "boolean", "name": "capturing = true", "syntax_pass": true}, {"attribute_expression": "private String source;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "String", "name": "source", "syntax_pass": true}, {"attribute_expression": "private int startIndex;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "startIndex", "syntax_pass": true}, {"attribute_expression": "private int endIndex;", "docstring": "", "modifiers": "private", "marker_annotations": [], "non_marker_annotations": ["private"], "comments": [], "type": "int", "name": "endIndex", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java.PatternCompilerProvider", "name": "PatternCompilerProvider", "file_path": "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java", "superclasses": "", "methods": ["[]PatternCompilerProvider()", "[PatternCompiler]getCompiler()", "[void]findPatternCompiler(Iterator<PatternCompiler>)", "[void]throwMoreThanOneCompilerException(Iterator<PatternCompiler>)"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java.PatternCompilerProvider.[]PatternCompilerProvider()", "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java.PatternCompilerProvider.[PatternCompiler]getCompiler()", "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java.PatternCompilerProvider.[void]findPatternCompiler(Iterator<PatternCompiler>)", "src/main/java/io/cucumber/cucumberexpressions/PatternCompilerProvider.java.PatternCompilerProvider.[void]throwMoreThanOneCompilerException(Iterator<PatternCompiler>)"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "final class PatternCompilerProvider {\n    // visible from tests\n    static PatternCompiler service;\n\n    private PatternCompilerProvider() {\n    }\n\n    static synchronized PatternCompiler getCompiler() {\n        if (service == null) {\n            ServiceLoader<PatternCompiler> loader = ServiceLoader.load(PatternCompiler.class);\n            Iterator<PatternCompiler> iterator = loader.iterator();\n            findPatternCompiler(iterator);\n        }\n        return service;\n    }\n\n    static void findPatternCompiler(Iterator<PatternCompiler> iterator) {\n        if (iterator.hasNext()) {\n            service = iterator.next();\n            if (iterator.hasNext()) {\n                throwMoreThanOneCompilerException(iterator);\n            }\n        } else {\n            service = new DefaultPatternCompiler();\n        }\n    }\n\n    private static void throwMoreThanOneCompilerException(Iterator<PatternCompiler> iterator) {\n        List<Class<? extends PatternCompiler>> allCompilers = new ArrayList<>();\n        allCompilers.add(service.getClass());\n        while (iterator.hasNext()) {\n            allCompilers.add(iterator.next().getClass());\n        }\n        throw new IllegalStateException(\"More than one PatternCompiler: \" + allCompilers);\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "static PatternCompiler service;", "docstring": " visible from tests", "modifiers": "static", "marker_annotations": [], "non_marker_annotations": ["static"], "comments": [], "type": "PatternCompiler", "name": "service", "syntax_pass": true}]}, {"uris": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression", "name": "GeneratedExpression", "file_path": "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java", "superclasses": "", "methods": ["[]GeneratedExpression(String,List<ParameterType<?>>)", "[boolean]isJavaKeyword(String)", "[String]getSource()", "[String]getParameterName(String,Map<String, Integer>)", "[List<String>]getParameterNames()", "[List<ParameterType<?>>]getParameterTypes()"], "method_uris": ["src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression.[]GeneratedExpression(String,List<ParameterType<?>>)", "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression.[boolean]isJavaKeyword(String)", "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression.[String]getSource()", "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression.[String]getParameterName(String,Map<String, Integer>)", "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression.[List<String>]getParameterNames()", "src/main/java/io/cucumber/cucumberexpressions/GeneratedExpression.java.GeneratedExpression.[List<ParameterType<?>>]getParameterTypes()"], "overrides": null, "attributes": [], "class_docstring": "", "original_string": "@API(status = API.Status.STABLE)\npublic class GeneratedExpression {\n    private static final Collator ENGLISH_COLLATOR = Collator.getInstance(Locale.ENGLISH);\n    private static final String[] JAVA_KEYWORDS = {\n            \"abstract\", \"assert\", \"boolean\", \"break\", \"byte\", \"case\",\n            \"catch\", \"char\", \"class\", \"const\", \"continue\",\n            \"default\", \"do\", \"double\", \"else\", \"extends\",\n            \"false\", \"final\", \"finally\", \"float\", \"for\",\n            \"goto\", \"if\", \"implements\", \"import\", \"instanceof\",\n            \"int\", \"interface\", \"long\", \"native\", \"new\",\n            \"null\", \"package\", \"private\", \"protected\", \"public\",\n            \"return\", \"short\", \"static\", \"strictfp\", \"super\",\n            \"switch\", \"synchronized\", \"this\", \"throw\", \"throws\",\n            \"transient\", \"true\", \"try\", \"void\", \"volatile\",\n            \"while\"\n    };\n    private final String expressionTemplate;\n    private final List<ParameterType<?>> parameterTypes;\n\n    GeneratedExpression(String expressionTemplate, List<ParameterType<?>> parameterTypes) {\n        this.expressionTemplate = expressionTemplate;\n        this.parameterTypes = parameterTypes;\n    }\n\n    private static boolean isJavaKeyword(String keyword) {\n        return (Arrays.binarySearch(JAVA_KEYWORDS, keyword, ENGLISH_COLLATOR) >= 0);\n    }\n\n    public String getSource() {\n        List<String> parameterTypeNames = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            String name = parameterType.getName();\n            parameterTypeNames.add(name);\n        }\n        return String.format(expressionTemplate, parameterTypeNames.toArray());\n    }\n\n    private String getParameterName(String typeName, Map<String, Integer> usageByTypeName) {\n        Integer count = usageByTypeName.get(typeName);\n        count = count != null ? count + 1 : 1;\n        usageByTypeName.put(typeName, count);\n\n        return count == 1 && !isJavaKeyword(typeName) ? typeName : typeName + count;\n    }\n\n    public List<String> getParameterNames() {\n        HashMap<String, Integer> usageByTypeName = new HashMap<>();\n        List<String> list = new ArrayList<>();\n        for (ParameterType<?> parameterType : parameterTypes) {\n            String parameterName = getParameterName(parameterType.getName(), usageByTypeName);\n            list.add(parameterName);\n        }\n        return list;\n    }\n\n    public List<ParameterType<?>> getParameterTypes() {\n        return parameterTypes;\n    }\n}", "super_interfaces": [], "fields": [{"attribute_expression": "private static final Collator ENGLISH_COLLATOR = Collator.getInstance(Locale.ENGLISH);", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "Collator", "name": "ENGLISH_COLLATOR = Collator.getInstance(Locale.ENGLISH)", "syntax_pass": true}, {"attribute_expression": "private static final String[] JAVA_KEYWORDS = {\n            \"abstract\", \"assert\", \"boolean\", \"break\", \"byte\", \"case\",\n            \"catch\", \"char\", \"class\", \"const\", \"continue\",\n            \"default\", \"do\", \"double\", \"else\", \"extends\",\n            \"false\", \"final\", \"finally\", \"float\", \"for\",\n            \"goto\", \"if\", \"implements\", \"import\", \"instanceof\",\n            \"int\", \"interface\", \"long\", \"native\", \"new\",\n            \"null\", \"package\", \"private\", \"protected\", \"public\",\n            \"return\", \"short\", \"static\", \"strictfp\", \"super\",\n            \"switch\", \"synchronized\", \"this\", \"throw\", \"throws\",\n            \"transient\", \"true\", \"try\", \"void\", \"volatile\",\n            \"while\"\n    };", "docstring": "", "modifiers": "private static final", "marker_annotations": [], "non_marker_annotations": ["private", "static", "final"], "comments": [], "type": "String[]", "name": "JAVA_KEYWORDS = {\n            \"abstract\", \"assert\", \"boolean\", \"break\", \"byte\", \"case\",\n            \"catch\", \"char\", \"class\", \"const\", \"continue\",\n            \"default\", \"do\", \"double\", \"else\", \"extends\",\n            \"false\", \"final\", \"finally\", \"float\", \"for\",\n            \"goto\", \"if\", \"implements\", \"import\", \"instanceof\",\n            \"int\", \"interface\", \"long\", \"native\", \"new\",\n            \"null\", \"package\", \"private\", \"protected\", \"public\",\n            \"return\", \"short\", \"static\", \"strictfp\", \"super\",\n            \"switch\", \"synchronized\", \"this\", \"throw\", \"throws\",\n            \"transient\", \"true\", \"try\", \"void\", \"volatile\",\n            \"while\"\n    }", "syntax_pass": true}, {"attribute_expression": "private final String expressionTemplate;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "String", "name": "expressionTemplate", "syntax_pass": true}, {"attribute_expression": "private final List<ParameterType<?>> parameterTypes;", "docstring": "", "modifiers": "private final", "marker_annotations": [], "non_marker_annotations": ["private", "final"], "comments": [], "type": "List<ParameterType<?>>", "name": "parameterTypes", "syntax_pass": true}]}]